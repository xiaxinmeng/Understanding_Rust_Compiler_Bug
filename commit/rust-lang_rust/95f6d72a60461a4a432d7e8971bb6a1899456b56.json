{"sha": "95f6d72a60461a4a432d7e8971bb6a1899456b56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZjZkNzJhNjA0NjFhNGE0MzJkN2U4OTcxYmI2YTE4OTk0NTZiNTY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T13:39:48Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:21:09Z"}, "message": "Rename `Expr.node` to `Expr.kind`\n\nFor both `ast::Expr` and `hir::Expr`.", "tree": {"sha": "df668b1056098eb4f00c2426136aecb3c51f1936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df668b1056098eb4f00c2426136aecb3c51f1936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95f6d72a60461a4a432d7e8971bb6a1899456b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95f6d72a60461a4a432d7e8971bb6a1899456b56", "html_url": "https://github.com/rust-lang/rust/commit/95f6d72a60461a4a432d7e8971bb6a1899456b56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95f6d72a60461a4a432d7e8971bb6a1899456b56/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf43867a9cbb3766b48552632a602498fae2699", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf43867a9cbb3766b48552632a602498fae2699", "html_url": "https://github.com/rust-lang/rust/commit/ddf43867a9cbb3766b48552632a602498fae2699"}], "stats": {"total": 571, "additions": 281, "deletions": 290}, "files": [{"sha": "987745722d6d8242bda938b80fbc5d509eaafecb", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -280,7 +280,7 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     fn check_expr_attributes(&self, expr: &hir::Expr) {\n-        let target = match expr.node {\n+        let target = match expr.kind {\n             hir::ExprKind::Closure(..) => Target::Closure,\n             _ => Target::Expression,\n         };"}, {"sha": "083bc00b34b8f43806d20b5cd6a4003dcd1a80f4", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -992,7 +992,7 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_id(expression.hir_id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n-    match expression.node {\n+    match expression.kind {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }"}, {"sha": "b951614511d2e29165ced153be403deb6843e308", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -3378,7 +3378,7 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n         }\n     };\n \n-    match expr.node {\n+    match expr.kind {\n         // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n         ExprKind::Struct(ref qpath, _, _) => {\n             if let QPath::Resolved(None, ref path) = **qpath {\n@@ -3393,7 +3393,7 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n \n         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n         ExprKind::Call(ref func, _) => {\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n                 if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n                     let new_call = segment.ident.as_str() == \"new\";\n                     return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;"}, {"sha": "ba6164b2a110a3e15560b4c3f6c942062d073a2c", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -17,7 +17,7 @@ impl LoweringContext<'_> {\n     }\n \n     pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n-        let kind = match e.node {\n+        let kind = match e.kind {\n             ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n             ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n             ExprKind::Repeat(ref expr, ref count) => {\n@@ -184,7 +184,7 @@ impl LoweringContext<'_> {\n \n         hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n-            node: kind,\n+            kind,\n             span: e.span,\n             attrs: e.attrs.clone(),\n         }\n@@ -282,7 +282,7 @@ impl LoweringContext<'_> {\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n-        let (then_pat, scrutinee, desugar) = match cond.node {\n+        let (then_pat, scrutinee, desugar) = match cond.kind {\n             // `<pat> => <then>`:\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n@@ -332,7 +332,7 @@ impl LoweringContext<'_> {\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(body);\n-        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+        let (then_pat, scrutinee, desugar, source) = match cond.kind {\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n@@ -459,7 +459,7 @@ impl LoweringContext<'_> {\n         });\n \n         // `static || -> <ret_ty> { body }`:\n-        let generator_node = hir::ExprKind::Closure(\n+        let generator_kind = hir::ExprKind::Closure(\n             capture_clause,\n             decl,\n             body_id,\n@@ -468,7 +468,7 @@ impl LoweringContext<'_> {\n         );\n         let generator = hir::Expr {\n             hir_id: self.lower_node_id(closure_node_id),\n-            node: generator_node,\n+            kind: generator_kind,\n             span,\n             attrs: ThinVec::new(),\n         };\n@@ -625,7 +625,7 @@ impl LoweringContext<'_> {\n         // loop { .. }\n         let loop_expr = P(hir::Expr {\n             hir_id: loop_hir_id,\n-            node: hir::ExprKind::Loop(\n+            kind: hir::ExprKind::Loop(\n                 loop_block,\n                 None,\n                 hir::LoopSource::Loop,\n@@ -1135,14 +1135,14 @@ impl LoweringContext<'_> {\n         ));\n \n         // `[opt_ident]: loop { ... }`\n-        let loop_expr = hir::ExprKind::Loop(\n+        let kind = hir::ExprKind::Loop(\n             loop_block,\n             self.lower_label(opt_label),\n             hir::LoopSource::ForLoop,\n         );\n         let loop_expr = P(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n-            node: loop_expr,\n+            kind,\n             span: e.span,\n             attrs: ThinVec::new(),\n         });\n@@ -1443,15 +1443,10 @@ impl LoweringContext<'_> {\n     pub(super) fn expr(\n         &mut self,\n         span: Span,\n-        node: hir::ExprKind,\n+        kind: hir::ExprKind,\n         attrs: ThinVec<Attribute>\n     ) -> hir::Expr {\n-        hir::Expr {\n-            hir_id: self.next_id(),\n-            node,\n-            span,\n-            attrs,\n-        }\n+        hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n \n     fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {"}, {"sha": "c7e70d93041fd625cf03268ebf468507f31652ad", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -58,7 +58,7 @@ impl MaybeFnLike for ast::TraitItem {\n \n impl MaybeFnLike for ast::Expr {\n     fn is_fn_like(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             ast::ExprKind::Closure(..) => true,\n             _ => false,\n         }\n@@ -241,7 +241,7 @@ impl<'a> FnLikeNode<'a> {\n                     _ => bug!(\"impl method FnLikeNode that is not fn-like\")\n                 }\n             },\n-            map::Node::Expr(e) => match e.node {\n+            map::Node::Expr(e) => match e.kind {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),"}, {"sha": "42a76a721a33e0c476dbed00c2f80ab3de628e85", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -271,7 +271,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        let parent_def = match expr.node {\n+        let parent_def = match expr.kind {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n             ExprKind::Closure(_, asyncness, ..) => {\n                 // Async closures desugar to closures inside of closures, so\n@@ -312,7 +312,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_token(&mut self, t: Token) {\n         if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n-                if let ExprKind::Mac(..) = expr.node {\n+                if let ExprKind::Mac(..) = expr.kind {\n                     self.visit_macro_invoc(expr.id);\n                 }\n             }"}, {"sha": "f4ac39921113c048dccc1e341cd7072c9c7416e9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -71,7 +71,7 @@ impl<'hir> Entry<'hir> {\n             }\n \n             Node::Expr(ref expr) => {\n-                match expr.node {\n+                match expr.kind {\n                     ExprKind::Closure(_, ref fn_decl, ..) => Some(fn_decl),\n                     _ => None,\n                 }\n@@ -111,7 +111,7 @@ impl<'hir> Entry<'hir> {\n             Node::AnonConst(constant) => Some(constant.body),\n \n             Node::Expr(expr) => {\n-                match expr.node {\n+                match expr.kind {\n                     ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n                 }\n@@ -468,7 +468,7 @@ impl<'hir> Map<'hir> {\n             Node::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n-            Node::Expr(&Expr { node: ExprKind::Closure(..), .. }) => {\n+            Node::Expr(&Expr { kind: ExprKind::Closure(..), .. }) => {\n                 BodyOwnerKind::Closure\n             }\n             node => bug!(\"{:#?} is not a body node\", node),\n@@ -634,7 +634,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::TraitItem(_)) |\n             Some(Node::ImplItem(_)) => true,\n             Some(Node::Expr(e)) => {\n-                match e.node {\n+                match e.kind {\n                     ExprKind::Closure(..) => true,\n                     _ => false,\n                 }\n@@ -749,15 +749,15 @@ impl<'hir> Map<'hir> {\n                 Node::Item(_) |\n                 Node::ForeignItem(_) |\n                 Node::TraitItem(_) |\n-                Node::Expr(Expr { node: ExprKind::Closure(..), ..}) |\n+                Node::Expr(Expr { kind: ExprKind::Closure(..), ..}) |\n                 Node::ImplItem(_) => true,\n                 _ => false,\n             }\n         };\n         let match_non_returning_block = |node: &Node<'_>| {\n             match *node {\n                 Node::Expr(ref expr) => {\n-                    match expr.node {\n+                    match expr.kind {\n                         ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n                         _ => false,\n                     }"}, {"sha": "2657dbfd7adfa215b537cb95a667d91c10a57e10", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1434,7 +1434,7 @@ pub struct AnonConst {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub hir_id: HirId,\n-    pub node: ExprKind,\n+    pub kind: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n     pub span: Span,\n }\n@@ -1445,7 +1445,7 @@ static_assert_size!(Expr, 72);\n \n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n-        match self.node {\n+        match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n@@ -1478,7 +1478,7 @@ impl Expr {\n     }\n \n     pub fn is_place_expr(&self) -> bool {\n-         match self.node {\n+         match self.kind {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n                 match path.res {\n                     Res::Local(..)"}, {"sha": "d5140141d7e80adb7f3ea23fd8b2f072c8a17f1a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1035,7 +1035,7 @@ impl<'a> State<'a> {\n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n     pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) {\n-        let needs_par = match expr.node {\n+        let needs_par = match expr.kind {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n             hir::ExprKind::Closure(..) |\n@@ -1119,11 +1119,10 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) {\n-        let prec =\n-            match func.node {\n-                hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n-                _ => parser::PREC_POSTFIX,\n-            };\n+        let prec = match func.kind {\n+            hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n+            _ => parser::PREC_POSTFIX,\n+        };\n \n         self.print_expr_maybe_paren(func, prec);\n         self.print_call_post(args)\n@@ -1161,7 +1160,7 @@ impl<'a> State<'a> {\n             Fixity::None => (prec + 1, prec + 1),\n         };\n \n-        let left_prec = match (&lhs.node, op.node) {\n+        let left_prec = match (&lhs.kind, op.node) {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n@@ -1200,7 +1199,7 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&expr.attrs);\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n@@ -1803,7 +1802,7 @@ impl<'a> State<'a> {\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.node {\n+        match arm.body.kind {\n             hir::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n@@ -2222,7 +2221,7 @@ impl<'a> State<'a> {\n //\n // Duplicated from `parse::classify`, but adapted for the HIR.\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n-    match e.node {\n+    match e.kind {\n         hir::ExprKind::Match(..) |\n         hir::ExprKind::Block(..) |\n         hir::ExprKind::Loop(..) => false,\n@@ -2273,7 +2272,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n-    match value.node {\n+    match value.kind {\n         hir::ExprKind::Struct(..) => true,\n \n         hir::ExprKind::Assign(ref lhs, ref rhs) |"}, {"sha": "3442881e0f4f6c9b86df3180e6b154f204168541", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -82,7 +82,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Closure(..) = expr.node {\n+        if let hir::ExprKind::Closure(..) = expr.kind {\n             let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n                 // Every capture of a closure expression is a local in scope,"}, {"sha": "7f83fe95c130838150ad94b457bcfcadeb379cac", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -173,12 +173,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n             let hir::Expr {\n                 hir_id: _,\n                 ref span,\n-                ref node,\n+                ref kind,\n                 ref attrs\n             } = *self;\n \n             span.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "13de626b996980a3e499d5aa1a21caa82ce2bc9b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir().find(scope.hir_id(region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n-                    Some(Node::Expr(expr)) => match expr.node {\n+                    Some(Node::Expr(expr)) => match expr.kind {\n                         hir::ExprKind::Call(..) => \"call\",\n                         hir::ExprKind::MethodCall(..) => \"method call\",\n                         hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n                         let discrim_expr = self.tcx.hir().expect_expr(discrim_hir_id);\n-                        let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.node {\n+                        let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n                             self.in_progress_tables.and_then(|tables| {\n                                 tables.borrow().expr_ty_opt(arg_expr)"}, {"sha": "1df60dfc63ef367e6a8d0c034d13c221ace3a35f", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -92,10 +92,10 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n-            &expr.node,\n+            &expr.kind,\n             self.node_matches_type(expr.hir_id),\n         ) {\n-            self.found_closure = Some(&expr.node);\n+            self.found_closure = Some(&expr.kind);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -114,7 +114,7 @@ fn closure_return_type_suggestion(\n         FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n         _ => (\"\", \"\"),\n     };\n-    let suggestion = match body.value.node {\n+    let suggestion = match body.value.kind {\n         ExprKind::Block(..) => {\n             vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n         }"}, {"sha": "9231e4f779eb768ab5a1a351ac46b149840b7c70", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let hir = &self.tcx().hir();\n                 if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n-                        node: Closure(_, _, _, closure_span, None),\n+                        kind: Closure(_, _, _, closure_span, None),\n                         ..\n                     }) = hir.get(hir_id) {\n                         let sup_sp = sup_origin.span();"}, {"sha": "b31b25d6beed8aecf356d8f8d4ec17a6297d84e3", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -236,7 +236,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);"}, {"sha": "a30b1214a22126409eea86d06106a512d25727d6", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n         self.walk_adjustment(expr);\n \n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(_) => { }\n \n             hir::ExprKind::Type(ref subexpr, _) => {"}, {"sha": "ecca62349c985d96303b8b217cbccbf45818ed6f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -150,7 +150,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let res = if let hir::ExprKind::Path(ref qpath) = expr.node {\n+        let res = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n             self.tables.qpath_res(qpath, expr.hir_id)\n         } else {\n             Res::Err"}, {"sha": "6b539ec544d40117e8d44c3794a2accc8c2100b9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -456,7 +456,7 @@ fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n }\n \n fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n-    match expr.node {\n+    match expr.kind {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n         debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n-        match expr.node {\n+        match expr.kind {\n             // Interesting cases with control flow or which gen/kill\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // these errors are detected in the later pass borrowck.  We\n         // just ignore such cases and treat them as reads.\n \n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(_) => succ,\n             hir::ExprKind::Field(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // see comment on propagate_through_place()\n     fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32) -> LiveNode {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 self.access_path(expr.hir_id, path, succ, acc)\n             }\n@@ -1377,7 +1377,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n }\n \n fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n-    match expr.node {\n+    match expr.kind {\n         hir::ExprKind::Assign(ref l, _) => {\n             this.check_place(&l);\n         }\n@@ -1420,7 +1420,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n \n impl<'tcx> Liveness<'_, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n                     let upvars = self.ir.tcx.upvars(self.ir.body_owner);"}, {"sha": "fe28c6d21fc24916ecf9975975f74d0a5443ef59", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -577,7 +577,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n                 if self.tables.is_method_call(expr) {\n                     self.cat_overloaded_place(expr, e_base, NoteNone)"}, {"sha": "57119a5e236608214d1f3da4f2001038b8fc1af8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let res = match expr.node {\n+        let res = match expr.kind {\n             hir::ExprKind::Path(ref qpath) => {\n                 Some(self.tables.qpath_res(qpath, expr.hir_id))\n             }\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::TyAlias(_) => {}\n                 }\n             }\n-            Node::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n+            Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these"}, {"sha": "63e925346d7e98fc286a810b0176e92e78fd6ec2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -893,7 +893,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n         let mut terminating = |id: hir::ItemLocalId| {\n             terminating_scopes.insert(id);\n         };\n-        match expr.node {\n+        match expr.kind {\n             // Conditional or repeating scopes are always terminating\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n@@ -996,7 +996,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n     // properly, we can't miss any types.\n \n \n-    match expr.node {\n+    match expr.kind {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n         hir::ExprKind::Closure(.., body, _, _) => {\n@@ -1053,7 +1053,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprKind::Yield(_, source) = &expr.node {\n+    if let hir::ExprKind::Yield(_, source) = &expr.kind {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n         loop {\n@@ -1240,7 +1240,7 @@ fn resolve_local<'tcx>(\n         expr: &hir::Expr,\n         blk_id: Option<Scope>,\n     ) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::AddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n@@ -1300,7 +1300,7 @@ fn resolve_local<'tcx>(\n             // outer expression.\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n-            match expr.node {\n+            match expr.kind {\n                 hir::ExprKind::AddrOf(_, ref subexpr) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref subexpr) |\n                 hir::ExprKind::Field(ref subexpr, _) |"}, {"sha": "1054df767d63ab199c354fa681ab8a2033a0e7b8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1214,7 +1214,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n-        if let hir::ExprKind::Loop(_, Some(label), _) = ex.node {\n+        if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind {\n             Some(label.ident)\n         } else {\n             None"}, {"sha": "849eed957a8449044c599c0555022f0685c4b9ff", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -956,7 +956,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let parent_node = self.tcx.hir().get_parent_node(hir_id);\n             if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n                 if let Some(ref expr) = local.init {\n-                    if let hir::ExprKind::Index(_, _) = expr.node {\n+                    if let hir::ExprKind::Index(_, _) = expr.kind {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n                             err.span_suggestion(\n                                 expr.span,\n@@ -1110,7 +1110,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ..\n         })) = node {\n             let body = hir.body(*body_id);\n-            if let hir::ExprKind::Block(blk, _) = &body.value.node {\n+            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n                 if decl.output.span().overlaps(span) && blk.expr.is_none() &&\n                     \"()\" == &trait_ref.self_ty().to_string()\n                 {\n@@ -1134,7 +1134,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n         match node {\n             Node::Expr(&hir::Expr {\n-                node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n                 (self.tcx.sess.source_map().def_span(span),"}, {"sha": "b587250bf7c2d484a29ac60dacfafed39228c739", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -604,7 +604,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n         // Only paths and method calls/overloaded operators have\n         // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprKind::Path(_) = expr.node {\n+        if let hir::ExprKind::Path(_) = expr.kind {\n             return false;\n         }\n "}, {"sha": "dd2aeb4276faacd46ac8dabee260bb6a3703adaa", "filename": "src/librustc_ast_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -177,7 +177,7 @@ pub fn check_loans<'a, 'tcx>(\n     let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir().get(hir_id) {\n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n+            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,\n         _ => false,"}, {"sha": "40e28299a5c0a15eac451b9565c236298d125dc7", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -338,7 +338,7 @@ pub enum LoanPathElem<'tcx> {\n fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n     let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n     match tcx.hir().get(closure_id) {\n-        Node::Expr(expr) => match expr.node {\n+        Node::Expr(expr) => match expr.kind {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.hir_id\n             }"}, {"sha": "48d0699c146af8b47d603f1164b9a1d0c9cb026f", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Block(ref blk, _) => {\n                 let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])"}, {"sha": "12d325d59390aca8963ceabe3f4a7567aabf5c96", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -834,7 +834,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n         fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n             let expr = P(ast::Expr {\n                 id: sess.next_node_id(),\n-                node: ast::ExprKind::Block(P(b), None),\n+                kind: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n             });\n@@ -848,7 +848,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n \n         let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.sess);\n         let loop_expr = P(ast::Expr {\n-            node: ast::ExprKind::Loop(P(empty_block), None),\n+            kind: ast::ExprKind::Loop(P(empty_block), None),\n             id: self.sess.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),"}, {"sha": "875f16241a62f396a95f8b448986601a299ddc0a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -67,16 +67,16 @@ declare_lint_pass!(WhileTrue => [WHILE_TRUE]);\n \n /// Traverse through any amount of parenthesis and return the first non-parens expression.\n fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n-    while let ast::ExprKind::Paren(sub) = &expr.node {\n+    while let ast::ExprKind::Paren(sub) = &expr.kind {\n         expr = sub;\n     }\n     expr\n }\n \n impl EarlyLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::While(cond, ..) = &e.node {\n-            if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).node {\n+        if let ast::ExprKind::While(cond, ..) = &e.kind {\n+            if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n@@ -224,7 +224,7 @@ impl EarlyLintPass for UnsafeCode {\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::Block(ref blk, _) = e.node {\n+        if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n@@ -932,7 +932,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n              -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n-            let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n                 cx.tables.qpath_res(qpath, expr.hir_id)\n             } else {\n                 return None;\n@@ -1900,7 +1900,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         fn is_zero(expr: &hir::Expr) -> bool {\n             use hir::ExprKind::*;\n             use syntax::ast::LitKind::*;\n-            match &expr.node {\n+            match &expr.kind {\n                 Lit(lit) =>\n                     if let Int(i, _) = lit.node {\n                         i == 0\n@@ -1923,8 +1923,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             const TRANSMUTE_PATH: &[Symbol] =\n                 &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n \n-            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n-                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n                     if cx.match_def_path(def_id, ZEROED_PATH) {"}, {"sha": "0bfd4c3afc974dcd858227d8557a683f08aae97c", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -13,7 +13,7 @@ declare_lint_pass!(RedundantSemicolon => [REDUNDANT_SEMICOLON]);\n impl EarlyLintPass for RedundantSemicolon {\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n         if let StmtKind::Semi(expr) = &stmt.node {\n-            if let ExprKind::Tup(ref v) = &expr.node {\n+            if let ExprKind::Tup(ref v) = &expr.kind {\n                 if v.is_empty() {\n                     // Strings of excess semicolons are encoded as empty tuple expressions\n                     // during the parsing stage, so we check for empty tuple expressions"}, {"sha": "eacfe4be9e59b19ea516e1a69d21334911658e15", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -72,7 +72,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n-    if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n+    if let ExprKind::Struct(_, eps, _) = &parent_expr.kind {\n         if eps.len() != 2 {\n             return false;\n         }\n@@ -279,7 +279,7 @@ fn lint_int_literal<'a, 'tcx>(\n \n         let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n-            if let hir::ExprKind::Struct(..) = par_e.node {\n+            if let hir::ExprKind::Struct(..) = par_e.kind {\n                 if is_range_literal(cx.sess(), par_e)\n                     && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n                 {\n@@ -318,7 +318,7 @@ fn lint_uint_literal<'a, 'tcx>(\n     if lit_val < min || lit_val > max {\n         let parent_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n-            match par_e.node {\n+            match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.tables.expr_ty(par_e).kind {\n                         let mut err = cx.struct_span_lint(\n@@ -400,7 +400,7 @@ fn lint_literal<'a, 'tcx>(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.hir_id {\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         l: &hir::Expr,\n                         r: &hir::Expr)\n                         -> bool {\n-            let (lit, expr, swap) = match (&l.node, &r.node) {\n+            let (lit, expr, swap) = match (&l.kind, &r.kind) {\n                 (&hir::ExprKind::Lit(_), _) => (l, r, true),\n                 (_, &hir::ExprKind::Lit(_)) => (r, l, false),\n                 _ => return true,\n@@ -456,7 +456,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             match cx.tables.node_type(expr.hir_id).kind {\n                 ty::Int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i128 = match lit.node {\n+                    let lit_val: i128 = match lit.kind {\n                         hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -470,7 +470,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n                 ty::Uint(uint_ty) => {\n                     let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n-                    let lit_val: u128 = match lit.node {\n+                    let lit_val: u128 = match lit.kind {\n                         hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,"}, {"sha": "cd9cebd6c6fb8c0330a6f9e24657edfbfc1bf3e0", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             _ => return,\n         };\n \n-        if let hir::ExprKind::Ret(..) = expr.node {\n+        if let hir::ExprKind::Ret(..) = expr.kind {\n             return;\n         }\n \n@@ -52,9 +52,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        let maybe_def_id = match expr.node {\n+        let maybe_def_id = match expr.kind {\n             hir::ExprKind::Call(ref callee, _) => {\n-                match callee.node {\n+                match callee.kind {\n                     hir::ExprKind::Path(ref qpath) => {\n                         match cx.tables.qpath_res(qpath, callee.hir_id) {\n                             Res::Def(DefKind::Fn, def_id)\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             return;\n         }\n \n-        let must_use_op = match expr.node {\n+        let must_use_op = match expr.kind {\n             // Hardcoding operators here seemed more expedient than the\n             // refactoring that would be needed to look up the `#[must_use]`\n             // attribute which does exist on the comparison trait methods\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 }\n                 ty::Tuple(ref tys) => {\n                     let mut has_emitted = false;\n-                    let spans = if let hir::ExprKind::Tup(comps) = &expr.node {\n+                    let spans = if let hir::ExprKind::Tup(comps) = &expr.kind {\n                         debug_assert_eq!(comps.len(), tys.len());\n                         comps.iter().map(|e| e.span).collect()\n                     } else {\n@@ -270,7 +270,7 @@ declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n         if let hir::StmtKind::Semi(ref expr) = s.node {\n-            if let hir::ExprKind::Path(_) = expr.node {\n+            if let hir::ExprKind::Path(_) = expr.kind {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }\n@@ -363,7 +363,7 @@ declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n impl UnusedParens {\n \n     fn is_expr_parens_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n-        followed_by_block && match inner.node {\n+        followed_by_block && match inner.kind {\n             ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n             _ => parser::contains_exterior_struct_lit(&inner),\n         }\n@@ -376,7 +376,7 @@ impl UnusedParens {\n                                      followed_by_block: bool,\n                                      left_pos: Option<BytePos>,\n                                      right_pos: Option<BytePos>) {\n-        match value.node {\n+        match value.kind {\n             ast::ExprKind::Paren(ref inner) => {\n                 if !Self::is_expr_parens_necessary(inner, followed_by_block) &&\n                     value.attrs.is_empty() {\n@@ -501,7 +501,7 @@ impl UnusedParens {\n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n-        let (value, msg, followed_by_block, left_pos, right_pos) = match e.node {\n+        let (value, msg, followed_by_block, left_pos, right_pos) = match e.kind {\n             Let(ref pat, ..) => {\n                 self.check_unused_parens_pat(cx, pat, false, false);\n                 return;\n@@ -663,7 +663,7 @@ declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Box(_) => {}\n             _ => return,\n         }"}, {"sha": "c8402018570a53d7d0d0572cb7ed2fb9636e073e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1810,7 +1810,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n                 self.record(def_id, EncodeContext::encode_info_for_closure, def_id);"}, {"sha": "dc7e4b220658851df3c88386e59d1353e5ad381f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -890,7 +890,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             def_id, target_place, places\n         );\n         let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id)?;\n-        let expr = &self.infcx.tcx.hir().expect_expr(hir_id).node;\n+        let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(\n             .., args_span, _"}, {"sha": "811ad6bb46627516d70da6d84d8fe41685b71b86", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -236,7 +236,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n+            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,\n         _ => true,"}, {"sha": "b39378f0cb7fbaa58948f7d815088d9eb06ca73e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -292,7 +292,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(mir_hir_id).node\n+                            tcx.hir().expect_expr(mir_hir_id).kind\n                         {\n                             span\n                         } else {\n@@ -758,7 +758,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n-                node: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n+                kind: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n                 ..\n             }) => (\n                 match return_ty.output {\n@@ -821,7 +821,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n-                node: hir::ExprKind::Closure(_, _, _, span, _),\n+                kind: hir::ExprKind::Closure(_, _, _, span, _),\n                 ..\n             }) => (\n                 tcx.sess.source_map().end_point(*span)"}, {"sha": "0cd32acdb665b8cd608be717e0b2bdc1ebef0280", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     if let ExprKind::Block { body } = expr.kind {\n                         if let Some(tail_expr) = &body.expr {\n                             let mut expr = tail_expr;\n-                            while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.node {\n+                            while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.kind {\n                                 if let Some(subtail_expr) = &subblock.expr {\n                                     expr = subtail_expr\n                                 } else {"}, {"sha": "8b80c9d7d673e6a371b775b6345c4d80b729fa92", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -27,7 +27,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n-        Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n+        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n         | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n         | Node::ImplItem(\n             hir::ImplItem {"}, {"sha": "da1b9ed7693e6650ca9f10dba03ab1b229f5aa5b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -204,7 +204,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n     let expr_ty = cx.tables().expr_ty(expr);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-    let kind = match expr.node {\n+    let kind = match expr.kind {\n         // Here comes the interesting stuff:\n         hir::ExprKind::MethodCall(_, method_span, ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n@@ -247,7 +247,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 }\n             } else {\n                 let adt_data = if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n-                    fun.node\n+                    fun.kind\n                 {\n                     // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n@@ -427,7 +427,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n-                if let hir::ExprKind::Lit(ref lit) = arg.node {\n+                if let hir::ExprKind::Lit(ref lit) = arg.kind {\n                     ExprKind::Literal {\n                         literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n                         user_ty: None,\n@@ -639,7 +639,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 // }\n                 // The correct solution would be to add symbolic computations to miri,\n                 // so we wouldn't have to compute and store the actual value\n-                let var = if let hir::ExprKind::Path(ref qpath) = source.node {\n+                let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n                     let res = cx.tables().qpath_res(qpath, source.hir_id);\n                     cx\n                         .tables()"}, {"sha": "a49955b02df5354d3a89e4dd5b6f56b77a69fce9", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n \n-        if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.node {\n+        if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.kind {\n             self.check_match(scrut, arms, source);\n         }\n     }"}, {"sha": "435244965f4a17ef5b890e6a65efe53a80ce7819", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -933,7 +933,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);\n                 match lit_to_const(&lit.node, self.tcx, ty, false) {\n@@ -954,7 +954,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 let ty = self.tables.expr_ty(expr);\n-                let lit = match expr.node {\n+                let lit = match expr.kind {\n                     hir::ExprKind::Lit(ref lit) => lit,\n                     _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                 };"}, {"sha": "75d6fcf95ad900e0ae7b549bce80396a5bfc1c31", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -286,11 +286,11 @@ impl<'a> AstValidator<'a> {\n     // m!(S);\n     // ```\n     fn check_expr_within_pat(&self, expr: &Expr, allow_paths: bool) {\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Lit(..) | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner)\n-                if match inner.node { ExprKind::Lit(_) => true, _ => false } => {}\n+                if match inner.kind { ExprKind::Lit(_) => true, _ => false } => {}\n             _ => self.err_handler().span_err(expr.span, \"arbitrary expressions aren't allowed \\\n                                                          in patterns\")\n         }\n@@ -442,7 +442,7 @@ fn validate_generics_order<'a>(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        match &expr.node {\n+        match &expr.kind {\n             ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n                 self.check_fn_decl(fn_decl);\n             }"}, {"sha": "6c9e018fafc4ff85ba2af0a654a84dcc4bad2279", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n@@ -99,7 +99,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     let loop_kind = if loop_id == hir::DUMMY_HIR_ID {\n                         None\n                     } else {\n-                        Some(match self.hir_map.expect_expr(loop_id).node {\n+                        Some(match self.hir_map.expect_expr(loop_id).kind {\n                             hir::ExprKind::Loop(_, _, source) => source,\n                             ref r => span_bug!(e.span,\n                                                \"break label resolved to a non-loop: {:?}\", r),"}, {"sha": "ddc85cd364c38d2a2676a3aea80cf126a12a5ec1", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -280,7 +280,7 @@ fn check_expr_kind<'a, 'tcx>(\n         _ => Promotable\n     };\n \n-    let node_result = match e.node {\n+    let kind_result = match e.kind {\n         hir::ExprKind::Box(ref expr) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n@@ -376,7 +376,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             let mut callee = &**callee;\n             loop {\n-                callee = match callee.node {\n+                callee = match callee.kind {\n                     hir::ExprKind::Block(ref block, _) => match block.expr {\n                         Some(ref tail) => &tail,\n                         None => break\n@@ -385,7 +385,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 };\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = callee.kind {\n                 v.tables.qpath_res(qpath, callee.hir_id)\n             } else {\n                 Res::Err\n@@ -553,7 +553,7 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n     };\n-    ty_result & node_result\n+    ty_result & kind_result\n }\n \n /// Checks the adjustments of an expression."}, {"sha": "a862a7011ef1ce172819f01a475c32d3c3275801", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n@@ -1197,7 +1197,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             // Do not check nested expressions if the error already happened.\n             return;\n         }\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Assign(.., ref rhs) | hir::ExprKind::Match(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n                 if self.check_expr_pat_type(rhs.hir_id, rhs.span) {"}, {"sha": "9f8068fbcf7cd83d125154546268c081907165f4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1120,9 +1120,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n }\n \n macro_rules! method {\n-    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n+    ($visit:ident: $ty:ty, $invoc:path, $walk:ident, $kind:ident) => {\n         fn $visit(&mut self, node: &'b $ty) {\n-            if let $invoc(..) = node.node {\n+            if let $invoc(..) = node.$kind {\n                 self.visit_invoc(node.id);\n             } else {\n                 visit::$walk(self, node);\n@@ -1132,10 +1132,10 @@ macro_rules! method {\n }\n \n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n-    method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n-    method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n-    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n-    method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n+    method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item, node);\n+    method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr, kind);\n+    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat, node);\n+    method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty, node);\n \n     fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.node {\n@@ -1219,7 +1219,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_token(&mut self, t: Token) {\n         if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n-                if let ast::ExprKind::Mac(..) = expr.node {\n+                if let ast::ExprKind::Mac(..) = expr.kind {\n                     self.visit_invoc(expr.id);\n                 }\n             }"}, {"sha": "b13b7e2b528e0d2569081c423a1947cefbb587b4", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -221,7 +221,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n+            PathSource::Expr(parent) => match parent.map(|p| &p.kind) {\n                 // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n@@ -1836,7 +1836,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.record_candidate_traits_for_expr_if_necessary(expr);\n \n         // Next, resolve the node.\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(expr.id, qself.as_ref(), path, PathSource::Expr(parent));\n                 visit::walk_expr(self, expr);\n@@ -1968,7 +1968,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Field(_, ident) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match"}, {"sha": "e04e56cb945af8bd4eb535f2f202b954b7a706e8", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -325,7 +325,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n-        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n+        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.kind {\n             ExprKind::Field(_, ident) => {\n                 err.span_suggestion(\n                     expr.span,"}, {"sha": "bddc24f944334017e694a45572e838e495a5ebf6", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1461,9 +1461,9 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, ex: &'l ast::Expr) {\n-        debug!(\"visit_expr {:?}\", ex.node);\n+        debug!(\"visit_expr {:?}\", ex.kind);\n         self.process_macro_use(ex.span);\n-        match ex.node {\n+        match ex.kind {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let expr_hir_id = self.save_ctxt.tcx.hir().node_to_hir_id(ex.id);\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(expr_hir_id);\n@@ -1509,7 +1509,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n                 self.process_var_decl(pattern);\n-                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n+                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.kind);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }"}, {"sha": "fe5ef3ed3b73da675fd547838fbd93a50b023b7e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -518,7 +518,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         if ty.is_none() || ty.unwrap().kind == ty::Error {\n             return None;\n         }\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let sub_ex_hir_id = self.tcx.hir().node_to_hir_id(sub_ex.id);\n                 let hir_node = match self.tcx.hir().find(sub_ex_hir_id) {\n@@ -629,14 +629,14 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             }\n \n             Node::Expr(&hir::Expr {\n-                node: hir::ExprKind::Struct(ref qpath, ..),\n+                kind: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) => {\n                 self.tables.qpath_res(qpath, hir_id)\n             }\n \n             Node::Expr(&hir::Expr {\n-                node: hir::ExprKind::Path(ref qpath),\n+                kind: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {"}, {"sha": "ae9c021d24259cc08d3449c2551bf707fe170448", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -2175,13 +2175,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn const_param_def_id(&self, expr: &hir::Expr) -> Option<DefId> {\n         // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n         // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.node {\n+        let expr = match &expr.kind {\n             ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() =>\n                 block.expr.as_ref().unwrap(),\n             _ => expr,\n         };\n \n-        match &expr.node {\n+        match &expr.kind {\n             ExprKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n                 Res::Def(DefKind::ConstParam, did) => Some(did),\n                 _ => None,"}, {"sha": "019a82350bde39c1c24835f97944192cb9d860b4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             } else {\n-                let arm_span = if let hir::ExprKind::Block(blk, _) = &arm.body.node {\n+                let arm_span = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n                     // Point at the block expr instead of the entire block\n                     blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n                 } else {\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.coerce_forced_unit(self, &cause, &mut |err| {\n             if let Some((span, msg)) = &ret_reason {\n                 err.span_label(*span, msg.as_str());\n-            } else if let ExprKind::Block(block, _) = &then_expr.node {\n+            } else if let ExprKind::Block(block, _) = &then_expr.kind {\n                 if let Some(expr) = &block.expr {\n                     err.span_label(expr.span, \"found here\".to_string());\n                 }\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut remove_semicolon = None;\n-        let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n+        let error_sp = if let ExprKind::Block(block, _) = &else_expr.kind {\n             if let Some(expr) = &block.expr {\n                 expr.span\n             } else if let Some(stmt) = block.stmts.last() {\n@@ -345,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Compute `Span` of `then` part of `if`-expression.\n-        let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n+        let then_sp = if let ExprKind::Block(block, _) = &then_expr.kind {\n             if let Some(expr) = &block.expr {\n                 expr.span\n             } else if let Some(stmt) = block.stmts.last() {"}, {"sha": "4d8ec6fb0b83da7c5da758a210bc444633fb8235", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir_id = self.tcx.hir().get_parent_node(hir_id);\n         let parent_node = self.tcx.hir().get(hir_id);\n         if let (\n-            hir::Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, _, _, sp, ..), .. }),\n+            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, _, _, sp, ..), .. }),\n             hir::ExprKind::Block(..),\n         ) = (parent_node, callee_node) {\n             let start = sp.shrink_to_lo();\n@@ -278,13 +278,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut unit_variant = None;\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n-                        if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n+                        if let hir::ExprKind::Call(ref expr, _) = call_expr.kind {\n                             unit_variant = Some(self.tcx.hir().hir_to_pretty_string(expr.hir_id))\n                         }\n                     }\n                 }\n \n-                if let hir::ExprKind::Call(ref callee, _) = call_expr.node {\n+                if let hir::ExprKind::Call(ref callee, _) = call_expr.kind {\n                     let mut err = type_error_struct!(\n                         self.tcx.sess,\n                         callee.span,\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.identify_bad_closure_def_and_call(\n                         &mut err,\n                         call_expr.hir_id,\n-                        &callee.node,\n+                        &callee.kind,\n                         callee.span,\n                     );\n \n@@ -318,7 +318,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n \n                     let mut inner_callee_path = None;\n-                    let def = match callee.node {\n+                    let def = match callee.kind {\n                         hir::ExprKind::Path(ref qpath) => {\n                             self.tables.borrow().qpath_res(qpath, callee.hir_id)\n                         }\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.node {\n+                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n                                 inner_callee_path = Some(inner_qpath);\n                                 self.tables\n                                     .borrow()\n@@ -375,8 +375,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.emit();\n                 } else {\n                     bug!(\n-                        \"call_expr.node should be an ExprKind::Call, got {:?}\",\n-                        call_expr.node\n+                        \"call_expr.kind should be an ExprKind::Call, got {:?}\",\n+                        call_expr.kind\n                     );\n                 }\n "}, {"sha": "0878e72932a797c979931bbda65438816de48578", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Returns whether the expected type is `bool` and the expression is `x = y`.\n     pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n-        if let hir::ExprKind::Assign(..) = expr.node {\n+        if let hir::ExprKind::Assign(..) = expr.kind {\n             return expected == self.tcx.types.bool;\n         }\n         false\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr,\n     ) -> Option<(Span, &'static str, String)> {\n-        let path = match expr.node {\n+        let path = match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n             _ => return None\n         };\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n         let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(param_parent) {\n             Some(Node::Expr(\n-                hir::Expr { hir_id, node: hir::ExprKind::Closure(_, decl, ..), .. }\n+                hir::Expr { hir_id, kind: hir::ExprKind::Closure(_, decl, ..), .. }\n             )) => (hir_id, decl),\n             _ => return None\n         };\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let closure_params_len = closure_fn_decl.inputs.len();\n         let (method_path, method_span, method_expr) = match (hir, closure_params_len) {\n             (Some(Node::Expr(\n-                hir::Expr { node: hir::ExprKind::MethodCall(path, span, expr), .. }\n+                hir::Expr { kind: hir::ExprKind::MethodCall(path, span, expr), .. }\n             )), 1) => (path, span, expr),\n             _ => return None\n         };\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(parent) = self.tcx.hir().find(parent_id) {\n             // Account for fields\n             if let Node::Expr(hir::Expr {\n-                node: hir::ExprKind::Struct(_, fields, ..), ..\n+                kind: hir::ExprKind::Struct(_, fields, ..), ..\n             }) = parent {\n                 if let Ok(src) = cm.span_to_snippet(sp) {\n                     for field in fields {\n@@ -351,11 +351,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // and make a good suggestion, so don't bother.\n         let is_macro = sp.from_expansion();\n \n-        match (&expr.node, &expected.kind, &checked_ty.kind) {\n+        match (&expr.kind, &expected.kind, &checked_ty.kind) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.kind, &check.kind) {\n                 (&ty::Str, &ty::Array(arr, _)) |\n                 (&ty::Str, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n                                 return Some((sp,\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 },\n                 (&ty::Array(arr, _), &ty::Str) |\n                 (&ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n                                 return Some((sp,\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.node {\n+                    if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.kind {\n                         let clone_trait = self.tcx.lang_items().clone_trait().unwrap();\n                         if let ([arg], Some(true), \"clone\") = (\n                             &args[..],\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     if let Ok(src) = cm.span_to_snippet(sugg_sp) {\n-                        let needs_parens = match expr.node {\n+                        let needs_parens = match expr.kind {\n                             // parenthesize if needed (Issue #46756)\n                             hir::ExprKind::Cast(_, _) |\n                             hir::ExprKind::Binary(_, _, _) => true,\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             String::new()\n                         };\n                         if let Some(hir::Node::Expr(hir::Expr {\n-                            node: hir::ExprKind::Assign(left_expr, _),\n+                            kind: hir::ExprKind::Assign(left_expr, _),\n                             ..\n                         })) = self.tcx.hir().find(\n                             self.tcx.hir().get_parent_node(expr.hir_id),\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut prefix = String::new();\n         if let Some(hir::Node::Expr(hir::Expr {\n-            node: hir::ExprKind::Struct(_, fields, _),\n+            kind: hir::ExprKind::Struct(_, fields, _),\n             ..\n         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id)) {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n@@ -587,11 +587,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return false;\n             }\n         }\n-        if let hir::ExprKind::Call(path, args) = &expr.node {\n+        if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (\n                 hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)),\n                 1,\n-            ) = (&path.node, args.len()) {\n+            ) = (&path.kind, args.len()) {\n                 // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n                 if let (\n                     hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)),\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if needs_paren { \")\" } else { \"\" },\n             );\n             let literal_is_ty_suffixed = |expr: &hir::Expr| {\n-                if let hir::ExprKind::Lit(lit) = &expr.node {\n+                if let hir::ExprKind::Lit(lit) = &expr.kind {\n                     lit.node.is_suffixed()\n                 } else {\n                     false"}, {"sha": "58f41ca4f88f94c481ce3721113beb38b1dc575c", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = match &expr.node {\n+            let expr = match &expr.kind {\n                 ExprKind::DropTemps(expr) => expr,\n                 _ => expr,\n             };\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.check_expr_kind(expr, expected, needs);\n \n         // Warn for non-block expressions with diverging children.\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n             ExprKind::Call(ref callee, _) =>\n                 self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let tcx = self.tcx;\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Box(ref subexpr) => {\n                 self.check_expr_box(subexpr, expected)\n             }\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n                     if path.segments.len() == 1 &&\n                         path.segments[0].ident.name == sym::rust {\n                         fatally_break_rust(self.tcx.sess);\n@@ -1604,7 +1604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let mut needs_note = true;\n                         // If the index is an integer, we can show the actual\n                         // fixed expression:\n-                        if let ExprKind::Lit(ref lit) = idx.node {\n+                        if let ExprKind::Lit(ref lit) = idx.kind {\n                             if let ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) = lit.node {\n                                 let snip = self.tcx.sess.source_map().span_to_snippet(base.span);\n                                 if let Ok(snip) = snip {"}, {"sha": "9baf06be3f6b5f47f8776b8910a13a44f50aaec0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -436,7 +436,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let mut exprs = vec![self.self_expr];\n \n         loop {\n-            match exprs.last().unwrap().node {\n+            match exprs.last().unwrap().kind {\n                 hir::ExprKind::Field(ref expr, _) |\n                 hir::ExprKind::Index(ref expr, _) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref expr) => exprs.push(&expr),\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n             }\n \n-            match expr.node {\n+            match expr.kind {\n                 hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n                     let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_place_op_to_mutable("}, {"sha": "4b02bc58d66c61d6893d2acd7cd055bbcae8c6ff", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             \"f32\"\n                         };\n-                        match expr.node {\n+                        match expr.kind {\n                             ExprKind::Lit(ref lit) => {\n                                 // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n@@ -446,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n                         } else if let ExprKind::Path(QPath::Resolved(_, ref path)) =\n-                            expr.node\n+                            expr.kind\n                         {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.ident);"}, {"sha": "486f4a1d5f6739efdf6ad2048f1a77b73c7c615a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -3376,7 +3376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n-                let is_closure = match arg.node {\n+                let is_closure = match arg.kind {\n                     ExprKind::Closure(..) => true,\n                     _ => false\n                 };\n@@ -3495,8 +3495,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n         call_expr: &'tcx hir::Expr,\n     ) {\n-        if let hir::ExprKind::Call(path, _) = &call_expr.node {\n-            if let hir::ExprKind::Path(qpath) = &path.node {\n+        if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n+            if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n                         if let ty::Predicate::Trait(predicate) = error.obligation.predicate {\n@@ -3912,15 +3912,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// //                               ^^^^ point at this instead of the whole `if` expression\n     /// ```\n     fn get_expr_coercion_span(&self, expr: &hir::Expr) -> syntax_pos::Span {\n-        if let hir::ExprKind::Match(_, arms, _) = &expr.node {\n+        if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n             let arm_spans: Vec<Span> = arms.iter().filter_map(|arm| {\n                 self.in_progress_tables\n                     .and_then(|tables| tables.borrow().node_type_opt(arm.body.hir_id))\n                     .and_then(|arm_ty| {\n                         if arm_ty.is_never() {\n                             None\n                         } else {\n-                            Some(match &arm.body.node {\n+                            Some(match &arm.body.kind {\n                                 // Point at the tail expression when possible.\n                                 hir::ExprKind::Block(block, _) => block.expr\n                                     .as_ref()\n@@ -4075,7 +4075,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 node: hir::ImplItemKind::Method(_, body_id), ..\n             }) => {\n                 let body = self.tcx.hir().body(body_id);\n-                if let ExprKind::Block(block, _) = &body.value.node {\n+                if let ExprKind::Block(block, _) = &body.value.kind {\n                     return Some(block.span);\n                 }\n             }\n@@ -4212,7 +4212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }).collect::<Vec<_>>().join(\", \");\n                 }\n                 Some(Node::Expr(hir::Expr {\n-                    node: ExprKind::Closure(_, _, body_id, closure_span, _),\n+                    kind: ExprKind::Closure(_, _, body_id, closure_span, _),\n                     span: full_closure_span,\n                     ..\n                 })) => {\n@@ -4388,7 +4388,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if expected.is_unit() {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n-            match expression.node {\n+            match expression.kind {\n                 ExprKind::Call(..) |\n                 ExprKind::MethodCall(..) |\n                 ExprKind::Loop(..) |\n@@ -4893,7 +4893,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Node::Expr(expr) = self.tcx.hir().get(\n             self.tcx.hir().get_parent_node(hir_id))\n         {\n-            if let ExprKind::Call(ref callee, ..) = expr.node {\n+            if let ExprKind::Call(ref callee, ..) = expr.kind {\n                 if callee.hir_id == hir_id {\n                     return\n                 }\n@@ -4968,7 +4968,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while let hir::Node::Expr(parent_expr) =\n             self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n         {\n-            match &parent_expr.node {\n+            match &parent_expr.kind {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n                     if lhs.hir_id == expr_id {\n                         contained_in_place = true;"}, {"sha": "77564bf141a1b28f4784a1041c99faed60d16c03", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Byte string patterns behave the same way as array patterns\n         // They can denote both statically and dynamically-sized byte arrays.\n         let mut pat_ty = ty;\n-        if let hir::ExprKind::Lit(ref lt) = lt.node {\n+        if let hir::ExprKind::Lit(ref lt) = lt.kind {\n             if let ast::LitKind::ByteStr(_) = lt.node {\n                 let expected_ty = self.structurally_resolved_type(span, expected);\n                 if let ty::Ref(_, r_ty, _) = expected_ty.kind {"}, {"sha": "1ba21651812dc515d341b6aeab33778737fd77f3", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n         // arguments for its type parameters are well-formed, and all the regions\n         // provided as arguments outlive the call.\n         if is_method_call {\n-            let origin = match expr.node {\n+            let origin = match expr.kind {\n                 hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n                 hir::ExprKind::Unary(op, _) if op == hir::UnDeref => {\n                     infer::ParameterOrigin::OverloadedDeref\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n             \"regionck::visit_expr(e={:?}, repeating_scope={:?}) - visiting subexprs\",\n             expr, self.repeating_scope\n         );\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;"}, {"sha": "71ea938a8039b6da15b1fe3472a9e1e931bfcb92", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.node {\n+        if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.kind {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);\n             self.fcx"}, {"sha": "b22decf6eb9ecae3bcaa0a61902c227556b05613", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -134,7 +134,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // we observe that something like `a+b` is (known to be)\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n@@ -159,7 +159,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     tables.type_dependent_defs_mut().remove(e.hir_id);\n                     tables.node_substs_mut().remove(e.hir_id);\n \n-                    match e.node {\n+                    match e.kind {\n                         hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n                                 let mut adjustments = tables.adjustments_mut();\n@@ -186,7 +186,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // to use builtin indexing because the index type is known to be\n     // usize-ish\n     fn fix_index_builtin_expr(&mut self, e: &hir::Expr) {\n-        if let hir::ExprKind::Index(ref base, ref index) = e.node {\n+        if let hir::ExprKind::Index(ref base, ref index) = e.kind {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n             // All valid indexing looks like this; might encounter non-valid indexes at this point\n@@ -241,7 +241,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n         self.visit_node_id(e.span, e.hir_id);\n \n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir().body(body);\n                 for param in &body.params {"}, {"sha": "91975253c81ca4b8e8cc14eb98f6a93c457511e5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -135,7 +135,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Closure(..) = expr.node {\n+        if let hir::ExprKind::Closure(..) = expr.kind {\n             let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n@@ -915,7 +915,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             }\n         }\n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(..),\n+            kind: hir::ExprKind::Closure(..),\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n         Node::Item(item) => match item.node {\n@@ -1072,7 +1072,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n     if let Node::Expr(&hir::Expr {\n-        node: hir::ExprKind::Closure(.., gen),\n+        kind: hir::ExprKind::Closure(.., gen),\n         ..\n     }) = node\n     {\n@@ -1355,7 +1355,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n         Node::Field(field) => icx.to_ty(&field.ty),\n \n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(.., gen),\n+            kind: hir::ExprKind::Closure(.., gen),\n             ..\n         }) => {\n             if gen.is_some() {\n@@ -1381,7 +1381,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     ..\n                 })\n                 | Node::Expr(&hir::Expr {\n-                    node: ExprKind::Repeat(_, ref constant),\n+                    kind: ExprKind::Repeat(_, ref constant),\n                     ..\n                 }) if constant.hir_id == hir_id =>\n                 {\n@@ -1400,21 +1400,21 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 }\n \n                 Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) |\n+                Node::Expr(&hir::Expr { kind: ExprKind::Struct(..), .. }) |\n+                Node::Expr(&hir::Expr { kind: ExprKind::Path(_), .. }) |\n                 Node::TraitRef(..) => {\n                     let path = match parent_node {\n                         Node::Ty(&hir::Ty {\n                             node: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n                             ..\n                         })\n                         | Node::Expr(&hir::Expr {\n-                            node: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n                             ..\n                         }) => {\n                             Some(&**path)\n                         }\n-                        Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n+                        Node::Expr(&hir::Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n                             if let QPath::Resolved(_, ref path) = **path {\n                                 Some(&**path)\n                             } else {\n@@ -1847,7 +1847,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         }\n \n         Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(..),\n+            kind: hir::ExprKind::Closure(..),\n             ..\n         }) => {\n             // Closure signatures are not like other function"}, {"sha": "966e65fd5e519125c2bcf0161785eb6672d99ed6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -977,7 +977,7 @@ pub struct AnonConst {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub id: NodeId,\n-    pub node: ExprKind,\n+    pub kind: ExprKind,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n }\n@@ -990,12 +990,12 @@ impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n     /// for example, an `if` condition.\n     pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block, _) = self.node {\n+        if let ExprKind::Block(ref block, _) = self.kind {\n             match block.stmts.last().map(|last_stmt| &last_stmt.node) {\n                 // Implicit return\n                 Some(&StmtKind::Expr(_)) => true,\n                 Some(&StmtKind::Semi(ref expr)) => {\n-                    if let ExprKind::Ret(_) = expr.node {\n+                    if let ExprKind::Ret(_) = expr.kind {\n                         // Last statement is explicit return.\n                         true\n                     } else {\n@@ -1012,7 +1012,7 @@ impl Expr {\n     }\n \n     fn to_bound(&self) -> Option<GenericBound> {\n-        match &self.node {\n+        match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n                 PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n                 TraitBoundModifier::None,\n@@ -1022,7 +1022,7 @@ impl Expr {\n     }\n \n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n-        let node = match &self.node {\n+        let kind = match &self.kind {\n             ExprKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             ExprKind::Mac(mac) => TyKind::Mac(mac.clone()),\n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n@@ -1051,14 +1051,14 @@ impl Expr {\n         };\n \n         Some(P(Ty {\n-            node,\n+            node: kind,\n             id: self.id,\n             span: self.span,\n         }))\n     }\n \n     pub fn precedence(&self) -> ExprPrecedence {\n-        match self.node {\n+        match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::Call(..) => ExprPrecedence::Call,"}, {"sha": "0c3922ee96ec079105be0d7f81aecb905f46be3a", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -321,13 +321,13 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n \n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.configure_expr(expr);\n-        self.configure_expr_kind(&mut expr.node);\n+        self.configure_expr_kind(&mut expr.kind);\n         noop_visit_expr(expr, self);\n     }\n \n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         let mut expr = configure!(self, expr);\n-        self.configure_expr_kind(&mut expr.node);\n+        self.configure_expr_kind(&mut expr.kind);\n         noop_visit_expr(&mut expr, self);\n         Some(expr)\n     }"}, {"sha": "3079382a3b23142189acdeaab7b2d581080aa790", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -507,7 +507,7 @@ impl MacResult for MacEager {\n             return Some(p);\n         }\n         if let Some(e) = self.expr {\n-            if let ast::ExprKind::Lit(_) = e.node {\n+            if let ast::ExprKind::Lit(_) = e.kind {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n@@ -549,7 +549,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span, is_error: bool) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n             span: sp,\n             attrs: ThinVec::new(),\n         })\n@@ -1098,7 +1098,7 @@ pub fn expr_to_spanned_string<'a>(\n     // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n     let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n \n-    Err(match expr.node {\n+    Err(match expr.kind {\n         ast::ExprKind::Lit(ref l) => match l.node {\n             ast::LitKind::Str(s, style) => return Ok((s, style, expr.span)),\n             ast::LitKind::Err(_) => None,"}, {"sha": "4f61a7e427e22bcb46b6ba9c18e86964151a5051", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -73,12 +73,12 @@ impl<'a> ExtCtxt<'a> {\n         self.ty_path(self.path_ident(span, ident))\n     }\n \n-    pub fn anon_const(&self, span: Span, expr: ast::ExprKind) -> ast::AnonConst {\n+    pub fn anon_const(&self, span: Span, kind: ast::ExprKind) -> ast::AnonConst {\n         ast::AnonConst {\n             id: ast::DUMMY_NODE_ID,\n             value: P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: expr,\n+                kind,\n                 span,\n                 attrs: ThinVec::new(),\n             })\n@@ -239,10 +239,10 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n+    pub fn expr(&self, span: Span, kind: ast::ExprKind) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node,\n+            kind,\n             span,\n             attrs: ThinVec::new(),\n         })"}, {"sha": "3cec7c1e7ecfaeb09b5dad04073ec88e4be46605", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1035,7 +1035,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.cfg.configure_expr(expr);\n         visit_clobber(expr.deref_mut(), |mut expr| {\n-            self.cfg.configure_expr_kind(&mut expr.node);\n+            self.cfg.configure_expr_kind(&mut expr.kind);\n \n             // ignore derives so they remain unused\n             let (attr, after_derive) = self.classify_nonitem(&mut expr);\n@@ -1052,7 +1052,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     .into_inner()\n             }\n \n-            if let ast::ExprKind::Mac(mac) = expr.node {\n+            if let ast::ExprKind::Mac(mac) = expr.kind {\n                 self.check_attributes(&expr.attrs);\n                 self.collect_bang(mac, expr.span, AstFragmentKind::Expr)\n                     .make_expr()\n@@ -1145,7 +1145,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         let expr = configure!(self, expr);\n         expr.filter_map(|mut expr| {\n-            self.cfg.configure_expr_kind(&mut expr.node);\n+            self.cfg.configure_expr_kind(&mut expr.kind);\n \n             // Ignore derives so they remain unused.\n             let (attr, after_derive) = self.classify_nonitem(&mut expr);\n@@ -1159,7 +1159,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     .map(|expr| expr.into_inner())\n             }\n \n-            if let ast::ExprKind::Mac(mac) = expr.node {\n+            if let ast::ExprKind::Mac(mac) = expr.kind {\n                 self.check_attributes(&expr.attrs);\n                 self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr)\n                     .make_opt_expr()"}, {"sha": "827a2f9da323eb9e6c5e74272a4cd736238004cc", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -30,7 +30,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     let expr_placeholder = || P(ast::Expr {\n         id, span,\n         attrs: ThinVec::new(),\n-        node: ast::ExprKind::Mac(mac_placeholder()),\n+        kind: ast::ExprKind::Mac(mac_placeholder()),\n     });\n     let ty = P(ast::Ty {\n         id,\n@@ -282,14 +282,14 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Mac(_) => *expr = self.remove(expr.id).make_expr(),\n             _ => noop_visit_expr(expr, self),\n         }\n     }\n \n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Mac(_) => self.remove(expr.id).make_opt_expr(),\n             _ => noop_filter_map_expr(expr, self),\n         }"}, {"sha": "516f3bb0e9e5d6d567df929283847a5d250c3f46", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -456,7 +456,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        match e.node {\n+        match e.kind {\n             ast::ExprKind::Box(_) => {\n                 gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n             }"}, {"sha": "6b7c574b82faaf4adca36c2f55308ce5c7b8e77f", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1097,8 +1097,8 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n     vis.visit_expr(value);\n }\n \n-pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr, vis: &mut T) {\n-    match node {\n+pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr, vis: &mut T) {\n+    match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n         ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n         ExprKind::Repeat(expr, count) => {"}, {"sha": "4456068875019fd347260ce8c7b4f7abc412be23", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -12,7 +12,7 @@ use crate::ast;\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n-    match e.node {\n+    match e.kind {\n         ast::ExprKind::If(..) |\n         ast::ExprKind::Match(..) |\n         ast::ExprKind::Block(..) |"}, {"sha": "c73ef982b07086cc563b1a4687277378d17386ed", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -161,7 +161,7 @@ impl RecoverQPath for Expr {\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self {\n             span: path.span,\n-            node: ExprKind::Path(qself, path),\n+            kind: ExprKind::Path(qself, path),\n             attrs: ThinVec::new(),\n             id: ast::DUMMY_NODE_ID,\n         }\n@@ -549,7 +549,7 @@ impl<'a> Parser<'a> {\n         debug_assert!(outer_op.is_comparison(),\n                       \"check_no_chained_comparison: {:?} is not comparison\",\n                       outer_op);\n-        match lhs.node {\n+        match lhs.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n                 let op_span = op.span.to(self.token.span);\n@@ -915,7 +915,7 @@ impl<'a> Parser<'a> {\n             .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n         let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n         let sp = lo.to(hi);\n-        let app = match expr.node {\n+        let app = match expr.kind {\n             ExprKind::Try(_) => Applicability::MaybeIncorrect, // `await <expr>?`\n             _ => Applicability::MachineApplicable,\n         };"}, {"sha": "973c54017b69447233e78cce237b811b772ab0f7", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -267,7 +267,7 @@ impl Lit {\n                 lit,\n             token::Interpolated(ref nt) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n-                    if let ast::ExprKind::Lit(lit) = &expr.node {\n+                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n                         return Ok(lit.clone());\n                     }\n                 }"}, {"sha": "deb2140f7974c23329015ad734ea740f69d2a4e3", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -210,7 +210,7 @@ impl<'a> Parser<'a> {\n             // it refers to. Interpolated identifiers are unwrapped early and never show up here\n             // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n             // it as \"interpolated\", it doesn't change the answer for non-interpolated idents.\n-            let lhs_span = match (self.prev_token_kind, &lhs.node) {\n+            let lhs_span = match (self.prev_token_kind, &lhs.kind) {\n                 (PrevTokenKind::Interpolated, _) => self.prev_span,\n                 (PrevTokenKind::Ident, &ExprKind::Path(None, ref path))\n                     if path.segments.len() == 1 => self.prev_span,\n@@ -245,7 +245,7 @@ impl<'a> Parser<'a> {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue\n             } else if op == AssocOp::Colon {\n-                let maybe_path = self.could_ascription_be_path(&lhs.node);\n+                let maybe_path = self.could_ascription_be_path(&lhs.kind);\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n@@ -614,7 +614,7 @@ impl<'a> Parser<'a> {\n             expr.map(|mut expr| {\n                 attrs.extend::<Vec<_>>(expr.attrs.into());\n                 expr.attrs = attrs;\n-                match expr.node {\n+                match expr.kind {\n                     ExprKind::If(..) if !expr.attrs.is_empty() => {\n                         // Just point to the first attribute in there...\n                         let span = expr.attrs[0].span;\n@@ -1242,7 +1242,7 @@ impl<'a> Parser<'a> {\n     fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n \n-        if let ExprKind::Let(..) = cond.node {\n+        if let ExprKind::Let(..) = cond.kind {\n             // Remove the last feature gating of a `let` expression since it's stable.\n             let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n             debug_assert_eq!(cond.span, last.unwrap());\n@@ -1779,7 +1779,7 @@ impl<'a> Parser<'a> {\n         Ok(await_expr)\n     }\n \n-    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n-        P(Expr { node, span, attrs, id: DUMMY_NODE_ID })\n+    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+        P(Expr { kind, span, attrs, id: DUMMY_NODE_ID })\n     }\n }"}, {"sha": "984a2018e7a1f642c0af40d0b05ccdbaa8950a1d", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -272,7 +272,7 @@ fn ttdelim_span() {\n         let expr = parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n-        let tts: Vec<_> = match expr.node {\n+        let tts: Vec<_> = match expr.kind {\n             ast::ExprKind::Mac(ref mac) => mac.stream().trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };"}, {"sha": "d43b778241352281184f6c8b46140c3394e6bee2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -1734,33 +1734,30 @@ impl<'a> State<'a> {\n     }\n \n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n-        match els {\n-            Some(_else) => {\n-                match _else.node {\n-                    // Another `else if` block.\n-                    ast::ExprKind::If(ref i, ref then, ref e) => {\n-                        self.cbox(INDENT_UNIT - 1);\n-                        self.ibox(0);\n-                        self.s.word(\" else if \");\n-                        self.print_expr_as_cond(i);\n-                        self.s.space();\n-                        self.print_block(then);\n-                        self.print_else(e.as_ref().map(|e| &**e))\n-                    }\n-                    // Final `else` block.\n-                    ast::ExprKind::Block(ref b, _) => {\n-                        self.cbox(INDENT_UNIT - 1);\n-                        self.ibox(0);\n-                        self.s.word(\" else \");\n-                        self.print_block(b)\n-                    }\n-                    // Constraints would be great here!\n-                    _ => {\n-                        panic!(\"print_if saw if with weird alternative\");\n-                    }\n+        if let Some(_else) = els {\n+            match _else.kind {\n+                // Another `else if` block.\n+                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.s.word(\" else if \");\n+                    self.print_expr_as_cond(i);\n+                    self.s.space();\n+                    self.print_block(then);\n+                    self.print_else(e.as_ref().map(|e| &**e))\n+                }\n+                // Final `else` block.\n+                ast::ExprKind::Block(ref b, _) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.s.word(\" else \");\n+                    self.print_block(b)\n+                }\n+                // Constraints would be great here!\n+                _ => {\n+                    panic!(\"print_if saw if with weird alternative\");\n                 }\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1805,7 +1802,7 @@ impl<'a> State<'a> {\n \n     /// Does `expr` need parenthesis when printed in a condition position?\n     fn cond_needs_par(expr: &ast::Expr) -> bool {\n-        match expr.node {\n+        match expr.kind {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n             ast::ExprKind::Closure(..) |\n@@ -1905,7 +1902,7 @@ impl<'a> State<'a> {\n                        func: &ast::Expr,\n                        args: &[P<ast::Expr>]) {\n         let prec =\n-            match func.node {\n+            match func.kind {\n                 ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n@@ -1941,7 +1938,7 @@ impl<'a> State<'a> {\n             Fixity::None => (prec + 1, prec + 1),\n         };\n \n-        let left_prec = match (&lhs.node, op.node) {\n+        let left_prec = match (&lhs.kind, op.node) {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n@@ -2000,7 +1997,7 @@ impl<'a> State<'a> {\n \n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n@@ -2477,7 +2474,7 @@ impl<'a> State<'a> {\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.node {\n+        match arm.body.kind {\n             ast::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);"}, {"sha": "982755e868054ec159b06ba7cb7ffbffcf28f958", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -375,7 +375,7 @@ crate fn needs_par_as_let_scrutinee(order: i8) -> bool {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-    match value.node {\n+    match value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n         ast::ExprKind::Assign(ref lhs, ref rhs) |"}, {"sha": "c91b9f8bc3aebc2151d576d7a93b478e8a682a4d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -683,7 +683,7 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n-    match expression.node {\n+    match expression.kind {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }"}, {"sha": "becbf6d60a07012b3e1282e38c44eb9a88816310", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -61,7 +61,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n \n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprKind::InlineAsm(P(inline_asm)),\n+        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n         span: cx.with_def_site_ctxt(sp),\n         attrs: ThinVec::new(),\n     }))"}, {"sha": "ded8f2bc09423fd247702eebcbbefd7f5ff47be3", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -18,7 +18,7 @@ pub fn expand_concat(\n     let mut missing_literal = vec![];\n     let mut has_errors = false;\n     for e in es {\n-        match e.node {\n+        match e.kind {\n             ast::ExprKind::Lit(ref lit) => match lit.node {\n                 ast::LitKind::Str(ref s, _)\n                 | ast::LitKind::Float(ref s, _)"}, {"sha": "912eba94b1f3ff8e83a877ecff7916ce6ad0798d", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -47,7 +47,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n             Some(P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n+                kind: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n                 attrs: ThinVec::new(),\n             }))"}, {"sha": "7e4fd467e132d21be0576431208e3762c828aa6e", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f6d72a60461a4a432d7e8971bb6a1899456b56/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=95f6d72a60461a4a432d7e8971bb6a1899456b56", "patch": "@@ -172,7 +172,7 @@ struct RemoveParens;\n \n impl MutVisitor for RemoveParens {\n     fn visit_expr(&mut self, e: &mut P<Expr>) {\n-        match e.node.clone() {\n+        match e.kind.clone() {\n             ExprKind::Paren(inner) => *e = inner,\n             _ => {}\n         };\n@@ -190,7 +190,7 @@ impl MutVisitor for AddParens {\n         visit_clobber(e, |e| {\n             P(Expr {\n                 id: DUMMY_NODE_ID,\n-                node: ExprKind::Paren(e),\n+                kind: ExprKind::Paren(e),\n                 span: DUMMY_SP,\n                 attrs: ThinVec::new(),\n             })"}]}