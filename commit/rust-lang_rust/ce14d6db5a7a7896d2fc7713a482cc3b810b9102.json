{"sha": "ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMTRkNmRiNWE3YTc4OTZkMmZjNzcxM2E0ODJjYzNiODEwYjkxMDI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-06T20:36:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T20:36:43Z"}, "message": "Rollup merge of #70908 - estebank:suggest-add, r=nikomatsakis\n\nProvide suggestions for type parameters missing bounds for associated types\n\nWhen implementing the binary operator traits it is easy to forget to restrict the `Output` associated type. `rustc` now accounts for different cases to lead users in the right direction to add the necessary restrictions. The structured suggestions in the following output are new:\n\n```\nerror: equality constraints are not yet supported in `where` clauses\n  --> $DIR/missing-bounds.rs:37:33\n   |\nLL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n   |\n   = note: see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\nhelp: if `Output` is an associated type you're trying to set, use the associated type binding syntax\n   |\nLL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n   |                                 ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> $DIR/missing-bounds.rs:11:11\n   |\n7  | impl<B> Add for A<B> where B: Add {\n   |      - this type parameter\n...\n11 |         A(self.0 + rhs.0)\n   |           ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n   |\n   = note: expected type parameter `B`\n             found associated type `<B as std::ops::Add>::Output`\nhelp: consider further restricting this bound\n   |\n7  | impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: cannot add `B` to `B`\n  --> $DIR/missing-bounds.rs:31:21\n   |\n31 |         Self(self.0 + rhs.0)\n   |              ------ ^ ----- B\n   |              |\n   |              B\n   |\nhelp: consider restricting type parameter `B`\n   |\n27 | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nThat output is given for the following cases:\n\n```rust\nstruct A<B>(B);\nimpl<B> Add for A<B> where B: Add {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n        A(self.0 + rhs.0) //~ ERROR mismatched types\n    }\n}\n\nstruct D<B>(B);\nimpl<B> Add for D<B> {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n    }\n}\n\nstruct E<B>(B);\nimpl<B: Add> Add for E<B> where <B as Add>::Output = B {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n        Self(self.0 + rhs.0)\n    }\n}\n```", "tree": {"sha": "447323cd2ce31fd4fbbfd24c372d9ffa5931fe1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/447323cd2ce31fd4fbbfd24c372d9ffa5931fe1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJesx/bCRBK7hj4Ov3rIwAAdHIIAAVxXqXvJAzXkJQiDdgi0X2I\nIEGNmKfE3qxQ265NuuQ95mY0RkdI4jPlWcYIyYoOZE7wbFOdDwkZMOwbgcyyZVjx\nWvIT/r323ud14qYz0SVvn10GeuWnf1vDqaz5DnPQB5EaTQsERnnGY2373wyD6qqS\nDfjbRq/X8jMA3zP2M+TRcC0ah4BfRclCK2O9Wff4lE0yDLvM/vOlpTCddAlAFYJR\n+Xs0hhLdrkMOLEoWZELbHxSN0DIq9mZbB1vJzJ5T0p5QNhY2CE38VnYBVT32sp+C\nLP15ik6OI6Oyw4dfuSigXUx2+sywe1g4NNo9qDeqL9f8y5Vh/n0Rr4ODreWurtw=\n=K/9X\n-----END PGP SIGNATURE-----\n", "payload": "tree 447323cd2ce31fd4fbbfd24c372d9ffa5931fe1a\nparent 1836e3b42a5b2f37fd79104eedbe8f48a5afdee6\nparent b17b20cafc87193dace2beb1cdb0e126d944f8e3\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588797403 +0200\ncommitter GitHub <noreply@github.com> 1588797403 +0200\n\nRollup merge of #70908 - estebank:suggest-add, r=nikomatsakis\n\nProvide suggestions for type parameters missing bounds for associated types\n\nWhen implementing the binary operator traits it is easy to forget to restrict the `Output` associated type. `rustc` now accounts for different cases to lead users in the right direction to add the necessary restrictions. The structured suggestions in the following output are new:\n\n```\nerror: equality constraints are not yet supported in `where` clauses\n  --> $DIR/missing-bounds.rs:37:33\n   |\nLL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n   |\n   = note: see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\nhelp: if `Output` is an associated type you're trying to set, use the associated type binding syntax\n   |\nLL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n   |                                 ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> $DIR/missing-bounds.rs:11:11\n   |\n7  | impl<B> Add for A<B> where B: Add {\n   |      - this type parameter\n...\n11 |         A(self.0 + rhs.0)\n   |           ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n   |\n   = note: expected type parameter `B`\n             found associated type `<B as std::ops::Add>::Output`\nhelp: consider further restricting this bound\n   |\n7  | impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: cannot add `B` to `B`\n  --> $DIR/missing-bounds.rs:31:21\n   |\n31 |         Self(self.0 + rhs.0)\n   |              ------ ^ ----- B\n   |              |\n   |              B\n   |\nhelp: consider restricting type parameter `B`\n   |\n27 | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nThat output is given for the following cases:\n\n```rust\nstruct A<B>(B);\nimpl<B> Add for A<B> where B: Add {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n        A(self.0 + rhs.0) //~ ERROR mismatched types\n    }\n}\n\nstruct D<B>(B);\nimpl<B> Add for D<B> {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n    }\n}\n\nstruct E<B>(B);\nimpl<B: Add> Add for E<B> where <B as Add>::Output = B {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n        Self(self.0 + rhs.0)\n    }\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "html_url": "https://github.com/rust-lang/rust/commit/ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1836e3b42a5b2f37fd79104eedbe8f48a5afdee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1836e3b42a5b2f37fd79104eedbe8f48a5afdee6", "html_url": "https://github.com/rust-lang/rust/commit/1836e3b42a5b2f37fd79104eedbe8f48a5afdee6"}, {"sha": "b17b20cafc87193dace2beb1cdb0e126d944f8e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b17b20cafc87193dace2beb1cdb0e126d944f8e3", "html_url": "https://github.com/rust-lang/rust/commit/b17b20cafc87193dace2beb1cdb0e126d944f8e3"}], "stats": {"total": 853, "additions": 629, "deletions": 224}, "files": [{"sha": "cc88fbb295c68384ed45560bbd4774a699c1aa63", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 85, "deletions": 11, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -23,6 +23,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use std::mem;\n+use std::ops::DerefMut;\n \n const MORE_EXTERN: &str =\n     \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n@@ -1113,17 +1114,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n         for predicate in &generics.where_clause.predicates {\n             if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        predicate.span,\n-                        \"equality constraints are not yet supported in `where` clauses\",\n-                    )\n-                    .span_label(predicate.span, \"not supported\")\n-                    .note(\n-                        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> \\\n-                         for more information\",\n-                    )\n-                    .emit();\n+                deny_equality_constraints(self, predicate, generics);\n             }\n         }\n \n@@ -1300,6 +1291,89 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n+/// When encountering an equality constraint in a `where` clause, emit an error. If the code seems\n+/// like it's setting an associated type, provide an appropriate suggestion.\n+fn deny_equality_constraints(\n+    this: &mut AstValidator<'_>,\n+    predicate: &WhereEqPredicate,\n+    generics: &Generics,\n+) {\n+    let mut err = this.err_handler().struct_span_err(\n+        predicate.span,\n+        \"equality constraints are not yet supported in `where` clauses\",\n+    );\n+    err.span_label(predicate.span, \"not supported\");\n+\n+    // Given `<A as Foo>::Bar = RhsTy`, suggest `A: Foo<Bar = RhsTy>`.\n+    if let TyKind::Path(Some(qself), full_path) = &predicate.lhs_ty.kind {\n+        if let TyKind::Path(None, path) = &qself.ty.kind {\n+            match &path.segments[..] {\n+                [PathSegment { ident, args: None, .. }] => {\n+                    for param in &generics.params {\n+                        if param.ident == *ident {\n+                            let param = ident;\n+                            match &full_path.segments[qself.position..] {\n+                                [PathSegment { ident, .. }] => {\n+                                    // Make a new `Path` from `foo::Bar` to `Foo<Bar = RhsTy>`.\n+                                    let mut assoc_path = full_path.clone();\n+                                    // Remove `Bar` from `Foo::Bar`.\n+                                    assoc_path.segments.pop();\n+                                    let len = assoc_path.segments.len() - 1;\n+                                    // Build `<Bar = RhsTy>`.\n+                                    let arg = AngleBracketedArg::Constraint(AssocTyConstraint {\n+                                        id: rustc_ast::node_id::DUMMY_NODE_ID,\n+                                        ident: *ident,\n+                                        kind: AssocTyConstraintKind::Equality {\n+                                            ty: predicate.rhs_ty.clone(),\n+                                        },\n+                                        span: ident.span,\n+                                    });\n+                                    // Add `<Bar = RhsTy>` to `Foo`.\n+                                    match &mut assoc_path.segments[len].args {\n+                                        Some(args) => match args.deref_mut() {\n+                                            GenericArgs::Parenthesized(_) => continue,\n+                                            GenericArgs::AngleBracketed(args) => {\n+                                                args.args.push(arg);\n+                                            }\n+                                        },\n+                                        empty_args => {\n+                                            *empty_args = AngleBracketedArgs {\n+                                                span: ident.span,\n+                                                args: vec![arg],\n+                                            }\n+                                            .into();\n+                                        }\n+                                    }\n+                                    err.span_suggestion_verbose(\n+                                        predicate.span,\n+                                        &format!(\n+                                            \"if `{}` is an associated type you're trying to set, \\\n+                                            use the associated type binding syntax\",\n+                                            ident\n+                                        ),\n+                                        format!(\n+                                            \"{}: {}\",\n+                                            param,\n+                                            pprust::path_to_string(&assoc_path)\n+                                        ),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                                _ => {}\n+                            };\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+    err.note(\n+        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\",\n+    );\n+    err.emit();\n+}\n+\n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {\n     let mut validator = AstValidator {\n         session,"}, {"sha": "e6d673b30f7bcfe319c340f60255d7e83568acc1", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -2626,8 +2626,42 @@ impl Node<'_> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })\n             | Node::ImplItem(ImplItem { generics, .. })\n-            | Node::Item(Item { kind: ItemKind::Fn(_, generics, _), .. }) => Some(generics),\n+            | Node::Item(Item {\n+                kind:\n+                    ItemKind::Trait(_, _, generics, ..)\n+                    | ItemKind::Impl { generics, .. }\n+                    | ItemKind::Fn(_, generics, _),\n+                ..\n+            }) => Some(generics),\n             _ => None,\n         }\n     }\n+\n+    pub fn hir_id(&self) -> Option<HirId> {\n+        match self {\n+            Node::Item(Item { hir_id, .. })\n+            | Node::ForeignItem(ForeignItem { hir_id, .. })\n+            | Node::TraitItem(TraitItem { hir_id, .. })\n+            | Node::ImplItem(ImplItem { hir_id, .. })\n+            | Node::Field(StructField { hir_id, .. })\n+            | Node::AnonConst(AnonConst { hir_id, .. })\n+            | Node::Expr(Expr { hir_id, .. })\n+            | Node::Stmt(Stmt { hir_id, .. })\n+            | Node::Ty(Ty { hir_id, .. })\n+            | Node::Binding(Pat { hir_id, .. })\n+            | Node::Pat(Pat { hir_id, .. })\n+            | Node::Arm(Arm { hir_id, .. })\n+            | Node::Block(Block { hir_id, .. })\n+            | Node::Local(Local { hir_id, .. })\n+            | Node::MacroDef(MacroDef { hir_id, .. })\n+            | Node::Lifetime(Lifetime { hir_id, .. })\n+            | Node::Param(Param { hir_id, .. })\n+            | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n+            Node::TraitRef(TraitRef { hir_ref_id, .. }) => Some(*hir_ref_id),\n+            Node::PathSegment(PathSegment { hir_id, .. }) => *hir_id,\n+            Node::Variant(Variant { id, .. }) => Some(*id),\n+            Node::Ctor(variant) => variant.ctor_hir_id(),\n+            Node::Crate(_) | Node::Visibility(_) => None,\n+        }\n+    }\n }"}, {"sha": "613d66d59c55bc81e8c8dfa6a6e5321be675333b", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 183, "deletions": 1, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -2,7 +2,12 @@\n \n use crate::ty::sty::InferTy;\n use crate::ty::TyKind::*;\n-use crate::ty::TyS;\n+use crate::ty::{TyCtxt, TyS};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_span::{BytePos, Span};\n \n impl<'tcx> TyS<'tcx> {\n     /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n@@ -67,3 +72,180 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    def_id: Option<DefId>,\n+) -> bool {\n+    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+\n+    let param = if let Some(param) = param {\n+        param\n+    } else {\n+        return false;\n+    };\n+\n+    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n+    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n+    let msg_restrict_type_further =\n+        format!(\"consider further restricting type parameter `{}`\", param_name);\n+\n+    if def_id == tcx.lang_items().sized_trait() {\n+        // Type parameters are already `Sized` by default.\n+        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n+        return true;\n+    }\n+    let mut suggest_restrict = |span| {\n+        err.span_suggestion_verbose(\n+            span,\n+            MSG_RESTRICT_BOUND_FURTHER,\n+            format!(\" + {}\", constraint),\n+            Applicability::MachineApplicable,\n+        );\n+    };\n+\n+    if param_name.starts_with(\"impl \") {\n+        // If there's an `impl Trait` used in argument position, suggest\n+        // restricting it:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             help: consider further restricting this bound with `+ Bar`\n+        //\n+        // Suggestion for tools in this case is:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             replace with: `impl Foo + Bar`\n+\n+        suggest_restrict(param.span.shrink_to_hi());\n+        return true;\n+    }\n+\n+    if generics.where_clause.predicates.is_empty()\n+        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n+        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n+        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+    {\n+        if let Some(bounds_span) = param.bounds_span() {\n+            // If user has provided some bounds, suggest restricting them:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //             ---\n+            //             |\n+            //             help: consider further restricting this bound with `+ Bar`\n+            //\n+            // Suggestion for tools in this case is:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //          --\n+            //          |\n+            //          replace with: `T: Bar +`\n+            suggest_restrict(bounds_span.shrink_to_hi());\n+        } else {\n+            // If user hasn't provided any bounds, suggest adding a new one:\n+            //\n+            //   fn foo<T>(t: T) { ... }\n+            //          - help: consider restricting this type parameter with `T: Foo`\n+            err.span_suggestion_verbose(\n+                param.span.shrink_to_hi(),\n+                &msg_restrict_type,\n+                format!(\": {}\", constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        true\n+    } else {\n+        // This part is a bit tricky, because using the `where` clause user can\n+        // provide zero, one or many bounds for the same type parameter, so we\n+        // have following cases to consider:\n+        //\n+        // 1) When the type parameter has been provided zero bounds\n+        //\n+        //    Message:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //             - help: consider restricting this type parameter with `where X: Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //                                           - insert: `, X: Bar`\n+        //\n+        //\n+        // 2) When the type parameter has been provided one bound\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^^^^^\n+        //                            |\n+        //                            help: consider further restricting this bound with `+ Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^\n+        //                            |\n+        //                            replace with: `T: Bar +`\n+        //\n+        //\n+        // 3) When the type parameter has been provided many bounds\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //             - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //                                          - insert: `, T: Zar`\n+\n+        let mut param_spans = Vec::new();\n+\n+        for predicate in generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                span, bounded_ty, ..\n+            }) = predicate\n+            {\n+                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                    if let Some(segment) = path.segments.first() {\n+                        if segment.ident.to_string() == param_name {\n+                            param_spans.push(span);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n+        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n+        let mut trailing_comma = false;\n+        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n+            trailing_comma = snippet.ends_with(',');\n+        }\n+        let where_clause_span = if trailing_comma {\n+            let hi = where_clause_span.hi();\n+            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n+        } else {\n+            where_clause_span.shrink_to_hi()\n+        };\n+\n+        match &param_spans[..] {\n+            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+            _ => {\n+                err.span_suggestion_verbose(\n+                    where_clause_span,\n+                    &msg_restrict_type_further,\n+                    format!(\", {}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        true\n+    }\n+}"}, {"sha": "f3b6a53dfeb824e84251291065fa76d74e33f747", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -1,4 +1,5 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::{self, BoundRegion, Region, Ty, TyCtxt};\n use rustc_ast::ast;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n@@ -401,8 +402,46 @@ impl<'tcx> TyCtxt<'tcx> {\n                     (ty::Projection(_), ty::Projection(_)) => {\n                         db.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(_), ty::Projection(_)) | (ty::Projection(_), ty::Param(_)) => {\n-                        db.note(\"you might be missing a type parameter or trait bound\");\n+                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p)) => {\n+                        let generics = self.generics_of(body_owner_def_id);\n+                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n+                        if !sp.contains(p_span) {\n+                            db.span_label(p_span, \"this type parameter\");\n+                        }\n+                        let hir = self.hir();\n+                        let mut note = true;\n+                        if let Some(generics) = generics\n+                            .type_param(p, self)\n+                            .def_id\n+                            .as_local()\n+                            .map(|id| hir.as_local_hir_id(id))\n+                            .and_then(|id| self.hir().find(self.hir().get_parent_node(id)))\n+                            .as_ref()\n+                            .and_then(|node| node.generics())\n+                        {\n+                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n+                            // FIXME: extract this logic for use in other diagnostics.\n+                            let trait_ref = proj.trait_ref(self);\n+                            let path =\n+                                self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n+                            let item_name = self.item_name(proj.item_def_id);\n+                            let path = if path.ends_with('>') {\n+                                format!(\"{}, {} = {}>\", &path[..path.len() - 1], item_name, p)\n+                            } else {\n+                                format!(\"{}<{} = {}>\", path, item_name, p)\n+                            };\n+                            note = !suggest_constraining_type_param(\n+                                self,\n+                                generics,\n+                                db,\n+                                &format!(\"{}\", proj.self_ty()),\n+                                &path,\n+                                None,\n+                            );\n+                        }\n+                        if note {\n+                            db.note(\"you might be missing a type parameter or trait bound\");\n+                        }\n                     }\n                     (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n                     | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {"}, {"sha": "14a094b9d5273f6fefa7796001c68729144d3df1", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -10,10 +10,9 @@ use rustc_middle::mir::{\n     FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::suggest_constraining_type_param;\n \n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MoveOutIndex, MovePathIndex};"}, {"sha": "19ed6b50f92a624ba00d7082927edbce4b6d17ac", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 182, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -15,17 +15,16 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::{Node, QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::SubtypePredicate;\n use rustc_middle::ty::{\n-    self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n+    TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::{BytePos, ExpnKind, Span, DUMMY_SP};\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1700,180 +1699,3 @@ impl ArgKind {\n         }\n     }\n }\n-\n-/// Suggest restricting a type param with a new bound.\n-pub fn suggest_constraining_type_param(\n-    tcx: TyCtxt<'_>,\n-    generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n-    param_name: &str,\n-    constraint: &str,\n-    def_id: Option<DefId>,\n-) -> bool {\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n-\n-    let param = if let Some(param) = param {\n-        param\n-    } else {\n-        return false;\n-    };\n-\n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n-    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n-    let msg_restrict_type_further =\n-        format!(\"consider further restricting type parameter `{}`\", param_name);\n-\n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        return true;\n-    }\n-    let mut suggest_restrict = |span| {\n-        err.span_suggestion_verbose(\n-            span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\" + {}\", constraint),\n-            Applicability::MachineApplicable,\n-        );\n-    };\n-\n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        suggest_restrict(param.span.shrink_to_hi());\n-        return true;\n-    }\n-\n-    if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-    {\n-        if let Some(bounds_span) = param.bounds_span() {\n-            // If user has provided some bounds, suggest restricting them:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n-            //             |\n-            //             help: consider further restricting this bound with `+ Bar`\n-            //\n-            // Suggestion for tools in this case is:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-            suggest_restrict(bounds_span.shrink_to_hi());\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-            err.span_suggestion_verbose(\n-                param.span.shrink_to_hi(),\n-                &msg_restrict_type,\n-                format!(\": {}\", constraint),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-\n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-\n-        let mut param_spans = Vec::new();\n-\n-        for predicate in generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                span, bounded_ty, ..\n-            }) = predicate\n-            {\n-                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                    if let Some(segment) = path.segments.first() {\n-                        if segment.ident.to_string() == param_name {\n-                            param_spans.push(span);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n-        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n-        let mut trailing_comma = false;\n-        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n-            trailing_comma = snippet.ends_with(',');\n-        }\n-        let where_clause_span = if trailing_comma {\n-            let hi = where_clause_span.hi();\n-            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n-        } else {\n-            where_clause_span.shrink_to_hi()\n-        };\n-\n-        match &param_spans[..] {\n-            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-            _ => {\n-                err.span_suggestion_verbose(\n-                    where_clause_span,\n-                    &msg_restrict_type_further,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        true\n-    }\n-}"}, {"sha": "74dd47a91c2790e9b86bb840fd55aa1ef0defe59", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -3,7 +3,6 @@ use super::{\n };\n \n use crate::infer::InferCtxt;\n-use crate::traits::error_reporting::suggest_constraining_type_param;\n \n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n@@ -13,7 +12,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n+    TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};"}, {"sha": "e6cbc8ab7230c79795c8180c72730fcba3019329", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 78, "deletions": 14, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -253,6 +253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() && !rhs_ty.references_error() {\n                     let source_map = self.tcx.sess.source_map();\n+\n                     match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(\n@@ -317,59 +318,74 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.kind {\n-                                    // FIXME: point to span of param\n-                                    err.note(&format!(\n-                                        \"`{}` might need a bound for `{}`\",\n-                                        lhs_ty, missing_trait\n-                                    ));\n+                                } else if let ty::Param(p) = lhs_ty.kind {\n+                                    suggest_constraining_param(\n+                                        self.tcx,\n+                                        self.body_id,\n+                                        &mut err,\n+                                        lhs_ty,\n+                                        rhs_ty,\n+                                        missing_trait,\n+                                        p,\n+                                        false,\n+                                    );\n                                 } else if !suggested_deref {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n                             err.emit();\n                         }\n                         IsAssign::No => {\n-                            let (message, missing_trait) = match op.node {\n+                            let (message, missing_trait, use_output) = match op.node {\n                                 hir::BinOpKind::Add => (\n                                     format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Add\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Sub => (\n                                     format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Sub\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Mul => (\n                                     format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Mul\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Div => (\n                                     format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Div\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Rem => (\n                                     format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Rem\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitAnd => (\n                                     format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitAnd\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitXor => (\n                                     format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitXor\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitOr => (\n                                     format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitOr\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Shl => (\n                                     format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Shl\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Shr => (\n                                     format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Shr\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n                                     format!(\n@@ -378,6 +394,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     Some(\"std::cmp::PartialEq\"),\n+                                    false,\n                                 ),\n                                 hir::BinOpKind::Lt\n                                 | hir::BinOpKind::Le\n@@ -389,6 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     Some(\"std::cmp::PartialOrd\"),\n+                                    false,\n                                 ),\n                                 _ => (\n                                     format!(\n@@ -397,6 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     None,\n+                                    false,\n                                 ),\n                             };\n                             let mut err = struct_span_err!(\n@@ -459,12 +478,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.kind {\n-                                    // FIXME: point to span of param\n-                                    err.note(&format!(\n-                                        \"`{}` might need a bound for `{}`\",\n-                                        lhs_ty, missing_trait\n-                                    ));\n+                                } else if let ty::Param(p) = lhs_ty.kind {\n+                                    suggest_constraining_param(\n+                                        self.tcx,\n+                                        self.body_id,\n+                                        &mut err,\n+                                        lhs_ty,\n+                                        rhs_ty,\n+                                        missing_trait,\n+                                        p,\n+                                        use_output,\n+                                    );\n                                 } else if !suggested_deref && !involves_fn {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n@@ -911,3 +935,43 @@ fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_tra\n         }\n     }\n }\n+\n+fn suggest_constraining_param(\n+    tcx: TyCtxt<'_>,\n+    body_id: hir::HirId,\n+    mut err: &mut DiagnosticBuilder<'_>,\n+    lhs_ty: Ty<'_>,\n+    rhs_ty: Ty<'_>,\n+    missing_trait: &str,\n+    p: ty::ParamTy,\n+    set_output: bool,\n+) {\n+    let hir = tcx.hir();\n+    let msg = &format!(\"`{}` might need a bound for `{}`\", lhs_ty, missing_trait);\n+    // Try to find the def-id and details for the parameter p. We have only the index,\n+    // so we have to find the enclosing function's def-id, then look through its declared\n+    // generic parameters to get the declaration.\n+    let def_id = hir.body_owner_def_id(hir::BodyId { hir_id: body_id });\n+    let generics = tcx.generics_of(def_id);\n+    let param_def_id = generics.type_param(&p, tcx).def_id;\n+    if let Some(generics) = param_def_id\n+        .as_local()\n+        .map(|id| hir.as_local_hir_id(id))\n+        .and_then(|id| hir.find(hir.get_parent_item(id)))\n+        .as_ref()\n+        .and_then(|node| node.generics())\n+    {\n+        let output = if set_output { format!(\"<Output = {}>\", rhs_ty) } else { String::new() };\n+        suggest_constraining_type_param(\n+            tcx,\n+            generics,\n+            &mut err,\n+            &format!(\"{}\", lhs_ty),\n+            &format!(\"{}{}\", missing_trait, output),\n+            None,\n+        );\n+    } else {\n+        let span = tcx.def_span(param_def_id);\n+        err.span_label(span, msg);\n+    }\n+}"}, {"sha": "b9468b3330b44e5b4a794fe2a7b2824b837dbe34", "filename": "src/test/ui/generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -2,11 +2,16 @@ error[E0271]: type mismatch resolving `for<'a> <<T as Baz>::Baa<'a> as std::ops:\n   --> $DIR/construct_with_other_type.rs:19:9\n    |\n LL | impl<T> Baz for T where T: Foo {\n-   |         ^^^ expected type parameter `T`, found associated type\n+   |      -  ^^^ expected type parameter `T`, found associated type\n+   |      |\n+   |      this type parameter\n    |\n    = note: expected associated type `<T as Foo>::Bar<'_, 'static>`\n               found associated type `<<T as Baz>::Quux<'_> as Foo>::Bar<'_, 'static>`\n-   = note: you might be missing a type parameter or trait bound\n+help: consider further restricting this bound\n+   |\n+LL | impl<T> Baz for T where T: Foo + Baz<Quux = T> {\n+   |                                ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "364d2388741b0e9664970e9a17bd4ba6a94a3136", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -0,0 +1,46 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add + std::ops::Add<Output = B>> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+struct E<B>(B);\n+\n+impl<B: Add> Add for E<B> where B: Add<Output = B>, B: std::ops::Add<Output = B> {\n+    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ffafff5e9f586d2543061aaaa616eec501040f8a", "filename": "src/test/ui/generic-associated-types/missing-bounds.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -0,0 +1,46 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+struct E<B>(B);\n+\n+impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n+    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "50536fdaca96e25d04359a9ac5bf05d8c5ee4194", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -0,0 +1,77 @@\n+error: equality constraints are not yet supported in `where` clauses\n+  --> $DIR/missing-bounds.rs:37:33\n+   |\n+LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n+   |\n+   = note: see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+help: if `Output` is an associated type you're trying to set, use the associated type binding syntax\n+   |\n+LL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n+   |                                 ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:11:11\n+   |\n+LL | impl<B> Add for A<B> where B: Add {\n+   |      - this type parameter\n+...\n+LL |         A(self.0 + rhs.0)\n+   |           ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:21:14\n+   |\n+LL | impl<B: Add> Add for C<B> {\n+   |      - this type parameter\n+...\n+LL |         Self(self.0 + rhs.0)\n+   |              ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B: Add + std::ops::Add<Output = B>> Add for C<B> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0369]: cannot add `B` to `B`\n+  --> $DIR/missing-bounds.rs:31:21\n+   |\n+LL |         Self(self.0 + rhs.0)\n+   |              ------ ^ ----- B\n+   |              |\n+   |              B\n+   |\n+help: consider restricting type parameter `B`\n+   |\n+LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:42:14\n+   |\n+LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n+   |      - this type parameter\n+...\n+LL |         Self(self.0 + rhs.0)\n+   |              ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting type parameter `B`\n+   |\n+LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B, B: std::ops::Add<Output = B> {\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "f53489a99f3b4edc32eae4d81086f84d86c0d63d", "filename": "src/test/ui/issues/issue-20005.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -5,12 +5,18 @@ LL | trait From<Src> {\n    |            --- required by this bound in `From`\n ...\n LL |     ) -> <Dst as From<Self>>::Result where Dst: From<Self> {\n-   |                                                 ^^^^^^^^^^- help: consider further restricting `Self`: `, Self: std::marker::Sized`\n-   |                                                 |\n-   |                                                 doesn't have a size known at compile-time\n+   |                                                 ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     ) -> <Dst as From<Self>>::Result where Dst: From<Self>, Self: std::marker::Sized  {\n+   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait From<Src: ?Sized> {\n+   |               ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d5cbcf786bf1abfe5426869412c4f3fd01871c89", "filename": "src/test/ui/issues/issue-24204.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -7,7 +7,9 @@ LL |     type A: MultiDispatch<Self::B, O = Self>;\n    |                                    -------- required by this bound in `Trait`\n ...\n LL | fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-   |            ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |         -  ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |         |\n+   |         this type parameter\n    |\n    = note: expected type parameter `T`\n              found associated type `<<T as Trait>::A as MultiDispatch<i32>>::O`"}, {"sha": "a428ff7e91faddb04e0a80a4136be4bcf0dfff91", "filename": "src/test/ui/issues/issue-6738.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -6,7 +6,10 @@ LL |         self.x += v.x;\n    |         |\n    |         cannot use `+=` on type `T`\n    |\n-   = note: `T` might need a bound for `std::ops::AddAssign`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::AddAssign> Foo<T> {\n+   |       ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "30df1261cefa1f56e9f23a3245f57fa400b12627", "filename": "src/test/ui/type/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce14d6db5a7a7896d2fc7713a482cc3b810b9102/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr?ref=ce14d6db5a7a7896d2fc7713a482cc3b810b9102", "patch": "@@ -6,7 +6,10 @@ LL |     let z = x + y;\n    |             |\n    |             T\n    |\n-   = note: `T` might need a bound for `std::ops::Add`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn foo<T: std::ops::Add<Output = T>>(x: T, y: T) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n   --> $DIR/missing_trait_impl.rs:9:5\n@@ -16,7 +19,10 @@ LL |     x += x;\n    |     |\n    |     cannot use `+=` on type `T`\n    |\n-   = note: `T` might need a bound for `std::ops::AddAssign`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn bar<T: std::ops::AddAssign>(x: T) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}