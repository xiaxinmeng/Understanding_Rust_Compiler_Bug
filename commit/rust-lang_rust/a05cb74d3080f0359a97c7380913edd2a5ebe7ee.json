{"sha": "a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "node_id": "C_kwDOAAsO6NoAKGEwNWNiNzRkMzA4MGYwMzU5YTk3YzczODA5MTNlZGQyYTVlYmU3ZWU", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-07-08T09:29:10Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-08-16T22:34:51Z"}, "message": "Enhance `needless_borrow` to consider trait implementations", "tree": {"sha": "c61f554ec3f3d0d1ddc7c1ad733b4e69acc664bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c61f554ec3f3d0d1ddc7c1ad733b4e69acc664bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "html_url": "https://github.com/rust-lang/rust/commit/a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "048e4d004aa2335393b805d690035ff3db5549c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/048e4d004aa2335393b805d690035ff3db5549c9", "html_url": "https://github.com/rust-lang/rust/commit/048e4d004aa2335393b805d690035ff3db5549c9"}], "stats": {"total": 612, "additions": 559, "deletions": 53}, "files": [{"sha": "e38704701ea64a947af8d894ab6945e53f698131", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 276, "deletions": 31, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -1,24 +1,31 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, ty_sig, variant_of_res};\n-use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n+use clippy_utils::ty::{contains_ty, expr_sig, is_copy, peel_mid_ty_refs, ty_sig, variant_of_res};\n+use clippy_utils::{fn_def_id, get_parent_expr, is_lint_allowed, meets_msrv, msrvs, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy, GenericArg, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n-    TraitItemKind, TyKind, UnOp,\n+    self as hir, def_id::DefId, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy,\n+    GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n+    Path, QPath, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n+use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Binder, BoundVariableKind, List, Ty, TyCtxt, TypeVisitable, TypeckResults};\n+use rustc_middle::ty::{\n+    self, subst::Subst, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n+    ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n+};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n-use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use std::collections::VecDeque;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -151,13 +158,27 @@ pub struct Dereferencing {\n     /// been finished. Note we can't lint at the end of every body as they can be nested within each\n     /// other.\n     current_body: Option<BodyId>,\n+\n     /// The list of locals currently being checked by the lint.\n     /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n     /// This is needed for or patterns where one of the branches can be linted, but another can not\n     /// be.\n     ///\n     /// e.g. `m!(x) | Foo::Bar(ref x)`\n     ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n+\n+    // `IntoIterator` for arrays requires Rust 1.53.\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Dereferencing {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Dereferencing::default()\n+        }\n+    }\n }\n \n struct StateData {\n@@ -170,6 +191,7 @@ struct StateData {\n struct DerefedBorrow {\n     count: usize,\n     msg: &'static str,\n+    snip_expr: Option<HirId>,\n }\n \n enum State {\n@@ -250,7 +272,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n         match (self.state.take(), kind) {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n-                let (position, adjustments) = walk_parents(cx, expr);\n+                let (position, adjustments) = walk_parents(cx, expr, self.msrv);\n \n                 match kind {\n                     RefOp::Deref => {\n@@ -331,20 +353,23 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         let deref_msg =\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n+                        let impl_msg = \"the borrowed expression implements the required traits\";\n \n-                        let (required_refs, msg) = if position.can_auto_borrow() {\n-                            (1, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        let (required_refs, msg, snip_expr) = if position.can_auto_borrow() {\n+                            (1, if deref_count == 1 { borrow_msg } else { deref_msg }, None)\n+                        } else if let Position::ImplArg(hir_id) = position {\n+                            (0, impl_msg, Some(hir_id))\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n                             if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n-                                (3, deref_msg)\n+                                (3, deref_msg, None)\n                             } else {\n-                                (2, deref_msg)\n+                                (2, deref_msg, None)\n                             }\n                         } else {\n-                            (2, deref_msg)\n+                            (2, deref_msg, None)\n                         };\n \n                         if deref_count >= required_refs {\n@@ -354,6 +379,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n                                     msg,\n+                                    snip_expr,\n                                 }),\n                                 StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n@@ -510,7 +536,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             spans: vec![pat.span],\n                             app,\n                             replacements: vec![(pat.span, snip.into())],\n-                            hir_id: pat.hir_id\n+                            hir_id: pat.hir_id,\n                         }),\n                     );\n                 }\n@@ -542,6 +568,8 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n             self.current_body = None;\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n fn try_parse_ref_op<'tcx>(\n@@ -594,6 +622,7 @@ enum Position {\n     /// The method is defined on a reference type. e.g. `impl Foo for &T`\n     MethodReceiverRefImpl,\n     Callee,\n+    ImplArg(HirId),\n     FieldAccess(Symbol),\n     Postfix,\n     Deref,\n@@ -630,7 +659,7 @@ impl Position {\n             | Self::Callee\n             | Self::FieldAccess(_)\n             | Self::Postfix => PREC_POSTFIX,\n-            Self::Deref => PREC_PREFIX,\n+            Self::ImplArg(_) | Self::Deref => PREC_PREFIX,\n             Self::DerefStable(p, _) | Self::ReborrowStable(p) | Self::Other(p) => p,\n         }\n     }\n@@ -639,8 +668,12 @@ impl Position {\n /// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n /// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n /// locations as those follow different rules.\n-#[allow(clippy::too_many_lines)]\n-fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n+#[expect(clippy::too_many_lines)]\n+fn walk_parents<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) -> (Position, &'tcx [Adjustment<'tcx>]) {\n     let mut adjustments = [].as_slice();\n     let mut precedence = 0i8;\n     let ctxt = e.span.ctxt();\n@@ -732,13 +765,20 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .iter()\n                     .position(|arg| arg.hir_id == child_id)\n                     .zip(expr_sig(cx, func))\n-                    .and_then(|(i, sig)| sig.input_with_hir(i))\n-                    .map(|(hir_ty, ty)| match hir_ty {\n-                        // Type inference for closures can depend on how they're called. Only go by the explicit\n-                        // types here.\n-                        Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n-                        None => ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n-                            .position_for_arg(),\n+                    .and_then(|(i, sig)| {\n+                        sig.input_with_hir(i).map(|(hir_ty, ty)| match hir_ty {\n+                            // Type inference for closures can depend on how they're called. Only go by the explicit\n+                            // types here.\n+                            Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n+                            None => {\n+                                if let ty::Param(param_ty) = ty.skip_binder().kind() {\n+                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                } else {\n+                                    ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                                        .position_for_arg()\n+                                }\n+                            },\n+                        })\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -779,12 +819,17 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            ty_auto_deref_stability(\n-                                cx,\n-                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                precedence,\n-                            )\n-                            .position_for_arg()\n+                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n+                            if let ty::Param(param_ty) = ty.kind() {\n+                                needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                            } else {\n+                                ty_auto_deref_stability(\n+                                    cx,\n+                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                    precedence,\n+                                )\n+                                .position_for_arg()\n+                            }\n                         }\n                     })\n                 },\n@@ -946,6 +991,205 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+// Checks whether:\n+// * child is an expression of the form `&e` in an argument position requiring an `impl Trait`\n+// * `e`'s type implements `Trait` and is copyable\n+// If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n+//   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n+// be moved, but it cannot be.\n+fn needless_borrow_impl_arg_position<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    parent: &Expr<'tcx>,\n+    arg_index: usize,\n+    param_ty: ParamTy,\n+    mut expr: &Expr<'tcx>,\n+    precedence: i8,\n+    msrv: Option<RustcVersion>,\n+) -> Position {\n+    let destruct_trait_def_id = cx.tcx.lang_items().destruct_trait();\n+    let sized_trait_def_id = cx.tcx.lang_items().sized_trait();\n+\n+    let Some(callee_def_id) = fn_def_id(cx, parent) else { return Position::Other(precedence) };\n+    let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+    let substs_with_expr_ty = cx\n+        .typeck_results()\n+        .node_substs(if let ExprKind::Call(callee, _) = parent.kind {\n+            callee.hir_id\n+        } else {\n+            parent.hir_id\n+        });\n+\n+    let predicates = cx.tcx.param_env(callee_def_id).caller_bounds();\n+    let projection_predicates = predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+                Some(projection_predicate)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    let mut trait_with_ref_mut_self_method = false;\n+\n+    // If no traits were found, or only the `Destruct`, `Sized`, or `Any` traits were found, return.\n+    if predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+                && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n+            {\n+                Some(trait_predicate.trait_ref.def_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .inspect(|trait_def_id| {\n+            trait_with_ref_mut_self_method |= has_ref_mut_self_method(cx, *trait_def_id);\n+        })\n+        .all(|trait_def_id| {\n+            Some(trait_def_id) == destruct_trait_def_id\n+                || Some(trait_def_id) == sized_trait_def_id\n+                || cx.tcx.is_diagnostic_item(sym::Any, trait_def_id)\n+        })\n+    {\n+        return Position::Other(precedence);\n+    }\n+\n+    // `substs_with_referent_ty` can be constructed outside of `check_referent` because the same\n+    // elements are modified each time `check_referent` is called.\n+    let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n+\n+    let mut check_referent = |referent| {\n+        let referent_ty = cx.typeck_results().expr_ty(referent);\n+\n+        if !is_copy(cx, referent_ty) {\n+            return false;\n+        }\n+\n+        // https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+        if trait_with_ref_mut_self_method && !matches!(referent_ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+            return false;\n+        }\n+\n+        if !replace_types(\n+            cx,\n+            param_ty,\n+            referent_ty,\n+            fn_sig,\n+            arg_index,\n+            &projection_predicates,\n+            &mut substs_with_referent_ty,\n+        ) {\n+            return false;\n+        }\n+\n+        predicates.iter().all(|predicate| {\n+            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+                && cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_predicate.trait_ref.def_id)\n+                && let ty::Param(param_ty) = trait_predicate.self_ty().kind()\n+                && let GenericArgKind::Type(ty) = substs_with_referent_ty[param_ty.index as usize].unpack()\n+                && ty.is_array()\n+                && !meets_msrv(msrv, msrvs::ARRAY_INTO_ITERATOR)\n+            {\n+                return false;\n+            }\n+\n+            let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n+            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+            cx.tcx\n+                .infer_ctxt()\n+                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+        })\n+    };\n+\n+    let mut needless_borrow = false;\n+    while let ExprKind::AddrOf(_, _, referent) = expr.kind {\n+        if !check_referent(referent) {\n+            break;\n+        }\n+        expr = referent;\n+        needless_borrow = true;\n+    }\n+\n+    if needless_borrow {\n+        Position::ImplArg(expr.hir_id)\n+    } else {\n+        Position::Other(precedence)\n+    }\n+}\n+\n+fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n+    cx.tcx\n+        .associated_items(trait_def_id)\n+        .in_definition_order()\n+        .any(|assoc_item| {\n+            if assoc_item.fn_has_self_parameter {\n+                let self_ty = cx.tcx.fn_sig(assoc_item.def_id).skip_binder().inputs()[0];\n+                matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Mut))\n+            } else {\n+                false\n+            }\n+        })\n+}\n+\n+// Iteratively replaces `param_ty` with `new_ty` in `substs`, and similarly for each resulting\n+// projected type that is a type parameter. Returns `false` if replacing the types would have an\n+// effect on the function signature beyond substituting `new_ty` for `param_ty`.\n+// See: https://github.com/rust-lang/rust-clippy/pull/9136#discussion_r927212757\n+fn replace_types<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_ty: ParamTy,\n+    new_ty: Ty<'tcx>,\n+    fn_sig: FnSig<'tcx>,\n+    arg_index: usize,\n+    projection_predicates: &[ProjectionPredicate<'tcx>],\n+    substs: &mut [ty::GenericArg<'tcx>],\n+) -> bool {\n+    let mut replaced = BitSet::new_empty(substs.len());\n+\n+    let mut deque = VecDeque::with_capacity(substs.len());\n+    deque.push_back((param_ty, new_ty));\n+\n+    while let Some((param_ty, new_ty)) = deque.pop_front() {\n+        // If `replaced.is_empty()`, then `param_ty` and `new_ty` are those initially passed in.\n+        if !fn_sig\n+            .inputs_and_output\n+            .iter()\n+            .enumerate()\n+            .all(|(i, ty)| (replaced.is_empty() && i == arg_index) || !contains_ty(ty, param_ty.to_ty(cx.tcx)))\n+        {\n+            return false;\n+        }\n+\n+        substs[param_ty.index as usize] = ty::GenericArg::from(new_ty);\n+\n+        // The `replaced.insert(...)` check provides some protection against infinite loops.\n+        if replaced.insert(param_ty.index) {\n+            for projection_predicate in projection_predicates {\n+                if projection_predicate.projection_ty.self_ty() == param_ty.to_ty(cx.tcx)\n+                    && let ty::Term::Ty(term_ty) = projection_predicate.term\n+                    && let ty::Param(term_param_ty) = term_ty.kind()\n+                {\n+                    let item_def_id = projection_predicate.projection_ty.item_def_id;\n+                    let assoc_item = cx.tcx.associated_item(item_def_id);\n+                    let projection = cx.tcx\n+                        .mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(new_ty, &[]));\n+\n+                    if let Ok(projected_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, projection)\n+                        && substs[term_param_ty.index as usize] != ty::GenericArg::from(projected_ty)\n+                    {\n+                        deque.push_back((*term_param_ty, projected_ty));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    true\n+}\n+\n struct TyPosition<'tcx> {\n     position: Position,\n     ty: Option<Ty<'tcx>>,\n@@ -1084,7 +1328,8 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n         },\n         State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n-            let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            let snip_expr = state.snip_expr.map_or(expr, |hir_id| cx.tcx.hir().expect_expr(hir_id));\n+            let (snip, snip_is_macro) = snippet_with_context(cx, snip_expr.span, data.span.ctxt(), \"..\", &mut app);\n             span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n                 let calls_field = matches!(expr.kind, ExprKind::Field(..)) && matches!(data.position, Position::Callee);\n                 let sugg = if !snip_is_macro"}, {"sha": "521739c28ff64a39cacfd2f7f3f292b231886e25", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -821,7 +821,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(verbose_file_reads::VerboseFileReads));\n     store.register_late_pass(|| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n     store.register_late_pass(|| Box::new(unnamed_address::UnnamedAddress));\n-    store.register_late_pass(|| Box::new(dereference::Dereferencing::default()));\n+    store.register_late_pass(move || Box::new(dereference::Dereferencing::new(msrv)));\n     store.register_late_pass(|| Box::new(option_if_let_else::OptionIfLetElse));\n     store.register_late_pass(|| Box::new(future_not_send::FutureNotSend));\n     store.register_late_pass(|| Box::new(if_let_mutex::IfLetMutex));"}, {"sha": "e4624167ad0c07012a43fba0e8a55d385d330332", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -6,9 +6,8 @@ use clippy_utils::ty::{\n     contains_ty, get_associated_type, get_iterator_item_ty, implements_trait, is_copy, is_type_diagnostic_item,\n     peel_mid_ty_refs,\n };\n-use clippy_utils::{meets_msrv, msrvs};\n-\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -373,25 +372,15 @@ fn get_input_traits_and_projections<'tcx>(\n ) -> (Vec<TraitPredicate<'tcx>>, Vec<ProjectionPredicate<'tcx>>) {\n     let mut trait_predicates = Vec::new();\n     let mut projection_predicates = Vec::new();\n-    for (predicate, _) in cx.tcx.predicates_of(callee_def_id).predicates.iter() {\n-        // `substs` should have 1 + n elements. The first is the type on the left hand side of an\n-        // `as`. The remaining n are trait parameters.\n-        let is_input_substs = |substs: SubstsRef<'tcx>| {\n-            if_chain! {\n-                if let Some(arg) = substs.iter().next();\n-                if let GenericArgKind::Type(arg_ty) = arg.unpack();\n-                if arg_ty == input;\n-                then { true } else { false }\n-            }\n-        };\n+    for predicate in cx.tcx.param_env(callee_def_id).caller_bounds() {\n         match predicate.kind().skip_binder() {\n             PredicateKind::Trait(trait_predicate) => {\n-                if is_input_substs(trait_predicate.trait_ref.substs) {\n+                if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n             },\n             PredicateKind::Projection(projection_predicate) => {\n-                if is_input_substs(projection_predicate.projection_ty.substs) {\n+                if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n             },"}, {"sha": "7fa0046a267bb9a9916aaab989b42c4ebbdbb611", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -13,7 +13,7 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,62,0 { BOOL_THEN_SOME }\n-    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN }\n+    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }\n     1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n     1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n     1,50,0 { BOOL_THEN }"}, {"sha": "8cf93bd248173ee93cef0b0ec5e87815e11f370b", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(lint_reasons)]\n+#![feature(custom_inner_attributes, lint_reasons)]\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables, clippy::unnecessary_mut_passed)]\n@@ -127,6 +127,20 @@ fn main() {\n             0\n         }\n     }\n+\n+    let _ = std::process::Command::new(\"ls\").args([\"-a\", \"-l\"]).status().unwrap();\n+    let _ = std::path::Path::new(\".\").join(\".\");\n+    deref_target_is_x(X);\n+    multiple_constraints([[\"\"]]);\n+    multiple_constraints_normalizes_to_same(X, X);\n+    let _ = Some(\"\").unwrap_or(\"\");\n+\n+    only_sized(&\"\"); // Don't lint. `Sized` is only bound\n+    let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n+    let _ = Box::new(&\"\"); // Don't lint. Type parameter appears in return type\n+    ref_as_ref_path(&\"\"); // Don't lint. Argument type is not a type parameter\n+    refs_only(&()); // Don't lint. `&T` implements trait, but `T` doesn't\n+    multiple_constraints_normalizes_to_different(&[[\"\"]], &[\"\"]); // Don't lint. Projected type appears in arguments\n }\n \n #[allow(clippy::needless_borrowed_reference)]\n@@ -183,3 +197,104 @@ mod issue9160 {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+struct X;\n+\n+impl std::ops::Deref for X {\n+    type Target = X;\n+    fn deref(&self) -> &Self::Target {\n+        self\n+    }\n+}\n+\n+fn deref_target_is_x<T>(_: T)\n+where\n+    T: std::ops::Deref<Target = X>,\n+{\n+}\n+\n+fn multiple_constraints<T, U, V, X, Y>(_: T)\n+where\n+    T: IntoIterator<Item = U> + IntoIterator<Item = X>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+    X: IntoIterator<Item = Y>,\n+    Y: AsRef<std::ffi::OsStr>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_same<T, U, V>(_: T, _: V)\n+where\n+    T: std::ops::Deref<Target = U>,\n+    U: std::ops::Deref<Target = V>,\n+{\n+}\n+\n+fn only_sized<T>(_: T) {}\n+\n+fn ref_as_ref_path<T: 'static>(_: &'static T)\n+where\n+    &'static T: AsRef<std::path::Path>,\n+{\n+}\n+\n+trait RefsOnly {\n+    type Referent;\n+}\n+\n+impl<T> RefsOnly for &T {\n+    type Referent = T;\n+}\n+\n+fn refs_only<T, U>(_: T)\n+where\n+    T: RefsOnly<Referent = U>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_different<T, U, V>(_: T, _: U)\n+where\n+    T: IntoIterator<Item = U>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+{\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+#[allow(dead_code)]\n+mod copyable_iterator {\n+    #[derive(Clone, Copy)]\n+    struct Iter;\n+    impl Iterator for Iter {\n+        type Item = ();\n+        fn next(&mut self) -> Option<Self::Item> {\n+            None\n+        }\n+    }\n+    fn takes_iter(_: impl Iterator) {}\n+    fn dont_warn(mut x: Iter) {\n+        takes_iter(&mut x);\n+    }\n+    fn warn(mut x: &mut Iter) {\n+        takes_iter(&mut x)\n+    }\n+}\n+\n+mod under_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.52.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}\n+\n+mod meets_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.53.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args([\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}"}, {"sha": "fd9b2a11df96f1cba7dcd147dd7d6ca96774435d", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(lint_reasons)]\n+#![feature(custom_inner_attributes, lint_reasons)]\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables, clippy::unnecessary_mut_passed)]\n@@ -127,6 +127,20 @@ fn main() {\n             0\n         }\n     }\n+\n+    let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    let _ = std::path::Path::new(\".\").join(&&\".\");\n+    deref_target_is_x(&X);\n+    multiple_constraints(&[[\"\"]]);\n+    multiple_constraints_normalizes_to_same(&X, X);\n+    let _ = Some(\"\").unwrap_or(&\"\");\n+\n+    only_sized(&\"\"); // Don't lint. `Sized` is only bound\n+    let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n+    let _ = Box::new(&\"\"); // Don't lint. Type parameter appears in return type\n+    ref_as_ref_path(&\"\"); // Don't lint. Argument type is not a type parameter\n+    refs_only(&()); // Don't lint. `&T` implements trait, but `T` doesn't\n+    multiple_constraints_normalizes_to_different(&[[\"\"]], &[\"\"]); // Don't lint. Projected type appears in arguments\n }\n \n #[allow(clippy::needless_borrowed_reference)]\n@@ -183,3 +197,104 @@ mod issue9160 {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+struct X;\n+\n+impl std::ops::Deref for X {\n+    type Target = X;\n+    fn deref(&self) -> &Self::Target {\n+        self\n+    }\n+}\n+\n+fn deref_target_is_x<T>(_: T)\n+where\n+    T: std::ops::Deref<Target = X>,\n+{\n+}\n+\n+fn multiple_constraints<T, U, V, X, Y>(_: T)\n+where\n+    T: IntoIterator<Item = U> + IntoIterator<Item = X>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+    X: IntoIterator<Item = Y>,\n+    Y: AsRef<std::ffi::OsStr>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_same<T, U, V>(_: T, _: V)\n+where\n+    T: std::ops::Deref<Target = U>,\n+    U: std::ops::Deref<Target = V>,\n+{\n+}\n+\n+fn only_sized<T>(_: T) {}\n+\n+fn ref_as_ref_path<T: 'static>(_: &'static T)\n+where\n+    &'static T: AsRef<std::path::Path>,\n+{\n+}\n+\n+trait RefsOnly {\n+    type Referent;\n+}\n+\n+impl<T> RefsOnly for &T {\n+    type Referent = T;\n+}\n+\n+fn refs_only<T, U>(_: T)\n+where\n+    T: RefsOnly<Referent = U>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_different<T, U, V>(_: T, _: U)\n+where\n+    T: IntoIterator<Item = U>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+{\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+#[allow(dead_code)]\n+mod copyable_iterator {\n+    #[derive(Clone, Copy)]\n+    struct Iter;\n+    impl Iterator for Iter {\n+        type Item = ();\n+        fn next(&mut self) -> Option<Self::Item> {\n+            None\n+        }\n+    }\n+    fn takes_iter(_: impl Iterator) {}\n+    fn dont_warn(mut x: Iter) {\n+        takes_iter(&mut x);\n+    }\n+    fn warn(mut x: &mut Iter) {\n+        takes_iter(&mut x)\n+    }\n+}\n+\n+mod under_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.52.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}\n+\n+mod meets_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.53.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}"}, {"sha": "5af68706d4ba579311308199b560dbfcad016ad2", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a05cb74d3080f0359a97c7380913edd2a5ebe7ee/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=a05cb74d3080f0359a97c7380913edd2a5ebe7ee", "patch": "@@ -120,17 +120,59 @@ error: this expression creates a reference which is immediately dereferenced by\n LL |     (&&5).foo();\n    |     ^^^^^ help: change this to: `(&5)`\n \n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:131:51\n+   |\n+LL |     let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+   |                                                   ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:132:44\n+   |\n+LL |     let _ = std::path::Path::new(\".\").join(&&\".\");\n+   |                                            ^^^^^ help: change this to: `\".\"`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:133:23\n+   |\n+LL |     deref_target_is_x(&X);\n+   |                       ^^ help: change this to: `X`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:134:26\n+   |\n+LL |     multiple_constraints(&[[\"\"]]);\n+   |                          ^^^^^^^ help: change this to: `[[\"\"]]`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:135:45\n+   |\n+LL |     multiple_constraints_normalizes_to_same(&X, X);\n+   |                                             ^^ help: change this to: `X`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:136:32\n+   |\n+LL |     let _ = Some(\"\").unwrap_or(&\"\");\n+   |                                ^^^ help: change this to: `\"\"`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:173:13\n+  --> $DIR/needless_borrow.rs:187:13\n    |\n LL |             (&self.f)()\n    |             ^^^^^^^^^ help: change this to: `(self.f)`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:182:13\n+  --> $DIR/needless_borrow.rs:196:13\n    |\n LL |             (&mut self.f)()\n    |             ^^^^^^^^^^^^^ help: change this to: `(self.f)`\n \n-error: aborting due to 22 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:298:55\n+   |\n+LL |         let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+   |                                                       ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n+\n+error: aborting due to 29 previous errors\n "}]}