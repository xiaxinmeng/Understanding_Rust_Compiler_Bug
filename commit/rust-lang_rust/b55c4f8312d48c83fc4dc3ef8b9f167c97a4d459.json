{"sha": "b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459", "node_id": "C_kwDOAAsO6NoAKGI1NWM0ZjgzMTJkNDhjODNmYzRkYzNlZjhiOWYxNjdjOTdhNGQ0NTk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-07T16:34:11Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-08T14:40:38Z"}, "message": "Separate checking rvalue from evaluation.", "tree": {"sha": "3d01bc6d08613600570e05ddfb8beca615b42fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d01bc6d08613600570e05ddfb8beca615b42fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459", "html_url": "https://github.com/rust-lang/rust/commit/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f00be8b77bbbc614662a1e8349463aca45c01e62", "url": "https://api.github.com/repos/rust-lang/rust/commits/f00be8b77bbbc614662a1e8349463aca45c01e62", "html_url": "https://github.com/rust-lang/rust/commit/f00be8b77bbbc614662a1e8349463aca45c01e62"}], "stats": {"total": 217, "additions": 104, "deletions": 113}, "files": [{"sha": "6e590981357e91169af6704caf9d1952920feff2", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459", "patch": "@@ -470,7 +470,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn const_prop(&mut self, rvalue: &Rvalue<'tcx>, place: Place<'tcx>) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -527,7 +527,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.eval_rvalue_with_identities(rvalue, place)\n+        Some(())\n     }\n \n     // Attempt to use algebraic identities to eliminate constant expressions\n@@ -595,7 +595,16 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }))\n     }\n \n-    fn replace_with_const(&mut self, rval: &mut Rvalue<'tcx>, value: &OpTy<'tcx>) {\n+    fn replace_with_const(&mut self, place: Place<'tcx>, rval: &mut Rvalue<'tcx>) {\n+        // This will return None if the above `const_prop` invocation only \"wrote\" a\n+        // type whose creation requires no write. E.g. a generator whose initial state\n+        // consists solely of uninitialized memory (so it doesn't capture any locals).\n+        let Some(ref value) = self.get_const(place) else { return };\n+        if !self.should_const_prop(value) {\n+            return;\n+        }\n+        trace!(\"replacing {:?}={:?} with {:?}\", place, rval, value);\n+\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n             match c.literal {\n                 ConstantKind::Ty(c) if matches!(c.kind(), ConstKind::Unevaluated(..)) => {}\n@@ -688,6 +697,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    fn ensure_not_propagated(&mut self, local: Local) {\n+        if cfg!(debug_assertions) {\n+            assert!(\n+                self.get_const(local.into()).is_none()\n+                    || self\n+                        .layout_of(self.local_decls[local].ty)\n+                        .map_or(true, |layout| layout.is_zst()),\n+                \"failed to remove values for `{local:?}`, value={:?}\",\n+                self.get_const(local.into()),\n+            )\n+        }\n+    }\n }\n \n /// The mode that `ConstProp` is allowed to run in for a given `Local`.\n@@ -827,44 +849,23 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.eval_constant(constant);\n     }\n \n-    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n-        trace!(\"visit_statement: {:?}\", statement);\n-\n-        // Recurse into statement before applying the assignment.\n-        self.super_statement(statement, location);\n-\n-        match statement.kind {\n-            StatementKind::Assign(box (place, ref mut rval)) => {\n-                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, place) {\n-                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                    // type whose creation requires no write. E.g. a generator whose initial state\n-                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                    if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n-                        trace!(\"replacing {:?} with {:?}\", rval, value);\n-                        self.replace_with_const(rval, value);\n-                        if can_const_prop == ConstPropMode::FullConstProp\n-                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                        {\n-                            trace!(\"propagated into {:?}\", place);\n-                        }\n-                    }\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n-                                Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                        }\n-                        ConstPropMode::FullConstProp => {}\n-                    }\n+    fn visit_assign(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        rvalue: &mut Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_assign(place, rvalue, location);\n+\n+        let Some(()) = self.check_rvalue(rvalue) else { return };\n+\n+        match self.ecx.machine.can_const_prop[place.local] {\n+            // Do nothing if the place is indirect.\n+            _ if place.is_indirect() => {}\n+            ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n+                if let Some(()) = self.eval_rvalue_with_identities(rvalue, *place) {\n+                    self.replace_with_const(*place, rvalue);\n                 } else {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n                     // from here on, does not know about the previous value.\n@@ -884,18 +885,28 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     Self::remove_const(&mut self.ecx, place.local);\n                 }\n             }\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+\n+        // Recurse into statement before applying the assignment.\n+        self.super_statement(statement, location);\n+\n+        match statement.kind {\n             StatementKind::SetDiscriminant { ref place, .. } => {\n                 match self.ecx.machine.can_const_prop[place.local] {\n+                    // Do nothing if the place is indirect.\n+                    _ if place.is_indirect() => {}\n+                    ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n                         if self.ecx.statement(statement).is_ok() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n-                    ConstPropMode::NoPropagation => {\n-                        Self::remove_const(&mut self.ecx, place.local);\n-                    }\n                 }\n             }\n             StatementKind::StorageLive(local) => {\n@@ -958,30 +969,17 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         self.super_basic_block_data(block, data);\n \n-        let ensure_not_propagated = |this: &mut Self, local: Local| {\n-            if cfg!(debug_assertions) {\n-                assert!(\n-                    this.get_const(local.into()).is_none()\n-                        || this\n-                            .layout_of(this.local_decls[local].ty)\n-                            .map_or(true, |layout| layout.is_zst()),\n-                    \"failed to remove values for `{local:?}`, value={:?}\",\n-                    this.get_const(local.into()),\n-                )\n-            }\n-        };\n-\n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n         let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n         for (local, &mode) in can_const_prop.iter_enumerated() {\n             match mode {\n                 ConstPropMode::FullConstProp => {}\n-                ConstPropMode::NoPropagation => ensure_not_propagated(self, local),\n+                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n                 ConstPropMode::OnlyInsideOwnBlock => {\n                     Self::remove_const(&mut self.ecx, local);\n-                    ensure_not_propagated(self, local);\n+                    self.ensure_not_propagated(local);\n                 }\n             }\n         }"}, {"sha": "28198781fd97f5370b4c0cfb4f7545a118b3674b", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=b55c4f8312d48c83fc4dc3ef8b9f167c97a4d459", "patch": "@@ -405,12 +405,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn const_prop(\n-        &mut self,\n-        rvalue: &Rvalue<'tcx>,\n-        source_info: SourceInfo,\n-        place: Place<'tcx>,\n-    ) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, source_info: SourceInfo) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -486,7 +481,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+        Some(())\n+    }\n+\n+    fn ensure_not_propagated(&mut self, local: Local) {\n+        if cfg!(debug_assertions) {\n+            assert!(\n+                self.get_const(local.into()).is_none()\n+                    || self\n+                        .layout_of(self.local_decls[local].ty)\n+                        .map_or(true, |layout| layout.is_zst()),\n+                \"failed to remove values for `{local:?}`, value={:?}\",\n+                self.get_const(local.into()),\n+            )\n+        }\n     }\n }\n \n@@ -507,35 +515,21 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.eval_constant(constant, self.source_info.unwrap());\n     }\n \n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        trace!(\"visit_statement: {:?}\", statement);\n-        let source_info = statement.source_info;\n-        self.source_info = Some(source_info);\n-\n-        // Recurse into statement before applying the assignment.\n-        self.super_statement(statement, location);\n-\n-        match statement.kind {\n-            StatementKind::Assign(box (place, ref rval)) => {\n-                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, source_info, place) {\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n-                                Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                        }\n-                        ConstPropMode::FullConstProp => {}\n-                    }\n-                } else {\n+    fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_assign(place, rvalue, location);\n+\n+        let source_info = self.source_info.unwrap();\n+        let Some(()) = self.check_rvalue(rvalue, source_info) else { return };\n+\n+        match self.ecx.machine.can_const_prop[place.local] {\n+            // Do nothing if the place is indirect.\n+            _ if place.is_indirect() => {}\n+            ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n+                if self\n+                    .use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n+                    .is_none()\n+                {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n                     // from here on, does not know about the previous value.\n                     // This is important in case we have\n@@ -554,8 +548,23 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     Self::remove_const(&mut self.ecx, place.local);\n                 }\n             }\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+        let source_info = statement.source_info;\n+        self.source_info = Some(source_info);\n+\n+        // Recurse into statement before applying the assignment.\n+        self.super_statement(statement, location);\n+\n+        match statement.kind {\n             StatementKind::SetDiscriminant { ref place, .. } => {\n                 match self.ecx.machine.can_const_prop[place.local] {\n+                    // Do nothing if the place is indirect.\n+                    _ if place.is_indirect() => {}\n+                    ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n                         if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n                         {\n@@ -564,9 +573,6 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                             Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n-                    ConstPropMode::NoPropagation => {\n-                        Self::remove_const(&mut self.ecx, place.local);\n-                    }\n                 }\n             }\n             StatementKind::StorageLive(local) => {\n@@ -682,30 +688,17 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.super_basic_block_data(block, data);\n \n-        let ensure_not_propagated = |this: &mut Self, local: Local| {\n-            if cfg!(debug_assertions) {\n-                assert!(\n-                    this.get_const(local.into()).is_none()\n-                        || this\n-                            .layout_of(this.local_decls[local].ty)\n-                            .map_or(true, |layout| layout.is_zst()),\n-                    \"failed to remove values for `{local:?}`, value={:?}\",\n-                    this.get_const(local.into()),\n-                )\n-            }\n-        };\n-\n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n         let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n         for (local, &mode) in can_const_prop.iter_enumerated() {\n             match mode {\n                 ConstPropMode::FullConstProp => {}\n-                ConstPropMode::NoPropagation => ensure_not_propagated(self, local),\n+                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n                 ConstPropMode::OnlyInsideOwnBlock => {\n                     Self::remove_const(&mut self.ecx, local);\n-                    ensure_not_propagated(self, local);\n+                    self.ensure_not_propagated(local);\n                 }\n             }\n         }"}]}