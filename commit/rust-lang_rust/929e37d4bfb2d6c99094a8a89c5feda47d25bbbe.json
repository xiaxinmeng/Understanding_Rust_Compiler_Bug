{"sha": "929e37d4bfb2d6c99094a8a89c5feda47d25bbbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOWUzN2Q0YmZiMmQ2Yzk5MDk0YThhODljNWZlZGE0N2QyNWJiYmU=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-08-04T17:15:48Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-08-04T17:15:48Z"}, "message": "Revert renaming of \"memory block\"", "tree": {"sha": "2e5196e238cf1db99e02a942908a6cc638fe3a91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e5196e238cf1db99e02a942908a6cc638fe3a91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/929e37d4bfb2d6c99094a8a89c5feda47d25bbbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/929e37d4bfb2d6c99094a8a89c5feda47d25bbbe", "html_url": "https://github.com/rust-lang/rust/commit/929e37d4bfb2d6c99094a8a89c5feda47d25bbbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/929e37d4bfb2d6c99094a8a89c5feda47d25bbbe/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab9362ad9a9b4b93951ccb577224dda367923226", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9362ad9a9b4b93951ccb577224dda367923226", "html_url": "https://github.com/rust-lang/rust/commit/ab9362ad9a9b4b93951ccb577224dda367923226"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "d2c3e47865046c53c30e082e8e6d476c0e5a4534", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/929e37d4bfb2d6c99094a8a89c5feda47d25bbbe/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929e37d4bfb2d6c99094a8a89c5feda47d25bbbe/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=929e37d4bfb2d6c99094a8a89c5feda47d25bbbe", "patch": "@@ -42,13 +42,13 @@ impl fmt::Display for AllocErr {\n ///\n /// ### Currently allocated memory\n ///\n-/// Some of the methods require that a memory slice be *currently allocated* via an allocator. This\n+/// Some of the methods require that a memory block be *currently allocated* via an allocator. This\n /// means that:\n ///\n-/// * the starting address for that memory slice was previously returned by [`alloc`], [`grow`], or\n+/// * the starting address for that memory block was previously returned by [`alloc`], [`grow`], or\n ///   [`shrink`], and\n ///\n-/// * the memory slice has not been subsequently deallocated, where slices are either deallocated\n+/// * the memory block has not been subsequently deallocated, where blocks are either deallocated\n ///   directly by being passed to [`dealloc`] or were changed by being passed to [`grow`] or\n ///   [`shrink`] that returns `Ok`. If `grow` or `shrink` have returned `Err`, the passed pointer\n ///   remains valid.\n@@ -60,38 +60,38 @@ impl fmt::Display for AllocErr {\n ///\n /// ### Memory fitting\n ///\n-/// Some of the methods require that a layout *fit* a memory slice. What it means for a layout to\n-/// \"fit\" a memory slice means (or equivalently, for a memory slice to \"fit\" a layout) is that the\n+/// Some of the methods require that a layout *fit* a memory block. What it means for a layout to\n+/// \"fit\" a memory block means (or equivalently, for a memory block to \"fit\" a layout) is that the\n /// following conditions must hold:\n ///\n-/// * The slice must be allocated with the same alignment as [`layout.align()`], and\n+/// * The block must be allocated with the same alignment as [`layout.align()`], and\n ///\n /// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n-///   - `min` is the size of the layout most recently used to allocate the slice, and\n+///   - `min` is the size of the layout most recently used to allocate the block, and\n ///   - `max` is the latest actual size returned from [`alloc`], [`grow`], or [`shrink`].\n ///\n /// [`layout.align()`]: Layout::align\n /// [`layout.size()`]: Layout::size\n ///\n /// # Safety\n ///\n-/// * Memory slices returned from an allocator must point to valid memory and retain their validity\n+/// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n ///   until the instance and all of its clones are dropped,\n ///\n-/// * cloning or moving the allocator must not invalidate memory slices returned from this\n+/// * cloning or moving the allocator must not invalidate memory blocks returned from this\n ///   allocator. A cloned allocator must behave like the same allocator, and\n ///\n-/// * any pointer to a memory slice which is [*currently allocated*] may be passed to any other\n+/// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n ///   method of the allocator.\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    /// Attempts to allocate a slice of memory.\n+    /// Attempts to allocate a block of memory.\n     ///\n     /// On success, returns a [`NonNull<[u8]>`] meeting the size and alignment guarantees of `layout`.\n     ///\n-    /// The returned slice may have a larger size than specified by `layout.size()`, and may or may\n+    /// The returned block may have a larger size than specified by `layout.size()`, and may or may\n     /// not have its contents initialized.\n     ///\n     /// [`NonNull<[u8]>`]: NonNull\n@@ -133,18 +133,18 @@ pub unsafe trait AllocRef {\n         Ok(ptr)\n     }\n \n-    /// Deallocates the memory slice referenced by `ptr`.\n+    /// Deallocates the memory referenced by `ptr`.\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must denote a slice of memory [*currently allocated*] via this allocator, and\n-    /// * `layout` must [*fit*] that slice of memory.\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n+    /// * `layout` must [*fit*] that block of memory.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n-    /// Attempts to extend the memory slice.\n+    /// Attempts to extend the memory block.\n     ///\n     /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n@@ -293,27 +293,27 @@ pub unsafe trait AllocRef {\n         }\n     }\n \n-    /// Attempts to shrink the memory slice.\n+    /// Attempts to shrink the memory block.\n     ///\n     /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n     /// allocation referenced by `ptr` to fit the new layout.\n     ///\n-    /// If this returns `Ok`, then ownership of the memory slice referenced by `ptr` has been\n+    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n     /// transferred to this allocator. The memory may or may not have been freed, and should be\n     /// considered unusable unless it was transferred back to the caller again via the\n     /// return value of this method.\n     ///\n-    /// If this method returns `Err`, then ownership of the memory slice has not been transferred to\n-    /// this allocator, and the contents of the memory slice are unaltered.\n+    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n+    /// this allocator, and the contents of the memory block are unaltered.\n     ///\n     /// [`NonNull<[u8]>`]: NonNull\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must denote a slice of memory [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] that slice of memory (The `new_size` argument need not fit it.), and\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n     /// * `new_size` must be smaller than or equal to `layout.size()`.\n     // Note: We can't require that `new_size` is strictly smaller than `layout.size()` because of ZSTs.\n     // alternative: `new_size` must be smaller than `layout.size()` or both are zero"}]}