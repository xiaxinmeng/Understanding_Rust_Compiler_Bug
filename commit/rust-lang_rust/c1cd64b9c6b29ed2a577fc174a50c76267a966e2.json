{"sha": "c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "node_id": "C_kwDOAAsO6NoAKGMxY2Q2NGI5YzZiMjllZDJhNTc3ZmMxNzRhNTBjNzYyNjdhOTY2ZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T22:15:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T22:15:53Z"}, "message": "Auto merge of #8117 - hotate29:issue7320, r=camsteffen\n\nupdate: ```Sugg::not()``` replacing the comparison operator. #7320\n\nfixes #7320\n\nchangelog: ```needless_bool```: Changed to make a smart suggestion.", "tree": {"sha": "ac76694aa0fac911bd2da7f00fa84548deb0fca9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac76694aa0fac911bd2da7f00fa84548deb0fca9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "html_url": "https://github.com/rust-lang/rust/commit/c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16ef044e72ef8db08307c4fdaa1c0dd8b24d0861", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ef044e72ef8db08307c4fdaa1c0dd8b24d0861", "html_url": "https://github.com/rust-lang/rust/commit/16ef044e72ef8db08307c4fdaa1c0dd8b24d0861"}, {"sha": "a172439f29301d7c34645406f439f064edc58d69", "url": "https://api.github.com/repos/rust-lang/rust/commits/a172439f29301d7c34645406f439f064edc58d69", "html_url": "https://github.com/rust-lang/rust/commit/a172439f29301d7c34645406f439f064edc58d69"}], "stats": {"total": 435, "additions": 307, "deletions": 128}, "files": [{"sha": "4fefd9fd18a0a00abdbdb95b7729c84686418e11", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -356,7 +356,7 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n             if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n             if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n-                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, lmul_lhs, \"..\"), Sugg::hir(cx, rmul_lhs, \"..\")));\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, lmul_lhs, \"..\").maybe_par(), Sugg::hir(cx, rmul_lhs, \"..\")));\n             }\n         }\n \n@@ -379,7 +379,7 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n             if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), rargs_1);\n             if Int(2) == lvalue && Int(2) == rvalue;\n             then {\n-                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, largs_0, \"..\"), Sugg::hir(cx, rargs_0, \"..\")));\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, largs_0, \"..\").maybe_par(), Sugg::hir(cx, rargs_0, \"..\")));\n             }\n         }\n     }"}, {"sha": "c62fa5e998bd475da630f949ac6198c71ce02a97", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Pat, PatKind, StmtKind}\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n+use std::fmt::Display;\n use std::iter::Iterator;\n \n /// Checks for for loops that sequentially copy items from one slice-like\n@@ -108,7 +109,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     src: &IndexExpr<'_>,\n ) -> String {\n     fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        if offset.as_str() == \"0\" {\n+        if offset.to_string() == \"0\" {\n             sugg::EMPTY.into()\n         } else {\n             offset\n@@ -123,7 +124,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n             if let Some(arg) = len_args.get(0);\n             if path_to_local(arg) == path_to_local(base);\n             then {\n-                if sugg.as_str() == end_str {\n+                if sugg.to_string() == end_str {\n                     sugg::EMPTY.into()\n                 } else {\n                     sugg\n@@ -147,7 +148,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n             print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n             print_limit(\n                 end,\n-                end_str.as_str(),\n+                end_str.to_string().as_str(),\n                 idx_expr.base,\n                 apply_offset(&end_str, &idx_expr.idx_offset),\n             )\n@@ -159,7 +160,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n                 print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n                 print_limit(\n                     end,\n-                    end_str.as_str(),\n+                    end_str.to_string().as_str(),\n                     idx_expr.base,\n                     apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n                 )\n@@ -202,12 +203,13 @@ fn build_manual_memcpy_suggestion<'tcx>(\n #[derive(Clone)]\n struct MinifyingSugg<'a>(Sugg<'a>);\n \n-impl<'a> MinifyingSugg<'a> {\n-    fn as_str(&self) -> &str {\n-        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n-        s.as_ref()\n+impl Display for MinifyingSugg<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        self.0.fmt(f)\n     }\n+}\n \n+impl<'a> MinifyingSugg<'a> {\n     fn into_sugg(self) -> Sugg<'a> {\n         self.0\n     }\n@@ -222,7 +224,7 @@ impl<'a> From<Sugg<'a>> for MinifyingSugg<'a> {\n impl std::ops::Add for &MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (\"0\", _) => rhs.clone(),\n             (_, \"0\") => self.clone(),\n             (_, _) => (&self.0 + &rhs.0).into(),\n@@ -233,7 +235,7 @@ impl std::ops::Add for &MinifyingSugg<'static> {\n impl std::ops::Sub for &MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (_, \"0\") => self.clone(),\n             (\"0\", _) => (-rhs.0.clone()).into(),\n             (x, y) if x == y => sugg::ZERO.into(),\n@@ -245,7 +247,7 @@ impl std::ops::Sub for &MinifyingSugg<'static> {\n impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (\"0\", _) => rhs.clone(),\n             (_, \"0\") => self,\n             (_, _) => (self.0 + &rhs.0).into(),\n@@ -256,7 +258,7 @@ impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (_, \"0\") => self,\n             (\"0\", _) => (-rhs.0.clone()).into(),\n             (x, y) if x == y => sugg::ZERO.into(),"}, {"sha": "778d49cb4b6ed1634cc1024bfad5e3d6883376bb", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -187,14 +187,14 @@ impl<'tcx> LateLintPass<'tcx> for BoolComparison {\n                 BinOpKind::Eq => {\n                     let true_case = Some((|h| h, \"equality checks against true are unnecessary\"));\n                     let false_case = Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"equality checks against false can be replaced by a negation\",\n                     ));\n                     check_comparison(cx, e, true_case, false_case, true_case, false_case, ignore_no_literal);\n                 },\n                 BinOpKind::Ne => {\n                     let true_case = Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"inequality checks against true can be replaced by a negation\",\n                     ));\n                     let false_case = Some((|h| h, \"inequality checks against false are unnecessary\"));\n@@ -206,27 +206,27 @@ impl<'tcx> LateLintPass<'tcx> for BoolComparison {\n                     ignore_case,\n                     Some((|h| h, \"greater than checks against false are unnecessary\")),\n                     Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"less than comparison against true can be replaced by a negation\",\n                     )),\n                     ignore_case,\n                     Some((\n-                        |l: Sugg<'_>, r: Sugg<'_>| (!l).bit_and(&r),\n+                        |l: Sugg<'tcx>, r: Sugg<'tcx>| (!l).bit_and(&r),\n                         \"order comparisons between booleans can be simplified\",\n                     )),\n                 ),\n                 BinOpKind::Gt => check_comparison(\n                     cx,\n                     e,\n                     Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"less than comparison against true can be replaced by a negation\",\n                     )),\n                     ignore_case,\n                     ignore_case,\n                     Some((|h| h, \"greater than checks against false are unnecessary\")),\n                     Some((\n-                        |l: Sugg<'_>, r: Sugg<'_>| l.bit_and(&(!r)),\n+                        |l: Sugg<'tcx>, r: Sugg<'tcx>| l.bit_and(&(!r)),\n                         \"order comparisons between booleans can be simplified\",\n                     )),\n                 ),"}, {"sha": "a1e67c33abf14668e0b207a94eb482866d12c4f6", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -378,8 +378,8 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 span,\n                 \"an inclusive range would be more readable\",\n                 |diag| {\n-                    let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n-                    let end = Sugg::hir(cx, y, \"y\");\n+                    let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").maybe_par().to_string());\n+                    let end = Sugg::hir(cx, y, \"y\").maybe_par();\n                     if let Some(is_wrapped) = &snippet_opt(cx, span) {\n                         if is_wrapped.starts_with('(') && is_wrapped.ends_with(')') {\n                             diag.span_suggestion(\n@@ -415,8 +415,8 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 expr.span,\n                 \"an exclusive range would be more readable\",\n                 |diag| {\n-                    let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n-                    let end = Sugg::hir(cx, y, \"y\");\n+                    let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").maybe_par().to_string());\n+                    let end = Sugg::hir(cx, y, \"y\").maybe_par();\n                     diag.span_suggestion(\n                         expr.span,\n                         \"use\","}, {"sha": "92662c59226a2e300f38ac8378fe9f932540ce98", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 163, "deletions": 88, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -1,9 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::source::{\n-    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n-};\n+use crate::source::{snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite};\n use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n@@ -33,7 +31,7 @@ pub enum Sugg<'a> {\n     MaybeParen(Cow<'a, str>),\n     /// A binary operator expression, including `as`-casts and explicit type\n     /// coercion.\n-    BinOp(AssocOp, Cow<'a, str>),\n+    BinOp(AssocOp, Cow<'a, str>, Cow<'a, str>),\n }\n \n /// Literal constant `0`, for convenience.\n@@ -46,7 +44,8 @@ pub const EMPTY: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"\"));\n impl Display for Sugg<'_> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match *self {\n-            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => s.fmt(f),\n+            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) => s.fmt(f),\n+            Sugg::BinOp(op, ref lhs, ref rhs) => binop_to_string(op, lhs, rhs).fmt(f),\n         }\n     }\n }\n@@ -55,10 +54,8 @@ impl Display for Sugg<'_> {\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n     pub fn hir_opt(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Self> {\n-        snippet_opt(cx, expr.span).map(|snippet| {\n-            let snippet = Cow::Owned(snippet);\n-            Self::hir_from_snippet(expr, snippet)\n-        })\n+        let get_snippet = |span| snippet(cx, span, \"\");\n+        snippet_opt(cx, expr.span).map(|_| Self::hir_from_snippet(expr, get_snippet))\n     }\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n@@ -93,9 +90,8 @@ impl<'a> Sugg<'a> {\n \n     /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n     pub fn hir_with_macro_callsite(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n-        let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n-\n-        Self::hir_from_snippet(expr, snippet)\n+        let get_snippet = |span| snippet_with_macro_callsite(cx, span, default);\n+        Self::hir_from_snippet(expr, get_snippet)\n     }\n \n     /// Same as `hir`, but first walks the span up to the given context. This will result in the\n@@ -112,24 +108,26 @@ impl<'a> Sugg<'a> {\n         default: &'a str,\n         applicability: &mut Applicability,\n     ) -> Self {\n-        let (snippet, in_macro) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n-\n-        if in_macro {\n-            Sugg::NonParen(snippet)\n+        if expr.span.ctxt() == ctxt {\n+            Self::hir_from_snippet(expr, |span| snippet(cx, span, default))\n         } else {\n-            Self::hir_from_snippet(expr, snippet)\n+            let snip = snippet_with_applicability(cx, expr.span, default, applicability);\n+            Sugg::NonParen(snip)\n         }\n     }\n \n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n-    fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n+    fn hir_from_snippet(expr: &hir::Expr<'_>, get_snippet: impl Fn(Span) -> Cow<'a, str>) -> Self {\n         if let Some(range) = higher::Range::hir(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,\n             };\n-            return Sugg::BinOp(op, snippet);\n+            let start = range.start.map_or(\"\".into(), |expr| get_snippet(expr.span));\n+            let end = range.end.map_or(\"\".into(), |expr| get_snippet(expr.span));\n+\n+            return Sugg::BinOp(op, start, end);\n         }\n \n         match expr.kind {\n@@ -139,7 +137,7 @@ impl<'a> Sugg<'a> {\n             | hir::ExprKind::Let(..)\n             | hir::ExprKind::Closure(..)\n             | hir::ExprKind::Unary(..)\n-            | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            | hir::ExprKind::Match(..) => Sugg::MaybeParen(get_snippet(expr.span)),\n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Yield(..)\n             | hir::ExprKind::Array(..)\n@@ -160,23 +158,33 @@ impl<'a> Sugg<'a> {\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Tup(..)\n             | hir::ExprKind::DropTemps(_)\n-            | hir::ExprKind::Err => Sugg::NonParen(snippet),\n-            hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-            hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-            hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(op.node.into()), snippet),\n-            hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-            hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+            | hir::ExprKind::Err => Sugg::NonParen(get_snippet(expr.span)),\n+            hir::ExprKind::Assign(lhs, rhs, _) => {\n+                Sugg::BinOp(AssocOp::Assign, get_snippet(lhs.span), get_snippet(rhs.span))\n+            },\n+            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n+                Sugg::BinOp(hirbinop2assignop(op), get_snippet(lhs.span), get_snippet(rhs.span))\n+            },\n+            hir::ExprKind::Binary(op, lhs, rhs) => Sugg::BinOp(\n+                AssocOp::from_ast_binop(op.node.into()),\n+                get_snippet(lhs.span),\n+                get_snippet(rhs.span),\n+            ),\n+            hir::ExprKind::Cast(lhs, ty) => Sugg::BinOp(AssocOp::As, get_snippet(lhs.span), get_snippet(ty.span)),\n+            hir::ExprKind::Type(lhs, ty) => Sugg::BinOp(AssocOp::Colon, get_snippet(lhs.span), get_snippet(ty.span)),\n         }\n     }\n \n     /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use rustc_ast::ast::RangeLimits;\n \n-        let snippet = if expr.span.from_expansion() {\n-            snippet_with_macro_callsite(cx, expr.span, default)\n-        } else {\n-            snippet(cx, expr.span, default)\n+        let get_whole_snippet = || {\n+            if expr.span.from_expansion() {\n+                snippet_with_macro_callsite(cx, expr.span, default)\n+            } else {\n+                snippet(cx, expr.span, default)\n+            }\n         };\n \n         match expr.kind {\n@@ -186,7 +194,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::If(..)\n             | ast::ExprKind::Let(..)\n             | ast::ExprKind::Unary(..)\n-            | ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            | ast::ExprKind::Match(..) => Sugg::MaybeParen(get_whole_snippet()),\n             ast::ExprKind::Async(..)\n             | ast::ExprKind::Block(..)\n             | ast::ExprKind::Break(..)\n@@ -215,14 +223,42 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::Array(..)\n             | ast::ExprKind::While(..)\n             | ast::ExprKind::Await(..)\n-            | ast::ExprKind::Err => Sugg::NonParen(snippet),\n-            ast::ExprKind::Range(.., RangeLimits::HalfOpen) => Sugg::BinOp(AssocOp::DotDot, snippet),\n-            ast::ExprKind::Range(.., RangeLimits::Closed) => Sugg::BinOp(AssocOp::DotDotEq, snippet),\n-            ast::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-            ast::ExprKind::AssignOp(op, ..) => Sugg::BinOp(astbinop2assignop(op), snippet),\n-            ast::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(op.node), snippet),\n-            ast::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-            ast::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+            | ast::ExprKind::Err => Sugg::NonParen(get_whole_snippet()),\n+            ast::ExprKind::Range(ref lhs, ref rhs, RangeLimits::HalfOpen) => Sugg::BinOp(\n+                AssocOp::DotDot,\n+                lhs.as_ref().map_or(\"\".into(), |lhs| snippet(cx, lhs.span, default)),\n+                rhs.as_ref().map_or(\"\".into(), |rhs| snippet(cx, rhs.span, default)),\n+            ),\n+            ast::ExprKind::Range(ref lhs, ref rhs, RangeLimits::Closed) => Sugg::BinOp(\n+                AssocOp::DotDotEq,\n+                lhs.as_ref().map_or(\"\".into(), |lhs| snippet(cx, lhs.span, default)),\n+                rhs.as_ref().map_or(\"\".into(), |rhs| snippet(cx, rhs.span, default)),\n+            ),\n+            ast::ExprKind::Assign(ref lhs, ref rhs, _) => Sugg::BinOp(\n+                AssocOp::Assign,\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, rhs.span, default),\n+            ),\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => Sugg::BinOp(\n+                astbinop2assignop(op),\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, rhs.span, default),\n+            ),\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => Sugg::BinOp(\n+                AssocOp::from_ast_binop(op.node),\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, rhs.span, default),\n+            ),\n+            ast::ExprKind::Cast(ref lhs, ref ty) => Sugg::BinOp(\n+                AssocOp::As,\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, ty.span, default),\n+            ),\n+            ast::ExprKind::Type(ref lhs, ref ty) => Sugg::BinOp(\n+                AssocOp::Colon,\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, ty.span, default),\n+            ),\n         }\n     }\n \n@@ -306,17 +342,51 @@ impl<'a> Sugg<'a> {\n                     Sugg::NonParen(format!(\"({})\", sugg).into())\n                 }\n             },\n-            Sugg::BinOp(_, sugg) => {\n-                if has_enclosing_paren(&sugg) {\n-                    Sugg::NonParen(sugg)\n-                } else {\n-                    Sugg::NonParen(format!(\"({})\", sugg).into())\n-                }\n+            Sugg::BinOp(op, lhs, rhs) => {\n+                let sugg = binop_to_string(op, &lhs, &rhs);\n+                Sugg::NonParen(format!(\"({})\", sugg).into())\n             },\n         }\n     }\n }\n \n+/// Generates a string from the operator and both sides.\n+fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n+    match op {\n+        AssocOp::Add\n+        | AssocOp::Subtract\n+        | AssocOp::Multiply\n+        | AssocOp::Divide\n+        | AssocOp::Modulus\n+        | AssocOp::LAnd\n+        | AssocOp::LOr\n+        | AssocOp::BitXor\n+        | AssocOp::BitAnd\n+        | AssocOp::BitOr\n+        | AssocOp::ShiftLeft\n+        | AssocOp::ShiftRight\n+        | AssocOp::Equal\n+        | AssocOp::Less\n+        | AssocOp::LessEqual\n+        | AssocOp::NotEqual\n+        | AssocOp::Greater\n+        | AssocOp::GreaterEqual => format!(\n+            \"{} {} {}\",\n+            lhs,\n+            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n+            rhs\n+        ),\n+        AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n+        AssocOp::AssignOp(op) => {\n+            format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs)\n+        },\n+        AssocOp::As => format!(\"{} as {}\", lhs, rhs),\n+        AssocOp::DotDot => format!(\"{}..{}\", lhs, rhs),\n+        AssocOp::DotDotEq => format!(\"{}..={}\", lhs, rhs),\n+        AssocOp::Colon => format!(\"{}: {}\", lhs, rhs),\n+    }\n+}\n+\n /// Return `true` if `sugg` is enclosed in parenthesis.\n fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     let mut chars = sugg.as_ref().chars();\n@@ -391,10 +461,25 @@ impl Neg for Sugg<'_> {\n     }\n }\n \n-impl Not for Sugg<'_> {\n-    type Output = Sugg<'static>;\n-    fn not(self) -> Sugg<'static> {\n-        make_unop(\"!\", self)\n+impl Not for Sugg<'a> {\n+    type Output = Sugg<'a>;\n+    fn not(self) -> Sugg<'a> {\n+        use AssocOp::{Equal, Greater, GreaterEqual, Less, LessEqual, NotEqual};\n+\n+        if let Sugg::BinOp(op, lhs, rhs) = self {\n+            let to_op = match op {\n+                Equal => NotEqual,\n+                NotEqual => Equal,\n+                Less => GreaterEqual,\n+                GreaterEqual => Less,\n+                Greater => LessEqual,\n+                LessEqual => Greater,\n+                _ => return make_unop(\"!\", Sugg::BinOp(op, lhs, rhs)),\n+            };\n+            Sugg::BinOp(to_op, lhs, rhs)\n+        } else {\n+            make_unop(\"!\", self)\n+        }\n     }\n }\n \n@@ -463,53 +548,21 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n             || is_shift(other) && is_arith(op)\n     }\n \n-    let lhs_paren = if let Sugg::BinOp(lop, _) = *lhs {\n+    let lhs_paren = if let Sugg::BinOp(lop, _, _) = *lhs {\n         needs_paren(op, lop, Associativity::Left)\n     } else {\n         false\n     };\n \n-    let rhs_paren = if let Sugg::BinOp(rop, _) = *rhs {\n+    let rhs_paren = if let Sugg::BinOp(rop, _, _) = *rhs {\n         needs_paren(op, rop, Associativity::Right)\n     } else {\n         false\n     };\n \n-    let lhs = ParenHelper::new(lhs_paren, lhs);\n-    let rhs = ParenHelper::new(rhs_paren, rhs);\n-    let sugg = match op {\n-        AssocOp::Add\n-        | AssocOp::BitAnd\n-        | AssocOp::BitOr\n-        | AssocOp::BitXor\n-        | AssocOp::Divide\n-        | AssocOp::Equal\n-        | AssocOp::Greater\n-        | AssocOp::GreaterEqual\n-        | AssocOp::LAnd\n-        | AssocOp::LOr\n-        | AssocOp::Less\n-        | AssocOp::LessEqual\n-        | AssocOp::Modulus\n-        | AssocOp::Multiply\n-        | AssocOp::NotEqual\n-        | AssocOp::ShiftLeft\n-        | AssocOp::ShiftRight\n-        | AssocOp::Subtract => format!(\n-            \"{} {} {}\",\n-            lhs,\n-            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n-            rhs\n-        ),\n-        AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n-        AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs),\n-        AssocOp::As => format!(\"{} as {}\", lhs, rhs),\n-        AssocOp::DotDot => format!(\"{}..{}\", lhs, rhs),\n-        AssocOp::DotDotEq => format!(\"{}..={}\", lhs, rhs),\n-        AssocOp::Colon => format!(\"{}: {}\", lhs, rhs),\n-    };\n-\n-    Sugg::BinOp(op, sugg.into())\n+    let lhs = ParenHelper::new(lhs_paren, lhs).to_string();\n+    let rhs = ParenHelper::new(rhs_paren, rhs).to_string();\n+    Sugg::BinOp(op, lhs.into(), rhs.into())\n }\n \n /// Convenience wrapper around `make_assoc` and `AssocOp::from_ast_binop`.\n@@ -1007,10 +1060,32 @@ mod test {\n \n     #[test]\n     fn binop_maybe_par() {\n-        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1)\".into());\n+        let sugg = Sugg::BinOp(AssocOp::Add, \"1\".into(), \"1\".into());\n         assert_eq!(\"(1 + 1)\", sugg.maybe_par().to_string());\n \n-        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1) + (1 + 1)\".into());\n+        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1)\".into(), \"(1 + 1)\".into());\n         assert_eq!(\"((1 + 1) + (1 + 1))\", sugg.maybe_par().to_string());\n     }\n+    #[test]\n+    fn not_op() {\n+        use AssocOp::{Add, Equal, Greater, GreaterEqual, LAnd, LOr, Less, LessEqual, NotEqual};\n+\n+        fn test_not(op: AssocOp, correct: &str) {\n+            let sugg = Sugg::BinOp(op, \"x\".into(), \"y\".into());\n+            assert_eq!((!sugg).to_string(), correct);\n+        }\n+\n+        // Invert the comparison operator.\n+        test_not(Equal, \"x != y\");\n+        test_not(NotEqual, \"x == y\");\n+        test_not(Less, \"x >= y\");\n+        test_not(LessEqual, \"x > y\");\n+        test_not(Greater, \"x <= y\");\n+        test_not(GreaterEqual, \"x < y\");\n+\n+        // Other operators are inverted like !(..).\n+        test_not(Add, \"!(x + y)\");\n+        test_not(LAnd, \"!(x && y)\");\n+        test_not(LOr, \"!(x || y)\");\n+    }\n }"}, {"sha": "2e3ebadd7b5d2c580d2c89b09898d01b67f00adc", "filename": "tests/ui/manual_memcpy/with_loop_counters.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -43,7 +43,7 @@ LL | /     for i in 3..(3 + src.len()) {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].clone_from_slice(&src[..((3 + src.len()) - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].clone_from_slice(&src[..(3 + src.len() - 3)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:35:5"}, {"sha": "89dc13fd5b13d20077cfeecb305ea35fa20dcc2f", "filename": "tests/ui/needless_bool/fixable.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fneedless_bool%2Ffixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fneedless_bool%2Ffixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bool%2Ffixable.fixed?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -41,6 +41,15 @@ fn main() {\n     x;\n     !x;\n     !(x && y);\n+    let a = 0;\n+    let b = 1;\n+\n+    a != b;\n+    a == b;\n+    a >= b;\n+    a > b;\n+    a <= b;\n+    a < b;\n     if x {\n         x\n     } else {"}, {"sha": "c11d9472e8d066fa643c7472d4e2fa024c75eb7d", "filename": "tests/ui/needless_bool/fixable.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fneedless_bool%2Ffixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fneedless_bool%2Ffixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bool%2Ffixable.rs?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -53,6 +53,39 @@ fn main() {\n     } else {\n         true\n     };\n+    let a = 0;\n+    let b = 1;\n+\n+    if a == b {\n+        false\n+    } else {\n+        true\n+    };\n+    if a != b {\n+        false\n+    } else {\n+        true\n+    };\n+    if a < b {\n+        false\n+    } else {\n+        true\n+    };\n+    if a <= b {\n+        false\n+    } else {\n+        true\n+    };\n+    if a > b {\n+        false\n+    } else {\n+        true\n+    };\n+    if a >= b {\n+        false\n+    } else {\n+        true\n+    };\n     if x {\n         x\n     } else {"}, {"sha": "d2c48376f76622d0fe3528a76e92c45165261f31", "filename": "tests/ui/needless_bool/fixable.stderr", "status": "modified", "additions": 73, "deletions": 13, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fneedless_bool%2Ffixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fneedless_bool%2Ffixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bool%2Ffixable.stderr?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -31,7 +31,67 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `!(x && y)`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:72:5\n+  --> $DIR/fixable.rs:59:5\n+   |\n+LL | /     if a == b {\n+LL | |         false\n+LL | |     } else {\n+LL | |         true\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `a != b`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:64:5\n+   |\n+LL | /     if a != b {\n+LL | |         false\n+LL | |     } else {\n+LL | |         true\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `a == b`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:69:5\n+   |\n+LL | /     if a < b {\n+LL | |         false\n+LL | |     } else {\n+LL | |         true\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `a >= b`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:74:5\n+   |\n+LL | /     if a <= b {\n+LL | |         false\n+LL | |     } else {\n+LL | |         true\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `a > b`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:79:5\n+   |\n+LL | /     if a > b {\n+LL | |         false\n+LL | |     } else {\n+LL | |         true\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `a <= b`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:84:5\n+   |\n+LL | /     if a >= b {\n+LL | |         false\n+LL | |     } else {\n+LL | |         true\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `a < b`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:105:5\n    |\n LL | /     if x {\n LL | |         return true;\n@@ -41,7 +101,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:80:5\n+  --> $DIR/fixable.rs:113:5\n    |\n LL | /     if x {\n LL | |         return false;\n@@ -51,7 +111,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return !x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:88:5\n+  --> $DIR/fixable.rs:121:5\n    |\n LL | /     if x && y {\n LL | |         return true;\n@@ -61,7 +121,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return x && y`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:96:5\n+  --> $DIR/fixable.rs:129:5\n    |\n LL | /     if x && y {\n LL | |         return false;\n@@ -71,33 +131,33 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return !(x && y)`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/fixable.rs:104:8\n+  --> $DIR/fixable.rs:137:8\n    |\n LL |     if x == true {};\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n    |\n    = note: `-D clippy::bool-comparison` implied by `-D warnings`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/fixable.rs:108:8\n+  --> $DIR/fixable.rs:141:8\n    |\n LL |     if x == false {};\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/fixable.rs:118:8\n+  --> $DIR/fixable.rs:151:8\n    |\n LL |     if x == true {};\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/fixable.rs:119:8\n+  --> $DIR/fixable.rs:152:8\n    |\n LL |     if x == false {};\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:128:12\n+  --> $DIR/fixable.rs:161:12\n    |\n LL |       } else if returns_bool() {\n    |  ____________^\n@@ -108,7 +168,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `{ !returns_bool() }`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:141:5\n+  --> $DIR/fixable.rs:174:5\n    |\n LL | /     if unsafe { no(4) } & 1 != 0 {\n LL | |         true\n@@ -118,16 +178,16 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `(unsafe { no(4) } & 1 != 0)`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:146:30\n+  --> $DIR/fixable.rs:179:30\n    |\n LL |     let _brackets_unneeded = if unsafe { no(4) } & 1 != 0 { true } else { false };\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `unsafe { no(4) } & 1 != 0`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:149:9\n+  --> $DIR/fixable.rs:182:9\n    |\n LL |         if unsafe { no(4) } & 1 != 0 { true } else { false }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `(unsafe { no(4) } & 1 != 0)`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "dd22ecab0b551593f959cb7ce425318866ea09ee", "filename": "tests/ui/short_circuit_statement.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fshort_circuit_statement.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fshort_circuit_statement.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshort_circuit_statement.fixed?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -6,7 +6,7 @@\n fn main() {\n     if f() { g(); }\n     if !f() { g(); }\n-    if !(1 == 2) { g(); }\n+    if 1 != 2 { g(); }\n }\n \n fn f() -> bool {"}, {"sha": "aa84ac3a7925f3e6d0f741dd1d244b3c5b46209e", "filename": "tests/ui/short_circuit_statement.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fshort_circuit_statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1cd64b9c6b29ed2a577fc174a50c76267a966e2/tests%2Fui%2Fshort_circuit_statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshort_circuit_statement.stderr?ref=c1cd64b9c6b29ed2a577fc174a50c76267a966e2", "patch": "@@ -16,7 +16,7 @@ error: boolean short circuit operator in statement may be clearer using an expli\n   --> $DIR/short_circuit_statement.rs:9:5\n    |\n LL |     1 == 2 || g();\n-   |     ^^^^^^^^^^^^^^ help: replace it with: `if !(1 == 2) { g(); }`\n+   |     ^^^^^^^^^^^^^^ help: replace it with: `if 1 != 2 { g(); }`\n \n error: aborting due to 3 previous errors\n "}]}