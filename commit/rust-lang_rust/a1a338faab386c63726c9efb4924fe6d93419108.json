{"sha": "a1a338faab386c63726c9efb4924fe6d93419108", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYTMzOGZhYWIzODZjNjM3MjZjOWVmYjQ5MjRmZTZkOTM0MTkxMDg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T20:35:43Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-27T20:45:46Z"}, "message": "Rename MapEntry to EntryKind", "tree": {"sha": "82223ded76eb8ce841222f99b90807f9ea460c86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82223ded76eb8ce841222f99b90807f9ea460c86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1a338faab386c63726c9efb4924fe6d93419108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a338faab386c63726c9efb4924fe6d93419108", "html_url": "https://github.com/rust-lang/rust/commit/a1a338faab386c63726c9efb4924fe6d93419108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1a338faab386c63726c9efb4924fe6d93419108/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70a21e89f136c91f676959c126666d13a2deeadf", "url": "https://api.github.com/repos/rust-lang/rust/commits/70a21e89f136c91f676959c126666d13a2deeadf", "html_url": "https://github.com/rust-lang/rust/commit/70a21e89f136c91f676959c126666d13a2deeadf"}], "stats": {"total": 320, "additions": 159, "deletions": 161}, "files": [{"sha": "b67944c43528e145433d7a9301bd8f66b0d2a8f5", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a1a338faab386c63726c9efb4924fe6d93419108/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a338faab386c63726c9efb4924fe6d93419108/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a1a338faab386c63726c9efb4924fe6d93419108", "patch": "@@ -29,7 +29,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n     /// The node map\n-    map: Vec<MapEntry<'hir>>,\n+    map: Vec<EntryKind<'hir>>,\n     /// The parent of this node\n     parent_node: NodeId,\n \n@@ -114,7 +114,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             hcx,\n             hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_sig_dep_index));\n+        collector.insert_entry(CRATE_NODE_ID, EntryKind::RootCrate(root_mod_sig_dep_index));\n \n         collector\n     }\n@@ -124,7 +124,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   cstore: &dyn CrateStore,\n                                                   source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n-                                                  -> (Vec<MapEntry<'hir>>, Svh) {\n+                                                  -> (Vec<EntryKind<'hir>>, Svh) {\n         self\n             .hir_body_nodes\n             .sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n@@ -178,11 +178,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         (self.map, svh)\n     }\n \n-    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n+    fn insert_entry(&mut self, id: NodeId, entry: EntryKind<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n         if id.as_usize() >= len {\n-            self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n+            self.map.extend(repeat(EntryKind::NotPresent).take(id.as_usize() - len + 1));\n         }\n         self.map[id.as_usize()] = entry;\n     }\n@@ -196,26 +196,26 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         };\n \n         let entry = match node {\n-            NodeItem(n) => EntryItem(parent, dep_node_index, n),\n-            NodeForeignItem(n) => EntryForeignItem(parent, dep_node_index, n),\n-            NodeTraitItem(n) => EntryTraitItem(parent, dep_node_index, n),\n-            NodeImplItem(n) => EntryImplItem(parent, dep_node_index, n),\n-            NodeVariant(n) => EntryVariant(parent, dep_node_index, n),\n-            NodeField(n) => EntryField(parent, dep_node_index, n),\n-            NodeAnonConst(n) => EntryAnonConst(parent, dep_node_index, n),\n-            NodeExpr(n) => EntryExpr(parent, dep_node_index, n),\n-            NodeStmt(n) => EntryStmt(parent, dep_node_index, n),\n-            NodeTy(n) => EntryTy(parent, dep_node_index, n),\n-            NodeTraitRef(n) => EntryTraitRef(parent, dep_node_index, n),\n-            NodeBinding(n) => EntryBinding(parent, dep_node_index, n),\n-            NodePat(n) => EntryPat(parent, dep_node_index, n),\n-            NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n-            NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n-            NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n-            NodeGenericParam(n) => EntryGenericParam(parent, dep_node_index, n),\n-            NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n-            NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n-            NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n+            NodeItem(n) => EntryKind::Item(parent, dep_node_index, n),\n+            NodeForeignItem(n) => EntryKind::ForeignItem(parent, dep_node_index, n),\n+            NodeTraitItem(n) => EntryKind::TraitItem(parent, dep_node_index, n),\n+            NodeImplItem(n) => EntryKind::ImplItem(parent, dep_node_index, n),\n+            NodeVariant(n) => EntryKind::Variant(parent, dep_node_index, n),\n+            NodeField(n) => EntryKind::Field(parent, dep_node_index, n),\n+            NodeAnonConst(n) => EntryKind::AnonConst(parent, dep_node_index, n),\n+            NodeExpr(n) => EntryKind::Expr(parent, dep_node_index, n),\n+            NodeStmt(n) => EntryKind::Stmt(parent, dep_node_index, n),\n+            NodeTy(n) => EntryKind::Ty(parent, dep_node_index, n),\n+            NodeTraitRef(n) => EntryKind::TraitRef(parent, dep_node_index, n),\n+            NodeBinding(n) => EntryKind::Binding(parent, dep_node_index, n),\n+            NodePat(n) => EntryKind::Pat(parent, dep_node_index, n),\n+            NodeBlock(n) => EntryKind::Block(parent, dep_node_index, n),\n+            NodeStructCtor(n) => EntryKind::StructCtor(parent, dep_node_index, n),\n+            NodeLifetime(n) => EntryKind::Lifetime(parent, dep_node_index, n),\n+            NodeGenericParam(n) => EntryKind::GenericParam(parent, dep_node_index, n),\n+            NodeVisibility(n) => EntryKind::Visibility(parent, dep_node_index, n),\n+            NodeLocal(n) => EntryKind::Local(parent, dep_node_index, n),\n+            NodeMacroDef(n) => EntryKind::MacroDef(dep_node_index, n),\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId"}, {"sha": "5e85ca528466701a4ccc308483f1d27e62332a6f", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 134, "deletions": 136, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/a1a338faab386c63726c9efb4924fe6d93419108/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a338faab386c63726c9efb4924fe6d93419108/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a1a338faab386c63726c9efb4924fe6d93419108", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n pub use self::Node::*;\n-use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n@@ -76,125 +75,124 @@ pub enum Node<'hir> {\n /// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n-enum MapEntry<'hir> {\n+pub enum EntryKind<'hir> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, DepNodeIndex, &'hir Item),\n-    EntryForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n-    EntryTraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n-    EntryImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n-    EntryVariant(NodeId, DepNodeIndex, &'hir Variant),\n-    EntryField(NodeId, DepNodeIndex, &'hir StructField),\n-    EntryAnonConst(NodeId, DepNodeIndex, &'hir AnonConst),\n-    EntryExpr(NodeId, DepNodeIndex, &'hir Expr),\n-    EntryStmt(NodeId, DepNodeIndex, &'hir Stmt),\n-    EntryTy(NodeId, DepNodeIndex, &'hir Ty),\n-    EntryTraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n-    EntryBinding(NodeId, DepNodeIndex, &'hir Pat),\n-    EntryPat(NodeId, DepNodeIndex, &'hir Pat),\n-    EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n-    EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n-    EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n-    EntryGenericParam(NodeId, DepNodeIndex, &'hir GenericParam),\n-    EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n-    EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n-\n-    EntryMacroDef(DepNodeIndex, &'hir MacroDef),\n+    Item(NodeId, DepNodeIndex, &'hir Item),\n+    ForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n+    TraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n+    ImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n+    Variant(NodeId, DepNodeIndex, &'hir Variant),\n+    Field(NodeId, DepNodeIndex, &'hir StructField),\n+    AnonConst(NodeId, DepNodeIndex, &'hir AnonConst),\n+    Expr(NodeId, DepNodeIndex, &'hir Expr),\n+    Stmt(NodeId, DepNodeIndex, &'hir Stmt),\n+    Ty(NodeId, DepNodeIndex, &'hir Ty),\n+    TraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n+    Binding(NodeId, DepNodeIndex, &'hir Pat),\n+    Pat(NodeId, DepNodeIndex, &'hir Pat),\n+    Block(NodeId, DepNodeIndex, &'hir Block),\n+    StructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n+    Lifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n+    GenericParam(NodeId, DepNodeIndex, &'hir GenericParam),\n+    Visibility(NodeId, DepNodeIndex, &'hir Visibility),\n+    Local(NodeId, DepNodeIndex, &'hir Local),\n+    MacroDef(DepNodeIndex, &'hir MacroDef),\n \n     /// Roots for node trees. The DepNodeIndex is the dependency node of the\n     /// crate's root module.\n     RootCrate(DepNodeIndex),\n }\n \n-impl<'hir> Clone for MapEntry<'hir> {\n-    fn clone(&self) -> MapEntry<'hir> {\n+impl<'hir> Clone for EntryKind<'hir> {\n+    fn clone(&self) -> EntryKind<'hir> {\n         *self\n     }\n }\n \n-impl<'hir> MapEntry<'hir> {\n+impl<'hir> EntryKind<'hir> {\n     fn parent_node(self) -> Option<NodeId> {\n         Some(match self {\n-            EntryItem(id, _, _) => id,\n-            EntryForeignItem(id, _, _) => id,\n-            EntryTraitItem(id, _, _) => id,\n-            EntryImplItem(id, _, _) => id,\n-            EntryVariant(id, _, _) => id,\n-            EntryField(id, _, _) => id,\n-            EntryAnonConst(id, _, _) => id,\n-            EntryExpr(id, _, _) => id,\n-            EntryStmt(id, _, _) => id,\n-            EntryTy(id, _, _) => id,\n-            EntryTraitRef(id, _, _) => id,\n-            EntryBinding(id, _, _) => id,\n-            EntryPat(id, _, _) => id,\n-            EntryBlock(id, _, _) => id,\n-            EntryStructCtor(id, _, _) => id,\n-            EntryLifetime(id, _, _) => id,\n-            EntryGenericParam(id, _, _) => id,\n-            EntryVisibility(id, _, _) => id,\n-            EntryLocal(id, _, _) => id,\n-\n-            NotPresent |\n-            EntryMacroDef(..) |\n-            RootCrate(_) => return None,\n+            EntryKind::Item(id, _, _) => id,\n+            EntryKind::ForeignItem(id, _, _) => id,\n+            EntryKind::TraitItem(id, _, _) => id,\n+            EntryKind::ImplItem(id, _, _) => id,\n+            EntryKind::Variant(id, _, _) => id,\n+            EntryKind::Field(id, _, _) => id,\n+            EntryKind::AnonConst(id, _, _) => id,\n+            EntryKind::Expr(id, _, _) => id,\n+            EntryKind::Stmt(id, _, _) => id,\n+            EntryKind::Ty(id, _, _) => id,\n+            EntryKind::TraitRef(id, _, _) => id,\n+            EntryKind::Binding(id, _, _) => id,\n+            EntryKind::Pat(id, _, _) => id,\n+            EntryKind::Block(id, _, _) => id,\n+            EntryKind::StructCtor(id, _, _) => id,\n+            EntryKind::Lifetime(id, _, _) => id,\n+            EntryKind::GenericParam(id, _, _) => id,\n+            EntryKind::Visibility(id, _, _) => id,\n+            EntryKind::Local(id, _, _) => id,\n+\n+            EntryKind::NotPresent |\n+            EntryKind::MacroDef(..) |\n+            EntryKind::RootCrate(_) => return None,\n         })\n     }\n \n     fn to_node(self) -> Option<Node<'hir>> {\n         Some(match self {\n-            EntryItem(_, _, n) => NodeItem(n),\n-            EntryForeignItem(_, _, n) => NodeForeignItem(n),\n-            EntryTraitItem(_, _, n) => NodeTraitItem(n),\n-            EntryImplItem(_, _, n) => NodeImplItem(n),\n-            EntryVariant(_, _, n) => NodeVariant(n),\n-            EntryField(_, _, n) => NodeField(n),\n-            EntryAnonConst(_, _, n) => NodeAnonConst(n),\n-            EntryExpr(_, _, n) => NodeExpr(n),\n-            EntryStmt(_, _, n) => NodeStmt(n),\n-            EntryTy(_, _, n) => NodeTy(n),\n-            EntryTraitRef(_, _, n) => NodeTraitRef(n),\n-            EntryBinding(_, _, n) => NodeBinding(n),\n-            EntryPat(_, _, n) => NodePat(n),\n-            EntryBlock(_, _, n) => NodeBlock(n),\n-            EntryStructCtor(_, _, n) => NodeStructCtor(n),\n-            EntryLifetime(_, _, n) => NodeLifetime(n),\n-            EntryGenericParam(_, _, n) => NodeGenericParam(n),\n-            EntryVisibility(_, _, n) => NodeVisibility(n),\n-            EntryLocal(_, _, n) => NodeLocal(n),\n-            EntryMacroDef(_, n) => NodeMacroDef(n),\n-\n-            NotPresent |\n-            RootCrate(_) => return None\n+            EntryKind::Item(_, _, n) => NodeItem(n),\n+            EntryKind::ForeignItem(_, _, n) => NodeForeignItem(n),\n+            EntryKind::TraitItem(_, _, n) => NodeTraitItem(n),\n+            EntryKind::ImplItem(_, _, n) => NodeImplItem(n),\n+            EntryKind::Variant(_, _, n) => NodeVariant(n),\n+            EntryKind::Field(_, _, n) => NodeField(n),\n+            EntryKind::AnonConst(_, _, n) => NodeAnonConst(n),\n+            EntryKind::Expr(_, _, n) => NodeExpr(n),\n+            EntryKind::Stmt(_, _, n) => NodeStmt(n),\n+            EntryKind::Ty(_, _, n) => NodeTy(n),\n+            EntryKind::TraitRef(_, _, n) => NodeTraitRef(n),\n+            EntryKind::Binding(_, _, n) => NodeBinding(n),\n+            EntryKind::Pat(_, _, n) => NodePat(n),\n+            EntryKind::Block(_, _, n) => NodeBlock(n),\n+            EntryKind::StructCtor(_, _, n) => NodeStructCtor(n),\n+            EntryKind::Lifetime(_, _, n) => NodeLifetime(n),\n+            EntryKind::GenericParam(_, _, n) => NodeGenericParam(n),\n+            EntryKind::Visibility(_, _, n) => NodeVisibility(n),\n+            EntryKind::Local(_, _, n) => NodeLocal(n),\n+            EntryKind::MacroDef(_, n) => NodeMacroDef(n),\n+\n+            EntryKind::NotPresent |\n+            EntryKind::RootCrate(_) => return None\n         })\n     }\n \n     fn fn_decl(&self) -> Option<&FnDecl> {\n         match self {\n-            EntryItem(_, _, ref item) => {\n+            EntryKind::Item(_, _, ref item) => {\n                 match item.node {\n                     ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n \n-            EntryTraitItem(_, _, ref item) => {\n+            EntryKind::TraitItem(_, _, ref item) => {\n                 match item.node {\n                     TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, _, ref item) => {\n+            EntryKind::ImplItem(_, _, ref item) => {\n                 match item.node {\n                     ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None,\n                 }\n             }\n \n-            EntryExpr(_, _, ref expr) => {\n+            EntryKind::Expr(_, _, ref expr) => {\n                 match expr.node {\n                     ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n                     _ => None,\n@@ -207,7 +205,7 @@ impl<'hir> MapEntry<'hir> {\n \n     fn associated_body(self) -> Option<BodyId> {\n         match self {\n-            EntryItem(_, _, item) => {\n+            EntryKind::Item(_, _, item) => {\n                 match item.node {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n@@ -216,25 +214,25 @@ impl<'hir> MapEntry<'hir> {\n                 }\n             }\n \n-            EntryTraitItem(_, _, item) => {\n+            EntryKind::TraitItem(_, _, item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, _, item) => {\n+            EntryKind::ImplItem(_, _, item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            EntryAnonConst(_, _, constant) => Some(constant.body),\n+            EntryKind::AnonConst(_, _, constant) => Some(constant.body),\n \n-            EntryExpr(_, _, expr) => {\n+            EntryKind::Expr(_, _, expr) => {\n                 match expr.node {\n                     ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n@@ -296,7 +294,7 @@ pub struct Map<'hir> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: Vec<MapEntry<'hir>>,\n+    map: Vec<EntryKind<'hir>>,\n \n     definitions: &'hir Definitions,\n \n@@ -315,30 +313,30 @@ impl<'hir> Map<'hir> {\n     pub fn read(&self, id: NodeId) {\n         let entry = self.map[id.as_usize()];\n         match entry {\n-            EntryItem(_, dep_node_index, _) |\n-            EntryTraitItem(_, dep_node_index, _) |\n-            EntryImplItem(_, dep_node_index, _) |\n-            EntryVariant(_, dep_node_index, _) |\n-            EntryForeignItem(_, dep_node_index, _) |\n-            EntryField(_, dep_node_index, _) |\n-            EntryStmt(_, dep_node_index, _) |\n-            EntryTy(_, dep_node_index, _) |\n-            EntryTraitRef(_, dep_node_index, _) |\n-            EntryBinding(_, dep_node_index, _) |\n-            EntryPat(_, dep_node_index, _) |\n-            EntryBlock(_, dep_node_index, _) |\n-            EntryStructCtor(_, dep_node_index, _) |\n-            EntryLifetime(_, dep_node_index, _) |\n-            EntryGenericParam(_, dep_node_index, _) |\n-            EntryVisibility(_, dep_node_index, _) |\n-            EntryAnonConst(_, dep_node_index, _) |\n-            EntryExpr(_, dep_node_index, _) |\n-            EntryLocal(_, dep_node_index, _) |\n-            EntryMacroDef(dep_node_index, _) |\n-            RootCrate(dep_node_index) => {\n+            EntryKind::Item(_, dep_node_index, _) |\n+            EntryKind::TraitItem(_, dep_node_index, _) |\n+            EntryKind::ImplItem(_, dep_node_index, _) |\n+            EntryKind::Variant(_, dep_node_index, _) |\n+            EntryKind::ForeignItem(_, dep_node_index, _) |\n+            EntryKind::Field(_, dep_node_index, _) |\n+            EntryKind::Stmt(_, dep_node_index, _) |\n+            EntryKind::Ty(_, dep_node_index, _) |\n+            EntryKind::TraitRef(_, dep_node_index, _) |\n+            EntryKind::Binding(_, dep_node_index, _) |\n+            EntryKind::Pat(_, dep_node_index, _) |\n+            EntryKind::Block(_, dep_node_index, _) |\n+            EntryKind::StructCtor(_, dep_node_index, _) |\n+            EntryKind::Lifetime(_, dep_node_index, _) |\n+            EntryKind::GenericParam(_, dep_node_index, _) |\n+            EntryKind::Visibility(_, dep_node_index, _) |\n+            EntryKind::AnonConst(_, dep_node_index, _) |\n+            EntryKind::Expr(_, dep_node_index, _) |\n+            EntryKind::Local(_, dep_node_index, _) |\n+            EntryKind::MacroDef(dep_node_index, _) |\n+            EntryKind::RootCrate(dep_node_index) => {\n                 self.dep_graph.read_index(dep_node_index);\n             }\n-            NotPresent => {\n+            EntryKind::NotPresent => {\n                 bug!(\"called HirMap::read() with invalid NodeId\")\n             }\n         }\n@@ -509,7 +507,7 @@ impl<'hir> Map<'hir> {\n         self.map.len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<MapEntry<'hir>> {\n+    fn find_entry(&self, id: NodeId) -> Option<EntryKind<'hir>> {\n         self.map.get(id.as_usize()).cloned()\n     }\n \n@@ -892,7 +890,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, _, i)) => {\n+            Some(EntryKind::Item(_, _, i)) => {\n                 match i.node {\n                     ItemKind::ForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n@@ -1034,32 +1032,32 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n         match self.find_entry(id) {\n-            Some(EntryItem(_, _, item)) => item.span,\n-            Some(EntryForeignItem(_, _, foreign_item)) => foreign_item.span,\n-            Some(EntryTraitItem(_, _, trait_method)) => trait_method.span,\n-            Some(EntryImplItem(_, _, impl_item)) => impl_item.span,\n-            Some(EntryVariant(_, _, variant)) => variant.span,\n-            Some(EntryField(_, _, field)) => field.span,\n-            Some(EntryAnonConst(_, _, constant)) => self.body(constant.body).value.span,\n-            Some(EntryExpr(_, _, expr)) => expr.span,\n-            Some(EntryStmt(_, _, stmt)) => stmt.span,\n-            Some(EntryTy(_, _, ty)) => ty.span,\n-            Some(EntryTraitRef(_, _, tr)) => tr.path.span,\n-            Some(EntryBinding(_, _, pat)) => pat.span,\n-            Some(EntryPat(_, _, pat)) => pat.span,\n-            Some(EntryBlock(_, _, block)) => block.span,\n-            Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n-            Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n-            Some(EntryGenericParam(_, _, param)) => param.span,\n-            Some(EntryVisibility(_, _, &Spanned {\n+            Some(EntryKind::Item(_, _, item)) => item.span,\n+            Some(EntryKind::ForeignItem(_, _, foreign_item)) => foreign_item.span,\n+            Some(EntryKind::TraitItem(_, _, trait_method)) => trait_method.span,\n+            Some(EntryKind::ImplItem(_, _, impl_item)) => impl_item.span,\n+            Some(EntryKind::Variant(_, _, variant)) => variant.span,\n+            Some(EntryKind::Field(_, _, field)) => field.span,\n+            Some(EntryKind::AnonConst(_, _, constant)) => self.body(constant.body).value.span,\n+            Some(EntryKind::Expr(_, _, expr)) => expr.span,\n+            Some(EntryKind::Stmt(_, _, stmt)) => stmt.span,\n+            Some(EntryKind::Ty(_, _, ty)) => ty.span,\n+            Some(EntryKind::TraitRef(_, _, tr)) => tr.path.span,\n+            Some(EntryKind::Binding(_, _, pat)) => pat.span,\n+            Some(EntryKind::Pat(_, _, pat)) => pat.span,\n+            Some(EntryKind::Block(_, _, block)) => block.span,\n+            Some(EntryKind::StructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryKind::Lifetime(_, _, lifetime)) => lifetime.span,\n+            Some(EntryKind::GenericParam(_, _, param)) => param.span,\n+            Some(EntryKind::Visibility(_, _, &Spanned {\n                 node: VisibilityKind::Restricted { ref path, .. }, ..\n             })) => path.span,\n-            Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(EntryLocal(_, _, local)) => local.span,\n-            Some(EntryMacroDef(_, macro_def)) => macro_def.span,\n+            Some(EntryKind::Visibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(EntryKind::Local(_, _, local)) => local.span,\n+            Some(EntryKind::MacroDef(_, macro_def)) => macro_def.span,\n \n-            Some(RootCrate(_)) => self.forest.krate.span,\n-            Some(NotPresent) | None => {\n+            Some(EntryKind::RootCrate(_)) => self.forest.krate.span,\n+            Some(EntryKind::NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n         }\n@@ -1155,12 +1153,12 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n-                Some(EntryItem(_, _, n))       => n.name(),\n-                Some(EntryForeignItem(_, _, n))=> n.name(),\n-                Some(EntryTraitItem(_, _, n))  => n.name(),\n-                Some(EntryImplItem(_, _, n))   => n.name(),\n-                Some(EntryVariant(_, _, n))    => n.name(),\n-                Some(EntryField(_, _, n))      => n.name(),\n+                Some(EntryKind::Item(_, _, n))       => n.name(),\n+                Some(EntryKind::ForeignItem(_, _, n))=> n.name(),\n+                Some(EntryKind::TraitItem(_, _, n))  => n.name(),\n+                Some(EntryKind::ImplItem(_, _, n))   => n.name(),\n+                Some(EntryKind::Variant(_, _, n))    => n.name(),\n+                Some(EntryKind::Field(_, _, n))      => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1211,7 +1209,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         // enumerate to count the number of entries.\n         let (entries_less_1, _) = map.iter().filter(|&x| {\n             match *x {\n-                NotPresent => false,\n+                EntryKind::NotPresent => false,\n                 _ => true\n             }\n         }).enumerate().last().expect(\"AST map was empty after folding?\");"}]}