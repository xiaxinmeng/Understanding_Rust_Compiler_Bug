{"sha": "563ed27c01c204d734355709c905f9a14246d4ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2M2VkMjdjMDFjMjA0ZDczNDM1NTcwOWM5MDVmOWExNDI0NmQ0ZmY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-16T15:58:54Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-11-27T17:22:03Z"}, "message": "rustc: move debug info from LocalDecl and UpvarDecl into a dedicated VarDebugInfo.", "tree": {"sha": "8609414c35f238977d85651ca531d6599eec7298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8609414c35f238977d85651ca531d6599eec7298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/563ed27c01c204d734355709c905f9a14246d4ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/563ed27c01c204d734355709c905f9a14246d4ff", "html_url": "https://github.com/rust-lang/rust/commit/563ed27c01c204d734355709c905f9a14246d4ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/563ed27c01c204d734355709c905f9a14246d4ff/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876a72a251e0d533f776fa9149b3e4daaeea3a61", "url": "https://api.github.com/repos/rust-lang/rust/commits/876a72a251e0d533f776fa9149b3e4daaeea3a61", "html_url": "https://github.com/rust-lang/rust/commit/876a72a251e0d533f776fa9149b3e4daaeea3a61"}], "stats": {"total": 1260, "additions": 780, "deletions": 480}, "files": [{"sha": "4103d25fbd173f56847297aa97fbf8944f02543e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 49, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -141,14 +141,8 @@ pub struct Body<'tcx> {\n     /// This is used for the \"rust-call\" ABI.\n     pub spread_arg: Option<Local>,\n \n-    /// Names and capture modes of all the closure upvars, assuming\n-    /// the first argument is either the closure or a reference to it.\n-    //\n-    // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n-    // debuginfo generation, and will be removed at some point.\n-    // Do **NOT** use it for anything else; upvar information should not be\n-    // in the MIR, so please rely on local crate HIR or other side-channels.\n-    pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+    /// Debug information pertaining to user variables, including captures.\n+    pub var_debug_info: Vec<VarDebugInfo<'tcx>>,\n \n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n     /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n@@ -170,11 +164,10 @@ impl<'tcx> Body<'tcx> {\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        yield_ty: Option<Ty<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n-        __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+        var_debug_info: Vec<VarDebugInfo<'tcx>>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n@@ -191,14 +184,14 @@ impl<'tcx> Body<'tcx> {\n             basic_blocks,\n             source_scopes,\n             source_scope_local_data,\n-            yield_ty,\n+            yield_ty: None,\n             generator_drop: None,\n             generator_layout: None,\n             local_decls,\n             user_type_annotations,\n             arg_count,\n-            __upvar_debuginfo_codegen_only_do_not_use,\n             spread_arg: None,\n+            var_debug_info,\n             span,\n             cache: cache::Cache::new(),\n             control_flow_destroyed,\n@@ -280,7 +273,7 @@ impl<'tcx> Body<'tcx> {\n             LocalKind::ReturnPointer\n         } else if index < self.arg_count + 1 {\n             LocalKind::Arg\n-        } else if self.local_decls[local].name.is_some() {\n+        } else if self.local_decls[local].is_user_variable() {\n             LocalKind::Var\n         } else {\n             LocalKind::Temp\n@@ -728,12 +721,6 @@ pub struct LocalDecl<'tcx> {\n     // FIXME(matthewjasper) Don't store in this in `Body`\n     pub user_ty: UserTypeProjections,\n \n-    /// The name of the local, used in debuginfo and pretty-printing.\n-    ///\n-    /// Note that function arguments can also have this set to `Some(_)`\n-    /// to generate better debuginfo.\n-    pub name: Option<Name>,\n-\n     /// The *syntactic* (i.e., not visibility) source scope the local is defined\n     /// in. If the local was defined in a let-statement, this\n     /// is *within* the let-statement, rather than outside\n@@ -785,9 +772,9 @@ pub struct LocalDecl<'tcx> {\n     /// `drop(x)`, we want it to refer to `x: u32`.\n     ///\n     /// To allow both uses to work, we need to have more than a single scope\n-    /// for a local. We have the `source_info.scope` represent the\n-    /// \"syntactic\" lint scope (with a variable being under its let\n-    /// block) while the `visibility_scope` represents the \"local variable\"\n+    /// for a local. We have the `source_info.scope` represent the \"syntactic\"\n+    /// lint scope (with a variable being under its let block) while the\n+    /// `var_debug_info.source_info.scope` represents the \"local variable\"\n     /// scope (where the \"rest\" of a block is under all prior let-statements).\n     ///\n     /// The end result looks like this:\n@@ -806,18 +793,14 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502 \u2502\n     ///  \u2502 \u2502 \u2502{ let y: u32 }\n     ///  \u2502 \u2502 \u2502\n-    ///  \u2502 \u2502 \u2502\u2190 y.visibility_scope\n+    ///  \u2502 \u2502 \u2502\u2190 y.var_debug_info.source_info.scope\n     ///  \u2502 \u2502 \u2502\u2190 `y + 2`\n     ///  \u2502\n     ///  \u2502 \u2502{ let x: u32 }\n-    ///  \u2502 \u2502\u2190 x.visibility_scope\n+    ///  \u2502 \u2502\u2190 x.var_debug_info.source_info.scope\n     ///  \u2502 \u2502\u2190 `drop(x)` // This accesses `x: u32`.\n     /// ```\n     pub source_info: SourceInfo,\n-\n-    /// Source scope within which the local is visible (for debuginfo)\n-    /// (see `source_info` for more details).\n-    pub visibility_scope: SourceScope,\n }\n \n /// Extra information about a local that's used for diagnostics.\n@@ -955,9 +938,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             mutability,\n             ty,\n             user_ty: UserTypeProjections::none(),\n-            name: None,\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n-            visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n             local_info: LocalInfo::Other,\n             is_block_tail: None,\n@@ -974,22 +955,27 @@ impl<'tcx> LocalDecl<'tcx> {\n             ty: return_ty,\n             user_ty: UserTypeProjections::none(),\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n-            visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             is_block_tail: None,\n-            name: None, // FIXME maybe we do want some name here?\n             local_info: LocalInfo::Other,\n         }\n     }\n }\n \n-/// A closure capture, with its name and mode.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UpvarDebuginfo {\n-    pub debug_name: Name,\n+/// Debug information pertaining to a user variable.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VarDebugInfo<'tcx> {\n+    pub name: Name,\n \n-    /// If true, the capture is behind a reference.\n-    pub by_ref: bool,\n+    /// Source info of the user variable, including the scope\n+    /// within which the variable is visible (to debuginfo)\n+    /// (see `LocalDecl`'s `source_info` field for more details).\n+    pub source_info: SourceInfo,\n+\n+    /// Where the data for this user variable is to be found.\n+    /// NOTE(eddyb) There's an unenforced invariant that this `Place` is\n+    /// based on a `Local`, not a `Static`, and contains no indexing.\n+    pub place: Place<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -2758,16 +2744,6 @@ pub struct GeneratorLayout<'tcx> {\n     /// have conflicts with each other are allowed to overlap in the computed\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n-\n-    /// The names and scopes of all the stored generator locals.\n-    ///\n-    /// N.B., this is *strictly* a temporary hack for codegen\n-    /// debuginfo generation, and will be removed at some point.\n-    /// Do **NOT** use it for anything else, local information should not be\n-    /// in the MIR, please rely on local crate HIR or other side-channels.\n-    //\n-    // FIXME(tmandry): see above.\n-    pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2946,7 +2922,6 @@ CloneTypeFoldableAndLiftImpls! {\n     MirPhase,\n     Mutability,\n     SourceInfo,\n-    UpvarDebuginfo,\n     FakeReadCause,\n     RetagKind,\n     SourceScope,"}, {"sha": "464d4c74366e5e92166b8c381dd136d7ce2bf0b9", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -221,6 +221,11 @@ macro_rules! make_mir_visitor {\n                 self.super_local_decl(local, local_decl);\n             }\n \n+            fn visit_var_debug_info(&mut self,\n+                                    var_debug_info: & $($mutability)* VarDebugInfo<'tcx>) {\n+                self.super_var_debug_info(var_debug_info);\n+            }\n+\n             fn visit_local(&mut self,\n                             _local: & $($mutability)? Local,\n                             _context: PlaceContext,\n@@ -279,6 +284,10 @@ macro_rules! make_mir_visitor {\n                     );\n                 }\n \n+                for var_debug_info in &$($mutability)? body.var_debug_info {\n+                    self.visit_var_debug_info(var_debug_info);\n+                }\n+\n                 self.visit_span(&$($mutability)? body.span);\n             }\n \n@@ -687,9 +696,7 @@ macro_rules! make_mir_visitor {\n                     mutability: _,\n                     ty,\n                     user_ty,\n-                    name: _,\n                     source_info,\n-                    visibility_scope,\n                     internal: _,\n                     local_info: _,\n                     is_block_tail: _,\n@@ -703,7 +710,23 @@ macro_rules! make_mir_visitor {\n                     self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n-                self.visit_source_scope(visibility_scope);\n+            }\n+\n+            fn super_var_debug_info(&mut self,\n+                                    var_debug_info: & $($mutability)? VarDebugInfo<'tcx>) {\n+                let VarDebugInfo {\n+                    name: _,\n+                    source_info,\n+                    place,\n+                } = var_debug_info;\n+\n+                self.visit_source_info(source_info);\n+                let location = START_BLOCK.start_location();\n+                self.visit_place(\n+                    place,\n+                    PlaceContext::NonUse(NonUseContext::VarDebugInfo),\n+                    location,\n+                );\n             }\n \n             fn super_source_scope(&mut self,\n@@ -1029,6 +1052,8 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n+    /// The data of an user variable, for debug info.\n+    VarDebugInfo,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "91d5a22b0228d4bcc184a1ba336b814683f2784d", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -23,12 +23,10 @@ pub fn compute_mir_scopes(\n ) {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n-    // FIXME(eddyb) base this on `decl.name`, or even better, on debuginfo.\n     // FIXME(eddyb) take into account that arguments always have debuginfo,\n     // irrespective of their name (assuming full debuginfo is enabled).\n-    for var in mir.vars_iter() {\n-        let decl = &mir.local_decls[var];\n-        has_variables.insert(decl.visibility_scope);\n+    for var_debug_info in &mir.var_debug_info {\n+        has_variables.insert(var_debug_info.source_info.scope);\n     }\n \n     // Instantiate all scopes."}, {"sha": "1847e4e9fa951963091cc616ae2d98b1477e44ff", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -17,13 +17,13 @@ use crate::llvm_util;\n use crate::value::Value;\n \n use rustc_codegen_ssa::traits::*;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n-use rustc::mir::Field;\n-use rustc::mir::GeneratorLayout;\n+use rustc::mir::{self, Field, GeneratorLayout};\n use rustc::mir::interpret::truncate;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n@@ -1316,6 +1316,45 @@ fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n         || llvm_util::get_major_version() < 8;\n }\n \n+// FIXME(eddyb) maybe precompute this? Right now it's computed once\n+// per generator monomorphization, but it doesn't depend on substs.\n+fn generator_layout_and_saved_local_names(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>) {\n+    let body = tcx.optimized_mir(def_id);\n+    let generator_layout = body.generator_layout.as_ref().unwrap();\n+    let mut generator_saved_local_names =\n+        IndexVec::from_elem(None, &generator_layout.field_tys);\n+\n+    let state_arg = mir::PlaceBase::Local(mir::Local::new(1));\n+    for var in &body.var_debug_info {\n+        if var.place.base != state_arg {\n+            continue;\n+        }\n+        match var.place.projection[..] {\n+            [\n+                // Deref of the `Pin<&mut Self>` state argument.\n+                mir::ProjectionElem::Field(..),\n+                mir::ProjectionElem::Deref,\n+\n+                // Field of a variant of the state.\n+                mir::ProjectionElem::Downcast(_, variant),\n+                mir::ProjectionElem::Field(field, _),\n+            ] => {\n+                let name = &mut generator_saved_local_names[\n+                    generator_layout.variant_fields[variant][field]\n+                ];\n+                if name.is_none() {\n+                    name.replace(var.name);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    (generator_layout, generator_saved_local_names)\n+}\n+\n /// Describes the members of an enum value; an enum is described as a union of\n /// structs in DWARF. This `MemberDescriptionFactory` provides the description for\n /// the members of this union; so for every variant of the given enum, this\n@@ -1332,12 +1371,25 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n+        let generator_variant_info_data = match self.enum_type.kind {\n+            ty::Generator(def_id, ..) => {\n+                Some(generator_layout_and_saved_local_names(cx.tcx, def_id))\n+            }\n+            _ => None,\n+        };\n+\n         let variant_info_for = |index: VariantIdx| {\n-            match &self.enum_type.kind {\n+            match self.enum_type.kind {\n                 ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n-                ty::Generator(def_id, substs, _) => {\n-                    let generator_layout = cx.tcx.generator_layout(*def_id);\n-                    VariantInfo::Generator(substs, generator_layout, index)\n+                ty::Generator(_, substs, _) => {\n+                    let (generator_layout, generator_saved_local_names) =\n+                        generator_variant_info_data.as_ref().unwrap();\n+                    VariantInfo::Generator {\n+                        substs,\n+                        generator_layout: *generator_layout,\n+                        generator_saved_local_names,\n+                        variant_index: index,\n+                    }\n                 }\n                 _ => bug!(),\n             }\n@@ -1608,24 +1660,29 @@ enum EnumDiscriminantInfo<'ll> {\n }\n \n #[derive(Copy, Clone)]\n-enum VariantInfo<'tcx> {\n+enum VariantInfo<'a, 'tcx> {\n     Adt(&'tcx ty::VariantDef),\n-    Generator(SubstsRef<'tcx>, &'tcx GeneratorLayout<'tcx>, VariantIdx),\n+    Generator {\n+        substs: SubstsRef<'tcx>,\n+        generator_layout: &'tcx GeneratorLayout<'tcx>,\n+        generator_saved_local_names: &'a IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>,\n+        variant_index: VariantIdx,\n+    },\n }\n \n-impl<'tcx> VariantInfo<'tcx> {\n+impl<'tcx> VariantInfo<'_, 'tcx> {\n     fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n         match self {\n             VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n-            VariantInfo::Generator(substs, _, variant_index) =>\n+            VariantInfo::Generator { substs, variant_index, .. } =>\n                 f(&substs.as_generator().variant_name(*variant_index)),\n         }\n     }\n \n     fn variant_name(&self) -> String {\n         match self {\n             VariantInfo::Adt(variant) => variant.ident.to_string(),\n-            VariantInfo::Generator(_, _, variant_index) => {\n+            VariantInfo::Generator { variant_index, .. } => {\n                 // Since GDB currently prints out the raw discriminant along\n                 // with every variant, make each variant name be just the value\n                 // of the discriminant. The struct name for the variant includes\n@@ -1636,17 +1693,20 @@ impl<'tcx> VariantInfo<'tcx> {\n     }\n \n     fn field_name(&self, i: usize) -> String {\n-        let field_name = match self {\n+        let field_name = match *self {\n             VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn =>\n-                Some(variant.fields[i].ident.to_string()),\n-            VariantInfo::Generator(_, generator_layout, variant_index) => {\n-                let field = generator_layout.variant_fields[*variant_index][i.into()];\n-                let decl = &generator_layout.__local_debuginfo_codegen_only_do_not_use[field];\n-                decl.name.map(|name| name.to_string())\n-            }\n+                Some(variant.fields[i].ident.name),\n+            VariantInfo::Generator {\n+                generator_layout,\n+                generator_saved_local_names,\n+                variant_index,\n+                ..\n+            } => generator_saved_local_names[\n+                generator_layout.variant_fields[variant_index][i.into()]\n+            ],\n             _ => None,\n         };\n-        field_name.unwrap_or_else(|| format!(\"__{}\", i))\n+        field_name.map(|name| name.to_string()).unwrap_or_else(|| format!(\"__{}\", i))\n     }\n }\n \n@@ -1657,7 +1717,7 @@ impl<'tcx> VariantInfo<'tcx> {\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n-    variant: VariantInfo<'tcx>,\n+    variant: VariantInfo<'_, 'tcx>,\n     discriminant_info: EnumDiscriminantInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,"}, {"sha": "e44551fcbcdfe3e3e8b02429b62dd85c731c5bf9", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 82, "deletions": 31, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -5,7 +5,9 @@ use rustc_index::bit_set::BitSet;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n-use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::visit::{\n+    Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext, NonUseContext,\n+};\n use rustc::mir::traversal;\n use rustc::session::config::DebugInfo;\n use rustc::ty;\n@@ -27,7 +29,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n         // of putting everything in allocas just so we can use llvm.dbg.declare.\n         if fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n-            if mir.local_kind(local) == mir::LocalKind::Arg || decl.name.is_some() {\n+            if mir.local_kind(local) == mir::LocalKind::Arg {\n                 analyzer.not_ssa(local);\n                 continue;\n             }\n@@ -114,6 +116,12 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         let cx = self.fx.cx;\n \n         if let [proj_base @ .., elem] = place_ref.projection {\n+            let mut base_context = if context.is_mutating_use() {\n+                PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+            } else {\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+            };\n+\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n                 PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n@@ -145,47 +153,81 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n                         // which would trigger `not_ssa` on locals.\n-                        self.process_place(\n-                            &mir::PlaceRef {\n-                                base: place_ref.base,\n-                                projection: proj_base,\n-                            },\n-                            context,\n-                            location,\n-                        );\n-                        return;\n+                        base_context = context;\n                     }\n                 }\n             }\n \n-            // A deref projection only reads the pointer, never needs the place.\n             if let mir::ProjectionElem::Deref = elem {\n-                self.process_place(\n-                    &mir::PlaceRef {\n-                        base: place_ref.base,\n-                        projection: proj_base,\n-                    },\n+                // Deref projections typically only read the pointer.\n+                // (the exception being `VarDebugInfo` contexts, handled below)\n+                base_context = PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy);\n+\n+                // Indirect debuginfo requires going through memory, that only\n+                // the debugger accesses, following our emitted DWARF pointer ops.\n+                //\n+                // FIXME(eddyb) Investigate the possibility of relaxing this, but\n+                // note that `llvm.dbg.declare` *must* be used for indirect places,\n+                // even if we start using `llvm.dbg.value` for all other cases,\n+                // as we don't necessarily know when the value changes, but only\n+                // where it lives in memory.\n+                //\n+                // It's possible `llvm.dbg.declare` could support starting from\n+                // a pointer that doesn't point to an `alloca`, but this would\n+                // only be useful if we know the pointer being `Deref`'d comes\n+                // from an immutable place, and if `llvm.dbg.declare` calls\n+                // must be at the very start of the function, then only function\n+                // arguments could contain such pointers.\n+                if context == PlaceContext::NonUse(NonUseContext::VarDebugInfo) {\n+                    // We use `NonUseContext::VarDebugInfo` for the base,\n+                    // which might not force the base local to memory,\n+                    // so we have to do it manually.\n+                    if let mir::PlaceBase::Local(local) = place_ref.base {\n+                        self.visit_local(&local, context, location);\n+                    }\n+                }\n+            }\n+\n+            // `NonUseContext::VarDebugInfo` needs to flow all the\n+            // way down to the base local (see `visit_local`).\n+            if context == PlaceContext::NonUse(NonUseContext::VarDebugInfo) {\n+                base_context = context;\n+            }\n+\n+            self.process_place(\n+                &mir::PlaceRef {\n+                    base: place_ref.base,\n+                    projection: proj_base,\n+                },\n+                base_context,\n+                location\n+            );\n+            // HACK(eddyb) this emulates the old `visit_projection_elem`, this\n+            // entire `visit_place`-like `process_place` method should be rewritten,\n+            // now that we have moved to the \"slice of projections\" representation.\n+            if let mir::ProjectionElem::Index(local) = elem {\n+                self.visit_local(\n+                    local,\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                     location\n                 );\n-                return;\n             }\n-        }\n+        } else {\n+            // FIXME this is super_place code, is repeated here to avoid cloning place or changing\n+            // visit_place API\n+            let mut context = context;\n \n-        // FIXME this is super_place code, is repeated here to avoid cloning place or changing\n-        // visit_place API\n-        let mut context = context;\n+            if !place_ref.projection.is_empty() {\n+                context = if context.is_mutating_use() {\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                } else {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                };\n+            }\n \n-        if !place_ref.projection.is_empty() {\n-            context = if context.is_mutating_use() {\n-                PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-            } else {\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-            };\n+            self.visit_place_base(place_ref.base, context, location);\n+            self.visit_projection(place_ref.base, place_ref.projection, context, location);\n         }\n-\n-        self.visit_place_base(place_ref.base, context, location);\n-        self.visit_projection(place_ref.base, place_ref.projection, context, location);\n     }\n \n }\n@@ -264,6 +306,15 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 self.assign(local, location);\n             }\n \n+            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {\n+                // We need to keep locals in `alloca`s for debuginfo.\n+                // FIXME(eddyb): We should figure out how to use `llvm.dbg.value` instead\n+                // of putting everything in allocas just so we can use `llvm.dbg.declare`.\n+                if self.fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n+                    self.not_ssa(local);\n+                }\n+            }\n+\n             PlaceContext::NonUse(_) |\n             PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}\n "}, {"sha": "bb2679e214db47c1192f530b416d891d9c9d1da8", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 126, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -1,12 +1,12 @@\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::session::config::DebugInfo;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::{LayoutOf, Size, VariantIdx};\n+use rustc::ty::TyCtxt;\n+use rustc::ty::layout::{LayoutOf, Size};\n use crate::traits::*;\n \n-use syntax_pos::{BytePos, Span, Symbol};\n+use syntax_pos::{BytePos, Span};\n use syntax::symbol::kw;\n \n use super::{FunctionCx, LocalRef};\n@@ -113,7 +113,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(per_local) => &per_local[local],\n             None => return,\n         };\n-        let whole_local_var = vars.iter().find(|var| {\n+        let whole_local_var = vars.iter().copied().find(|var| {\n             var.place.projection.is_empty()\n         });\n         let has_proj = || vars.iter().any(|var| {\n@@ -131,7 +131,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // be offset to account for the hidden environment?\n                 None\n             } else {\n-                Some(VarDebugInfo {\n+                Some(mir::VarDebugInfo {\n                     name: kw::Invalid,\n                     source_info: self.mir.local_decls[local].source_info,\n                     place: local.into(),\n@@ -185,7 +185,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => return,\n         };\n \n-        let vars = vars.iter().chain(if whole_local_var.is_none() {\n+        let vars = vars.iter().copied().chain(if whole_local_var.is_none() {\n             fallback_var.as_ref()\n         } else {\n             None\n@@ -253,133 +253,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n+/// Partition all `VarDebuginfo` in `body`, by their base `Local`.\n pub fn per_local_var_debug_info(\n     tcx: TyCtxt<'tcx>,\n-    body: &mir::Body<'tcx>,\n-) -> Option<IndexVec<mir::Local, Vec<VarDebugInfo<'tcx>>>> {\n+    body: &'a mir::Body<'tcx>,\n+) -> Option<IndexVec<mir::Local, Vec<&'a mir::VarDebugInfo<'tcx>>>> {\n     if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n         let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n-        for (local, decl) in body.local_decls.iter_enumerated() {\n-            if let Some(name) = decl.name {\n-                per_local[local].push(VarDebugInfo {\n-                    name,\n-                    source_info: mir::SourceInfo {\n-                        span: decl.source_info.span,\n-                        scope: decl.visibility_scope,\n-                    },\n-                    place: local.into(),\n-                });\n-            }\n-        }\n-\n-        let upvar_debuginfo = &body.__upvar_debuginfo_codegen_only_do_not_use;\n-        if !upvar_debuginfo.is_empty() {\n-\n-            let env_arg = mir::Local::new(1);\n-            let mut env_projs = vec![];\n-\n-            let pin_did = tcx.lang_items().pin_type();\n-            match body.local_decls[env_arg].ty.kind {\n-                ty::RawPtr(_) |\n-                ty::Ref(..)  => {\n-                    env_projs.push(mir::ProjectionElem::Deref);\n-                }\n-                ty::Adt(def, substs) if Some(def.did) == pin_did => {\n-                    if let ty::Ref(..) = substs.type_at(0).kind {\n-                        env_projs.push(mir::ProjectionElem::Field(\n-                            mir::Field::new(0),\n-                            // HACK(eddyb) field types aren't used or needed here.\n-                            tcx.types.err,\n-                        ));\n-                        env_projs.push(mir::ProjectionElem::Deref);\n-                    }\n-                }\n-                _ => {}\n-            }\n-\n-            let extra_locals = {\n-                let upvars = upvar_debuginfo\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, upvar)| {\n-                        let source_info = mir::SourceInfo {\n-                            span: body.span,\n-                            scope: mir::OUTERMOST_SOURCE_SCOPE,\n-                        };\n-                        (None, i, upvar.debug_name, upvar.by_ref, source_info)\n-                    });\n-\n-                let generator_fields = body.generator_layout.as_ref().map(|generator_layout| {\n-                    generator_layout.variant_fields.iter()\n-                        .enumerate()\n-                        .flat_map(move |(variant_idx, fields)| {\n-                            let variant_idx = Some(VariantIdx::from(variant_idx));\n-                            fields.iter()\n-                                .enumerate()\n-                                .filter_map(move |(i, field)| {\n-                                    let decl = &generator_layout.\n-                                        __local_debuginfo_codegen_only_do_not_use[*field];\n-                                    if let Some(name) = decl.name {\n-                                        let source_info = mir::SourceInfo {\n-                                            span: decl.source_info.span,\n-                                            scope: decl.visibility_scope,\n-                                        };\n-                                        Some((variant_idx, i, name, false, source_info))\n-                                    } else {\n-                                        None\n-                                    }\n-                            })\n-                        })\n-                }).into_iter().flatten();\n-\n-                upvars.chain(generator_fields)\n-            };\n-\n-            for (variant_idx, field, name, by_ref, source_info) in extra_locals {\n-                let mut projs = env_projs.clone();\n-\n-                if let Some(variant_idx) = variant_idx {\n-                    projs.push(mir::ProjectionElem::Downcast(None, variant_idx));\n-                }\n-\n-                projs.push(mir::ProjectionElem::Field(\n-                    mir::Field::new(field),\n-                    // HACK(eddyb) field types aren't used or needed here.\n-                    tcx.types.err,\n-                ));\n-\n-                if by_ref {\n-                    projs.push(mir::ProjectionElem::Deref);\n-                }\n-\n-                per_local[env_arg].push(VarDebugInfo {\n-                    name,\n-                    source_info,\n-                    place: mir::Place {\n-                        base: mir::PlaceBase::Local(env_arg),\n-                        projection: tcx.intern_place_elems(&projs),\n-                    },\n-                });\n+        for var in &body.var_debug_info {\n+            if let mir::PlaceBase::Local(local) = var.place.base {\n+                per_local[local].push(var);\n             }\n         }\n-\n         Some(per_local)\n     } else {\n         None\n     }\n }\n-\n-/// Debug information relatating to an user variable.\n-// FIXME(eddyb) move this to the MIR bodies themselves.\n-#[derive(Clone)]\n-pub struct VarDebugInfo<'tcx> {\n-    pub name: Symbol,\n-\n-    /// Source info of the user variable, including the scope\n-    /// within which the variable is visible (to debuginfo)\n-    /// (see `LocalDecl`'s `source_info` field for more details).\n-    pub source_info: mir::SourceInfo,\n-\n-    /// Where the data for this user variable is to be found.\n-    pub place: mir::Place<'tcx>,\n-}"}, {"sha": "6041232489d0d30dcf319a018ac13149741f0346", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -74,7 +74,9 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// notably `expect`.\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n-    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<debuginfo::VarDebugInfo<'tcx>>>>,\n+    /// All `VarDebuginfo` from the MIR body, partitioned by `Local`.\n+    /// This is `None` if no variable debuginfo/names are needed.\n+    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<&'a mir::VarDebugInfo<'tcx>>>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {"}, {"sha": "8508bf62d8f60e5a9c5b0f305d2715a15b9fb7d1", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -308,7 +308,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location,\n             borrow,\n             None,\n-        ).add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", Some(borrow_span));\n+        ).add_explanation_to_diagnostic(\n+            self.infcx.tcx,\n+            self.body,\n+            &self.local_names,\n+            &mut err,\n+            \"\",\n+            Some(borrow_span),\n+        );\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -343,7 +350,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n-            .add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n+            .add_explanation_to_diagnostic(\n+                self.infcx.tcx,\n+                self.body,\n+                &self.local_names,\n+                &mut err,\n+                \"\",\n+                None,\n+            );\n         err\n     }\n \n@@ -561,6 +575,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n             self.body,\n+            &self.local_names,\n             &mut err,\n             first_borrow_desc,\n             None,\n@@ -947,6 +962,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 explanation.add_explanation_to_diagnostic(\n                     self.infcx.tcx,\n                     self.body,\n+                    &self.local_names,\n                     &mut err,\n                     \"\",\n                     None,\n@@ -971,7 +987,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n \n             explanation.add_explanation_to_diagnostic(\n-                self.infcx.tcx, self.body, &mut err, \"\", None);\n+                self.infcx.tcx, self.body, &self.local_names, &mut err, \"\", None);\n         }\n \n         err\n@@ -1029,7 +1045,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             _ => {}\n         }\n \n-        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n+        explanation.add_explanation_to_diagnostic(\n+            self.infcx.tcx,\n+            self.body,\n+            &self.local_names,\n+            &mut err,\n+            \"\",\n+            None,\n+        );\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -1109,7 +1132,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             _ => {}\n         }\n-        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n+        explanation.add_explanation_to_diagnostic(\n+            self.infcx.tcx,\n+            self.body,\n+            &self.local_names,\n+            &mut err,\n+            \"\",\n+            None,\n+        );\n \n         let within = if borrow_spans.for_generator() {\n             \" by generator\"\n@@ -1478,7 +1508,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(location, loan, None)\n-            .add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n+            .add_explanation_to_diagnostic(\n+                self.infcx.tcx,\n+                self.body,\n+                &self.local_names,\n+                &mut err,\n+                \"\",\n+                None,\n+            );\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -1496,14 +1533,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assigned_span: Span,\n         err_place: &Place<'tcx>,\n     ) {\n-        let (from_arg, local_decl) = if let Some(local) = err_place.as_local() {\n-            if let LocalKind::Arg = self.body.local_kind(local) {\n-                (true, Some(&self.body.local_decls[local]))\n-            } else {\n-                (false, Some(&self.body.local_decls[local]))\n-            }\n-        } else {\n-            (false, None)\n+        let (from_arg, local_decl, local_name) = match err_place.as_local() {\n+            Some(local) => (\n+                self.body.local_kind(local) == LocalKind::Arg,\n+                Some(&self.body.local_decls[local]),\n+                self.local_names[local],\n+            ),\n+            None => (false, None, None),\n         };\n \n         // If root local is initialized immediately (everything apart from let\n@@ -1553,7 +1589,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n         if let Some(decl) = local_decl {\n-            if let Some(name) = decl.name {\n+            if let Some(name) = local_name {\n                 if decl.can_be_made_mutable() {\n                     err.span_suggestion(\n                         decl.source_info.span,"}, {"sha": "a555e0b74c2b780c440720980ef2bdb3afb83769", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -331,10 +331,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n     /// a name, or its name was generated by the compiler, then `Err` is returned\n-    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n-        let local = &self.body.local_decls[local_index];\n-        match local.name {\n-            Some(name) if !local.from_compiler_desugaring() => {\n+    fn append_local_to_string(&self, local: Local, buf: &mut String) -> Result<(), ()> {\n+        let decl = &self.body.local_decls[local];\n+        match self.local_names[local] {\n+            Some(name) if !decl.from_compiler_desugaring() => {\n                 buf.push_str(&name.as_str());\n                 Ok(())\n             }"}, {"sha": "8a74e3a74add74085eaa738787fbd8b17f275f48", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -115,6 +115,20 @@ fn do_mir_borrowck<'a, 'tcx>(\n         .as_local_hir_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n+    let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n+    for var_debug_info in &input_body.var_debug_info {\n+        if let Some(local) = var_debug_info.place.as_local() {\n+            if let Some(prev_name) = local_names[local] {\n+                if var_debug_info.name != prev_name {\n+                    span_bug!(var_debug_info.source_info.span,\n+                        \"local {:?} has many names (`{}` vs `{}`)\",\n+                        local, prev_name, var_debug_info.name);\n+                }\n+            }\n+            local_names[local] = Some(var_debug_info.name);\n+        }\n+    }\n+\n     // Gather the upvars of a closure, if any.\n     let tables = tcx.typeck_tables_of(def_id);\n     let upvars: Vec<_> = tables\n@@ -189,6 +203,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         free_regions,\n         body,\n         &promoted,\n+        &local_names,\n         &upvars,\n         location_table,\n         param_env,\n@@ -264,6 +279,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         borrow_set,\n         dominators,\n         upvars,\n+        local_names,\n     };\n \n     let mut state = Flows::new(\n@@ -325,13 +341,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n         if let ClearCrossCrate::Set(ref vsi) = mbcx.body.source_scope_local_data {\n             let local_decl = &mbcx.body.local_decls[local];\n \n-            // Skip implicit `self` argument for closures\n-            if local.index() == 1 && tcx.is_closure(mbcx.mir_def_id) {\n-                continue;\n-            }\n-\n             // Skip over locals that begin with an underscore or have no name\n-            match local_decl.name {\n+            match mbcx.local_names[local] {\n                 Some(name) => if name.as_str().starts_with(\"_\") {\n                     continue;\n                 },\n@@ -463,6 +474,9 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Information about upvars not necessarily preserved in types or MIR\n     upvars: Vec<Upvar>,\n+\n+    /// Names of local (user) variables (extracted from `var_debug_info`).\n+    local_names: IndexVec<Local, Option<Name>>,\n }\n \n // Check that:"}, {"sha": "bf61eb9f0c5c7c4af0c7e315806471e4f80a0952", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of(\n                     span,\n-                    &format!(\"`{}` in pattern guard\", decl.name.unwrap()),\n+                    &format!(\"`{}` in pattern guard\", self.local_names[*local].unwrap()),\n                 );\n                 err.note(\n                     \"variables bound in patterns cannot be moved from \\\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             if binds_to.len() == 1 {\n                 self.note_type_does_not_implement_copy(\n                     err,\n-                    &format!(\"`{}`\", bind_to.name.unwrap()),\n+                    &format!(\"`{}`\", self.local_names[*local].unwrap()),\n                     bind_to.ty,\n                     Some(binding_span)\n                 );"}, {"sha": "bf070c3f07d48d68aef87731bcac5b4390fdcf8e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -50,8 +50,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.body.local_decls[*local]\n-                        .name\n+                    let name = self.local_names[*local]\n                         .expect(\"immutable unnamed local\");\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n@@ -253,7 +252,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // Deliberately fall into this case for all implicit self types,\n                         // so that we don't fall in to the next case with them.\n                         kind == mir::ImplicitSelfKind::MutRef\n-                    } else if Some(kw::SelfLower) == local_decl.name {\n+                    } else if Some(kw::SelfLower) == self.local_names[*local] {\n                         // Otherwise, check if the name is the self kewyord - in which case\n                         // we have an explicit self. Do the same thing in this case and check\n                         // for a `self: &mut Self` to suggest removing the `&mut`.\n@@ -290,7 +289,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_suggestion(\n                     local_decl.source_info.span,\n                     \"consider changing this to be mutable\",\n-                    format!(\"mut {}\", local_decl.name.unwrap()),\n+                    format!(\"mut {}\", self.local_names[*local].unwrap()),\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -415,7 +414,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                match local_decl.name {\n+                match self.local_names[*local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n                         err.span_label(\n                             span,"}, {"sha": "c7058531958e193ebf8572c17210b3306b9972ef", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -11,9 +11,11 @@ use rustc::mir::{\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::adjustment::{PointerCast};\n+use rustc_index::vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n mod find_use;\n \n@@ -56,6 +58,7 @@ impl BorrowExplanation {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,\n         borrow_span: Option<Span>,\n@@ -112,7 +115,7 @@ impl BorrowExplanation {\n                     _ => (\"destructor\", format!(\"type `{}`\", local_decl.ty)),\n                 };\n \n-                match local_decl.name {\n+                match local_names[dropped_local] {\n                     Some(local_name) if !local_decl.from_compiler_desugaring() => {\n                         let message = format!(\n                             \"{B}borrow might be used here, when `{LOC}` is dropped \\\n@@ -271,10 +274,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Some(Cause::DropVar(local, location)) => {\n                 let mut should_note_order = false;\n-                if body.local_decls[local].name.is_some() {\n+                if self.local_names[local].is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Some(borrowed_local) = place.as_local() {\n-                             if body.local_decls[borrowed_local].name.is_some()\n+                            if self.local_names[borrowed_local].is_some()\n                                 && local != borrowed_local\n                             {\n                                 should_note_order = true;\n@@ -295,6 +298,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n                             self.body,\n+                        &self.local_names,\n                         &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n@@ -495,7 +499,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Operand::Move(place) => {\n                                 if let Some(l) = place.as_local() {\n                                     let local_decl = &self.body.local_decls[l];\n-                                    if local_decl.name.is_none() {\n+                                    if self.local_names[l].is_none() {\n                                         local_decl.source_info.span\n                                     } else {\n                                         span"}, {"sha": "4d67b72c98c57e4f0f11bf9b0c77823212fe419f", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -16,6 +16,7 @@ use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements,\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_index::vec::IndexVec;\n use rustc_errors::Diagnostic;\n+use syntax_pos::symbol::Symbol;\n use std::fmt::Debug;\n use std::env;\n use std::io;\n@@ -158,6 +159,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    local_names: &IndexVec<Local, Option<Symbol>>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -281,7 +283,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, &body, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, body, local_names, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "5e79a2fea9b735b7093e3e8b2dcb2aded39d28cf", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -9,14 +9,15 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::mir::{ConstraintCategory, Location, Body};\n+use rustc::mir::{ConstraintCategory, Local, Location, Body};\n use rustc::ty::{self, RegionVid};\n use rustc_index::vec::IndexVec;\n use rustc_errors::DiagnosticBuilder;\n use std::collections::VecDeque;\n use syntax::errors::Applicability;\n use syntax::symbol::kw;\n use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n use self::outlives_suggestion::OutlivesSuggestionBuilder;\n \n@@ -71,6 +72,9 @@ pub struct ErrorReportingCtx<'a, 'b, 'tcx> {\n     /// The MIR body we are reporting errors on (for convenience).\n     body: &'b Body<'tcx>,\n \n+    /// User variable names for MIR locals (where applicable).\n+    local_names: &'b IndexVec<Local, Option<Symbol>>,\n+\n     /// Any upvars for the MIR body we have kept track of during borrow checking.\n     upvars: &'b [Upvar],\n }\n@@ -367,13 +371,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn report_error<'a>(\n         &'a self,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n@@ -407,6 +412,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             infcx,\n             mir_def_id,\n             body,\n+            local_names,\n             upvars,\n         };\n \n@@ -551,17 +557,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'_> {\n         let ErrorReportingCtx {\n-            infcx, body, upvars, ..\n+            infcx, body, upvars, local_names, ..\n         } = errctx;\n \n         let ErrorConstraintInfo {\n             span, category, ..\n         } = errci;\n \n         let fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.fr);\n-        let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, local_names, upvars, errci.fr);\n+        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n+            infcx.tcx,\n+            body,\n+            local_names,\n+            upvars,\n+            errci.outlived_fr,\n+        );\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -789,6 +800,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn free_region_constraint_info(\n         &self,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -804,7 +816,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut renctx = RegionErrorNamingCtx::new();\n         let errctx = ErrorReportingCtx {\n-            infcx, body, upvars, mir_def_id,\n+            infcx, body, local_names, upvars, mir_def_id,\n             region_infcx: self,\n         };\n         let outlived_fr_name = self.give_region_a_name(&errctx, &mut renctx, outlived_region);"}, {"sha": "c0cf4eb5285c92d9528a483acc1be7cb583a25c7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/outlives_suggestion.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Foutlives_suggestion.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -4,9 +4,12 @@\n use std::collections::BTreeMap;\n \n use log::debug;\n-use rustc::{hir::def_id::DefId, infer::InferCtxt, mir::Body, ty::RegionVid};\n+use rustc::{hir::def_id::DefId, infer::InferCtxt, ty::RegionVid};\n+use rustc::mir::{Body, Local};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n+use rustc_index::vec::IndexVec;\n+use syntax_pos::symbol::Symbol;\n \n use smallvec::SmallVec;\n \n@@ -34,10 +37,12 @@ enum SuggestedConstraint {\n /// corresponding to a function definition.\n ///\n /// Adds a help note suggesting adding a where clause with the needed constraints.\n-pub struct OutlivesSuggestionBuilder {\n+pub struct OutlivesSuggestionBuilder<'a> {\n     /// The MIR DefId of the fn with the lifetime error.\n     mir_def_id: DefId,\n \n+    local_names: &'a IndexVec<Local, Option<Symbol>>,\n+\n     /// The list of outlives constraints that need to be added. Specifically, we map each free\n     /// region to all other regions that it must outlive. I will use the shorthand `fr:\n     /// outlived_frs`. Not all of these regions will already have names necessarily. Some could be\n@@ -46,10 +51,17 @@ pub struct OutlivesSuggestionBuilder {\n     constraints_to_add: BTreeMap<RegionVid, Vec<RegionVid>>,\n }\n \n-impl OutlivesSuggestionBuilder {\n+impl OutlivesSuggestionBuilder<'a> {\n     /// Create a new builder for the given MIR node representing a fn definition.\n-    crate fn new(mir_def_id: DefId) -> Self {\n-        OutlivesSuggestionBuilder { mir_def_id, constraints_to_add: BTreeMap::default() }\n+    crate fn new(\n+        mir_def_id: DefId,\n+        local_names: &'a IndexVec<Local, Option<Symbol>>,\n+    ) -> Self {\n+        OutlivesSuggestionBuilder {\n+            mir_def_id,\n+            local_names,\n+            constraints_to_add: BTreeMap::default(),\n+        }\n     }\n \n     /// Returns `true` iff the `RegionNameSource` is a valid source for an outlives\n@@ -125,6 +137,7 @@ impl OutlivesSuggestionBuilder {\n             infcx,\n             body,\n             mir_def_id: self.mir_def_id,\n+            local_names: self.local_names,\n \n             // We should not be suggesting naming upvars, so we pass in a dummy set of upvars that\n             // should never be used."}, {"sha": "e59928987a03c8c70b1a4c9bbc431867e1170e30", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -11,10 +11,11 @@ use rustc::hir;\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::Body;\n+use rustc::mir::{Local, Body};\n use rustc::ty::subst::{SubstsRef, GenericArgKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n+use rustc_index::vec::IndexVec;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n use rustc_data_structures::fx::FxHashMap;\n@@ -210,7 +211,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n     ) -> Option<RegionName> {\n         let ErrorReportingCtx {\n-            infcx, body, mir_def_id, upvars, ..\n+            infcx, body, mir_def_id, local_names, upvars, ..\n         } = errctx;\n \n         debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n@@ -225,7 +226,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .give_name_from_error_region(infcx.tcx, *mir_def_id, fr, renctx)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, body, *mir_def_id, fr, renctx,\n+                    infcx, body, local_names, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n@@ -395,6 +396,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n@@ -415,7 +417,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, renctx)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, body, local_names, fr, arg_ty, renctx)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -463,6 +465,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         renctx: &mut RegionErrorNamingCtx,\n@@ -479,7 +482,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n             let argument_index = self.get_argument_index_for_region(infcx.tcx, needle_fr)?;\n-            let (_, span) = self.get_argument_name_and_span_for_region(body, argument_index);\n+            let (_, span) =\n+                self.get_argument_name_and_span_for_region(body, local_names, argument_index);\n \n             Some(RegionName {\n                 // This counter value will already have been used, so this function will increment"}, {"sha": "1ac44c4fdb10115db4cda7fde070c5d4c144bc30", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -3,7 +3,7 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n use rustc::mir::{Local, Body};\n use rustc::ty::{RegionVid, TyCtxt};\n-use rustc_index::vec::Idx;\n+use rustc_index::vec::{Idx, IndexVec};\n use syntax::source_map::Span;\n use syntax_pos::symbol::Symbol;\n \n@@ -12,6 +12,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n@@ -27,8 +28,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             })\n             .or_else(|| {\n                 debug!(\"get_var_name_and_span_for_region: attempting argument\");\n-                self.get_argument_index_for_region(tcx, fr)\n-                    .map(|index| self.get_argument_name_and_span_for_region(body, index))\n+                self.get_argument_index_for_region(tcx, fr).map(|index| {\n+                    self.get_argument_name_and_span_for_region(body, local_names, index)\n+                })\n             })\n     }\n \n@@ -117,13 +119,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_argument_name_and_span_for_region(\n         &self,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n \n-        let argument_name = body.local_decls[argument_local].name;\n+        let argument_name = local_names[argument_local];\n         let argument_span = body.local_decls[argument_local].source_info.span;\n         debug!(\"get_argument_name_and_span_for_region: argument_name={:?} argument_span={:?}\",\n                argument_name, argument_span);"}, {"sha": "d44e85fa7900db2728a35bdf91ac169e8ef2ff99", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -36,6 +36,7 @@ use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_index::vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n crate use self::error_reporting::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n use self::values::{LivenessValues, RegionValueElements, RegionValues};\n@@ -471,6 +472,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -502,6 +504,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.check_universal_regions(\n             infcx,\n             body,\n+            local_names,\n             upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n@@ -1321,13 +1324,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n         region_naming: &mut RegionErrorNamingCtx,\n     ) {\n-        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id);\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id, local_names);\n \n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n@@ -1338,6 +1342,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_universal_region(\n                         infcx,\n                         body,\n+                        local_names,\n                         upvars,\n                         mir_def_id,\n                         fr,\n@@ -1374,11 +1379,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n         errors_buffer: &mut Vec<Diagnostic>,\n         region_naming: &mut RegionErrorNamingCtx,\n     ) {\n@@ -1404,6 +1410,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 representative,\n                 infcx,\n                 body,\n+                local_names,\n                 upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n@@ -1422,6 +1429,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 shorter_fr,\n                 infcx,\n                 body,\n+                local_names,\n                 upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n@@ -1445,10 +1453,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         shorter_fr: RegionVid,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n         errors_buffer: &mut Vec<Diagnostic>,\n         region_naming: &mut RegionErrorNamingCtx,\n     ) -> Option<ErrorReported> {\n@@ -1502,6 +1511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // error. This gives better error messages in some cases.\n         let db = self.report_error(\n             body,\n+            local_names,\n             upvars,\n             infcx,\n             mir_def_id,"}, {"sha": "f5dc09ccebc1e65b96902296c5640a1fc7377934", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -227,9 +227,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         mutability: Mutability::Mut,\n                         ty: ptr_ty,\n                         user_ty: UserTypeProjections::none(),\n-                        name: None,\n                         source_info,\n-                        visibility_scope: source_info.scope,\n                         internal: true,\n                         local_info: LocalInfo::Other,\n                         is_block_tail: None,"}, {"sha": "032ea7d8161cbf53e75fb60b599a0595219338d9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -1721,6 +1721,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n \n         let tcx = self.hir.tcx();\n+        let debug_source_info = SourceInfo {\n+            span: source_info.span,\n+            scope: visibility_scope,\n+        };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability.into()),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability.into()),\n@@ -1730,9 +1734,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             mutability,\n             ty: var_ty,\n             user_ty,\n-            name: Some(name),\n             source_info,\n-            visibility_scope,\n             internal: false,\n             is_block_tail: None,\n             local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n@@ -1749,20 +1751,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n+        self.var_debug_info.push(VarDebugInfo {\n+            name,\n+            source_info: debug_source_info,\n+            place: for_arm_body.into(),\n+        });\n         let locals = if has_guard.0 {\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n                 // This variable isn't mutated but has a name, so has to be\n                 // immutable to avoid the unused mut lint.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.lifetimes.re_erased, var_ty),\n                 user_ty: UserTypeProjections::none(),\n-                name: Some(name),\n                 source_info,\n-                visibility_scope,\n                 internal: false,\n                 is_block_tail: None,\n                 local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n+            self.var_debug_info.push(VarDebugInfo {\n+                name,\n+                source_info: debug_source_info,\n+                place: ref_for_guard.into(),\n+            });\n             LocalsForNode::ForGuard {\n                 ref_for_guard,\n                 for_arm_body,"}, {"sha": "180f2cc089f020ca947c54a5723b2e726173da56", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 109, "deletions": 77, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -161,8 +161,18 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n                 (None, fn_sig.output())\n             };\n \n-            build::construct_fn(cx, id, arguments, safety, abi,\n-                                return_ty, yield_ty, return_ty_span, body)\n+            let mut mir = build::construct_fn(\n+                cx,\n+                id,\n+                arguments,\n+                safety,\n+                abi,\n+                return_ty,\n+                return_ty_span,\n+                body,\n+            );\n+            mir.yield_ty = yield_ty;\n+            mir\n         } else {\n             // Get the revealed type of this const. This is *not* the adjusted\n             // type of its body, which may be a subtype of this type. For\n@@ -312,10 +322,11 @@ struct Builder<'a, 'tcx> {\n     var_indices: HirIdMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n-    __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n     upvar_mutbls: Vec<Mutability>,\n     unit_temp: Option<Place<'tcx>>,\n \n+    var_debug_info: Vec<VarDebugInfo<'tcx>>,\n+\n     /// Cached block with the `RESUME` terminator; this is created\n     /// when first set of cleanups are built.\n     cached_resume_block: Option<BasicBlock>,\n@@ -539,7 +550,6 @@ fn construct_fn<'a, 'tcx, A>(\n     safety: Safety,\n     abi: Abi,\n     return_ty: Ty<'tcx>,\n-    yield_ty: Option<Ty<'tcx>>,\n     return_ty_span: Span,\n     body: &'tcx hir::Body,\n ) -> Body<'tcx>\n@@ -552,58 +562,14 @@ where\n     let tcx_hir = tcx.hir();\n     let span = tcx_hir.span(fn_id);\n \n-    let hir_tables = hir.tables();\n     let fn_def_id = tcx_hir.local_def_id(fn_id);\n \n-    // Gather the upvars of a closure, if any.\n-    let mut upvar_mutbls = vec![];\n-    // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n-    // closure and we stored in a map called upvar_list in TypeckTables indexed\n-    // with the closure's DefId. Here, we run through that vec of UpvarIds for\n-    // the given closure and use the necessary information to create UpvarDecl.\n-    let upvar_debuginfo: Vec<_> = hir_tables\n-        .upvar_list\n-        .get(&fn_def_id)\n-        .into_iter()\n-        .flatten()\n-        .map(|(&var_hir_id, &upvar_id)| {\n-            let capture = hir_tables.upvar_capture(upvar_id);\n-            let by_ref = match capture {\n-                ty::UpvarCapture::ByValue => false,\n-                ty::UpvarCapture::ByRef(..) => true,\n-            };\n-            let mut debuginfo = UpvarDebuginfo {\n-                debug_name: kw::Invalid,\n-                by_ref,\n-            };\n-            let mut mutability = Mutability::Not;\n-            if let Some(Node::Binding(pat)) = tcx_hir.find(var_hir_id) {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n-                    debuginfo.debug_name = ident.name;\n-                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                        if bm == ty::BindByValue(hir::Mutability::Mutable) {\n-                            mutability = Mutability::Mut;\n-                        } else {\n-                            mutability = Mutability::Not;\n-                        }\n-                    } else {\n-                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n-                    }\n-                }\n-            }\n-            upvar_mutbls.push(mutability);\n-            debuginfo\n-        })\n-        .collect();\n-\n     let mut builder = Builder::new(hir,\n         span,\n         arguments.len(),\n         safety,\n         return_ty,\n         return_ty_span,\n-        upvar_debuginfo,\n-        upvar_mutbls,\n         body.generator_kind.is_some());\n \n     let call_site_scope = region::Scope {\n@@ -631,7 +597,7 @@ where\n             Place::return_place(),\n             |builder| {\n                 builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                    builder.args_and_body(block, &arguments, arg_scope, &body.value)\n+                    builder.args_and_body(block, fn_def_id, &arguments, arg_scope, &body.value)\n                 })\n             },\n         ));\n@@ -660,7 +626,7 @@ where\n     info!(\"fn_id {:?} has attrs {:?}\", fn_def_id,\n           tcx.get_attrs(fn_def_id));\n \n-    let mut body = builder.finish(yield_ty);\n+    let mut body = builder.finish();\n     body.spread_arg = spread_arg;\n     body\n }\n@@ -681,8 +647,6 @@ fn construct_const<'a, 'tcx>(\n         Safety::Safe,\n         const_ty,\n         const_ty_span,\n-        vec![],\n-        vec![],\n         false,\n     );\n \n@@ -704,7 +668,7 @@ fn construct_const<'a, 'tcx>(\n                               TerminatorKind::Unreachable);\n     }\n \n-    builder.finish(None)\n+    builder.finish()\n }\n \n fn construct_error<'a, 'tcx>(\n@@ -714,10 +678,10 @@ fn construct_error<'a, 'tcx>(\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![], vec![], false);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, false);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish(None)\n+    builder.finish()\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -727,8 +691,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n-           __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n-           upvar_mutbls: Vec<Mutability>,\n            is_generator: bool)\n            -> Builder<'a, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n@@ -751,10 +713,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 1,\n             ),\n             canonical_user_type_annotations: IndexVec::new(),\n-            __upvar_debuginfo_codegen_only_do_not_use,\n-            upvar_mutbls,\n+            upvar_mutbls: vec![],\n             var_indices: Default::default(),\n             unit_temp: None,\n+            var_debug_info: vec![],\n             cached_resume_block: None,\n             cached_return_block: None,\n             cached_unreachable_block: None,\n@@ -769,9 +731,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         builder\n     }\n \n-    fn finish(self,\n-              yield_ty: Option<Ty<'tcx>>)\n-              -> Body<'tcx> {\n+    fn finish(self) -> Body<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n                 span_bug!(self.fn_span, \"no terminator on block {:?}\", index);\n@@ -782,47 +742,119 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.cfg.basic_blocks,\n             self.source_scopes,\n             ClearCrossCrate::Set(self.source_scope_local_data),\n-            yield_ty,\n             self.local_decls,\n             self.canonical_user_type_annotations,\n             self.arg_count,\n-            self.__upvar_debuginfo_codegen_only_do_not_use,\n+            self.var_debug_info,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n         )\n     }\n \n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n+                     fn_def_id: DefId,\n                      arguments: &[ArgInfo<'tcx>],\n                      argument_scope: region::Scope,\n                      ast_body: &'tcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n-            // If this is a simple binding pattern, give the local a name for\n-            // debuginfo and so that error reporting knows that this is a user\n-            // variable. For any other pattern the pattern introduces new\n-            // variables which will be named instead.\n-            let (name, span) = if let Some(arg) = arg_opt {\n-                (arg.pat.simple_ident().map(|ident| ident.name), arg.pat.span)\n-            } else {\n-                (None, self.fn_span)\n+            let source_info = SourceInfo {\n+                scope: OUTERMOST_SOURCE_SCOPE,\n+                span: arg_opt.map_or(self.fn_span, |arg| arg.pat.span)\n             };\n-\n-            let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span, };\n-            self.local_decls.push(LocalDecl {\n+            let arg_local = self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n                 user_ty: UserTypeProjections::none(),\n                 source_info,\n-                visibility_scope: source_info.scope,\n-                name,\n                 internal: false,\n                 local_info: LocalInfo::Other,\n                 is_block_tail: None,\n             });\n+\n+            // If this is a simple binding pattern, give debuginfo a nice name.\n+            if let Some(arg) = arg_opt {\n+                if let Some(ident) = arg.pat.simple_ident() {\n+                    self.var_debug_info.push(VarDebugInfo {\n+                        name: ident.name,\n+                        source_info,\n+                        place: arg_local.into(),\n+                    });\n+                }\n+            }\n+        }\n+\n+        let tcx = self.hir.tcx();\n+        let tcx_hir = tcx.hir();\n+        let hir_tables = self.hir.tables();\n+\n+        // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n+        // closure and we stored in a map called upvar_list in TypeckTables indexed\n+        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n+        // the given closure and use the necessary information to create upvar\n+        // debuginfo and to fill `self.upvar_mutbls`.\n+        if let Some(upvars) = hir_tables.upvar_list.get(&fn_def_id) {\n+            let closure_env_arg = Local::new(1);\n+            let mut closure_env_projs = vec![];\n+            let mut closure_ty = self.local_decls[closure_env_arg].ty;\n+            if let ty::Ref(_, ty, _) = closure_ty.kind {\n+                closure_env_projs.push(ProjectionElem::Deref);\n+                closure_ty = ty;\n+            }\n+            let (def_id, upvar_substs) = match closure_ty.kind {\n+                ty::Closure(def_id, substs) => (def_id, ty::UpvarSubsts::Closure(substs)),\n+                ty::Generator(def_id, substs, _) => (def_id, ty::UpvarSubsts::Generator(substs)),\n+                _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty)\n+            };\n+            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n+            let upvars_with_tys = upvars.iter().zip(upvar_tys);\n+            self.upvar_mutbls = upvars_with_tys.enumerate().map(|(i, ((&var_id, &upvar_id), ty))| {\n+                let capture = hir_tables.upvar_capture(upvar_id);\n+\n+                let mut mutability = Mutability::Not;\n+                let mut name = kw::Invalid;\n+                if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n+                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                        name = ident.name;\n+\n+                        if let Some(&bm) = hir_tables.pat_binding_modes().get(pat.hir_id) {\n+                            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n+                                mutability = Mutability::Mut;\n+                            } else {\n+                                mutability = Mutability::Not;\n+                            }\n+                        } else {\n+                            tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+                        }\n+                    }\n+                }\n+\n+                let mut projs = closure_env_projs.clone();\n+                projs.push(ProjectionElem::Field(Field::new(i), ty));\n+                match capture {\n+                    ty::UpvarCapture::ByValue => {}\n+                    ty::UpvarCapture::ByRef(..) => {\n+                        projs.push(ProjectionElem::Deref);\n+                    }\n+                };\n+\n+                self.var_debug_info.push(VarDebugInfo {\n+                    name,\n+                    source_info: SourceInfo {\n+                        scope: OUTERMOST_SOURCE_SCOPE,\n+                        span: tcx_hir.span(var_id),\n+                    },\n+                    place: Place {\n+                        base: closure_env_arg.into(),\n+                        projection: tcx.intern_place_elems(&projs),\n+                    },\n+                });\n+\n+                mutability\n+            }).collect();\n         }\n \n         let mut scope = None;"}, {"sha": "b5cb6a92816beb656c7985e050324ca8b78b0e5a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -148,9 +148,7 @@ fn temp_decl(mutability: Mutability, ty: Ty<'_>, span: Span) -> LocalDecl<'_> {\n         mutability,\n         ty,\n         user_ty: UserTypeProjections::none(),\n-        name: None,\n         source_info,\n-        visibility_scope: source_info.scope,\n         internal: false,\n         local_info: LocalInfo::Other,\n         is_block_tail: None,\n@@ -204,7 +202,6 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n             SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n-        None,\n         local_decls_for_sig(&sig, span),\n         IndexVec::new(),\n         sig.inputs().len(),\n@@ -371,7 +368,6 @@ impl CloneShimBuilder<'tcx> {\n                 SourceScopeData { span: self.span, parent_scope: None }, 1\n             ),\n             ClearCrossCrate::Clear,\n-            None,\n             self.local_decls,\n             IndexVec::new(),\n             self.sig.inputs().len(),\n@@ -832,7 +828,6 @@ fn build_call_shim<'tcx>(\n             SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n-        None,\n         local_decls,\n         IndexVec::new(),\n         sig.inputs().len(),\n@@ -919,7 +914,6 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n             SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n-        None,\n         local_decls,\n         IndexVec::new(),\n         sig.inputs().len(),"}, {"sha": "8de16308e8375c950e24fb05fdbce3684f721613", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -85,7 +85,6 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n                 body.basic_blocks().clone(),\n                 Default::default(),\n                 ClearCrossCrate::Clear,\n-                None,\n                 body.local_decls.clone(),\n                 Default::default(),\n                 body.arg_count,"}, {"sha": "a904c6a3ada0f644292b2c2546cad8c7ca316a58", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -62,7 +62,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_index::bit_set::{BitSet, BitMatrix};\n use std::borrow::Cow;\n use std::iter;\n-use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n@@ -427,9 +426,7 @@ fn replace_result_variable<'tcx>(\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n         user_ty: UserTypeProjections::none(),\n-        name: None,\n         source_info,\n-        visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n         local_info: LocalInfo::Other\n@@ -788,18 +785,12 @@ fn compute_layout<'tcx>(\n         }\n     }\n \n-    let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), body.span);\n-\n-    // Gather live locals and their indices replacing values in body.local_decls\n-    // with a dummy to avoid changing local indices.\n+    // Gather live local types and their indices.\n     let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n     let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n-    let mut decls = IndexVec::<GeneratorSavedLocal, _>::new();\n     for (idx, local) in live_locals.iter().enumerate() {\n-        let var = mem::replace(&mut body.local_decls[local], dummy_local.clone());\n         locals.push(local);\n-        tys.push(var.ty);\n-        decls.push(var);\n+        tys.push(body.local_decls[local].ty);\n         debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n     }\n \n@@ -831,7 +822,6 @@ fn compute_layout<'tcx>(\n         field_tys: tys,\n         variant_fields,\n         storage_conflicts,\n-        __local_debuginfo_codegen_only_do_not_use: decls,\n     };\n \n     (remap, layout, storage_liveness)\n@@ -962,9 +952,7 @@ fn create_generator_drop_shim<'tcx>(\n         mutability: Mutability::Mut,\n         ty: tcx.mk_unit(),\n         user_ty: UserTypeProjections::none(),\n-        name: None,\n         source_info,\n-        visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n         local_info: LocalInfo::Other\n@@ -980,9 +968,7 @@ fn create_generator_drop_shim<'tcx>(\n             mutbl: hir::Mutability::Mutable,\n         }),\n         user_ty: UserTypeProjections::none(),\n-        name: None,\n         source_info,\n-        visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n         local_info: LocalInfo::Other"}, {"sha": "867673beb35ccd8e49003cf89a47b44e232d518d", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -219,13 +219,6 @@ impl Inliner<'tcx> {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n-        // Don't inline closures that have capture debuginfo\n-        // FIXME: Handle closures better\n-        if callee_body.__upvar_debuginfo_codegen_only_do_not_use.len() > 0 {\n-            debug!(\"    upvar debuginfo present - not inlining\");\n-            return false;\n-        }\n-\n         // Cannot inline generators which haven't been transformed yet\n         if callee_body.yield_ty.is_some() {\n             debug!(\"    yield ty present - not inlining\");\n@@ -413,7 +406,6 @@ impl Inliner<'tcx> {\n                     local.source_info.scope =\n                         scope_map[local.source_info.scope];\n                     local.source_info.span = callsite.location.span;\n-                    local.visibility_scope = scope_map[local.visibility_scope];\n \n                     let idx = caller_body.local_decls.push(local);\n                     local_map.push(idx);\n@@ -484,6 +476,10 @@ impl Inliner<'tcx> {\n                     tcx: self.tcx,\n                 };\n \n+                for mut var_debug_info in callee_body.var_debug_info.drain(..) {\n+                    integrator.visit_var_debug_info(&mut var_debug_info);\n+                    caller_body.var_debug_info.push(var_debug_info);\n+                }\n \n                 for (bb, mut block) in callee_body.basic_blocks_mut().drain_enumerated(..) {\n                     integrator.visit_basic_block_data(bb, &mut block);"}, {"sha": "c92c59dd2f79caed942c748b3af26070eae584c4", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -1098,7 +1098,6 @@ pub fn promote_candidates<'tcx>(\n                 // memory usage?\n                 body.source_scopes.clone(),\n                 body.source_scope_local_data.clone(),\n-                None,\n                 initial_locals,\n                 IndexVec::new(),\n                 0,"}, {"sha": "c9185d14148c129bd5fea8f409a3f194d6305acf", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -32,7 +32,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Visitor, PlaceContext, MutatingUseContext};\n-use rustc::session::config::DebugInfo;\n use std::borrow::Cow;\n use crate::transform::{MirPass, MirSource};\n \n@@ -307,13 +306,6 @@ impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n                 marker.locals.insert(arg);\n             }\n \n-            // We may need to keep dead user variables live for debuginfo.\n-            if tcx.sess.opts.debuginfo == DebugInfo::Full {\n-                for local in body.vars_iter() {\n-                    marker.locals.insert(local);\n-                }\n-            }\n-\n             marker.locals\n         };\n "}, {"sha": "28f68ac2de037dccadfcee9f33e62ced3987c333", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -362,6 +362,7 @@ impl<'tcx> Visitor<'tcx> for RestoreDataCollector {\n         match context {\n             PlaceContext::NonUse(NonUseContext::StorageLive) => local_use.alive = Some(location),\n             PlaceContext::NonUse(NonUseContext::StorageDead) => local_use.dead = Some(location),\n+            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {}\n             _ => {\n                 local_use.use_count += 1;\n                 if local_use.first_use.is_none() {"}, {"sha": "1611caddad1a6fe5344c91a40a6c4d44fbf54c33", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -1,6 +1,6 @@\n //! Def-use analysis.\n \n-use rustc::mir::{Body, Local, Location, PlaceElem};\n+use rustc::mir::{Body, Local, Location, PlaceElem, VarDebugInfo};\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n use rustc_index::vec::IndexVec;\n@@ -12,7 +12,9 @@ pub struct DefUseAnalysis {\n \n #[derive(Clone)]\n pub struct Info {\n+    // FIXME(eddyb) use smallvec where possible.\n     pub defs_and_uses: Vec<Use>,\n+    var_debug_info_indices: Vec<usize>,\n }\n \n #[derive(Clone)]\n@@ -33,6 +35,8 @@ impl DefUseAnalysis {\n \n         let mut finder = DefUseFinder {\n             info: mem::take(&mut self.info),\n+            var_debug_info_index: 0,\n+            in_var_debug_info: false,\n         };\n         finder.visit_body(body);\n         self.info = finder.info\n@@ -55,9 +59,14 @@ impl DefUseAnalysis {\n         new_local: Local,\n         tcx: TyCtxt<'tcx>,\n     ) {\n-        for place_use in &self.info[local].defs_and_uses {\n-            MutateUseVisitor::new(local, new_local, body, tcx)\n-                .visit_location(body, place_use.location)\n+        let mut visitor = MutateUseVisitor::new(local, new_local, body, tcx);\n+        let info = &self.info[local];\n+        for place_use in &info.defs_and_uses {\n+            visitor.visit_location(body, place_use.location)\n+        }\n+        // Update debuginfo as well, alongside defs/uses.\n+        for &i in &info.var_debug_info_indices {\n+            visitor.visit_var_debug_info(&mut body.var_debug_info[i]);\n         }\n     }\n \n@@ -73,29 +82,45 @@ impl DefUseAnalysis {\n \n struct DefUseFinder {\n     info: IndexVec<Local, Info>,\n+    var_debug_info_index: usize,\n+    in_var_debug_info: bool,\n }\n \n impl Visitor<'_> for DefUseFinder {\n     fn visit_local(&mut self,\n                    &local: &Local,\n                    context: PlaceContext,\n                    location: Location) {\n-        self.info[local].defs_and_uses.push(Use {\n-            context,\n-            location,\n-        });\n+        let info = &mut self.info[local];\n+        if self.in_var_debug_info {\n+            info.var_debug_info_indices.push(self.var_debug_info_index);\n+        } else {\n+            info.defs_and_uses.push(Use {\n+                context,\n+                location,\n+            });\n+        }\n+    }\n+    fn visit_var_debug_info(&mut self, var_debug_info: &VarDebugInfo<'tcx>) {\n+        assert!(!self.in_var_debug_info);\n+        self.in_var_debug_info = true;\n+        self.super_var_debug_info(var_debug_info);\n+        self.in_var_debug_info = false;\n+        self.var_debug_info_index += 1;\n     }\n }\n \n impl Info {\n     fn new() -> Info {\n         Info {\n             defs_and_uses: vec![],\n+            var_debug_info_indices: vec![],\n         }\n     }\n \n     fn clear(&mut self) {\n         self.defs_and_uses.clear();\n+        self.var_debug_info_indices.clear();\n     }\n \n     pub fn def_count(&self) -> usize {"}, {"sha": "3a7ec9f038aa59023dbf8cfd42cf05329069d579", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -197,13 +197,13 @@ fn write_graph_label<'tcx, W: Write>(\n             write!(w, \"mut \")?;\n         }\n \n-        if let Some(name) = decl.name {\n-            write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-                   Place::from(local), escape(&decl.ty), name)?;\n-        } else {\n-            write!(w, r#\"{:?}: {};<br align=\"left\"/>\"#,\n-                   Place::from(local), escape(&decl.ty))?;\n-        }\n+        write!(w, r#\"{:?}: {};<br align=\"left\"/>\"#,\n+               Place::from(local), escape(&decl.ty))?;\n+    }\n+\n+    for var_debug_info in &body.var_debug_info {\n+        write!(w, r#\"debug {} => {};<br align=\"left\"/>\"#,\n+               var_debug_info.name, escape(&var_debug_info.place))?;\n     }\n \n     writeln!(w, \">;\")"}, {"sha": "63e4af0a56a75c8cda085b11dd7955ca2caa10be", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -183,6 +183,9 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n \n         PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n+\n+        // Debug info is neither def nor use.\n+        PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n     }\n }\n "}, {"sha": "36194335a555a6098367417e112386dd9aff24ea", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -463,6 +463,30 @@ fn write_scope_tree(\n ) -> io::Result<()> {\n     let indent = depth * INDENT.len();\n \n+    // Local variable debuginfo.\n+    for var_debug_info in &body.var_debug_info {\n+        if var_debug_info.source_info.scope != parent {\n+            // Not declared in this scope.\n+            continue;\n+        }\n+\n+        let indented_debug_info = format!(\n+            \"{0:1$}debug {2} => {3:?};\",\n+            INDENT,\n+            indent,\n+            var_debug_info.name,\n+            var_debug_info.place,\n+        );\n+\n+        writeln!(\n+            w,\n+            \"{0:1$} // in {2}\",\n+            indented_debug_info,\n+            ALIGN,\n+            comment(tcx, var_debug_info.source_info),\n+        )?;\n+    }\n+\n     // Local variable types (including the user's name in a comment).\n     for (local, local_decl) in body.local_decls.iter_enumerated() {\n         if (1..body.arg_count+1).contains(&local.index()) {\n@@ -496,8 +520,6 @@ fn write_scope_tree(\n \n         let local_name = if local == RETURN_PLACE {\n             format!(\" return place\")\n-        } else if let Some(name) = local_decl.name {\n-            format!(\" \\\"{}\\\"\", name)\n         } else {\n             String::new()\n         };"}, {"sha": "70820dfaea4a033de9c4b9b79f1fca0faace731c", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;"}, {"sha": "68545b7daaa5cafd70c25ab488f701743a85b611", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -22,7 +22,7 @@ pub fn change_name() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_name() {\n     let _y = 2u64;\n@@ -86,7 +86,7 @@ pub fn change_mutability_of_slot() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,typeck_tables_of,mir_built\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n@@ -182,7 +182,7 @@ pub fn add_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,typeck_tables_of,mir_built\")]\n+    except=\"HirBody,typeck_tables_of,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;\n@@ -198,7 +198,7 @@ pub fn change_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,mir_built\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_initializer() {\n     let _x = 5u16;"}, {"sha": "a2222db4c59ad37a57c59ba3a4bad2525a67cee5", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;"}, {"sha": "a427ffb96e33982c5c79ad67c80455734ef672ec", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -48,7 +48,7 @@ pub fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_condition() {\n     let mut _x = 0;"}, {"sha": "fa1a291858becca149f0abe544f4be40434da9e4", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -27,6 +27,7 @@ impl Drop for S {\n //     let _3: ();\n //     let mut _4: std::boxed::Box<S>;\n //     scope 1 {\n+//         debug x => _1;\n //     }\n //     bb0: {\n //         StorageLive(_1);"}, {"sha": "ecce0a08c7bf017eddb0269408493f27ca728d6f", "filename": "src/test/mir-opt/generator-storage-dead-unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -37,8 +37,10 @@ fn main() {\n // ...\n // let mut _9: Bar;\n // scope 1 {\n+//     debug a => _2;\n //     let _3: Bar;\n //     scope 2 {\n+//         debug b => _3;\n //     }\n // }\n // bb0: {"}, {"sha": "b5bfeef5e9c56ab41ad5865b920c494b5ee6c339", "filename": "src/test/mir-opt/inline-closure-borrows-arg.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -17,23 +17,43 @@ fn foo<T: Copy>(_t: T, q: &i32) -> i32 {\n \n // END RUST SOURCE\n // START rustc.foo.Inline.after.mir\n-// ...\n-// bb0: {\n-//     ...\n-//     _3 = [closure@HirId { owner: DefIndex(4), local_id: 31 }];\n-//     ...\n-//     _4 = &_3;\n-//     ...\n-//     _6 = &(*_2);\n-//     ...\n-//     _7 = &(*_2);\n-//     _5 = (move _6, move _7);\n-//     _8 = move (_5.0: &i32);\n-//     _9 = move (_5.1: &i32);\n-//     ...\n-//     _0 = (*_8);\n-//     ...\n-//     return;\n+// fn foo(_1: T, _2: &i32) -> i32{\n+//     debug _t => _1;\n+//     debug q => _2;\n+//     let mut _0: i32;\n+//     let _3: [closure@HirId { owner: DefIndex(4), local_id: 31 }];\n+//     let mut _4: &[closure@HirId { owner: DefIndex(4), local_id: 31 }];\n+//     let mut _5: (&i32, &i32);\n+//     let mut _6: &i32;\n+//     let mut _7: &i32;\n+//     let mut _8: &i32;\n+//     let mut _9: &i32;\n+//     scope 1 {\n+//         debug x => _3;\n+//         scope 2 {\n+//             debug r => _8;\n+//             debug _s => _9;\n+//         }\n+//     }\n+//     scope 3 {\n+//         debug variable => _8;\n+//     }\n+//     bb0: {\n+//         ...\n+//         _3 = [closure@HirId { owner: DefIndex(4), local_id: 31 }];\n+//         ...\n+//         _4 = &_3;\n+//         ...\n+//         _6 = &(*_2);\n+//         ...\n+//         _7 = &(*_2);\n+//         _5 = (move _6, move _7);\n+//         _8 = move (_5.0: &i32);\n+//         _9 = move (_5.1: &i32);\n+//         ...\n+//         _0 = (*_8);\n+//         ...\n+//         return;\n+//     }\n // }\n-// ...\n // END rustc.foo.Inline.after.mir"}, {"sha": "e73dbe48bd14307a97842466c190d432f41caf22", "filename": "src/test/mir-opt/inline-closure-captures.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Finline-closure-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Finline-closure-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-captures.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -0,0 +1,60 @@\n+// compile-flags: -Z span_free_formats\n+\n+// Tests that MIR inliner can handle closure captures.\n+\n+fn main() {\n+    println!(\"{:?}\", foo(0, 14));\n+}\n+\n+fn foo<T: Copy>(t: T, q: i32) -> (i32, T) {\n+    let x = |_q| (q, t);\n+    x(q)\n+}\n+\n+// END RUST SOURCE\n+// START rustc.foo.Inline.after.mir\n+// fn foo(_1: T, _2: i32) -> (i32, T){\n+//     debug t => _1;\n+//     debug q => _2;\n+//     let mut _0: (i32, T);\n+//     let _3: [closure@HirId { owner: DefIndex(4), local_id: 15 } q:&i32, t:&T];\n+//     let mut _4: &i32;\n+//     let mut _5: &T;\n+//     let mut _6: &[closure@HirId { owner: DefIndex(4), local_id: 15 } q:&i32, t:&T];\n+//     let mut _7: (i32,);\n+//     let mut _8: i32;\n+//     let mut _11: i32;\n+//     scope 1 {\n+//         debug x => _3;\n+//         scope 2 {\n+//             debug _q => _11;\n+//             debug q => (*((*_6).0: &i32));\n+//             debug t => (*((*_6).1: &T));\n+//             let mut _9: i32;\n+//             let mut _10: T;\n+//         }\n+//     }\n+//     bb0: {\n+//         ...\n+//         _4 = &_2;\n+//         ...\n+//         _5 = &_1;\n+//         _3 = [closure@HirId { owner: DefIndex(4), local_id: 15 }] { q: move _4, t: move _5 };\n+//         ...\n+//         _6 = &_3;\n+//         ...\n+//         ...\n+//         _8 = _2;\n+//         _7 = (move _8,);\n+//         _11 = move (_7.0: i32);\n+//         ...\n+//         _9 = (*((*_6).0: &i32));\n+//         ...\n+//         _10 = (*((*_6).1: &T));\n+//         (_0.0: i32) = move _9;\n+//         (_0.1: T) = move _10;\n+//         ...\n+//         return;\n+//     }\n+// }\n+// END rustc.foo.Inline.after.mir"}, {"sha": "ddf027f4be38aac0acbf83731490b2a82f316009", "filename": "src/test/mir-opt/inline-closure.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -13,22 +13,38 @@ fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n \n // END RUST SOURCE\n // START rustc.foo.Inline.after.mir\n-// ...\n-// bb0: {\n-//     ...\n-//     _3 = [closure@HirId { owner: DefIndex(4), local_id: 15 }];\n-//     ...\n-//     _4 = &_3;\n-//     ...\n-//     _6 = _2;\n-//     ...\n-//     _7 = _2;\n-//     _5 = (move _6, move _7);\n-//     _8 = move (_5.0: i32);\n-//     _9 = move (_5.1: i32);\n-//     _0 = _8;\n-//     ...\n-//     return;\n-// }\n-// ...\n+// fn foo(_1: T, _2: i32) -> i32{\n+//     debug _t => _1;\n+//     debug q => _2;\n+//     let mut _0: i32;\n+//     let _3: [closure@HirId { owner: DefIndex(4), local_id: 15 }];\n+//     let mut _4: &[closure@HirId { owner: DefIndex(4), local_id: 15 }];\n+//     let mut _5: (i32, i32);\n+//     let mut _6: i32;\n+//     let mut _7: i32;\n+//     let mut _8: i32;\n+//     let mut _9: i32;\n+//     scope 1 {\n+//         debug x => _3;\n+//         scope 2 {\n+//             debug _t => _8;\n+//             debug _q => _9;\n+//         }\n+//     }\n+//     bb0: {\n+//         ...\n+//         _3 = [closure@HirId { owner: DefIndex(4), local_id: 15 }];\n+//         ...\n+//         _4 = &_3;\n+//         ...\n+//         _6 = _2;\n+//         ...\n+//         _7 = _2;\n+//         _5 = (move _6, move _7);\n+//         _8 = move (_5.0: i32);\n+//         _9 = move (_5.1: i32);\n+//         _0 = _8;\n+//         ...\n+//         return;\n+//     }\n // END rustc.foo.Inline.after.mir"}, {"sha": "5ba54f98d00da7fcf15e559cda3569b594f4ea79", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -35,6 +35,7 @@ impl S {\n //    let mut _4: S;\n //    let mut _5: bool;\n //    scope 1 {\n+//        debug x => _1;\n //    }\n //    ...\n //    bb0: {\n@@ -47,7 +48,11 @@ impl S {\n //    let mut _5: S;\n //    let mut _6: bool;\n //    ...\n+//    debug u => _1;\n+//    ...\n //    let mut _2: S;\n //    ...\n+//    debug v => _2;\n+//    ...\n //    bb0: {\n // END rustc.test.ElaborateDrops.after.mir"}, {"sha": "efe2b249d4a8653237651d337af3b2afb3987d50", "filename": "src/test/mir-opt/issue-41888.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fissue-41888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fissue-41888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41888.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -25,9 +25,11 @@ enum E {\n // fn main() -> () {\n //     let mut _0: ();\n //     scope 1 {\n-//         let _1: E; // `e`\n+//         let _1: E;\n+//         debug e => _1;\n //         scope 2 {\n //             let _6: K;\n+//             debug _k => _6;\n //         }\n //     }\n //     let mut _2: bool;"}, {"sha": "54c89b85f42d7945062310d3065c64fbb6366c7c", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -24,6 +24,7 @@ fn main() {\n //     let _5: ();\n //     let mut _6: &i32;\n //     scope 1 {\n+//         debug beacon => _2;\n //     }\n //     bb0: {\n //         goto -> bb1;"}, {"sha": "4412a16e74d5ea53593a7c0bfaf76e51a02cf107", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -53,8 +53,14 @@ fn main() {\n // let _15: bool;                       // `b`\n // let _16: std::string::String;        // `t`\n // scope 1 {\n+//     debug a => _5;\n+//     debug a => _6;\n+//     debug s => _7;\n+//     debug s => _8;\n // }\n // scope 2 {\n+//     debug b => _15;\n+//     debug t => _16;\n // }\n // bb0: {\n //     FakeRead(ForMatchedPlace, _2);"}, {"sha": "16e357fc162559e9cf9bc5c6b7eeb5f545577107", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -29,8 +29,12 @@ fn main() {\n // START rustc.main.nll.0.mir\n // let _2: &'_#3r usize;\n // ...\n+// debug p => _2;\n+// ...\n // let _6: &'_#4r usize;\n // ...\n+// debug q => _6;\n+// ...\n // _2 = &'_#2r _1[_3];\n // ...\n // _6 = _2;"}, {"sha": "113f81c441f7c7d08d200f74e76f8d6e483c4103", "filename": "src/test/mir-opt/packed-struct-drop-aligned.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -25,6 +25,7 @@ impl Drop for Droppy {\n //     let mut _5: Droppy;\n //     let mut _6: Aligned;\n //     scope 1 {\n+//         debug x => _1;\n //     }\n //\n //     bb0: {"}, {"sha": "656b405ef340edbd20510947b5833f602a1a5e28", "filename": "src/test/mir-opt/simplify_try.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/563ed27c01c204d734355709c905f9a14246d4ff/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs?ref=563ed27c01c204d734355709c905f9a14246d4ff", "patch": "@@ -10,6 +10,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.try_identity.SimplifyArmIdentity.before.mir\n // fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     debug x => _1;\n //     let mut _0: std::result::Result<u32, i32>;\n //     let _2: u32;\n //     let mut _3: std::result::Result<u32, i32>;\n@@ -22,21 +23,27 @@ fn main() {\n //     let _10: u32;\n //     let mut _11: u32;\n //     scope 1 {\n+//         debug y => _10;\n //     }\n //     scope 2 {\n+//         debug err => _6;\n //         scope 3 {\n //             scope 7 {\n+//                 debug t => _6;\n //             }\n //             scope 8 {\n+//                 debug v => _6;\n //                 let mut _12: i32;\n //             }\n //         }\n //     }\n //     scope 4 {\n+//         debug val => _10;\n //         scope 5 {\n //         }\n //     }\n //     scope 6 {\n+//         debug self => _1;\n //     }\n //     bb0: {\n //         _5 = discriminant(_1);\n@@ -65,6 +72,7 @@ fn main() {\n \n // START rustc.try_identity.SimplifyArmIdentity.after.mir\n // fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     debug x => _1;\n //     let mut _0: std::result::Result<u32, i32>;\n //     let _2: u32;\n //     let mut _3: std::result::Result<u32, i32>;\n@@ -77,21 +85,27 @@ fn main() {\n //     let _10: u32;\n //     let mut _11: u32;\n //     scope 1 {\n+//         debug y => _10;\n //     }\n //     scope 2 {\n+//         debug err => _6;\n //         scope 3 {\n //             scope 7 {\n+//                 debug t => _6;\n //             }\n //             scope 8 {\n+//                 debug v => _6;\n //                 let mut _12: i32;\n //             }\n //         }\n //     }\n //     scope 4 {\n+//         debug val => _10;\n //         scope 5 {\n //         }\n //     }\n //     scope 6 {\n+//         debug self => _1;\n //     }\n //     bb0: {\n //         _5 = discriminant(_1);\n@@ -120,6 +134,7 @@ fn main() {\n \n // START rustc.try_identity.SimplifyBranchSame.after.mir\n // fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     debug x => _1;\n //     let mut _0: std::result::Result<u32, i32>;\n //     let _2: u32;\n //     let mut _3: std::result::Result<u32, i32>;\n@@ -132,21 +147,27 @@ fn main() {\n //     let _10: u32;\n //     let mut _11: u32;\n //     scope 1 {\n+//         debug y => _10;\n //     }\n //     scope 2 {\n+//         debug err => _6;\n //         scope 3 {\n //             scope 7 {\n+//                 debug t => _6;\n //             }\n //             scope 8 {\n+//                 debug v => _6;\n //                 let mut _12: i32;\n //             }\n //         }\n //     }\n //     scope 4 {\n+//         debug val => _10;\n //         scope 5 {\n //         }\n //     }\n //     scope 6 {\n+//         debug self => _1;\n //     }\n //     bb0: {\n //         _5 = discriminant(_1);\n@@ -166,23 +187,32 @@ fn main() {\n \n // START rustc.try_identity.SimplifyLocals.after.mir\n // fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     debug x => _1;\n //     let mut _0: std::result::Result<u32, i32>;\n //     let mut _2: isize;\n+//     let _3: i32;\n+//     let _4: u32;\n //     scope 1 {\n+//         debug y => _4;\n //     }\n //     scope 2 {\n+//         debug err => _3;\n //         scope 3 {\n //             scope 7 {\n+//                 debug t => _3;\n //             }\n //             scope 8 {\n+//                 debug v => _3;\n //             }\n //         }\n //     }\n //     scope 4 {\n+//         debug val => _4;\n //         scope 5 {\n //         }\n //     }\n //     scope 6 {\n+//         debug self => _1;\n //     }\n //     bb0: {\n //         _2 = discriminant(_1);"}]}