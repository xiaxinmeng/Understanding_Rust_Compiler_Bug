{"sha": "74f4badcab30c91b018f308d2c44641abed7d732", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZjRiYWRjYWIzMGM5MWIwMThmMzA4ZDJjNDQ2NDFhYmVkN2Q3MzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-22T05:34:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-22T05:34:36Z"}, "message": "auto merge of #7955 : thestinger/rust/snapshot, r=huonw", "tree": {"sha": "81dd71ea871e583375edf2dc423b17f3653b2e08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81dd71ea871e583375edf2dc423b17f3653b2e08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f4badcab30c91b018f308d2c44641abed7d732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f4badcab30c91b018f308d2c44641abed7d732", "html_url": "https://github.com/rust-lang/rust/commit/74f4badcab30c91b018f308d2c44641abed7d732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f4badcab30c91b018f308d2c44641abed7d732/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6c0bc05640b9cc62db9fe287903cb709056dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6c0bc05640b9cc62db9fe287903cb709056dcb", "html_url": "https://github.com/rust-lang/rust/commit/3d6c0bc05640b9cc62db9fe287903cb709056dcb"}, {"sha": "f51e2ad435d7c0b4cb1bdebc5b6db29b65249125", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51e2ad435d7c0b4cb1bdebc5b6db29b65249125", "html_url": "https://github.com/rust-lang/rust/commit/f51e2ad435d7c0b4cb1bdebc5b6db29b65249125"}], "stats": {"total": 841, "additions": 27, "deletions": 814}, "files": [{"sha": "7a8d6950120f5d1481388c48cdd40394855253a2", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -305,7 +305,6 @@ struct RWARCInner<T> { priv lock: RWlock, priv failed: bool, priv data: T }\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n-#[mutable] // XXX remove after snap\n #[no_freeze]\n struct RWARC<T> {\n     priv x: UnsafeAtomicRcBox<RWARCInner<T>>,"}, {"sha": "3c10c3545bf456822d09e89c1037e73470970c7b", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -46,15 +46,7 @@ use std::sys;\n use std::uint;\n use std::vec;\n use std::unstable::intrinsics;\n-use std::unstable::intrinsics::{TyDesc};\n-\n-#[cfg(not(stage0))]\n-use std::unstable::intrinsics::{get_tydesc};\n-\n-#[cfg(stage0)]\n-unsafe fn get_tydesc<T>() -> *TyDesc {\n-    intrinsics::get_tydesc::<T>() as *TyDesc\n-}\n+use std::unstable::intrinsics::{TyDesc, get_tydesc};\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -65,7 +57,6 @@ struct Chunk {\n     is_pod: bool,\n }\n \n-#[mutable] // XXX remove after snap\n #[no_freeze]\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n@@ -117,19 +108,6 @@ fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n \n-#[inline]\n-#[cfg(not(stage0))]\n-unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n-    // This function should be inlined when stage0 is gone\n-    ((*tydesc).drop_glue)(data);\n-}\n-\n-#[inline]\n-#[cfg(stage0)]\n-unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n-    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n-}\n-\n // Walk down a chunk, running the destructors for any objects stored\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n@@ -149,7 +127,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n         //       start, size, align, is_done);\n         if is_done {\n-            call_drop_glue(tydesc, ptr::offset(buf, start) as *i8);\n+            ((*tydesc).drop_glue)(ptr::offset(buf, start) as *i8);\n         }\n \n         // Find where the next tydesc lives"}, {"sha": "2c25ee9da78f608da98899c80fb4483ccaa791df", "filename": "src/libextra/dbg.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdbg.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -13,15 +13,9 @@\n #[allow(missing_doc)];\n \n use std::cast::transmute;\n-#[cfg(stage0)]\n-use intrinsic::{get_tydesc};\n-#[cfg(not(stage0))]\n use std::unstable::intrinsics::{get_tydesc};\n \n pub mod rustrt {\n-    #[cfg(stage0)]\n-    use intrinsic::{TyDesc};\n-    #[cfg(not(stage0))]\n     use std::unstable::intrinsics::{TyDesc};\n \n     #[abi = \"cdecl\"]"}, {"sha": "8d6b146e1426436c47124e4b1d53d00948af6a07", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -166,9 +166,7 @@ struct RcMutBox<T> {\n }\n \n /// Mutable reference counted pointer type\n-#[non_owned]\n #[no_send]\n-#[mutable] // XXX remove after snap\n #[no_freeze]\n #[unsafe_no_drop_flag]\n pub struct RcMut<T> {"}, {"sha": "8d291377b1eb99277c72158dcef0e8a49e979ff5", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -68,10 +68,7 @@ pub unsafe fn read(prompt: &str) -> Option<~str> {\n \n pub type CompletionCb = @fn(~str, @fn(~str));\n \n-#[cfg(not(stage0))]\n static complete_key: local_data::Key<@CompletionCb> = &local_data::Key;\n-#[cfg(stage0)]\n-fn complete_key(_: @CompletionCb) {}\n \n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {"}, {"sha": "bb0280ab0650af3bad7814225f7d735aa2a55842", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -106,7 +106,6 @@ pub mod jit {\n     use metadata::cstore;\n \n     use std::cast;\n-    #[cfg(not(stage0))]\n     use std::local_data;\n     use std::unstable::intrinsics;\n \n@@ -204,22 +203,15 @@ pub mod jit {\n \n     // The stage1 compiler won't work, but that doesn't really matter. TLS\n     // changed only very recently to allow storage of owned values.\n-    #[cfg(not(stage0))]\n     static engine_key: local_data::Key<~Engine> = &local_data::Key;\n \n-    #[cfg(not(stage0))]\n     fn set_engine(engine: ~Engine) {\n         local_data::set(engine_key, engine)\n     }\n-    #[cfg(stage0)]\n-    fn set_engine(_: ~Engine) {}\n \n-    #[cfg(not(stage0))]\n     pub fn consume_engine() -> Option<~Engine> {\n         local_data::pop(engine_key)\n     }\n-    #[cfg(stage0)]\n-    pub fn consume_engine() -> Option<~Engine> { None }\n }\n \n pub mod write {"}, {"sha": "da92e76e1997f70d9b336a590e62b12b26e7d688", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -90,10 +90,7 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::task_llcx;\n \n-#[cfg(not(stage0))]\n static task_local_insn_key: local_data::Key<@~[&'static str]> = &local_data::Key;\n-#[cfg(stage0)]\n-fn task_local_insn_key(_: @~[&'static str]) {}\n \n pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n     let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));"}, {"sha": "2a071bb00f418a58a4725cf147ea515acc219d74", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -236,9 +236,6 @@ impl Drop for CrateContext {\n     }\n }\n \n-#[cfg(stage0)]\n-fn task_local_llcx_key(_v: @ContextRef) {}\n-#[cfg(not(stage0))]\n static task_local_llcx_key: local_data::Key<@ContextRef> = &local_data::Key;\n \n pub fn task_llcx() -> ContextRef {"}, {"sha": "220e5b887cb0372e5f9ef2e763b6dc8a82fd0cea", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -607,9 +607,6 @@ fn tuple_metadata(cx: &mut CrateContext,\n         span);\n }\n \n-// The stage0 snapshot does not yet support the fixes from PR #7557, so there are two versions of\n-// following function for now\n-#[cfg(not(stage0))]\n fn enum_metadata(cx: &mut CrateContext,\n                  enum_type: ty::t,\n                  enum_def_id: ast::def_id,\n@@ -772,142 +769,6 @@ fn enum_metadata(cx: &mut CrateContext,\n     }\n }\n \n-#[cfg(stage0)]\n-fn enum_metadata(cx: &mut CrateContext,\n-                 enum_type: ty::t,\n-                 enum_def_id: ast::def_id,\n-                 substs: &ty::substs,\n-                 span: span)\n-              -> DIType {\n-\n-    let enum_name = ty_to_str(cx.tcx, enum_type);\n-\n-    // For empty enums there is an early exit. Just describe it as an empty struct with the\n-    // appropriate type name\n-    if ty::type_is_empty(cx.tcx, enum_type) {\n-        return composite_type_metadata(cx, Type::nil(), enum_name, &[], &[], &[], span);\n-    }\n-\n-    // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n-    // needed in all of the following cases.\n-    let discriminant_llvm_type = Type::enum_discrim(cx);\n-    let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n-\n-    assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_type_metadata = type_metadata(cx, ty::mk_int(), span);\n-\n-    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n-\n-    let enumerators_metadata: ~[DIDescriptor] = variants\n-        .iter()\n-        .transform(|v| {\n-            let name: &str = cx.sess.str_of(v.name);\n-            let discriminant_value = v.disr_val as c_ulonglong;\n-\n-            do name.as_c_str |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerator(\n-                        DIB(cx),\n-                        name,\n-                        discriminant_value)\n-                }\n-            }\n-        })\n-        .collect();\n-\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n-\n-    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateEnumerationType(\n-                DIB(cx),\n-                file_metadata,\n-                enum_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(discriminant_size),\n-                bytes_to_bits(discriminant_align),\n-                create_DIArray(DIB(cx), enumerators_metadata),\n-                discriminant_type_metadata)\n-        }\n-    };\n-\n-    if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n-        return discriminant_type_metadata;\n-    }\n-\n-    let is_univariant = variants.len() == 1;\n-\n-    let variants_metadata = do variants.map |&vi| {\n-\n-        let raw_types: &[ty::t] = vi.args;\n-        let arg_types = do raw_types.map |&raw_type| { ty::subst(cx.tcx, substs, raw_type) };\n-\n-        let mut arg_llvm_types = do arg_types.map |&ty| { type_of::type_of(cx, ty) };\n-        let mut arg_names = match vi.arg_names {\n-            Some(ref names) => do names.map |ident| { cx.sess.str_of(*ident).to_owned() },\n-            None => do arg_types.map |_| { ~\"\" }\n-        };\n-\n-        let mut arg_metadata = do arg_types.map |&ty| { type_metadata(cx, ty, span) };\n-\n-        if !is_univariant {\n-            arg_llvm_types.insert(0, discriminant_llvm_type);\n-            arg_names.insert(0, ~\"\");\n-            arg_metadata.insert(0, discriminant_type_metadata);\n-        }\n-\n-        let variant_llvm_type = Type::struct_(arg_llvm_types, false);\n-        let (variant_type_size, variant_type_align) = size_and_align_of(cx, variant_llvm_type);\n-\n-        let variant_type_metadata = composite_type_metadata(\n-            cx,\n-            variant_llvm_type,\n-            &\"\",\n-            arg_llvm_types,\n-            arg_names,\n-            arg_metadata,\n-            span);\n-\n-        do \"\".as_c_str |name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateMemberType(\n-                    DIB(cx),\n-                    file_metadata,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    bytes_to_bits(variant_type_size),\n-                    bytes_to_bits(variant_type_align),\n-                    bytes_to_bits(0),\n-                    0,\n-                    variant_type_metadata)\n-            }\n-        }\n-    };\n-\n-    let enum_llvm_type = type_of::type_of(cx, enum_type);\n-    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n-\n-    return do enum_name.as_c_str |enum_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateUnionType(\n-                DIB(cx),\n-                file_metadata,\n-                enum_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(enum_type_size),\n-                bytes_to_bits(enum_type_align),\n-                0, // Flags\n-                create_DIArray(DIB(cx), variants_metadata),\n-                0) // RuntimeLang\n-        }\n-    };\n-}\n-\n-\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums."}, {"sha": "4b4a1645a9b4c00cf9664f304d3beba7fad50422", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -475,7 +475,8 @@ fn test_install_invalid() {\n \n // Tests above should (maybe) be converted to shell out to rustpkg, too\n \n-#[test] #[ignore(cfg(target_arch = \"x86\"))]\n+// FIXME: #7956: temporarily disabled\n+#[ignore(cfg(target_arch = \"x86\"))]\n fn test_install_git() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n@@ -566,7 +567,8 @@ fn test_package_ids_must_be_relative_path_like() {\n \n }\n \n-#[test] #[ignore(cfg(target_arch = \"x86\"))]\n+// FIXME: #7956: temporarily disabled\n+#[ignore(cfg(target_arch = \"x86\"))]\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n@@ -678,7 +680,7 @@ fn rustpkg_install_url_2() {\n                      &temp_dir);\n }\n \n-#[test]\n+// FIXME: #7956: temporarily disabled\n fn rustpkg_library_target() {\n     let foo_repo = init_git_repo(&Path(\"foo\"));\n     let package_dir = foo_repo.push(\"foo\");"}, {"sha": "5a0c781fe9a879cbb003904869c0341c1df499f0", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -21,7 +21,6 @@ A dynamic, mutable location.\n Similar to a mutable option type, but friendlier.\n */\n \n-#[mutable] // XXX remove after snap\n #[no_freeze]\n #[deriving(Clone, DeepClone, Eq)]\n #[allow(missing_doc)]"}, {"sha": "2ea10b09c8ec1c6b25a41d19a8d7a76028ea568e", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -73,19 +73,6 @@ fn debug_mem() -> bool {\n     false\n }\n \n-#[inline]\n-#[cfg(not(stage0))]\n-unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n-    // This function should be inlined when stage0 is gone\n-    ((*tydesc).drop_glue)(data);\n-}\n-\n-#[inline]\n-#[cfg(stage0)]\n-unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n-    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n-}\n-\n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n@@ -128,7 +115,7 @@ pub unsafe fn annihilate() {\n         if !uniq {\n             let tydesc: *TyDesc = transmute((*box).header.type_desc);\n             let data = transmute(&(*box).data);\n-            call_drop_glue(tydesc, data);\n+            ((*tydesc).drop_glue)(data);\n         }\n     }\n "}, {"sha": "1f7f96d93c32ae390ab6728a6edc02304ea94fad", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -23,18 +23,11 @@ pub struct Handler<T, U> {\n     prev: Option<@Handler<T, U>>,\n }\n \n-#[cfg(stage0)]\n-pub struct Condition<'self, T, U> {\n-    name: &'static str,\n-    key: local_data::Key<'self, @Handler<T, U>>\n-}\n-#[cfg(not(stage0))]\n pub struct Condition<T, U> {\n     name: &'static str,\n     key: local_data::Key<@Handler<T, U>>\n }\n \n-#[cfg(not(stage0))]\n impl<T, U> Condition<T, U> {\n     pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n         unsafe {\n@@ -73,56 +66,7 @@ impl<T, U> Condition<T, U> {\n         }\n     }\n }\n-#[cfg(stage0)]\n-impl<'self, T, U> Condition<'self, T, U> {\n-    pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n-        unsafe {\n-            let p : *RustClosure = ::cast::transmute(&h);\n-            let prev = local_data::get(::cast::unsafe_copy(&self.key),\n-                                       |k| k.map(|&x| *x));\n-            let h = @Handler { handle: *p, prev: prev };\n-            Trap { cond: self, handler: h }\n-        }\n-    }\n-\n-    pub fn raise(&self, t: T) -> U {\n-        let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n-        self.raise_default(t, || fail!(msg.clone()))\n-    }\n-\n-    pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n-        unsafe {\n-            match local_data::pop(::cast::unsafe_copy(&self.key)) {\n-                None => {\n-                    debug!(\"Condition.raise: found no handler\");\n-                    default()\n-                }\n-                Some(handler) => {\n-                    debug!(\"Condition.raise: found handler\");\n-                    match handler.prev {\n-                        None => {}\n-                        Some(hp) => {\n-                            local_data::set(::cast::unsafe_copy(&self.key),\n-                                            hp)\n-                        }\n-                    }\n-                    let handle : &fn(T) -> U =\n-                        ::cast::transmute(handler.handle);\n-                    let u = handle(t);\n-                    local_data::set(::cast::unsafe_copy(&self.key), handler);\n-                    u\n-                }\n-            }\n-        }\n-    }\n-}\n \n-#[cfg(stage0)]\n-struct Trap<'self, T, U> {\n-    cond: &'self Condition<'self, T, U>,\n-    handler: @Handler<T, U>\n-}\n-#[cfg(not(stage0))]\n struct Trap<'self, T, U> {\n     cond: &'self Condition<T, U>,\n     handler: @Handler<T, U>\n@@ -137,11 +81,6 @@ impl<'self, T, U> Trap<'self, T, U> {\n     }\n }\n \n-#[cfg(stage0)]\n-struct Guard<'self, T, U> {\n-    cond: &'self Condition<'self, T, U>\n-}\n-#[cfg(not(stage0))]\n struct Guard<'self, T, U> {\n     cond: &'self Condition<T, U>\n }"}, {"sha": "911fb5625e58864d52b15e49e23c14d82944a11a", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -317,19 +317,6 @@ fn expect_sentinel() -> bool { true }\n #[cfg(nogc)]\n fn expect_sentinel() -> bool { false }\n \n-#[inline]\n-#[cfg(not(stage0))]\n-unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n-    // This function should be inlined when stage0 is gone\n-    ((*tydesc).drop_glue)(data);\n-}\n-\n-#[inline]\n-#[cfg(stage0)]\n-unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n-    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n-}\n-\n // Entry point for GC-based cleanup. Walks stack looking for exchange\n // heap and stack allocations requiring drop, and runs all\n // destructors.\n@@ -373,7 +360,7 @@ pub fn cleanup_stack_for_failure() {\n                 // FIXME #4420: Destroy this box\n                 // FIXME #4330: Destroy this box\n             } else {\n-                call_drop_glue(tydesc, *root as *i8);\n+                ((*tydesc).drop_glue)(*root as *i8);\n             }\n         }\n     }"}, {"sha": "6b45ddddf7e9378611f59c1f869078c46a1efb42", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -29,31 +29,11 @@ The 2 kinds are\n \n #[allow(missing_doc)];\n \n-#[cfg(stage0)]\n-#[lang=\"copy\"]\n-pub trait Copy {\n-    // Empty.\n-}\n-\n-#[cfg(stage0)]\n-#[lang=\"owned\"]\n-pub trait Send {\n-    // empty.\n-}\n-\n-#[cfg(not(stage0))]\n #[lang=\"send\"]\n pub trait Send {\n     // empty.\n }\n \n-#[cfg(stage0)]\n-#[lang=\"const\"]\n-pub trait Freeze {\n-    // empty.\n-}\n-\n-#[cfg(not(stage0))]\n #[lang=\"freeze\"]\n pub trait Freeze {\n     // empty."}, {"sha": "537289c8dd6c2f9bded558498515d9c393e3b2b9", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -56,84 +56,45 @@ use task::local_data_priv::*;\n  * sections to ensure that each value of the `Key` type points to a unique\n  * location.\n  */\n-#[cfg(not(stage0))]\n pub type Key<T> = &'static KeyValue<T>;\n-#[cfg(stage0)]\n-pub type Key<'self,T> = &'self fn(v: T);\n \n pub enum KeyValue<T> { Key }\n \n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-#[cfg(stage0)]\n-pub fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n-    unsafe { local_pop(Handle::new(), key) }\n-}\n-/**\n- * Remove a task-local data value from the table, returning the\n- * reference that was originally created to insert it.\n- */\n-#[cfg(not(stage0))]\n pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n     unsafe { local_pop(Handle::new(), key) }\n }\n+\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-#[cfg(stage0)]\n-pub fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n-    unsafe { local_get(Handle::new(), key, f) }\n-}\n-/**\n- * Retrieve a task-local data value. It will also be kept alive in the\n- * table until explicitly removed.\n- */\n-#[cfg(not(stage0))]\n pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n     unsafe { local_get(Handle::new(), key, f) }\n }\n+\n /**\n  * Retrieve a mutable borrowed pointer to a task-local data value.\n  */\n-#[cfg(not(stage0))]\n pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n     unsafe { local_get_mut(Handle::new(), key, f) }\n }\n+\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-#[cfg(stage0)]\n-pub fn set<T: 'static>(key: Key<@T>, data: @T) {\n-    unsafe { local_set(Handle::new(), key, data) }\n-}\n-/**\n- * Store a value in task-local data. If this key already has a value,\n- * that value is overwritten (and its destructor is run).\n- */\n-#[cfg(not(stage0))]\n pub fn set<T: 'static>(key: Key<T>, data: T) {\n     unsafe { local_set(Handle::new(), key, data) }\n }\n+\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n-#[cfg(stage0)]\n-pub fn modify<T: 'static>(key: Key<@T>, f: &fn(Option<@T>) -> Option<@T>) {\n-    match f(pop(key)) {\n-        Some(next) => { set(key, next); }\n-        None => {}\n-    }\n-}\n-/**\n- * Modify a task-local data value. If the function returns 'None', the\n- * data is removed (and its reference dropped).\n- */\n-#[cfg(not(stage0))]\n pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n     unsafe {\n         match f(pop(::cast::unsafe_copy(&key))) {"}, {"sha": "bbfa15d69bd94af55af85b2a1fdd2e9d182238db", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -1237,9 +1237,6 @@ struct OverriddenArgs {\n     val: ~[~str]\n }\n \n-#[cfg(stage0)]\n-fn overridden_arg_key(_v: @OverriddenArgs) {}\n-#[cfg(not(stage0))]\n static overridden_arg_key: local_data::Key<@OverriddenArgs> = &local_data::Key;\n \n /// Returns the arguments which this program was started with (normally passed"}, {"sha": "9af2d8be2970ff2e9972852f594bc91b343c6af7", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -852,9 +852,6 @@ pub fn seed() -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n-#[cfg(stage0)]\n-fn tls_rng_state(_v: @@mut IsaacRng) {}\n-#[cfg(not(stage0))]\n static tls_rng_state: local_data::Key<@@mut IsaacRng> = &local_data::Key;\n \n /**"}, {"sha": "d49d54ae68fe64513e5f490c756b63dffc28010f", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -16,9 +16,6 @@ Runtime type reflection\n \n #[allow(missing_doc)];\n \n-#[cfg(stage0)]\n-use intrinsic::{Opaque, TyDesc, TyVisitor};\n-#[cfg(not(stage0))]\n use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n use libc::c_void;\n use sys;\n@@ -197,14 +194,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_str(&self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_str() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n     fn visit_estr_box(&self) -> bool {\n         self.align_to::<@str>();\n         if ! self.inner.visit_estr_box() { return false; }\n@@ -249,7 +238,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(not(stage0))]\n     fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n@@ -298,7 +286,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(not(stage0))]\n     fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[@u8]>();\n         if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }"}, {"sha": "07fd82e16160a5a1cf5103224c9b0ba4aabf6e1e", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -31,9 +31,6 @@ use to_str::ToStr;\n use vec::raw::{VecRepr, SliceRepr};\n use vec;\n use vec::{OwnedVector, UnboxedVecRepr};\n-#[cfg(stage0)]\n-use intrinsic::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n-#[cfg(not(stage0))]\n use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n \n #[cfg(test)] use io;\n@@ -267,10 +264,6 @@ impl TyVisitor for ReprVisitor {\n         }\n     }\n \n-    // Type no longer exists, vestigial function.\n-    #[cfg(stage0)]\n-    fn visit_str(&self) -> bool { fail!(); }\n-\n     fn visit_estr_box(&self) -> bool {\n         do self.get::<@str> |s| {\n             self.writer.write_char('@');\n@@ -309,7 +302,6 @@ impl TyVisitor for ReprVisitor {\n         }\n     }\n \n-    #[cfg(not(stage0))]\n     fn visit_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('~');\n         do self.get::<&managed::raw::BoxRepr> |b| {\n@@ -351,23 +343,13 @@ impl TyVisitor for ReprVisitor {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<&UnboxedVecRepr> |b| {\n             self.writer.write_char('~');\n             self.write_unboxed_vec_repr(mtbl, *b, inner);\n         }\n     }\n \n-    #[cfg(not(stage0))]\n     fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<&VecRepr> |b| {\n             self.writer.write_char('~');\n@@ -563,24 +545,13 @@ impl TyVisitor for ReprVisitor {\n     fn visit_self(&self) -> bool { true }\n     fn visit_type(&self) -> bool { true }\n \n-    #[cfg(not(stage0))]\n     fn visit_opaque_box(&self) -> bool {\n         self.writer.write_char('@');\n         do self.get::<&managed::raw::BoxRepr> |b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             self.visit_ptr_inner(p, b.header.type_desc);\n         }\n     }\n-    #[cfg(stage0)]\n-    fn visit_opaque_box(&self) -> bool {\n-        self.writer.write_char('@');\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            unsafe {\n-                self.visit_ptr_inner(p, transmute(b.header.type_desc));\n-            }\n-        }\n-    }\n \n     // Type no longer exists, vestigial function.\n     fn visit_constr(&self, _inner: *TyDesc) -> bool { fail!(); }"}, {"sha": "580390c19530edcdaa0ef9b54ee60c0b240acd53", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -56,28 +56,8 @@ pub unsafe fn realloc_raw(ptr: *mut c_void, size: uint) -> *mut c_void {\n     p\n }\n \n-// FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n-#[cfg(stage0, not(test))]\n-#[lang=\"exchange_malloc\"]\n-#[inline]\n-pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    let td = td as *TyDesc;\n-    let size = size as uint;\n-\n-    assert!(td.is_not_null());\n-\n-    let total_size = get_box_size(size, (*td).align);\n-    let p = malloc_raw(total_size as uint);\n-\n-    let box: *mut BoxRepr = p as *mut BoxRepr;\n-    (*box).header.ref_count = -1;\n-    (*box).header.type_desc = td;\n-\n-    box as *c_char\n-}\n-\n /// The allocator for unique pointers without contained managed pointers.\n-#[cfg(not(stage0), not(test))]\n+#[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n pub unsafe fn exchange_malloc(size: uintptr_t) -> *c_char {"}, {"sha": "125df156ed0b2f3203ba4d3bba386a8ec3002d9c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -1006,19 +1006,6 @@ pub mod raw {\n \n     /// Sets the length of the string and adds the null terminator\n     #[inline]\n-    #[cfg(stage0)]\n-    pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n-        let v: **mut vec::raw::VecRepr = cast::transmute(v);\n-        let repr: *mut vec::raw::VecRepr = *v;\n-        (*repr).unboxed.fill = new_len + 1u;\n-        let null = ptr::mut_offset(cast::transmute(&((*repr).unboxed.data)),\n-                                   new_len);\n-        *null = 0u8;\n-    }\n-\n-    /// Sets the length of the string and adds the null terminator\n-    #[inline]\n-    #[cfg(not(stage0))]\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n         let v: **mut vec::UnboxedVecRepr = cast::transmute(v);\n         let repr: *mut vec::UnboxedVecRepr = *v;"}, {"sha": "fe80ec06c69d01ff997f85a17ecb29907fdd2876", "filename": "src/libstd/task/local_data_priv_stage0.rs", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/3d6c0bc05640b9cc62db9fe287903cb709056dcb/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6c0bc05640b9cc62db9fe287903cb709056dcb/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs?ref=3d6c0bc05640b9cc62db9fe287903cb709056dcb", "patch": "@@ -1,229 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use cast;\n-use cmp::Eq;\n-use libc;\n-use local_data;\n-use prelude::*;\n-use sys;\n-use task::rt;\n-\n-use super::rt::rust_task;\n-use rt::task::{Task, LocalStorage};\n-\n-pub enum Handle {\n-    OldHandle(*rust_task),\n-    NewHandle(*mut LocalStorage)\n-}\n-\n-impl Handle {\n-    pub fn new() -> Handle {\n-        use rt::{context, OldTaskContext};\n-        use rt::local::Local;\n-        unsafe {\n-            match context() {\n-                OldTaskContext => {\n-                    OldHandle(rt::rust_get_task())\n-                }\n-                _ => {\n-                    let task = Local::unsafe_borrow::<Task>();\n-                    NewHandle(&mut (*task).storage)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub trait LocalData { }\n-impl<T: 'static> LocalData for @T { }\n-\n-impl Eq for @LocalData {\n-    fn eq(&self, other: &@LocalData) -> bool {\n-        unsafe {\n-            let ptr_a: &(uint, uint) = cast::transmute(self);\n-            let ptr_b: &(uint, uint) = cast::transmute(other);\n-            return ptr_a == ptr_b;\n-        }\n-    }\n-    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n-}\n-\n-// If TLS is used heavily in future, this could be made more efficient with a\n-// proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n-// Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = ~[Option<TaskLocalElement>];\n-\n-fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n-    unsafe {\n-        assert!(!map_ptr.is_null());\n-        // Get and keep the single reference that was created at the\n-        // beginning.\n-        let _map: TaskLocalMap = cast::transmute(map_ptr);\n-        // All local_data will be destroyed along with the map.\n-    }\n-}\n-\n-// Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n-    match handle {\n-        OldHandle(task) => get_task_local_map(task),\n-        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n-    }\n-}\n-\n-unsafe fn get_task_local_map(task: *rust_task) -> &mut TaskLocalMap {\n-\n-    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n-        cleanup_task_local_map(map_ptr);\n-    }\n-\n-    // Relies on the runtime initialising the pointer to null.\n-    // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n-    // into the tls slot for this task, and then mutable loans are taken from\n-    // this slot to modify the map.\n-    let map_ptr = rt::rust_get_task_local_data(task);\n-    if (*map_ptr).is_null() {\n-        // First time TLS is used, create a new map and set up the necessary\n-        // TLS information for its safe destruction\n-        let map: TaskLocalMap = ~[];\n-        *map_ptr = cast::transmute(map);\n-        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n-    }\n-    return cast::transmute(map_ptr);\n-}\n-\n-unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n-    // This is based on the same idea as the oldsched code above.\n-    match &mut *local {\n-        // If the at_exit function is already set, then we just need to take a\n-        // loan out on the TLS map stored inside\n-        &LocalStorage(ref mut map_ptr, Some(_)) => {\n-            assert!(map_ptr.is_not_null());\n-            return cast::transmute(map_ptr);\n-        }\n-        // If this is the first time we've accessed TLS, perform similar\n-        // actions to the oldsched way of doing things.\n-        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n-            assert!(map_ptr.is_null());\n-            assert!(at_exit.is_none());\n-            let map: TaskLocalMap = ~[];\n-            *map_ptr = cast::transmute(map);\n-            *at_exit = Some(cleanup_task_local_map);\n-            return cast::transmute(map_ptr);\n-        }\n-    }\n-}\n-\n-unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<@T>) -> *libc::c_void {\n-    let pair: sys::Closure = cast::transmute(key);\n-    return pair.code as *libc::c_void;\n-}\n-\n-// If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: 'static>(\n-    map: &mut TaskLocalMap, key: local_data::Key<@T>)\n-    -> Option<(uint, *libc::c_void)> {\n-\n-    let key_value = key_to_key_value(key);\n-    for map.iter().enumerate().advance |(i, entry)| {\n-        match *entry {\n-            Some((k, data, _)) if k == key_value => { return Some((i, data)); }\n-            _ => {}\n-        }\n-    }\n-    return None;\n-}\n-\n-unsafe fn local_get_helper<T: 'static>(\n-    handle: Handle, key: local_data::Key<@T>,\n-    do_pop: bool) -> Option<@T> {\n-\n-    let map = get_local_map(handle);\n-    // Interpreturn our findings from the map\n-    do local_data_lookup(map, key).map |result| {\n-        // A reference count magically appears on 'data' out of thin air. It\n-        // was referenced in the local_data box, though, not here, so before\n-        // overwriting the local_data_box we need to give an extra reference.\n-        // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = *result;\n-        let data: @T = cast::transmute(data_ptr);\n-        cast::bump_box_refcount(data);\n-        if do_pop {\n-            map[index] = None;\n-        }\n-        data\n-    }\n-}\n-\n-\n-pub unsafe fn local_pop<T: 'static>(\n-    handle: Handle,\n-    key: local_data::Key<@T>) -> Option<@T> {\n-\n-    local_get_helper(handle, key, true)\n-}\n-\n-pub unsafe fn local_get<T: 'static, U>(\n-    handle: Handle,\n-    key: local_data::Key<@T>,\n-    f: &fn(Option<&@T>) -> U) -> U {\n-\n-    match local_get_helper(handle, key, false) {\n-        Some(ref x) => f(Some(x)),\n-        None => f(None)\n-    }\n-}\n-\n-pub unsafe fn local_set<T: 'static>(\n-    handle: Handle, key: local_data::Key<@T>, data: @T) {\n-\n-    let map = get_local_map(handle);\n-    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n-    let keyval = key_to_key_value(key);\n-    // We keep the data in two forms: one as an unsafe pointer, so we can get\n-    // it back by casting; another in an existential box, so the reference we\n-    // own on it can be dropped when the box is destroyed. The unsafe pointer\n-    // does not have a reference associated with it, so it may become invalid\n-    // when the box is destroyed.\n-    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n-    let data_box = @data as @LocalData;\n-    // Construct new entry to store in the map.\n-    let new_entry = Some((keyval, data_ptr, data_box));\n-    // Find a place to put it.\n-    match local_data_lookup(map, key) {\n-        Some((index, _old_data_ptr)) => {\n-            // Key already had a value set, _old_data_ptr, whose reference\n-            // will get dropped when the local_data box is overwritten.\n-            map[index] = new_entry;\n-        }\n-        None => {\n-            // Find an empty slot. If not, grow the vector.\n-            match map.iter().position(|x| x.is_none()) {\n-                Some(empty_index) => { map[empty_index] = new_entry; }\n-                None => { map.push(new_entry); }\n-            }\n-        }\n-    }\n-}\n-\n-pub unsafe fn local_modify<T: 'static>(\n-    handle: Handle, key: local_data::Key<@T>,\n-    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n-\n-    // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(handle, key));\n-    if newdata.is_some() {\n-        local_set(handle, key, newdata.unwrap());\n-    }\n-}"}, {"sha": "1ce8641085bfb542efc05118c0da6ea4cbdde933", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -54,10 +54,6 @@ use util;\n #[cfg(test)] use ptr;\n #[cfg(test)] use task;\n \n-#[cfg(stage0)]\n-#[path=\"local_data_priv_stage0.rs\"]\n-mod local_data_priv;\n-#[cfg(not(stage0))]\n mod local_data_priv;\n pub mod rt;\n pub mod spawn;"}, {"sha": "a17bb2b1632591f25ce78af7936c6ee427ac1267", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -487,14 +487,9 @@ fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n // a proper closure because the #[test]s won't understand. Have to fake it.\n-#[cfg(not(stage0))]\n fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n     unsafe { cast::transmute(-2) }\n }\n-#[cfg(stage0)]\n-fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n-    unsafe { cast::transmute((-2, 0)) }\n-}\n \n // Transitionary.\n struct RuntimeGlue;"}, {"sha": "76958fa333fd38270060dbe04175ee35da46cceb", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -36,12 +36,8 @@ A quick refresher on memory ordering:\n #[cfg(test)]\n pub use realstd::unstable::intrinsics::{TyDesc, Opaque, TyVisitor};\n \n-#[cfg(not(stage0))]\n pub type GlueFn = extern \"Rust\" fn(*i8);\n \n-#[cfg(stage0)]\n-pub type GlueFn = extern \"Rust\" fn(**TyDesc, *i8);\n-\n // NB: this has to be kept in sync with the Rust ABI.\n #[lang=\"ty_desc\"]\n #[cfg(not(test))]\n@@ -284,10 +280,7 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> uint;\n \n     /// Get a static pointer to a type descriptor.\n-    #[cfg(not(stage0))]\n     pub fn get_tydesc<T>() -> *TyDesc;\n-    #[cfg(stage0)]\n-    pub fn get_tydesc<T>() -> *();\n \n     /// Create a value initialized to zero.\n     ///\n@@ -310,10 +303,8 @@ extern \"rust-intrinsic\" {\n     pub fn needs_drop<T>() -> bool;\n \n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n-    #[cfg(not(stage0))]\n     pub fn contains_managed<T>() -> bool;\n \n-    #[cfg(not(stage0))]\n     pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n \n     pub fn frame_address(f: &once fn(*u8));"}, {"sha": "5ae45b74dd8ca2fb27daf1d9c4daa23901239136", "filename": "src/libstd/util.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -175,26 +175,23 @@ mod tests {\n \n         // verify that `#[unsafe_no_drop_flag]` works as intended on a zero-size struct\n \n-        // NOTE: uncomment after snapshot, will not parse yet\n-        //static mut did_run: bool = false;\n+        static mut did_run: bool = false;\n \n         struct Foo { five: int }\n \n         impl Drop for Foo {\n             fn drop(&self) {\n                 assert_eq!(self.five, 5);\n-                // NOTE: uncomment after snapshot, will not parse yet\n-                //unsafe {\n-                    //did_run = true;\n-                //}\n+                unsafe {\n+                    did_run = true;\n+                }\n             }\n         }\n \n         {\n             let _a = (NonCopyable, Foo { five: 5 }, NonCopyable);\n         }\n \n-        // NOTE: uncomment after snapshot, will not parse yet\n-        //unsafe { assert_eq!(did_run, true); }\n+        unsafe { assert_eq!(did_run, true); }\n     }\n }"}, {"sha": "6c9d3c15b9ef292f9380b8c4a1f1b50573a8d3d6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -25,16 +25,12 @@ use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n use ptr::RawPtr;\n-#[cfg(not(stage0))]\n use rt::global_heap::malloc_raw;\n use rt::global_heap::realloc_raw;\n use sys;\n use sys::size_of;\n use uint;\n use unstable::intrinsics;\n-#[cfg(stage0)]\n-use intrinsic::{get_tydesc};\n-#[cfg(not(stage0))]\n use unstable::intrinsics::{get_tydesc, contains_managed};\n use vec;\n use util;\n@@ -91,15 +87,6 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n }\n \n /// Creates a new vector with a capacity of `capacity`\n-#[cfg(stage0)]\n-pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n-    let mut vec = ~[];\n-    vec.reserve(capacity);\n-    vec\n-}\n-\n-/// Creates a new vector with a capacity of `capacity`\n-#[cfg(not(stage0))]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     unsafe {\n         if contains_managed::<T>() {\n@@ -1136,40 +1123,6 @@ impl<T> OwnedVector<T> for ~[T] {\n      *\n      * * n - The number of elements to reserve space for\n      */\n-    #[cfg(stage0)]\n-    fn reserve(&mut self, n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        use managed;\n-        if self.capacity() < n {\n-            unsafe {\n-                let ptr: *mut *mut raw::VecRepr = cast::transmute(self);\n-                let td = get_tydesc::<T>();\n-                if ((**ptr).box_header.ref_count ==\n-                    managed::raw::RC_MANAGED_UNIQUE) {\n-                    // XXX transmute shouldn't be necessary\n-                    let td = cast::transmute(td);\n-                    ::at_vec::raw::reserve_raw(td, ptr, n);\n-                } else {\n-                    let alloc = n * sys::nonzero_size_of::<T>();\n-                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + size_of::<raw::VecRepr>())\n-                           as *mut raw::VecRepr;\n-                    (**ptr).unboxed.alloc = alloc;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Reserves capacity for exactly `n` elements in the given vector.\n-     *\n-     * If the capacity for `self` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to reserve space for\n-     */\n-    #[cfg(not(stage0))]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n@@ -1213,17 +1166,6 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     /// Returns the number of elements the vector can hold without reallocating.\n     #[inline]\n-    #[cfg(stage0)]\n-    fn capacity(&self) -> uint {\n-        unsafe {\n-            let repr: **raw::VecRepr = transmute(self);\n-            (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n-        }\n-    }\n-\n-    /// Returns the number of elements the vector can hold without reallocating.\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn capacity(&self) -> uint {\n         unsafe {\n             if contains_managed::<T>() {\n@@ -1238,23 +1180,6 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     /// Append an element to a vector\n     #[inline]\n-    #[cfg(stage0)]\n-    fn push(&mut self, t: T) {\n-        unsafe {\n-            let repr: **raw::VecRepr = transmute(&mut *self);\n-            let fill = (**repr).unboxed.fill;\n-            if (**repr).unboxed.alloc <= fill {\n-                let new_len = self.len() + 1;\n-                self.reserve_at_least(new_len);\n-            }\n-\n-            self.push_fast(t);\n-        }\n-    }\n-\n-    /// Append an element to a vector\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn push(&mut self, t: T) {\n         unsafe {\n             if contains_managed::<T>() {\n@@ -1281,19 +1206,6 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     // This doesn't bother to make sure we have space.\n     #[inline] // really pretty please\n-    #[cfg(stage0)]\n-    unsafe fn push_fast(&mut self, t: T) {\n-        let repr: **mut raw::VecRepr = transmute(self);\n-        let fill = (**repr).unboxed.fill;\n-        (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n-        let p = to_unsafe_ptr(&((**repr).unboxed.data));\n-        let p = ptr::offset(p, fill) as *mut T;\n-        intrinsics::move_val_init(&mut(*p), t);\n-    }\n-\n-    // This doesn't bother to make sure we have space.\n-    #[inline] // really pretty please\n-    #[cfg(not(stage0))]\n     unsafe fn push_fast(&mut self, t: T) {\n         if contains_managed::<T>() {\n             let repr: **mut raw::VecRepr = transmute(self);\n@@ -1901,7 +1813,6 @@ pub mod raw {\n     use sys;\n     use unstable::intrinsics;\n     use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n-    #[cfg(not(stage0))]\n     use unstable::intrinsics::contains_managed;\n \n     /// The internal representation of a (boxed) vector\n@@ -1927,21 +1838,6 @@ pub mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline]\n-    #[cfg(stage0)]\n-    pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        let repr: **mut VecRepr = transmute(v);\n-        (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n-    }\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifing its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    #[inline]\n-    #[cfg(not(stage0))]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         if contains_managed::<T>() {\n             let repr: **mut VecRepr = transmute(v);\n@@ -2286,19 +2182,6 @@ impl<T> Iterator<T> for VecConsumeRevIterator<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n-    pub fn from_iterator(iterator: &mut T) -> ~[A] {\n-        let mut xs = ~[];\n-        for iterator.advance |x| {\n-            xs.push(x);\n-        }\n-        xs\n-    }\n-}\n-\n-\n-#[cfg(not(stage0))]\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();"}, {"sha": "15ac50b917cc39046b442f3e067d0e2389bb780a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -704,10 +704,7 @@ pub fn new_sctable_internal() -> SCTable {\n \n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_sctable() -> @mut SCTable {\n-    #[cfg(not(stage0))]\n     static sctable_key: local_data::Key<@@mut SCTable> = &local_data::Key;\n-    #[cfg(stage0)]\n-    fn sctable_key(_: @@mut SCTable) {}\n     match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n         None => {\n             let new_table = @@mut new_sctable_internal();"}, {"sha": "8be55ac0dc715eb1b313c249a104b1613b305ef6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -188,10 +188,7 @@ fn diagnosticcolor(lvl: level) -> term::color::Color {\n }\n \n fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n-    #[cfg(not(stage0))]\n     static tls_terminal: local_data::Key<@Option<term::Terminal>> = &local_data::Key;\n-    #[cfg(stage0)]\n-    fn tls_terminal(_: @Option<term::Terminal>) {}\n \n     let stderr = io::stderr();\n "}, {"sha": "322424b90fbe19663666b7f5e95ec54611505a9b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -484,11 +484,8 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n-    #[cfg(not(stage0))]\n     static key: local_data::Key<@@::parse::token::ident_interner> =\n         &local_data::Key;\n-    #[cfg(stage0)]\n-    fn key(_: @@::parse::token::ident_interner) {}\n     match local_data::get(key, |k| k.map(|&k| *k)) {\n         Some(interner) => *interner,\n         None => {"}, {"sha": "a4afb1c0bc5352f15fdc0b25a67c6e64b7639393", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -183,9 +183,6 @@ void task_start_wrapper(spawn_args *a)\n         // free the environment (which should be a unique closure).\n         const type_desc *td = env->td;\n         td->drop_glue(NULL,\n-#ifdef _RUST_STAGE0\n-                      NULL,\n-#endif\n                       box_body(env));\n         task->kernel->region()->free(env);\n     }"}, {"sha": "60ca5674b01638cf7a8e0c9982a2ed9e06422561", "filename": "src/rt/rust_type.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Frt%2Frust_type.h", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Frt%2Frust_type.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_type.h?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -26,9 +26,6 @@ typedef void (*CDECL spawn_fn)(rust_opaque_box*, void *);\n struct type_desc;\n \n typedef void CDECL (glue_fn)(void *,\n-#ifdef _RUST_STAGE0\n-                             const type_desc **,\n-#endif\n                              void *);\n \n // Corresponds to the boxed data in the @ region.  The body follows the"}, {"sha": "a3297ef7f1d84d2df6588bc8d03c17fcd1c2f7c7", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74f4badcab30c91b018f308d2c44641abed7d732/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/74f4badcab30c91b018f308d2c44641abed7d732/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=74f4badcab30c91b018f308d2c44641abed7d732", "patch": "@@ -1,3 +1,11 @@\n+S 2013-07-21 e336cbf\n+  macos-i386 d9666dccc1040ebe298a54acb378902a7472ad0f\n+  macos-x86_64 808f68916444e3857ef2aab20f8db9db8f4b0b4a\n+  winnt-i386 f9a5f891fd24e9446acb2a1b5d697461665c4388\n+  freebsd-x86_64 8e79f6e970bc33ea6a3b9329bc4526d89ca63d47\n+  linux-i386 054a0229b9cbdadf013868ba01a8277883f83a6d\n+  linux-x86_64 2c53a72e9c9bb547df248a2d4b857d480ce0b910\n+\n S 2013-06-23 f827561\n   macos-i386 63ffbcf99b6853d7840bdfe01380068518d0e466\n   macos-x86_64 b34fdf3845f8ef4760817007d8ef820cd32f2e07"}]}