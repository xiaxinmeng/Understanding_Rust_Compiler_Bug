{"sha": "fb169d5543c84e11038ba2d07b538ec88fb49ca6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMTY5ZDU1NDNjODRlMTEwMzhiYTJkMDdiNTM4ZWM4OGZiNDljYTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-15T04:57:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-19T19:59:40Z"}, "message": "Remove a number of deprecated crates\n\nAll of these crates have been deprecated for some time and properly live in the\nrust-lang organization as cargo-based crates.\n\nTo update your code, depend on the rust-lang/foo repository via cargo.\n\n[breaking-change]", "tree": {"sha": "252d6fd6dffe26a06e39f735275979b247f40302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/252d6fd6dffe26a06e39f735275979b247f40302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb169d5543c84e11038ba2d07b538ec88fb49ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb169d5543c84e11038ba2d07b538ec88fb49ca6", "html_url": "https://github.com/rust-lang/rust/commit/fb169d5543c84e11038ba2d07b538ec88fb49ca6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb169d5543c84e11038ba2d07b538ec88fb49ca6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c121cbab35c9ff9ba133c578976a4ec35c011bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c121cbab35c9ff9ba133c578976a4ec35c011bcf", "html_url": "https://github.com/rust-lang/rust/commit/c121cbab35c9ff9ba133c578976a4ec35c011bcf"}], "stats": {"total": 8551, "additions": 4, "deletions": 8547}, "files": [{"sha": "00c00b3d3595b87c3d4342769391bf851f9dcb61", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb169d5543c84e11038ba2d07b538ec88fb49ca6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fb169d5543c84e11038ba2d07b538ec88fb49ca6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=fb169d5543c84e11038ba2d07b538ec88fb49ca6", "patch": "@@ -49,11 +49,11 @@\n # automatically generated for all stage/host/target combinations.\n ################################################################################\n \n-TARGET_CRATES := libc std green native flate arena glob term semver \\\n-                 uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rbml rlibc alloc rustrt \\\n+TARGET_CRATES := libc std green native flate arena term \\\n+                 serialize sync getopts collections test time rand \\\n+                 log regex graphviz core rbml rlibc alloc rustrt \\\n                  unicode\n-HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros \\\n+HOST_CRATES := syntax rustc rustdoc regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n@@ -83,18 +83,13 @@ DEPS_glob := std\n DEPS_serialize := std log\n DEPS_rbml := std log serialize\n DEPS_term := std log\n-DEPS_semver := std\n-DEPS_uuid := std serialize\n DEPS_sync := core alloc rustrt collections\n DEPS_getopts := std\n DEPS_collections := core alloc unicode\n-DEPS_fourcc := rustc syntax std\n-DEPS_hexfloat := rustc syntax std\n DEPS_num := std\n DEPS_test := std getopts serialize rbml term time regex native:rust_test_helpers\n DEPS_time := std serialize\n DEPS_rand := core\n-DEPS_url := std\n DEPS_log := std regex\n DEPS_regex := std\n DEPS_regex_macros = rustc syntax std regex"}, {"sha": "ffa72e6d7958ea4c17c357bb7c53a1041c78e82f", "filename": "src/libfourcc/lib.rs", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,163 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Syntax extension to generate FourCCs.\n-\n-Once loaded, fourcc!() is called with a single 4-character string,\n-and an optional ident that is either `big`, `little`, or `target`.\n-The ident represents endianness, and specifies in which direction\n-the characters should be read. If the ident is omitted, it is assumed\n-to be `big`, i.e. left-to-right order. It returns a u32.\n-\n-# Examples\n-\n-To load the extension and use it:\n-\n-```rust,ignore\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(\"\\xC0\\xFF\\xEE!\");\n-    assert_eq!(val, 0xC0FFEE21u32);\n-    let little_val = fourcc!(\"foo \", little);\n-    assert_eq!(little_val, 0x21EEFFC0u32);\n-}\n-```\n-\n-# References\n-\n-* [Wikipedia: FourCC](http://en.wikipedia.org/wiki/FourCC)\n-\n-*/\n-\n-#![crate_name = \"fourcc\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/fourcc\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![feature(plugin_registrar)]\n-\n-extern crate syntax;\n-extern crate rustc;\n-\n-use syntax::ast;\n-use syntax::attr::contains;\n-use syntax::codemap::{Span, mk_sp};\n-use syntax::ext::base;\n-use syntax::ext::base::{ExtCtxt, MacExpr};\n-use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n-use syntax::parse::token::InternedString;\n-use syntax::ptr::P;\n-use rustc::plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"fourcc\", expand_syntax_ext);\n-}\n-\n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n-    let (expr, endian) = parse_tts(cx, tts);\n-\n-    let little = match endian {\n-        None => false,\n-        Some(Ident{ident, span}) => match token::get_ident(ident).get() {\n-            \"little\" => true,\n-            \"big\" => false,\n-            \"target\" => target_endian_little(cx, sp),\n-            _ => {\n-                cx.span_err(span, \"invalid endian directive in fourcc!\");\n-                target_endian_little(cx, sp)\n-            }\n-        }\n-    };\n-\n-    let s = match expr.node {\n-        // expression is a literal\n-        ast::ExprLit(ref lit) => match lit.node {\n-            // string literal\n-            ast::LitStr(ref s, _) => {\n-                if s.get().char_len() != 4 {\n-                    cx.span_err(expr.span, \"string literal with len != 4 in fourcc!\");\n-                }\n-                s\n-            }\n-            _ => {\n-                cx.span_err(expr.span, \"unsupported literal in fourcc!\");\n-                return base::DummyResult::expr(sp)\n-            }\n-        },\n-        _ => {\n-            cx.span_err(expr.span, \"non-literal in fourcc!\");\n-            return base::DummyResult::expr(sp)\n-        }\n-    };\n-\n-    let mut val = 0u32;\n-    for codepoint in s.get().chars().take(4) {\n-        let byte = if codepoint as u32 > 0xFF {\n-            cx.span_err(expr.span, \"fourcc! literal character out of range 0-255\");\n-            0u8\n-        } else {\n-            codepoint as u8\n-        };\n-\n-        val = if little {\n-            (val >> 8) | ((byte as u32) << 24)\n-        } else {\n-            (val << 8) | (byte as u32)\n-        };\n-    }\n-    let e = cx.expr_lit(sp, ast::LitInt(val as u64, ast::UnsignedIntLit(ast::TyU32)));\n-    MacExpr::new(e)\n-}\n-\n-struct Ident {\n-    ident: ast::Ident,\n-    span: Span\n-}\n-\n-fn parse_tts(cx: &ExtCtxt,\n-             tts: &[ast::TokenTree]) -> (P<ast::Expr>, Option<Ident>) {\n-    let p = &mut cx.new_parser_from_tts(tts);\n-    let ex = p.parse_expr();\n-    let id = if p.token == token::EOF {\n-        None\n-    } else {\n-        p.expect(&token::COMMA);\n-        let lo = p.span.lo;\n-        let ident = p.parse_ident();\n-        let hi = p.last_span.hi;\n-        Some(Ident{ident: ident, span: mk_sp(lo, hi)})\n-    };\n-    if p.token != token::EOF {\n-        p.unexpected();\n-    }\n-    (ex, id)\n-}\n-\n-fn target_endian_little(cx: &ExtCtxt, sp: Span) -> bool {\n-    let meta = cx.meta_name_value(sp, InternedString::new(\"target_endian\"),\n-        ast::LitStr(InternedString::new(\"little\"), ast::CookedStr));\n-    contains(cx.cfg().as_slice(), &*meta)\n-}\n-\n-// FIXME (10872): This is required to prevent an LLVM assert on Windows\n-#[test]\n-fn dummy_test() { }"}, {"sha": "0313c22933cfabb0fc8fcbb7ca45a20530df9ac4", "filename": "src/libglob/lib.rs", "status": "removed", "additions": 0, "deletions": 893, "changes": 893, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,893 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Support for matching file paths against Unix shell style patterns.\n- *\n- * The `glob` and `glob_with` functions, in concert with the `Paths`\n- * type, allow querying the filesystem for all files that match a particular\n- * pattern - just like the libc `glob` function (for an example see the `glob`\n- * documentation). The methods on the `Pattern` type provide functionality\n- * for checking if individual paths match a particular pattern - in a similar\n- * manner to the libc `fnmatch` function\n- *\n- * For consistency across platforms, and for Windows support, this module\n- * is implemented entirely in Rust rather than deferring to the libc\n- * `glob`/`fnmatch` functions.\n- */\n-\n-#![crate_name = \"glob\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/glob\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(deprecated)]\n-\n-use std::cell::Cell;\n-use std::{cmp, os, path};\n-use std::io::fs::PathExtensions;\n-use std::io::fs;\n-use std::path::is_sep;\n-use std::string::String;\n-\n-/**\n- * An iterator that yields Paths from the filesystem that match a particular\n- * pattern - see the `glob` function for more details.\n- */\n-pub struct Paths {\n-    dir_patterns: Vec<Pattern>,\n-    require_dir: bool,\n-    options: MatchOptions,\n-    todo: Vec<(Path,uint)>,\n-}\n-\n-///\n-/// Return an iterator that produces all the Paths that match the given pattern,\n-/// which may be absolute or relative to the current working directory.\n-///\n-/// This method uses the default match options and is equivalent to calling\n-/// `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n-/// want to use non-default match options.\n-///\n-/// # Example\n-///\n-/// Consider a directory `/media/pictures` containing only the files `kittens.jpg`,\n-/// `puppies.jpg` and `hamsters.gif`:\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use glob::glob;\n-///\n-/// for path in glob(\"/media/pictures/*.jpg\") {\n-///     println!(\"{}\", path.display());\n-/// }\n-/// ```\n-///\n-/// The above code will print:\n-///\n-/// ```ignore\n-/// /media/pictures/kittens.jpg\n-/// /media/pictures/puppies.jpg\n-/// ```\n-///\n-pub fn glob(pattern: &str) -> Paths {\n-    glob_with(pattern, MatchOptions::new())\n-}\n-\n-/**\n- * Return an iterator that produces all the Paths that match the given pattern,\n- * which may be absolute or relative to the current working directory.\n- *\n- * This function accepts Unix shell style patterns as described by `Pattern::new(..)`.\n- * The options given are passed through unchanged to `Pattern::matches_with(..)` with\n- * the exception that `require_literal_separator` is always set to `true` regardless of the\n- * value passed to this function.\n- *\n- * Paths are yielded in alphabetical order, as absolute paths.\n- */\n-pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n-    #[cfg(windows)]\n-    fn check_windows_verbatim(p: &Path) -> bool { path::windows::is_verbatim(p) }\n-    #[cfg(not(windows))]\n-    fn check_windows_verbatim(_: &Path) -> bool { false }\n-\n-    // calculate root this way to handle volume-relative Windows paths correctly\n-    let mut root = os::getcwd();\n-    let pat_root = Path::new(pattern).root_path();\n-    if pat_root.is_some() {\n-        if check_windows_verbatim(pat_root.as_ref().unwrap()) {\n-            // FIXME: How do we want to handle verbatim paths? I'm inclined to return nothing,\n-            // since we can't very well find all UNC shares with a 1-letter server name.\n-            return Paths {\n-                dir_patterns: Vec::new(),\n-                require_dir: false,\n-                options: options,\n-                todo: Vec::new(),\n-            };\n-        }\n-        root.push(pat_root.as_ref().unwrap());\n-    }\n-\n-    let root_len = pat_root.map_or(0u, |p| p.as_vec().len());\n-    let dir_patterns = pattern.slice_from(cmp::min(root_len, pattern.len()))\n-                       .split_terminator(is_sep)\n-                       .map(|s| Pattern::new(s))\n-                       .collect::<Vec<Pattern>>();\n-    let require_dir = pattern.chars().next_back().map(is_sep) == Some(true);\n-\n-    let mut todo = Vec::new();\n-    if dir_patterns.len() > 0 {\n-        // Shouldn't happen, but we're using -1 as a special index.\n-        assert!(dir_patterns.len() < -1 as uint);\n-\n-        fill_todo(&mut todo, dir_patterns.as_slice(), 0, &root, options);\n-    }\n-\n-    Paths {\n-        dir_patterns: dir_patterns,\n-        require_dir: require_dir,\n-        options: options,\n-        todo: todo,\n-    }\n-}\n-\n-impl Iterator<Path> for Paths {\n-\n-    fn next(&mut self) -> Option<Path> {\n-        loop {\n-            if self.dir_patterns.is_empty() || self.todo.is_empty() {\n-                return None;\n-            }\n-\n-            let (path,idx) = self.todo.pop().unwrap();\n-            // idx -1: was already checked by fill_todo, maybe path was '.' or\n-            // '..' that we can't match here because of normalization.\n-            if idx == -1 as uint {\n-                if self.require_dir && !path.is_dir() { continue; }\n-                return Some(path);\n-            }\n-            let ref pattern = self.dir_patterns[idx];\n-\n-            if pattern.matches_with(match path.filename_str() {\n-                // this ugly match needs to go here to avoid a borrowck error\n-                None => {\n-                    // FIXME (#9639): How do we handle non-utf8 filenames? Ignore them for now\n-                    // Ideally we'd still match them against a *\n-                    continue;\n-                }\n-                Some(x) => x\n-            }, self.options) {\n-                if idx == self.dir_patterns.len() - 1 {\n-                    // it is not possible for a pattern to match a directory *AND* its children\n-                    // so we don't need to check the children\n-\n-                    if !self.require_dir || path.is_dir() {\n-                        return Some(path);\n-                    }\n-                } else {\n-                    fill_todo(&mut self.todo, self.dir_patterns.as_slice(),\n-                              idx + 1, &path, self.options);\n-                }\n-            }\n-        }\n-    }\n-\n-}\n-\n-fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n-    match fs::readdir(path) {\n-        Ok(mut children) => {\n-            children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n-            Some(children.into_iter().collect())\n-        }\n-        Err(..) => None\n-    }\n-}\n-\n-/**\n- * A compiled Unix shell style pattern.\n- */\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n-pub struct Pattern {\n-    tokens: Vec<PatternToken>,\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-enum PatternToken {\n-    Char(char),\n-    AnyChar,\n-    AnySequence,\n-    AnyWithin(Vec<CharSpecifier> ),\n-    AnyExcept(Vec<CharSpecifier> )\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-enum CharSpecifier {\n-    SingleChar(char),\n-    CharRange(char, char)\n-}\n-\n-#[deriving(PartialEq)]\n-enum MatchResult {\n-    Match,\n-    SubPatternDoesntMatch,\n-    EntirePatternDoesntMatch\n-}\n-\n-impl Pattern {\n-\n-    /**\n-     * This function compiles Unix shell style patterns: `?` matches any single\n-     * character, `*` matches any (possibly empty) sequence of characters and\n-     * `[...]` matches any character inside the brackets, unless the first\n-     * character is `!` in which case it matches any character except those\n-     * between the `!` and the `]`. Character sequences can also specify ranges\n-     * of characters, as ordered by Unicode, so e.g. `[0-9]` specifies any\n-     * character between 0 and 9 inclusive.\n-     *\n-     * The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets\n-     * (e.g. `[?]`).  When a `]` occurs immediately following `[` or `[!` then\n-     * it is interpreted as being part of, rather then ending, the character\n-     * set, so `]` and NOT `]` can be matched by `[]]` and `[!]]` respectively.\n-     * The `-` character can be specified inside a character sequence pattern by\n-     * placing it at the start or the end, e.g. `[abc-]`.\n-     *\n-     * When a `[` does not have a closing `]` before the end of the string then\n-     * the `[` will be treated literally.\n-     */\n-    pub fn new(pattern: &str) -> Pattern {\n-\n-        let chars = pattern.chars().collect::<Vec<_>>();\n-        let mut tokens = Vec::new();\n-        let mut i = 0;\n-\n-        while i < chars.len() {\n-            match chars[i] {\n-                '?' => {\n-                    tokens.push(AnyChar);\n-                    i += 1;\n-                }\n-                '*' => {\n-                    // *, **, ***, ****, ... are all equivalent\n-                    while i < chars.len() && chars[i] == '*' {\n-                        i += 1;\n-                    }\n-                    tokens.push(AnySequence);\n-                }\n-                '[' => {\n-\n-                    if i <= chars.len() - 4 && chars[i + 1] == '!' {\n-                        match chars.slice_from(i + 3).position_elem(&']') {\n-                            None => (),\n-                            Some(j) => {\n-                                let chars = chars.slice(i + 2, i + 3 + j);\n-                                let cs = parse_char_specifiers(chars);\n-                                tokens.push(AnyExcept(cs));\n-                                i += j + 4;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                    else if i <= chars.len() - 3 && chars[i + 1] != '!' {\n-                        match chars.slice_from(i + 2).position_elem(&']') {\n-                            None => (),\n-                            Some(j) => {\n-                                let cs = parse_char_specifiers(chars.slice(i + 1, i + 2 + j));\n-                                tokens.push(AnyWithin(cs));\n-                                i += j + 3;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    // if we get here then this is not a valid range pattern\n-                    tokens.push(Char('['));\n-                    i += 1;\n-                }\n-                c => {\n-                    tokens.push(Char(c));\n-                    i += 1;\n-                }\n-            }\n-        }\n-\n-        Pattern { tokens: tokens }\n-    }\n-\n-    /**\n-     * Escape metacharacters within the given string by surrounding them in\n-     * brackets. The resulting string will, when compiled into a `Pattern`,\n-     * match the input string and nothing else.\n-     */\n-    pub fn escape(s: &str) -> String {\n-        let mut escaped = String::new();\n-        for c in s.chars() {\n-            match c {\n-                // note that ! does not need escaping because it is only special inside brackets\n-                '?' | '*' | '[' | ']' => {\n-                    escaped.push_char('[');\n-                    escaped.push_char(c);\n-                    escaped.push_char(']');\n-                }\n-                c => {\n-                    escaped.push_char(c);\n-                }\n-            }\n-        }\n-        escaped\n-    }\n-\n-    /**\n-     * Return if the given `str` matches this `Pattern` using the default\n-     * match options (i.e. `MatchOptions::new()`).\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * #![allow(deprecated)]\n-     * use glob::Pattern;\n-     *\n-     * assert!(Pattern::new(\"c?t\").matches(\"cat\"));\n-     * assert!(Pattern::new(\"k[!e]tteh\").matches(\"kitteh\"));\n-     * assert!(Pattern::new(\"d*g\").matches(\"doog\"));\n-     * ```\n-     */\n-    pub fn matches(&self, str: &str) -> bool {\n-        self.matches_with(str, MatchOptions::new())\n-    }\n-\n-    /**\n-     * Return if the given `Path`, when converted to a `str`, matches this `Pattern`\n-     * using the default match options (i.e. `MatchOptions::new()`).\n-     */\n-    pub fn matches_path(&self, path: &Path) -> bool {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        path.as_str().map_or(false, |s| {\n-            self.matches(s)\n-        })\n-    }\n-\n-    /**\n-     * Return if the given `str` matches this `Pattern` using the specified match options.\n-     */\n-    pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool {\n-        self.matches_from(None, str, 0, options) == Match\n-    }\n-\n-    /**\n-     * Return if the given `Path`, when converted to a `str`, matches this `Pattern`\n-     * using the specified match options.\n-     */\n-    pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        path.as_str().map_or(false, |s| {\n-            self.matches_with(s, options)\n-        })\n-    }\n-\n-    fn matches_from(&self,\n-                    prev_char: Option<char>,\n-                    mut file: &str,\n-                    i: uint,\n-                    options: MatchOptions) -> MatchResult {\n-\n-        let prev_char = Cell::new(prev_char);\n-\n-        let require_literal = |c| {\n-            (options.require_literal_separator && is_sep(c)) ||\n-            (options.require_literal_leading_dot && c == '.'\n-             && is_sep(prev_char.get().unwrap_or('/')))\n-        };\n-\n-        for (ti, token) in self.tokens.slice_from(i).iter().enumerate() {\n-            match *token {\n-                AnySequence => {\n-                    loop {\n-                        match self.matches_from(prev_char.get(), file, i + ti + 1, options) {\n-                            SubPatternDoesntMatch => (), // keep trying\n-                            m => return m,\n-                        }\n-\n-                        if file.is_empty() {\n-                            return EntirePatternDoesntMatch;\n-                        }\n-\n-                        let (some_c, next) = file.slice_shift_char();\n-                        if require_literal(some_c.unwrap()) {\n-                            return SubPatternDoesntMatch;\n-                        }\n-                        prev_char.set(some_c);\n-                        file = next;\n-                    }\n-                }\n-                _ => {\n-                    if file.is_empty() {\n-                        return EntirePatternDoesntMatch;\n-                    }\n-\n-                    let (some_c, next) = file.slice_shift_char();\n-                    let c = some_c.unwrap();\n-                    let matches = match *token {\n-                        AnyChar => {\n-                            !require_literal(c)\n-                        }\n-                        AnyWithin(ref specifiers) => {\n-                            !require_literal(c) &&\n-                                in_char_specifiers(specifiers.as_slice(),\n-                                                   c,\n-                                                   options)\n-                        }\n-                        AnyExcept(ref specifiers) => {\n-                            !require_literal(c) &&\n-                                !in_char_specifiers(specifiers.as_slice(),\n-                                                    c,\n-                                                    options)\n-                        }\n-                        Char(c2) => {\n-                            chars_eq(c, c2, options.case_sensitive)\n-                        }\n-                        AnySequence => {\n-                            unreachable!()\n-                        }\n-                    };\n-                    if !matches {\n-                        return SubPatternDoesntMatch;\n-                    }\n-                    prev_char.set(some_c);\n-                    file = next;\n-                }\n-            }\n-        }\n-\n-        if file.is_empty() {\n-            Match\n-        } else {\n-            SubPatternDoesntMatch\n-        }\n-    }\n-\n-}\n-\n-// Fills `todo` with paths under `path` to be matched by `patterns[idx]`,\n-// special-casing patterns to match `.` and `..`, and avoiding `readdir()`\n-// calls when there are no metacharacters in the pattern.\n-fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path: &Path,\n-             options: MatchOptions) {\n-    // convert a pattern that's just many Char(_) to a string\n-    fn pattern_as_str(pattern: &Pattern) -> Option<String> {\n-        let mut s = String::new();\n-        for token in pattern.tokens.iter() {\n-            match *token {\n-                Char(c) => s.push_char(c),\n-                _ => return None\n-            }\n-        }\n-        return Some(s);\n-    }\n-\n-    let add = |todo: &mut Vec<_>, next_path: Path| {\n-        if idx + 1 == patterns.len() {\n-            // We know it's good, so don't make the iterator match this path\n-            // against the pattern again. In particular, it can't match\n-            // . or .. globs since these never show up as path components.\n-            todo.push((next_path, -1 as uint));\n-        } else {\n-            fill_todo(todo, patterns, idx + 1, &next_path, options);\n-        }\n-    };\n-\n-    let pattern = &patterns[idx];\n-\n-    match pattern_as_str(pattern) {\n-        Some(s) => {\n-            // This pattern component doesn't have any metacharacters, so we\n-            // don't need to read the current directory to know where to\n-            // continue. So instead of passing control back to the iterator,\n-            // we can just check for that one entry and potentially recurse\n-            // right away.\n-            let special = \".\" == s.as_slice() || \"..\" == s.as_slice();\n-            let next_path = path.join(s.as_slice());\n-            if (special && path.is_dir()) || (!special && next_path.exists()) {\n-                add(todo, next_path);\n-            }\n-        },\n-        None => {\n-            match list_dir_sorted(path) {\n-                Some(entries) => {\n-                    todo.extend(entries.into_iter().map(|x|(x, idx)));\n-\n-                    // Matching the special directory entries . and .. that refer to\n-                    // the current and parent directory respectively requires that\n-                    // the pattern has a leading dot, even if the `MatchOptions` field\n-                    // `require_literal_leading_dot` is not set.\n-                    if pattern.tokens.len() > 0 && pattern.tokens[0] == Char('.') {\n-                        for &special in [\".\", \"..\"].iter() {\n-                            if pattern.matches_with(special, options) {\n-                                add(todo, path.join(special));\n-                            }\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {\n-    let mut cs = Vec::new();\n-    let mut i = 0;\n-    while i < s.len() {\n-        if i + 3 <= s.len() && s[i + 1] == '-' {\n-            cs.push(CharRange(s[i], s[i + 2]));\n-            i += 3;\n-        } else {\n-            cs.push(SingleChar(s[i]));\n-            i += 1;\n-        }\n-    }\n-    cs\n-}\n-\n-fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool {\n-\n-    for &specifier in specifiers.iter() {\n-        match specifier {\n-            SingleChar(sc) => {\n-                if chars_eq(c, sc, options.case_sensitive) {\n-                    return true;\n-                }\n-            }\n-            CharRange(start, end) => {\n-\n-                // FIXME: work with non-ascii chars properly (issue #1347)\n-                if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii() {\n-\n-                    let start = start.to_ascii().to_lowercase();\n-                    let end = end.to_ascii().to_lowercase();\n-\n-                    let start_up = start.to_uppercase();\n-                    let end_up = end.to_uppercase();\n-\n-                    // only allow case insensitive matching when\n-                    // both start and end are within a-z or A-Z\n-                    if start != start_up && end != end_up {\n-                        let start = start.to_char();\n-                        let end = end.to_char();\n-                        let c = c.to_ascii().to_lowercase().to_char();\n-                        if c >= start && c <= end {\n-                            return true;\n-                        }\n-                    }\n-                }\n-\n-                if c >= start && c <= end {\n-                    return true;\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-/// A helper function to determine if two chars are (possibly case-insensitively) equal.\n-fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n-    if cfg!(windows) && path::windows::is_sep(a) && path::windows::is_sep(b) {\n-        true\n-    } else if !case_sensitive && a.is_ascii() && b.is_ascii() {\n-        // FIXME: work with non-ascii chars properly (issue #1347)\n-        a.to_ascii().eq_ignore_case(b.to_ascii())\n-    } else {\n-        a == b\n-    }\n-}\n-\n-/**\n- * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n- */\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n-pub struct MatchOptions {\n-\n-    /**\n-     * Whether or not patterns should be matched in a case-sensitive manner. This\n-     * currently only considers upper/lower case relationships between ASCII characters,\n-     * but in future this might be extended to work with Unicode.\n-     */\n-    pub case_sensitive: bool,\n-\n-    /**\n-     * If this is true then path-component separator characters (e.g. `/` on Posix)\n-     * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n-     */\n-    pub require_literal_separator: bool,\n-\n-    /**\n-     * If this is true then paths that contain components that start with a `.` will\n-     * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n-     * will not match. This is useful because such files are conventionally considered\n-     * hidden on Unix systems and it might be desirable to skip them when listing files.\n-     */\n-    pub require_literal_leading_dot: bool\n-}\n-\n-impl MatchOptions {\n-\n-    /**\n-     * Constructs a new `MatchOptions` with default field values. This is used\n-     * when calling functions that do not take an explicit `MatchOptions` parameter.\n-     *\n-     * This function always returns this value:\n-     *\n-     * ```rust,ignore\n-     * MatchOptions {\n-     *     case_sensitive: true,\n-     *     require_literal_separator: false.\n-     *     require_literal_leading_dot: false\n-     * }\n-     * ```\n-     */\n-    pub fn new() -> MatchOptions {\n-        MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        }\n-    }\n-\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::os;\n-    use super::{glob, Pattern, MatchOptions};\n-\n-    #[test]\n-    fn test_absolute_pattern() {\n-        // assume that the filesystem is not empty!\n-        assert!(glob(\"/*\").next().is_some());\n-        assert!(glob(\"//\").next().is_some());\n-\n-        // check windows absolute paths with host/device components\n-        let root_with_device = os::getcwd().root_path().unwrap().join(\"*\");\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        assert!(glob(root_with_device.as_str().unwrap()).next().is_some());\n-    }\n-\n-    #[test]\n-    fn test_wildcard_optimizations() {\n-        assert!(Pattern::new(\"a*b\").matches(\"a___b\"));\n-        assert!(Pattern::new(\"a**b\").matches(\"a___b\"));\n-        assert!(Pattern::new(\"a***b\").matches(\"a___b\"));\n-        assert!(Pattern::new(\"a*b*c\").matches(\"abc\"));\n-        assert!(!Pattern::new(\"a*b*c\").matches(\"abcd\"));\n-        assert!(Pattern::new(\"a*b*c\").matches(\"a_b_c\"));\n-        assert!(Pattern::new(\"a*b*c\").matches(\"a___b___c\"));\n-        assert!(Pattern::new(\"abc*abc*abc\").matches(\"abcabcabcabcabcabcabc\"));\n-        assert!(!Pattern::new(\"abc*abc*abc\").matches(\"abcabcabcabcabcabcabca\"));\n-        assert!(Pattern::new(\"a*a*a*a*a*a*a*a*a\").matches(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n-        assert!(Pattern::new(\"a*b[xyz]c*d\").matches(\"abxcdbxcddd\"));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(windows, ignore)] // FIXME (#9406)\n-    fn test_lots_of_files() {\n-        // this is a good test because it touches lots of differently named files\n-        glob(\"/*/*/*/*\").skip(10000).next();\n-    }\n-\n-    #[test]\n-    fn test_range_pattern() {\n-\n-        let pat = Pattern::new(\"a[0-9]b\");\n-        for i in range(0u, 10) {\n-            assert!(pat.matches(format!(\"a{}b\", i).as_slice()));\n-        }\n-        assert!(!pat.matches(\"a_b\"));\n-\n-        let pat = Pattern::new(\"a[!0-9]b\");\n-        for i in range(0u, 10) {\n-            assert!(!pat.matches(format!(\"a{}b\", i).as_slice()));\n-        }\n-        assert!(pat.matches(\"a_b\"));\n-\n-        let pats = [\"[a-z123]\", \"[1a-z23]\", \"[123a-z]\"];\n-        for &p in pats.iter() {\n-            let pat = Pattern::new(p);\n-            for c in \"abcdefghijklmnopqrstuvwxyz\".chars() {\n-                assert!(pat.matches(c.to_string().as_slice()));\n-            }\n-            for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars() {\n-                let options = MatchOptions {case_sensitive: false, .. MatchOptions::new()};\n-                assert!(pat.matches_with(c.to_string().as_slice(), options));\n-            }\n-            assert!(pat.matches(\"1\"));\n-            assert!(pat.matches(\"2\"));\n-            assert!(pat.matches(\"3\"));\n-        }\n-\n-        let pats = [\"[abc-]\", \"[-abc]\", \"[a-c-]\"];\n-        for &p in pats.iter() {\n-            let pat = Pattern::new(p);\n-            assert!(pat.matches(\"a\"));\n-            assert!(pat.matches(\"b\"));\n-            assert!(pat.matches(\"c\"));\n-            assert!(pat.matches(\"-\"));\n-            assert!(!pat.matches(\"d\"));\n-        }\n-\n-        let pat = Pattern::new(\"[2-1]\");\n-        assert!(!pat.matches(\"1\"));\n-        assert!(!pat.matches(\"2\"));\n-\n-        assert!(Pattern::new(\"[-]\").matches(\"-\"));\n-        assert!(!Pattern::new(\"[!-]\").matches(\"-\"));\n-    }\n-\n-    #[test]\n-    fn test_unclosed_bracket() {\n-        // unclosed `[` should be treated literally\n-        assert!(Pattern::new(\"abc[def\").matches(\"abc[def\"));\n-        assert!(Pattern::new(\"abc[!def\").matches(\"abc[!def\"));\n-        assert!(Pattern::new(\"abc[\").matches(\"abc[\"));\n-        assert!(Pattern::new(\"abc[!\").matches(\"abc[!\"));\n-        assert!(Pattern::new(\"abc[d\").matches(\"abc[d\"));\n-        assert!(Pattern::new(\"abc[!d\").matches(\"abc[!d\"));\n-        assert!(Pattern::new(\"abc[]\").matches(\"abc[]\"));\n-        assert!(Pattern::new(\"abc[!]\").matches(\"abc[!]\"));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches() {\n-        let txt_pat = Pattern::new(\"*hello.txt\");\n-        assert!(txt_pat.matches(\"hello.txt\"));\n-        assert!(txt_pat.matches(\"gareth_says_hello.txt\"));\n-        assert!(txt_pat.matches(\"some/path/to/hello.txt\"));\n-        assert!(txt_pat.matches(\"some\\\\path\\\\to\\\\hello.txt\"));\n-        assert!(txt_pat.matches(\"/an/absolute/path/to/hello.txt\"));\n-        assert!(!txt_pat.matches(\"hello.txt-and-then-some\"));\n-        assert!(!txt_pat.matches(\"goodbye.txt\"));\n-\n-        let dir_pat = Pattern::new(\"*some/path/to/hello.txt\");\n-        assert!(dir_pat.matches(\"some/path/to/hello.txt\"));\n-        assert!(dir_pat.matches(\"a/bigger/some/path/to/hello.txt\"));\n-        assert!(!dir_pat.matches(\"some/path/to/hello.txt-and-then-some\"));\n-        assert!(!dir_pat.matches(\"some/other/path/to/hello.txt\"));\n-    }\n-\n-    #[test]\n-    fn test_pattern_escape() {\n-        let s = \"_[_]_?_*_!_\";\n-        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_string());\n-        assert!(Pattern::new(Pattern::escape(s).as_slice()).matches(s));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_case_insensitive() {\n-\n-        let pat = Pattern::new(\"aBcDeFg\");\n-        let options = MatchOptions {\n-            case_sensitive: false,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        assert!(pat.matches_with(\"aBcDeFg\", options));\n-        assert!(pat.matches_with(\"abcdefg\", options));\n-        assert!(pat.matches_with(\"ABCDEFG\", options));\n-        assert!(pat.matches_with(\"AbCdEfG\", options));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_case_insensitive_range() {\n-\n-        let pat_within = Pattern::new(\"[a]\");\n-        let pat_except = Pattern::new(\"[!a]\");\n-\n-        let options_case_insensitive = MatchOptions {\n-            case_sensitive: false,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-        let options_case_sensitive = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        assert!(pat_within.matches_with(\"a\", options_case_insensitive));\n-        assert!(pat_within.matches_with(\"A\", options_case_insensitive));\n-        assert!(!pat_within.matches_with(\"A\", options_case_sensitive));\n-\n-        assert!(!pat_except.matches_with(\"a\", options_case_insensitive));\n-        assert!(!pat_except.matches_with(\"A\", options_case_insensitive));\n-        assert!(pat_except.matches_with(\"A\", options_case_sensitive));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_require_literal_separator() {\n-\n-        let options_require_literal = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: true,\n-            require_literal_leading_dot: false\n-        };\n-        let options_not_require_literal = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        assert!(Pattern::new(\"abc/def\").matches_with(\"abc/def\", options_require_literal));\n-        assert!(!Pattern::new(\"abc?def\").matches_with(\"abc/def\", options_require_literal));\n-        assert!(!Pattern::new(\"abc*def\").matches_with(\"abc/def\", options_require_literal));\n-        assert!(!Pattern::new(\"abc[/]def\").matches_with(\"abc/def\", options_require_literal));\n-\n-        assert!(Pattern::new(\"abc/def\").matches_with(\"abc/def\", options_not_require_literal));\n-        assert!(Pattern::new(\"abc?def\").matches_with(\"abc/def\", options_not_require_literal));\n-        assert!(Pattern::new(\"abc*def\").matches_with(\"abc/def\", options_not_require_literal));\n-        assert!(Pattern::new(\"abc[/]def\").matches_with(\"abc/def\", options_not_require_literal));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_require_literal_leading_dot() {\n-\n-        let options_require_literal_leading_dot = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: true\n-        };\n-        let options_not_require_literal_leading_dot = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        let f = |options| Pattern::new(\"*.txt\").matches_with(\".hello.txt\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\".*.*\").matches_with(\".hello.txt\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/bbb/*\").matches_with(\"aaa/bbb/.ccc\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/bbb/*\").matches_with(\"aaa/bbb/c.c.c.\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/bbb/.*\").matches_with(\"aaa/bbb/.ccc\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/?bbb\").matches_with(\"aaa/.bbb\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/[.]bbb\").matches_with(\"aaa/.bbb\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-    }\n-\n-    #[test]\n-    fn test_matches_path() {\n-        // on windows, (Path::new(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n-        // tests that / and \\ are considered equivalent on windows\n-        assert!(Pattern::new(\"a/b\").matches_path(&Path::new(\"a/b\")));\n-    }\n-}"}, {"sha": "8335cc16d649f6767ad3a94ebec6433c28fb33d6", "filename": "src/libhexfloat/lib.rs", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,189 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Syntax extension to create floating point literals from hexadecimal strings\n-\n-Once loaded, hexfloat!() is called with a string containing the hexadecimal\n-floating-point literal, and an optional type (f32 or f64).\n-If the type is omitted, the literal is treated the same as a normal unsuffixed\n-literal.\n-\n-# Examples\n-\n-To load the extension and use it:\n-\n-```rust,ignore\n-#[phase(plugin)]\n-extern crate hexfloat;\n-\n-fn main() {\n-    let val = hexfloat!(\"0x1.ffffb4\", f32);\n-}\n-```\n-\n-# References\n-\n-* [ExploringBinary: hexadecimal floating point constants]\n-  (http://www.exploringbinary.com/hexadecimal-floating-point-constants/)\n-\n-*/\n-\n-#![crate_name = \"hexfloat\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/hexfloat\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(plugin_registrar)]\n-\n-extern crate syntax;\n-extern crate rustc;\n-\n-use syntax::ast;\n-use syntax::codemap::{Span, mk_sp};\n-use syntax::ext::base;\n-use syntax::ext::base::{ExtCtxt, MacExpr};\n-use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n-use syntax::ptr::P;\n-use rustc::plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"hexfloat\", expand_syntax_ext);\n-}\n-\n-//Check if the literal is valid (as LLVM expects),\n-//and return a descriptive error if not.\n-fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n-    let mut chars = s.chars().peekable();\n-    let mut i = 0;\n-    if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    if chars.next() != Some('0') {\n-        return Some((i, \"Expected '0'\".to_string()));\n-    } i+=1;\n-    if chars.next() != Some('x') {\n-        return Some((i, \"Expected 'x'\".to_string()));\n-    } i+=1;\n-    let mut d_len = 0i;\n-    for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n-    if chars.next() != Some('.') {\n-        return Some((i, \"Expected '.'\".to_string()));\n-    } i+=1;\n-    let mut f_len = 0i;\n-    for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n-    if d_len == 0 && f_len == 0 {\n-        return Some((i, \"Expected digits before or after decimal \\\n-                         point\".to_string()));\n-    }\n-    if chars.next() != Some('p') {\n-        return Some((i, \"Expected 'p'\".to_string()));\n-    } i+=1;\n-    if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    let mut e_len = 0i;\n-    for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n-    if e_len == 0 {\n-        return Some((i, \"Expected exponent digits\".to_string()));\n-    }\n-    match chars.next() {\n-        None => None,\n-        Some(_) => Some((i, \"Expected end of string\".to_string()))\n-    }\n-}\n-\n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult+'static> {\n-    let (expr, ty_lit) = parse_tts(cx, tts);\n-\n-    let ty = match ty_lit {\n-        None => None,\n-        Some(Ident{ident, span}) => match token::get_ident(ident).get() {\n-            \"f32\" => Some(ast::TyF32),\n-            \"f64\" => Some(ast::TyF64),\n-            _ => {\n-                cx.span_err(span, \"invalid floating point type in hexfloat!\");\n-                None\n-            }\n-        }\n-    };\n-\n-    let s = match expr.node {\n-        // expression is a literal\n-        ast::ExprLit(ref lit) => match lit.node {\n-            // string literal\n-            ast::LitStr(ref s, _) => {\n-                s.clone()\n-            }\n-            _ => {\n-                cx.span_err(expr.span, \"unsupported literal in hexfloat!\");\n-                return base::DummyResult::expr(sp);\n-            }\n-        },\n-        _ => {\n-            cx.span_err(expr.span, \"non-literal in hexfloat!\");\n-            return base::DummyResult::expr(sp);\n-        }\n-    };\n-\n-    {\n-        let err = hex_float_lit_err(s.get());\n-        match err {\n-            Some((err_pos, err_str)) => {\n-                let pos = expr.span.lo + syntax::codemap::Pos::from_uint(err_pos + 1);\n-                let span = syntax::codemap::mk_sp(pos,pos);\n-                cx.span_err(span,\n-                            format!(\"invalid hex float literal in hexfloat!: \\\n-                                     {}\",\n-                                    err_str).as_slice());\n-                return base::DummyResult::expr(sp);\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    let lit = match ty {\n-        None => ast::LitFloatUnsuffixed(s),\n-        Some (ty) => ast::LitFloat(s, ty)\n-    };\n-    MacExpr::new(cx.expr_lit(sp, lit))\n-}\n-\n-struct Ident {\n-    ident: ast::Ident,\n-    span: Span\n-}\n-\n-fn parse_tts(cx: &ExtCtxt,\n-             tts: &[ast::TokenTree]) -> (P<ast::Expr>, Option<Ident>) {\n-    let p = &mut cx.new_parser_from_tts(tts);\n-    let ex = p.parse_expr();\n-    let id = if p.token == token::EOF {\n-        None\n-    } else {\n-        p.expect(&token::COMMA);\n-        let lo = p.span.lo;\n-        let ident = p.parse_ident();\n-        let hi = p.last_span.hi;\n-        Some(Ident{ident: ident, span: mk_sp(lo, hi)})\n-    };\n-    if p.token != token::EOF {\n-        p.unexpected();\n-    }\n-    (ex, id)\n-}\n-\n-// FIXME (10872): This is required to prevent an LLVM assert on Windows\n-#[test]\n-fn dummy_test() { }"}, {"sha": "e52d62a040be83dc5fdf5c7ec0f4aac912596606", "filename": "src/libnum/bigint.rs", "status": "removed", "additions": 0, "deletions": 2961, "changes": 2961, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,2961 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).\n-//!\n-//! A `BigUint` is represented as an array of `BigDigit`s.\n-//! A `BigInt` is a combination of `BigUint` and `Sign`.\n-//!\n-//! Common numerical operations are overloaded, so we can treat them\n-//! the same way we treat other numbers.\n-//!\n-//! ## Example\n-//!\n-//! ```rust\n-//! # #![allow(deprecated)]\n-//! use num::bigint::BigUint;\n-//! use std::num::{Zero, One};\n-//! use std::mem::replace;\n-//!\n-//! // Calculate large fibonacci numbers.\n-//! fn fib(n: uint) -> BigUint {\n-//!     let mut f0: BigUint = Zero::zero();\n-//!     let mut f1: BigUint = One::one();\n-//!     for _ in range(0, n) {\n-//!         let f2 = f0 + f1;\n-//!         // This is a low cost way of swapping f0 with f1 and f1 with f2.\n-//!         f0 = replace(&mut f1, f2);\n-//!     }\n-//!     f0\n-//! }\n-//!\n-//! // This is a very large number.\n-//! println!(\"fib(1000) = {}\", fib(1000));\n-//! ```\n-//!\n-//! It's easy to generate large random numbers:\n-//!\n-//! ```rust\n-//! # #![allow(deprecated)]\n-//! use num::bigint::{ToBigInt, RandBigInt};\n-//! use std::rand;\n-//!\n-//! let mut rng = rand::task_rng();\n-//! let a = rng.gen_bigint(1000u);\n-//!\n-//! let low = -10000i.to_bigint().unwrap();\n-//! let high = 10000i.to_bigint().unwrap();\n-//! let b = rng.gen_bigint_range(&low, &high);\n-//!\n-//! // Probably an even larger number.\n-//! println!(\"{}\", a * b);\n-//! ```\n-\n-use Integer;\n-use rand::Rng;\n-\n-use std::{cmp, fmt, hash};\n-use std::default::Default;\n-use std::from_str::FromStr;\n-use std::num::CheckedDiv;\n-use std::num::{ToPrimitive, FromPrimitive};\n-use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n-use std::string::String;\n-use std::{uint, i64, u64};\n-\n-/// A `BigDigit` is a `BigUint`'s composing element.\n-pub type BigDigit = u32;\n-\n-/// A `DoubleBigDigit` is the internal type used to do the computations.  Its\n-/// size is the double of the size of `BigDigit`.\n-pub type DoubleBigDigit = u64;\n-\n-pub const ZERO_BIG_DIGIT: BigDigit = 0;\n-static ZERO_VEC: [BigDigit, ..1] = [ZERO_BIG_DIGIT];\n-\n-#[allow(non_snake_case)]\n-pub mod BigDigit {\n-    use super::BigDigit;\n-    use super::DoubleBigDigit;\n-\n-    // `DoubleBigDigit` size dependent\n-    #[allow(non_uppercase_statics)]\n-    pub const bits: uint = 32;\n-\n-    #[allow(non_uppercase_statics)]\n-    pub const base: DoubleBigDigit = 1 << bits;\n-    #[allow(non_uppercase_statics)]\n-    static lo_mask: DoubleBigDigit = (-1 as DoubleBigDigit) >> bits;\n-\n-    #[inline]\n-    fn get_hi(n: DoubleBigDigit) -> BigDigit { (n >> bits) as BigDigit }\n-    #[inline]\n-    fn get_lo(n: DoubleBigDigit) -> BigDigit { (n & lo_mask) as BigDigit }\n-\n-    /// Split one `DoubleBigDigit` into two `BigDigit`s.\n-    #[inline]\n-    pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) {\n-        (get_hi(n), get_lo(n))\n-    }\n-\n-    /// Join two `BigDigit`s into one `DoubleBigDigit`\n-    #[inline]\n-    pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {\n-        (lo as DoubleBigDigit) | ((hi as DoubleBigDigit) << bits)\n-    }\n-}\n-\n-/// A big unsigned integer type.\n-///\n-/// A `BigUint`-typed value `BigUint { data: vec!(a, b, c) }` represents a number\n-/// `(a + b * BigDigit::base + c * BigDigit::base^2)`.\n-#[deriving(Clone)]\n-pub struct BigUint {\n-    data: Vec<BigDigit>\n-}\n-\n-impl PartialEq for BigUint {\n-    #[inline]\n-    fn eq(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Equal => true, _ => false }\n-    }\n-}\n-impl Eq for BigUint {}\n-\n-impl PartialOrd for BigUint {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for BigUint {\n-    #[inline]\n-    fn cmp(&self, other: &BigUint) -> Ordering {\n-        let (s_len, o_len) = (self.data.len(), other.data.len());\n-        if s_len < o_len { return Less; }\n-        if s_len > o_len { return Greater;  }\n-\n-        for (&self_i, &other_i) in self.data.iter().rev().zip(other.data.iter().rev()) {\n-            if self_i < other_i { return Less; }\n-            if self_i > other_i { return Greater; }\n-        }\n-        return Equal;\n-    }\n-}\n-\n-impl Default for BigUint {\n-    #[inline]\n-    fn default() -> BigUint { Zero::zero() }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for BigUint {\n-    fn hash(&self, state: &mut S) {\n-        // hash 0 in case it's all 0's\n-        0u32.hash(state);\n-\n-        let mut found_first_value = false;\n-        for elem in self.data.iter().rev() {\n-            // don't hash any leading 0's, they shouldn't affect the hash\n-            if found_first_value || *elem != 0 {\n-                found_first_value = true;\n-                elem.hash(state);\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Show for BigUint {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_str_radix(10))\n-    }\n-}\n-\n-impl FromStr for BigUint {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<BigUint> {\n-        FromStrRadix::from_str_radix(s, 10)\n-    }\n-}\n-\n-impl Num for BigUint {}\n-\n-impl BitAnd<BigUint, BigUint> for BigUint {\n-    fn bitand(&self, other: &BigUint) -> BigUint {\n-        BigUint::new(self.data.iter().zip(other.data.iter()).map(|(ai, bi)| *ai & *bi).collect())\n-    }\n-}\n-\n-impl BitOr<BigUint, BigUint> for BigUint {\n-    fn bitor(&self, other: &BigUint) -> BigUint {\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n-        let ored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n-            |(ai, bi)| *ai | *bi\n-        ).collect();\n-        return BigUint::new(ored);\n-    }\n-}\n-\n-impl BitXor<BigUint, BigUint> for BigUint {\n-    fn bitxor(&self, other: &BigUint) -> BigUint {\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n-        let xored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n-            |(ai, bi)| *ai ^ *bi\n-        ).collect();\n-        return BigUint::new(xored);\n-    }\n-}\n-\n-impl Shl<uint, BigUint> for BigUint {\n-    #[inline]\n-    fn shl(&self, rhs: &uint) -> BigUint {\n-        let n_unit = *rhs / BigDigit::bits;\n-        let n_bits = *rhs % BigDigit::bits;\n-        return self.shl_unit(n_unit).shl_bits(n_bits);\n-    }\n-}\n-\n-impl Shr<uint, BigUint> for BigUint {\n-    #[inline]\n-    fn shr(&self, rhs: &uint) -> BigUint {\n-        let n_unit = *rhs / BigDigit::bits;\n-        let n_bits = *rhs % BigDigit::bits;\n-        return self.shr_unit(n_unit).shr_bits(n_bits);\n-    }\n-}\n-\n-impl Zero for BigUint {\n-    #[inline]\n-    fn zero() -> BigUint { BigUint::new(Vec::new()) }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { self.data.is_empty() }\n-}\n-\n-impl One for BigUint {\n-    #[inline]\n-    fn one() -> BigUint { BigUint::new(vec!(1)) }\n-}\n-\n-impl Unsigned for BigUint {}\n-\n-impl Add<BigUint, BigUint> for BigUint {\n-    fn add(&self, other: &BigUint) -> BigUint {\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n-\n-        let mut carry = 0;\n-        let mut sum: Vec<BigDigit> =  a.data.iter().zip(b.data.iter().chain(zeros)).map(|(ai, bi)| {\n-            let (hi, lo) = BigDigit::from_doublebigdigit(\n-                (*ai as DoubleBigDigit) + (*bi as DoubleBigDigit) + (carry as DoubleBigDigit));\n-            carry = hi;\n-            lo\n-        }).collect();\n-        if carry != 0 { sum.push(carry); }\n-        return BigUint::new(sum);\n-    }\n-}\n-\n-impl Sub<BigUint, BigUint> for BigUint {\n-    fn sub(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = (self.data.iter().chain(zeros.clone()), other.data.iter().chain(zeros));\n-\n-        let mut borrow = 0i;\n-        let diff: Vec<BigDigit> =  a.take(new_len).zip(b).map(|(ai, bi)| {\n-            let (hi, lo) = BigDigit::from_doublebigdigit(\n-                BigDigit::base\n-                    + (*ai as DoubleBigDigit)\n-                    - (*bi as DoubleBigDigit)\n-                    - (borrow as DoubleBigDigit)\n-            );\n-            /*\n-            hi * (base) + lo == 1*(base) + ai - bi - borrow\n-            => ai - bi - borrow < 0 <=> hi == 0\n-            */\n-            borrow = if hi == 0 { 1 } else { 0 };\n-            lo\n-        }).collect();\n-\n-        assert!(borrow == 0,\n-                \"Cannot subtract other from self because other is larger than self.\");\n-        return BigUint::new(diff);\n-    }\n-}\n-\n-impl Mul<BigUint, BigUint> for BigUint {\n-    fn mul(&self, other: &BigUint) -> BigUint {\n-        if self.is_zero() || other.is_zero() { return Zero::zero(); }\n-\n-        let (s_len, o_len) = (self.data.len(), other.data.len());\n-        if s_len == 1 { return mul_digit(other, self.data.as_slice()[0]);  }\n-        if o_len == 1 { return mul_digit(self,  other.data.as_slice()[0]); }\n-\n-        // Using Karatsuba multiplication\n-        // (a1 * base + a0) * (b1 * base + b0)\n-        // = a1*b1 * base^2 +\n-        //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n-        //   a0*b0\n-        let half_len = cmp::max(s_len, o_len) / 2;\n-        let (s_hi, s_lo) = cut_at(self,  half_len);\n-        let (o_hi, o_lo) = cut_at(other, half_len);\n-\n-        let ll = s_lo * o_lo;\n-        let hh = s_hi * o_hi;\n-        let mm = {\n-            let (s1, n1) = sub_sign(s_hi, s_lo);\n-            let (s2, n2) = sub_sign(o_hi, o_lo);\n-            match (s1, s2) {\n-                (Equal, _) | (_, Equal) => hh + ll,\n-                (Less, Greater) | (Greater, Less) => hh + ll + (n1 * n2),\n-                (Less, Less) | (Greater, Greater) => hh + ll - (n1 * n2)\n-            }\n-        };\n-\n-        return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n-\n-\n-        fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n-            if n == 0 { return Zero::zero(); }\n-            if n == 1 { return (*a).clone(); }\n-\n-            let mut carry = 0;\n-            let mut prod: Vec<BigDigit> = a.data.iter().map(|ai| {\n-                let (hi, lo) = BigDigit::from_doublebigdigit(\n-                    (*ai as DoubleBigDigit) * (n as DoubleBigDigit) + (carry as DoubleBigDigit)\n-                );\n-                carry = hi;\n-                lo\n-            }).collect();\n-            if carry != 0 { prod.push(carry); }\n-            return BigUint::new(prod);\n-        }\n-\n-        #[inline]\n-        fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n-            let mid = cmp::min(a.data.len(), n);\n-            return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n-                    BigUint::from_slice(a.data.slice(0, mid)));\n-        }\n-\n-        #[inline]\n-        fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n-            match a.cmp(&b) {\n-                Less    => (Less,    b - a),\n-                Greater => (Greater, a - b),\n-                _       => (Equal,   Zero::zero())\n-            }\n-        }\n-    }\n-}\n-\n-impl Div<BigUint, BigUint> for BigUint {\n-    #[inline]\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (q, _) = self.div_rem(other);\n-        return q;\n-    }\n-}\n-\n-impl Rem<BigUint, BigUint> for BigUint {\n-    #[inline]\n-    fn rem(&self, other: &BigUint) -> BigUint {\n-        let (_, r) = self.div_rem(other);\n-        return r;\n-    }\n-}\n-\n-impl Neg<BigUint> for BigUint {\n-    #[inline]\n-    fn neg(&self) -> BigUint { fail!() }\n-}\n-\n-impl CheckedAdd for BigUint {\n-    #[inline]\n-    fn checked_add(&self, v: &BigUint) -> Option<BigUint> {\n-        return Some(self.add(v));\n-    }\n-}\n-\n-impl CheckedSub for BigUint {\n-    #[inline]\n-    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {\n-        if *self < *v {\n-            return None;\n-        }\n-        return Some(self.sub(v));\n-    }\n-}\n-\n-impl CheckedMul for BigUint {\n-    #[inline]\n-    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {\n-        return Some(self.mul(v));\n-    }\n-}\n-\n-impl CheckedDiv for BigUint {\n-    #[inline]\n-    fn checked_div(&self, v: &BigUint) -> Option<BigUint> {\n-        if v.is_zero() {\n-            return None;\n-        }\n-        return Some(self.div(v));\n-    }\n-}\n-\n-impl Integer for BigUint {\n-    #[inline]\n-    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.div_mod_floor(other)\n-    }\n-\n-    #[inline]\n-    fn div_floor(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.div_mod_floor(other);\n-        return d;\n-    }\n-\n-    #[inline]\n-    fn mod_floor(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.div_mod_floor(other);\n-        return m;\n-    }\n-\n-    fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail!() }\n-        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n-        if *other == One::one() { return ((*self).clone(), Zero::zero()); }\n-\n-        match self.cmp(other) {\n-            Less    => return (Zero::zero(), (*self).clone()),\n-            Equal   => return (One::one(), Zero::zero()),\n-            Greater => {} // Do nothing\n-        }\n-\n-        let mut shift = 0;\n-        let mut n = *other.data.last().unwrap();\n-        while n < (1 << BigDigit::bits - 2) {\n-            n <<= 1;\n-            shift += 1;\n-        }\n-        assert!(shift < BigDigit::bits);\n-        let (d, m) = div_mod_floor_inner(self << shift, other << shift);\n-        return (d, m >> shift);\n-\n-\n-        fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n-            let mut m = a;\n-            let mut d: BigUint = Zero::zero();\n-            let mut n = 1;\n-            while m >= b {\n-                let (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n-                let mut d0 = d0;\n-                let mut prod = b * d0;\n-                while prod > m {\n-                    // FIXME(#5992): assignment operator overloads\n-                    // d0 -= d_unit\n-                    d0   = d0 - d_unit;\n-                    // FIXME(#5992): assignment operator overloads\n-                    // prod -= b_unit;\n-                    prod = prod - b_unit\n-                }\n-                if d0.is_zero() {\n-                    n = 2;\n-                    continue;\n-                }\n-                n = 1;\n-                // FIXME(#5992): assignment operator overloads\n-                // d += d0;\n-                d = d + d0;\n-                // FIXME(#5992): assignment operator overloads\n-                // m -= prod;\n-                m = m - prod;\n-            }\n-            return (d, m);\n-        }\n-\n-\n-        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n-            -> (BigUint, BigUint, BigUint) {\n-            if a.data.len() < n {\n-                return (Zero::zero(), Zero::zero(), (*a).clone());\n-            }\n-\n-            let an = a.data.tailn(a.data.len() - n);\n-            let bn = *b.data.last().unwrap();\n-            let mut d = Vec::with_capacity(an.len());\n-            let mut carry = 0;\n-            for elt in an.iter().rev() {\n-                let ai = BigDigit::to_doublebigdigit(carry, *elt);\n-                let di = ai / (bn as DoubleBigDigit);\n-                assert!(di < BigDigit::base);\n-                carry = (ai % (bn as DoubleBigDigit)) as BigDigit;\n-                d.push(di as BigDigit)\n-            }\n-            d.reverse();\n-\n-            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n-            if shift == 0 {\n-                return (BigUint::new(d), One::one(), (*b).clone());\n-            }\n-            let one: BigUint = One::one();\n-            return (BigUint::new(d).shl_unit(shift),\n-                    one.shl_unit(shift),\n-                    b.shl_unit(shift));\n-        }\n-    }\n-\n-    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.\n-    ///\n-    /// The result is always positive.\n-    #[inline]\n-    fn gcd(&self, other: &BigUint) -> BigUint {\n-        // Use Euclid's algorithm\n-        let mut m = (*self).clone();\n-        let mut n = (*other).clone();\n-        while !m.is_zero() {\n-            let temp = m;\n-            m = n % temp;\n-            n = temp;\n-        }\n-        return n;\n-    }\n-\n-    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-    #[inline]\n-    fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n-\n-    /// Deprecated, use `is_multiple_of` instead.\n-    #[deprecated = \"function renamed to `is_multiple_of`\"]\n-    #[inline]\n-    fn divides(&self, other: &BigUint) -> bool { return self.is_multiple_of(other); }\n-\n-    /// Returns `true` if the number is a multiple of `other`.\n-    #[inline]\n-    fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n-\n-    /// Returns `true` if the number is divisible by `2`.\n-    #[inline]\n-    fn is_even(&self) -> bool {\n-        // Considering only the last digit.\n-        match self.data.as_slice().head() {\n-            Some(x) => x.is_even(),\n-            None => true\n-        }\n-    }\n-\n-    /// Returns `true` if the number is not divisible by `2`.\n-    #[inline]\n-    fn is_odd(&self) -> bool { !self.is_even() }\n-}\n-\n-impl ToPrimitive for BigUint {\n-    #[inline]\n-    fn to_i64(&self) -> Option<i64> {\n-        self.to_u64().and_then(|n| {\n-            // If top bit of u64 is set, it's too large to convert to i64.\n-            if n >> 63 == 0 {\n-                Some(n as i64)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64> {\n-        match self.data.len() {\n-            0 => Some(0),\n-            1 => Some(self.data.as_slice()[0] as u64),\n-            2 => Some(BigDigit::to_doublebigdigit(self.data.as_slice()[1], self.data.as_slice()[0])\n-                      as u64),\n-            _ => None\n-        }\n-    }\n-}\n-\n-impl FromPrimitive for BigUint {\n-    #[inline]\n-    fn from_i64(n: i64) -> Option<BigUint> {\n-        if n > 0 {\n-            FromPrimitive::from_u64(n as u64)\n-        } else if n == 0 {\n-            Some(Zero::zero())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[inline]\n-    fn from_u64(n: u64) -> Option<BigUint> {\n-        let n = match BigDigit::from_doublebigdigit(n) {\n-            (0,  0)  => Zero::zero(),\n-            (0,  n0) => BigUint::new(vec!(n0)),\n-            (n1, n0) => BigUint::new(vec!(n0, n1))\n-        };\n-        Some(n)\n-    }\n-}\n-\n-/// A generic trait for converting a value to a `BigUint`.\n-pub trait ToBigUint {\n-    /// Converts the value of `self` to a `BigUint`.\n-    fn to_biguint(&self) -> Option<BigUint>;\n-}\n-\n-impl ToBigUint for BigInt {\n-    #[inline]\n-    fn to_biguint(&self) -> Option<BigUint> {\n-        if self.sign == Plus {\n-            Some(self.data.clone())\n-        } else if self.sign == NoSign {\n-            Some(Zero::zero())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl ToBigUint for BigUint {\n-    #[inline]\n-    fn to_biguint(&self) -> Option<BigUint> {\n-        Some(self.clone())\n-    }\n-}\n-\n-macro_rules! impl_to_biguint(\n-    ($T:ty, $from_ty:path) => {\n-        impl ToBigUint for $T {\n-            #[inline]\n-            fn to_biguint(&self) -> Option<BigUint> {\n-                $from_ty(*self)\n-            }\n-        }\n-    }\n-)\n-\n-impl_to_biguint!(int,  FromPrimitive::from_int)\n-impl_to_biguint!(i8,   FromPrimitive::from_i8)\n-impl_to_biguint!(i16,  FromPrimitive::from_i16)\n-impl_to_biguint!(i32,  FromPrimitive::from_i32)\n-impl_to_biguint!(i64,  FromPrimitive::from_i64)\n-impl_to_biguint!(uint, FromPrimitive::from_uint)\n-impl_to_biguint!(u8,   FromPrimitive::from_u8)\n-impl_to_biguint!(u16,  FromPrimitive::from_u16)\n-impl_to_biguint!(u32,  FromPrimitive::from_u32)\n-impl_to_biguint!(u64,  FromPrimitive::from_u64)\n-\n-impl ToStrRadix for BigUint {\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        assert!(1 < radix && radix <= 16, \"The radix must be within (1, 16]\");\n-        let (base, max_len) = get_radix_base(radix);\n-        if base == BigDigit::base {\n-            return fill_concat(self.data.as_slice(), radix, max_len)\n-        }\n-        return fill_concat(convert_base(self, base).as_slice(), radix, max_len);\n-\n-        fn convert_base(n: &BigUint, base: DoubleBigDigit) -> Vec<BigDigit> {\n-            let divider    = base.to_biguint().unwrap();\n-            let mut result = Vec::new();\n-            let mut m      = n.clone();\n-            while m >= divider {\n-                let (d, m0) = m.div_mod_floor(&divider);\n-                result.push(m0.to_uint().unwrap() as BigDigit);\n-                m = d;\n-            }\n-            if !m.is_zero() {\n-                result.push(m.to_uint().unwrap() as BigDigit);\n-            }\n-            return result;\n-        }\n-\n-        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> String {\n-            if v.is_empty() {\n-                return \"0\".to_string()\n-            }\n-            let mut s = String::with_capacity(v.len() * l);\n-            for n in v.iter().rev() {\n-                let ss = (*n as uint).to_str_radix(radix);\n-                s.push_str(\"0\".repeat(l - ss.len()).as_slice());\n-                s.push_str(ss.as_slice());\n-            }\n-            s.as_slice().trim_left_chars('0').to_string()\n-        }\n-    }\n-}\n-\n-impl FromStrRadix for BigUint {\n-    /// Creates and initializes a `BigUint`.\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<BigUint> {\n-        BigUint::parse_bytes(s.as_bytes(), radix)\n-    }\n-}\n-\n-impl BigUint {\n-    /// Creates and initializes a `BigUint`.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn new(mut digits: Vec<BigDigit>) -> BigUint {\n-        // omit trailing zeros\n-        let new_len = digits.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n-        digits.truncate(new_len);\n-        BigUint { data: digits }\n-    }\n-\n-    /// Creates and initializes a `BigUint`.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        BigUint::new(Vec::from_slice(slice))\n-    }\n-\n-    /// Creates and initializes a `BigUint`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> {\n-        let (base, unit_len) = get_radix_base(radix);\n-        let base_num = match base.to_biguint() {\n-            Some(base_num) => base_num,\n-            None => { return None; }\n-        };\n-\n-        let mut end             = buf.len();\n-        let mut n: BigUint      = Zero::zero();\n-        let mut power: BigUint  = One::one();\n-        loop {\n-            let start = cmp::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(buf[start..end], radix) {\n-                Some(d) => {\n-                    let d: Option<BigUint> = FromPrimitive::from_uint(d);\n-                    match d {\n-                        Some(d) => {\n-                            // FIXME(#5992): assignment operator overloads\n-                            // n += d * power;\n-                            n = n + d * power;\n-                        }\n-                        None => { return None; }\n-                    }\n-                }\n-                None => { return None; }\n-            }\n-            if end <= unit_len {\n-                return Some(n);\n-            }\n-            end -= unit_len;\n-            // FIXME(#5992): assignment operator overloads\n-            // power *= base_num;\n-            power = power * base_num;\n-        }\n-    }\n-\n-    #[inline]\n-    fn shl_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n-\n-        BigUint::new(Vec::from_elem(n_unit, ZERO_BIG_DIGIT).append(self.data.as_slice()))\n-    }\n-\n-    #[inline]\n-    fn shl_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n-\n-        let mut carry = 0;\n-        let mut shifted: Vec<BigDigit> = self.data.iter().map(|elem| {\n-            let (hi, lo) = BigDigit::from_doublebigdigit(\n-                (*elem as DoubleBigDigit) << n_bits | (carry as DoubleBigDigit)\n-            );\n-            carry = hi;\n-            lo\n-        }).collect();\n-        if carry != 0 { shifted.push(carry); }\n-        return BigUint::new(shifted);\n-    }\n-\n-    #[inline]\n-    fn shr_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return (*self).clone(); }\n-        if self.data.len() < n_unit { return Zero::zero(); }\n-        return BigUint::from_slice(\n-            self.data.slice(n_unit, self.data.len())\n-        );\n-    }\n-\n-    #[inline]\n-    fn shr_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n-\n-        let mut borrow = 0;\n-        let mut shifted_rev = Vec::with_capacity(self.data.len());\n-        for elem in self.data.iter().rev() {\n-            shifted_rev.push((*elem >> n_bits) | borrow);\n-            borrow = *elem << (BigDigit::bits - n_bits);\n-        }\n-        let shifted = { shifted_rev.reverse(); shifted_rev };\n-        return BigUint::new(shifted);\n-    }\n-\n-    /// Determines the fewest bits necessary to express the `BigUint`.\n-    pub fn bits(&self) -> uint {\n-        if self.is_zero() { return 0; }\n-        let zeros = self.data.last().unwrap().leading_zeros();\n-        return self.data.len()*BigDigit::bits - zeros;\n-    }\n-}\n-\n-// `DoubleBigDigit` size dependent\n-#[inline]\n-fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n-    match radix {\n-        2  => (4294967296, 32),\n-        3  => (3486784401, 20),\n-        4  => (4294967296, 16),\n-        5  => (1220703125, 13),\n-        6  => (2176782336, 12),\n-        7  => (1977326743, 11),\n-        8  => (1073741824, 10),\n-        9  => (3486784401, 10),\n-        10 => (1000000000, 9),\n-        11 => (2357947691, 9),\n-        12 => (429981696,  8),\n-        13 => (815730721,  8),\n-        14 => (1475789056, 8),\n-        15 => (2562890625, 8),\n-        16 => (4294967296, 8),\n-        _  => fail!(\"The radix must be within (1, 16]\")\n-    }\n-}\n-\n-/// A Sign is a `BigInt`'s composing element.\n-#[deriving(PartialEq, PartialOrd, Eq, Ord, Clone, Show)]\n-pub enum Sign { Minus, NoSign, Plus }\n-\n-impl Neg<Sign> for Sign {\n-    /// Negate Sign value.\n-    #[inline]\n-    fn neg(&self) -> Sign {\n-        match *self {\n-          Minus => Plus,\n-          NoSign  => NoSign,\n-          Plus  => Minus\n-        }\n-    }\n-}\n-\n-/// A big signed integer type.\n-#[deriving(Clone)]\n-pub struct BigInt {\n-    sign: Sign,\n-    data: BigUint\n-}\n-\n-impl PartialEq for BigInt {\n-    #[inline]\n-    fn eq(&self, other: &BigInt) -> bool {\n-        self.cmp(other) == Equal\n-    }\n-}\n-\n-impl Eq for BigInt {}\n-\n-impl PartialOrd for BigInt {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for BigInt {\n-    #[inline]\n-    fn cmp(&self, other: &BigInt) -> Ordering {\n-        let scmp = self.sign.cmp(&other.sign);\n-        if scmp != Equal { return scmp; }\n-\n-        match self.sign {\n-            NoSign  => Equal,\n-            Plus  => self.data.cmp(&other.data),\n-            Minus => other.data.cmp(&self.data),\n-        }\n-    }\n-}\n-\n-impl Default for BigInt {\n-    #[inline]\n-    fn default() -> BigInt { Zero::zero() }\n-}\n-\n-impl fmt::Show for BigInt {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_str_radix(10))\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for BigInt {\n-    fn hash(&self, state: &mut S) {\n-        (self.sign == Plus).hash(state);\n-        self.data.hash(state);\n-    }\n-}\n-\n-impl FromStr for BigInt {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<BigInt> {\n-        FromStrRadix::from_str_radix(s, 10)\n-    }\n-}\n-\n-impl Num for BigInt {}\n-\n-impl Shl<uint, BigInt> for BigInt {\n-    #[inline]\n-    fn shl(&self, rhs: &uint) -> BigInt {\n-        BigInt::from_biguint(self.sign, self.data << *rhs)\n-    }\n-}\n-\n-impl Shr<uint, BigInt> for BigInt {\n-    #[inline]\n-    fn shr(&self, rhs: &uint) -> BigInt {\n-        BigInt::from_biguint(self.sign, self.data >> *rhs)\n-    }\n-}\n-\n-impl Zero for BigInt {\n-    #[inline]\n-    fn zero() -> BigInt {\n-        BigInt::from_biguint(NoSign, Zero::zero())\n-    }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { self.sign == NoSign }\n-}\n-\n-impl One for BigInt {\n-    #[inline]\n-    fn one() -> BigInt {\n-        BigInt::from_biguint(Plus, One::one())\n-    }\n-}\n-\n-impl Signed for BigInt {\n-    #[inline]\n-    fn abs(&self) -> BigInt {\n-        match self.sign {\n-            Plus | NoSign => self.clone(),\n-            Minus => BigInt::from_biguint(Plus, self.data.clone())\n-        }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(&self, other: &BigInt) -> BigInt {\n-        if *self <= *other { Zero::zero() } else { *self - *other }\n-    }\n-\n-    #[inline]\n-    fn signum(&self) -> BigInt {\n-        match self.sign {\n-            Plus  => BigInt::from_biguint(Plus, One::one()),\n-            Minus => BigInt::from_biguint(Minus, One::one()),\n-            NoSign  => Zero::zero(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_positive(&self) -> bool { self.sign == Plus }\n-\n-    #[inline]\n-    fn is_negative(&self) -> bool { self.sign == Minus }\n-}\n-\n-impl Add<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn add(&self, other: &BigInt) -> BigInt {\n-        match (self.sign, other.sign) {\n-            (NoSign, _)      => other.clone(),\n-            (_,    NoSign)   => self.clone(),\n-            (Plus, Plus)   => BigInt::from_biguint(Plus, self.data + other.data),\n-            (Plus, Minus)  => self - (-*other),\n-            (Minus, Plus)  => other - (-*self),\n-            (Minus, Minus) => -((-self) + (-*other))\n-        }\n-    }\n-}\n-\n-impl Sub<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn sub(&self, other: &BigInt) -> BigInt {\n-        match (self.sign, other.sign) {\n-            (NoSign, _)    => -other,\n-            (_,    NoSign) => self.clone(),\n-            (Plus, Plus) => match self.data.cmp(&other.data) {\n-                Less    => BigInt::from_biguint(Minus, other.data - self.data),\n-                Greater => BigInt::from_biguint(Plus, self.data - other.data),\n-                Equal   => Zero::zero()\n-            },\n-            (Plus, Minus) => self + (-*other),\n-            (Minus, Plus) => -((-self) + *other),\n-            (Minus, Minus) => (-other) - (-*self)\n-        }\n-    }\n-}\n-\n-impl Mul<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn mul(&self, other: &BigInt) -> BigInt {\n-        match (self.sign, other.sign) {\n-            (NoSign, _)     | (_,     NoSign)  => Zero::zero(),\n-            (Plus, Plus)  | (Minus, Minus) => {\n-                BigInt::from_biguint(Plus, self.data * other.data)\n-            },\n-            (Plus, Minus) | (Minus, Plus) => {\n-                BigInt::from_biguint(Minus, self.data * other.data)\n-            }\n-        }\n-    }\n-}\n-\n-impl Div<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (q, _) = self.div_rem(other);\n-        q\n-    }\n-}\n-\n-impl Rem<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn rem(&self, other: &BigInt) -> BigInt {\n-        let (_, r) = self.div_rem(other);\n-        r\n-    }\n-}\n-\n-impl Neg<BigInt> for BigInt {\n-    #[inline]\n-    fn neg(&self) -> BigInt {\n-        BigInt::from_biguint(self.sign.neg(), self.data.clone())\n-    }\n-}\n-\n-impl CheckedAdd for BigInt {\n-    #[inline]\n-    fn checked_add(&self, v: &BigInt) -> Option<BigInt> {\n-        return Some(self.add(v));\n-    }\n-}\n-\n-impl CheckedSub for BigInt {\n-    #[inline]\n-    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {\n-        return Some(self.sub(v));\n-    }\n-}\n-\n-impl CheckedMul for BigInt {\n-    #[inline]\n-    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {\n-        return Some(self.mul(v));\n-    }\n-}\n-\n-impl CheckedDiv for BigInt {\n-    #[inline]\n-    fn checked_div(&self, v: &BigInt) -> Option<BigInt> {\n-        if v.is_zero() {\n-            return None;\n-        }\n-        return Some(self.div(v));\n-    }\n-}\n-\n-\n-impl Integer for BigInt {\n-    #[inline]\n-    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // r.sign == self.sign\n-        let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui);\n-        let r = BigInt::from_biguint(Plus, r_ui);\n-        match (self.sign, other.sign) {\n-            (_,    NoSign)   => fail!(),\n-            (Plus, Plus)  | (NoSign, Plus)  => ( d,  r),\n-            (Plus, Minus) | (NoSign, Minus) => (-d,  r),\n-            (Minus, Plus)                 => (-d, -r),\n-            (Minus, Minus)                => ( d, -r)\n-        }\n-    }\n-\n-    #[inline]\n-    fn div_floor(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.div_mod_floor(other);\n-        d\n-    }\n-\n-    #[inline]\n-    fn mod_floor(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.div_mod_floor(other);\n-        m\n-    }\n-\n-    fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.div_rem(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui);\n-        let m = BigInt::from_biguint(Plus, m_ui);\n-        match (self.sign, other.sign) {\n-            (_,    NoSign)   => fail!(),\n-            (Plus, Plus)  | (NoSign, Plus)  => (d, m),\n-            (Plus, Minus) | (NoSign, Minus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), m + *other)\n-            },\n-            (Minus, Plus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), other - m)\n-            },\n-            (Minus, Minus) => (d, -m)\n-        }\n-    }\n-\n-    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.\n-    ///\n-    /// The result is always positive.\n-    #[inline]\n-    fn gcd(&self, other: &BigInt) -> BigInt {\n-        BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n-    }\n-\n-    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-    #[inline]\n-    fn lcm(&self, other: &BigInt) -> BigInt {\n-        BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n-    }\n-\n-    /// Deprecated, use `is_multiple_of` instead.\n-    #[deprecated = \"function renamed to `is_multiple_of`\"]\n-    #[inline]\n-    fn divides(&self, other: &BigInt) -> bool { return self.is_multiple_of(other); }\n-\n-    /// Returns `true` if the number is a multiple of `other`.\n-    #[inline]\n-    fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n-\n-    /// Returns `true` if the number is divisible by `2`.\n-    #[inline]\n-    fn is_even(&self) -> bool { self.data.is_even() }\n-\n-    /// Returns `true` if the number is not divisible by `2`.\n-    #[inline]\n-    fn is_odd(&self) -> bool { self.data.is_odd() }\n-}\n-\n-impl ToPrimitive for BigInt {\n-    #[inline]\n-    fn to_i64(&self) -> Option<i64> {\n-        match self.sign {\n-            Plus  => self.data.to_i64(),\n-            NoSign  => Some(0),\n-            Minus => {\n-                self.data.to_u64().and_then(|n| {\n-                    let m: u64 = 1 << 63;\n-                    if n < m {\n-                        Some(-(n as i64))\n-                    } else if n == m {\n-                        Some(i64::MIN)\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64> {\n-        match self.sign {\n-            Plus => self.data.to_u64(),\n-            NoSign => Some(0),\n-            Minus => None\n-        }\n-    }\n-}\n-\n-impl FromPrimitive for BigInt {\n-    #[inline]\n-    fn from_i64(n: i64) -> Option<BigInt> {\n-        if n > 0 {\n-            FromPrimitive::from_u64(n as u64).and_then(|n| {\n-                Some(BigInt::from_biguint(Plus, n))\n-            })\n-        } else if n < 0 {\n-            FromPrimitive::from_u64(u64::MAX - (n as u64) + 1).and_then(\n-                |n| {\n-                    Some(BigInt::from_biguint(Minus, n))\n-                })\n-        } else {\n-            Some(Zero::zero())\n-        }\n-    }\n-\n-    #[inline]\n-    fn from_u64(n: u64) -> Option<BigInt> {\n-        if n == 0 {\n-            Some(Zero::zero())\n-        } else {\n-            FromPrimitive::from_u64(n).and_then(|n| {\n-                Some(BigInt::from_biguint(Plus, n))\n-            })\n-        }\n-    }\n-}\n-\n-/// A generic trait for converting a value to a `BigInt`.\n-pub trait ToBigInt {\n-    /// Converts the value of `self` to a `BigInt`.\n-    fn to_bigint(&self) -> Option<BigInt>;\n-}\n-\n-impl ToBigInt for BigInt {\n-    #[inline]\n-    fn to_bigint(&self) -> Option<BigInt> {\n-        Some(self.clone())\n-    }\n-}\n-\n-impl ToBigInt for BigUint {\n-    #[inline]\n-    fn to_bigint(&self) -> Option<BigInt> {\n-        if self.is_zero() {\n-            Some(Zero::zero())\n-        } else {\n-            Some(BigInt { sign: Plus, data: self.clone() })\n-        }\n-    }\n-}\n-\n-macro_rules! impl_to_bigint(\n-    ($T:ty, $from_ty:path) => {\n-        impl ToBigInt for $T {\n-            #[inline]\n-            fn to_bigint(&self) -> Option<BigInt> {\n-                $from_ty(*self)\n-            }\n-        }\n-    }\n-)\n-\n-impl_to_bigint!(int,  FromPrimitive::from_int)\n-impl_to_bigint!(i8,   FromPrimitive::from_i8)\n-impl_to_bigint!(i16,  FromPrimitive::from_i16)\n-impl_to_bigint!(i32,  FromPrimitive::from_i32)\n-impl_to_bigint!(i64,  FromPrimitive::from_i64)\n-impl_to_bigint!(uint, FromPrimitive::from_uint)\n-impl_to_bigint!(u8,   FromPrimitive::from_u8)\n-impl_to_bigint!(u16,  FromPrimitive::from_u16)\n-impl_to_bigint!(u32,  FromPrimitive::from_u32)\n-impl_to_bigint!(u64,  FromPrimitive::from_u64)\n-\n-impl ToStrRadix for BigInt {\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        match self.sign {\n-            Plus  => self.data.to_str_radix(radix),\n-            NoSign  => \"0\".to_string(),\n-            Minus => format!(\"-{}\", self.data.to_str_radix(radix)),\n-        }\n-    }\n-}\n-\n-impl FromStrRadix for BigInt {\n-    /// Creates and initializes a BigInt.\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<BigInt> {\n-        BigInt::parse_bytes(s.as_bytes(), radix)\n-    }\n-}\n-\n-pub trait RandBigInt {\n-    /// Generate a random `BigUint` of the given bit size.\n-    fn gen_biguint(&mut self, bit_size: uint) -> BigUint;\n-\n-    /// Generate a random BigInt of the given bit size.\n-    fn gen_bigint(&mut self, bit_size: uint) -> BigInt;\n-\n-    /// Generate a random `BigUint` less than the given bound. Fails\n-    /// when the bound is zero.\n-    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;\n-\n-    /// Generate a random `BigUint` within the given range. The lower\n-    /// bound is inclusive; the upper bound is exclusive. Fails when\n-    /// the upper bound is not greater than the lower bound.\n-    fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;\n-\n-    /// Generate a random `BigInt` within the given range. The lower\n-    /// bound is inclusive; the upper bound is exclusive. Fails when\n-    /// the upper bound is not greater than the lower bound.\n-    fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;\n-}\n-\n-impl<R: Rng> RandBigInt for R {\n-    fn gen_biguint(&mut self, bit_size: uint) -> BigUint {\n-        let (digits, rem) = bit_size.div_rem(&BigDigit::bits);\n-        let mut data = Vec::with_capacity(digits+1);\n-        for _ in range(0, digits) {\n-            data.push(self.gen());\n-        }\n-        if rem > 0 {\n-            let final_digit: BigDigit = self.gen();\n-            data.push(final_digit >> (BigDigit::bits - rem));\n-        }\n-        BigUint::new(data)\n-    }\n-\n-    fn gen_bigint(&mut self, bit_size: uint) -> BigInt {\n-        // Generate a random BigUint...\n-        let biguint = self.gen_biguint(bit_size);\n-        // ...and then randomly assign it a Sign...\n-        let sign = if biguint.is_zero() {\n-            // ...except that if the BigUint is zero, we need to try\n-            // again with probability 0.5. This is because otherwise,\n-            // the probability of generating a zero BigInt would be\n-            // double that of any other number.\n-            if self.gen() {\n-                return self.gen_bigint(bit_size);\n-            } else {\n-                NoSign\n-            }\n-        } else if self.gen() {\n-            Plus\n-        } else {\n-            Minus\n-        };\n-        BigInt::from_biguint(sign, biguint)\n-    }\n-\n-    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {\n-        assert!(!bound.is_zero());\n-        let bits = bound.bits();\n-        loop {\n-            let n = self.gen_biguint(bits);\n-            if n < *bound { return n; }\n-        }\n-    }\n-\n-    fn gen_biguint_range(&mut self,\n-                         lbound: &BigUint,\n-                         ubound: &BigUint)\n-                         -> BigUint {\n-        assert!(*lbound < *ubound);\n-        return *lbound + self.gen_biguint_below(&(*ubound - *lbound));\n-    }\n-\n-    fn gen_bigint_range(&mut self,\n-                        lbound: &BigInt,\n-                        ubound: &BigInt)\n-                        -> BigInt {\n-        assert!(*lbound < *ubound);\n-        let delta = (*ubound - *lbound).to_biguint().unwrap();\n-        return *lbound + self.gen_biguint_below(&delta).to_bigint().unwrap();\n-    }\n-}\n-\n-impl BigInt {\n-    /// Creates and initializes a BigInt.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn new(sign: Sign, digits: Vec<BigDigit>) -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::new(digits))\n-    }\n-\n-    /// Creates and initializes a `BigInt`.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n-        if sign == NoSign || data.is_zero() {\n-            return BigInt { sign: NoSign, data: Zero::zero() };\n-        }\n-        BigInt { sign: sign, data: data }\n-    }\n-\n-    /// Creates and initializes a `BigInt`.\n-    #[inline]\n-    pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::from_slice(slice))\n-    }\n-\n-    /// Creates and initializes a `BigInt`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigInt> {\n-        if buf.is_empty() { return None; }\n-        let mut sign  = Plus;\n-        let mut start = 0;\n-        if buf[0] == b'-' {\n-            sign  = Minus;\n-            start = 1;\n-        }\n-        return BigUint::parse_bytes(buf[start..], radix)\n-            .map(|bu| BigInt::from_biguint(sign, bu));\n-    }\n-\n-    /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n-    #[inline]\n-    pub fn to_biguint(&self) -> Option<BigUint> {\n-        match self.sign {\n-            Plus => Some(self.data.clone()),\n-            NoSign => Some(Zero::zero()),\n-            Minus => None\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod biguint_tests {\n-    use Integer;\n-    use super::{BigDigit, BigUint, ToBigUint};\n-    use super::{Plus, BigInt, RandBigInt, ToBigInt};\n-\n-    use std::cmp::{Less, Equal, Greater};\n-    use std::from_str::FromStr;\n-    use std::i64;\n-    use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n-    use std::num::{ToPrimitive, FromPrimitive};\n-    use std::num::CheckedDiv;\n-    use std::rand::task_rng;\n-    use std::u64;\n-    use std::hash::hash;\n-\n-    #[test]\n-    fn test_from_slice() {\n-        fn check(slice: &[BigDigit], data: &[BigDigit]) {\n-            assert!(data == BigUint::from_slice(slice).data.as_slice());\n-        }\n-        check([1], [1]);\n-        check([0, 0, 0], []);\n-        check([1, 2, 0, 0], [1, 2]);\n-        check([0, 0, 1, 2], [0, 0, 1, 2]);\n-        check([0, 0, 1, 2, 0, 0], [0, 0, 1, 2]);\n-        check([-1], [-1]);\n-    }\n-\n-    #[test]\n-    fn test_cmp() {\n-        let data: [&[_], ..7] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ];\n-        let data: Vec<BigUint> = data.iter().map(|v| BigUint::from_slice(*v)).collect();\n-        for (i, ni) in data.iter().enumerate() {\n-            for (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n-                let j = j0 + i;\n-                if i == j {\n-                    assert_eq!(ni.cmp(nj), Equal);\n-                    assert_eq!(nj.cmp(ni), Equal);\n-                    assert_eq!(ni, nj);\n-                    assert!(!(ni != nj));\n-                    assert!(ni <= nj);\n-                    assert!(ni >= nj);\n-                    assert!(!(ni < nj));\n-                    assert!(!(ni > nj));\n-                } else {\n-                    assert_eq!(ni.cmp(nj), Less);\n-                    assert_eq!(nj.cmp(ni), Greater);\n-\n-                    assert!(!(ni == nj));\n-                    assert!(ni != nj);\n-\n-                    assert!(ni <= nj);\n-                    assert!(!(ni >= nj));\n-                    assert!(ni < nj);\n-                    assert!(!(ni > nj));\n-\n-                    assert!(!(nj <= ni));\n-                    assert!(nj >= ni);\n-                    assert!(!(nj < ni));\n-                    assert!(nj > ni);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let a = BigUint::new(vec!());\n-        let b = BigUint::new(vec!(0));\n-        let c = BigUint::new(vec!(1));\n-        let d = BigUint::new(vec!(1,0,0,0,0,0));\n-        let e = BigUint::new(vec!(0,0,0,0,0,1));\n-        assert!(hash(&a) == hash(&b));\n-        assert!(hash(&b) != hash(&c));\n-        assert!(hash(&c) == hash(&d));\n-        assert!(hash(&d) != hash(&e));\n-    }\n-\n-    #[test]\n-    fn test_bitand() {\n-        fn check(left: &[BigDigit],\n-                 right: &[BigDigit],\n-                 expected: &[BigDigit]) {\n-            assert_eq!(BigUint::from_slice(left) & BigUint::from_slice(right),\n-                       BigUint::from_slice(expected));\n-        }\n-        check([], [], []);\n-        check([268, 482, 17],\n-              [964, 54],\n-              [260, 34]);\n-    }\n-\n-    #[test]\n-    fn test_bitor() {\n-        fn check(left: &[BigDigit],\n-                 right: &[BigDigit],\n-                 expected: &[BigDigit]) {\n-            assert_eq!(BigUint::from_slice(left) | BigUint::from_slice(right),\n-                       BigUint::from_slice(expected));\n-        }\n-        check([], [], []);\n-        check([268, 482, 17],\n-              [964, 54],\n-              [972, 502, 17]);\n-    }\n-\n-    #[test]\n-    fn test_bitxor() {\n-        fn check(left: &[BigDigit],\n-                 right: &[BigDigit],\n-                 expected: &[BigDigit]) {\n-            assert_eq!(BigUint::from_slice(left) ^ BigUint::from_slice(right),\n-                       BigUint::from_slice(expected));\n-        }\n-        check([], [], []);\n-        check([268, 482, 17],\n-              [964, 54],\n-              [712, 468, 17]);\n-    }\n-\n-    #[test]\n-    fn test_shl() {\n-        fn check(s: &str, shift: uint, ans: &str) {\n-            let opt_biguint: Option<BigUint> = FromStrRadix::from_str_radix(s, 16);\n-            let bu = (opt_biguint.unwrap() << shift).to_str_radix(16);\n-            assert_eq!(bu.as_slice(), ans);\n-        }\n-\n-        check(\"0\", 3, \"0\");\n-        check(\"1\", 3, \"8\");\n-\n-        check(\"1\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0001\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0001\",\n-              3,\n-              \"8\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0008\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0008\");\n-        check(\"1\\\n-               0000\\\n-               0001\\\n-               0000\\\n-               0001\",\n-              2,\n-              \"4\\\n-               0000\\\n-               0004\\\n-               0000\\\n-               0004\");\n-        check(\"1\\\n-               0001\\\n-               0001\",\n-              1,\n-              \"2\\\n-               0002\\\n-               0002\");\n-\n-        check(\"\\\n-              4000\\\n-              0000\\\n-              0000\\\n-              0000\",\n-              3,\n-              \"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"4000\\\n-              0000\",\n-              2,\n-              \"1\\\n-              0000\\\n-              0000\");\n-        check(\"4000\",\n-              2,\n-              \"1\\\n-              0000\");\n-\n-        check(\"4000\\\n-              0000\\\n-              0000\\\n-              0000\",\n-              67,\n-              \"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"4000\\\n-              0000\",\n-              35,\n-              \"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"4000\",\n-              19,\n-              \"2\\\n-              0000\\\n-              0000\");\n-\n-        check(\"fedc\\\n-              ba98\\\n-              7654\\\n-              3210\\\n-              fedc\\\n-              ba98\\\n-              7654\\\n-              3210\",\n-              4,\n-              \"f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              210f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              2100\");\n-        check(\"88887777666655554444333322221111\", 16,\n-              \"888877776666555544443333222211110000\");\n-    }\n-\n-    #[test]\n-    fn test_shr() {\n-        fn check(s: &str, shift: uint, ans: &str) {\n-            let opt_biguint: Option<BigUint> =\n-                FromStrRadix::from_str_radix(s, 16);\n-            let bu = (opt_biguint.unwrap() >> shift).to_str_radix(16);\n-            assert_eq!(bu.as_slice(), ans);\n-        }\n-\n-        check(\"0\", 3, \"0\");\n-        check(\"f\", 3, \"1\");\n-\n-        check(\"1\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\",\n-              3,\n-              \"2000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              2000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"1\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0001\",\n-              2,\n-              \"4000\\\n-              0000\\\n-              4000\\\n-              0000\");\n-        check(\"1\\\n-              0001\\\n-              0001\",\n-              1,\n-              \"8000\\\n-              8000\");\n-\n-        check(\"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\",\n-              67,\n-              \"4000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"2\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0001\",\n-              35,\n-              \"4000\\\n-              0000\");\n-        check(\"2\\\n-              0001\\\n-              0001\",\n-              19,\n-              \"4000\");\n-\n-        check(\"1\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\",\n-              1,\n-              \"8000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"1\\\n-              0000\\\n-              0000\",\n-              1,\n-              \"8000\\\n-              0000\");\n-        check(\"1\\\n-              0000\",\n-              1,\n-              \"8000\");\n-        check(\"f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              210f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              2100\",\n-              4,\n-              \"fedc\\\n-              ba98\\\n-              7654\\\n-              3210\\\n-              fedc\\\n-              ba98\\\n-              7654\\\n-              3210\");\n-\n-        check(\"888877776666555544443333222211110000\", 16,\n-              \"88887777666655554444333322221111\");\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[test]\n-    fn test_convert_i64() {\n-        fn check(b1: BigUint, i: i64) {\n-            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_i64().unwrap() == i);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n-\n-        check(BigUint::new(vec!(           )), 0);\n-        check(BigUint::new(vec!( 1         )), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1         )), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  1     )), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1 >> 1)), i64::MAX);\n-\n-        assert_eq!(i64::MIN.to_biguint(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1    )).to_i64(), None);\n-        assert_eq!(BigUint::new(vec!( 0,  0,  1)).to_i64(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_i64(), None);\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[test]\n-    fn test_convert_u64() {\n-        fn check(b1: BigUint, u: u64) {\n-            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_u64().unwrap() == u);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n-        check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n-\n-        check(BigUint::new(vec!(      )), 0);\n-        check(BigUint::new(vec!( 1    )), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1    )), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  1)), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1)), u64::MAX);\n-\n-        assert_eq!(BigUint::new(vec!( 0,  0,  1)).to_u64(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_u64(), None);\n-    }\n-\n-    #[test]\n-    fn test_convert_to_bigint() {\n-        fn check(n: BigUint, ans: BigInt) {\n-            assert_eq!(n.to_bigint().unwrap(), ans);\n-            assert_eq!(n.to_bigint().unwrap().to_biguint().unwrap(), n);\n-        }\n-        check(Zero::zero(), Zero::zero());\n-        check(BigUint::new(vec!(1,2,3)),\n-              BigInt::from_biguint(Plus, BigUint::new(vec!(1,2,3))));\n-    }\n-\n-    static SUM_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],          &[],       &[]),\n-        (&[],          &[ 1],     &[ 1]),\n-        (&[ 1],        &[ 1],     &[ 2]),\n-        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n-        (&[ 1],        &[-1],     &[ 0,  1]),\n-        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n-        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n-        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n-        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n-    ];\n-\n-    #[test]\n-    fn test_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a + b == c);\n-            assert!(b + a == c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(c - a == b);\n-            assert!(c - b == a);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_sub_fail_on_underflow() {\n-        let (a, b) : (BigUint, BigUint) = (Zero::zero(), One::one());\n-        a - b;\n-    }\n-\n-    static MUL_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],               &[],               &[]),\n-        (&[],               &[ 1],             &[]),\n-        (&[ 2],             &[],               &[]),\n-        (&[ 1],             &[ 1],             &[1]),\n-        (&[ 2],             &[ 3],             &[ 6]),\n-        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n-        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n-        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n-        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n-        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n-        (&[-1],             &[-1],             &[ 1, -2]),\n-        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n-        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n-        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n-        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n-        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n-        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n-        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n-        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n-        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n-        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n-    ];\n-\n-    static DIV_REM_QUADRUPLES: &'static [(&'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit])]\n-        = &[\n-            (&[ 1],        &[ 2], &[],               &[1]),\n-            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n-            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n-            (&[ 0,  1],    &[-1], &[1],              &[1]),\n-            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n-        ];\n-\n-    #[test]\n-    fn test_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a * b == c);\n-            assert!(b * a == c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-            let d = BigUint::from_slice(d_vec);\n-\n-            assert!(a == b * c + d);\n-            assert!(a == c * b + d);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_div_rem() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            if !a.is_zero() {\n-                assert_eq!(c.div_rem(&a), (b.clone(), Zero::zero()));\n-            }\n-            if !b.is_zero() {\n-                assert_eq!(c.div_rem(&b), (a.clone(), Zero::zero()));\n-            }\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-            let d = BigUint::from_slice(d_vec);\n-\n-            if !b.is_zero() { assert!(a.div_rem(&b) == (c, d)); }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a.checked_add(&b).unwrap() == c);\n-            assert!(b.checked_add(&a).unwrap() == c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(c.checked_sub(&a).unwrap() == b);\n-            assert!(c.checked_sub(&b).unwrap() == a);\n-\n-            if a > c {\n-                assert!(a.checked_sub(&c).is_none());\n-            }\n-            if b > c {\n-                assert!(b.checked_sub(&c).is_none());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a.checked_mul(&b).unwrap() == c);\n-            assert!(b.checked_mul(&a).unwrap() == c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-            let d = BigUint::from_slice(d_vec);\n-\n-            assert!(a == b.checked_mul(&c).unwrap() + d);\n-            assert!(a == c.checked_mul(&b).unwrap() + d);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_div() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            if !a.is_zero() {\n-                assert!(c.checked_div(&a).unwrap() == b);\n-            }\n-            if !b.is_zero() {\n-                assert!(c.checked_div(&b).unwrap() == a);\n-            }\n-\n-            assert!(c.checked_div(&Zero::zero()).is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gcd() {\n-        fn check(a: uint, b: uint, c: uint) {\n-            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n-            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n-            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n-\n-            assert_eq!(big_a.gcd(&big_b), big_c);\n-        }\n-\n-        check(10, 2, 2);\n-        check(10, 3, 1);\n-        check(0, 3, 3);\n-        check(3, 3, 3);\n-        check(56, 42, 14);\n-    }\n-\n-    #[test]\n-    fn test_lcm() {\n-        fn check(a: uint, b: uint, c: uint) {\n-            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n-            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n-            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n-\n-            assert_eq!(big_a.lcm(&big_b), big_c);\n-        }\n-\n-        check(1, 0, 0);\n-        check(0, 1, 0);\n-        check(1, 1, 1);\n-        check(8, 9, 72);\n-        check(11, 5, 55);\n-        check(99, 17, 1683);\n-    }\n-\n-    #[test]\n-    fn test_is_even() {\n-        let one: BigUint = FromStr::from_str(\"1\").unwrap();\n-        let two: BigUint = FromStr::from_str(\"2\").unwrap();\n-        let thousand: BigUint = FromStr::from_str(\"1000\").unwrap();\n-        let big: BigUint = FromStr::from_str(\"1000000000000000000000\").unwrap();\n-        let bigger: BigUint = FromStr::from_str(\"1000000000000000000001\").unwrap();\n-        assert!(one.is_odd());\n-        assert!(two.is_even());\n-        assert!(thousand.is_even());\n-        assert!(big.is_even());\n-        assert!(bigger.is_odd());\n-        assert!((one << 64).is_even());\n-        assert!(((one << 64) + one).is_odd());\n-    }\n-\n-    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, String)>)> {\n-        let bits = BigDigit::bits;\n-        vec!(( Zero::zero(), vec!(\n-            (2, \"0\".to_string()), (3, \"0\".to_string())\n-        )), ( BigUint::from_slice([ 0xff ]), vec!(\n-            (2,  \"11111111\".to_string()),\n-            (3,  \"100110\".to_string()),\n-            (4,  \"3333\".to_string()),\n-            (5,  \"2010\".to_string()),\n-            (6,  \"1103\".to_string()),\n-            (7,  \"513\".to_string()),\n-            (8,  \"377\".to_string()),\n-            (9,  \"313\".to_string()),\n-            (10, \"255\".to_string()),\n-            (11, \"212\".to_string()),\n-            (12, \"193\".to_string()),\n-            (13, \"168\".to_string()),\n-            (14, \"143\".to_string()),\n-            (15, \"120\".to_string()),\n-            (16, \"ff\".to_string())\n-        )), ( BigUint::from_slice([ 0xfff ]), vec!(\n-            (2,  \"111111111111\".to_string()),\n-            (4,  \"333333\".to_string()),\n-            (16, \"fff\".to_string())\n-        )), ( BigUint::from_slice([ 1, 2 ]), vec!(\n-            (2,\n-             format!(\"10{}1\", \"0\".repeat(bits - 1))),\n-            (4,\n-             format!(\"2{}1\", \"0\".repeat(bits / 2 - 1))),\n-            (10, match bits {\n-                32 => \"8589934593\".to_string(),\n-                16 => \"131073\".to_string(),\n-                _ => fail!()\n-            }),\n-            (16,\n-             format!(\"2{}1\", \"0\".repeat(bits / 4 - 1)))\n-        )), ( BigUint::from_slice([ 1, 2, 3 ]), vec!(\n-            (2,\n-             format!(\"11{}10{}1\",\n-                     \"0\".repeat(bits - 2),\n-                     \"0\".repeat(bits - 1))),\n-            (4,\n-             format!(\"3{}2{}1\",\n-                     \"0\".repeat(bits / 2 - 1),\n-                     \"0\".repeat(bits / 2 - 1))),\n-            (10, match bits {\n-                32 => \"55340232229718589441\".to_string(),\n-                16 => \"12885032961\".to_string(),\n-                _ => fail!()\n-            }),\n-            (16,\n-             format!(\"3{}2{}1\",\n-                     \"0\".repeat(bits / 4 - 1),\n-                     \"0\".repeat(bits / 4 - 1)))\n-        )) )\n-    }\n-\n-    #[test]\n-    fn test_to_str_radix() {\n-        let r = to_str_pairs();\n-        for num_pair in r.iter() {\n-            let &(ref n, ref rs) = num_pair;\n-            for str_pair in rs.iter() {\n-                let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n.to_str_radix(*radix).as_slice(),\n-                           str.as_slice());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        let r = to_str_pairs();\n-        for num_pair in r.iter() {\n-            let &(ref n, ref rs) = num_pair;\n-            for str_pair in rs.iter() {\n-                let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n,\n-                           &FromStrRadix::from_str_radix(str.as_slice(),\n-                                                         *radix).unwrap());\n-            }\n-        }\n-\n-        let zed: Option<BigUint> = FromStrRadix::from_str_radix(\"Z\", 10);\n-        assert_eq!(zed, None);\n-        let blank: Option<BigUint> = FromStrRadix::from_str_radix(\"_\", 2);\n-        assert_eq!(blank, None);\n-        let minus_one: Option<BigUint> = FromStrRadix::from_str_radix(\"-1\",\n-                                                                      10);\n-        assert_eq!(minus_one, None);\n-    }\n-\n-    #[test]\n-    fn test_factor() {\n-        fn factor(n: uint) -> BigUint {\n-            let mut f: BigUint = One::one();\n-            for i in range(2, n + 1) {\n-                // FIXME(#5992): assignment operator overloads\n-                // f *= FromPrimitive::from_uint(i);\n-                f = f * FromPrimitive::from_uint(i).unwrap();\n-            }\n-            return f;\n-        }\n-\n-        fn check(n: uint, s: &str) {\n-            let n = factor(n);\n-            let ans = match FromStrRadix::from_str_radix(s, 10) {\n-                Some(x) => x, None => fail!()\n-            };\n-            assert_eq!(n, ans);\n-        }\n-\n-        check(3, \"6\");\n-        check(10, \"3628800\");\n-        check(20, \"2432902008176640000\");\n-        check(30, \"265252859812191058636308480000000\");\n-    }\n-\n-    #[test]\n-    fn test_bits() {\n-        assert_eq!(BigUint::new(vec!(0,0,0,0)).bits(), 0);\n-        let n: BigUint = FromPrimitive::from_uint(0).unwrap();\n-        assert_eq!(n.bits(), 0);\n-        let n: BigUint = FromPrimitive::from_uint(1).unwrap();\n-        assert_eq!(n.bits(), 1);\n-        let n: BigUint = FromPrimitive::from_uint(3).unwrap();\n-        assert_eq!(n.bits(), 2);\n-        let n: BigUint = FromStrRadix::from_str_radix(\"4000000000\", 16).unwrap();\n-        assert_eq!(n.bits(), 39);\n-        let one: BigUint = One::one();\n-        assert_eq!((one << 426).bits(), 427);\n-    }\n-\n-    #[test]\n-    fn test_rand() {\n-        let mut rng = task_rng();\n-        let _n: BigUint = rng.gen_biguint(137);\n-        assert!(rng.gen_biguint(0).is_zero());\n-    }\n-\n-    #[test]\n-    fn test_rand_range() {\n-        let mut rng = task_rng();\n-\n-        for _ in range(0u, 10) {\n-            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n-                                            &FromPrimitive::from_uint(237).unwrap()),\n-                       FromPrimitive::from_uint(236).unwrap());\n-        }\n-\n-        let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n-        let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        for _ in range(0u, 1000) {\n-            let n: BigUint = rng.gen_biguint_below(&u);\n-            assert!(n < u);\n-\n-            let n: BigUint = rng.gen_biguint_range(&l, &u);\n-            assert!(n >= l);\n-            assert!(n < u);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_zero_rand_range() {\n-        task_rng().gen_biguint_range(&FromPrimitive::from_uint(54).unwrap(),\n-                                     &FromPrimitive::from_uint(54).unwrap());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_negative_rand_range() {\n-        let mut rng = task_rng();\n-        let l = FromPrimitive::from_uint(2352).unwrap();\n-        let u = FromPrimitive::from_uint(3513).unwrap();\n-        // Switching u and l should fail:\n-        let _n: BigUint = rng.gen_biguint_range(&u, &l);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bigint_tests {\n-    use Integer;\n-    use super::{BigDigit, BigUint, ToBigUint};\n-    use super::{Sign, Minus, NoSign, Plus, BigInt, RandBigInt, ToBigInt};\n-\n-    use std::cmp::{Less, Equal, Greater};\n-    use std::i64;\n-    use std::num::CheckedDiv;\n-    use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n-    use std::num::{ToPrimitive, FromPrimitive};\n-    use std::rand::task_rng;\n-    use std::u64;\n-    use std::hash::hash;\n-\n-    #[test]\n-    fn test_from_biguint() {\n-        fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n-            let inp = BigInt::from_biguint(inp_s, FromPrimitive::from_uint(inp_n).unwrap());\n-            let ans = BigInt { sign: ans_s, data: FromPrimitive::from_uint(ans_n).unwrap()};\n-            assert_eq!(inp, ans);\n-        }\n-        check(Plus, 1, Plus, 1);\n-        check(Plus, 0, NoSign, 0);\n-        check(Minus, 1, Minus, 1);\n-        check(NoSign, 1, NoSign, 0);\n-    }\n-\n-    #[test]\n-    fn test_cmp() {\n-        let vs: [&[BigDigit], ..4] = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n-        let mut nums = Vec::new();\n-        for s in vs.iter().rev() {\n-            nums.push(BigInt::from_slice(Minus, *s));\n-        }\n-        nums.push(Zero::zero());\n-        nums.extend(vs.iter().map(|s| BigInt::from_slice(Plus, *s)));\n-\n-        for (i, ni) in nums.iter().enumerate() {\n-            for (j0, nj) in nums.slice(i, nums.len()).iter().enumerate() {\n-                let j = i + j0;\n-                if i == j {\n-                    assert_eq!(ni.cmp(nj), Equal);\n-                    assert_eq!(nj.cmp(ni), Equal);\n-                    assert_eq!(ni, nj);\n-                    assert!(!(ni != nj));\n-                    assert!(ni <= nj);\n-                    assert!(ni >= nj);\n-                    assert!(!(ni < nj));\n-                    assert!(!(ni > nj));\n-                } else {\n-                    assert_eq!(ni.cmp(nj), Less);\n-                    assert_eq!(nj.cmp(ni), Greater);\n-\n-                    assert!(!(ni == nj));\n-                    assert!(ni != nj);\n-\n-                    assert!(ni <= nj);\n-                    assert!(!(ni >= nj));\n-                    assert!(ni < nj);\n-                    assert!(!(ni > nj));\n-\n-                    assert!(!(nj <= ni));\n-                    assert!(nj >= ni);\n-                    assert!(!(nj < ni));\n-                    assert!(nj > ni);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let a = BigInt::new(NoSign, vec!());\n-        let b = BigInt::new(NoSign, vec!(0));\n-        let c = BigInt::new(Plus, vec!(1));\n-        let d = BigInt::new(Plus, vec!(1,0,0,0,0,0));\n-        let e = BigInt::new(Plus, vec!(0,0,0,0,0,1));\n-        let f = BigInt::new(Minus, vec!(1));\n-        assert!(hash(&a) == hash(&b));\n-        assert!(hash(&b) != hash(&c));\n-        assert!(hash(&c) == hash(&d));\n-        assert!(hash(&d) != hash(&e));\n-        assert!(hash(&c) != hash(&f));\n-    }\n-\n-    #[test]\n-    fn test_convert_i64() {\n-        fn check(b1: BigInt, i: i64) {\n-            let b2: BigInt = FromPrimitive::from_i64(i).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_i64().unwrap() == i);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(i64::MIN.to_bigint().unwrap(), i64::MIN);\n-        check(i64::MAX.to_bigint().unwrap(), i64::MAX);\n-\n-        assert_eq!(\n-            (i64::MAX as u64 + 1).to_bigint().unwrap().to_i64(),\n-            None);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Plus,  BigUint::new(vec!(1, 2, 3, 4, 5))).to_i64(),\n-            None);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(vec!(1,0,0,1<<(BigDigit::bits-1)))).to_i64(),\n-            None);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_i64(),\n-            None);\n-    }\n-\n-    #[test]\n-    fn test_convert_u64() {\n-        fn check(b1: BigInt, u: u64) {\n-            let b2: BigInt = FromPrimitive::from_u64(u).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_u64().unwrap() == u);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(u64::MIN.to_bigint().unwrap(), u64::MIN);\n-        check(u64::MAX.to_bigint().unwrap(), u64::MAX);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Plus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_u64(),\n-            None);\n-\n-        let max_value: BigUint = FromPrimitive::from_u64(u64::MAX).unwrap();\n-        assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n-        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_u64(), None);\n-    }\n-\n-    #[test]\n-    fn test_convert_to_biguint() {\n-        fn check(n: BigInt, ans_1: BigUint) {\n-            assert_eq!(n.to_biguint().unwrap(), ans_1);\n-            assert_eq!(n.to_biguint().unwrap().to_bigint().unwrap(), n);\n-        }\n-        let zero: BigInt = Zero::zero();\n-        let unsigned_zero: BigUint = Zero::zero();\n-        let positive = BigInt::from_biguint(\n-            Plus, BigUint::new(vec!(1,2,3)));\n-        let negative = -positive;\n-\n-        check(zero, unsigned_zero);\n-        check(positive, BigUint::new(vec!(1,2,3)));\n-\n-        assert_eq!(negative.to_biguint(), None);\n-    }\n-\n-    static SUM_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],          &[],       &[]),\n-        (&[],          &[ 1],     &[ 1]),\n-        (&[ 1],        &[ 1],     &[ 2]),\n-        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n-        (&[ 1],        &[-1],     &[ 0,  1]),\n-        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n-        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n-        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n-        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n-    ];\n-\n-    #[test]\n-    fn test_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a + b == c);\n-            assert!(b + a == c);\n-            assert!(c + (-a) == b);\n-            assert!(c + (-b) == a);\n-            assert!(a + (-c) == (-b));\n-            assert!(b + (-c) == (-a));\n-            assert!((-a) + (-b) == (-c))\n-            assert!(a + (-a) == Zero::zero());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(c - a == b);\n-            assert!(c - b == a);\n-            assert!((-b) - a == (-c))\n-            assert!((-a) - b == (-c))\n-            assert!(b - (-a) == c);\n-            assert!(a - (-b) == c);\n-            assert!((-c) - (-a) == (-b));\n-            assert!(a - a == Zero::zero());\n-        }\n-    }\n-\n-    static MUL_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],               &[],               &[]),\n-        (&[],               &[ 1],             &[]),\n-        (&[ 2],             &[],               &[]),\n-        (&[ 1],             &[ 1],             &[1]),\n-        (&[ 2],             &[ 3],             &[ 6]),\n-        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n-        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n-        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n-        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n-        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n-        (&[-1],             &[-1],             &[ 1, -2]),\n-        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n-        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n-        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n-        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n-        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n-        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n-        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n-        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n-        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n-        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n-    ];\n-\n-    static DIV_REM_QUADRUPLES: &'static [(&'static [BigDigit],\n-                                          &'static [BigDigit],\n-                                          &'static [BigDigit],\n-                                          &'static [BigDigit])]\n-        = &[\n-            (&[ 1],        &[ 2], &[],               &[1]),\n-            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n-            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n-            (&[ 0,  1],    &[-1], &[1],              &[1]),\n-            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n-        ];\n-\n-    #[test]\n-    fn test_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a * b == c);\n-            assert!(b * a == c);\n-\n-            assert!((-a) * b == -c);\n-            assert!((-b) * a == -c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            assert!(a == b * c + d);\n-            assert!(a == c * b + d);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_div_mod_floor() {\n-        fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n-            let (d, m) = a.div_mod_floor(b);\n-            if !m.is_zero() {\n-                assert_eq!(m.sign, b.sign);\n-            }\n-            assert!(m.abs() <= b.abs());\n-            assert!(*a == b * d + m);\n-            assert!(d == *ans_d);\n-            assert!(m == *ans_m);\n-        }\n-\n-        fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n-            if m.is_zero() {\n-                check_sub(a, b, d, m);\n-                check_sub(a, &b.neg(), &d.neg(), m);\n-                check_sub(&a.neg(), b, &d.neg(), m);\n-                check_sub(&a.neg(), &b.neg(), d, m);\n-            } else {\n-                check_sub(a, b, d, m);\n-                check_sub(a, &b.neg(), &(d.neg() - One::one()), &(m - *b));\n-                check_sub(&a.neg(), b, &(d.neg() - One::one()), &(b - *m));\n-                check_sub(&a.neg(), &b.neg(), d, &m.neg());\n-            }\n-        }\n-\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n-            if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            if !b.is_zero() {\n-                check(&a, &b, &c, &d);\n-            }\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_div_rem() {\n-        fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n-            let (q, r) = a.div_rem(b);\n-            if !r.is_zero() {\n-                assert_eq!(r.sign, a.sign);\n-            }\n-            assert!(r.abs() <= b.abs());\n-            assert!(*a == b * q + r);\n-            assert!(q == *ans_q);\n-            assert!(r == *ans_r);\n-        }\n-\n-        fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n-            check_sub(a, b, q, r);\n-            check_sub(a, &b.neg(), &q.neg(), r);\n-            check_sub(&a.neg(), b, &q.neg(), &r.neg());\n-            check_sub(&a.neg(), &b.neg(), q, &r.neg());\n-        }\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n-            if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            if !b.is_zero() {\n-                check(&a, &b, &c, &d);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a.checked_add(&b).unwrap() == c);\n-            assert!(b.checked_add(&a).unwrap() == c);\n-            assert!(c.checked_add(&(-a)).unwrap() == b);\n-            assert!(c.checked_add(&(-b)).unwrap() == a);\n-            assert!(a.checked_add(&(-c)).unwrap() == (-b));\n-            assert!(b.checked_add(&(-c)).unwrap() == (-a));\n-            assert!((-a).checked_add(&(-b)).unwrap() == (-c))\n-            assert!(a.checked_add(&(-a)).unwrap() == Zero::zero());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(c.checked_sub(&a).unwrap() == b);\n-            assert!(c.checked_sub(&b).unwrap() == a);\n-            assert!((-b).checked_sub(&a).unwrap() == (-c))\n-            assert!((-a).checked_sub(&b).unwrap() == (-c))\n-            assert!(b.checked_sub(&(-a)).unwrap() == c);\n-            assert!(a.checked_sub(&(-b)).unwrap() == c);\n-            assert!((-c).checked_sub(&(-a)).unwrap() == (-b));\n-            assert!(a.checked_sub(&a).unwrap() == Zero::zero());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a.checked_mul(&b).unwrap() == c);\n-            assert!(b.checked_mul(&a).unwrap() == c);\n-\n-            assert!((-a).checked_mul(&b).unwrap() == -c);\n-            assert!((-b).checked_mul(&a).unwrap() == -c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            assert!(a == b.checked_mul(&c).unwrap() + d);\n-            assert!(a == c.checked_mul(&b).unwrap() + d);\n-        }\n-    }\n-    #[test]\n-    fn test_checked_div() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            if !a.is_zero() {\n-                assert!(c.checked_div(&a).unwrap() == b);\n-                assert!((-c).checked_div(&(-a)).unwrap() == b);\n-                assert!((-c).checked_div(&a).unwrap() == -b);\n-            }\n-            if !b.is_zero() {\n-                assert!(c.checked_div(&b).unwrap() == a);\n-                assert!((-c).checked_div(&(-b)).unwrap() == a);\n-                assert!((-c).checked_div(&b).unwrap() == -a);\n-            }\n-\n-            assert!(c.checked_div(&Zero::zero()).is_none());\n-            assert!((-c).checked_div(&Zero::zero()).is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gcd() {\n-        fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n-            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n-            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n-\n-            assert_eq!(big_a.gcd(&big_b), big_c);\n-        }\n-\n-        check(10, 2, 2);\n-        check(10, 3, 1);\n-        check(0, 3, 3);\n-        check(3, 3, 3);\n-        check(56, 42, 14);\n-        check(3, -3, 3);\n-        check(-6, 3, 3);\n-        check(-4, -2, 2);\n-    }\n-\n-    #[test]\n-    fn test_lcm() {\n-        fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n-            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n-            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n-\n-            assert_eq!(big_a.lcm(&big_b), big_c);\n-        }\n-\n-        check(1, 0, 0);\n-        check(0, 1, 0);\n-        check(1, 1, 1);\n-        check(-1, 1, 1);\n-        check(1, -1, 1);\n-        check(-1, -1, 1);\n-        check(8, 9, 72);\n-        check(11, 5, 55);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        let zero: BigInt = Zero::zero();\n-        let one: BigInt = One::one();\n-        assert_eq!((-one).abs_sub(&one), zero);\n-        let one: BigInt = One::one();\n-        let zero: BigInt = Zero::zero();\n-        assert_eq!(one.abs_sub(&one), zero);\n-        let one: BigInt = One::one();\n-        let zero: BigInt = Zero::zero();\n-        assert_eq!(one.abs_sub(&zero), one);\n-        let one: BigInt = One::one();\n-        let two: BigInt = FromPrimitive::from_int(2).unwrap();\n-        assert_eq!(one.abs_sub(&-one), two);\n-    }\n-\n-    #[test]\n-    fn test_to_str_radix() {\n-        fn check(n: int, ans: &str) {\n-            let n: BigInt = FromPrimitive::from_int(n).unwrap();\n-            assert!(ans == n.to_str_radix(10).as_slice());\n-        }\n-        check(10, \"10\");\n-        check(1, \"1\");\n-        check(0, \"0\");\n-        check(-1, \"-1\");\n-        check(-10, \"-10\");\n-    }\n-\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map(|n| {\n-                let x: BigInt = FromPrimitive::from_int(n).unwrap();\n-                x\n-            });\n-            assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n-        }\n-        check(\"10\", Some(10));\n-        check(\"1\", Some(1));\n-        check(\"0\", Some(0));\n-        check(\"-1\", Some(-1));\n-        check(\"-10\", Some(-10));\n-        check(\"Z\", None);\n-        check(\"_\", None);\n-\n-        // issue 10522, this hit an edge case that caused it to\n-        // attempt to allocate a vector of size (-1u) == huge.\n-        let x: BigInt =\n-            from_str(format!(\"1{}\", \"0\".repeat(36)).as_slice()).unwrap();\n-        let _y = x.to_string();\n-    }\n-\n-    #[test]\n-    fn test_neg() {\n-        assert!(-BigInt::new(Plus,  vec!(1, 1, 1)) ==\n-            BigInt::new(Minus, vec!(1, 1, 1)));\n-        assert!(-BigInt::new(Minus, vec!(1, 1, 1)) ==\n-            BigInt::new(Plus,  vec!(1, 1, 1)));\n-        let zero: BigInt = Zero::zero();\n-        assert_eq!(-zero, zero);\n-    }\n-\n-    #[test]\n-    fn test_rand() {\n-        let mut rng = task_rng();\n-        let _n: BigInt = rng.gen_bigint(137);\n-        assert!(rng.gen_bigint(0).is_zero());\n-    }\n-\n-    #[test]\n-    fn test_rand_range() {\n-        let mut rng = task_rng();\n-\n-        for _ in range(0u, 10) {\n-            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n-                                            &FromPrimitive::from_uint(237).unwrap()),\n-                       FromPrimitive::from_uint(236).unwrap());\n-        }\n-\n-        fn check(l: BigInt, u: BigInt) {\n-            let mut rng = task_rng();\n-            for _ in range(0u, 1000) {\n-                let n: BigInt = rng.gen_bigint_range(&l, &u);\n-                assert!(n >= l);\n-                assert!(n < u);\n-            }\n-        }\n-        let l: BigInt = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n-        let u: BigInt = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        check( l.clone(),  u.clone());\n-        check(-l.clone(),  u.clone());\n-        check(-u.clone(), -l.clone());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_zero_rand_range() {\n-        task_rng().gen_bigint_range(&FromPrimitive::from_int(54).unwrap(),\n-                                    &FromPrimitive::from_int(54).unwrap());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_negative_rand_range() {\n-        let mut rng = task_rng();\n-        let l = FromPrimitive::from_uint(2352).unwrap();\n-        let u = FromPrimitive::from_uint(3513).unwrap();\n-        // Switching u and l should fail:\n-        let _n: BigInt = rng.gen_bigint_range(&u, &l);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::BigUint;\n-    use std::iter;\n-    use std::mem::replace;\n-    use std::num::{FromPrimitive, Zero, One};\n-\n-    fn factorial(n: uint) -> BigUint {\n-        let mut f: BigUint = One::one();\n-        for i in iter::range_inclusive(1, n) {\n-            f = f * FromPrimitive::from_uint(i).unwrap();\n-        }\n-        f\n-    }\n-\n-    fn fib(n: uint) -> BigUint {\n-        let mut f0: BigUint = Zero::zero();\n-        let mut f1: BigUint = One::one();\n-        for _ in range(0, n) {\n-            let f2 = f0 + f1;\n-            f0 = replace(&mut f1, f2);\n-        }\n-        f0\n-    }\n-\n-    #[bench]\n-    fn factorial_100(b: &mut Bencher) {\n-        b.iter(|| {\n-            factorial(100);\n-        });\n-    }\n-\n-    #[bench]\n-    fn fib_100(b: &mut Bencher) {\n-        b.iter(|| {\n-            fib(100);\n-        });\n-    }\n-\n-    #[bench]\n-    fn to_string(b: &mut Bencher) {\n-        let fac = factorial(100);\n-        let fib = fib(100);\n-        b.iter(|| {\n-            fac.to_string();\n-        });\n-        b.iter(|| {\n-            fib.to_string();\n-        });\n-    }\n-\n-    #[bench]\n-    fn shr(b: &mut Bencher) {\n-        let n = { let one : BigUint = One::one(); one << 1000 };\n-        b.iter(|| {\n-            let mut m = n.clone();\n-            for _ in range(0u, 10) {\n-                m = m >> 1;\n-            }\n-        })\n-    }\n-}"}, {"sha": "6690b1d5ddc7acd3b7c4b6f842e36a6e64b0cdd3", "filename": "src/libnum/complex.rs", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,379 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-//! Complex numbers.\n-\n-use std::fmt;\n-use std::num::{Zero, One, ToStrRadix};\n-\n-// FIXME #1284: handle complex NaN & infinity etc. This\n-// probably doesn't map to C's _Complex correctly.\n-\n-/// A complex number in Cartesian form.\n-#[deriving(PartialEq, Clone, Hash)]\n-pub struct Complex<T> {\n-    /// Real portion of the complex number\n-    pub re: T,\n-    /// Imaginary portion of the complex number\n-    pub im: T\n-}\n-\n-pub type Complex32 = Complex<f32>;\n-pub type Complex64 = Complex<f64>;\n-\n-impl<T: Clone + Num> Complex<T> {\n-    /// Create a new Complex\n-    #[inline]\n-    pub fn new(re: T, im: T) -> Complex<T> {\n-        Complex { re: re, im: im }\n-    }\n-\n-    /// Returns the square of the norm (since `T` doesn't necessarily\n-    /// have a sqrt function), i.e. `re^2 + im^2`.\n-    #[inline]\n-    pub fn norm_sqr(&self) -> T {\n-        self.re * self.re + self.im * self.im\n-    }\n-\n-\n-    /// Returns the complex conjugate. i.e. `re - i im`\n-    #[inline]\n-    pub fn conj(&self) -> Complex<T> {\n-        Complex::new(self.re.clone(), -self.im)\n-    }\n-\n-\n-    /// Multiplies `self` by the scalar `t`.\n-    #[inline]\n-    pub fn scale(&self, t: T) -> Complex<T> {\n-        Complex::new(self.re * t, self.im * t)\n-    }\n-\n-    /// Divides `self` by the scalar `t`.\n-    #[inline]\n-    pub fn unscale(&self, t: T) -> Complex<T> {\n-        Complex::new(self.re / t, self.im / t)\n-    }\n-\n-    /// Returns `1/self`\n-    #[inline]\n-    pub fn inv(&self) -> Complex<T> {\n-        let norm_sqr = self.norm_sqr();\n-        Complex::new(self.re / norm_sqr,\n-                    -self.im / norm_sqr)\n-    }\n-}\n-\n-impl<T: Clone + FloatMath> Complex<T> {\n-    /// Calculate |self|\n-    #[inline]\n-    pub fn norm(&self) -> T {\n-        self.re.hypot(self.im)\n-    }\n-}\n-\n-impl<T: Clone + FloatMath> Complex<T> {\n-    /// Calculate the principal Arg of self.\n-    #[inline]\n-    pub fn arg(&self) -> T {\n-        self.im.atan2(self.re)\n-    }\n-    /// Convert to polar form (r, theta), such that `self = r * exp(i\n-    /// * theta)`\n-    #[inline]\n-    pub fn to_polar(&self) -> (T, T) {\n-        (self.norm(), self.arg())\n-    }\n-    /// Convert a polar representation into a complex number.\n-    #[inline]\n-    pub fn from_polar(r: &T, theta: &T) -> Complex<T> {\n-        Complex::new(*r * theta.cos(), *r * theta.sin())\n-    }\n-}\n-\n-/* arithmetic */\n-// (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Clone + Num> Add<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn add(&self, other: &Complex<T>) -> Complex<T> {\n-        Complex::new(self.re + other.re, self.im + other.im)\n-    }\n-}\n-// (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Clone + Num> Sub<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn sub(&self, other: &Complex<T>) -> Complex<T> {\n-        Complex::new(self.re - other.re, self.im - other.im)\n-    }\n-}\n-// (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Clone + Num> Mul<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn mul(&self, other: &Complex<T>) -> Complex<T> {\n-        Complex::new(self.re*other.re - self.im*other.im,\n-                   self.re*other.im + self.im*other.re)\n-    }\n-}\n-\n-// (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n-//   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Clone + Num> Div<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn div(&self, other: &Complex<T>) -> Complex<T> {\n-        let norm_sqr = other.norm_sqr();\n-        Complex::new((self.re*other.re + self.im*other.im) / norm_sqr,\n-                   (self.im*other.re - self.re*other.im) / norm_sqr)\n-    }\n-}\n-\n-impl<T: Clone + Num> Neg<Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn neg(&self) -> Complex<T> {\n-        Complex::new(-self.re, -self.im)\n-    }\n-}\n-\n-/* constants */\n-impl<T: Clone + Num> Zero for Complex<T> {\n-    #[inline]\n-    fn zero() -> Complex<T> {\n-        Complex::new(Zero::zero(), Zero::zero())\n-    }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.re.is_zero() && self.im.is_zero()\n-    }\n-}\n-\n-impl<T: Clone + Num> One for Complex<T> {\n-    #[inline]\n-    fn one() -> Complex<T> {\n-        Complex::new(One::one(), Zero::zero())\n-    }\n-}\n-\n-/* string conversions */\n-impl<T: fmt::Show + Num + PartialOrd> fmt::Show for Complex<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.im < Zero::zero() {\n-            write!(f, \"{}-{}i\", self.re, -self.im)\n-        } else {\n-            write!(f, \"{}+{}i\", self.re, self.im)\n-        }\n-    }\n-}\n-\n-impl<T: ToStrRadix + Num + PartialOrd> ToStrRadix for Complex<T> {\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        if self.im < Zero::zero() {\n-            format!(\"{}-{}i\",\n-                    self.re.to_str_radix(radix),\n-                    (-self.im).to_str_radix(radix))\n-        } else {\n-            format!(\"{}+{}i\",\n-                    self.re.to_str_radix(radix),\n-                    self.im.to_str_radix(radix))\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    #![allow(non_uppercase_statics)]\n-\n-    use super::{Complex64, Complex};\n-    use std::num::{Zero, One, Float};\n-    use std::hash::hash;\n-\n-    pub const _0_0i : Complex64 = Complex { re: 0.0, im: 0.0 };\n-    pub const _1_0i : Complex64 = Complex { re: 1.0, im: 0.0 };\n-    pub const _1_1i : Complex64 = Complex { re: 1.0, im: 1.0 };\n-    pub const _0_1i : Complex64 = Complex { re: 0.0, im: 1.0 };\n-    pub const _neg1_1i : Complex64 = Complex { re: -1.0, im: 1.0 };\n-    pub const _05_05i : Complex64 = Complex { re: 0.5, im: 0.5 };\n-    pub const all_consts : [Complex64, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n-\n-    #[test]\n-    fn test_consts() {\n-        // check our constants are what Complex::new creates\n-        fn test(c : Complex64, r : f64, i: f64) {\n-            assert_eq!(c, Complex::new(r,i));\n-        }\n-        test(_0_0i, 0.0, 0.0);\n-        test(_1_0i, 1.0, 0.0);\n-        test(_1_1i, 1.0, 1.0);\n-        test(_neg1_1i, -1.0, 1.0);\n-        test(_05_05i, 0.5, 0.5);\n-\n-        assert_eq!(_0_0i, Zero::zero());\n-        assert_eq!(_1_0i, One::one());\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_arch = \"x86\", ignore)]\n-    // FIXME #7158: (maybe?) currently failing on x86.\n-    fn test_norm() {\n-        fn test(c: Complex64, ns: f64) {\n-            assert_eq!(c.norm_sqr(), ns);\n-            assert_eq!(c.norm(), ns.sqrt())\n-        }\n-        test(_0_0i, 0.0);\n-        test(_1_0i, 1.0);\n-        test(_1_1i, 2.0);\n-        test(_neg1_1i, 2.0);\n-        test(_05_05i, 0.5);\n-    }\n-\n-    #[test]\n-    fn test_scale_unscale() {\n-        assert_eq!(_05_05i.scale(2.0), _1_1i);\n-        assert_eq!(_1_1i.unscale(2.0), _05_05i);\n-        for &c in all_consts.iter() {\n-            assert_eq!(c.scale(2.0).unscale(2.0), c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_conj() {\n-        for &c in all_consts.iter() {\n-            assert_eq!(c.conj(), Complex::new(c.re, -c.im));\n-            assert_eq!(c.conj().conj(), c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_inv() {\n-        assert_eq!(_1_1i.inv(), _05_05i.conj());\n-        assert_eq!(_1_0i.inv(), _1_0i.inv());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_divide_by_zero_natural() {\n-        let n = Complex::new(2i, 3i);\n-        let d = Complex::new(0, 0);\n-        let _x = n / d;\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore]\n-    fn test_inv_zero() {\n-        // FIXME #5736: should this really fail, or just NaN?\n-        _0_0i.inv();\n-    }\n-\n-    #[test]\n-    fn test_arg() {\n-        fn test(c: Complex64, arg: f64) {\n-            assert!((c.arg() - arg).abs() < 1.0e-6)\n-        }\n-        test(_1_0i, 0.0);\n-        test(_1_1i, 0.25 * Float::pi());\n-        test(_neg1_1i, 0.75 * Float::pi());\n-        test(_05_05i, 0.25 * Float::pi());\n-    }\n-\n-    #[test]\n-    fn test_polar_conv() {\n-        fn test(c: Complex64) {\n-            let (r, theta) = c.to_polar();\n-            assert!((c - Complex::from_polar(&r, &theta)).norm() < 1e-6);\n-        }\n-        for &c in all_consts.iter() { test(c); }\n-    }\n-\n-    mod arith {\n-        use super::{_0_0i, _1_0i, _1_1i, _0_1i, _neg1_1i, _05_05i, all_consts};\n-        use std::num::Zero;\n-\n-        #[test]\n-        fn test_add() {\n-            assert_eq!(_05_05i + _05_05i, _1_1i);\n-            assert_eq!(_0_1i + _1_0i, _1_1i);\n-            assert_eq!(_1_0i + _neg1_1i, _0_1i);\n-\n-            for &c in all_consts.iter() {\n-                assert_eq!(_0_0i + c, c);\n-                assert_eq!(c + _0_0i, c);\n-            }\n-        }\n-\n-        #[test]\n-        fn test_sub() {\n-            assert_eq!(_05_05i - _05_05i, _0_0i);\n-            assert_eq!(_0_1i - _1_0i, _neg1_1i);\n-            assert_eq!(_0_1i - _neg1_1i, _1_0i);\n-\n-            for &c in all_consts.iter() {\n-                assert_eq!(c - _0_0i, c);\n-                assert_eq!(c - c, _0_0i);\n-            }\n-        }\n-\n-        #[test]\n-        fn test_mul() {\n-            assert_eq!(_05_05i * _05_05i, _0_1i.unscale(2.0));\n-            assert_eq!(_1_1i * _0_1i, _neg1_1i);\n-\n-            // i^2 & i^4\n-            assert_eq!(_0_1i * _0_1i, -_1_0i);\n-            assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n-\n-            for &c in all_consts.iter() {\n-                assert_eq!(c * _1_0i, c);\n-                assert_eq!(_1_0i * c, c);\n-            }\n-        }\n-        #[test]\n-        fn test_div() {\n-            assert_eq!(_neg1_1i / _0_1i, _1_1i);\n-            for &c in all_consts.iter() {\n-                if c != Zero::zero() {\n-                    assert_eq!(c / c, _1_0i);\n-                }\n-            }\n-        }\n-        #[test]\n-        fn test_neg() {\n-            assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n-            assert_eq!((-_0_1i) * _0_1i, _1_0i);\n-            for &c in all_consts.iter() {\n-                assert_eq!(-(-c), c);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_string() {\n-        fn test(c : Complex64, s: String) {\n-            assert_eq!(c.to_string(), s);\n-        }\n-        test(_0_0i, \"0+0i\".to_string());\n-        test(_1_0i, \"1+0i\".to_string());\n-        test(_0_1i, \"0+1i\".to_string());\n-        test(_1_1i, \"1+1i\".to_string());\n-        test(_neg1_1i, \"-1+1i\".to_string());\n-        test(-_neg1_1i, \"1-1i\".to_string());\n-        test(_05_05i, \"0.5+0.5i\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let a = Complex::new(0i32, 0i32);\n-        let b = Complex::new(1i32, 0i32);\n-        let c = Complex::new(0i32, 1i32);\n-        assert!(hash(&a) != hash(&b));\n-        assert!(hash(&b) != hash(&c));\n-        assert!(hash(&c) != hash(&a));\n-    }\n-}"}, {"sha": "c5d076a70b5823985ad153acd12da4b71dfe03e4", "filename": "src/libnum/integer.rs", "status": "removed", "additions": 0, "deletions": 507, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,507 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Integer trait and functions.\n-\n-pub trait Integer: Num + PartialOrd\n-                 + Div<Self, Self>\n-                 + Rem<Self, Self> {\n-    /// Floored integer division.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert!(( 8i).div_floor(& 3) ==  2);\n-    /// assert!(( 8i).div_floor(&-3) == -3);\n-    /// assert!((-8i).div_floor(& 3) == -3);\n-    /// assert!((-8i).div_floor(&-3) ==  2);\n-    ///\n-    /// assert!(( 1i).div_floor(& 2) ==  0);\n-    /// assert!(( 1i).div_floor(&-2) == -1);\n-    /// assert!((-1i).div_floor(& 2) == -1);\n-    /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ```\n-    fn div_floor(&self, other: &Self) -> Self;\n-\n-    /// Floored integer modulo, satisfying:\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// # let n = 1i; let d = 1i;\n-    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ```\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert!(( 8i).mod_floor(& 3) ==  2);\n-    /// assert!(( 8i).mod_floor(&-3) == -1);\n-    /// assert!((-8i).mod_floor(& 3) ==  1);\n-    /// assert!((-8i).mod_floor(&-3) == -2);\n-    ///\n-    /// assert!(( 1i).mod_floor(& 2) ==  1);\n-    /// assert!(( 1i).mod_floor(&-2) == -1);\n-    /// assert!((-1i).mod_floor(& 2) ==  1);\n-    /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ```\n-    fn mod_floor(&self, other: &Self) -> Self;\n-\n-    /// Greatest Common Divisor (GCD).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(6i.gcd(&8), 2);\n-    /// assert_eq!(7i.gcd(&3), 1);\n-    /// ```\n-    fn gcd(&self, other: &Self) -> Self;\n-\n-    /// Lowest Common Multiple (LCM).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(7i.lcm(&3), 21);\n-    /// assert_eq!(2i.lcm(&4), 4);\n-    /// ```\n-    fn lcm(&self, other: &Self) -> Self;\n-\n-    /// Deprecated, use `is_multiple_of` instead.\n-    #[deprecated = \"function renamed to `is_multiple_of`\"]\n-    fn divides(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if `other` is a multiple of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(9i.is_multiple_of(&3), true);\n-    /// assert_eq!(3i.is_multiple_of(&9), false);\n-    /// ```\n-    fn is_multiple_of(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if the number is even.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(3i.is_even(), false);\n-    /// assert_eq!(4i.is_even(), true);\n-    /// ```\n-    fn is_even(&self) -> bool;\n-\n-    /// Returns `true` if the number is odd.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(3i.is_odd(), true);\n-    /// assert_eq!(4i.is_odd(), false);\n-    /// ```\n-    fn is_odd(&self) -> bool;\n-\n-    /// Simultaneous truncated integer division and modulus.\n-    /// Returns `(quotient, remainder)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(( 8i).div_rem( &3), ( 2,  2));\n-    /// assert_eq!(( 8i).div_rem(&-3), (-2,  2));\n-    /// assert_eq!((-8i).div_rem( &3), (-2, -2));\n-    /// assert_eq!((-8i).div_rem(&-3), ( 2, -2));\n-    ///\n-    /// assert_eq!(( 1i).div_rem( &2), ( 0,  1));\n-    /// assert_eq!(( 1i).div_rem(&-2), ( 0,  1));\n-    /// assert_eq!((-1i).div_rem( &2), ( 0, -1));\n-    /// assert_eq!((-1i).div_rem(&-2), ( 0, -1));\n-    /// ```\n-    #[inline]\n-    fn div_rem(&self, other: &Self) -> (Self, Self) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    /// Simultaneous floored integer division and modulus.\n-    /// Returns `(quotient, remainder)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(( 8i).div_mod_floor( &3), ( 2,  2));\n-    /// assert_eq!(( 8i).div_mod_floor(&-3), (-3, -1));\n-    /// assert_eq!((-8i).div_mod_floor( &3), (-3,  1));\n-    /// assert_eq!((-8i).div_mod_floor(&-3), ( 2, -2));\n-    ///\n-    /// assert_eq!(( 1i).div_mod_floor( &2), ( 0,  1));\n-    /// assert_eq!(( 1i).div_mod_floor(&-2), (-1, -1));\n-    /// assert_eq!((-1i).div_mod_floor( &2), (-1,  1));\n-    /// assert_eq!((-1i).div_mod_floor(&-2), ( 0, -1));\n-    /// ```\n-    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n-        (self.div_floor(other), self.mod_floor(other))\n-    }\n-}\n-\n-/// Simultaneous integer division and modulus\n-#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n-/// Floored integer division\n-#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n-/// Floored integer modulus\n-#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n-/// Simultaneous floored integer division and modulus\n-#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n-\n-/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n-/// result is always positive.\n-#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n-/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n-\n-macro_rules! impl_integer_for_int {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Floored integer division\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => d - 1,\n-                    (d, _)                          => d,\n-                }\n-            }\n-\n-            /// Floored integer modulo\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match *self % *other {\n-                    r if (r > 0 && *other < 0)\n-                      || (r < 0 && *other > 0) => r + *other,\n-                    r                          => r,\n-                }\n-            }\n-\n-            /// Calculates `div_floor` and `mod_floor` simultaneously\n-            #[inline]\n-            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n-                    (d, r)                          => (d, r),\n-                }\n-            }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and\n-            /// `other`. The result is always positive.\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n.abs()\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and\n-            /// `other`.\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                // should not have to recalculate abs\n-                ((*self * *other) / self.gcd(other)).abs()\n-            }\n-\n-            /// Deprecated, use `is_multiple_of` instead.\n-            #[deprecated = \"function renamed to `is_multiple_of`\"]\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { return self.is_multiple_of(other); }\n-\n-            /// Returns `true` if the number is a multiple of `other`.\n-            #[inline]\n-            fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            /// Checks that the division rule holds for:\n-            ///\n-            /// - `n`: numerator (dividend)\n-            /// - `d`: denominator (divisor)\n-            /// - `qr`: quotient and remainder\n-            #[cfg(test)]\n-            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n-                assert_eq!(d * q + r, n);\n-            }\n-\n-            #[test]\n-            fn test_div_rem() {\n-                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_rem = (n / d, n % d);\n-                    let combined_div_rem = n.div_rem(&d);\n-\n-                    assert_eq!(separate_div_rem, qr);\n-                    assert_eq!(combined_div_rem, qr);\n-\n-                    test_division_rule(nd, separate_div_rem);\n-                    test_division_rule(nd, combined_div_rem);\n-                }\n-\n-                test_nd_dr(( 8,  3), ( 2,  2));\n-                test_nd_dr(( 8, -3), (-2,  2));\n-                test_nd_dr((-8,  3), (-2, -2));\n-                test_nd_dr((-8, -3), ( 2, -2));\n-\n-                test_nd_dr(( 1,  2), ( 0,  1));\n-                test_nd_dr(( 1, -2), ( 0,  1));\n-                test_nd_dr((-1,  2), ( 0, -1));\n-                test_nd_dr((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n-                    let combined_div_mod_floor = n.div_mod_floor(&d);\n-\n-                    assert_eq!(separate_div_mod_floor, dm);\n-                    assert_eq!(combined_div_mod_floor, dm);\n-\n-                    test_division_rule(nd, separate_div_mod_floor);\n-                    test_division_rule(nd, combined_div_mod_floor);\n-                }\n-\n-                test_nd_dm(( 8,  3), ( 2,  2));\n-                test_nd_dm(( 8, -3), (-3, -1));\n-                test_nd_dm((-8,  3), (-3,  1));\n-                test_nd_dm((-8, -3), ( 2, -2));\n-\n-                test_nd_dm(( 1,  2), ( 0,  1));\n-                test_nd_dm(( 1, -2), (-1, -1));\n-                test_nd_dm((-1,  2), (-1,  1));\n-                test_nd_dm((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n-                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n-            }\n-\n-            #[test]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((-4 as $T).is_even(), true);\n-                assert_eq!((-3 as $T).is_even(), false);\n-                assert_eq!((-2 as $T).is_even(), true);\n-                assert_eq!((-1 as $T).is_even(), false);\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((-4 as $T).is_odd(), false);\n-                assert_eq!((-3 as $T).is_odd(), true);\n-                assert_eq!((-2 as $T).is_odd(), false);\n-                assert_eq!((-1 as $T).is_odd(), true);\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_int!(i8,   test_integer_i8)\n-impl_integer_for_int!(i16,  test_integer_i16)\n-impl_integer_for_int!(i32,  test_integer_i32)\n-impl_integer_for_int!(i64,  test_integer_i64)\n-impl_integer_for_int!(int,  test_integer_int)\n-\n-macro_rules! impl_integer_for_uint {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Unsigned integer division. Returns the same result as `div` (`/`).\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n-\n-            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                (*self * *other) / self.gcd(other)\n-            }\n-\n-            /// Deprecated, use `is_multiple_of` instead.\n-            #[deprecated = \"function renamed to `is_multiple_of`\"]\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { return self.is_multiple_of(other); }\n-\n-            /// Returns `true` if the number is a multiple of `other`.\n-            #[inline]\n-            fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`.\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`.\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n-                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n-                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n-                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n-                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n-                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n-                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n-                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n-                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-            }\n-\n-            #[test]\n-            #[allow(type_overflow)]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n-            }\n-\n-            #[test]\n-            fn test_is_multiple_of() {\n-                assert!((6 as $T).is_multiple_of(&(6 as $T)));\n-                assert!((6 as $T).is_multiple_of(&(3 as $T)));\n-                assert!((6 as $T).is_multiple_of(&(1 as $T)));\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_uint!(u8,   test_integer_u8)\n-impl_integer_for_uint!(u16,  test_integer_u16)\n-impl_integer_for_uint!(u32,  test_integer_u32)\n-impl_integer_for_uint!(u64,  test_integer_u64)\n-impl_integer_for_uint!(uint, test_integer_uint)"}, {"sha": "063bb17e09a6d6947e0217d7db9e747d88b8ed35", "filename": "src/libnum/lib.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,73 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple numerics.\n-//!\n-//! This crate contains arbitrary-sized integer, rational, and complex types.\n-//!\n-//! ## Example\n-//!\n-//! This example uses the BigRational type and [Newton's method][newt] to\n-//! approximate a square root to arbitrary precision:\n-//!\n-//! ```\n-//! # #![allow(deprecated)]\n-//! extern crate num;\n-//!\n-//! use num::bigint::BigInt;\n-//! use num::rational::{Ratio, BigRational};\n-//!\n-//! fn approx_sqrt(number: u64, iterations: uint) -> BigRational {\n-//!     let start: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u64(number).unwrap());\n-//!     let mut approx = start.clone();\n-//!\n-//!     for _ in range(0, iterations) {\n-//!         approx = (approx + (start / approx)) /\n-//!             Ratio::from_integer(FromPrimitive::from_u64(2).unwrap());\n-//!     }\n-//!\n-//!     approx\n-//! }\n-//!\n-//! fn main() {\n-//!     println!(\"{}\", approx_sqrt(10, 4)); // prints 4057691201/1283082416\n-//! }\n-//! ```\n-//!\n-//! [newt]: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n-\n-#![allow(unknown_features)]\n-#![feature(macro_rules, slicing_syntax)]\n-#![feature(default_type_params)]\n-\n-#![crate_name = \"num\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/num\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(deprecated)] // from_str_radix\n-\n-extern crate rand;\n-\n-pub use bigint::{BigInt, BigUint};\n-pub use rational::{Rational, BigRational};\n-pub use complex::Complex;\n-pub use integer::Integer;\n-\n-pub mod bigint;\n-pub mod complex;\n-pub mod integer;\n-pub mod rational;"}, {"sha": "ceaf685c19a5154d03b89d1a25def253c3136635", "filename": "src/libnum/rational.rs", "status": "removed", "additions": 0, "deletions": 803, "changes": 803, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,803 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Rational numbers\n-\n-use Integer;\n-\n-use std::cmp;\n-use std::fmt;\n-use std::from_str::FromStr;\n-use std::num;\n-use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n-\n-use bigint::{BigInt, BigUint, Sign, Plus, Minus};\n-\n-/// Represents the ratio between 2 numbers.\n-#[deriving(Clone, Hash)]\n-#[allow(missing_doc)]\n-pub struct Ratio<T> {\n-    numer: T,\n-    denom: T\n-}\n-\n-/// Alias for a `Ratio` of machine-sized integers.\n-pub type Rational = Ratio<int>;\n-pub type Rational32 = Ratio<i32>;\n-pub type Rational64 = Ratio<i64>;\n-\n-/// Alias for arbitrary precision rationals.\n-pub type BigRational = Ratio<BigInt>;\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    Ratio<T> {\n-    /// Creates a ratio representing the integer `t`.\n-    #[inline]\n-    pub fn from_integer(t: T) -> Ratio<T> {\n-        Ratio::new_raw(t, One::one())\n-    }\n-\n-    /// Creates a ratio without checking for `denom == 0` or reducing.\n-    #[inline]\n-    pub fn new_raw(numer: T, denom: T) -> Ratio<T> {\n-        Ratio { numer: numer, denom: denom }\n-    }\n-\n-    /// Create a new Ratio. Fails if `denom == 0`.\n-    #[inline]\n-    pub fn new(numer: T, denom: T) -> Ratio<T> {\n-        if denom == Zero::zero() {\n-            fail!(\"denominator == 0\");\n-        }\n-        let mut ret = Ratio::new_raw(numer, denom);\n-        ret.reduce();\n-        ret\n-    }\n-\n-    /// Converts to an integer.\n-    #[inline]\n-    pub fn to_integer(&self) -> T {\n-        self.trunc().numer\n-    }\n-\n-    /// Gets an immutable reference to the numerator.\n-    #[inline]\n-    pub fn numer<'a>(&'a self) -> &'a T {\n-        &self.numer\n-    }\n-\n-    /// Gets an immutable reference to the denominator.\n-    #[inline]\n-    pub fn denom<'a>(&'a self) -> &'a T {\n-        &self.denom\n-    }\n-\n-    /// Returns true if the rational number is an integer (denominator is 1).\n-    #[inline]\n-    pub fn is_integer(&self) -> bool {\n-        self.denom == One::one()\n-    }\n-\n-    /// Put self into lowest terms, with denom > 0.\n-    fn reduce(&mut self) {\n-        let g : T = self.numer.gcd(&self.denom);\n-\n-        // FIXME(#5992): assignment operator overloads\n-        // self.numer /= g;\n-        self.numer = self.numer / g;\n-        // FIXME(#5992): assignment operator overloads\n-        // self.denom /= g;\n-        self.denom = self.denom / g;\n-\n-        // keep denom positive!\n-        if self.denom < Zero::zero() {\n-            self.numer = -self.numer;\n-            self.denom = -self.denom;\n-        }\n-    }\n-\n-    /// Returns a `reduce`d copy of self.\n-    pub fn reduced(&self) -> Ratio<T> {\n-        let mut ret = self.clone();\n-        ret.reduce();\n-        ret\n-    }\n-\n-    /// Returns the reciprocal.\n-    #[inline]\n-    pub fn recip(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.denom.clone(), self.numer.clone())\n-    }\n-\n-    /// Rounds towards minus infinity.\n-    #[inline]\n-    pub fn floor(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n-        } else {\n-            Ratio::from_integer(self.numer / self.denom)\n-        }\n-    }\n-\n-    /// Rounds towards plus infinity.\n-    #[inline]\n-    pub fn ceil(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer(self.numer / self.denom)\n-        } else {\n-            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n-        }\n-    }\n-\n-    /// Rounds to the nearest integer. Rounds half-way cases away from zero.\n-    #[inline]\n-    pub fn round(&self) -> Ratio<T> {\n-        let one: T = One::one();\n-        let two: T = one + one;\n-\n-        // Find unsigned fractional part of rational number\n-        let fractional = self.fract().abs();\n-\n-        // The algorithm compares the unsigned fractional part with 1/2, that\n-        // is, a/b >= 1/2, or a >= b/2. For odd denominators, we use\n-        // a >= (b/2)+1. This avoids overflow issues.\n-        let half_or_larger = if fractional.denom().is_even() {\n-            *fractional.numer() >= *fractional.denom() / two\n-        } else {\n-            *fractional.numer() >= (*fractional.denom() / two) + one\n-        };\n-\n-        if half_or_larger {\n-            if *self >= Zero::zero() {\n-                self.trunc() + One::one()\n-            } else {\n-                self.trunc() - One::one()\n-            }\n-        } else {\n-            self.trunc()\n-        }\n-    }\n-\n-    /// Rounds towards zero.\n-    #[inline]\n-    pub fn trunc(&self) -> Ratio<T> {\n-        Ratio::from_integer(self.numer / self.denom)\n-    }\n-\n-    /// Returns the fractional part of a number.\n-    #[inline]\n-    pub fn fract(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n-    }\n-}\n-\n-impl Ratio<BigInt> {\n-    /// Converts a float into a rational number.\n-    pub fn from_float<T: Float>(f: T) -> Option<BigRational> {\n-        if !f.is_finite() {\n-            return None;\n-        }\n-        let (mantissa, exponent, sign) = f.integer_decode();\n-        let bigint_sign: Sign = if sign == 1 { Plus } else { Minus };\n-        if exponent < 0 {\n-            let one: BigInt = One::one();\n-            let denom: BigInt = one << ((-exponent) as uint);\n-            let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n-            Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))\n-        } else {\n-            let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n-            numer = numer << (exponent as uint);\n-            Some(Ratio::from_integer(BigInt::from_biguint(bigint_sign, numer)))\n-        }\n-    }\n-}\n-\n-/* Comparisons */\n-\n-// comparing a/b and c/d is the same as comparing a*d and b*c, so we\n-// abstract that pattern. The following macro takes a trait and either\n-// a comma-separated list of \"method name -> return value\" or just\n-// \"method name\" (return value is bool in that case)\n-macro_rules! cmp_impl {\n-    (impl $imp:ident, $($method:ident),+) => {\n-        cmp_impl!(impl $imp, $($method -> bool),+)\n-    };\n-    // return something other than a Ratio<T>\n-    (impl $imp:ident, $($method:ident -> $res:ty),*) => {\n-        impl<T: Mul<T,T> + $imp> $imp for Ratio<T> {\n-            $(\n-                #[inline]\n-                fn $method(&self, other: &Ratio<T>) -> $res {\n-                    (self.numer * other.denom). $method (&(self.denom*other.numer))\n-                }\n-            )*\n-        }\n-    };\n-}\n-cmp_impl!(impl PartialEq, eq, ne)\n-cmp_impl!(impl PartialOrd, lt -> bool, gt -> bool, le -> bool, ge -> bool,\n-          partial_cmp -> Option<cmp::Ordering>)\n-cmp_impl!(impl Eq, )\n-cmp_impl!(impl Ord, cmp -> cmp::Ordering)\n-\n-/* Arithmetic */\n-// a/b * c/d = (a*c)/(b*d)\n-impl<T: Clone + Integer + PartialOrd>\n-    Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n-    #[inline]\n-    fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n-        Ratio::new(self.numer * rhs.numer, self.denom * rhs.denom)\n-    }\n-}\n-\n-// (a/b) / (c/d) = (a*d)/(b*c)\n-impl<T: Clone + Integer + PartialOrd>\n-    Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n-    #[inline]\n-    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n-        Ratio::new(self.numer * rhs.denom, self.denom * rhs.numer)\n-    }\n-}\n-\n-// Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n-macro_rules! arith_impl {\n-    (impl $imp:ident, $method:ident) => {\n-        impl<T: Clone + Integer + PartialOrd>\n-            $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n-            #[inline]\n-            fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n-                Ratio::new((self.numer * rhs.denom).$method(&(self.denom * rhs.numer)),\n-                           self.denom * rhs.denom)\n-            }\n-        }\n-    }\n-}\n-\n-// a/b + c/d = (a*d + b*c)/(b*d)\n-arith_impl!(impl Add, add)\n-\n-// a/b - c/d = (a*d - b*c)/(b*d)\n-arith_impl!(impl Sub, sub)\n-\n-// a/b % c/d = (a*d % b*c)/(b*d)\n-arith_impl!(impl Rem, rem)\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    Neg<Ratio<T>> for Ratio<T> {\n-    #[inline]\n-    fn neg(&self) -> Ratio<T> {\n-        Ratio::new_raw(-self.numer, self.denom.clone())\n-    }\n-}\n-\n-/* Constants */\n-impl<T: Clone + Integer + PartialOrd>\n-    Zero for Ratio<T> {\n-    #[inline]\n-    fn zero() -> Ratio<T> {\n-        Ratio::new_raw(Zero::zero(), One::one())\n-    }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        *self == Zero::zero()\n-    }\n-}\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    One for Ratio<T> {\n-    #[inline]\n-    fn one() -> Ratio<T> {\n-        Ratio::new_raw(One::one(), One::one())\n-    }\n-}\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    Num for Ratio<T> {}\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    num::Signed for Ratio<T> {\n-    #[inline]\n-    fn abs(&self) -> Ratio<T> {\n-        if self.is_negative() { -self.clone() } else { self.clone() }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {\n-        if *self <= *other { Zero::zero() } else { *self - *other }\n-    }\n-\n-    #[inline]\n-    fn signum(&self) -> Ratio<T> {\n-        if *self > Zero::zero() {\n-            num::one()\n-        } else if self.is_zero() {\n-            num::zero()\n-        } else {\n-            - num::one::<Ratio<T>>()\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > Zero::zero() }\n-\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < Zero::zero() }\n-}\n-\n-/* String conversions */\n-impl<T: fmt::Show + Eq + One> fmt::Show for Ratio<T> {\n-    /// Renders as `numer/denom`. If denom=1, renders as numer.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.denom == One::one() {\n-            write!(f, \"{}\", self.numer)\n-        } else {\n-            write!(f, \"{}/{}\", self.numer, self.denom)\n-        }\n-    }\n-}\n-\n-impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n-    /// Renders as `numer/denom` where the numbers are in base `radix`.\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        format!(\"{}/{}\",\n-                self.numer.to_str_radix(radix),\n-                self.denom.to_str_radix(radix))\n-    }\n-}\n-\n-impl<T: FromStr + Clone + Integer + PartialOrd>\n-    FromStr for Ratio<T> {\n-    /// Parses `numer/denom` or just `numer`.\n-    fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let mut split = s.splitn(1, '/');\n-\n-        let num = split.next().and_then(|n| FromStr::from_str(n));\n-        let den = split.next().or(Some(\"1\")).and_then(|d| FromStr::from_str(d));\n-\n-        match (num, den) {\n-            (Some(n), Some(d)) => Some(Ratio::new(n, d)),\n-            _ => None\n-        }\n-    }\n-}\n-\n-impl<T: FromStrRadix + Clone + Integer + PartialOrd>\n-    FromStrRadix for Ratio<T> {\n-    /// Parses `numer/denom` where the numbers are in base `radix`.\n-    fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split: Vec<&str> = s.splitn(1, '/').collect();\n-        if split.len() < 2 {\n-            None\n-        } else {\n-            let a_option: Option<T> = FromStrRadix::from_str_radix(\n-                *split.get(0),\n-                radix);\n-            a_option.and_then(|a| {\n-                let b_option: Option<T> =\n-                    FromStrRadix::from_str_radix(*split.get(1), radix);\n-                b_option.and_then(|b| {\n-                    Some(Ratio::new(a.clone(), b.clone()))\n-                })\n-            })\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::{Ratio, Rational, BigRational};\n-    use std::num::{Zero, One, FromStrRadix, FromPrimitive, ToStrRadix};\n-    use std::from_str::FromStr;\n-    use std::hash::hash;\n-    use std::num;\n-    use std::i32;\n-\n-    pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n-    pub static _1 : Rational = Ratio { numer: 1, denom: 1};\n-    pub static _2: Rational = Ratio { numer: 2, denom: 1};\n-    pub static _1_2: Rational = Ratio { numer: 1, denom: 2};\n-    pub static _3_2: Rational = Ratio { numer: 3, denom: 2};\n-    #[allow(non_uppercase_statics)]\n-    pub static _neg1_2: Rational = Ratio { numer: -1, denom: 2};\n-    pub static _1_3: Rational = Ratio { numer: 1, denom: 3};\n-    #[allow(non_uppercase_statics)]\n-    pub static _neg1_3: Rational = Ratio { numer: -1, denom: 3};\n-    pub static _2_3: Rational = Ratio { numer: 2, denom: 3};\n-    #[allow(non_uppercase_statics)]\n-    pub static _neg2_3: Rational = Ratio { numer: -2, denom: 3};\n-\n-    pub fn to_big(n: Rational) -> BigRational {\n-        Ratio::new(\n-            FromPrimitive::from_int(n.numer).unwrap(),\n-            FromPrimitive::from_int(n.denom).unwrap()\n-        )\n-    }\n-\n-    #[test]\n-    fn test_test_constants() {\n-        // check our constants are what Ratio::new etc. would make.\n-        assert_eq!(_0, Zero::zero());\n-        assert_eq!(_1, One::one());\n-        assert_eq!(_2, Ratio::from_integer(2i));\n-        assert_eq!(_1_2, Ratio::new(1i,2i));\n-        assert_eq!(_3_2, Ratio::new(3i,2i));\n-        assert_eq!(_neg1_2, Ratio::new(-1i,2i));\n-    }\n-\n-    #[test]\n-    fn test_new_reduce() {\n-        let one22 = Ratio::new(2i,2);\n-\n-        assert_eq!(one22, One::one());\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_new_zero() {\n-        let _a = Ratio::new(1i,0);\n-    }\n-\n-\n-    #[test]\n-    fn test_cmp() {\n-        assert!(_0 == _0 && _1 == _1);\n-        assert!(_0 != _1 && _1 != _0);\n-        assert!(_0 < _1 && !(_1 < _0));\n-        assert!(_1 > _0 && !(_0 > _1));\n-\n-        assert!(_0 <= _0 && _1 <= _1);\n-        assert!(_0 <= _1 && !(_1 <= _0));\n-\n-        assert!(_0 >= _0 && _1 >= _1);\n-        assert!(_1 >= _0 && !(_0 >= _1));\n-    }\n-\n-\n-    #[test]\n-    fn test_to_integer() {\n-        assert_eq!(_0.to_integer(), 0);\n-        assert_eq!(_1.to_integer(), 1);\n-        assert_eq!(_2.to_integer(), 2);\n-        assert_eq!(_1_2.to_integer(), 0);\n-        assert_eq!(_3_2.to_integer(), 1);\n-        assert_eq!(_neg1_2.to_integer(), 0);\n-    }\n-\n-\n-    #[test]\n-    fn test_numer() {\n-        assert_eq!(_0.numer(), &0);\n-        assert_eq!(_1.numer(), &1);\n-        assert_eq!(_2.numer(), &2);\n-        assert_eq!(_1_2.numer(), &1);\n-        assert_eq!(_3_2.numer(), &3);\n-        assert_eq!(_neg1_2.numer(), &(-1));\n-    }\n-    #[test]\n-    fn test_denom() {\n-        assert_eq!(_0.denom(), &1);\n-        assert_eq!(_1.denom(), &1);\n-        assert_eq!(_2.denom(), &1);\n-        assert_eq!(_1_2.denom(), &2);\n-        assert_eq!(_3_2.denom(), &2);\n-        assert_eq!(_neg1_2.denom(), &2);\n-    }\n-\n-\n-    #[test]\n-    fn test_is_integer() {\n-        assert!(_0.is_integer());\n-        assert!(_1.is_integer());\n-        assert!(_2.is_integer());\n-        assert!(!_1_2.is_integer());\n-        assert!(!_3_2.is_integer());\n-        assert!(!_neg1_2.is_integer());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        assert_eq!(format!(\"{}\", _2), \"2\".to_string());\n-        assert_eq!(format!(\"{}\", _1_2), \"1/2\".to_string());\n-        assert_eq!(format!(\"{}\", _0), \"0\".to_string());\n-        assert_eq!(format!(\"{}\", Ratio::from_integer(-2i)), \"-2\".to_string());\n-    }\n-\n-    mod arith {\n-        use super::{_0, _1, _2, _1_2, _3_2, _neg1_2, to_big};\n-        use super::super::{Ratio, Rational};\n-\n-        #[test]\n-        fn test_add() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a + b, c);\n-                assert_eq!(to_big(a) + to_big(b), to_big(c));\n-            }\n-\n-            test(_1, _1_2, _3_2);\n-            test(_1, _1, _2);\n-            test(_1_2, _3_2, _2);\n-            test(_1_2, _neg1_2, _0);\n-        }\n-\n-        #[test]\n-        fn test_sub() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a - b, c);\n-                assert_eq!(to_big(a) - to_big(b), to_big(c))\n-            }\n-\n-            test(_1, _1_2, _1_2);\n-            test(_3_2, _1_2, _1);\n-            test(_1, _neg1_2, _3_2);\n-        }\n-\n-        #[test]\n-        fn test_mul() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a * b, c);\n-                assert_eq!(to_big(a) * to_big(b), to_big(c))\n-            }\n-\n-            test(_1, _1_2, _1_2);\n-            test(_1_2, _3_2, Ratio::new(3i,4i));\n-            test(_1_2, _neg1_2, Ratio::new(-1i, 4i));\n-        }\n-\n-        #[test]\n-        fn test_div() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a / b, c);\n-                assert_eq!(to_big(a) / to_big(b), to_big(c))\n-            }\n-\n-            test(_1, _1_2, _2);\n-            test(_3_2, _1_2, _1 + _2);\n-            test(_1, _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n-        }\n-\n-        #[test]\n-        fn test_rem() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a % b, c);\n-                assert_eq!(to_big(a) % to_big(b), to_big(c))\n-            }\n-\n-            test(_3_2, _1, _1_2);\n-            test(_2, _neg1_2, _0);\n-            test(_1_2, _2,  _1_2);\n-        }\n-\n-        #[test]\n-        fn test_neg() {\n-            fn test(a: Rational, b: Rational) {\n-                assert_eq!(-a, b);\n-                assert_eq!(-to_big(a), to_big(b))\n-            }\n-\n-            test(_0, _0);\n-            test(_1_2, _neg1_2);\n-            test(-_1, _1);\n-        }\n-        #[test]\n-        fn test_zero() {\n-            assert_eq!(_0 + _0, _0);\n-            assert_eq!(_0 * _0, _0);\n-            assert_eq!(_0 * _1, _0);\n-            assert_eq!(_0 / _neg1_2, _0);\n-            assert_eq!(_0 - _0, _0);\n-        }\n-        #[test]\n-        #[should_fail]\n-        fn test_div_0() {\n-            let _a =  _1 / _0;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_round() {\n-        assert_eq!(_1_3.ceil(), _1);\n-        assert_eq!(_1_3.floor(), _0);\n-        assert_eq!(_1_3.round(), _0);\n-        assert_eq!(_1_3.trunc(), _0);\n-\n-        assert_eq!(_neg1_3.ceil(), _0);\n-        assert_eq!(_neg1_3.floor(), -_1);\n-        assert_eq!(_neg1_3.round(), _0);\n-        assert_eq!(_neg1_3.trunc(), _0);\n-\n-        assert_eq!(_2_3.ceil(), _1);\n-        assert_eq!(_2_3.floor(), _0);\n-        assert_eq!(_2_3.round(), _1);\n-        assert_eq!(_2_3.trunc(), _0);\n-\n-        assert_eq!(_neg2_3.ceil(), _0);\n-        assert_eq!(_neg2_3.floor(), -_1);\n-        assert_eq!(_neg2_3.round(), -_1);\n-        assert_eq!(_neg2_3.trunc(), _0);\n-\n-        assert_eq!(_1_2.ceil(), _1);\n-        assert_eq!(_1_2.floor(), _0);\n-        assert_eq!(_1_2.round(), _1);\n-        assert_eq!(_1_2.trunc(), _0);\n-\n-        assert_eq!(_neg1_2.ceil(), _0);\n-        assert_eq!(_neg1_2.floor(), -_1);\n-        assert_eq!(_neg1_2.round(), -_1);\n-        assert_eq!(_neg1_2.trunc(), _0);\n-\n-        assert_eq!(_1.ceil(), _1);\n-        assert_eq!(_1.floor(), _1);\n-        assert_eq!(_1.round(), _1);\n-        assert_eq!(_1.trunc(), _1);\n-\n-        // Overflow checks\n-\n-        let _neg1 = Ratio::from_integer(-1);\n-        let _large_rat1 = Ratio::new(i32::MAX, i32::MAX-1);\n-        let _large_rat2 = Ratio::new(i32::MAX-1, i32::MAX);\n-        let _large_rat3 = Ratio::new(i32::MIN+2, i32::MIN+1);\n-        let _large_rat4 = Ratio::new(i32::MIN+1, i32::MIN+2);\n-        let _large_rat5 = Ratio::new(i32::MIN+2, i32::MAX);\n-        let _large_rat6 = Ratio::new(i32::MAX, i32::MIN+2);\n-        let _large_rat7 = Ratio::new(1, i32::MIN+1);\n-        let _large_rat8 = Ratio::new(1, i32::MAX);\n-\n-        assert_eq!(_large_rat1.round(), One::one());\n-        assert_eq!(_large_rat2.round(), One::one());\n-        assert_eq!(_large_rat3.round(), One::one());\n-        assert_eq!(_large_rat4.round(), One::one());\n-        assert_eq!(_large_rat5.round(), _neg1);\n-        assert_eq!(_large_rat6.round(), _neg1);\n-        assert_eq!(_large_rat7.round(), Zero::zero());\n-        assert_eq!(_large_rat8.round(), Zero::zero());\n-    }\n-\n-    #[test]\n-    fn test_fract() {\n-        assert_eq!(_1.fract(), _0);\n-        assert_eq!(_neg1_2.fract(), _neg1_2);\n-        assert_eq!(_1_2.fract(), _1_2);\n-        assert_eq!(_3_2.fract(), _1_2);\n-    }\n-\n-    #[test]\n-    fn test_recip() {\n-        assert_eq!(_1 * _1.recip(), _1);\n-        assert_eq!(_2 * _2.recip(), _1);\n-        assert_eq!(_1_2 * _1_2.recip(), _1);\n-        assert_eq!(_3_2 * _3_2.recip(), _1);\n-        assert_eq!(_neg1_2 * _neg1_2.recip(), _1);\n-    }\n-\n-    #[test]\n-    fn test_to_from_str() {\n-        fn test(r: Rational, s: String) {\n-            assert_eq!(FromStr::from_str(s.as_slice()), Some(r));\n-            assert_eq!(r.to_string(), s);\n-        }\n-        test(_1, \"1\".to_string());\n-        test(_0, \"0\".to_string());\n-        test(_1_2, \"1/2\".to_string());\n-        test(_3_2, \"3/2\".to_string());\n-        test(_2, \"2\".to_string());\n-        test(_neg1_2, \"-1/2\".to_string());\n-    }\n-    #[test]\n-    fn test_from_str_fail() {\n-        fn test(s: &str) {\n-            let rational: Option<Rational> = FromStr::from_str(s);\n-            assert_eq!(rational, None);\n-        }\n-\n-        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n-        for &s in xs.iter() {\n-            test(s);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_from_str_radix() {\n-        fn test(r: Rational, s: String, n: uint) {\n-            assert_eq!(FromStrRadix::from_str_radix(s.as_slice(), n),\n-                       Some(r));\n-            assert_eq!(r.to_str_radix(n).to_string(), s);\n-        }\n-        fn test3(r: Rational, s: String) { test(r, s, 3) }\n-        fn test16(r: Rational, s: String) { test(r, s, 16) }\n-\n-        test3(_1, \"1/1\".to_string());\n-        test3(_0, \"0/1\".to_string());\n-        test3(_1_2, \"1/2\".to_string());\n-        test3(_3_2, \"10/2\".to_string());\n-        test3(_2, \"2/1\".to_string());\n-        test3(_neg1_2, \"-1/2\".to_string());\n-        test3(_neg1_2 / _2, \"-1/11\".to_string());\n-\n-        test16(_1, \"1/1\".to_string());\n-        test16(_0, \"0/1\".to_string());\n-        test16(_1_2, \"1/2\".to_string());\n-        test16(_3_2, \"3/2\".to_string());\n-        test16(_2, \"2/1\".to_string());\n-        test16(_neg1_2, \"-1/2\".to_string());\n-        test16(_neg1_2 / _2, \"-1/4\".to_string());\n-        test16(Ratio::new(13i,15i), \"d/f\".to_string());\n-        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_fail() {\n-        fn test(s: &str) {\n-            let radix: Option<Rational> = FromStrRadix::from_str_radix(s, 3);\n-            assert_eq!(radix, None);\n-        }\n-\n-        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];\n-        for &s in xs.iter() {\n-            test(s);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_float() {\n-        fn test<T: Float>(given: T, (numer, denom): (&str, &str)) {\n-            let ratio: BigRational = Ratio::from_float(given).unwrap();\n-            assert_eq!(ratio, Ratio::new(\n-                FromStr::from_str(numer).unwrap(),\n-                FromStr::from_str(denom).unwrap()));\n-        }\n-\n-        // f32\n-        test(3.14159265359f32, (\"13176795\", \"4194304\"));\n-        test(2f32.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f32.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n-        test(1.0 / 2f32.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n-        test(684729.48391f32, (\"1369459\", \"2\"));\n-        test(-8573.5918555f32, (\"-4389679\", \"512\"));\n-\n-        // f64\n-        test(3.14159265359f64, (\"3537118876014453\", \"1125899906842624\"));\n-        test(2f64.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f64.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n-        test(684729.48391f64, (\"367611342500051\", \"536870912\"));\n-        test(-8573.5918555f64, (\"-4713381968463931\", \"549755813888\"));\n-        test(1.0 / 2f64.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n-    }\n-\n-    #[test]\n-    fn test_from_float_fail() {\n-        use std::{f32, f64};\n-\n-        assert_eq!(Ratio::from_float(f32::NAN), None);\n-        assert_eq!(Ratio::from_float(f32::INFINITY), None);\n-        assert_eq!(Ratio::from_float(f32::NEG_INFINITY), None);\n-        assert_eq!(Ratio::from_float(f64::NAN), None);\n-        assert_eq!(Ratio::from_float(f64::INFINITY), None);\n-        assert_eq!(Ratio::from_float(f64::NEG_INFINITY), None);\n-    }\n-\n-    #[test]\n-    fn test_signed() {\n-        assert_eq!(_neg1_2.abs(), _1_2);\n-        assert_eq!(_3_2.abs_sub(&_1_2), _1);\n-        assert_eq!(_1_2.abs_sub(&_3_2), Zero::zero());\n-        assert_eq!(_1_2.signum(), One::one());\n-        assert_eq!(_neg1_2.signum(), - num::one::<Ratio<int>>());\n-        assert!(_neg1_2.is_negative());\n-        assert!(! _neg1_2.is_positive());\n-        assert!(! _1_2.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        assert!(hash(&_0) != hash(&_1));\n-        assert!(hash(&_0) != hash(&_3_2));\n-    }\n-}"}, {"sha": "cc0e7d9ba2d98f78e40d253aa227e2684a9a3845", "filename": "src/libsemver/lib.rs", "status": "removed", "additions": 0, "deletions": 462, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,462 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Semantic version parsing and comparison.\n-//!\n-//! Semantic versioning (see http://semver.org/) is a set of rules for\n-//! assigning version numbers intended to convey meaning about what has\n-//! changed, and how much. A version number has five parts:\n-//!\n-//!  * Major number, updated for incompatible API changes\n-//!  * Minor number, updated for backwards-compatible API additions\n-//!  * Patch number, updated for backwards-compatible bugfixes\n-//!  * Pre-release information (optional), preceded by a hyphen (`-`)\n-//!  * Build metadata (optional), preceded by a plus sign (`+`)\n-//!\n-//! The three mandatory components are required to be decimal numbers. The\n-//! pre-release information and build metadata are required to be a\n-//! period-separated list of identifiers containing only alphanumeric\n-//! characters and hyphens.\n-//!\n-//! An example version number with all five components is\n-//! `0.8.1-rc.3.0+20130922.linux`.\n-\n-#![crate_name = \"semver\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/semver\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(default_type_params)]\n-\n-use std::char;\n-use std::cmp;\n-use std::fmt::Show;\n-use std::fmt;\n-use std::hash;\n-\n-/// An identifier in the pre-release or build metadata. If the identifier can\n-/// be parsed as a decimal value, it will be represented with `Numeric`.\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[allow(missing_doc)]\n-pub enum Identifier {\n-    Numeric(uint),\n-    AlphaNumeric(String)\n-}\n-\n-impl fmt::Show for Identifier {\n-    #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Numeric(ref n) => n.fmt(f),\n-            AlphaNumeric(ref s) => s.fmt(f)\n-        }\n-    }\n-}\n-\n-\n-/// Represents a version number conforming to the semantic versioning scheme.\n-#[deriving(Clone, Eq)]\n-pub struct Version {\n-    /// The major version, to be incremented on incompatible changes.\n-    pub major: uint,\n-    /// The minor version, to be incremented when functionality is added in a\n-    /// backwards-compatible manner.\n-    pub minor: uint,\n-    /// The patch version, to be incremented when backwards-compatible bug\n-    /// fixes are made.\n-    pub patch: uint,\n-    /// The pre-release version identifier, if one exists.\n-    pub pre: Vec<Identifier>,\n-    /// The build metadata, ignored when determining version precedence.\n-    pub build: Vec<Identifier>,\n-}\n-\n-impl fmt::Show for Version {\n-    #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch))\n-        if !self.pre.is_empty() {\n-            try!(write!(f, \"-\"));\n-            for (i, x) in self.pre.iter().enumerate() {\n-                if i != 0 { try!(write!(f, \".\")) };\n-                try!(x.fmt(f));\n-            }\n-        }\n-        if !self.build.is_empty() {\n-            try!(write!(f, \"+\"));\n-            for (i, x) in self.build.iter().enumerate() {\n-                if i != 0 { try!(write!(f, \".\")) };\n-                try!(x.fmt(f));\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl cmp::PartialEq for Version {\n-    #[inline]\n-    fn eq(&self, other: &Version) -> bool {\n-        // We should ignore build metadata here, otherwise versions v1 and v2\n-        // can exist such that !(v1 < v2) && !(v1 > v2) && v1 != v2, which\n-        // violate strict total ordering rules.\n-        self.major == other.major &&\n-            self.minor == other.minor &&\n-            self.patch == other.patch &&\n-            self.pre == other.pre\n-    }\n-}\n-\n-impl cmp::PartialOrd for Version {\n-    fn partial_cmp(&self, other: &Version) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl cmp::Ord for Version {\n-    fn cmp(&self, other: &Version) -> Ordering {\n-        match self.major.cmp(&other.major) {\n-            Equal => {}\n-            r => return r,\n-        }\n-\n-        match self.minor.cmp(&other.minor) {\n-            Equal => {}\n-            r => return r,\n-        }\n-\n-        match self.patch.cmp(&other.patch) {\n-            Equal => {}\n-            r => return r,\n-        }\n-\n-        // NB: semver spec says 0.0.0-pre < 0.0.0\n-        // but the version of ord defined for vec\n-        // says that [] < [pre] so we alter it here\n-        match (self.pre.len(), other.pre.len()) {\n-            (0, 0) => Equal,\n-            (0, _) => Greater,\n-            (_, 0) => Less,\n-            (_, _) => self.pre.cmp(&other.pre)\n-        }\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Version {\n-    fn hash(&self, into: &mut S) {\n-        self.major.hash(into);\n-        self.minor.hash(into);\n-        self.patch.hash(into);\n-        self.pre.hash(into);\n-    }\n-}\n-\n-fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n-                        -> (String, Option<char>) {\n-    let mut buf = String::new();\n-    let mut ch = rdr.next();\n-    loop {\n-        match ch {\n-            None => break,\n-            Some(c) if !pred(c) => break,\n-            Some(c) => {\n-                buf.push_char(c);\n-                ch = rdr.next();\n-            }\n-        }\n-    }\n-    (buf, ch)\n-}\n-\n-fn take_num<T: Iterator<char>>(rdr: &mut T) -> Option<(uint, Option<char>)> {\n-    let (s, ch) = take_nonempty_prefix(rdr, char::is_digit);\n-    match from_str::<uint>(s.as_slice()) {\n-        None => None,\n-        Some(i) => Some((i, ch))\n-    }\n-}\n-\n-fn take_ident<T: Iterator<char>>(rdr: &mut T) -> Option<(Identifier, Option<char>)> {\n-    let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n-    if s.as_slice().chars().all(char::is_digit) {\n-        match from_str::<uint>(s.as_slice()) {\n-            None => None,\n-            Some(i) => Some((Numeric(i), ch))\n-        }\n-    } else {\n-        Some((AlphaNumeric(s), ch))\n-    }\n-}\n-\n-fn expect(ch: Option<char>, c: char) -> Option<()> {\n-    if ch != Some(c) {\n-        None\n-    } else {\n-        Some(())\n-    }\n-}\n-\n-fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Option<Version> {\n-    let maybe_vers = take_num(rdr).and_then(|(major, ch)| {\n-        expect(ch, '.').and_then(|_| Some(major))\n-    }).and_then(|major| {\n-        take_num(rdr).and_then(|(minor, ch)| {\n-            expect(ch, '.').and_then(|_| Some((major, minor)))\n-        })\n-    }).and_then(|(major, minor)| {\n-        take_num(rdr).and_then(|(patch, ch)| {\n-           Some((major, minor, patch, ch))\n-        })\n-    });\n-\n-    let (major, minor, patch, ch) = match maybe_vers {\n-        Some((a, b, c, d)) => (a, b, c, d),\n-        None => return None\n-    };\n-\n-    let mut pre = vec!();\n-    let mut build = vec!();\n-\n-    let mut ch = ch;\n-    if ch == Some('-') {\n-        loop {\n-            let (id, c) = match take_ident(rdr) {\n-                Some((id, c)) => (id, c),\n-                None => return None\n-            };\n-            pre.push(id);\n-            ch = c;\n-            if ch != Some('.') { break; }\n-        }\n-    }\n-\n-    if ch == Some('+') {\n-        loop {\n-            let (id, c) = match take_ident(rdr) {\n-                Some((id, c)) => (id, c),\n-                None => return None\n-            };\n-            build.push(id);\n-            ch = c;\n-            if ch != Some('.') { break; }\n-        }\n-    }\n-\n-    Some(Version {\n-        major: major,\n-        minor: minor,\n-        patch: patch,\n-        pre: pre,\n-        build: build,\n-    })\n-}\n-\n-\n-/// Parse a string into a semver object.\n-pub fn parse(s: &str) -> Option<Version> {\n-    if !s.is_ascii() {\n-        return None;\n-    }\n-    let s = s.trim();\n-    let v = parse_iter(&mut s.chars());\n-    match v {\n-        Some(v) => {\n-            if v.to_string().equiv(&s) {\n-                Some(v)\n-            } else {\n-                None\n-            }\n-        }\n-        None => None\n-    }\n-}\n-\n-#[test]\n-fn test_parse() {\n-    assert_eq!(parse(\"\"), None);\n-    assert_eq!(parse(\"  \"), None);\n-    assert_eq!(parse(\"1\"), None);\n-    assert_eq!(parse(\"1.2\"), None);\n-    assert_eq!(parse(\"1.2\"), None);\n-    assert_eq!(parse(\"1\"), None);\n-    assert_eq!(parse(\"1.2\"), None);\n-    assert_eq!(parse(\"1.2.3-\"), None);\n-    assert_eq!(parse(\"a.b.c\"), None);\n-    assert_eq!(parse(\"1.2.3 abc\"), None);\n-\n-    assert!(parse(\"1.2.3\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(),\n-    }));\n-    assert!(parse(\"  1.2.3  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(),\n-    }));\n-    assert!(parse(\"1.2.3-alpha1\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!(),\n-    }));\n-    assert!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!()\n-    }));\n-    assert!(parse(\"1.2.3+build5\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"  1.2.3+build5  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_string()),Numeric(9)),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()),\n-                 Numeric(7),\n-                 AlphaNumeric(\"3aedf\".to_string()))\n-    }));\n-\n-}\n-\n-#[test]\n-fn test_eq() {\n-    assert_eq!(parse(\"1.2.3\"), parse(\"1.2.3\"));\n-    assert_eq!(parse(\"1.2.3-alpha1\"), parse(\"1.2.3-alpha1\"));\n-    assert_eq!(parse(\"1.2.3+build.42\"), parse(\"1.2.3+build.42\"));\n-    assert_eq!(parse(\"1.2.3-alpha1+42\"), parse(\"1.2.3-alpha1+42\"));\n-    assert_eq!(parse(\"1.2.3+23\"), parse(\"1.2.3+42\"));\n-}\n-\n-#[test]\n-fn test_ne() {\n-    assert!(parse(\"0.0.0\")       != parse(\"0.0.1\"));\n-    assert!(parse(\"0.0.0\")       != parse(\"0.1.0\"));\n-    assert!(parse(\"0.0.0\")       != parse(\"1.0.0\"));\n-    assert!(parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\"));\n-}\n-\n-#[test]\n-fn test_show() {\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3\").unwrap()),\n-               \"1.2.3\".to_string());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()),\n-               \"1.2.3-alpha1\".to_string());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3+build.42\").unwrap()),\n-               \"1.2.3+build.42\".to_string());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()),\n-               \"1.2.3-alpha1+42\".to_string());\n-}\n-\n-#[test]\n-fn test_to_string() {\n-    assert_eq!(parse(\"1.2.3\").unwrap().to_string(), \"1.2.3\".to_string());\n-    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_string(), \"1.2.3-alpha1\".to_string());\n-    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_string(), \"1.2.3+build.42\".to_string());\n-    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_string(), \"1.2.3-alpha1+42\".to_string());\n-}\n-\n-#[test]\n-fn test_lt() {\n-    assert!(parse(\"0.0.0\")          < parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.0.0\")          < parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.0\")          < parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3-alpha1\")   < parse(\"1.2.3\"));\n-    assert!(parse(\"1.2.3-alpha1\")   < parse(\"1.2.3-alpha2\"));\n-    assert!(!(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\")));\n-    assert!(!(parse(\"1.2.3+23\")     < parse(\"1.2.3+42\")));\n-}\n-\n-#[test]\n-fn test_le() {\n-    assert!(parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3+23\")     <= parse(\"1.2.3+42\"));\n-}\n-\n-#[test]\n-fn test_gt() {\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"0.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"1.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"1.2.0\"));\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"1.2.3-alpha1\"));\n-    assert!(parse(\"1.2.3\")          > parse(\"1.2.3-alpha2\"));\n-    assert!(!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\")));\n-    assert!(!(parse(\"1.2.3+23\")     > parse(\"1.2.3+42\")));\n-}\n-\n-#[test]\n-fn test_ge() {\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3+23\")     >= parse(\"1.2.3+42\"));\n-}\n-\n-#[test]\n-fn test_spec_order() {\n-    let vs = [\"1.0.0-alpha\",\n-              \"1.0.0-alpha.1\",\n-              \"1.0.0-alpha.beta\",\n-              \"1.0.0-beta\",\n-              \"1.0.0-beta.2\",\n-              \"1.0.0-beta.11\",\n-              \"1.0.0-rc.1\",\n-              \"1.0.0\"];\n-    let mut i = 1;\n-    while i < vs.len() {\n-        let a = parse(vs[i-1]).unwrap();\n-        let b = parse(vs[i]).unwrap();\n-        assert!(a < b);\n-        i += 1;\n-    }\n-}"}, {"sha": "bf9a959afffbda4d2380d20b2b7d6f93da9c11d6", "filename": "src/liburl/lib.rs", "status": "removed", "additions": 0, "deletions": 1243, "changes": 1243, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,1243 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types/fns concerning URLs (see RFC 3986)\n-\n-#![crate_name = \"url\"]\n-#![deprecated=\"This is being removed. Use rust-url instead. http://servo.github.io/rust-url/\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(default_type_params)]\n-\n-use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n-use std::fmt;\n-use std::from_str::FromStr;\n-use std::hash;\n-use std::uint;\n-use std::path::BytesContainer;\n-\n-/// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n-/// Identifier) that includes network location information, such as hostname or\n-/// port number.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::Url;\n-///\n-/// let raw = \"https://username@example.com:8080/foo/bar?baz=qux#quz\";\n-/// match Url::parse(raw) {\n-///     Ok(u) => println!(\"Parsed '{}'\", u),\n-///     Err(e) => println!(\"Couldn't parse '{}': {}\", raw, e),\n-/// }\n-/// ```\n-#[deriving(Clone, PartialEq, Eq)]\n-pub struct Url {\n-    /// The scheme part of a URL, such as `https` in the above example.\n-    pub scheme: String,\n-    /// A URL subcomponent for user authentication.  `username` in the above example.\n-    pub user: Option<UserInfo>,\n-    /// A domain name or IP address.  For example, `example.com`.\n-    pub host: String,\n-    /// A TCP port number, for example `8080`.\n-    pub port: Option<u16>,\n-    /// The path component of a URL, for example `/foo/bar?baz=qux#quz`.\n-    pub path: Path,\n-}\n-\n-#[deriving(Clone, PartialEq, Eq)]\n-pub struct Path {\n-    /// The path component of a URL, for example `/foo/bar`.\n-    pub path: String,\n-    /// The query component of a URL.\n-    /// `vec![(\"baz\".to_string(), \"qux\".to_string())]` represents the fragment\n-    /// `baz=qux` in the above example.\n-    pub query: Query,\n-    /// The fragment component, such as `quz`. Not including the leading `#` character.\n-    pub fragment: Option<String>\n-}\n-\n-/// An optional subcomponent of a URI authority component.\n-#[deriving(Clone, PartialEq, Eq)]\n-pub struct UserInfo {\n-    /// The user name.\n-    pub user: String,\n-    /// Password or other scheme-specific authentication information.\n-    pub pass: Option<String>\n-}\n-\n-/// Represents the query component of a URI.\n-pub type Query = Vec<(String, String)>;\n-\n-impl Url {\n-    pub fn new(scheme: String,\n-               user: Option<UserInfo>,\n-               host: String,\n-               port: Option<u16>,\n-               path: String,\n-               query: Query,\n-               fragment: Option<String>)\n-               -> Url {\n-        Url {\n-            scheme: scheme,\n-            user: user,\n-            host: host,\n-            port: port,\n-            path: Path::new(path, query, fragment)\n-        }\n-    }\n-\n-    /// Parses a URL, converting it from a string to a `Url` representation.\n-    ///\n-    /// # Arguments\n-    /// * rawurl - a string representing the full URL, including scheme.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Err(e)` if the string did not represent a valid URL, where `e` is a\n-    /// `String` error message. Otherwise, `Ok(u)` where `u` is a `Url` struct\n-    /// representing the URL.\n-    pub fn parse(rawurl: &str) -> DecodeResult<Url> {\n-        // scheme\n-        let (scheme, rest) = try!(get_scheme(rawurl));\n-\n-        // authority\n-        let (userinfo, host, port, rest) = try!(get_authority(rest));\n-\n-        // path\n-        let has_authority = host.len() > 0;\n-        let (path, rest) = try!(get_path(rest, has_authority));\n-\n-        // query and fragment\n-        let (query, fragment) = try!(get_query_fragment(rest));\n-\n-        let url = Url::new(scheme.to_string(),\n-                            userinfo,\n-                            host.to_string(),\n-                            port,\n-                            path,\n-                            query,\n-                            fragment);\n-        Ok(url)\n-    }\n-}\n-\n-#[deprecated=\"use `Url::parse`\"]\n-pub fn from_str(s: &str) -> Result<Url, String> {\n-    Url::parse(s)\n-}\n-\n-impl Path {\n-    pub fn new(path: String,\n-               query: Query,\n-               fragment: Option<String>)\n-               -> Path {\n-        Path {\n-            path: path,\n-            query: query,\n-            fragment: fragment,\n-        }\n-    }\n-\n-    /// Parses a URL path, converting it from a string to a `Path` representation.\n-    ///\n-    /// # Arguments\n-    /// * rawpath - a string representing the path component of a URL.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Err(e)` if the string did not represent a valid URL path, where `e` is a\n-    /// `String` error message. Otherwise, `Ok(p)` where `p` is a `Path` struct\n-    /// representing the URL path.\n-    pub fn parse(rawpath: &str) -> DecodeResult<Path> {\n-        let (path, rest) = try!(get_path(rawpath, false));\n-\n-        // query and fragment\n-        let (query, fragment) = try!(get_query_fragment(rest.as_slice()));\n-\n-        Ok(Path{ path: path, query: query, fragment: fragment })\n-    }\n-}\n-\n-#[deprecated=\"use `Path::parse`\"]\n-pub fn path_from_str(s: &str) -> Result<Path, String> {\n-    Path::parse(s)\n-}\n-\n-impl UserInfo {\n-    #[inline]\n-    pub fn new(user: String, pass: Option<String>) -> UserInfo {\n-        UserInfo { user: user, pass: pass }\n-    }\n-}\n-\n-fn encode_inner<T: BytesContainer>(c: T, full_url: bool) -> String {\n-    c.container_as_bytes().iter().fold(String::new(), |mut out, &b| {\n-        match b as char {\n-            // unreserved:\n-            'A' ... 'Z'\n-            | 'a' ... 'z'\n-            | '0' ... '9'\n-            | '-' | '.' | '_' | '~' => out.push_char(b as char),\n-\n-            // gen-delims:\n-            ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-            // sub-delims:\n-            '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-            '+' | ',' | ';' | '='\n-                if full_url => out.push_char(b as char),\n-\n-            ch => out.push_str(format!(\"%{:02X}\", ch as uint).as_slice()),\n-        };\n-\n-        out\n-    })\n-}\n-\n-/// Encodes a URI by replacing reserved characters with percent-encoded\n-/// character sequences.\n-///\n-/// This function is compliant with RFC 3986.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::encode;\n-///\n-/// let url = encode(\"https://example.com/Rust (programming language)\");\n-/// println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n-/// ```\n-pub fn encode<T: BytesContainer>(container: T) -> String {\n-    encode_inner(container, true)\n-}\n-\n-\n-/// Encodes a URI component by replacing reserved characters with percent-\n-/// encoded character sequences.\n-///\n-/// This function is compliant with RFC 3986.\n-pub fn encode_component<T: BytesContainer>(container: T) -> String {\n-    encode_inner(container, false)\n-}\n-\n-pub type DecodeResult<T> = Result<T, String>;\n-\n-/// Decodes a percent-encoded string representing a URI.\n-///\n-/// This will only decode escape sequences generated by `encode`.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::decode;\n-///\n-/// let url = decode(\"https://example.com/Rust%20(programming%20language)\");\n-/// println!(\"{}\", url); // https://example.com/Rust (programming language)\n-/// ```\n-pub fn decode<T: BytesContainer>(container: T) -> DecodeResult<String> {\n-    decode_inner(container, true)\n-}\n-\n-/// Decode a string encoded with percent encoding.\n-pub fn decode_component<T: BytesContainer>(container: T) -> DecodeResult<String> {\n-    decode_inner(container, false)\n-}\n-\n-fn decode_inner<T: BytesContainer>(c: T, full_url: bool) -> DecodeResult<String> {\n-    let mut out = String::new();\n-    let mut iter = c.container_as_bytes().iter().map(|&b| b);\n-\n-    loop {\n-        match iter.next() {\n-            Some(b) => match b as char {\n-                '%' => {\n-                    let bytes = match (iter.next(), iter.next()) {\n-                        (Some(one), Some(two)) => [one as u8, two as u8],\n-                        _ => return Err(format!(\"Malformed input: found '%' \\\n-                                                without two trailing bytes\")),\n-                    };\n-\n-                    // Only decode some characters if full_url:\n-                    match uint::parse_bytes(bytes, 16u).unwrap() as u8 as char {\n-                        // gen-delims:\n-                        ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                        // sub-delims:\n-                        '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                        '+' | ',' | ';' | '='\n-                            if full_url => {\n-                            out.push_char('%');\n-                            out.push_char(bytes[0u] as char);\n-                            out.push_char(bytes[1u] as char);\n-                        }\n-\n-                        ch => out.push_char(ch)\n-                    }\n-                }\n-                ch => out.push_char(ch)\n-            },\n-            None => return Ok(out),\n-        }\n-    }\n-}\n-\n-/// Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n-pub fn encode_form_urlencoded(m: &HashMap<String, Vec<String>>) -> String {\n-    fn encode_plus<T: Str>(s: &T) -> String {\n-        s.as_slice().bytes().fold(String::new(), |mut out, b| {\n-            match b as char {\n-              'A' ... 'Z'\n-              | 'a' ... 'z'\n-              | '0' ... '9'\n-              | '_' | '.' | '-' => out.push_char(b as char),\n-              ' ' => out.push_char('+'),\n-              ch => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n-            }\n-\n-            out\n-        })\n-    }\n-\n-    let mut first = true;\n-    m.iter().fold(String::new(), |mut out, (key, values)| {\n-        let key = encode_plus(key);\n-\n-        for value in values.iter() {\n-            if first {\n-                first = false;\n-            } else {\n-                out.push_char('&');\n-            }\n-\n-            out.push_str(key.as_slice());\n-            out.push_char('=');\n-            out.push_str(encode_plus(value).as_slice());\n-        }\n-\n-        out\n-    })\n-}\n-\n-/// Decode a string encoded with the 'application/x-www-form-urlencoded' media\n-/// type into a hashmap.\n-pub fn decode_form_urlencoded(s: &[u8])\n-                            -> DecodeResult<HashMap<String, Vec<String>>> {\n-    fn maybe_push_value(map: &mut HashMap<String, Vec<String>>,\n-                        key: String,\n-                        value: String) {\n-        if key.len() > 0 && value.len() > 0 {\n-            match map.entry(key) {\n-                Vacant(entry) => { entry.set(vec![value]); },\n-                Occupied(mut entry) => { entry.get_mut().push(value); },\n-            }\n-        }\n-    }\n-\n-    let mut out = HashMap::new();\n-    let mut iter = s.iter().map(|&x| x);\n-\n-    let mut key = String::new();\n-    let mut value = String::new();\n-    let mut parsing_key = true;\n-\n-    loop {\n-        match iter.next() {\n-            Some(b) => match b as char {\n-                '&' | ';' => {\n-                    maybe_push_value(&mut out, key, value);\n-\n-                    parsing_key = true;\n-                    key = String::new();\n-                    value = String::new();\n-                }\n-                '=' => parsing_key = false,\n-                ch => {\n-                    let ch = match ch {\n-                        '%' => {\n-                            let bytes = match (iter.next(), iter.next()) {\n-                                (Some(one), Some(two)) => [one as u8, two as u8],\n-                                _ => return Err(format!(\"Malformed input: found \\\n-                                                '%' without two trailing bytes\"))\n-                            };\n-\n-                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n-                        }\n-                        '+' => ' ',\n-                        ch => ch\n-                    };\n-\n-                    if parsing_key {\n-                        key.push_char(ch)\n-                    } else {\n-                        value.push_char(ch)\n-                    }\n-                }\n-            },\n-            None => {\n-                maybe_push_value(&mut out, key, value);\n-                return Ok(out)\n-            }\n-        }\n-    }\n-}\n-\n-fn split_char_first(s: &str, c: char) -> (&str, &str) {\n-    let mut iter = s.splitn(1, c);\n-\n-    match (iter.next(), iter.next()) {\n-        (Some(a), Some(b)) => (a, b),\n-        (Some(a), None) => (a, \"\"),\n-        (None, _) => unreachable!(),\n-    }\n-}\n-\n-impl fmt::Show for UserInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.pass {\n-            Some(ref pass) => write!(f, \"{}:{}@\", self.user, *pass),\n-            None => write!(f, \"{}@\", self.user),\n-        }\n-    }\n-}\n-\n-fn query_from_str(rawquery: &str) -> DecodeResult<Query> {\n-    let mut query: Query = vec!();\n-    if !rawquery.is_empty() {\n-        for p in rawquery.split('&') {\n-            let (k, v) = split_char_first(p, '=');\n-            query.push((try!(decode_component(k)),\n-                        try!(decode_component(v))));\n-        }\n-    }\n-\n-    Ok(query)\n-}\n-\n-/// Converts an instance of a URI `Query` type to a string.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// let query = vec![(\"title\".to_string(), \"The Village\".to_string()),\n-///                  (\"north\".to_string(), \"52.91\".to_string()),\n-///                  (\"west\".to_string(), \"4.10\".to_string())];\n-/// println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n-/// ```\n-pub fn query_to_str(query: &Query) -> String {\n-    query.iter().enumerate().fold(String::new(), |mut out, (i, &(ref k, ref v))| {\n-        if i != 0 {\n-            out.push_char('&');\n-        }\n-\n-        out.push_str(encode_component(k.as_slice()).as_slice());\n-        out.push_char('=');\n-        out.push_str(encode_component(v.as_slice()).as_slice());\n-        out\n-    })\n-}\n-\n-/// Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n-///\n-/// Does not include the separating `:` character.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::get_scheme;\n-///\n-/// let scheme = match get_scheme(\"https://example.com/\") {\n-///     Ok((sch, _)) => sch,\n-///     Err(_) => \"(None)\",\n-/// };\n-/// println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n-/// ```\n-pub fn get_scheme(rawurl: &str) -> DecodeResult<(&str, &str)> {\n-    for (i,c) in rawurl.chars().enumerate() {\n-        let result = match c {\n-            'A' ... 'Z'\n-            | 'a' ... 'z' => continue,\n-            '0' ... '9' | '+' | '-' | '.' => {\n-                if i != 0 { continue }\n-\n-                Err(\"url: Scheme must begin with a letter.\".to_string())\n-            }\n-            ':' => {\n-                if i == 0 {\n-                    Err(\"url: Scheme cannot be empty.\".to_string())\n-                } else {\n-                    Ok((rawurl.slice(0,i), rawurl.slice(i+1,rawurl.len())))\n-                }\n-            }\n-            _ => Err(\"url: Invalid character in scheme.\".to_string()),\n-        };\n-\n-        return result;\n-    }\n-\n-    Err(\"url: Scheme must be terminated with a colon.\".to_string())\n-}\n-\n-// returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority(rawurl: &str) ->\n-    DecodeResult<(Option<UserInfo>, &str, Option<u16>, &str)> {\n-    enum State {\n-        Start, // starting state\n-        PassHostPort, // could be in user or port\n-        Ip6Port, // either in ipv6 host or port\n-        Ip6Host, // are in an ipv6 host\n-        InHost, // are in a host - may be ipv6, but don't know yet\n-        InPort // are in port\n-    }\n-\n-    #[deriving(Clone, PartialEq)]\n-    enum Input {\n-        Digit, // all digits\n-        Hex, // digits and letters a-f\n-        Unreserved // all other legal characters\n-    }\n-\n-    if !rawurl.starts_with(\"//\") {\n-        // there is no authority.\n-        return Ok((None, \"\", None, rawurl));\n-    }\n-\n-    let len = rawurl.len();\n-    let mut st = Start;\n-    let mut input = Digit; // most restricted, start here.\n-\n-    let mut userinfo = None;\n-    let mut host = \"\";\n-    let mut port = None;\n-\n-    let mut colon_count = 0u;\n-    let mut pos = 0;\n-    let mut begin = 2;\n-    let mut end = len;\n-\n-    for (i,c) in rawurl.chars().enumerate()\n-                               // ignore the leading '//' handled by early return\n-                               .skip(2) {\n-        // deal with input class first\n-        match c {\n-            '0' ... '9' => (),\n-            'A' ... 'F'\n-            | 'a' ... 'f' => {\n-                if input == Digit {\n-                    input = Hex;\n-                }\n-            }\n-            'G' ... 'Z'\n-            | 'g' ... 'z'\n-            | '-' | '.' | '_' | '~' | '%'\n-            | '&' |'\\'' | '(' | ')' | '+'\n-            | '!' | '*' | ',' | ';' | '=' => input = Unreserved,\n-            ':' | '@' | '?' | '#' | '/' => {\n-                // separators, don't change anything\n-            }\n-            _ => return Err(\"Illegal character in authority\".to_string()),\n-        }\n-\n-        // now process states\n-        match c {\n-          ':' => {\n-            colon_count += 1;\n-            match st {\n-              Start => {\n-                pos = i;\n-                st = PassHostPort;\n-              }\n-              PassHostPort => {\n-                // multiple colons means ipv6 address.\n-                if input == Unreserved {\n-                    return Err(\n-                        \"Illegal characters in IPv6 address.\".to_string());\n-                }\n-                st = Ip6Host;\n-              }\n-              InHost => {\n-                pos = i;\n-                if input == Unreserved {\n-                    // must be port\n-                    host = rawurl.slice(begin, i);\n-                    st = InPort;\n-                } else {\n-                    // can't be sure whether this is an ipv6 address or a port\n-                    st = Ip6Port;\n-                }\n-              }\n-              Ip6Port => {\n-                if input == Unreserved {\n-                    return Err(\"Illegal characters in authority.\".to_string());\n-                }\n-                st = Ip6Host;\n-              }\n-              Ip6Host => {\n-                if colon_count > 7 {\n-                    host = rawurl.slice(begin, i);\n-                    pos = i;\n-                    st = InPort;\n-                }\n-              }\n-              _ => return Err(\"Invalid ':' in authority.\".to_string()),\n-            }\n-            input = Digit; // reset input class\n-          }\n-\n-          '@' => {\n-            input = Digit; // reset input class\n-            colon_count = 0; // reset count\n-            match st {\n-              Start => {\n-                let user = rawurl.slice(begin, i).to_string();\n-                userinfo = Some(UserInfo::new(user, None));\n-                st = InHost;\n-              }\n-              PassHostPort => {\n-                let user = rawurl.slice(begin, pos).to_string();\n-                let pass = rawurl.slice(pos+1, i).to_string();\n-                userinfo = Some(UserInfo::new(user, Some(pass)));\n-                st = InHost;\n-              }\n-              _ => return Err(\"Invalid '@' in authority.\".to_string()),\n-            }\n-            begin = i+1;\n-          }\n-\n-          '?' | '#' | '/' => {\n-            end = i;\n-            break;\n-          }\n-          _ => ()\n-        }\n-    }\n-\n-    // finish up\n-    match st {\n-      Start => host = rawurl.slice(begin, end),\n-      PassHostPort\n-      | Ip6Port => {\n-        if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_string());\n-        }\n-        host = rawurl.slice(begin, pos);\n-        port = Some(rawurl.slice(pos+1, end));\n-      }\n-      Ip6Host\n-      | InHost => host = rawurl.slice(begin, end),\n-      InPort => {\n-        if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_string());\n-        }\n-        port = Some(rawurl.slice(pos+1, end));\n-      }\n-    }\n-\n-    let rest = rawurl.slice(end, len);\n-    // If we have a port string, ensure it parses to u16.\n-    let port = match port {\n-        None => None,\n-        opt => match opt.and_then(|p| FromStr::from_str(p)) {\n-            None => return Err(format!(\"Failed to parse port: {}\", port)),\n-            opt => opt\n-        }\n-    };\n-\n-    Ok((userinfo, host, port, rest))\n-}\n-\n-\n-// returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: &str, is_authority: bool) -> DecodeResult<(String, &str)> {\n-    let len = rawurl.len();\n-    let mut end = len;\n-    for (i,c) in rawurl.chars().enumerate() {\n-        match c {\n-          'A' ... 'Z'\n-          | 'a' ... 'z'\n-          | '0' ... '9'\n-          | '&' |'\\'' | '(' | ')' | '.'\n-          | '@' | ':' | '%' | '/' | '+'\n-          | '!' | '*' | ',' | ';' | '='\n-          | '_' | '-' | '~' => continue,\n-          '?' | '#' => {\n-            end = i;\n-            break;\n-          }\n-          _ => return Err(\"Invalid character in path.\".to_string())\n-        }\n-    }\n-\n-    if is_authority && end != 0 && !rawurl.starts_with(\"/\") {\n-        Err(\"Non-empty path must begin with \\\n-            '/' in presence of authority.\".to_string())\n-    } else {\n-        Ok((try!(decode_component(rawurl.slice(0, end))),\n-            rawurl.slice(end, len)))\n-    }\n-}\n-\n-// returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: &str) -> DecodeResult<(Query, Option<String>)> {\n-    let (before_fragment, raw_fragment) = split_char_first(rawurl, '#');\n-\n-    // Parse the fragment if available\n-    let fragment = match raw_fragment {\n-        \"\" => None,\n-        raw => Some(try!(decode_component(raw)))\n-    };\n-\n-    match before_fragment.slice_shift_char() {\n-        (Some('?'), rest) => Ok((try!(query_from_str(rest)), fragment)),\n-        (None, \"\") => Ok((vec!(), fragment)),\n-        _ => Err(format!(\"Query didn't start with '?': '{}..'\", before_fragment)),\n-    }\n-}\n-\n-impl FromStr for Url {\n-    fn from_str(s: &str) -> Option<Url> {\n-        Url::parse(s).ok()\n-    }\n-}\n-\n-impl FromStr for Path {\n-    fn from_str(s: &str) -> Option<Path> {\n-        Path::parse(s).ok()\n-    }\n-}\n-\n-impl fmt::Show for Url {\n-    /// Converts a URL from `Url` to string representation.\n-    ///\n-    /// # Returns\n-    ///\n-    /// A string that contains the formatted URL. Note that this will usually\n-    /// be an inverse of `from_str` but might strip out unneeded separators;\n-    /// for example, \"http://somehost.com?\", when parsed and formatted, will\n-    /// result in just \"http://somehost.com\".\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}:\", self.scheme));\n-\n-        if !self.host.is_empty() {\n-            try!(write!(f, \"//\"));\n-            match self.user {\n-                Some(ref user) => try!(write!(f, \"{}\", *user)),\n-                None => {}\n-            }\n-            match self.port {\n-                Some(ref port) => try!(write!(f, \"{}:{}\", self.host,\n-                                                *port)),\n-                None => try!(write!(f, \"{}\", self.host)),\n-            }\n-        }\n-\n-        write!(f, \"{}\", self.path)\n-    }\n-}\n-\n-impl fmt::Show for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", self.path));\n-        if !self.query.is_empty() {\n-            try!(write!(f, \"?{}\", query_to_str(&self.query)))\n-        }\n-\n-        match self.fragment {\n-            Some(ref fragment) => {\n-                write!(f, \"#{}\", encode_component(fragment.as_slice()))\n-            }\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Url {\n-    fn hash(&self, state: &mut S) {\n-        self.to_string().hash(state)\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Path {\n-    fn hash(&self, state: &mut S) {\n-        self.to_string().hash(state)\n-    }\n-}\n-\n-// Put a few tests outside of the 'test' module so they can test the internal\n-// functions and those functions don't need 'pub'\n-\n-#[test]\n-fn test_split_char_first() {\n-    let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\");\n-    assert_eq!(v, \" sweet world\");\n-\n-    let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\");\n-    assert_eq!(v, \"\");\n-}\n-\n-#[test]\n-fn test_get_authority() {\n-    let (u, h, p, r) = get_authority(\n-        \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-    assert_eq!(h, \"rust-lang.org\");\n-    assert!(p.is_none());\n-    assert_eq!(r, \"/something\");\n-\n-    let (u, h, p, r) = get_authority(\n-        \"//rust-lang.org:8000?something\").unwrap();\n-    assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\");\n-    assert_eq!(p, Some(8000));\n-    assert_eq!(r, \"?something\");\n-\n-    let (u, h, p, r) = get_authority(\"//rust-lang.org#blah\").unwrap();\n-    assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\");\n-    assert!(p.is_none());\n-    assert_eq!(r, \"#blah\");\n-\n-    // ipv6 tests\n-    let (_, h, _, _) = get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-\n-    let (_, h, p, _) = get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert_eq!(p, Some(8000));\n-\n-    let (u, h, p, _) = get_authority(\n-        \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n-    ).unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"us\".to_string(), Some(\"p\".to_string()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert_eq!(p, Some(8000));\n-\n-    // invalid authorities;\n-    assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n-    assert!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n-    assert!(get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n-    assert!(get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n-    // outside u16 range\n-    assert!(get_authority(\"//user:pass@rust-lang:65536\").is_err());\n-\n-    // these parse as empty, because they don't start with '//'\n-    let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\");\n-    let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\");\n-}\n-\n-#[test]\n-fn test_get_path() {\n-    let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert_eq!(p, \"/something+ orother\".to_string());\n-    assert_eq!(r, \"\");\n-    let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert_eq!(p, \"test@email.com\".to_string());\n-    assert_eq!(r, \"#fragment\");\n-    let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n-    assert_eq!(p, \"/gen/:addr=\".to_string());\n-    assert_eq!(r, \"?q=v\");\n-\n-    //failure cases\n-    assert!(get_path(\"something?q\", true).is_err());\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use {encode_form_urlencoded, decode_form_urlencoded, decode, encode,\n-        encode_component, decode_component, UserInfo, get_scheme, Url, Path};\n-\n-    use std::collections::HashMap;\n-    use std::path::BytesContainer;\n-\n-    #[test]\n-    fn test_url_parse() {\n-        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-\n-        assert_eq!(u.scheme, \"http\".to_string());\n-        assert_eq!(u.user, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-        assert_eq!(u.host, \"rust-lang.org\".to_string());\n-        assert_eq!(u.port, Some(8080));\n-        assert_eq!(u.path.path, \"/doc/~u\".to_string());\n-        assert_eq!(u.path.query, vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(u.path.fragment, Some(\"something\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_path_parse() {\n-        let path = \"/doc/~u?s=v#something\";\n-        let u = from_str::<Path>(path).unwrap();\n-\n-        assert_eq!(u.path, \"/doc/~u\".to_string());\n-        assert_eq!(u.query, vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(u.fragment, Some(\"something\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_url_parse_host_slash() {\n-        let urlstr = \"http://0.42.42.42/\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.host, \"0.42.42.42\".to_string());\n-        assert_eq!(url.path.path, \"/\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_path_parse_host_slash() {\n-        let pathstr = \"/\";\n-        let path = from_str::<Path>(pathstr).unwrap();\n-        assert_eq!(path.path, \"/\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_url_host_with_port() {\n-        let urlstr = \"scheme://host:1234\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.scheme, \"scheme\".to_string());\n-        assert_eq!(url.host, \"host\".to_string());\n-        assert_eq!(url.port, Some(1234));\n-        // is empty path really correct? Other tests think so\n-        assert_eq!(url.path.path, \"\".to_string());\n-\n-        let urlstr = \"scheme://host:1234/\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.scheme, \"scheme\".to_string());\n-        assert_eq!(url.host, \"host\".to_string());\n-        assert_eq!(url.port, Some(1234));\n-        assert_eq!(url.path.path, \"/\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_url_with_underscores() {\n-        let urlstr = \"http://dotcom.com/file_name.html\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.path.path, \"/file_name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_path_with_underscores() {\n-        let pathstr = \"/file_name.html\";\n-        let path = from_str::<Path>(pathstr).unwrap();\n-        assert_eq!(path.path, \"/file_name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_url_with_dashes() {\n-        let urlstr = \"http://dotcom.com/file-name.html\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.path.path, \"/file-name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_path_with_dashes() {\n-        let pathstr = \"/file-name.html\";\n-        let path = from_str::<Path>(pathstr).unwrap();\n-        assert_eq!(path.path, \"/file-name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_no_scheme() {\n-        assert!(get_scheme(\"noschemehere.html\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_invalid_scheme_errors() {\n-        assert!(Url::parse(\"99://something\").is_err());\n-        assert!(Url::parse(\"://something\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_full_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_userless_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc?s=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_queryless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_empty_query_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?#something\";\n-        let should_be = \"http://user:pass@rust-lang.org/doc#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), should_be);\n-    }\n-\n-    #[test]\n-    fn test_fragmentless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?q=v\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_minimal_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_url_with_port_parse_and_format() {\n-        let url = \"http://rust-lang.org:80/doc\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_scheme_host_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_pathless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org?q=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_scheme_host_fragment_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_url_component_encoding() {\n-        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert!(u.path.path == \"/doc uments\".to_string());\n-        assert!(u.path.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_path_component_encoding() {\n-        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let p = from_str::<Path>(path).unwrap();\n-        assert!(p.path == \"/doc uments\".to_string());\n-        assert!(p.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_url_without_authority() {\n-        let url = \"mailto:test@email.com\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_encode() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(encode(input), expected.to_string())\n-        }\n-\n-        t(\"\", \"\");\n-        t(\"http://example.com\", \"http://example.com\");\n-        t(\"foo bar% baz\", \"foo%20bar%25%20baz\");\n-        t(\" \", \"%20\");\n-        t(\"!\", \"!\");\n-        t(\"\\\"\", \"\\\"\");\n-        t(\"#\", \"#\");\n-        t(\"$\", \"$\");\n-        t(\"%\", \"%25\");\n-        t(\"&\", \"&\");\n-        t(\"'\", \"%27\");\n-        t(\"(\", \"(\");\n-        t(\")\", \")\");\n-        t(\"*\", \"*\");\n-        t(\"+\", \"+\");\n-        t(\",\", \",\");\n-        t(\"/\", \"/\");\n-        t(\":\", \":\");\n-        t(\";\", \";\");\n-        t(\"=\", \"=\");\n-        t(\"?\", \"?\");\n-        t(\"@\", \"@\");\n-        t(\"[\", \"[\");\n-        t(\"]\", \"]\");\n-        t(\"\\0\", \"%00\");\n-        t(\"\\n\", \"%0A\");\n-\n-        let a: &[_] = &[0u8, 10, 37];\n-        t(a, \"%00%0A%25\");\n-    }\n-\n-    #[test]\n-    fn test_encode_component() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(encode_component(input), expected.to_string())\n-        }\n-\n-        t(\"\", \"\");\n-        t(\"http://example.com\", \"http%3A%2F%2Fexample.com\");\n-        t(\"foo bar% baz\", \"foo%20bar%25%20baz\");\n-        t(\" \", \"%20\");\n-        t(\"!\", \"%21\");\n-        t(\"#\", \"%23\");\n-        t(\"$\", \"%24\");\n-        t(\"%\", \"%25\");\n-        t(\"&\", \"%26\");\n-        t(\"'\", \"%27\");\n-        t(\"(\", \"%28\");\n-        t(\")\", \"%29\");\n-        t(\"*\", \"%2A\");\n-        t(\"+\", \"%2B\");\n-        t(\",\", \"%2C\");\n-        t(\"/\", \"%2F\");\n-        t(\":\", \"%3A\");\n-        t(\";\", \"%3B\");\n-        t(\"=\", \"%3D\");\n-        t(\"?\", \"%3F\");\n-        t(\"@\", \"%40\");\n-        t(\"[\", \"%5B\");\n-        t(\"]\", \"%5D\");\n-        t(\"\\0\", \"%00\");\n-        t(\"\\n\", \"%0A\");\n-\n-        let a: &[_] = &[0u8, 10, 37];\n-        t(a, \"%00%0A%25\");\n-    }\n-\n-    #[test]\n-    fn test_decode() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(decode(input), Ok(expected.to_string()))\n-        }\n-\n-        assert!(decode(\"sadsadsda%\").is_err());\n-        assert!(decode(\"waeasd%4\").is_err());\n-        t(\"\", \"\");\n-        t(\"abc/def 123\", \"abc/def 123\");\n-        t(\"abc%2Fdef%20123\", \"abc%2Fdef 123\");\n-        t(\"%20\", \" \");\n-        t(\"%21\", \"%21\");\n-        t(\"%22\", \"%22\");\n-        t(\"%23\", \"%23\");\n-        t(\"%24\", \"%24\");\n-        t(\"%25\", \"%\");\n-        t(\"%26\", \"%26\");\n-        t(\"%27\", \"'\");\n-        t(\"%28\", \"%28\");\n-        t(\"%29\", \"%29\");\n-        t(\"%2A\", \"%2A\");\n-        t(\"%2B\", \"%2B\");\n-        t(\"%2C\", \"%2C\");\n-        t(\"%2F\", \"%2F\");\n-        t(\"%3A\", \"%3A\");\n-        t(\"%3B\", \"%3B\");\n-        t(\"%3D\", \"%3D\");\n-        t(\"%3F\", \"%3F\");\n-        t(\"%40\", \"%40\");\n-        t(\"%5B\", \"%5B\");\n-        t(\"%5D\", \"%5D\");\n-\n-        t(\"%00%0A%25\".as_bytes(), \"\\0\\n%\");\n-    }\n-\n-    #[test]\n-    fn test_decode_component() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(decode_component(input), Ok(expected.to_string()))\n-        }\n-\n-        assert!(decode_component(\"asacsa%\").is_err());\n-        assert!(decode_component(\"acsas%4\").is_err());\n-        t(\"\", \"\");\n-        t(\"abc/def 123\", \"abc/def 123\");\n-        t(\"abc%2Fdef%20123\", \"abc/def 123\");\n-        t(\"%20\", \" \");\n-        t(\"%21\", \"!\");\n-        t(\"%22\", \"\\\"\");\n-        t(\"%23\", \"#\");\n-        t(\"%24\", \"$\");\n-        t(\"%25\", \"%\");\n-        t(\"%26\", \"&\");\n-        t(\"%27\", \"'\");\n-        t(\"%28\", \"(\");\n-        t(\"%29\", \")\");\n-        t(\"%2A\", \"*\");\n-        t(\"%2B\", \"+\");\n-        t(\"%2C\", \",\");\n-        t(\"%2F\", \"/\");\n-        t(\"%3A\", \":\");\n-        t(\"%3B\", \";\");\n-        t(\"%3D\", \"=\");\n-        t(\"%3F\", \"?\");\n-        t(\"%40\", \"@\");\n-        t(\"%5B\", \"[\");\n-        t(\"%5D\", \"]\");\n-\n-        t(\"%00%0A%25\".as_bytes(), \"\\0\\n%\");\n-    }\n-\n-    #[test]\n-    fn test_encode_form_urlencoded() {\n-        let mut m = HashMap::new();\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_string());\n-\n-        m.insert(\"\".to_string(), vec!());\n-        m.insert(\"foo\".to_string(), vec!());\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_string());\n-\n-        let mut m = HashMap::new();\n-        m.insert(\"foo\".to_string(), vec!(\"bar\".to_string(), \"123\".to_string()));\n-        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_string());\n-\n-        let mut m = HashMap::new();\n-        m.insert(\"foo bar\".to_string(), vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n-        assert_eq!(encode_form_urlencoded(&m),\n-                    \"foo+bar=abc&foo+bar=12+%3D+34\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_decode_form_urlencoded() {\n-        assert_eq!(decode_form_urlencoded([]).unwrap().len(), 0);\n-\n-        let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n-        let form = decode_form_urlencoded(s).unwrap();\n-        assert_eq!(form.len(), 2);\n-        assert_eq!(form.get(&\"a\".to_string()), &vec!(\"1\".to_string()));\n-        assert_eq!(form.get(&\"foo bar\".to_string()),\n-                   &vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n-    }\n-}"}, {"sha": "c041ca3799dc4891f154d85a20cc773b4996bbcf", "filename": "src/libuuid/lib.rs", "status": "removed", "additions": 0, "deletions": 865, "changes": 865, "blob_url": "https://github.com/rust-lang/rust/blob/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c121cbab35c9ff9ba133c578976a4ec35c011bcf/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=c121cbab35c9ff9ba133c578976a4ec35c011bcf", "patch": "@@ -1,865 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Generate and parse UUIDs\n-\n-Provides support for Universally Unique Identifiers (UUIDs). A UUID is a\n-unique 128-bit number, stored as 16 octets.  UUIDs are used to  assign unique\n-identifiers to entities without requiring a central allocating authority.\n-\n-They are particularly useful in distributed systems, though can be used in\n-disparate areas, such as databases and network protocols.  Typically a UUID is\n-displayed in a readable string form as a sequence of hexadecimal digits,\n-separated into groups by hyphens.\n-\n-The uniqueness property is not strictly guaranteed, however for all practical\n-purposes, it can be assumed that an unintentional collision would be extremely\n-unlikely.\n-\n-# Examples\n-\n-To create a new random (V4) UUID and print it out in hexadecimal form:\n-\n-```rust\n-# #![allow(deprecated)]\n-# extern crate uuid;\n-use uuid::Uuid;\n-\n-fn main() {\n-    let uuid1 = Uuid::new_v4();\n-    println!(\"{}\", uuid1.to_string());\n-}\n-```\n-\n-# Strings\n-\n-Examples of string representations:\n-\n-* simple: `936DA01F9ABD4d9d80C702AF85C822A8`\n-* hyphenated: `550e8400-e29b-41d4-a716-446655440000`\n-* urn: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n-\n-# References\n-\n-* [Wikipedia: Universally Unique Identifier](\n-    http://en.wikipedia.org/wiki/Universally_unique_identifier)\n-* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](\n-    http://tools.ietf.org/html/rfc4122)\n-\n-*/\n-\n-#![crate_name = \"uuid\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/uuid\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-\n-#![feature(default_type_params)]\n-\n-// test harness access\n-#[cfg(test)]\n-extern crate test;\n-extern crate serialize;\n-\n-use std::char::Char;\n-use std::default::Default;\n-use std::fmt;\n-use std::from_str::FromStr;\n-use std::hash;\n-use std::mem::{transmute,transmute_copy};\n-use std::num::FromStrRadix;\n-use std::rand;\n-use std::rand::Rng;\n-use std::slice;\n-\n-use serialize::{Encoder, Encodable, Decoder, Decodable};\n-\n-/// A 128-bit (16 byte) buffer containing the ID\n-pub type UuidBytes = [u8, ..16];\n-\n-/// The version of the UUID, denoting the generating algorithm\n-#[deriving(PartialEq)]\n-pub enum UuidVersion {\n-    /// Version 1: MAC address\n-    Version1Mac    = 1,\n-    /// Version 2: DCE Security\n-    Version2Dce    = 2,\n-    /// Version 3: MD5 hash\n-    Version3Md5    = 3,\n-    /// Version 4: Random\n-    Version4Random = 4,\n-    /// Version 5: SHA-1 hash\n-    Version5Sha1   = 5,\n-}\n-\n-/// The reserved variants of UUIDs\n-#[deriving(PartialEq)]\n-pub enum UuidVariant {\n-    /// Reserved by the NCS for backward compatibility\n-    VariantNCS,\n-    /// As described in the RFC4122 Specification (default)\n-    VariantRFC4122,\n-    /// Reserved by Microsoft for backward compatibility\n-    VariantMicrosoft,\n-    /// Reserved for future expansion\n-    VariantFuture,\n-}\n-\n-/// A Universally Unique Identifier (UUID)\n-pub struct Uuid {\n-    /// The 128-bit number stored in 16 bytes\n-    bytes: UuidBytes\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Uuid {\n-    fn hash(&self, state: &mut S) {\n-        self.bytes.hash(state)\n-    }\n-}\n-\n-/// A UUID stored as fields (identical to UUID, used only for conversions)\n-struct UuidFields {\n-    /// First field, 32-bit word\n-    data1: u32,\n-    /// Second field, 16-bit short\n-    data2: u16,\n-    /// Third field, 16-bit short\n-    data3: u16,\n-    /// Fourth field, 8 bytes\n-    data4: [u8, ..8]\n-}\n-\n-/// Error details for string parsing failures\n-#[allow(missing_doc)]\n-pub enum ParseError {\n-    ErrorInvalidLength(uint),\n-    ErrorInvalidCharacter(char, uint),\n-    ErrorInvalidGroups(uint),\n-    ErrorInvalidGroupLength(uint, uint, uint),\n-}\n-\n-/// Converts a ParseError to a string\n-impl fmt::Show for ParseError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ErrorInvalidLength(found) =>\n-                write!(f, \"Invalid length; expecting 32, 36 or 45 chars, \\\n-                           found {}\", found),\n-            ErrorInvalidCharacter(found, pos) =>\n-                write!(f, \"Invalid character; found `{}` (0x{:02x}) at \\\n-                           offset {}\", found, found as uint, pos),\n-            ErrorInvalidGroups(found) =>\n-                write!(f, \"Malformed; wrong number of groups: expected 1 \\\n-                           or 5, found {}\", found),\n-            ErrorInvalidGroupLength(group, found, expecting) =>\n-                write!(f, \"Malformed; length of group {} was {}, \\\n-                           expecting {}\", group, found, expecting),\n-        }\n-    }\n-}\n-\n-// Length of each hyphenated group in hex digits\n-#[allow(non_uppercase_statics)]\n-static UuidGroupLens: [uint, ..5] = [8u, 4u, 4u, 4u, 12u];\n-\n-/// UUID support\n-impl Uuid {\n-    /// Returns a nil or empty UUID (containing all zeroes)\n-    pub fn nil() -> Uuid {\n-        let uuid = Uuid{ bytes: [0, .. 16] };\n-        uuid\n-    }\n-\n-    /// Create a new UUID of the specified version\n-    pub fn new(v: UuidVersion) -> Option<Uuid> {\n-        match v {\n-            Version4Random => Some(Uuid::new_v4()),\n-            _ => None\n-        }\n-    }\n-\n-    /// Creates a new random UUID\n-    ///\n-    /// Uses the `rand` module's default RNG task as the source\n-    /// of random numbers. Use the rand::Rand trait to supply\n-    /// a custom generator if required.\n-    pub fn new_v4() -> Uuid {\n-        let ub = rand::task_rng().gen_iter::<u8>().take(16).collect::<Vec<_>>();\n-        let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n-        uuid.set_variant(VariantRFC4122);\n-        uuid.set_version(Version4Random);\n-        uuid\n-    }\n-\n-    /// Creates a UUID using the supplied field values\n-    ///\n-    /// # Arguments\n-    /// * `d1` A 32-bit word\n-    /// * `d2` A 16-bit word\n-    /// * `d3` A 16-bit word\n-    /// * `d4` Array of 8 octets\n-    pub fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Uuid {\n-        // First construct a temporary field-based struct\n-        let mut fields = UuidFields {\n-                data1: 0,\n-                data2: 0,\n-                data3: 0,\n-                data4: [0, ..8]\n-        };\n-\n-        fields.data1 = d1.to_be();\n-        fields.data2 = d2.to_be();\n-        fields.data3 = d3.to_be();\n-        slice::bytes::copy_memory(fields.data4, d4);\n-\n-        unsafe {\n-            transmute(fields)\n-        }\n-    }\n-\n-    /// Creates a UUID using the supplied bytes\n-    ///\n-    /// # Arguments\n-    /// * `b` An array or slice of 16 bytes\n-    pub fn from_bytes(b: &[u8]) -> Option<Uuid> {\n-        if b.len() != 16 {\n-            return None\n-        }\n-\n-        let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, b);\n-        Some(uuid)\n-    }\n-\n-    /// Specifies the variant of the UUID structure\n-    fn set_variant(&mut self, v: UuidVariant) {\n-        // Octet 8 contains the variant in the most significant 3 bits\n-        match v {\n-            VariantNCS =>        // b0xx...\n-                self.bytes[8] =  self.bytes[8] & 0x7f,\n-            VariantRFC4122 =>    // b10x...\n-                self.bytes[8] = (self.bytes[8] & 0x3f) | 0x80,\n-            VariantMicrosoft =>  // b110...\n-                self.bytes[8] = (self.bytes[8] & 0x1f) | 0xc0,\n-            VariantFuture =>     // b111...\n-                self.bytes[8] = (self.bytes[8] & 0x1f) | 0xe0,\n-        }\n-    }\n-\n-    /// Returns the variant of the UUID structure\n-    ///\n-    /// This determines the interpretation of the structure of the UUID.\n-    /// Currently only the RFC4122 variant is generated by this module.\n-    ///\n-    /// * [Variant Reference](http://tools.ietf.org/html/rfc4122#section-4.1.1)\n-    pub fn get_variant(&self) -> Option<UuidVariant> {\n-        if self.bytes[8] & 0x80 == 0x00 {\n-            Some(VariantNCS)\n-        } else if self.bytes[8] & 0xc0 == 0x80 {\n-            Some(VariantRFC4122)\n-        } else if self.bytes[8] & 0xe0 == 0xc0  {\n-            Some(VariantMicrosoft)\n-        } else if self.bytes[8] & 0xe0 == 0xe0 {\n-            Some(VariantFuture)\n-        } else  {\n-            None\n-        }\n-    }\n-\n-    /// Specifies the version number of the UUID\n-    fn set_version(&mut self, v: UuidVersion) {\n-        self.bytes[6] = (self.bytes[6] & 0xF) | ((v as u8) << 4);\n-    }\n-\n-    /// Returns the version number of the UUID\n-    ///\n-    /// This represents the algorithm used to generate the contents.\n-    ///\n-    /// Currently only the Random (V4) algorithm is supported by this\n-    /// module.  There are security and privacy implications for using\n-    /// older versions - see [Wikipedia: Universally Unique Identifier](\n-    /// http://en.wikipedia.org/wiki/Universally_unique_identifier) for\n-    /// details.\n-    ///\n-    /// * [Version Reference](http://tools.ietf.org/html/rfc4122#section-4.1.3)\n-    pub fn get_version_num(&self) -> uint {\n-        (self.bytes[6] >> 4) as uint\n-    }\n-\n-    /// Returns the version of the UUID\n-    ///\n-    /// This represents the algorithm used to generate the contents\n-    pub fn get_version(&self) -> Option<UuidVersion> {\n-        let v = self.bytes[6] >> 4;\n-        match v {\n-            1 => Some(Version1Mac),\n-            2 => Some(Version2Dce),\n-            3 => Some(Version3Md5),\n-            4 => Some(Version4Random),\n-            5 => Some(Version5Sha1),\n-            _ => None\n-        }\n-    }\n-\n-    /// Return an array of 16 octets containing the UUID data\n-    pub fn as_bytes(&self) -> &[u8] {\n-        self.bytes.as_slice()\n-    }\n-\n-    /// Returns the UUID as a string of 16 hexadecimal digits\n-    ///\n-    /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n-    pub fn to_simple_str(&self) -> String {\n-        let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n-        for i in range(0u, 16u) {\n-            let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n-            *s.get_mut(i*2+0) = digit.as_bytes()[0];\n-            *s.get_mut(i*2+1) = digit.as_bytes()[1];\n-        }\n-        String::from_utf8(s).unwrap()\n-    }\n-\n-    /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n-    ///\n-    /// Example: `550e8400-e29b-41d4-a716-446655440000`\n-    pub fn to_hyphenated_str(&self) -> String {\n-        // Convert to field-based struct as it matches groups in output.\n-        // Ensure fields are in network byte order, as per RFC.\n-        let mut uf: UuidFields;\n-        unsafe {\n-            uf = transmute_copy(&self.bytes);\n-        }\n-        uf.data1 = uf.data1.to_be();\n-        uf.data2 = uf.data2.to_be();\n-        uf.data3 = uf.data3.to_be();\n-        let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n-                         {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n-            uf.data1,\n-            uf.data2, uf.data3,\n-            uf.data4[0], uf.data4[1],\n-            uf.data4[2], uf.data4[3], uf.data4[4],\n-            uf.data4[5], uf.data4[6], uf.data4[7]);\n-        s\n-    }\n-\n-    /// Returns the UUID formatted as a full URN string\n-    ///\n-    /// This is the same as the hyphenated format, but with the \"urn:uuid:\" prefix.\n-    ///\n-    /// Example: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n-    pub fn to_urn_str(&self) -> String {\n-        format!(\"urn:uuid:{}\", self.to_hyphenated_str())\n-    }\n-\n-    /// Parses a UUID from a string of hexadecimal digits with optional hyphens\n-    ///\n-    /// Any of the formats generated by this module (simple, hyphenated, urn) are\n-    /// supported by this parsing function.\n-    pub fn parse_string(us: &str) -> Result<Uuid, ParseError> {\n-\n-        let mut us = us.clone();\n-        let orig_len = us.len();\n-\n-        // Ensure length is valid for any of the supported formats\n-        if orig_len != 32 && orig_len != 36 && orig_len != 45 {\n-            return Err(ErrorInvalidLength(orig_len));\n-        }\n-\n-        // Strip off URN prefix if present\n-        if us.starts_with(\"urn:uuid:\") {\n-            us = us.slice(9, orig_len);\n-        }\n-\n-        // Make sure all chars are either hex digits or hyphen\n-        for (i, c) in us.chars().enumerate() {\n-            match c {\n-                '0'...'9' | 'A'...'F' | 'a'...'f' | '-' => {},\n-                _ => return Err(ErrorInvalidCharacter(c, i)),\n-            }\n-        }\n-\n-        // Split string up by hyphens into groups\n-        let hex_groups: Vec<&str> = us.split_str(\"-\").collect();\n-\n-        // Get the length of each group\n-        let group_lens: Vec<uint> = hex_groups.iter().map(|&v| v.len()).collect();\n-\n-        // Ensure the group lengths are valid\n-        match group_lens.len() {\n-            // Single group, no hyphens\n-            1 => {\n-                if group_lens[0] != 32 {\n-                    return Err(ErrorInvalidLength(group_lens[0]));\n-                }\n-            },\n-            // Five groups, hyphens in between each\n-            5 => {\n-                // Ensure each group length matches the expected\n-                for (i, (&gl, &expected)) in\n-                    group_lens.iter().zip(UuidGroupLens.iter()).enumerate() {\n-                    if gl != expected {\n-                        return Err(ErrorInvalidGroupLength(i, gl, expected))\n-                    }\n-                }\n-            },\n-            _ => {\n-                return Err(ErrorInvalidGroups(group_lens.len()));\n-            }\n-        }\n-\n-        // Normalise into one long hex string\n-        let vs = hex_groups.concat();\n-\n-        // At this point, we know we have a valid hex string, without hyphens\n-        assert!(vs.len() == 32);\n-        assert!(vs.as_slice().chars().all(|c| c.is_digit_radix(16)));\n-\n-        // Allocate output UUID buffer\n-        let mut ub = [0u8, ..16];\n-\n-        // Extract each hex digit from the string\n-        for i in range(0u, 16u) {\n-            ub[i] = FromStrRadix::from_str_radix(vs.as_slice()\n-                                                   .slice(i*2, (i+1)*2),\n-                                                 16).unwrap();\n-        }\n-\n-        Ok(Uuid::from_bytes(ub).unwrap())\n-    }\n-\n-    /// Tests if the UUID is nil\n-    pub fn is_nil(&self) -> bool {\n-        return self.bytes.iter().all(|&b| b == 0);\n-    }\n-}\n-\n-impl Default for Uuid {\n-    /// Returns the nil UUID, which is all zeroes\n-    fn default() -> Uuid {\n-        Uuid::nil()\n-    }\n-}\n-\n-impl Clone for Uuid {\n-    /// Returns a copy of the UUID\n-    fn clone(&self) -> Uuid { *self }\n-}\n-\n-impl FromStr for Uuid {\n-    /// Parse a hex string and interpret as a UUID\n-    ///\n-    /// Accepted formats are a sequence of 32 hexadecimal characters,\n-    /// with or without hyphens (grouped as 8, 4, 4, 4, 12).\n-    fn from_str(us: &str) -> Option<Uuid> {\n-        let result = Uuid::parse_string(us);\n-        match result {\n-            Ok(u) => Some(u),\n-            Err(_) => None\n-        }\n-    }\n-}\n-\n-/// Convert the UUID to a hexadecimal-based string representation\n-impl fmt::Show for Uuid {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_simple_str())\n-    }\n-}\n-\n-/// Test two UUIDs for equality\n-///\n-/// UUIDs are equal only when they are byte-for-byte identical\n-impl PartialEq for Uuid {\n-    fn eq(&self, other: &Uuid) -> bool {\n-        self.bytes == other.bytes\n-    }\n-}\n-\n-impl Eq for Uuid {}\n-\n-// FIXME #9845: Test these more thoroughly\n-impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n-    /// Encode a UUID as a hyphenated string\n-    fn encode(&self, e: &mut T) -> Result<(), E> {\n-        e.emit_str(self.to_hyphenated_str().as_slice())\n-    }\n-}\n-\n-impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n-    /// Decode a UUID from a string\n-    fn decode(d: &mut T) -> Result<Uuid, E> {\n-        match from_str(try!(d.read_str()).as_slice()) {\n-            Some(decode) => Ok(decode),\n-            None => Err(d.error(\"Unable to decode UUID\"))\n-        }\n-    }\n-}\n-\n-/// Generates a random instance of UUID (V4 conformant)\n-impl rand::Rand for Uuid {\n-    #[inline]\n-    fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n-        let ub = rng.gen_iter::<u8>().take(16).collect::<Vec<_>>();\n-        let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n-        uuid.set_variant(VariantRFC4122);\n-        uuid.set_version(Version4Random);\n-        uuid\n-    }\n-}\n-\n-#[cfg(test)]\n-mod uuidtest {\n-    use super::{Uuid, VariantMicrosoft, VariantNCS, VariantRFC4122,\n-                Version1Mac, Version2Dce, Version3Md5, Version4Random,\n-                Version5Sha1};\n-    use std::rand;\n-\n-    #[test]\n-    fn test_nil() {\n-        let nil = Uuid::nil();\n-        let not_nil = Uuid::new_v4();\n-\n-        assert!(nil.is_nil());\n-        assert!(!not_nil.is_nil());\n-    }\n-\n-    #[test]\n-    fn test_new() {\n-        // Supported\n-        let uuid1 = Uuid::new(Version4Random).unwrap();\n-        let s = uuid1.to_simple_str();\n-\n-        assert!(s.len() == 32);\n-        assert!(uuid1.get_version().unwrap() == Version4Random);\n-\n-        // Test unsupported versions\n-        assert!(Uuid::new(Version1Mac) == None);\n-        assert!(Uuid::new(Version2Dce) == None);\n-        assert!(Uuid::new(Version3Md5) == None);\n-        assert!(Uuid::new(Version5Sha1) == None);\n-    }\n-\n-    #[test]\n-    fn test_new_v4() {\n-        let uuid1 = Uuid::new_v4();\n-\n-        assert!(uuid1.get_version().unwrap() == Version4Random);\n-        assert!(uuid1.get_variant().unwrap() == VariantRFC4122);\n-    }\n-\n-    #[test]\n-    fn test_get_version() {\n-        let uuid1 = Uuid::new_v4();\n-\n-        assert!(uuid1.get_version().unwrap() == Version4Random);\n-        assert!(uuid1.get_version_num() == 4);\n-    }\n-\n-    #[test]\n-    fn test_get_variant() {\n-        let uuid1 = Uuid::new_v4();\n-        let uuid2 = Uuid::parse_string(\"550e8400-e29b-41d4-a716-446655440000\").unwrap();\n-        let uuid3 = Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").unwrap();\n-        let uuid4 = Uuid::parse_string(\"936DA01F9ABD4d9dC0C702AF85C822A8\").unwrap();\n-        let uuid5 = Uuid::parse_string(\"F9168C5E-CEB2-4faa-D6BF-329BF39FA1E4\").unwrap();\n-        let uuid6 = Uuid::parse_string(\"f81d4fae-7dec-11d0-7765-00a0c91e6bf6\").unwrap();\n-\n-        assert!(uuid1.get_variant().unwrap() == VariantRFC4122);\n-        assert!(uuid2.get_variant().unwrap() == VariantRFC4122);\n-        assert!(uuid3.get_variant().unwrap() == VariantRFC4122);\n-        assert!(uuid4.get_variant().unwrap() == VariantMicrosoft);\n-        assert!(uuid5.get_variant().unwrap() == VariantMicrosoft);\n-        assert!(uuid6.get_variant().unwrap() == VariantNCS);\n-    }\n-\n-    #[test]\n-    fn test_parse_uuid_v4() {\n-        use super::{ErrorInvalidCharacter, ErrorInvalidGroups,\n-                    ErrorInvalidGroupLength, ErrorInvalidLength};\n-\n-        // Invalid\n-        assert!(Uuid::parse_string(\"\").is_err());\n-        assert!(Uuid::parse_string(\"!\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF-329BF39FA1E45\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-BBF-329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-BGBF-329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BFF329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faaXB6BFF329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB-24fa-eB6BFF32-BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"01020304-1112-2122-3132-41424344\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c88\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0cg8\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426%9247bb680e5fe0c8\").is_err());\n-\n-        // Valid\n-        assert!(Uuid::parse_string(\"00000000000000000000000000000000\").is_ok());\n-        assert!(Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n-        assert!(Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\").is_ok());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c8\").is_ok());\n-        assert!(Uuid::parse_string(\"01020304-1112-2122-3132-414243444546\").is_ok());\n-        assert!(Uuid::parse_string(\"urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n-\n-        // Nil\n-        let nil = Uuid::nil();\n-        assert!(Uuid::parse_string(\"00000000000000000000000000000000\").unwrap()  == nil);\n-        assert!(Uuid::parse_string(\"00000000-0000-0000-0000-000000000000\").unwrap() == nil);\n-\n-        // Round-trip\n-        let uuid_orig = Uuid::new_v4();\n-        let orig_str = uuid_orig.to_string();\n-        let uuid_out = Uuid::parse_string(orig_str.as_slice()).unwrap();\n-        assert!(uuid_orig == uuid_out);\n-\n-        // Test error reporting\n-        let e = Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c\").unwrap_err();\n-        assert!(match e { ErrorInvalidLength(n) => n==31, _ => false });\n-\n-        let e = Uuid::parse_string(\"67e550X410b1426f9247bb680e5fe0cd\").unwrap_err();\n-        assert!(match e { ErrorInvalidCharacter(c, n) => c=='X' && n==6, _ => false });\n-\n-        let e = Uuid::parse_string(\"67e550-4105b1426f9247bb680e5fe0c\").unwrap_err();\n-        assert!(match e { ErrorInvalidGroups(n) => n==2, _ => false });\n-\n-        let e = Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF1-02BF39FA1E4\").unwrap_err();\n-        assert!(match e { ErrorInvalidGroupLength(g, n, e) => g==3 && n==5 && e==4, _ => false });\n-    }\n-\n-    #[test]\n-    fn test_to_simple_str() {\n-        let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_simple_str();\n-\n-        assert!(s.len() == 32);\n-        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n-    }\n-\n-    #[test]\n-    fn test_to_string() {\n-        let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_string();\n-\n-        assert!(s.len() == 32);\n-        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n-    }\n-\n-    #[test]\n-    fn test_to_hyphenated_str() {\n-        let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_hyphenated_str();\n-\n-        assert!(s.len() == 36);\n-        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16) || c == '-'));\n-    }\n-\n-    #[test]\n-    fn test_to_urn_str() {\n-        let uuid1 = Uuid::new_v4();\n-        let ss = uuid1.to_urn_str();\n-        let s = ss.as_slice().slice(9, ss.len());\n-\n-        assert!(ss.as_slice().starts_with(\"urn:uuid:\"));\n-        assert!(s.len() == 36);\n-        assert!(s.as_slice()\n-                 .chars()\n-                 .all(|c| c.is_digit_radix(16) || c == '-'));\n-    }\n-\n-    #[test]\n-    fn test_to_str_matching() {\n-        let uuid1 = Uuid::new_v4();\n-\n-        let hs = uuid1.to_hyphenated_str();\n-        let ss = uuid1.to_string();\n-\n-        let hsn = String::from_chars(hs.as_slice()\n-                                    .chars()\n-                                    .filter(|&c| c != '-')\n-                                    .collect::<Vec<char>>()\n-                                    .as_slice());\n-\n-        assert!(hsn == ss);\n-    }\n-\n-    #[test]\n-    fn test_string_roundtrip() {\n-        let uuid = Uuid::new_v4();\n-\n-        let hs = uuid.to_hyphenated_str();\n-        let uuid_hs = Uuid::parse_string(hs.as_slice()).unwrap();\n-        assert!(uuid_hs == uuid);\n-\n-        let ss = uuid.to_string();\n-        let uuid_ss = Uuid::parse_string(ss.as_slice()).unwrap();\n-        assert!(uuid_ss == uuid);\n-    }\n-\n-    #[test]\n-    fn test_compare() {\n-        let uuid1 = Uuid::new_v4();\n-        let uuid2 = Uuid::new_v4();\n-\n-        assert!(uuid1 == uuid1);\n-        assert!(uuid2 == uuid2);\n-        assert!(uuid1 != uuid2);\n-        assert!(uuid2 != uuid1);\n-    }\n-\n-    #[test]\n-    fn test_from_fields() {\n-        let d1: u32 = 0xa1a2a3a4;\n-        let d2: u16 = 0xb1b2;\n-        let d3: u16 = 0xc1c2;\n-        let d4: Vec<u8> = vec!(0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8);\n-\n-        let u = Uuid::from_fields(d1, d2, d3, d4.as_slice());\n-\n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_string();\n-        let result = u.to_simple_str();\n-        assert!(result == expected);\n-    }\n-\n-    #[test]\n-    fn test_from_bytes() {\n-        let b = vec!( 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n-                   0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 );\n-\n-        let u = Uuid::from_bytes(b.as_slice()).unwrap();\n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_string();\n-\n-        assert!(u.to_simple_str() == expected);\n-    }\n-\n-    #[test]\n-    fn test_as_bytes() {\n-        let u = Uuid::new_v4();\n-        let ub = u.as_bytes();\n-\n-        assert!(ub.len() == 16);\n-        assert!(! ub.iter().all(|&b| b == 0));\n-    }\n-\n-    #[test]\n-    fn test_bytes_roundtrip() {\n-        let b_in: [u8, ..16] = [ 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n-                                 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 ];\n-\n-        let u = Uuid::from_bytes(b_in.clone()).unwrap();\n-\n-        let b_out = u.as_bytes();\n-\n-        assert!(b_in == b_out);\n-    }\n-\n-    #[test]\n-    fn test_operator_eq() {\n-        let u1 = Uuid::new_v4();\n-        let u2 = u1.clone();\n-        let u3 = Uuid::new_v4();\n-\n-        assert!(u1 == u1);\n-        assert!(u1 == u2);\n-        assert!(u2 == u1);\n-\n-        assert!(u1 != u3);\n-        assert!(u3 != u1);\n-        assert!(u2 != u3);\n-        assert!(u3 != u2);\n-    }\n-\n-    #[test]\n-    fn test_rand_rand() {\n-        let mut rng = rand::task_rng();\n-        let u: Uuid = rand::Rand::rand(&mut rng);\n-        let ub = u.as_bytes();\n-\n-        assert!(ub.len() == 16);\n-        assert!(! ub.iter().all(|&b| b == 0));\n-    }\n-\n-    #[test]\n-    fn test_serialize_round_trip() {\n-        use serialize::json;\n-\n-        let u = Uuid::new_v4();\n-        let s = json::encode(&u);\n-        let u2 = json::decode(s.as_slice()).unwrap();\n-        assert_eq!(u, u2);\n-    }\n-\n-    #[test]\n-    fn test_bad_decode() {\n-        use serialize::json;\n-        use serialize::{Decodable};\n-\n-        let js_good = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7a8\".to_string());\n-        let js_bad1 = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7ah\".to_string());\n-        let js_bad2 = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7a\".to_string());\n-\n-        let u_good: Result<Uuid, _> = Decodable::decode(&mut json::Decoder::new(js_good));\n-        let u_bad1: Result<Uuid, _> = Decodable::decode(&mut json::Decoder::new(js_bad1));\n-        let u_bad2: Result<Uuid, _> = Decodable::decode(&mut json::Decoder::new(js_bad2));\n-        assert!(u_good.is_ok());\n-        assert!(u_bad1.is_err());\n-        assert!(u_bad2.is_err());\n-    }\n-\n-    #[test]\n-    fn test_iterbytes_impl_for_uuid() {\n-        use std::collections::HashSet;\n-        let mut set = HashSet::new();\n-        let id1 = Uuid::new_v4();\n-        let id2 = Uuid::new_v4();\n-        set.insert(id1);\n-        assert!(set.contains(&id1));\n-        assert!(!set.contains(&id2));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::Uuid;\n-\n-    #[bench]\n-    pub fn create_uuids(b: &mut Bencher) {\n-        b.iter(|| {\n-            Uuid::new_v4();\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn uuid_to_string(b: &mut Bencher) {\n-        let u = Uuid::new_v4();\n-        b.iter(|| {\n-            u.to_string();\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn parse_str(b: &mut Bencher) {\n-        let s = \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\";\n-        b.iter(|| {\n-            Uuid::parse_string(s).unwrap();\n-        })\n-    }\n-}"}]}