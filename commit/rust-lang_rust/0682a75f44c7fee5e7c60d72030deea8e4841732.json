{"sha": "0682a75f44c7fee5e7c60d72030deea8e4841732", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ODJhNzVmNDRjN2ZlZTVlN2M2MGQ3MjAzMGRlZWE4ZTQ4NDE3MzI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-08T20:40:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc: clean up the style of middle::resolve_lifetime.", "tree": {"sha": "961f0b63127b0a0b321c2d9cecac70a7b035193d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/961f0b63127b0a0b321c2d9cecac70a7b035193d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0682a75f44c7fee5e7c60d72030deea8e4841732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0682a75f44c7fee5e7c60d72030deea8e4841732", "html_url": "https://github.com/rust-lang/rust/commit/0682a75f44c7fee5e7c60d72030deea8e4841732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0682a75f44c7fee5e7c60d72030deea8e4841732/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a2a669bb70633a8c9ac4be708813b311c52ff93", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2a669bb70633a8c9ac4be708813b311c52ff93", "html_url": "https://github.com/rust-lang/rust/commit/7a2a669bb70633a8c9ac4be708813b311c52ff93"}], "stats": {"total": 188, "additions": 109, "deletions": 79}, "files": [{"sha": "c92722c40d575010e390a4adba5c1b1cd4f5c6cf", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 99, "deletions": 69, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0682a75f44c7fee5e7c60d72030deea8e4841732", "patch": "@@ -15,9 +15,6 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore we break lifetime name resolution into a separate pass.\n \n-pub use self::DefRegion::*;\n-use self::ScopeChain::*;\n-\n use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n@@ -36,22 +33,19 @@ use hir;\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n-pub enum DefRegion {\n-    DefStaticRegion,\n-    DefEarlyBoundRegion(/* index */ u32,\n-                        /* lifetime decl */ ast::NodeId),\n-    DefLateBoundRegion(ty::DebruijnIndex,\n-                       /* lifetime decl */ ast::NodeId),\n-    DefFreeRegion(region::CallSiteScopeData,\n-                  /* lifetime decl */ ast::NodeId),\n+pub enum Region {\n+    Static,\n+    EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n+    LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n+    Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n }\n \n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n pub struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n-    // `DefRegion` describing how that region is bound\n-    pub defs: NodeMap<DefRegion>,\n+    // `Region` describing how that region is bound\n+    pub defs: NodeMap<Region>,\n \n     // the set of lifetime def ids that are late-bound; late-bound ids\n     // are named regions appearing in fn arguments that do not appear\n@@ -63,7 +57,7 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     sess: &'a Session,\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n-    scope: Scope<'a>,\n+    scope: ScopeRef<'a>,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -86,25 +80,36 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n }\n \n #[derive(PartialEq, Debug)]\n-enum ScopeChain<'a> {\n-    /// EarlyScope(['a, 'b, ...], start, s) extends s with early-bound\n-    /// lifetimes, with consecutive parameter indices from `start`.\n-    /// That is, 'a has index `start`, 'b has index `start + 1`, etc.\n+enum Scope<'a> {\n+    /// Extends `s` with early-bound `lifetimes`, having consecutive parameter\n+    /// indices from `start`, i.e. `lifetimes[i]` has index `start + i`.\n     /// Indices before `start` correspond to other generic parameters\n     /// of a parent item (trait/impl of a method), or `Self` in traits.\n-    EarlyScope(&'a [hir::LifetimeDef], u32, Scope<'a>),\n-    /// LateScope(['a, 'b, ...], s) extends s with late-bound\n-    /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n-\n-    /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n-    FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n-    RootScope\n+    Early {\n+        lifetimes: &'a [hir::LifetimeDef],\n+        start: u32,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// Extends `s` with late-bound `lifetimes`.\n+    Late {\n+        lifetimes: &'a [hir::LifetimeDef],\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// Lifetimes introduced by a fn are scoped to the call-site for that fn.\n+    Fn {\n+        fn_id: ast::NodeId,\n+        body_id: ast::NodeId,\n+        s: ScopeRef<'a>\n+    },\n+\n+    Root\n }\n \n-type Scope<'a> = &'a ScopeChain<'a>;\n+type ScopeRef<'a> = &'a Scope<'a>;\n \n-static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n+const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn krate(sess: &Session,\n              hir_map: &Map)\n@@ -120,7 +125,7 @@ pub fn krate(sess: &Session,\n             sess: sess,\n             hir_map: hir_map,\n             map: &mut map,\n-            scope: &ROOT_SCOPE,\n+            scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         }, krate);\n@@ -140,7 +145,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n \n         // Items always introduce a new root scope\n-        self.with(RootScope, |_, this| {\n+        self.with(Scope::Root, |_, this| {\n             match item.node {\n                 hir::ItemFn(..) => {\n                     // Fn lifetimes get added in visit_fn below:\n@@ -169,7 +174,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     } else {\n                         0\n                     };\n-                    this.with(EarlyScope(lifetimes, start, &ROOT_SCOPE), |old_scope, this| {\n+                    let early = Scope::Early {\n+                        lifetimes: lifetimes,\n+                        start: start,\n+                        s: ROOT_SCOPE\n+                    };\n+                    this.with(early, |old_scope, this| {\n                         this.check_lifetime_defs(old_scope, lifetimes);\n                         intravisit::walk_item(this, item);\n                     });\n@@ -187,7 +197,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n \n         // Items always introduce a new root scope\n-        self.with(RootScope, |_, this| {\n+        self.with(Scope::Root, |_, this| {\n             match item.node {\n                 hir::ForeignItemFn(ref decl, _, ref generics) => {\n                     this.visit_early_late(item.id, decl, generics, |this| {\n@@ -233,7 +243,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n-                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n+                let late = Scope::Late {\n+                    lifetimes: &c.lifetimes,\n+                    s: self.scope\n+                };\n+                self.with(late, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n                     this.check_lifetime_defs(old_scope, &c.lifetimes);\n@@ -245,7 +259,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // a trait ref, which introduces a binding scope.\n                 match path.def {\n                     Def::Trait(..) => {\n-                        self.with(LateScope(&[], self.scope), |_, this| {\n+                        self.with(Scope::Late { lifetimes: &[], s: self.scope }, |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n                     }\n@@ -283,7 +297,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             return;\n         }\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n-            self.insert_lifetime(lifetime_ref, DefStaticRegion);\n+            self.insert_lifetime(lifetime_ref, Region::Static);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n@@ -304,8 +318,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                                                                .. }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n-                        let result = self.with(LateScope(bound_lifetimes, self.scope),\n-                                               |old_scope, this| {\n+                        let late = Scope::Late {\n+                            lifetimes: bound_lifetimes,\n+                            s: self.scope\n+                        };\n+                        let result = self.with(late, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n@@ -346,7 +363,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 span_err!(self.sess, trait_ref.span, E0316,\n                           \"nested quantification of lifetimes\");\n             }\n-            self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+            let late = Scope::Late {\n+                lifetimes: &trait_ref.bound_lifetimes,\n+                s: self.scope\n+            };\n+            self.with(late, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n@@ -412,7 +433,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n-        scope: Scope<'a>,\n+        scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n@@ -471,16 +492,16 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     }\n \n     fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n-                                           mut scope: Scope<'a>,\n+                                           mut scope: ScopeRef<'a>,\n                                            label: ast::Name,\n                                            label_span: Span) {\n         loop {\n             match *scope {\n-                FnScope { s, .. } => { scope = s; }\n-                RootScope => { return; }\n+                Scope::Fn { s, .. } => { scope = s; }\n+                Scope::Root => { return; }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n+                Scope::Early { lifetimes, s, .. } |\n+                Scope::Late { lifetimes, s } => {\n                     for lifetime_def in lifetimes {\n                         // FIXME (#24278): non-hygienic comparison\n                         if label == lifetime_def.lifetime.name {\n@@ -524,7 +545,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n+        self.with(Scope::Fn { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n                   |_old_scope, this| this.visit_nested_body(fb))\n     }\n \n@@ -535,8 +556,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         f(self)\n     }\n \n-    fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: for<'b> FnOnce(Scope, &mut LifetimeContext<'b, 'tcx>),\n+    fn with<F>(&mut self, wrap_scope: Scope, f: F) where\n+        F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let mut this = LifetimeContext {\n@@ -591,7 +612,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         // Find the start of nested early scopes, e.g. in methods.\n         let mut start = 0;\n-        if let EarlyScope(..) = *self.scope {\n+        if let Scope::Early {..} = *self.scope {\n             let parent = self.hir_map.expect_item(self.hir_map.get_parent(fn_id));\n             if let hir::ItemTrait(..) = parent.node {\n                 start += 1; // Self comes first.\n@@ -605,8 +626,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        self.with(EarlyScope(&early, start as u32, self.scope), move |old_scope, this| {\n-            this.with(LateScope(&late, this.scope), move |_, this| {\n+        let early = Scope::Early {\n+            lifetimes: &early,\n+            start: start as u32,\n+            s: self.scope\n+        };\n+        self.with(early, move |old_scope, this| {\n+            let late = Scope::Late {\n+                lifetimes: &late,\n+                s: this.scope\n+            };\n+            this.with(late, move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n             });\n@@ -624,22 +654,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n-                FnScope {fn_id, body_id, s } => {\n+                Scope::Fn { fn_id, body_id, s } => {\n                     return self.resolve_free_lifetime_ref(\n                         region::CallSiteScopeData { fn_id: fn_id, body_id: body_id },\n                         lifetime_ref,\n                         s);\n                 }\n \n-                RootScope => {\n+                Scope::Root => {\n                     break;\n                 }\n \n-                EarlyScope(lifetimes, start, s) => {\n+                Scope::Early { lifetimes, start, s } => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((index, lifetime_def)) => {\n                             let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(start + index, decl_id);\n+                            let def = Region::EarlyBound(start + index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -649,12 +679,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                LateScope(lifetimes, s) => {\n+                Scope::Late { lifetimes, s } => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, lifetime_def)) => {\n                             let decl_id = lifetime_def.id;\n                             let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n-                            let def = DefLateBoundRegion(debruijn, decl_id);\n+                            let def = Region::LateBound(debruijn, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -674,7 +704,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn resolve_free_lifetime_ref(&mut self,\n                                  scope_data: region::CallSiteScopeData,\n                                  lifetime_ref: &hir::Lifetime,\n-                                 scope: Scope) {\n+                                 scope: ScopeRef) {\n         debug!(\"resolve_free_lifetime_ref \\\n                 scope_data: {:?} lifetime_ref: {:?} scope: {:?}\",\n                scope_data, lifetime_ref, scope);\n@@ -690,19 +720,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope_data: {:?} scope: {:?} search_result: {:?}\",\n                    scope_data, scope, search_result);\n             match *scope {\n-                FnScope { fn_id, body_id, s } => {\n+                Scope::Fn { fn_id, body_id, s } => {\n                     scope_data = region::CallSiteScopeData {\n                         fn_id: fn_id, body_id: body_id\n                     };\n                     scope = s;\n                 }\n \n-                RootScope => {\n+                Scope::Root => {\n                     break;\n                 }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n+                Scope::Early { lifetimes, s, .. } |\n+                Scope::Late { lifetimes, s } => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n                         break;\n@@ -714,7 +744,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         match search_result {\n             Some((_depth, lifetime)) => {\n-                let def = DefFreeRegion(scope_data, lifetime.id);\n+                let def = Region::Free(scope_data, lifetime.id);\n                 self.insert_lifetime(lifetime_ref, def);\n             }\n \n@@ -732,7 +762,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .emit();\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &[hir::LifetimeDef]) {\n+    fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -773,7 +803,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: Scope,\n+                                        mut old_scope: ScopeRef,\n                                         lifetime: &hir::Lifetime)\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n@@ -789,16 +819,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         loop {\n             match *old_scope {\n-                FnScope { s, .. } => {\n+                Scope::Fn { s, .. } => {\n                     old_scope = s;\n                 }\n \n-                RootScope => {\n+                Scope::Root => {\n                     return;\n                 }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n+                Scope::Early { lifetimes, s, .. } |\n+                Scope::Late { lifetimes, s } => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n                         signal_shadowing_problem(\n                             self.sess,\n@@ -816,7 +846,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     fn insert_lifetime(&mut self,\n                        lifetime_ref: &hir::Lifetime,\n-                       def: DefRegion) {\n+                       def: Region) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n             span_bug!(lifetime_ref.span,\n                       \"lifetime reference not renumbered, \\"}, {"sha": "3338daeb774401b676a7ae4f452b4c42eb25bbef", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0682a75f44c7fee5e7c60d72030deea8e4841732", "patch": "@@ -247,11 +247,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let name = opt_lifetime.map(|l| l.name);\n         let resolved = opt_lifetime.and_then(|l| tcx.named_region_map.defs.get(&l.id));\n         let r = tcx.mk_region(match resolved {\n-            Some(&rl::DefStaticRegion) => {\n+            Some(&rl::Region::Static) => {\n                 ty::ReStatic\n             }\n \n-            Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n+            Some(&rl::Region::LateBound(debruijn, id)) => {\n                 // If this region is declared on a function, it will have\n                 // an entry in `late_bound`, but if it comes from\n                 // `for<'a>` in some type or something, it won't\n@@ -268,15 +268,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                       issue_32330))\n             }\n \n-            Some(&rl::DefEarlyBoundRegion(index, _)) => {\n+            Some(&rl::Region::EarlyBound(index, _)) => {\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n                     index: index,\n                     name: name.unwrap()\n                 })\n             }\n \n-            Some(&rl::DefFreeRegion(scope, id)) => {\n-                // As in DefLateBoundRegion above, could be missing for some late-bound\n+            Some(&rl::Region::Free(scope, id)) => {\n+                // As in Region::LateBound above, could be missing for some late-bound\n                 // regions, but also for early-bound regions.\n                 let issue_32330 = tcx.named_region_map\n                                      .late_bound"}, {"sha": "ba00f237684e6b6766dd29a5d89cd34082c4bb14", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0682a75f44c7fee5e7c60d72030deea8e4841732", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.hir, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id)) => lifetime_decl_id,\n+            Some(&rl::Region::EarlyBound(_, lifetime_decl_id)) => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is"}, {"sha": "4182dca71531196358bd810a32e0da3ae4c92e13", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682a75f44c7fee5e7c60d72030deea8e4841732/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0682a75f44c7fee5e7c60d72030deea8e4841732", "patch": "@@ -28,7 +28,7 @@ use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc::middle::privacy::AccessLevels;\n-use rustc::middle::resolve_lifetime::DefRegion::*;\n+use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -765,9 +765,9 @@ impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n         let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n         match def {\n-            Some(DefEarlyBoundRegion(_, node_id)) |\n-            Some(DefLateBoundRegion(_, node_id)) |\n-            Some(DefFreeRegion(_, node_id)) => {\n+            Some(rl::Region::EarlyBound(_, node_id)) |\n+            Some(rl::Region::LateBound(_, node_id)) |\n+            Some(rl::Region::Free(_, node_id)) => {\n                 if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n                     return lt;\n                 }"}]}