{"sha": "f7af0b4b969aa1ba85744f082a30af808a684d7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YWYwYjRiOTY5YWExYmE4NTc0NGYwODJhMzBhZjgwOGE2ODRkN2M=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-10T21:27:43Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-10T23:28:21Z"}, "message": "Add some more marks to rename tests", "tree": {"sha": "b690f6c8f5d1997862d0c2b4ac4879cad5198965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b690f6c8f5d1997862d0c2b4ac4879cad5198965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7af0b4b969aa1ba85744f082a30af808a684d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7af0b4b969aa1ba85744f082a30af808a684d7c", "html_url": "https://github.com/rust-lang/rust/commit/f7af0b4b969aa1ba85744f082a30af808a684d7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7af0b4b969aa1ba85744f082a30af808a684d7c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2347944aaec8b78c128acdc26fa83b6ebe8b1cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2347944aaec8b78c128acdc26fa83b6ebe8b1cf2", "html_url": "https://github.com/rust-lang/rust/commit/2347944aaec8b78c128acdc26fa83b6ebe8b1cf2"}], "stats": {"total": 75, "additions": 58, "deletions": 17}, "files": [{"sha": "44dfa9a0ed33442de1716a68a797edd5e6cf7397", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f7af0b4b969aa1ba85744f082a30af808a684d7c/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7af0b4b969aa1ba85744f082a30af808a684d7c/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=f7af0b4b969aa1ba85744f082a30af808a684d7c", "patch": "@@ -14,7 +14,7 @@ use ide_db::{\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    lex_single_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n+    lex_single_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken, T,\n };\n use test_utils::mark;\n use text_edit::TextEdit;\n@@ -55,7 +55,7 @@ pub(crate) fn prepare_rename(\n     if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n         rename_mod(&sema, position, module, \"dummy\")\n     } else if let Some(self_token) =\n-        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == T![self])\n     {\n         rename_self_to_param(&sema, position, self_token, \"dummy\")\n     } else {\n@@ -85,7 +85,7 @@ pub(crate) fn rename_with_semantics(\n     if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n         rename_mod(&sema, position, module, new_name)\n     } else if let Some(self_token) =\n-        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == T![self])\n     {\n         rename_self_to_param(&sema, position, self_token, new_name)\n     } else {\n@@ -110,7 +110,7 @@ pub(crate) fn will_rename_file(\n     Some(change)\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n enum IdentifierKind {\n     Ident,\n     Lifetime,\n@@ -122,8 +122,8 @@ fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n     match lex_single_syntax_kind(new_name) {\n         Some(res) => match res {\n             (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n-            (SyntaxKind::UNDERSCORE, _) => Ok(IdentifierKind::Underscore),\n-            (SyntaxKind::SELF_KW, _) => Ok(IdentifierKind::ToSelf),\n+            (T![_], _) => Ok(IdentifierKind::Underscore),\n+            (T![self], _) => Ok(IdentifierKind::ToSelf),\n             (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n                 Ok(IdentifierKind::Lifetime)\n             }\n@@ -390,6 +390,7 @@ fn rename_self_to_param(\n         IdentifierKind::Lifetime => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n         IdentifierKind::ToSelf => {\n             // no-op\n+            mark::hit!(rename_self_to_self);\n             return Ok(RangeInfo::new(self_token.text_range(), SourceChange::default()));\n         }\n         _ => (),\n@@ -409,9 +410,7 @@ fn rename_self_to_param(\n         if !search_range.contains_inclusive(offset) {\n             continue;\n         }\n-        if let Some(ref usage) =\n-            syn.token_at_offset(offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n-        {\n+        if let Some(ref usage) = syn.token_at_offset(offset).find(|t| t.kind() == T![self]) {\n             let edit = if let Some(ref self_param) = ast::SelfParam::cast(usage.parent()) {\n                 text_edit_from_self_param(syn, self_param, new_name)\n                     .ok_or_else(|| format_err!(\"No target type found\"))?\n@@ -444,21 +443,26 @@ fn rename_reference(\n         (IdentifierKind::ToSelf, ReferenceKind::Lifetime)\n         | (IdentifierKind::Underscore, ReferenceKind::Lifetime)\n         | (IdentifierKind::Ident, ReferenceKind::Lifetime) => {\n+            mark::hit!(rename_not_a_lifetime_ident_ref);\n             bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n         }\n-        (IdentifierKind::Lifetime, ReferenceKind::Lifetime) => (),\n-        (IdentifierKind::Lifetime, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        (IdentifierKind::Lifetime, ReferenceKind::Lifetime) => mark::hit!(rename_lifetime),\n+        (IdentifierKind::Lifetime, _) => {\n+            mark::hit!(rename_not_an_ident_ref);\n+            bail!(\"Invalid name `{}`: not an identifier\", new_name)\n+        }\n         (IdentifierKind::ToSelf, ReferenceKind::SelfKw) => {\n-            //no-op\n-            return Ok(RangeInfo::new(range, SourceChange::default()));\n+            unreachable!(\"rename_self_to_param should've been called instead\")\n         }\n         (IdentifierKind::ToSelf, _) => {\n+            mark::hit!(rename_to_self);\n             return rename_to_self(sema, position);\n         }\n         (IdentifierKind::Underscore, _) if !refs.references.is_empty() => {\n+            mark::hit!(rename_underscore_multiple);\n             bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\")\n         }\n-        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => (),\n+        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n     }\n \n     let edit = refs\n@@ -494,9 +498,11 @@ mod tests {\n                         text_edit_builder.replace(indel.delete, indel.insert);\n                     }\n                 }\n-                let mut result = analysis.file_text(file_id.unwrap()).unwrap().to_string();\n-                text_edit_builder.finish().apply(&mut result);\n-                assert_eq_text!(ra_fixture_after, &*result);\n+                if let Some(file_id) = file_id {\n+                    let mut result = analysis.file_text(file_id).unwrap().to_string();\n+                    text_edit_builder.finish().apply(&mut result);\n+                    assert_eq_text!(ra_fixture_after, &*result);\n+                }\n             }\n             Err(err) => {\n                 if ra_fixture_after.starts_with(\"error:\") {\n@@ -562,6 +568,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime() {\n+        mark::check!(rename_not_an_ident_ref);\n         check(\n             \"'foo\",\n             r#\"fn main() { let i$0 = 1; }\"#,\n@@ -571,6 +578,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime2() {\n+        mark::check!(rename_not_a_lifetime_ident_ref);\n         check(\n             \"foo\",\n             r#\"fn main<'a>(_: &'a$0 ()) {}\"#,\n@@ -580,15 +588,26 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_underscore_invalid() {\n+        mark::check!(rename_underscore_multiple);\n         check(\n             \"_\",\n             r#\"fn main(foo$0: ()) {foo;}\"#,\n             \"error: Cannot rename reference to `_` as it is being referenced multiple times\",\n         );\n     }\n \n+    #[test]\n+    fn test_rename_mod_invalid() {\n+        check(\n+            \"'foo\",\n+            r#\"mod foo$0 {}\"#,\n+            \"error: Invalid name `'foo`: cannot rename module to 'foo\",\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n+        mark::check!(rename_ident);\n         check(\n             \"k\",\n             r#\"\n@@ -1219,6 +1238,7 @@ fn foo(f: foo::Foo) {\n \n     #[test]\n     fn test_parameter_to_self() {\n+        mark::check!(rename_to_self);\n         check(\n             \"self\",\n             r#\"\n@@ -1522,6 +1542,7 @@ fn foo(Foo { i: bar }: foo) -> i32 {\n \n     #[test]\n     fn test_rename_lifetimes() {\n+        mark::check!(rename_lifetime);\n         check(\n             \"'yeeee\",\n             r#\"\n@@ -1603,6 +1624,26 @@ fn foo<'a>() -> &'a () {\n         }\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_self_to_self() {\n+        mark::check!(rename_self_to_self);\n+        check(\n+            \"self\",\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self$0) {}\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self) {}\n+}\n \"#,\n         )\n     }"}]}