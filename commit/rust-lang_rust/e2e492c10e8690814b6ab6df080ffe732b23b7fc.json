{"sha": "e2e492c10e8690814b6ab6df080ffe732b23b7fc", "node_id": "C_kwDOAAsO6NoAKGUyZTQ5MmMxMGU4NjkwODE0YjZhYjZkZjA4MGZmZTczMmIyM2I3ZmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-13T16:11:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-13T16:11:25Z"}, "message": "Auto merge of #8422 - buttercrab:only_used_in_recursion, r=llogiq\n\nnew lint: `only_used_in_recursion`\n\nchanged:\n- added `only_used_in_recursion`.\n- fixed code that variables are only used in recursion.\n- this would not lint when `unused_variable`\n\nThis fixes: #8390\n\n-----\n\nchangelog: add lint [`only_used_in_recursion`]", "tree": {"sha": "bd66f0b7a48e7958f045fe527527dad8e0012ddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd66f0b7a48e7958f045fe527527dad8e0012ddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e492c10e8690814b6ab6df080ffe732b23b7fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e492c10e8690814b6ab6df080ffe732b23b7fc", "html_url": "https://github.com/rust-lang/rust/commit/e2e492c10e8690814b6ab6df080ffe732b23b7fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e492c10e8690814b6ab6df080ffe732b23b7fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b616e92f6cad9c44bd4faf10e034439a5757f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b616e92f6cad9c44bd4faf10e034439a5757f2", "html_url": "https://github.com/rust-lang/rust/commit/75b616e92f6cad9c44bd4faf10e034439a5757f2"}, {"sha": "800f66de2bea7672e03ffa2be457ef06d91cce83", "url": "https://api.github.com/repos/rust-lang/rust/commits/800f66de2bea7672e03ffa2be457ef06d91cce83", "html_url": "https://github.com/rust-lang/rust/commit/800f66de2bea7672e03ffa2be457ef06d91cce83"}], "stats": {"total": 942, "additions": 903, "deletions": 39}, "files": [{"sha": "2bc393d60425678b7fe69e4949fc1d0df97901d4", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -3356,6 +3356,7 @@ Released 2018-09-13\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`octal_escapes`]: https://rust-lang.github.io/rust-clippy/master/index.html#octal_escapes\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n+[`only_used_in_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap"}, {"sha": "23bca5a0eabb2c10e680e85f6bdda842207c486f", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -236,6 +236,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),"}, {"sha": "68d6c6ce5f7dad5d9377fa8e993c64f5cfd463f2", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -65,6 +65,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "1a45763a86965de9050347d75ad3f43fda627a4d", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -400,6 +400,7 @@ store.register_lints(&[\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     octal_escapes::OCTAL_ESCAPES,\n+    only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,"}, {"sha": "504235d0d1ef00b40bf5b8f948514b86827a1c40", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -318,6 +318,7 @@ mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n mod octal_escapes;\n+mod only_used_in_recursion;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -857,6 +858,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n     store.register_late_pass(|| Box::new(dbg_macro::DbgMacro));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n     store.register_late_pass(move || {"}, {"sha": "2a5ab6e625c111ae0bec3d204db34d7f5c6653f0", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -14,18 +14,15 @@ use super::RESULT_MAP_OR_INTO_OPTION;\n \n // The expression inside a closure may or may not have surrounding braces\n // which causes problems when generating a suggestion.\n-fn reduce_unit_expression<'a>(\n-    cx: &LateContext<'_>,\n-    expr: &'a hir::Expr<'_>,\n-) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+fn reduce_unit_expression<'a>(expr: &'a hir::Expr<'_>) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n     match expr.kind {\n         hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `|x| { x + 1 }` to `|x| x + 1`\n-                    reduce_unit_expression(cx, inner_expr)\n+                    reduce_unit_expression(inner_expr)\n                 },\n                 _ => None,\n             }\n@@ -77,7 +74,7 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, [arg_char])) = reduce_unit_expression(cx, &body.value);\n+                if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n                 if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n                 if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {"}, {"sha": "b828d9334ee0e9e28d5f6a4d5d866edde7a218f6", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "added", "additions": 668, "deletions": 0, "changes": 668, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -0,0 +1,668 @@\n+use std::collections::VecDeque;\n+\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use itertools::{izip, Itertools};\n+use rustc_ast::{walk_list, Label, Mutability};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::{\n+    Arm, Block, Body, Expr, ExprKind, Guard, HirId, ImplicitSelfKind, Let, Local, Pat, PatKind, Path, PathSegment,\n+    QPath, Stmt, StmtKind, TyKind, UnOp,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arguments that are only used in recursion with no side-effects.\n+    ///\n+    /// ### Why is this bad?\n+    /// It could contain a useless calculation and can make function simpler.\n+    ///\n+    /// The arguments can be involved in calculations and assignments but as long as\n+    /// the calculations have no side-effects (function calls or mutating dereference)\n+    /// and the assigned variables are also only in recursion, it is useless.\n+    ///\n+    /// ### Known problems\n+    /// In some cases, this would not catch all useless arguments.\n+    ///\n+    /// ```rust\n+    /// fn foo(a: usize, b: usize) -> usize {\n+    ///     let f = |x| x + 1;\n+    ///\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         foo(a - 1, f(b))\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// For example, the argument `b` is only used in recursion, but the lint would not catch it.\n+    ///\n+    /// List of some examples that can not be caught:\n+    /// - binary operation of non-primitive types\n+    /// - closure usage\n+    /// - some `break` relative operations\n+    /// - struct pattern binding\n+    ///\n+    /// Also, when you recurse the function name with path segments, it is not possible to detect.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn f(a: usize, b: usize) -> usize {\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         f(a - 1, b + 1)\n+    ///     }\n+    /// }\n+    /// # fn main() {\n+    /// #     print!(\"{}\", f(1, 1));\n+    /// # }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn f(a: usize) -> usize {\n+    ///     if a == 0 {\n+    ///         1\n+    ///     } else {\n+    ///         f(a - 1)\n+    ///     }\n+    /// }\n+    /// # fn main() {\n+    /// #     print!(\"{}\", f(1));\n+    /// # }\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub ONLY_USED_IN_RECURSION,\n+    complexity,\n+    \"arguments that is only used in recursion can be removed\"\n+}\n+declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx rustc_hir::FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        id: HirId,\n+    ) {\n+        if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n+            let def_id = id.owner.to_def_id();\n+            let data = cx.tcx.def_path(def_id).data;\n+\n+            if data.len() > 1 {\n+                match data.get(data.len() - 2) {\n+                    Some(DisambiguatedDefPathData {\n+                        data: DefPathData::Impl,\n+                        disambiguator,\n+                    }) if *disambiguator != 0 => return,\n+                    _ => {},\n+                }\n+            }\n+\n+            let has_self = !matches!(decl.implicit_self, ImplicitSelfKind::None);\n+\n+            let ty_res = cx.typeck_results();\n+            let param_span = body\n+                .params\n+                .iter()\n+                .flat_map(|param| {\n+                    let mut v = Vec::new();\n+                    param.pat.each_binding(|_, hir_id, span, ident| {\n+                        v.push((hir_id, span, ident));\n+                    });\n+                    v\n+                })\n+                .skip(if has_self { 1 } else { 0 })\n+                .filter(|(_, _, ident)| !ident.name.as_str().starts_with('_'))\n+                .collect_vec();\n+\n+            let params = body.params.iter().map(|param| param.pat).collect();\n+\n+            let mut visitor = SideEffectVisit {\n+                graph: FxHashMap::default(),\n+                has_side_effect: FxHashSet::default(),\n+                ret_vars: Vec::new(),\n+                contains_side_effect: false,\n+                break_vars: FxHashMap::default(),\n+                params,\n+                fn_ident: ident,\n+                fn_def_id: def_id,\n+                is_method: matches!(kind, FnKind::Method(..)),\n+                has_self,\n+                ty_res,\n+                ty_ctx: cx.tcx,\n+            };\n+\n+            visitor.visit_expr(&body.value);\n+            let vars = std::mem::take(&mut visitor.ret_vars);\n+            // this would set the return variables to side effect\n+            visitor.add_side_effect(vars);\n+\n+            let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n+\n+            // a simple BFS to check all the variables that have side effect\n+            while let Some(id) = queue.pop_front() {\n+                if let Some(next) = visitor.graph.get(&id) {\n+                    for i in next {\n+                        if !visitor.has_side_effect.contains(i) {\n+                            visitor.has_side_effect.insert(*i);\n+                            queue.push_back(*i);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            for (id, span, ident) in param_span {\n+                // if the variable is not used in recursion, it would be marked as unused\n+                if !visitor.has_side_effect.contains(&id) {\n+                    let mut queue = VecDeque::new();\n+                    let mut visited = FxHashSet::default();\n+\n+                    queue.push_back(id);\n+\n+                    // a simple BFS to check the graph can reach to itself\n+                    // if it can't, it means the variable is never used in recursion\n+                    while let Some(id) = queue.pop_front() {\n+                        if let Some(next) = visitor.graph.get(&id) {\n+                            for i in next {\n+                                if !visited.contains(i) {\n+                                    visited.insert(id);\n+                                    queue.push_back(*i);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if visited.contains(&id) {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            ONLY_USED_IN_RECURSION,\n+                            span,\n+                            \"parameter is only used in recursion\",\n+                            \"if this is intentional, prefix with an underscore\",\n+                            format!(\"_{}\", ident.name.as_str()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn is_primitive(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n+        ty::Ref(_, t, _) => is_primitive(*t),\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_array(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(..) | ty::Slice(..) => true,\n+        ty::Ref(_, t, _) => is_array(*t),\n+        _ => false,\n+    }\n+}\n+\n+/// This builds the graph of side effect.\n+/// The edge `a -> b` means if `a` has side effect, `b` will have side effect.\n+///\n+/// There are some exmaple in following code:\n+/// ```rust, ignore\n+/// let b = 1;\n+/// let a = b; // a -> b\n+/// let (c, d) = (a, b); // c -> b, d -> b\n+///\n+/// let e = if a == 0 { // e -> a\n+///     c // e -> c\n+/// } else {\n+///     d // e -> d\n+/// };\n+/// ```\n+pub struct SideEffectVisit<'tcx> {\n+    graph: FxHashMap<HirId, FxHashSet<HirId>>,\n+    has_side_effect: FxHashSet<HirId>,\n+    // bool for if the variable was dereferenced from mutable reference\n+    ret_vars: Vec<(HirId, bool)>,\n+    contains_side_effect: bool,\n+    // break label\n+    break_vars: FxHashMap<Ident, Vec<(HirId, bool)>>,\n+    params: Vec<&'tcx Pat<'tcx>>,\n+    fn_ident: Ident,\n+    fn_def_id: DefId,\n+    is_method: bool,\n+    has_self: bool,\n+    ty_res: &'tcx TypeckResults<'tcx>,\n+    ty_ctx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n+    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n+        b.stmts.iter().for_each(|stmt| {\n+            self.visit_stmt(stmt);\n+            self.ret_vars.clear();\n+        });\n+        walk_list!(self, visit_expr, b.expr);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n+        match s.kind {\n+            StmtKind::Local(Local {\n+                pat, init: Some(init), ..\n+            }) => {\n+                self.visit_pat_expr(pat, init, false);\n+                self.ret_vars.clear();\n+            },\n+            StmtKind::Item(i) => {\n+                let item = self.ty_ctx.hir().item(i);\n+                self.visit_item(item);\n+                self.ret_vars.clear();\n+            },\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => {\n+                self.visit_expr(e);\n+                self.ret_vars.clear();\n+            },\n+            StmtKind::Local(_) => {},\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        match ex.kind {\n+            ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n+                self.ret_vars = exprs\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+            },\n+            ExprKind::Call(callee, args) => self.visit_fn(callee, args),\n+            ExprKind::MethodCall(path, args, _) => self.visit_method_call(path, args),\n+            ExprKind::Binary(_, lhs, rhs) => {\n+                self.visit_bin_op(lhs, rhs);\n+            },\n+            ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n+            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init, false),\n+            ExprKind::If(bind, then_expr, else_expr) => {\n+                self.visit_if(bind, then_expr, else_expr);\n+            },\n+            ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n+            // since analysing the closure is not easy, just set all variables in it to side-effect\n+            ExprKind::Closure(_, _, body_id, _, _) => {\n+                let body = self.ty_ctx.hir().body(body_id);\n+                self.visit_body(body);\n+                let vars = std::mem::take(&mut self.ret_vars);\n+                self.add_side_effect(vars);\n+            },\n+            ExprKind::Loop(block, label, _, _) | ExprKind::Block(block, label) => {\n+                self.visit_block_label(block, label);\n+            },\n+            ExprKind::Assign(bind, expr, _) => {\n+                self.visit_assign(bind, expr);\n+            },\n+            ExprKind::AssignOp(_, bind, expr) => {\n+                self.visit_assign(bind, expr);\n+                self.visit_bin_op(bind, expr);\n+            },\n+            ExprKind::Field(expr, _) => {\n+                self.visit_expr(expr);\n+                if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+                }\n+            },\n+            ExprKind::Index(expr, index) => {\n+                self.visit_expr(expr);\n+                let mut vars = std::mem::take(&mut self.ret_vars);\n+                self.visit_expr(index);\n+                self.ret_vars.append(&mut vars);\n+\n+                if !is_array(self.ty_res.expr_ty(expr)) {\n+                    self.add_side_effect(self.ret_vars.clone());\n+                } else if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+                }\n+            },\n+            ExprKind::Break(dest, Some(expr)) => {\n+                self.visit_expr(expr);\n+                if let Some(label) = dest.label {\n+                    self.break_vars\n+                        .entry(label.ident)\n+                        .or_insert(Vec::new())\n+                        .append(&mut self.ret_vars);\n+                }\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Ret(Some(expr)) => {\n+                self.visit_expr(expr);\n+                let vars = std::mem::take(&mut self.ret_vars);\n+                self.add_side_effect(vars);\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Break(_, None) | ExprKind::Continue(_) | ExprKind::Ret(None) => {\n+                self.contains_side_effect = true;\n+            },\n+            ExprKind::Struct(_, exprs, expr) => {\n+                let mut ret_vars = exprs\n+                    .iter()\n+                    .flat_map(|field| {\n+                        self.visit_expr(field.expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+\n+                walk_list!(self, visit_expr, expr);\n+                self.ret_vars.append(&mut ret_vars);\n+            },\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n+        if let Res::Local(id) = path.res {\n+            self.ret_vars.push((id, false));\n+        }\n+    }\n+}\n+\n+impl<'tcx> SideEffectVisit<'tcx> {\n+    fn visit_assign(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n+        // Just support array and tuple unwrapping for now.\n+        //\n+        // ex) `(a, b) = (c, d);`\n+        // The graph would look like this:\n+        //   a -> c\n+        //   b -> d\n+        //\n+        // This would minimize the connection of the side-effect graph.\n+        match (&lhs.kind, &rhs.kind) {\n+            (ExprKind::Array(lhs), ExprKind::Array(rhs)) | (ExprKind::Tup(lhs), ExprKind::Tup(rhs)) => {\n+                // if not, it is a compile error\n+                debug_assert!(lhs.len() == rhs.len());\n+                izip!(*lhs, *rhs).for_each(|(lhs, rhs)| self.visit_assign(lhs, rhs));\n+            },\n+            // in other assigns, we have to connect all each other\n+            // because they can be connected somehow\n+            _ => {\n+                self.visit_expr(lhs);\n+                let lhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.visit_expr(rhs);\n+                let rhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars, false);\n+            },\n+        }\n+    }\n+\n+    fn visit_block_label(&mut self, block: &'tcx Block<'tcx>, label: Option<Label>) {\n+        self.visit_block(block);\n+        let _ = label.and_then(|label| {\n+            self.break_vars\n+                .remove(&label.ident)\n+                .map(|mut break_vars| self.ret_vars.append(&mut break_vars))\n+        });\n+    }\n+\n+    fn visit_bin_op(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n+        self.visit_expr(lhs);\n+        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n+        self.visit_expr(rhs);\n+        self.ret_vars.append(&mut ret_vars);\n+\n+        // the binary operation between non primitive values are overloaded operators\n+        // so they can have side-effects\n+        if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n+            self.ret_vars.iter().for_each(|id| {\n+                self.has_side_effect.insert(id.0);\n+            });\n+            self.contains_side_effect = true;\n+        }\n+    }\n+\n+    fn visit_un_op(&mut self, op: UnOp, expr: &'tcx Expr<'tcx>) {\n+        self.visit_expr(expr);\n+        let ty = self.ty_res.expr_ty(expr);\n+        // dereferencing a reference has no side-effect\n+        if !is_primitive(ty) && !matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(..))) {\n+            self.add_side_effect(self.ret_vars.clone());\n+        }\n+\n+        if matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(_, _, Mutability::Mut))) {\n+            self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+        }\n+    }\n+\n+    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>, connect_self: bool) {\n+        match (&pat.kind, &expr.kind) {\n+            (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n+                self.ret_vars = izip!(*pats, *exprs)\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, connect_self);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+            },\n+            (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n+                let mut vars = izip!(*front_exprs, *exprs)\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, connect_self);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+                self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n+                    .flat_map(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, connect_self);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect();\n+                self.ret_vars.append(&mut vars);\n+            },\n+            _ => {\n+                let mut lhs_vars = Vec::new();\n+                pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n+                self.visit_expr(expr);\n+                let rhs_vars = std::mem::take(&mut self.ret_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars, connect_self);\n+                self.ret_vars = rhs_vars;\n+            },\n+        }\n+    }\n+\n+    fn visit_fn(&mut self, callee: &'tcx Expr<'tcx>, args: &'tcx [Expr<'tcx>]) {\n+        self.visit_expr(callee);\n+        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n+        self.add_side_effect(ret_vars.clone());\n+\n+        let mut is_recursive = false;\n+\n+        if_chain! {\n+            if !self.has_self;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind;\n+            if let Res::Def(DefKind::Fn, def_id) = path.res;\n+            if self.fn_def_id == def_id;\n+            then {\n+                is_recursive = true;\n+            }\n+        }\n+\n+        if_chain! {\n+            if !self.has_self && self.is_method;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, segment)) = callee.kind;\n+            if segment.ident == self.fn_ident;\n+            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+            if let Res::SelfTy{ .. } = path.res;\n+            then {\n+                is_recursive = true;\n+            }\n+        }\n+\n+        if is_recursive {\n+            izip!(self.params.clone(), args).for_each(|(pat, expr)| {\n+                self.visit_pat_expr(pat, expr, true);\n+                self.ret_vars.clear();\n+            });\n+        } else {\n+            // This would set arguments used in closure that does not have side-effect.\n+            // Closure itself can be detected whether there is a side-effect, but the\n+            // value of variable that is holding closure can change.\n+            // So, we just check the variables.\n+            self.ret_vars = args\n+                .iter()\n+                .flat_map(|expr| {\n+                    self.visit_expr(expr);\n+                    std::mem::take(&mut self.ret_vars)\n+                })\n+                .collect_vec()\n+                .into_iter()\n+                .map(|id| {\n+                    self.has_side_effect.insert(id.0);\n+                    id\n+                })\n+                .collect();\n+            self.contains_side_effect = true;\n+        }\n+\n+        self.ret_vars.append(&mut ret_vars);\n+    }\n+\n+    fn visit_method_call(&mut self, path: &'tcx PathSegment<'tcx>, args: &'tcx [Expr<'tcx>]) {\n+        if_chain! {\n+            if self.is_method;\n+            if path.ident == self.fn_ident;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = args.first().unwrap().kind;\n+            if let Res::Local(..) = path.res;\n+            let ident = path.segments.last().unwrap().ident;\n+            if ident.name == kw::SelfLower;\n+            then {\n+                izip!(self.params.clone(), args.iter())\n+                    .for_each(|(pat, expr)| {\n+                        self.visit_pat_expr(pat, expr, true);\n+                        self.ret_vars.clear();\n+                    });\n+            } else {\n+                self.ret_vars = args\n+                    .iter()\n+                    .flat_map(|expr| {\n+                        self.visit_expr(expr);\n+                        std::mem::take(&mut self.ret_vars)\n+                    })\n+                    .collect_vec()\n+                    .into_iter()\n+                    .map(|a| {\n+                        self.has_side_effect.insert(a.0);\n+                        a\n+                    })\n+                    .collect();\n+                self.contains_side_effect = true;\n+            }\n+        }\n+    }\n+\n+    fn visit_if(&mut self, bind: &'tcx Expr<'tcx>, then_expr: &'tcx Expr<'tcx>, else_expr: Option<&'tcx Expr<'tcx>>) {\n+        let contains_side_effect = self.contains_side_effect;\n+        self.contains_side_effect = false;\n+        self.visit_expr(bind);\n+        let mut vars = std::mem::take(&mut self.ret_vars);\n+        self.visit_expr(then_expr);\n+        let mut then_vars = std::mem::take(&mut self.ret_vars);\n+        walk_list!(self, visit_expr, else_expr);\n+        if self.contains_side_effect {\n+            self.add_side_effect(vars.clone());\n+        }\n+        self.contains_side_effect |= contains_side_effect;\n+        self.ret_vars.append(&mut vars);\n+        self.ret_vars.append(&mut then_vars);\n+    }\n+\n+    fn visit_match(&mut self, expr: &'tcx Expr<'tcx>, arms: &'tcx [Arm<'tcx>]) {\n+        self.visit_expr(expr);\n+        let mut expr_vars = std::mem::take(&mut self.ret_vars);\n+        self.ret_vars = arms\n+            .iter()\n+            .flat_map(|arm| {\n+                let contains_side_effect = self.contains_side_effect;\n+                self.contains_side_effect = false;\n+                // this would visit `expr` multiple times\n+                // but couldn't think of a better way\n+                self.visit_pat_expr(arm.pat, expr, false);\n+                let mut vars = std::mem::take(&mut self.ret_vars);\n+                let _ = arm.guard.as_ref().map(|guard| {\n+                    self.visit_expr(match guard {\n+                        Guard::If(expr) | Guard::IfLet(_, expr) => expr,\n+                    });\n+                    vars.append(&mut self.ret_vars);\n+                });\n+                self.visit_expr(arm.body);\n+                if self.contains_side_effect {\n+                    self.add_side_effect(vars.clone());\n+                    self.add_side_effect(expr_vars.clone());\n+                }\n+                self.contains_side_effect |= contains_side_effect;\n+                vars.append(&mut self.ret_vars);\n+                vars\n+            })\n+            .collect();\n+        self.ret_vars.append(&mut expr_vars);\n+    }\n+\n+    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)], connect_self: bool) {\n+        // if mutable dereference is on assignment it can have side-effect\n+        // (this can lead to parameter mutable dereference and change the original value)\n+        // too hard to detect whether this value is from parameter, so this would all\n+        // check mutable dereference assignment to side effect\n+        lhs.iter().filter(|(_, b)| *b).for_each(|(id, _)| {\n+            self.has_side_effect.insert(*id);\n+            self.contains_side_effect = true;\n+        });\n+\n+        // there is no connection\n+        if lhs.is_empty() || rhs.is_empty() {\n+            return;\n+        }\n+\n+        // by connected rhs in cycle, the connections would decrease\n+        // from `n * m` to `n + m`\n+        // where `n` and `m` are length of `lhs` and `rhs`.\n+\n+        // unwrap is possible since rhs is not empty\n+        let rhs_first = rhs.first().unwrap();\n+        for (id, _) in lhs.iter() {\n+            if connect_self || *id != rhs_first.0 {\n+                self.graph\n+                    .entry(*id)\n+                    .or_insert_with(FxHashSet::default)\n+                    .insert(rhs_first.0);\n+            }\n+        }\n+\n+        let rhs = rhs.iter();\n+        izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n+            if connect_self || from.0 != to.0 {\n+                self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n+            }\n+        });\n+    }\n+\n+    fn add_side_effect(&mut self, v: Vec<(HirId, bool)>) {\n+        for (id, _) in v {\n+            self.has_side_effect.insert(id);\n+            self.contains_side_effect = true;\n+        }\n+    }\n+}"}, {"sha": "899568a933f7afe196b890a5f81e146aca01ec2a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -123,7 +123,7 @@ impl QuestionMark {\n     }\n \n     fn result_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n-        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(cx, nested_expr, expr)\n+        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(nested_expr, expr)\n     }\n \n     fn option_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n@@ -156,9 +156,9 @@ impl QuestionMark {\n         }\n     }\n \n-    fn expression_returns_unmodified_err(cx: &LateContext<'_>, expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n+    fn expression_returns_unmodified_err(expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n         match peel_blocks_with_stmt(expr).kind {\n-            ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(cx, ret_expr, cond_expr),\n+            ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(ret_expr, cond_expr),\n             ExprKind::Path(_) => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         }"}, {"sha": "d371cafb16b13e017d8cdf7b160193753543636c", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -67,59 +67,51 @@ struct SortByKeyDetection {\n \n /// Detect if the two expressions are mirrored (identical, except one\n /// contains a and the other replaces it with b)\n-fn mirrored_exprs(\n-    cx: &LateContext<'_>,\n-    a_expr: &Expr<'_>,\n-    a_ident: &Ident,\n-    b_expr: &Expr<'_>,\n-    b_ident: &Ident,\n-) -> bool {\n+fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident: &Ident) -> bool {\n     match (&a_expr.kind, &b_expr.kind) {\n         // Two boxes with mirrored contents\n         (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => {\n-            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+            mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n         },\n         // Two arrays with mirrored contents\n         (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n         (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n-            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n-                && iter::zip(*left_args, *right_args)\n-                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n+                && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n         (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n             left_segment.ident == right_segment.ident\n-                && iter::zip(*left_args, *right_args)\n-                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+                && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n         },\n         // Two binary ops, which are the same operation and which have mirrored arguments\n         (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n             left_op.node == right_op.node\n-                && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n-                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident)\n+                && mirrored_exprs(left_left, a_ident, right_left, b_ident)\n+                && mirrored_exprs(left_right, a_ident, right_right, b_ident)\n         },\n         // Two unary ops, which are the same operation and which have the same argument\n         (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr)) => {\n-            left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+            left_op == right_op && mirrored_exprs(left_expr, a_ident, right_expr, b_ident)\n         },\n         // The two exprs are literals of some kind\n         (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n-        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(left, a_ident, right, b_ident),\n         (ExprKind::DropTemps(left_block), ExprKind::DropTemps(right_block)) => {\n-            mirrored_exprs(cx, left_block, a_ident, right_block, b_ident)\n+            mirrored_exprs(left_block, a_ident, right_block, b_ident)\n         },\n         (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident)) => {\n-            left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident)\n+            left_ident.name == right_ident.name && mirrored_exprs(left_expr, a_ident, right_expr, right_ident)\n         },\n         // Two paths: either one is a and the other is b, or they're identical to each other\n         (\n@@ -151,11 +143,9 @@ fn mirrored_exprs(\n         (\n             ExprKind::AddrOf(left_kind, Mutability::Not, left_expr),\n             ExprKind::AddrOf(right_kind, Mutability::Not, right_expr),\n-        ) => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => {\n-            mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident)\n-        },\n-        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        ) => left_kind == right_kind && mirrored_exprs(left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => mirrored_exprs(a_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(left_expr, a_ident, b_expr, b_ident),\n         _ => false,\n     }\n }\n@@ -176,14 +166,13 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n-                cx,\n                 left_expr,\n                 left_ident,\n                 right_expr,\n                 right_ident\n             ) {\n                 (Sugg::hir(cx, left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n-            } else if mirrored_exprs(cx, left_expr, right_ident, right_expr, left_ident) {\n+            } else if mirrored_exprs(left_expr, right_ident, right_expr, left_ident) {\n                 (Sugg::hir(cx, left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n             } else {\n                 return None;"}, {"sha": "4a5c597dda51fa3304afafe4174630eb62655db2", "filename": "tests/ui/crate_level_checks/no_std_main_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/tests%2Fui%2Fcrate_level_checks%2Fno_std_main_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/tests%2Fui%2Fcrate_level_checks%2Fno_std_main_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrate_level_checks%2Fno_std_main_recursion.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -12,12 +12,12 @@ static N: AtomicUsize = AtomicUsize::new(0);\n \n #[warn(clippy::main_recursion)]\n #[start]\n-fn main(argc: isize, argv: *const *const u8) -> isize {\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n     let x = N.load(Ordering::Relaxed);\n     N.store(x + 1, Ordering::Relaxed);\n \n     if x < 3 {\n-        main(argc, argv);\n+        main(_argc, _argv);\n     }\n \n     0"}, {"sha": "5768434f988ebf8b141fc4ee5e67a3971df67f29", "filename": "tests/ui/only_used_in_recursion.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/tests%2Fui%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/tests%2Fui%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.rs?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -0,0 +1,122 @@\n+#![warn(clippy::only_used_in_recursion)]\n+\n+fn simple(a: usize, b: usize) -> usize {\n+    if a == 0 { 1 } else { simple(a - 1, b) }\n+}\n+\n+fn with_calc(a: usize, b: isize) -> usize {\n+    if a == 0 { 1 } else { with_calc(a - 1, -b + 1) }\n+}\n+\n+fn tuple((a, b): (usize, usize)) -> usize {\n+    if a == 0 { 1 } else { tuple((a - 1, b + 1)) }\n+}\n+\n+fn let_tuple(a: usize, b: usize) -> usize {\n+    let (c, d) = (a, b);\n+    if c == 0 { 1 } else { let_tuple(c - 1, d + 1) }\n+}\n+\n+fn array([a, b]: [usize; 2]) -> usize {\n+    if a == 0 { 1 } else { array([a - 1, b + 1]) }\n+}\n+\n+fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+    if a == 0 { 1 } else { index(a - 1, b, c + b[0]) }\n+}\n+\n+fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n+    let c = loop {\n+        b += 1;\n+        c += 1;\n+        if c == 10 {\n+            break b;\n+        }\n+    };\n+\n+    if a == 0 { 1 } else { break_(a - 1, c, c) }\n+}\n+\n+// this has a side effect\n+fn mut_ref(a: usize, b: &mut usize) -> usize {\n+    *b = 1;\n+    if a == 0 { 1 } else { mut_ref(a - 1, b) }\n+}\n+\n+fn mut_ref2(a: usize, b: &mut usize) -> usize {\n+    let mut c = *b;\n+    if a == 0 { 1 } else { mut_ref2(a - 1, &mut c) }\n+}\n+\n+fn not_primitive(a: usize, b: String) -> usize {\n+    if a == 0 { 1 } else { not_primitive(a - 1, b) }\n+}\n+\n+// this doesn't have a side effect,\n+// but `String` is not primitive.\n+fn not_primitive_op(a: usize, b: String, c: &str) -> usize {\n+    if a == 1 { 1 } else { not_primitive_op(a, b + c, c) }\n+}\n+\n+struct A;\n+\n+impl A {\n+    fn method(a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { A::method(a - 1, b - 1) }\n+    }\n+\n+    fn method2(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.method2(a - 1, b + 1) }\n+    }\n+}\n+\n+trait B {\n+    fn hello(a: usize, b: usize) -> usize;\n+\n+    fn hello2(&self, a: usize, b: usize) -> usize;\n+}\n+\n+impl B for A {\n+    fn hello(a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { A::hello(a - 1, b + 1) }\n+    }\n+\n+    fn hello2(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    }\n+}\n+\n+trait C {\n+    fn hello(a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { Self::hello(a - 1, b + 1) }\n+    }\n+\n+    fn hello2(&self, a: usize, b: usize) -> usize {\n+        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    }\n+}\n+\n+fn ignore(a: usize, _: usize) -> usize {\n+    if a == 1 { 1 } else { ignore(a - 1, 0) }\n+}\n+\n+fn ignore2(a: usize, _b: usize) -> usize {\n+    if a == 1 { 1 } else { ignore2(a - 1, _b) }\n+}\n+\n+fn f1(a: u32) -> u32 {\n+    a\n+}\n+\n+fn f2(a: u32) -> u32 {\n+    f1(a)\n+}\n+\n+fn inner_fn(a: u32) -> u32 {\n+    fn inner_fn(a: u32) -> u32 {\n+        a\n+    }\n+    inner_fn(a)\n+}\n+\n+fn main() {}"}, {"sha": "6fe9361bf5feb2eee0d903887ae911f3673f5706", "filename": "tests/ui/only_used_in_recursion.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e2e492c10e8690814b6ab6df080ffe732b23b7fc/tests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2e492c10e8690814b6ab6df080ffe732b23b7fc/tests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.stderr?ref=e2e492c10e8690814b6ab6df080ffe732b23b7fc", "patch": "@@ -0,0 +1,82 @@\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:3:21\n+   |\n+LL | fn simple(a: usize, b: usize) -> usize {\n+   |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n+   |\n+   = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:7:24\n+   |\n+LL | fn with_calc(a: usize, b: isize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:11:14\n+   |\n+LL | fn tuple((a, b): (usize, usize)) -> usize {\n+   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:24\n+   |\n+LL | fn let_tuple(a: usize, b: usize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:20:14\n+   |\n+LL | fn array([a, b]: [usize; 2]) -> usize {\n+   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:24:20\n+   |\n+LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+   |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:24:37\n+   |\n+LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n+   |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:28:21\n+   |\n+LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n+   |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:46:23\n+   |\n+LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n+   |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:51:28\n+   |\n+LL | fn not_primitive(a: usize, b: String) -> usize {\n+   |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:68:33\n+   |\n+LL |     fn method2(&self, a: usize, b: usize) -> usize {\n+   |                                 ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:90:24\n+   |\n+LL |     fn hello(a: usize, b: usize) -> usize {\n+   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:94:32\n+   |\n+LL |     fn hello2(&self, a: usize, b: usize) -> usize {\n+   |                                ^ help: if this is intentional, prefix with an underscore: `_b`\n+\n+error: aborting due to 13 previous errors\n+"}]}