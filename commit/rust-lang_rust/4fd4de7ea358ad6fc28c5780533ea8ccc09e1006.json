{"sha": "4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "node_id": "C_kwDOAAsO6NoAKDRmZDRkZTdlYTM1OGFkNmZjMjhjNTc4MDUzM2VhOGNjYzA5ZTEwMDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T13:01:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T13:01:38Z"}, "message": "Auto merge of #101238 - RalfJung:rollup-bzcmobj, r=RalfJung\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #90946 (Ignore `reference`s in \"Type::inner_def_id\")\n - #100730 (Migrate rustc_monomorphize to use SessionDiagnostic)\n - #100753 (translations(rustc_session): migrates `rustc_session` to use `SessionDiagnostic` - Pt. 1)\n - #100831 (Migrate `symbol_mangling` module to new diagnostics structs)\n - #101204 (rustdoc: Resugar async fn return type in `clean`, not `html`)\n - #101216 (Use in-page links for sanitizer docs.)\n - #101237 (fix into_iter on ZST)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "375f93b95d1d9c9b54cab9683797a6f1d45731a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/375f93b95d1d9c9b54cab9683797a6f1d45731a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "html_url": "https://github.com/rust-lang/rust/commit/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e4fd0755d7d976d4ee0f2004dc938290752ff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "html_url": "https://github.com/rust-lang/rust/commit/12e4fd0755d7d976d4ee0f2004dc938290752ff7"}, {"sha": "2a0288266749800e621cfeb8e5404f0a8e6f9185", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a0288266749800e621cfeb8e5404f0a8e6f9185", "html_url": "https://github.com/rust-lang/rust/commit/2a0288266749800e621cfeb8e5404f0a8e6f9185"}], "stats": {"total": 893, "additions": 672, "deletions": 221}, "files": [{"sha": "002d73be7d1de67d1a7718ed60a75c00eb5984fe", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -3905,8 +3905,10 @@ name = \"rustc_monomorphize\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4154,7 +4156,9 @@ dependencies = [\n  \"punycode\",\n  \"rustc-demangle\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "c412e451a033e9619f2630e5362b5e0c12b4e08c", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -925,8 +925,11 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n     args: &[Value],\n     span: Span,\n ) {\n-    let def_id =\n-        fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+    let def_id = fx\n+        .tcx\n+        .lang_items()\n+        .require(lang_item)\n+        .unwrap_or_else(|e| fx.tcx.sess.span_fatal(span, e.to_string()));\n \n     let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n     let symbol_name = fx.tcx.symbol_name(instance).name;"}, {"sha": "68f3b19b715ad7563a672184f44ce9aa895f7aa0", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -1892,7 +1892,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n             }\n         });\n \n-        sess.cgu_reuse_tracker.check_expected_reuse(sess.diagnostic());\n+        sess.cgu_reuse_tracker.check_expected_reuse(sess);\n \n         sess.abort_if_errors();\n "}, {"sha": "42c84fdd2d14be92a8ff43dbb3f3768f3a291222", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,26 @@\n+monomorphize_recursion_limit =\n+    reached the recursion limit while instantiating `{$shrunk}`\n+    .note = `{$def_path_str}` defined here\n+\n+monomorphize_written_to_path = the full type name has been written to '{$path}'\n+\n+monomorphize_type_length_limit = reached the type-length limit while instantiating `{$shrunk}`\n+\n+monomorphize_consider_type_length_limit =\n+    consider adding a `#![type_length_limit=\"{$type_length}\"]` attribute to your crate\n+\n+monomorphize_fatal_error = {$error_message}\n+\n+monomorphize_unknown_partition_strategy = unknown partitioning strategy\n+\n+monomorphize_symbol_already_defined = symbol `{$symbol}` is already defined\n+\n+monomorphize_unused_generic_params = item has unused generic parameters\n+\n+monomorphize_large_assignments =\n+    moving {$size} bytes\n+    .label = value moved from here\n+    .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n+\n+monomorphize_requires_lang_item =\n+    requires `{$lang_item}` lang_item"}, {"sha": "983e5cee8237d801c8295fb85e706c993f0d5e7e", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,16 @@\n+session_incorrect_cgu_reuse_type =\n+    CGU-reuse for `{$cgu_user_name}` is `{$actual_reuse}` but should be {$at_least ->\n+    [one] {\"at least \"}\n+    *[other] {\"\"}\n+    }`{$expected_reuse}`\n+\n+session_cgu_not_recorded =\n+    CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded`\n+\n+session_feature_gate_error = {$explain}\n+\n+session_feature_diagnostic_for_issue =\n+    see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n+\n+session_feature_diagnostic_help =\n+    add `#![feature({$feature})]` to the crate attributes to enable"}, {"sha": "55d6fbbf86f33029d86bae9e7cdf6f3f968922eb", "filename": "compiler/rustc_error_messages/locales/en-US/symbol_mangling.ftl", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,7 @@\n+symbol_mangling_invalid_symbol_name = symbol-name({$mangled_formatted})\n+\n+symbol_mangling_invalid_trait_item = demangling({$demangling_formatted})\n+\n+symbol_mangling_alt_invalid_trait_item = demangling-alt({$alt_demangling_formatted})\n+\n+symbol_mangling_invalid_def_path = def-path({$def_path})"}, {"sha": "42fb2d538b04d2027cbb3b841cbf3fcd334b83f6", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -41,9 +41,11 @@ fluent_messages! {\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n+    session => \"../locales/en-US/session.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n+    monomorphize => \"../locales/en-US/monomorphize.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n@@ -52,6 +54,7 @@ fluent_messages! {\n     ty_utils => \"../locales/en-US/ty_utils.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n     mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n+    symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};"}, {"sha": "e593ed1044a5818e1f4cdb7765bd9bd75cb393d9", "filename": "compiler/rustc_hir/src/errors.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_hir%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_hir%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ferrors.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,10 @@\n+use crate::LangItem;\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub struct LangItemError(pub LangItem);\n+\n+impl ToString for LangItemError {\n+    fn to_string(&self) -> String {\n+        format!(\"requires `{}` lang_item\", self.0.name())\n+    }\n+}"}, {"sha": "0c01326d0032ac61842af06569cf493b714d7ed5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -8,6 +8,7 @@\n //! * Functions called by the compiler itself.\n \n use crate::def_id::DefId;\n+use crate::errors::LangItemError;\n use crate::{MethodKind, Target};\n \n use rustc_ast as ast;\n@@ -115,9 +116,9 @@ macro_rules! language_item_table {\n \n             /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n             /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-            /// returns an error message as a string.\n-            pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-                self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n+            /// returns an error encapsulating the `LangItem`.\n+            pub fn require(&self, it: LangItem) -> Result<DefId, LangItemError> {\n+                self.items[it as usize].ok_or_else(|| LangItemError(it))\n             }\n \n             /// Returns the [`DefId`]s of all lang items in a group."}, {"sha": "092029ef09ec80e6cab087b6b63838e94ed25f4e", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -27,6 +27,7 @@ pub mod def;\n pub mod def_path_hash_map;\n pub mod definitions;\n pub mod diagnostic_items;\n+pub mod errors;\n pub use rustc_span::def_id;\n mod hir;\n pub mod hir_id;"}, {"sha": "31c20fa14aaf5e819c23f6537fe6298ac2cba740", "filename": "compiler/rustc_middle/src/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -18,11 +18,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally aborts compilation.\n     pub fn require_lang_item(self, lang_item: LangItem, span: Option<Span>) -> DefId {\n-        self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n+        self.lang_items().require(lang_item).unwrap_or_else(|err| {\n             if let Some(span) = span {\n-                self.sess.span_fatal(span, &msg)\n+                self.sess.span_fatal(span, err.to_string())\n             } else {\n-                self.sess.fatal(&msg)\n+                self.sess.fatal(err.to_string())\n             }\n         })\n     }"}, {"sha": "59ca04ec868d159d32a2d62d65cfd8c67a196ace", "filename": "compiler/rustc_monomorphize/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2FCargo.toml?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -7,11 +7,13 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.8.1\", features = [ \"union\", \"may_dangle\" ] }\n tracing = \"0.1\"\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "170616d4b42ce76e62a6f12021907822b351e32c", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -207,6 +207,8 @@ use std::iter;\n use std::ops::Range;\n use std::path::PathBuf;\n \n+use crate::errors::{LargeAssignmentsLint, RecursionLimit, RequiresLangItem, TypeLengthLimit};\n+\n #[derive(PartialEq)]\n pub enum MonoItemCollectionMode {\n     Eager,\n@@ -604,17 +606,24 @@ fn check_recursion_limit<'tcx>(\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n     if !recursion_limit.value_within_limit(adjusted_recursion_depth) {\n+        let def_span = tcx.def_span(def_id);\n+        let def_path_str = tcx.def_path_str(def_id);\n         let (shrunk, written_to_path) = shrunk_instance_name(tcx, &instance, 32, 32);\n-        let error = format!(\"reached the recursion limit while instantiating `{}`\", shrunk);\n-        let mut err = tcx.sess.struct_span_fatal(span, &error);\n-        err.span_note(\n-            tcx.def_span(def_id),\n-            &format!(\"`{}` defined here\", tcx.def_path_str(def_id)),\n-        );\n-        if let Some(path) = written_to_path {\n-            err.note(&format!(\"the full type name has been written to '{}'\", path.display()));\n-        }\n-        err.emit()\n+        let mut path = PathBuf::new();\n+        let was_written = if written_to_path.is_some() {\n+            path = written_to_path.unwrap();\n+            Some(())\n+        } else {\n+            None\n+        };\n+        tcx.sess.emit_fatal(RecursionLimit {\n+            span,\n+            shrunk,\n+            def_span,\n+            def_path_str,\n+            was_written,\n+            path,\n+        });\n     }\n \n     recursion_depths.insert(def_id, recursion_depth + 1);\n@@ -642,16 +651,15 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     // Bail out in these cases to avoid that bad user experience.\n     if !tcx.type_length_limit().value_within_limit(type_length) {\n         let (shrunk, written_to_path) = shrunk_instance_name(tcx, &instance, 32, 32);\n-        let msg = format!(\"reached the type-length limit while instantiating `{}`\", shrunk);\n-        let mut diag = tcx.sess.struct_span_fatal(tcx.def_span(instance.def_id()), &msg);\n-        if let Some(path) = written_to_path {\n-            diag.note(&format!(\"the full type name has been written to '{}'\", path.display()));\n-        }\n-        diag.help(&format!(\n-            \"consider adding a `#![type_length_limit=\\\"{}\\\"]` attribute to your crate\",\n-            type_length\n-        ));\n-        diag.emit()\n+        let span = tcx.def_span(instance.def_id());\n+        let mut path = PathBuf::new();\n+        let was_written = if written_to_path.is_some() {\n+            path = written_to_path.unwrap();\n+            Some(())\n+        } else {\n+            None\n+        };\n+        tcx.sess.emit_fatal(TypeLengthLimit { span, shrunk, was_written, path, type_length });\n     }\n }\n \n@@ -914,17 +922,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // but correct span? This would make the lint at least accept crate-level lint attributes.\n                     return;\n                 };\n-                self.tcx.struct_span_lint_hir(\n+                self.tcx.emit_spanned_lint(\n                     LARGE_ASSIGNMENTS,\n                     lint_root,\n                     source_info.span,\n-                    |lint| {\n-                        let mut err = lint.build(&format!(\"moving {} bytes\", layout.size.bytes()));\n-                        err.span_label(source_info.span, \"value moved from here\");\n-                        err.note(&format!(r#\"The current maximum size is {}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\"#, limit.bytes()));\n-                        err.emit();\n+                    LargeAssignmentsLint {\n+                        span: source_info.span,\n+                        size: layout.size.bytes(),\n+                        limit: limit.bytes(),\n                     },\n-                );\n+                )\n             }\n         }\n     }\n@@ -1321,7 +1328,11 @@ impl<'v> RootCollector<'_, 'v> {\n \n         let start_def_id = match self.tcx.lang_items().require(LangItem::Start) {\n             Ok(s) => s,\n-            Err(err) => self.tcx.sess.fatal(&err),\n+            Err(lang_item_err) => {\n+                self.tcx\n+                    .sess\n+                    .emit_fatal(RequiresLangItem { lang_item: lang_item_err.0.name().to_string() });\n+            }\n         };\n         let main_ret_ty = self.tcx.fn_sig(main_def_id).output();\n "}, {"sha": "77b6cfa1f69f897822cf65c12146561830a29132", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,84 @@\n+use std::path::PathBuf;\n+\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic};\n+use rustc_session::SessionDiagnostic;\n+use rustc_span::Span;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(monomorphize::recursion_limit)]\n+pub struct RecursionLimit {\n+    #[primary_span]\n+    pub span: Span,\n+    pub shrunk: String,\n+    #[note]\n+    pub def_span: Span,\n+    pub def_path_str: String,\n+    #[note(monomorphize::written_to_path)]\n+    pub was_written: Option<()>,\n+    pub path: PathBuf,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(monomorphize::type_length_limit)]\n+#[help(monomorphize::consider_type_length_limit)]\n+pub struct TypeLengthLimit {\n+    #[primary_span]\n+    pub span: Span,\n+    pub shrunk: String,\n+    #[note(monomorphize::written_to_path)]\n+    pub was_written: Option<()>,\n+    pub path: PathBuf,\n+    pub type_length: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(monomorphize::requires_lang_item)]\n+pub struct RequiresLangItem {\n+    pub lang_item: String,\n+}\n+\n+pub struct UnusedGenericParams {\n+    pub span: Span,\n+    pub param_spans: Vec<Span>,\n+    pub param_names: Vec<String>,\n+}\n+\n+impl SessionDiagnostic<'_> for UnusedGenericParams {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::monomorphize::unused_generic_params);\n+        diag.set_span(self.span);\n+        for (span, name) in self.param_spans.into_iter().zip(self.param_names) {\n+            // FIXME: I can figure out how to do a label with a fluent string with a fixed message,\n+            // or a label with a dynamic value in a hard-coded string, but I haven't figured out\n+            // how to combine the two. \ud83d\ude22\n+            diag.span_label(span, format!(\"generic parameter `{}` is unused\", name));\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(monomorphize::large_assignments)]\n+#[note]\n+pub struct LargeAssignmentsLint {\n+    #[label]\n+    pub span: Span,\n+    pub size: u64,\n+    pub limit: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(monomorphize::unknown_partition_strategy)]\n+pub struct UnknownPartitionStrategy;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(monomorphize::symbol_already_defined)]\n+pub struct SymbolAlreadyDefined {\n+    #[primary_span]\n+    pub span: Option<Span>,\n+    pub symbol: String,\n+}"}, {"sha": "d64de44705bb2eaf7ea037a87af7516da3fac17c", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -3,6 +3,8 @@\n #![feature(let_else)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;\n@@ -16,6 +18,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n mod collector;\n+mod errors;\n mod partitioning;\n mod polymorphize;\n mod util;"}, {"sha": "932edc6675f5900cb6dd04d9678d7847345f0f9b", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -108,6 +108,7 @@ use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n use crate::collector::{self, MonoItemCollectionMode};\n+use crate::errors::{SymbolAlreadyDefined, UnknownPartitionStrategy};\n \n pub struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -149,7 +150,9 @@ fn get_partitioner<'tcx>(tcx: TyCtxt<'tcx>) -> Box<dyn Partitioner<'tcx>> {\n \n     match strategy {\n         \"default\" => Box::new(default::DefaultPartitioning),\n-        _ => tcx.sess.fatal(\"unknown partitioning strategy\"),\n+        _ => {\n+            tcx.sess.emit_fatal(UnknownPartitionStrategy);\n+        }\n     }\n }\n \n@@ -331,13 +334,7 @@ where\n                 (span1, span2) => span1.or(span2),\n             };\n \n-            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n-\n-            if let Some(span) = span {\n-                tcx.sess.span_fatal(span, &error_message)\n-            } else {\n-                tcx.sess.fatal(&error_message)\n-            }\n+            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n         }\n     }\n }"}, {"sha": "6e4ab2a35c3375e0c43b274ae285bf7fbd22f28d", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -22,6 +22,8 @@ use rustc_span::symbol::sym;\n use std::convert::TryInto;\n use std::ops::ControlFlow;\n \n+use crate::errors::UnusedGenericParams;\n+\n /// Provide implementations of queries relating to polymorphization analysis.\n pub fn provide(providers: &mut Providers) {\n     providers.unused_generic_params = unused_generic_params;\n@@ -206,22 +208,23 @@ fn emit_unused_generic_params_error<'tcx>(\n         _ => tcx.def_span(def_id),\n     };\n \n-    let mut err = tcx.sess.struct_span_err(fn_span, \"item has unused generic parameters\");\n-\n+    let mut param_spans = Vec::new();\n+    let mut param_names = Vec::new();\n     let mut next_generics = Some(generics);\n     while let Some(generics) = next_generics {\n         for param in &generics.params {\n             if unused_parameters.contains(param.index).unwrap_or(false) {\n                 debug!(?param);\n                 let def_span = tcx.def_span(param.def_id);\n-                err.span_label(def_span, &format!(\"generic parameter `{}` is unused\", param.name));\n+                param_spans.push(def_span);\n+                param_names.push(param.name.to_string());\n             }\n         }\n \n         next_generics = generics.parent.map(|did| tcx.generics_of(did));\n     }\n \n-    err.emit();\n+    tcx.sess.emit_err(UnusedGenericParams { span: fn_span, param_spans, param_names });\n }\n \n /// Visitor used to aggregate generic parameter uses."}, {"sha": "2a4a772f61085dfe13dfba1a48d4944cd39e0f56", "filename": "compiler/rustc_session/src/cgu_reuse_tracker.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -2,8 +2,13 @@\n //! compilation. This is used for incremental compilation tests and debug\n //! output.\n \n+use crate::errors::{CguNotRecorded, IncorrectCguReuseType};\n+use crate::Session;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+use std::fmt::{self};\n use std::sync::{Arc, Mutex};\n use tracing::debug;\n \n@@ -14,6 +19,22 @@ pub enum CguReuse {\n     PostLto,\n }\n \n+impl fmt::Display for CguReuse {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            CguReuse::No => write!(f, \"No\"),\n+            CguReuse::PreLto => write!(f, \"PreLto \"),\n+            CguReuse::PostLto => write!(f, \"PostLto \"),\n+        }\n+    }\n+}\n+\n+impl IntoDiagnosticArg for CguReuse {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum ComparisonKind {\n     Exact,\n@@ -84,7 +105,7 @@ impl CguReuseTracker {\n         }\n     }\n \n-    pub fn check_expected_reuse(&self, diag: &rustc_errors::Handler) {\n+    pub fn check_expected_reuse(&self, sess: &Session) {\n         if let Some(ref data) = self.data {\n             let data = data.lock().unwrap();\n \n@@ -98,19 +119,17 @@ impl CguReuseTracker {\n                     };\n \n                     if error {\n-                        let at_least = if at_least { \"at least \" } else { \"\" };\n-                        let msg = format!(\n-                            \"CGU-reuse for `{cgu_user_name}` is `{actual_reuse:?}` but \\\n-                                           should be {at_least}`{expected_reuse:?}`\"\n-                        );\n-                        diag.span_err(error_span.0, &msg);\n+                        let at_least = if at_least { 1 } else { 0 };\n+                        IncorrectCguReuseType {\n+                            span: error_span.0,\n+                            cgu_user_name: &cgu_user_name,\n+                            actual_reuse,\n+                            expected_reuse,\n+                            at_least,\n+                        };\n                     }\n                 } else {\n-                    let msg = format!(\n-                        \"CGU-reuse for `{cgu_user_name}` (mangled: `{cgu_name}`) was \\\n-                                       not recorded\"\n-                    );\n-                    diag.span_fatal(error_span.0, &msg)\n+                    sess.emit_fatal(CguNotRecorded { cgu_user_name, cgu_name });\n                 }\n             }\n         }"}, {"sha": "7252f1799dac178297ebcb0d024fea2444256e2f", "filename": "compiler/rustc_session/src/errors.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,45 @@\n+use std::num::NonZeroU32;\n+\n+use crate as rustc_session;\n+use crate::cgu_reuse_tracker::CguReuse;\n+use rustc_errors::MultiSpan;\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::incorrect_cgu_reuse_type)]\n+pub struct IncorrectCguReuseType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub cgu_user_name: &'a str,\n+    pub actual_reuse: CguReuse,\n+    pub expected_reuse: CguReuse,\n+    pub at_least: u8,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::cgu_not_recorded)]\n+pub struct CguNotRecorded<'a> {\n+    pub cgu_user_name: &'a str,\n+    pub cgu_name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(session::feature_gate_error, code = \"E0658\")]\n+pub struct FeatureGateError<'a> {\n+    #[primary_span]\n+    pub span: MultiSpan,\n+    pub explain: &'a str,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[note(session::feature_diagnostic_for_issue)]\n+pub struct FeatureDiagnosticForIssue {\n+    pub n: NonZeroU32,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[help(session::feature_diagnostic_help)]\n+pub struct FeatureDiagnosticHelp {\n+    pub feature: Symbol,\n+}"}, {"sha": "429475c573c8e8d01202e46d7ed7a1c8957ffd97", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -12,6 +12,7 @@\n \n #[macro_use]\n extern crate rustc_macros;\n+pub mod errors;\n \n pub mod cgu_reuse_tracker;\n pub mod utils;"}, {"sha": "ebec754dcffb841b063ed5ea0b4415bee8822345", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -2,6 +2,7 @@\n //! It also serves as an input to the parser itself.\n \n use crate::config::CheckCfg;\n+use crate::errors::{FeatureDiagnosticForIssue, FeatureDiagnosticHelp, FeatureGateError};\n use crate::lint::{\n     builtin::UNSTABLE_SYNTAX_PRE_EXPANSION, BufferedEarlyLint, BuiltinLintDiagnostics, Lint, LintId,\n };\n@@ -11,7 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n-    error_code, fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n+    fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n     DiagnosticMessage, EmissionGuarantee, ErrorGuaranteed, MultiSpan, StashKey,\n };\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n@@ -112,7 +113,7 @@ pub fn feature_err_issue<'a>(\n             .map(|err| err.cancel());\n     }\n \n-    let mut err = sess.span_diagnostic.struct_span_err_with_code(span, explain, error_code!(E0658));\n+    let mut err = sess.create_err(FeatureGateError { span, explain });\n     add_feature_diagnostics_for_issue(&mut err, sess, feature, issue);\n     err\n }\n@@ -130,6 +131,8 @@ pub fn feature_warn<'a>(sess: &'a ParseSess, feature: Symbol, span: Span, explai\n ///\n /// This variant allows you to control whether it is a library or language feature.\n /// Almost always, you want to use this for a language feature. If so, prefer `feature_warn`.\n+#[allow(rustc::diagnostic_outside_of_impl)]\n+#[allow(rustc::untranslatable_diagnostic)]\n pub fn feature_warn_issue<'a>(\n     sess: &'a ParseSess,\n     feature: Symbol,\n@@ -172,14 +175,12 @@ pub fn add_feature_diagnostics_for_issue<'a>(\n     issue: GateIssue,\n ) {\n     if let Some(n) = find_feature_issue(feature, issue) {\n-        err.note(&format!(\n-            \"see issue #{n} <https://github.com/rust-lang/rust/issues/{n}> for more information\"\n-        ));\n+        err.subdiagnostic(FeatureDiagnosticForIssue { n });\n     }\n \n     // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n     if sess.unstable_features.is_nightly_build() {\n-        err.help(&format!(\"add `#![feature({feature})]` to the crate attributes to enable\"));\n+        err.subdiagnostic(FeatureDiagnosticHelp { feature });\n     }\n }\n \n@@ -372,6 +373,8 @@ impl ParseSess {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n+    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -380,16 +383,22 @@ impl ParseSess {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n+    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.span_diagnostic.struct_warn(msg)\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n+    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         self.span_diagnostic.struct_fatal(msg)\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n+    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_diagnostic<G: EmissionGuarantee>(\n         &self,\n         msg: impl Into<DiagnosticMessage>,"}, {"sha": "3db05225722e71aad54fad9c2e6d53d288992353", "filename": "compiler/rustc_symbol_mangling/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2FCargo.toml?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -18,3 +18,5 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_session = { path = \"../rustc_session\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "242997365a892d693af193d91d18989b9df9350f", "filename": "compiler/rustc_symbol_mangling/src/errors.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,36 @@\n+//! Errors emitted by symbol_mangling.\n+\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::Span;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(symbol_mangling::invalid_symbol_name)]\n+pub struct InvalidSymbolName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub mangled_formatted: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(symbol_mangling::invalid_trait_item)]\n+pub struct InvalidTraitItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub demangling_formatted: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(symbol_mangling::alt_invalid_trait_item)]\n+pub struct AltInvalidTraitItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub alt_demangling_formatted: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(symbol_mangling::invalid_def_path)]\n+pub struct InvalidDefPath {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path: String,\n+}"}, {"sha": "0c6489acb34835085ceb32cd02f2223c5d05f8cf", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -91,6 +91,8 @@\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -110,6 +112,7 @@ use tracing::debug;\n mod legacy;\n mod v0;\n \n+pub mod errors;\n pub mod test;\n pub mod typeid;\n "}, {"sha": "b1c4cab11eb8e184772f74b8535e329072254381", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -4,6 +4,7 @@\n //! def-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n+use crate::errors::{AltInvalidTraitItem, InvalidDefPath, InvalidSymbolName, InvalidTraitItem};\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{subst::InternalSubsts, Instance, TyCtxt};\n@@ -59,16 +60,27 @@ impl SymbolNamesTest<'_> {\n                 tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def_id)),\n             );\n             let mangled = tcx.symbol_name(instance);\n-            tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n+            tcx.sess.emit_err(InvalidSymbolName {\n+                span: attr.span,\n+                mangled_formatted: format!(\"{mangled}\"),\n+            });\n             if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n-                tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n-                tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n+                tcx.sess.emit_err(InvalidTraitItem {\n+                    span: attr.span,\n+                    demangling_formatted: format!(\"{demangling}\"),\n+                });\n+                tcx.sess.emit_err(AltInvalidTraitItem {\n+                    span: attr.span,\n+                    alt_demangling_formatted: format!(\"{:#}\", demangling),\n+                });\n             }\n         }\n \n         for attr in tcx.get_attrs(def_id.to_def_id(), DEF_PATH) {\n-            let path = with_no_trimmed_paths!(tcx.def_path_str(def_id.to_def_id()));\n-            tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n+            tcx.sess.emit_err(InvalidDefPath {\n+                span: attr.span,\n+                def_path: with_no_trimmed_paths!(tcx.def_path_str(def_id.to_def_id())),\n+            });\n         }\n     }\n }"}, {"sha": "d08c0d4dbb72a6b5d12db254d92945dbca97d6bb", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -359,7 +359,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     let coerce_unsized_trait = tcx.require_lang_item(LangItem::CoerceUnsized, Some(span));\n \n     let unsize_trait = tcx.lang_items().require(LangItem::Unsize).unwrap_or_else(|err| {\n-        tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+        tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err.to_string()));\n     });\n \n     let source = tcx.type_of(impl_did);"}, {"sha": "b4157fd58954103340dfb9fb85f33fc7a3b4a9fc", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -266,7 +266,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             None\n         } else if mem::size_of::<T>() == 0 {\n             // See above for why 'ptr.offset' isn't used\n-            self.end = self.ptr.wrapping_byte_sub(1);\n+            self.end = self.end.wrapping_byte_sub(1);\n \n             // Make up a value of this ZST.\n             Some(unsafe { mem::zeroed() })"}, {"sha": "f140fc4143f3f50c37b54a24cf8357e2b01d90d8", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -1104,6 +1104,12 @@ fn test_into_iter_drop_allocator() {\n     assert_eq!(drop_count, 2);\n }\n \n+#[test]\n+fn test_into_iter_zst() {\n+    for _ in vec![[0u64; 0]].into_iter() {}\n+    for _ in vec![[0u64; 0]; 5].into_iter().rev() {}\n+}\n+\n #[test]\n fn test_from_iter_specialization() {\n     let src: Vec<usize> = vec![0usize; 1];"}, {"sha": "b33405f18e90bcc2c92672cdaecfdc0df869a78b", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -9,17 +9,17 @@ The tracking issues for this feature are:\n \n This feature allows for use of one of following sanitizers:\n \n-* [AddressSanitizer][clang-asan] a fast memory error detector.\n-* [ControlFlowIntegrity][clang-cfi] LLVM Control Flow Integrity (CFI) provides\n+* [AddressSanitizer](#addresssanitizer) a fast memory error detector.\n+* [ControlFlowIntegrity](#controlflowintegrity) LLVM Control Flow Integrity (CFI) provides\n   forward-edge control flow protection.\n-* [HWAddressSanitizer][clang-hwasan] a memory error detector similar to\n+* [HWAddressSanitizer](#hwaddresssanitizer) a memory error detector similar to\n   AddressSanitizer, but based on partial hardware assistance.\n-* [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n-* [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n-* [MemTagSanitizer][clang-memtag] fast memory error detector based on\n+* [LeakSanitizer](#leaksanitizer) a run-time memory leak detector.\n+* [MemorySanitizer](#memorysanitizer) a detector of uninitialized reads.\n+* [MemTagSanitizer](#memtagsanitizer) fast memory error detector based on\n   Armv8.5-A Memory Tagging Extension.\n-* [ShadowCallStack][clang-scs] provides backward-edge control flow protection.\n-* [ThreadSanitizer][clang-tsan] a fast data race detector.\n+* [ShadowCallStack](#shadowcallstack) provides backward-edge control flow protection.\n+* [ThreadSanitizer](#threadsanitizer) a fast data race detector.\n \n To enable a sanitizer compile with `-Zsanitizer=address`,`-Zsanitizer=cfi`,\n `-Zsanitizer=hwaddress`, `-Zsanitizer=leak`, `-Zsanitizer=memory`,\n@@ -58,6 +58,8 @@ AddressSanitizer works with non-instrumented code although it will impede its\n ability to detect some bugs.  It is not expected to produce false positive\n reports.\n \n+See the [Clang AddressSanitizer documentation][clang-asan] for more details.\n+\n ## Examples\n \n Stack buffer overflow:\n@@ -204,6 +206,8 @@ tracking issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n \n LLVM CFI can be enabled with -Zsanitizer=cfi and requires LTO (i.e., -Clto).\n \n+See the [Clang ControlFlowIntegrity documentation][clang-cfi] for more details.\n+\n ## Example\n \n ```text\n@@ -430,6 +434,8 @@ HWAddressSanitizer requires `tagged-globals` target feature to instrument\n globals. To enable this target feature compile with `-C\n target-feature=+tagged-globals`\n \n+See the [Clang HWAddressSanitizer documentation][clang-hwasan] for more details.\n+\n ## Example\n \n Heap buffer overflow:\n@@ -507,6 +513,8 @@ LeakSanitizer is supported on the following targets:\n * `x86_64-apple-darwin`\n * `x86_64-unknown-linux-gnu`\n \n+See the [Clang LeakSanitizer documentation][clang-lsan] for more details.\n+\n # MemorySanitizer\n \n MemorySanitizer is detector of uninitialized reads.\n@@ -521,6 +529,8 @@ MemorySanitizer requires all program code to be instrumented. C/C++ dependencies\n need to be recompiled using Clang with `-fsanitize=memory` option. Failing to\n achieve that will result in false positive reports.\n \n+See the [Clang MemorySanitizer documentation][clang-msan] for more details.\n+\n ## Example\n \n Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n@@ -569,7 +579,7 @@ MemTagSanitizer is supported on the following targets:\n MemTagSanitizer requires hardware support and the `mte` target feature.\n To enable this target feature compile with `-C target-feature=\"+mte\"`.\n \n-More information can be found in the associated [LLVM documentation](https://llvm.org/docs/MemTagSanitizer.html).\n+See the [LLVM MemTagSanitizer documentation][llvm-memtag] for more details.\n \n # ShadowCallStack\n \n@@ -581,7 +591,9 @@ ShadowCallStack can be enabled with `-Zsanitizer=shadow-call-stack` option and i\n \n * `aarch64-linux-android`\n \n-A runtime must be provided by the application or operating system. See the [LLVM documentation][clang-scs] for further details.\n+A runtime must be provided by the application or operating system.\n+\n+See the [Clang ShadowCallStack documentation][clang-scs] for more details.\n \n # ThreadSanitizer\n \n@@ -604,6 +616,8 @@ can lead to false positive reports.\n ThreadSanitizer does not support atomic fences `std::sync::atomic::fence`,\n nor synchronization performed using inline assembly code.\n \n+See the [Clang ThreadSanitizer documentation][clang-tsan] for more details.\n+\n ## Example\n \n ```rust\n@@ -673,6 +687,7 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n * [HWAddressSanitizer in Clang][clang-hwasan]\n * [LeakSanitizer in Clang][clang-lsan]\n * [MemorySanitizer in Clang][clang-msan]\n+* [MemTagSanitizer in LLVM][llvm-memtag]\n * [ThreadSanitizer in Clang][clang-tsan]\n \n [clang-asan]: https://clang.llvm.org/docs/AddressSanitizer.html\n@@ -682,3 +697,4 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html\n [clang-scs]: https://clang.llvm.org/docs/ShadowCallStack.html\n [clang-tsan]: https://clang.llvm.org/docs/ThreadSanitizer.html\n+[llvm-memtag]: https://llvm.org/docs/MemTagSanitizer.html"}, {"sha": "41f9eb3cdf6bd5bb040ab7359fd2764cfe831e1d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -886,7 +886,10 @@ fn clean_function<'tcx>(\n         // NOTE: generics must be cleaned before args\n         let generics = clean_generics(generics, cx);\n         let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n-        let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n+        let mut decl = clean_fn_decl_with_args(cx, sig.decl, args);\n+        if sig.header.is_async() {\n+            decl.output = decl.sugared_async_return_type();\n+        }\n         (generics, decl)\n     });\n     Box::new(Function { decl, generics })"}, {"sha": "6f49f00f93e5eb98abd62017ee1adaf0c7ca62c3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -1310,22 +1310,19 @@ impl clean::FnDecl {\n     ///   <br>Used to determine line-wrapping.\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n-    /// * `asyncness`: Whether the function is async or not.\n     pub(crate) fn full_print<'a, 'tcx: 'a>(\n         &'a self,\n         header_len: usize,\n         indent: usize,\n-        asyncness: hir::IsAsync,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        display_fn(move |f| self.inner_full_print(header_len, indent, asyncness, f, cx))\n+        display_fn(move |f| self.inner_full_print(header_len, indent, f, cx))\n     }\n \n     fn inner_full_print(\n         &self,\n         header_len: usize,\n         indent: usize,\n-        asyncness: hir::IsAsync,\n         f: &mut fmt::Formatter<'_>,\n         cx: &Context<'_>,\n     ) -> fmt::Result {\n@@ -1390,15 +1387,9 @@ impl clean::FnDecl {\n             args_plain.push_str(\", ...\");\n         }\n \n-        let arrow_plain;\n-        let arrow = if let hir::IsAsync::Async = asyncness {\n-            let output = self.sugared_async_return_type();\n-            arrow_plain = format!(\"{:#}\", output.print(cx));\n-            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", output.print(cx)) }\n-        } else {\n-            arrow_plain = format!(\"{:#}\", self.output.print(cx));\n-            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", self.output.print(cx)) }\n-        };\n+        let arrow_plain = format!(\"{:#}\", self.output.print(cx));\n+        let arrow =\n+            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", self.output.print(cx)) };\n \n         let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n         let output = if declaration_len > 80 {"}, {"sha": "eff34047e3c8fb93ac5bfa1b2f72351ecfc892cc", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 168, "deletions": 114, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -613,10 +613,10 @@ fn short_item_info(\n \n // Render the list of items inside one of the sections \"Trait Implementations\",\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n-fn render_impls(\n+pub(crate) fn render_impls(\n     cx: &mut Context<'_>,\n     w: &mut Buffer,\n-    impls: &[&&Impl],\n+    impls: &[&Impl],\n     containing_item: &clean::Item,\n     toggle_open_by_default: bool,\n ) {\n@@ -821,7 +821,7 @@ fn assoc_method(\n         href = href,\n         name = name,\n         generics = g.print(cx),\n-        decl = d.full_print(header_len, indent, header.asyncness, cx),\n+        decl = d.full_print(header_len, indent, cx),\n         notable_traits = notable_traits_decl(d, cx),\n         where_clause = print_where_clause(g, cx, indent, end_newline),\n     )\n@@ -1025,6 +1025,47 @@ impl<'a> AssocItemLink<'a> {\n     }\n }\n \n+fn write_impl_section_heading(w: &mut Buffer, title: &str, id: &str) {\n+    write!(\n+        w,\n+        \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n+            {title}\\\n+            <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n+         </h2>\"\n+    );\n+}\n+\n+pub(crate) fn render_all_impls(\n+    w: &mut Buffer,\n+    cx: &mut Context<'_>,\n+    containing_item: &clean::Item,\n+    concrete: &[&Impl],\n+    synthetic: &[&Impl],\n+    blanket_impl: &[&Impl],\n+) {\n+    let mut impls = Buffer::empty_from(w);\n+    render_impls(cx, &mut impls, concrete, containing_item, true);\n+    let impls = impls.into_inner();\n+    if !impls.is_empty() {\n+        write_impl_section_heading(w, \"Trait Implementations\", \"trait-implementations\");\n+        write!(w, \"<div id=\\\"trait-implementations-list\\\">{}</div>\", impls);\n+    }\n+\n+    if !synthetic.is_empty() {\n+        write_impl_section_heading(w, \"Auto Trait Implementations\", \"synthetic-implementations\");\n+        w.write_str(\"<div id=\\\"synthetic-implementations-list\\\">\");\n+        render_impls(cx, w, synthetic, containing_item, false);\n+        w.write_str(\"</div>\");\n+    }\n+\n+    if !blanket_impl.is_empty() {\n+        write_impl_section_heading(w, \"Blanket Implementations\", \"blanket-implementations\");\n+        w.write_str(\"<div id=\\\"blanket-implementations-list\\\">\");\n+        render_impls(cx, w, blanket_impl, containing_item, false);\n+        w.write_str(\"</div>\");\n+    }\n+}\n+\n fn render_assoc_items(\n     w: &mut Buffer,\n     cx: &mut Context<'_>,\n@@ -1054,12 +1095,7 @@ fn render_assoc_items_inner(\n         let mut tmp_buf = Buffer::empty_from(w);\n         let (render_mode, id) = match what {\n             AssocItemRender::All => {\n-                tmp_buf.write_str(\n-                    \"<h2 id=\\\"implementations\\\" class=\\\"small-section-header\\\">\\\n-                         Implementations\\\n-                         <a href=\\\"#implementations\\\" class=\\\"anchor\\\"></a>\\\n-                     </h2>\",\n-                );\n+                write_impl_section_heading(&mut tmp_buf, \"Implementations\", \"implementations\");\n                 (RenderMode::Normal, \"implementations-list\".to_owned())\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n@@ -1068,15 +1104,14 @@ fn render_assoc_items_inner(\n                 if let Some(def_id) = type_.def_id(cx.cache()) {\n                     cx.deref_id_map.insert(def_id, id.clone());\n                 }\n-                write!(\n-                    tmp_buf,\n-                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n-                         <span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\\\n-                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n-                     </h2>\",\n-                    id = id,\n-                    trait_ = trait_.print(cx),\n-                    type_ = type_.print(cx),\n+                write_impl_section_heading(\n+                    &mut tmp_buf,\n+                    &format!(\n+                        \"<span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\",\n+                        trait_ = trait_.print(cx),\n+                        type_ = type_.print(cx),\n+                    ),\n+                    &id,\n                 );\n                 (RenderMode::ForDeref { mut_: deref_mut_ }, cx.derive_id(id))\n             }\n@@ -1123,49 +1158,12 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n-            traits.iter().partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n             concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n-        let mut impls = Buffer::empty_from(w);\n-        render_impls(cx, &mut impls, &concrete, containing_item, true);\n-        let impls = impls.into_inner();\n-        if !impls.is_empty() {\n-            write!(\n-                w,\n-                \"<h2 id=\\\"trait-implementations\\\" class=\\\"small-section-header\\\">\\\n-                     Trait Implementations\\\n-                     <a href=\\\"#trait-implementations\\\" class=\\\"anchor\\\"></a>\\\n-                 </h2>\\\n-                 <div id=\\\"trait-implementations-list\\\">{}</div>\",\n-                impls\n-            );\n-        }\n-\n-        if !synthetic.is_empty() {\n-            w.write_str(\n-                \"<h2 id=\\\"synthetic-implementations\\\" class=\\\"small-section-header\\\">\\\n-                     Auto Trait Implementations\\\n-                     <a href=\\\"#synthetic-implementations\\\" class=\\\"anchor\\\"></a>\\\n-                 </h2>\\\n-                 <div id=\\\"synthetic-implementations-list\\\">\",\n-            );\n-            render_impls(cx, w, &synthetic, containing_item, false);\n-            w.write_str(\"</div>\");\n-        }\n-\n-        if !blanket_impl.is_empty() {\n-            w.write_str(\n-                \"<h2 id=\\\"blanket-implementations\\\" class=\\\"small-section-header\\\">\\\n-                     Blanket Implementations\\\n-                     <a href=\\\"#blanket-implementations\\\" class=\\\"anchor\\\"></a>\\\n-                 </h2>\\\n-                 <div id=\\\"blanket-implementations-list\\\">\",\n-            );\n-            render_impls(cx, w, &blanket_impl, containing_item, false);\n-            w.write_str(\"</div>\");\n-        }\n+        render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n }\n \n@@ -1970,6 +1968,70 @@ fn small_url_encode(s: String) -> String {\n     }\n }\n \n+pub(crate) fn sidebar_render_assoc_items(\n+    cx: &Context<'_>,\n+    out: &mut Buffer,\n+    id_map: &mut IdMap,\n+    concrete: Vec<&Impl>,\n+    synthetic: Vec<&Impl>,\n+    blanket_impl: Vec<&Impl>,\n+) {\n+    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n+        let mut links = FxHashSet::default();\n+\n+        let mut ret = impls\n+            .iter()\n+            .filter_map(|it| {\n+                let trait_ = it.inner_impl().trait_.as_ref()?;\n+                let encoded =\n+                    id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n+\n+                let i_display = format!(\"{:#}\", trait_.print(cx));\n+                let out = Escape(&i_display);\n+                let prefix = match it.inner_impl().polarity {\n+                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n+                    ty::ImplPolarity::Negative => \"!\",\n+                };\n+                let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n+                if links.insert(generated.clone()) { Some(generated) } else { None }\n+            })\n+            .collect::<Vec<String>>();\n+        ret.sort();\n+        ret\n+    };\n+\n+    let concrete_format = format_impls(concrete, id_map);\n+    let synthetic_format = format_impls(synthetic, id_map);\n+    let blanket_format = format_impls(blanket_impl, id_map);\n+\n+    if !concrete_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"trait-implementations\",\n+            \"Trait Implementations\",\n+            concrete_format.iter(),\n+        );\n+    }\n+\n+    if !synthetic_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"synthetic-implementations\",\n+            \"Auto Trait Implementations\",\n+            synthetic_format.iter(),\n+        );\n+    }\n+\n+    if !blanket_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"blanket-implementations\",\n+            \"Blanket Implementations\",\n+            blanket_format.iter(),\n+        );\n+    }\n+}\n+\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     let did = it.item_id.expect_def_id();\n     let cache = cx.cache();\n@@ -2018,65 +2080,12 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                 sidebar_deref_methods(cx, out, impl_, v, &mut derefs, &mut used_links);\n             }\n \n-            let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n-                let mut links = FxHashSet::default();\n-\n-                let mut ret = impls\n-                    .iter()\n-                    .filter_map(|it| {\n-                        let trait_ = it.inner_impl().trait_.as_ref()?;\n-                        let encoded =\n-                            id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n-\n-                        let i_display = format!(\"{:#}\", trait_.print(cx));\n-                        let out = Escape(&i_display);\n-                        let prefix = match it.inner_impl().polarity {\n-                            ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n-                            ty::ImplPolarity::Negative => \"!\",\n-                        };\n-                        let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n-                        if links.insert(generated.clone()) { Some(generated) } else { None }\n-                    })\n-                    .collect::<Vec<String>>();\n-                ret.sort();\n-                ret\n-            };\n-\n             let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n             let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n \n-            let concrete_format = format_impls(concrete, &mut id_map);\n-            let synthetic_format = format_impls(synthetic, &mut id_map);\n-            let blanket_format = format_impls(blanket_impl, &mut id_map);\n-\n-            if !concrete_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"trait-implementations\",\n-                    \"Trait Implementations\",\n-                    concrete_format.iter(),\n-                );\n-            }\n-\n-            if !synthetic_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"synthetic-implementations\",\n-                    \"Auto Trait Implementations\",\n-                    synthetic_format.iter(),\n-                );\n-            }\n-\n-            if !blanket_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"blanket-implementations\",\n-                    \"Blanket Implementations\",\n-                    blanket_format.iter(),\n-                );\n-            }\n+            sidebar_render_assoc_items(cx, out, &mut id_map, concrete, synthetic, blanket_impl);\n         }\n     }\n }\n@@ -2346,9 +2355,54 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     buf.push_str(\"</section>\")\n }\n \n+/// Returns the list of implementations for the primitive reference type, filtering out any\n+/// implementations that are on concrete or partially generic types, only keeping implementations\n+/// of the form `impl<T> Trait for &T`.\n+pub(crate) fn get_filtered_impls_for_reference<'a>(\n+    shared: &'a Rc<SharedContext<'_>>,\n+    it: &clean::Item,\n+) -> (Vec<&'a Impl>, Vec<&'a Impl>, Vec<&'a Impl>) {\n+    let def_id = it.item_id.expect_def_id();\n+    // If the reference primitive is somehow not defined, exit early.\n+    let Some(v) = shared.cache.impls.get(&def_id) else { return (Vec::new(), Vec::new(), Vec::new()) };\n+    // Since there is no \"direct implementation\" on the reference primitive type, we filter out\n+    // every implementation which isn't a trait implementation.\n+    let traits: Vec<_> = v.iter().filter(|i| i.inner_impl().trait_.is_some()).collect();\n+    let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+        traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+\n+    let (blanket_impl, concrete): (Vec<&Impl>, _) =\n+        concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n+    // Now we keep only references over full generic types.\n+    let concrete: Vec<_> = concrete\n+        .into_iter()\n+        .filter(|t| match t.inner_impl().for_ {\n+            clean::Type::BorrowedRef { ref type_, .. } => type_.is_full_generic(),\n+            _ => false,\n+        })\n+        .collect();\n+\n+    (concrete, synthetic, blanket_impl)\n+}\n+\n fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n     let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n+\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        sidebar_assoc_items(cx, &mut sidebar, it);\n+    } else {\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n+\n+        sidebar_render_assoc_items(\n+            cx,\n+            &mut sidebar,\n+            &mut IdMap::new(),\n+            concrete,\n+            synthetic,\n+            blanket_impl,\n+        );\n+    }\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<section>{}</section>\", sidebar.into_inner());"}, {"sha": "d63d4c2d159bab355547cfca026cbbb61e4b52a3", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -16,10 +16,10 @@ use std::fmt;\n use std::rc::Rc;\n \n use super::{\n-    collect_paths_for_type, document, ensure_trailing_slash, item_ty_to_section,\n-    notable_traits_decl, render_assoc_item, render_assoc_items, render_attributes_in_code,\n-    render_attributes_in_pre, render_impl, render_rightside, render_stability_since_raw,\n-    AssocItemLink, Context, ImplRenderingParameters,\n+    collect_paths_for_type, document, ensure_trailing_slash, get_filtered_impls_for_reference,\n+    item_ty_to_section, notable_traits_decl, render_all_impls, render_assoc_item,\n+    render_assoc_items, render_attributes_in_code, render_attributes_in_pre, render_impl,\n+    render_rightside, render_stability_since_raw, AssocItemLink, Context, ImplRenderingParameters,\n };\n use crate::clean;\n use crate::config::ModuleSorting;\n@@ -530,7 +530,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n                 name = name,\n                 generics = f.generics.print(cx),\n                 where_clause = print_where_clause(&f.generics, cx, 0, Ending::Newline),\n-                decl = f.decl.full_print(header_len, 0, header.asyncness, cx),\n+                decl = f.decl.full_print(header_len, 0, cx),\n                 notable_traits = notable_traits_decl(&f.decl, cx),\n             );\n         });\n@@ -1371,8 +1371,18 @@ fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &c\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n+    let def_id = it.item_id.expect_def_id();\n     document(w, cx, it, None, HeadingOffset::H2);\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n+    } else {\n+        // We handle the \"reference\" primitive type on its own because we only want to list\n+        // implementations on generic types.\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n+\n+        render_all_impls(w, cx, it, &concrete, &synthetic, &blanket_impl);\n+    }\n }\n \n fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {"}, {"sha": "b89781ca92da659f1a694b40c5ada4323987928e", "filename": "src/test/rustdoc-json/fns/async_return.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Ftest%2Frustdoc-json%2Ffns%2Fasync_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Ftest%2Frustdoc-json%2Ffns%2Fasync_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ffns%2Fasync_return.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,36 @@\n+// edition:2021\n+// ignore-tidy-linelength\n+\n+// Regression test for <https://github.com/rust-lang/rust/issues/101199>\n+\n+use std::future::Future;\n+\n+// @is \"$.index[*][?(@.name=='get_int')].inner.decl.output\" '{\"inner\": \"i32\", \"kind\": \"primitive\"}'\n+// @is \"$.index[*][?(@.name=='get_int')].inner.header.async\" false\n+pub fn get_int() -> i32 {\n+    42\n+}\n+\n+// @is \"$.index[*][?(@.name=='get_int_async')].inner.decl.output\" '{\"inner\": \"i32\", \"kind\": \"primitive\"}'\n+// @is \"$.index[*][?(@.name=='get_int_async')].inner.header.async\" true\n+pub async fn get_int_async() -> i32 {\n+    42\n+}\n+\n+// @is \"$.index[*][?(@.name=='get_int_future')].inner.decl.output.kind\" '\"impl_trait\"'\n+// @is \"$.index[*][?(@.name=='get_int_future')].inner.decl.output.inner[0].trait_bound.trait.name\" '\"Future\"'\n+// @is \"$.index[*][?(@.name=='get_int_future')].inner.decl.output.inner[0].trait_bound.trait.args.angle_bracketed.bindings[0].name\" '\"Output\"'\n+// @is \"$.index[*][?(@.name=='get_int_future')].inner.decl.output.inner[0].trait_bound.trait.args.angle_bracketed.bindings[0].binding.equality.type\" '{\"inner\": \"i32\", \"kind\": \"primitive\"}'\n+// @is \"$.index[*][?(@.name=='get_int_future')].inner.header.async\" false\n+pub fn get_int_future() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+// @is \"$.index[*][?(@.name=='get_int_future_async')].inner.decl.output.kind\" '\"impl_trait\"'\n+// @is \"$.index[*][?(@.name=='get_int_future_async')].inner.decl.output.inner[0].trait_bound.trait.name\" '\"Future\"'\n+// @is \"$.index[*][?(@.name=='get_int_future_async')].inner.decl.output.inner[0].trait_bound.trait.args.angle_bracketed.bindings[0].name\" '\"Output\"'\n+// @is \"$.index[*][?(@.name=='get_int_future_async')].inner.decl.output.inner[0].trait_bound.trait.args.angle_bracketed.bindings[0].binding.equality.type\" '{\"inner\": \"i32\", \"kind\": \"primitive\"}'\n+// @is \"$.index[*][?(@.name=='get_int_future_async')].inner.header.async\" true\n+pub async fn get_int_future_async() -> impl Future<Output = i32> {\n+    async { 42 }\n+}"}, {"sha": "5c1193406092244a7c76b5ff49d841b48f2bb844", "filename": "src/test/rustdoc/primitive-reference.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -0,0 +1,37 @@\n+#![crate_name = \"foo\"]\n+\n+#![feature(rustdoc_internals)]\n+\n+// @has foo/index.html\n+// @has - '//h2[@id=\"primitives\"]' 'Primitive Types'\n+// @has - '//a[@href=\"primitive.reference.html\"]' 'reference'\n+// @has - '//div[@class=\"sidebar-elems\"]//li/a' 'Primitive Types'\n+// @has - '//div[@class=\"sidebar-elems\"]//li/a/@href' '#primitives'\n+// @has foo/primitive.reference.html\n+// @has - '//a[@class=\"primitive\"]' 'reference'\n+// @has - '//span[@class=\"in-band\"]' 'Primitive Type reference'\n+// @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n+\n+// There should be only one implementation listed.\n+// @count - '//*[@class=\"impl has-srclink\"]' 1\n+// @has - '//*[@id=\"impl-Foo%3C%26A%3E-for-%26B\"]/*[@class=\"code-header in-band\"]' \\\n+//        'impl<A, B> Foo<&A> for &B'\n+#[doc(primitive = \"reference\")]\n+/// this is a test!\n+mod reference {}\n+\n+pub struct Bar;\n+\n+// This implementation should **not** show up.\n+impl<T> From<&T> for Bar {\n+    fn from(s: &T) -> Self {\n+        Bar\n+    }\n+}\n+\n+pub trait Foo<T> {\n+    fn stuff(&self, other: &T) {}\n+}\n+\n+// This implementation should show up.\n+impl<A, B> Foo<&A> for &B {}"}, {"sha": "84ac48b1e77b4ae610b45c204a22901536c97ddc", "filename": "src/test/ui/type_length_limit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fd4de7ea358ad6fc28c5780533ea8ccc09e1006/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.stderr?ref=4fd4de7ea358ad6fc28c5780533ea8ccc09e1006", "patch": "@@ -4,17 +4,17 @@ error: reached the type-length limit while instantiating `std::mem::drop::<Optio\n LL | pub fn drop<T>(_x: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the full type name has been written to '$TEST_BUILD_DIR/type_length_limit/type_length_limit.long-type.txt'\n    = help: consider adding a `#![type_length_limit=\"8\"]` attribute to your crate\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/type_length_limit/type_length_limit.long-type.txt'\n \n error: reached the type-length limit while instantiating `<[closure@std::rt::lang_start<()...e<()>>::call_once - shim(vtable)`\n   --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the full type name has been written to '$TEST_BUILD_DIR/type_length_limit/type_length_limit.long-type.txt'\n    = help: consider adding a `#![type_length_limit=\"8\"]` attribute to your crate\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/type_length_limit/type_length_limit.long-type.txt'\n \n error: aborting due to 2 previous errors\n "}]}