{"sha": "ed39e6d60a415f827aaca7fdbd571b309b1bb310", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzllNmQ2MGE0MTVmODI3YWFjYTdmZGJkNTcxYjMwOWIxYmIzMTA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-05T14:28:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-05T14:28:26Z"}, "message": "Rollup merge of #76078 - jyn514:no-disambiguator, r=manishearth\n\nRemove disambiguators from intra doc link text\n\nCloses https://github.com/rust-lang/rust/issues/65354.\nr? @Manishearth\n\nThe commits are mostly atomic, but there might be some mix between them here and there. I recommend reading 'refactor ItemLink' and 'refactor RenderedLink' on their own though, lots of churn without any logic changes.", "tree": {"sha": "d50ea79598797caa2451c2675f3f0322f2c5a871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d50ea79598797caa2451c2675f3f0322f2c5a871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed39e6d60a415f827aaca7fdbd571b309b1bb310", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfU6CKCRBK7hj4Ov3rIwAAdHIIAGKmcfJbKGRkNN84WCWP5xqv\nIwWju68393+w6wxBv5n3CqajoruPgLBGvGix54xjJa9aceC+PDlUckwAy+DJ8F1B\nyU668W5WUkOjqK44d5TvBimxSVoa1x+0Jcr6ZV+bQXYVlBOsGV2/JeGCnjO1YGhw\nUIvt4qIBHqvA9vI9EwI3Ud/Gdl80qmKPIkaQnmuNH56Or8B4c2B4Zy8rV1rpCNyK\nd4evMYU2fgdJLG51FlcoDH52f38v6UvRfFKR95yQHnt7zTfUm4YJEwINUsDykCHZ\nmZTfhYc5BDNrYwqGlfDhmklVmUwWzSNuR2/Jmct/rjNqRzb2DARAlAKtU5HBCQ8=\n=uC7k\n-----END PGP SIGNATURE-----\n", "payload": "tree d50ea79598797caa2451c2675f3f0322f2c5a871\nparent 86cf7976e2a81174a55aa9f77743764757f35597\nparent 18c14fde0d293a18fbd3c14487b52e1ce7daa205\nauthor Dylan DPC <dylan.dpc@gmail.com> 1599316106 +0200\ncommitter GitHub <noreply@github.com> 1599316106 +0200\n\nRollup merge of #76078 - jyn514:no-disambiguator, r=manishearth\n\nRemove disambiguators from intra doc link text\n\nCloses https://github.com/rust-lang/rust/issues/65354.\nr? @Manishearth\n\nThe commits are mostly atomic, but there might be some mix between them here and there. I recommend reading 'refactor ItemLink' and 'refactor RenderedLink' on their own though, lots of churn without any logic changes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed39e6d60a415f827aaca7fdbd571b309b1bb310", "html_url": "https://github.com/rust-lang/rust/commit/ed39e6d60a415f827aaca7fdbd571b309b1bb310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed39e6d60a415f827aaca7fdbd571b309b1bb310/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86cf7976e2a81174a55aa9f77743764757f35597", "url": "https://api.github.com/repos/rust-lang/rust/commits/86cf7976e2a81174a55aa9f77743764757f35597", "html_url": "https://github.com/rust-lang/rust/commit/86cf7976e2a81174a55aa9f77743764757f35597"}, {"sha": "18c14fde0d293a18fbd3c14487b52e1ce7daa205", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c14fde0d293a18fbd3c14487b52e1ce7daa205", "html_url": "https://github.com/rust-lang/rust/commit/18c14fde0d293a18fbd3c14487b52e1ce7daa205"}], "stats": {"total": 269, "additions": 229, "deletions": 40}, "files": [{"sha": "223fda84871e9725392f8c3c1717a34c0d3db1a9", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ed39e6d60a415f827aaca7fdbd571b309b1bb310", "patch": "@@ -118,7 +118,7 @@ impl Item {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    pub fn links(&self) -> Vec<(String, String)> {\n+    pub fn links(&self) -> Vec<RenderedLink> {\n         self.attrs.links(&self.def_id.krate)\n     }\n \n@@ -425,10 +425,38 @@ pub struct Attributes {\n     pub cfg: Option<Arc<Cfg>>,\n     pub span: Option<rustc_span::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n-    pub links: Vec<(String, Option<DefId>, Option<String>)>,\n+    pub links: Vec<ItemLink>,\n     pub inner_docs: bool,\n }\n \n+#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n+/// A link that has not yet been rendered.\n+///\n+/// This link will be turned into a rendered link by [`Attributes::links`]\n+pub struct ItemLink {\n+    /// The original link written in the markdown\n+    pub(crate) link: String,\n+    /// The link text displayed in the HTML.\n+    ///\n+    /// This may not be the same as `link` if there was a disambiguator\n+    /// in an intra-doc link (e.g. \\[`fn@f`\\])\n+    pub(crate) link_text: String,\n+    pub(crate) did: Option<DefId>,\n+    /// The url fragment to append to the link\n+    pub(crate) fragment: Option<String>,\n+}\n+\n+pub struct RenderedLink {\n+    /// The text the link was original written as.\n+    ///\n+    /// This could potentially include disambiguators and backticks.\n+    pub(crate) original_text: String,\n+    /// The text to display in the HTML\n+    pub(crate) new_text: String,\n+    /// The URL to put in the `href`\n+    pub(crate) href: String,\n+}\n+\n impl Attributes {\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n     pub fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n@@ -605,21 +633,25 @@ impl Attributes {\n     /// Gets links as a vector\n     ///\n     /// Cache must be populated before call\n-    pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n+    pub fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n         use crate::html::render::CURRENT_DEPTH;\n \n         self.links\n             .iter()\n-            .filter_map(|&(ref s, did, ref fragment)| {\n-                match did {\n+            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n+                match *did {\n                     Some(did) => {\n                         if let Some((mut href, ..)) = href(did) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push_str(\"#\");\n                                 href.push_str(fragment);\n                             }\n-                            Some((s.clone(), href))\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href,\n+                            })\n                         } else {\n                             None\n                         }\n@@ -639,16 +671,17 @@ impl Attributes {\n                             };\n                             // This is a primitive so the url is done \"by hand\".\n                             let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n-                            Some((\n-                                s.clone(),\n-                                format!(\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href: format!(\n                                     \"{}{}std/primitive.{}.html{}\",\n                                     url,\n                                     if !url.ends_with('/') { \"/\" } else { \"\" },\n                                     &fragment[..tail],\n                                     &fragment[tail..]\n                                 ),\n-                            ))\n+                            })\n                         } else {\n                             panic!(\"This isn't a primitive?!\");\n                         }"}, {"sha": "a8c60e4a76df4d8d38c315eb0c7e51af64ad1ff1", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 97, "deletions": 20, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ed39e6d60a415f827aaca7fdbd571b309b1bb310", "patch": "@@ -34,6 +34,7 @@ use std::fmt::Write;\n use std::ops::Range;\n use std::str;\n \n+use crate::clean::RenderedLink;\n use crate::doctest;\n use crate::html::highlight;\n use crate::html::toc::TocBuilder;\n@@ -52,7 +53,7 @@ fn opts() -> Options {\n pub struct Markdown<'a>(\n     pub &'a str,\n     /// A list of link replacements.\n-    pub &'a [(String, String)],\n+    pub &'a [RenderedLink],\n     /// The current list of used header IDs.\n     pub &'a mut IdMap,\n     /// Whether to allow the use of explicit error codes in doctest lang strings.\n@@ -78,7 +79,7 @@ pub struct MarkdownHtml<'a>(\n     pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n-pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n+pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ErrorCodes {\n@@ -337,31 +338,107 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n }\n \n /// Make headings links with anchor IDs and build up TOC.\n-struct LinkReplacer<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+struct LinkReplacer<'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n-    links: &'b [(String, String)],\n+    links: &'a [RenderedLink],\n+    shortcut_link: Option<&'a RenderedLink>,\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, 'b, I> {\n-    fn new(iter: I, links: &'b [(String, String)]) -> Self {\n-        LinkReplacer { inner: iter, links }\n+impl<'a, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, I> {\n+    fn new(iter: I, links: &'a [RenderedLink]) -> Self {\n+        LinkReplacer { inner: iter, links, shortcut_link: None }\n     }\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I> {\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Link(kind, dest, text))) = event {\n-            if let Some(&(_, ref replace)) = self.links.iter().find(|link| link.0 == *dest) {\n-                Some(Event::Start(Tag::Link(kind, replace.to_owned().into(), text)))\n-            } else {\n-                Some(Event::Start(Tag::Link(kind, dest, text)))\n+        use pulldown_cmark::LinkType;\n+\n+        let mut event = self.inner.next();\n+\n+        // Replace intra-doc links and remove disambiguators from shortcut links (`[fn@f]`).\n+        match &mut event {\n+            // This is a shortcut link that was resolved by the broken_link_callback: `[fn@f]`\n+            // Remove any disambiguator.\n+            Some(Event::Start(Tag::Link(\n+                // [fn@f] or [fn@f][]\n+                LinkType::ShortcutUnknown | LinkType::CollapsedUnknown,\n+                dest,\n+                title,\n+            ))) => {\n+                debug!(\"saw start of shortcut link to {} with title {}\", dest, title);\n+                // If this is a shortcut link, it was resolved by the broken_link_callback.\n+                // So the URL will already be updated properly.\n+                let link = self.links.iter().find(|&link| *link.href == **dest);\n+                // Since this is an external iterator, we can't replace the inner text just yet.\n+                // Store that we saw a link so we know to replace it later.\n+                if let Some(link) = link {\n+                    trace!(\"it matched\");\n+                    assert!(self.shortcut_link.is_none(), \"shortcut links cannot be nested\");\n+                    self.shortcut_link = Some(link);\n+                }\n             }\n-        } else {\n-            event\n+            // Now that we're done with the shortcut link, don't replace any more text.\n+            Some(Event::End(Tag::Link(\n+                LinkType::ShortcutUnknown | LinkType::CollapsedUnknown,\n+                dest,\n+                _,\n+            ))) => {\n+                debug!(\"saw end of shortcut link to {}\", dest);\n+                if self.links.iter().find(|&link| *link.href == **dest).is_some() {\n+                    assert!(self.shortcut_link.is_some(), \"saw closing link without opening tag\");\n+                    self.shortcut_link = None;\n+                }\n+            }\n+            // Handle backticks in inline code blocks, but only if we're in the middle of a shortcut link.\n+            // [`fn@f`]\n+            Some(Event::Code(text)) => {\n+                trace!(\"saw code {}\", text);\n+                if let Some(link) = self.shortcut_link {\n+                    trace!(\"original text was {}\", link.original_text);\n+                    // NOTE: this only replaces if the code block is the *entire* text.\n+                    // If only part of the link has code highlighting, the disambiguator will not be removed.\n+                    // e.g. [fn@`f`]\n+                    // This is a limitation from `collect_intra_doc_links`: it passes a full link,\n+                    // and does not distinguish at all between code blocks.\n+                    // So we could never be sure we weren't replacing too much:\n+                    // [fn@my_`f`unc] is treated the same as [my_func()] in that pass.\n+                    //\n+                    // NOTE: &[1..len() - 1] is to strip the backticks\n+                    if **text == link.original_text[1..link.original_text.len() - 1] {\n+                        debug!(\"replacing {} with {}\", text, link.new_text);\n+                        *text = CowStr::Borrowed(&link.new_text);\n+                    }\n+                }\n+            }\n+            // Replace plain text in links, but only in the middle of a shortcut link.\n+            // [fn@f]\n+            Some(Event::Text(text)) => {\n+                trace!(\"saw text {}\", text);\n+                if let Some(link) = self.shortcut_link {\n+                    trace!(\"original text was {}\", link.original_text);\n+                    // NOTE: same limitations as `Event::Code`\n+                    if **text == *link.original_text {\n+                        debug!(\"replacing {} with {}\", text, link.new_text);\n+                        *text = CowStr::Borrowed(&link.new_text);\n+                    }\n+                }\n+            }\n+            // If this is a link, but not a shortcut link,\n+            // replace the URL, since the broken_link_callback was not called.\n+            Some(Event::Start(Tag::Link(_, dest, _))) => {\n+                if let Some(link) = self.links.iter().find(|&link| *link.original_text == **dest) {\n+                    *dest = CowStr::Borrowed(link.href.as_ref());\n+                }\n+            }\n+            // Anything else couldn't have been a valid Rust path, so no need to replace the text.\n+            _ => {}\n         }\n+\n+        // Yield the modified event\n+        event\n     }\n }\n \n@@ -855,8 +932,8 @@ impl Markdown<'_> {\n             return String::new();\n         }\n         let replacer = |_: &str, s: &str| {\n-            if let Some(&(_, ref replace)) = links.iter().find(|link| &*link.0 == s) {\n-                Some((replace.clone(), s.to_owned()))\n+            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n+                Some((link.href.clone(), link.new_text.clone()))\n             } else {\n                 None\n             }\n@@ -933,8 +1010,8 @@ impl MarkdownSummaryLine<'_> {\n         }\n \n         let replacer = |_: &str, s: &str| {\n-            if let Some(&(_, ref replace)) = links.iter().find(|link| &*link.0 == s) {\n-                Some((replace.clone(), s.to_owned()))\n+            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n+                Some((link.href.clone(), link.new_text.clone()))\n             } else {\n                 None\n             }"}, {"sha": "f095f67b54c635fe44256375b671b712398ca4df", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=ed39e6d60a415f827aaca7fdbd571b309b1bb310", "patch": "@@ -63,9 +63,8 @@ use rustc_span::symbol::{sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n-use crate::config::RenderInfo;\n-use crate::config::RenderOptions;\n+use crate::clean::{self, AttributesExt, Deprecation, GetDefId, RenderedLink, SelfTy, TypeKind};\n+use crate::config::{RenderInfo, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n use crate::doctree;\n use crate::error::Error;\n@@ -1774,7 +1773,7 @@ fn render_markdown(\n     w: &mut Buffer,\n     cx: &Context,\n     md_text: &str,\n-    links: Vec<(String, String)>,\n+    links: Vec<RenderedLink>,\n     prefix: &str,\n     is_hidden: bool,\n ) {"}, {"sha": "13bfca4c5cdbf1f8dca5a6e852a67d8d736b7ba4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=ed39e6d60a415f827aaca7fdbd571b309b1bb310", "patch": "@@ -697,11 +697,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     // This is an anchor to an element of the current page, nothing to do in here!\n                     continue;\n                 }\n-                (parts[0].to_owned(), Some(parts[1].to_owned()))\n+                (parts[0], Some(parts[1].to_owned()))\n             } else {\n-                (parts[0].to_owned(), None)\n+                (parts[0], None)\n             };\n             let resolved_self;\n+            let link_text;\n             let mut path_str;\n             let disambiguator;\n             let (mut res, mut fragment) = {\n@@ -718,6 +719,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     continue;\n                 }\n \n+                // We stripped `()` and `!` when parsing the disambiguator.\n+                // Add them back to be displayed, but not prefix disambiguators.\n+                link_text = disambiguator\n+                    .map(|d| d.display_for(path_str))\n+                    .unwrap_or_else(|| path_str.to_owned());\n+\n                 // In order to correctly resolve intra-doc-links we need to\n                 // pick a base AST node to work from.  If the documentation for\n                 // this module came from an inner comment (//!) then we anchor\n@@ -906,7 +913,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             if let Res::PrimTy(_) = res {\n                 match disambiguator {\n                     Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                        item.attrs.links.push((ori_link, None, fragment))\n+                        item.attrs.links.push(ItemLink {\n+                            link: ori_link,\n+                            link_text: path_str.to_owned(),\n+                            did: None,\n+                            fragment,\n+                        });\n                     }\n                     Some(other) => {\n                         report_mismatch(other, Disambiguator::Primitive);\n@@ -957,7 +969,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n                 let id = register_res(cx, res);\n-                item.attrs.links.push((ori_link, Some(id), fragment));\n+                item.attrs.links.push(ItemLink {\n+                    link: ori_link,\n+                    link_text,\n+                    did: Some(id),\n+                    fragment,\n+                });\n             }\n         }\n \n@@ -985,6 +1002,18 @@ enum Disambiguator {\n }\n \n impl Disambiguator {\n+    /// The text that should be displayed when the path is rendered as HTML.\n+    ///\n+    /// NOTE: `path` is not the original link given by the user, but a name suitable for passing to `resolve`.\n+    fn display_for(&self, path: &str) -> String {\n+        match self {\n+            // FIXME: this will have different output if the user had `m!()` originally.\n+            Self::Kind(DefKind::Macro(MacroKind::Bang)) => format!(\"{}!\", path),\n+            Self::Kind(DefKind::Fn) => format!(\"{}()\", path),\n+            _ => path.to_owned(),\n+        }\n+    }\n+\n     /// (disambiguator, path_str)\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};\n@@ -1037,7 +1066,7 @@ impl Disambiguator {\n     }\n \n     /// Return (description of the change, suggestion)\n-    fn display_for(self, path_str: &str) -> (&'static str, String) {\n+    fn suggestion_for(self, path_str: &str) -> (&'static str, String) {\n         const PREFIX: &str = \"prefix with the item kind\";\n         const FUNCTION: &str = \"add parentheses\";\n         const MACRO: &str = \"add an exclamation mark\";\n@@ -1292,7 +1321,7 @@ fn suggest_disambiguator(\n     sp: Option<rustc_span::Span>,\n     link_range: &Option<Range<usize>>,\n ) {\n-    let (action, mut suggestion) = disambiguator.display_for(path_str);\n+    let (action, mut suggestion) = disambiguator.suggestion_for(path_str);\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), action);\n \n     if let Some(sp) = sp {"}, {"sha": "26d05b484b919b73ec6b0729eecfae0038b0d815", "filename": "src/test/rustdoc/intra-link-disambiguators-removed.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed39e6d60a415f827aaca7fdbd571b309b1bb310/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs?ref=ed39e6d60a415f827aaca7fdbd571b309b1bb310", "patch": "@@ -0,0 +1,51 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+// first try backticks\n+/// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n+// @has intra_link_disambiguators_removed/struct.AtDisambiguator.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"][code]' \"Name\"\n+pub struct AtDisambiguator;\n+\n+/// fn: [`Name()`], macro: [`Name!`]\n+// @has intra_link_disambiguators_removed/struct.SymbolDisambiguator.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name()\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"][code]' \"Name!\"\n+pub struct SymbolDisambiguator;\n+\n+// Now make sure that backticks aren't added if they weren't already there\n+/// [fn@Name]\n+// @has intra_link_disambiguators_removed/trait.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"]' \"Name\"\n+// @!has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+\n+// FIXME: this will turn !() into ! alone\n+/// [Name!()]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"]' \"Name!\"\n+pub trait Name {}\n+\n+#[allow(non_snake_case)]\n+\n+// Try collapsed reference links\n+/// [macro@Name][]\n+// @has intra_link_disambiguators_removed/fn.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"]' \"Name\"\n+\n+// Try links that have the same text as a generated URL\n+/// Weird URL aligned [../intra_link_disambiguators_removed/macro.Name.html][trait@Name]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"]' \"../intra_link_disambiguators_removed/macro.Name.html\"\n+pub fn Name() {}\n+\n+#[macro_export]\n+// Rustdoc doesn't currently handle links that have weird interspersing of inline code blocks.\n+/// [fn@Na`m`e]\n+// @has intra_link_disambiguators_removed/macro.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"]' \"fn@Name\"\n+\n+// It also doesn't handle any case where the code block isn't the whole link text:\n+/// [trait@`Name`]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"]' \"trait@Name\"\n+macro_rules! Name {\n+    () => ()\n+}"}]}