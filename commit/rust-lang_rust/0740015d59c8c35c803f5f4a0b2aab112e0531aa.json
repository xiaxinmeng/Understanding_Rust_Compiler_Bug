{"sha": "0740015d59c8c35c803f5f4a0b2aab112e0531aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NDAwMTVkNTljOGMzNWM4MDNmNWY0YTBiMmFhYjExMmUwNTMxYWE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-05-10T14:15:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-10T14:15:00Z"}, "message": "Rollup merge of #85050 - FabianWolff:issue-84592, r=jackh726\n\nFix suggestions for missing return type lifetime specifiers\n\nThis pull request aims to fix #84592. The issue is that the current code seems to assume that there is only a single relevant span pointing to the missing lifetime, and only looks at the first one:\nhttps://github.com/rust-lang/rust/blob/e5f83d24aee866a14753a7cedbb4e301dfe5bef5/compiler/rustc_resolve/src/late/lifetimes.rs#L2959\n\nThis is incorrect, though, and leads to incorrect error messages and invalid suggestions. For instance, the example from #84592:\n```rust\nstruct TwoLifetimes<'x, 'y> {\n    x: &'x (),\n    y: &'y (),\n}\n\nfn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n    TwoLifetimes { x: &(), y: &() }\n}\n```\ncurrently leads to:\n```\nerror[E0106]: missing lifetime specifiers\n --> src/main.rs:6:57\n  |\n6 | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n  |                            ---     ---                  ^^ expected 2 lifetime parameters\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\nhelp: consider introducing a named lifetime parameter\n  |\n6 | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'_<'a, 'a>, '_> {\n  |                        ^^^^    ^^^^^^     ^^^^^^                  ^^^^^^^^^^\n```\nThere are two problems:\n- The error message is wrong. There is only _one_ lifetime parameter expected at the location pointed to by the error message (and another one at a separate location).\n- The suggestion is incorrect and will not lead to correct code.\n\nWith the changes in this PR, I get the following output:\n```\nerror[E0106]: missing lifetime specifiers\n --> p.rs:6:57\n  |\n6 | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n  |                            ---     ---                  ^^  ^^ expected named lifetime parameter\n  |                                                         |\n  |                                                         expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\nhelp: consider introducing a named lifetime parameter\n  |\n6 | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'a, 'a> {\n  |                        ^^^^    ^^^^^^     ^^^^^^                  ^^  ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0106`.\n```\nMainly, I changed `add_missing_lifetime_specifiers_label()` to receive a _vector_ of spans (and counts) instead of just one, and adjusted its body accordingly.", "tree": {"sha": "f62ac654c143a9dbf6cd9c85717d8d567200586e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f62ac654c143a9dbf6cd9c85717d8d567200586e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0740015d59c8c35c803f5f4a0b2aab112e0531aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgmT/kCRBK7hj4Ov3rIwAACdYIAJRiDcsTlKZTgTiEXbMzTFR0\n5S0mrL0N8TbXVhNfGNRAZz5sMb8toPsoQv0BbK5adZINEfLe1DFXMvEvglfDmKSd\ntjTIV++1oPPr3h0o07nwQ7PM2puqe+ZJUYZRNHgk8jAYg+Ju2imtXjnTAmYGGzPo\ngLCH9ntS+hUxi9bBzpX544nQOwpLUfeF6UcDKyD6DBiuUsLFaSwHXf/1a4dpcY90\ntLkSl6jRwlMm1eqL1a452J638OJztdHuVUIz1sWkyulLKVDhl0XAyb/aB7llLSBS\nZj7+sUD1GHl2kMVBH5aMqyvPrkopvI/Flv+Fuqz4mn6oglpRMq637lnQEGHWkFM=\n=4HLn\n-----END PGP SIGNATURE-----\n", "payload": "tree f62ac654c143a9dbf6cd9c85717d8d567200586e\nparent 1b30245ea1286df96d673015c4519c861e06977a\nparent 2448c7698ef186ead88bd7980f2cac28c55111a8\nauthor Dylan DPC <dylan.dpc@gmail.com> 1620656100 +0200\ncommitter GitHub <noreply@github.com> 1620656100 +0200\n\nRollup merge of #85050 - FabianWolff:issue-84592, r=jackh726\n\nFix suggestions for missing return type lifetime specifiers\n\nThis pull request aims to fix #84592. The issue is that the current code seems to assume that there is only a single relevant span pointing to the missing lifetime, and only looks at the first one:\nhttps://github.com/rust-lang/rust/blob/e5f83d24aee866a14753a7cedbb4e301dfe5bef5/compiler/rustc_resolve/src/late/lifetimes.rs#L2959\n\nThis is incorrect, though, and leads to incorrect error messages and invalid suggestions. For instance, the example from #84592:\n```rust\nstruct TwoLifetimes<'x, 'y> {\n    x: &'x (),\n    y: &'y (),\n}\n\nfn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n    TwoLifetimes { x: &(), y: &() }\n}\n```\ncurrently leads to:\n```\nerror[E0106]: missing lifetime specifiers\n --> src/main.rs:6:57\n  |\n6 | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n  |                            ---     ---                  ^^ expected 2 lifetime parameters\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\nhelp: consider introducing a named lifetime parameter\n  |\n6 | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'_<'a, 'a>, '_> {\n  |                        ^^^^    ^^^^^^     ^^^^^^                  ^^^^^^^^^^\n```\nThere are two problems:\n- The error message is wrong. There is only _one_ lifetime parameter expected at the location pointed to by the error message (and another one at a separate location).\n- The suggestion is incorrect and will not lead to correct code.\n\nWith the changes in this PR, I get the following output:\n```\nerror[E0106]: missing lifetime specifiers\n --> p.rs:6:57\n  |\n6 | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n  |                            ---     ---                  ^^  ^^ expected named lifetime parameter\n  |                                                         |\n  |                                                         expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\nhelp: consider introducing a named lifetime parameter\n  |\n6 | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'a, 'a> {\n  |                        ^^^^    ^^^^^^     ^^^^^^                  ^^  ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0106`.\n```\nMainly, I changed `add_missing_lifetime_specifiers_label()` to receive a _vector_ of spans (and counts) instead of just one, and adjusted its body accordingly.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0740015d59c8c35c803f5f4a0b2aab112e0531aa", "html_url": "https://github.com/rust-lang/rust/commit/0740015d59c8c35c803f5f4a0b2aab112e0531aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0740015d59c8c35c803f5f4a0b2aab112e0531aa/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b30245ea1286df96d673015c4519c861e06977a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b30245ea1286df96d673015c4519c861e06977a", "html_url": "https://github.com/rust-lang/rust/commit/1b30245ea1286df96d673015c4519c861e06977a"}, {"sha": "2448c7698ef186ead88bd7980f2cac28c55111a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2448c7698ef186ead88bd7980f2cac28c55111a8", "html_url": "https://github.com/rust-lang/rust/commit/2448c7698ef186ead88bd7980f2cac28c55111a8"}], "stats": {"total": 641, "additions": 493, "deletions": 148}, "files": [{"sha": "14ccced2c6a56678fd4e6f4ac2d5d34555a57c52", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -282,6 +282,22 @@ impl Diagnostic {\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n+    ) -> &mut Self {\n+        self.multipart_suggestion_with_style(\n+            msg,\n+            suggestion,\n+            applicability,\n+            SuggestionStyle::ShowCode,\n+        )\n+    }\n+\n+    /// [`Diagnostic::multipart_suggestion()`] but you can set the [`SuggestionStyle`].\n+    pub fn multipart_suggestion_with_style(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+        applicability: Applicability,\n+        style: SuggestionStyle,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n         self.suggestions.push(CodeSuggestion {\n@@ -292,7 +308,7 @@ impl Diagnostic {\n                     .collect(),\n             }],\n             msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n             tool_metadata: Default::default(),\n         });"}, {"sha": "fdde687d4866c57913ca31bcb8de7394f24b4ed8", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 191, "deletions": 143, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n@@ -1687,12 +1687,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n impl<'tcx> LifetimeContext<'_, 'tcx> {\n     crate fn report_missing_lifetime_specifiers(\n         &self,\n-        span: Span,\n+        spans: Vec<Span>,\n         count: usize,\n     ) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             self.tcx.sess,\n-            span,\n+            spans,\n             E0106,\n             \"missing lifetime specifier{}\",\n             pluralize!(count)\n@@ -1821,81 +1821,107 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     crate fn add_missing_lifetime_specifiers_label(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        span: Span,\n-        count: usize,\n+        spans_with_counts: Vec<(Span, usize)>,\n         lifetime_names: &FxHashSet<Symbol>,\n         lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n-        let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n-\n-        err.span_label(\n-            span,\n-            &format!(\n-                \"expected {} lifetime parameter{}\",\n-                if count == 1 { \"named\".to_string() } else { count.to_string() },\n-                pluralize!(count)\n-            ),\n-        );\n+        let snippets: Vec<Option<String>> = spans_with_counts\n+            .iter()\n+            .map(|(span, _)| self.tcx.sess.source_map().span_to_snippet(*span).ok())\n+            .collect();\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n-                                name: &str,\n-                                formatter: &dyn Fn(&str) -> String| {\n-            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n-                self.missing_named_lifetime_spots.iter().rev().next()\n-            {\n-                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n-                // using `'a`, but also introduce the concept of HRLTs by suggesting\n-                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n-                let mut introduce_suggestion = vec![];\n+        for (span, count) in &spans_with_counts {\n+            err.span_label(\n+                *span,\n+                format!(\n+                    \"expected {} lifetime parameter{}\",\n+                    if *count == 1 { \"named\".to_string() } else { count.to_string() },\n+                    pluralize!(*count),\n+                ),\n+            );\n+        }\n \n-                let a_to_z_repeat_n = |n| {\n-                    (b'a'..=b'z').map(move |c| {\n-                        let mut s = '\\''.to_string();\n-                        s.extend(std::iter::repeat(char::from(c)).take(n));\n-                        s\n-                    })\n-                };\n+        let suggest_existing =\n+            |err: &mut DiagnosticBuilder<'_>,\n+             name: &str,\n+             formatters: Vec<Option<Box<dyn Fn(&str) -> String>>>| {\n+                if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                    self.missing_named_lifetime_spots.iter().rev().next()\n+                {\n+                    // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                    // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                    // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                    let mut introduce_suggestion = vec![];\n+\n+                    let a_to_z_repeat_n = |n| {\n+                        (b'a'..=b'z').map(move |c| {\n+                            let mut s = '\\''.to_string();\n+                            s.extend(std::iter::repeat(char::from(c)).take(n));\n+                            s\n+                        })\n+                    };\n \n-                // If all single char lifetime names are present, we wrap around and double the chars.\n-                let lt_name = (1..)\n-                    .flat_map(a_to_z_repeat_n)\n-                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n-                    .unwrap();\n-                let msg = format!(\n-                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                    span_type.descr(),\n-                    lt_name,\n-                );\n-                err.note(\n-                    \"for more information on higher-ranked polymorphism, visit \\\n+                    // If all single char lifetime names are present, we wrap around and double the chars.\n+                    let lt_name = (1..)\n+                        .flat_map(a_to_z_repeat_n)\n+                        .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                        .unwrap();\n+                    let msg = format!(\n+                        \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                        span_type.descr(),\n+                        lt_name,\n+                    );\n+                    err.note(\n+                        \"for more information on higher-ranked polymorphism, visit \\\n                     https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                );\n-                let for_sugg = span_type.suggestion(&lt_name);\n-                for param in params {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n-                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n-                        } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n+                    );\n+                    let for_sugg = span_type.suggestion(&lt_name);\n+                    for param in params {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n+                        {\n+                            if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                            } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n+                            }\n+                        }\n+                    }\n+                    introduce_suggestion.push((*for_span, for_sugg));\n+                    for ((span, _), formatter) in spans_with_counts.iter().zip(formatters.iter()) {\n+                        if let Some(formatter) = formatter {\n+                            introduce_suggestion.push((*span, formatter(&lt_name)));\n                         }\n                     }\n+                    err.multipart_suggestion_with_style(\n+                        &msg,\n+                        introduce_suggestion,\n+                        Applicability::MaybeIncorrect,\n+                        SuggestionStyle::ShowAlways,\n+                    );\n                 }\n-                introduce_suggestion.push((*for_span, for_sugg));\n-                introduce_suggestion.push((span, formatter(&lt_name)));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n-            }\n \n-            err.span_suggestion_verbose(\n-                span,\n-                &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                formatter(name),\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-        let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                let spans_suggs: Vec<_> = formatters\n+                    .into_iter()\n+                    .zip(spans_with_counts.iter())\n+                    .filter_map(|(fmt, (span, _))| {\n+                        if let Some(formatter) = fmt { Some((formatter, span)) } else { None }\n+                    })\n+                    .map(|(formatter, span)| (*span, formatter(name)))\n+                    .collect();\n+                err.multipart_suggestion_with_style(\n+                    &format!(\n+                        \"consider using the `{}` lifetime\",\n+                        lifetime_names.iter().next().unwrap()\n+                    ),\n+                    spans_suggs,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways,\n+                );\n+            };\n+        let suggest_new = |err: &mut DiagnosticBuilder<'_>, suggs: Vec<Option<String>>| {\n             for missing in self.missing_named_lifetime_spots.iter().rev() {\n                 let mut introduce_suggestion = vec![];\n                 let msg;\n@@ -1940,38 +1966,44 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         (*span, span_type.suggestion(\"'a\"))\n                     }\n                     MissingLifetimeSpot::Static => {\n-                        let (span, sugg) = match snippet.as_deref() {\n-                            Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n-                            Some(\"'_\") => (span, \"'static\".to_owned()),\n-                            Some(snippet) if !snippet.ends_with('>') => {\n-                                if snippet == \"\" {\n-                                    (\n-                                        span,\n-                                        std::iter::repeat(\"'static\")\n-                                            .take(count)\n-                                            .collect::<Vec<_>>()\n-                                            .join(\", \"),\n-                                    )\n-                                } else {\n-                                    (\n-                                        span.shrink_to_hi(),\n-                                        format!(\n-                                            \"<{}>\",\n+                        let mut spans_suggs = Vec::new();\n+                        for ((span, count), snippet) in\n+                            spans_with_counts.iter().copied().zip(snippets.iter())\n+                        {\n+                            let (span, sugg) = match snippet.as_deref() {\n+                                Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n+                                Some(\"'_\") => (span, \"'static\".to_owned()),\n+                                Some(snippet) if !snippet.ends_with('>') => {\n+                                    if snippet == \"\" {\n+                                        (\n+                                            span,\n                                             std::iter::repeat(\"'static\")\n                                                 .take(count)\n                                                 .collect::<Vec<_>>()\n-                                                .join(\", \")\n-                                        ),\n-                                    )\n+                                                .join(\", \"),\n+                                        )\n+                                    } else {\n+                                        (\n+                                            span.shrink_to_hi(),\n+                                            format!(\n+                                                \"<{}>\",\n+                                                std::iter::repeat(\"'static\")\n+                                                    .take(count)\n+                                                    .collect::<Vec<_>>()\n+                                                    .join(\", \")\n+                                            ),\n+                                        )\n+                                    }\n                                 }\n-                            }\n-                            _ => continue,\n-                        };\n-                        err.span_suggestion_verbose(\n-                            span,\n+                                _ => continue,\n+                            };\n+                            spans_suggs.push((span, sugg.to_string()));\n+                        }\n+                        err.multipart_suggestion_with_style(\n                             \"consider using the `'static` lifetime\",\n-                            sugg.to_string(),\n+                            spans_suggs,\n                             Applicability::MaybeIncorrect,\n+                            SuggestionStyle::ShowAlways,\n                         );\n                         continue;\n                     }\n@@ -1986,77 +2018,93 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         }\n                     }\n                 }\n-                introduce_suggestion.push((span, sugg.to_string()));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+                for ((span, _), sugg) in spans_with_counts.iter().copied().zip(suggs.iter()) {\n+                    if let Some(sugg) = sugg {\n+                        introduce_suggestion.push((span, sugg.to_string()));\n+                    }\n+                }\n+                err.multipart_suggestion_with_style(\n+                    &msg,\n+                    introduce_suggestion,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways,\n+                );\n                 if should_break {\n                     break;\n                 }\n             }\n         };\n \n         let lifetime_names: Vec<_> = lifetime_names.iter().collect();\n-        match (&lifetime_names[..], snippet.as_deref()) {\n-            ([name], Some(\"&\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n-            }\n-            ([name], Some(\"'_\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n-            }\n-            ([name], Some(\"\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n-            }\n-            ([name], Some(snippet)) if !snippet.ends_with('>') => {\n-                let f = |name: &str| {\n-                    format!(\n-                        \"{}<{}>\",\n-                        snippet,\n-                        std::iter::repeat(name.to_string())\n-                            .take(count)\n-                            .collect::<Vec<_>>()\n-                            .join(\", \")\n-                    )\n-                };\n-                suggest_existing(err, &name.as_str()[..], &f);\n-            }\n-            ([], Some(\"&\")) if count == 1 => {\n-                suggest_new(err, \"&'a \");\n-            }\n-            ([], Some(\"'_\")) if count == 1 => {\n-                suggest_new(err, \"'a\");\n+        match &lifetime_names[..] {\n+            [name] => {\n+                let mut suggs: Vec<Option<Box<dyn Fn(&str) -> String>>> = Vec::new();\n+                for (snippet, (_, count)) in snippets.iter().zip(spans_with_counts.iter().copied())\n+                {\n+                    suggs.push(match snippet.as_deref() {\n+                        Some(\"&\") => Some(Box::new(|name| format!(\"&{} \", name))),\n+                        Some(\"'_\") => Some(Box::new(|n| n.to_string())),\n+                        Some(\"\") => Some(Box::new(move |n| format!(\"{}, \", n).repeat(count))),\n+                        Some(snippet) if !snippet.ends_with('>') => Some(Box::new(move |name| {\n+                            format!(\n+                                \"{}<{}>\",\n+                                snippet,\n+                                std::iter::repeat(name.to_string())\n+                                    .take(count)\n+                                    .collect::<Vec<_>>()\n+                                    .join(\", \")\n+                            )\n+                        })),\n+                        _ => None,\n+                    });\n+                }\n+                suggest_existing(err, &name.as_str()[..], suggs);\n             }\n-            ([], Some(snippet)) if !snippet.ends_with('>') => {\n-                if snippet == \"\" {\n-                    // This happens when we have `type Bar<'a> = Foo<T>` where we point at the space\n-                    // before `T`. We will suggest `type Bar<'a> = Foo<'a, T>`.\n-                    suggest_new(\n-                        err,\n-                        &std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n-                    );\n-                } else {\n-                    suggest_new(\n-                        err,\n-                        &format!(\n+            [] => {\n+                let mut suggs = Vec::new();\n+                for (snippet, (_, count)) in\n+                    snippets.iter().cloned().zip(spans_with_counts.iter().copied())\n+                {\n+                    suggs.push(match snippet.as_deref() {\n+                        Some(\"&\") => Some(\"&'a \".to_string()),\n+                        Some(\"'_\") => Some(\"'a\".to_string()),\n+                        Some(\"\") => {\n+                            Some(std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"))\n+                        }\n+                        Some(snippet) => Some(format!(\n                             \"{}<{}>\",\n                             snippet,\n-                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n-                        ),\n-                    );\n+                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \"),\n+                        )),\n+                        None => None,\n+                    });\n                 }\n+                suggest_new(err, suggs);\n             }\n-            (lts, ..) if lts.len() > 1 => {\n+            lts if lts.len() > 1 => {\n                 err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n-                if Some(\"\") == snippet.as_deref() {\n+\n+                let mut spans_suggs: Vec<_> = Vec::new();\n+                for ((span, _), snippet) in spans_with_counts.iter().copied().zip(snippets.iter()) {\n+                    match snippet.as_deref() {\n+                        Some(\"\") => spans_suggs.push((span, \"'lifetime, \".to_string())),\n+                        Some(\"&\") => spans_suggs.push((span, \"&'lifetime \".to_string())),\n+                        _ => {}\n+                    }\n+                }\n+\n+                if spans_suggs.len() > 0 {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders.\n-                    err.span_suggestion_verbose(\n-                        span,\n+                    err.multipart_suggestion_with_style(\n                         \"consider using one of the available lifetimes here\",\n-                        \"'lifetime, \".repeat(count),\n+                        spans_suggs,\n                         Applicability::HasPlaceholders,\n+                        SuggestionStyle::ShowAlways,\n                     );\n                 }\n             }\n-            _ => {}\n+            _ => unreachable!(),\n         }\n     }\n "}, {"sha": "e8d21af435887ad907d5f6ebac045b0fdda371c8", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -2956,7 +2956,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             return;\n         }\n \n-        let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n@@ -3035,18 +3034,27 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = self.report_missing_lifetime_specifiers(span, lifetime_refs.len());\n+        let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n+        spans.sort();\n+        let mut spans_dedup = spans.clone();\n+        spans_dedup.dedup();\n+        let spans_with_counts: Vec<_> = spans_dedup\n+            .into_iter()\n+            .map(|sp| (sp, spans.iter().filter(|nsp| *nsp == &sp).count()))\n+            .collect();\n+\n+        let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n \n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n                 lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n+\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n-            span,\n-            lifetime_refs.len(),\n+            spans_with_counts,\n             &lifetime_names,\n             lifetime_spans,\n             error.unwrap_or(&[]),"}, {"sha": "aa246aaa3d45efb3006632356d86dca41797ce79", "filename": "src/test/ui/suggestions/issue-84592.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.rs?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -0,0 +1,17 @@\n+/* Checks whether issue #84592 has been resolved. The issue was\n+ * that in this example, there are two expected/missing lifetime\n+ * parameters with *different spans*, leading to incorrect\n+ * suggestions from rustc.\n+ */\n+\n+struct TwoLifetimes<'x, 'y> {\n+    x: &'x (),\n+    y: &'y (),\n+}\n+\n+fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n+//~^ ERROR missing lifetime specifiers [E0106]\n+    TwoLifetimes { x: &(), y: &() }\n+}\n+\n+fn main() {}"}, {"sha": "02f9241a6d2dae3fdbb5e13aa35870c777f2702f", "filename": "src/test/ui/suggestions/issue-84592.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.stderr?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -0,0 +1,17 @@\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/issue-84592.rs:12:57\n+   |\n+LL | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n+   |                            ---     ---                  ^^  ^^ expected named lifetime parameter\n+   |                                                         |\n+   |                                                         expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'a, 'a> {\n+   |                        ^^^^    ^^^^^^     ^^^^^^                  ^^  ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "a7a44b511db8de6b3b12dc917bf902a4f564caa8", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -44,6 +44,10 @@ note: these named lifetimes are available to use\n    |\n LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n    |          ^^              ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &'lifetime X);\n+   |                                        ^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lt-for-hrtb.rs:5:41"}, {"sha": "ca336bbb056d5105847adb9c12be2fc39b0ac935", "filename": "src/test/ui/suggestions/return-elided-lifetime.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -0,0 +1,37 @@\n+/* Checks all four scenarios possible in report_elision_failure() of\n+ * rustc_resolve::late::lifetimes::LifetimeContext related to returning\n+ * borrowed values, in various configurations.\n+ */\n+\n+fn f1() -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f1_() -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f2(a: i32, b: i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+struct S<'a, 'b> { a: &'a i32, b: &'b i32 }\n+fn f3(s: &S) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn main() {}"}, {"sha": "888cd5e58abeca671718a7572b56fe0a53db8f53", "filename": "src/test/ui/suggestions/return-elided-lifetime.stderr", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0740015d59c8c35c803f5f4a0b2aab112e0531aa/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr?ref=0740015d59c8c35c803f5f4a0b2aab112e0531aa", "patch": "@@ -0,0 +1,198 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:6:12\n+   |\n+LL | fn f1() -> &i32 { loop {} }\n+   |            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1() -> &'static i32 { loop {} }\n+   |            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:8:14\n+   |\n+LL | fn f1_() -> (&i32, &i32) { loop {} }\n+   |              ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1_() -> (&'static i32, &i32) { loop {} }\n+   |              ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:8:20\n+   |\n+LL | fn f1_() -> (&i32, &i32) { loop {} }\n+   |                    ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1_() -> (&i32, &'static i32) { loop {} }\n+   |                    ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:12:26\n+   |\n+LL | fn f2(a: i32, b: i32) -> &i32 { loop {} }\n+   |                          ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2(a: i32, b: i32) -> &'static i32 { loop {} }\n+   |                          ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:14:28\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+   |                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&'static i32, &i32) { loop {} }\n+   |                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:14:34\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+   |                                  ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &'static i32) { loop {} }\n+   |                                  ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:19:17\n+   |\n+LL | fn f3(s: &S) -> &i32 { loop {} }\n+   |          --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `s`'s 3 lifetimes it is borrowed from\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3<'a>(s: &'a S) -> &'a i32 { loop {} }\n+   |      ^^^^    ^^^^^     ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:21:26\n+   |\n+LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+   |           --     --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&'a i32, &i32) { loop {} }\n+   |       ^^^^    ^^^^^     ^^^^^      ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:21:32\n+   |\n+LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+   |           --     --            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&i32, &'a i32) { loop {} }\n+   |       ^^^^    ^^^^^     ^^^^^            ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:25:42\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+   |                  -------     -------     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:25:7\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+   |       ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &'lifetime i32 { loop {} }\n+   |                                          ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:27:44\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |                   -------     -------      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:27:8\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&'lifetime i32, &i32) { loop {} }\n+   |                                            ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:27:50\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |                   -------     -------            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:27:8\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &'lifetime i32) { loop {} }\n+   |                                                  ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:31:35\n+   |\n+LL | fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n+   |              -------     ----     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5<'a>(a: &'a i32, b: &i32) -> &'a i32 { loop {} }\n+   |                                   ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:33:37\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+   |               -------     ----      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&'a i32, &i32) { loop {} }\n+   |                                     ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:33:43\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+   |               -------     ----            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &'a i32) { loop {} }\n+   |                                           ^^^\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}]}