{"sha": "5dfc84cfa72b405c194228b53c4de3f6474204ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZmM4NGNmYTcyYjQwNWMxOTQyMjhiNTNjNGRlM2Y2NDc0MjA0ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-14T12:28:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-14T12:28:31Z"}, "message": "Auto merge of #44480 - Zoxc:gen-liveness, r=arielb1\n\nAnalyse storage liveness and preserve it during generator transformation\n\nThis uses a dataflow analysis on `StorageLive` and `StorageDead` statements to infer where the storage of locals are live. The result of this analysis is intersected with the regular liveness analysis such that a local is can only be live when its storage is. This fixes https://github.com/rust-lang/rust/issues/44184. If the storage of a local is live across a suspension point, we'll insert a `StorageLive` statement for it after the suspension point so storage liveness is preserved. This fixes https://github.com/rust-lang/rust/issues/44179.\n\nr? @arielb1", "tree": {"sha": "c29605d0077883e3e5a81fed475f645cd043c93b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c29605d0077883e3e5a81fed475f645cd043c93b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dfc84cfa72b405c194228b53c4de3f6474204ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dfc84cfa72b405c194228b53c4de3f6474204ec", "html_url": "https://github.com/rust-lang/rust/commit/5dfc84cfa72b405c194228b53c4de3f6474204ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dfc84cfa72b405c194228b53c4de3f6474204ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b6bc588ca7197bc5d9f212e9e91a2c3811d025c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b6bc588ca7197bc5d9f212e9e91a2c3811d025c", "html_url": "https://github.com/rust-lang/rust/commit/2b6bc588ca7197bc5d9f212e9e91a2c3811d025c"}, {"sha": "0e8e6592f6650f975fc39bfcdef53ce474c1e7a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8e6592f6650f975fc39bfcdef53ce474c1e7a9", "html_url": "https://github.com/rust-lang/rust/commit/0e8e6592f6650f975fc39bfcdef53ce474c1e7a9"}], "stats": {"total": 528, "additions": 354, "deletions": 174}, "files": [{"sha": "7665bfd5b1117316c0a758338ad103adca34e2b5", "filename": "src/librustc_data_structures/bitslice.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_data_structures%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_data_structures%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitslice.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -132,6 +132,11 @@ pub trait BitwiseOperator {\n     fn join(&self, pred1: usize, pred2: usize) -> usize;\n }\n \n+pub struct Intersect;\n+impl BitwiseOperator for Intersect {\n+    #[inline]\n+    fn join(&self, a: usize, b: usize) -> usize { a & b }\n+}\n pub struct Union;\n impl BitwiseOperator for Union {\n     #[inline]"}, {"sha": "c790463e47adb4f2ce3e897c2229e22dc9f7d88f", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -15,7 +15,7 @@ use std::mem;\n use std::ops::{Deref, DerefMut, Range};\n use std::slice;\n use bitslice::{BitSlice, Word};\n-use bitslice::{bitwise, Union, Subtract};\n+use bitslice::{bitwise, Union, Subtract, Intersect};\n use indexed_vec::Idx;\n \n /// Represents a set (or packed family of sets), of some element type\n@@ -164,6 +164,10 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n \n+    pub fn intersect(&mut self, other: &IdxSet<T>) -> bool {\n+        bitwise(self.words_mut(), other.words(), &Intersect)\n+    }\n+\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n             cur: None,"}, {"sha": "19a595622b92edf62b9a4394407a4e5dffa4a1d9", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -27,6 +27,10 @@ use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n use super::on_lookup_result_bits;\n \n+mod storage_liveness;\n+\n+pub use self::storage_liveness::*;\n+\n #[allow(dead_code)]\n pub(super) mod borrows;\n "}, {"sha": "98615c6b2682627bbb7d0574340b821da83ed480", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use super::*;\n+\n+use rustc::mir::*;\n+use dataflow::BitDenotation;\n+\n+#[derive(Copy, Clone)]\n+pub struct MaybeStorageLive<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> MaybeStorageLive<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>)\n+               -> Self {\n+        MaybeStorageLive { mir: mir }\n+    }\n+\n+    pub fn mir(&self) -> &Mir<'tcx> {\n+        self.mir\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n+    type Idx = Local;\n+    fn name() -> &'static str { \"maybe_storage_live\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.mir.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, _sets: &mut BlockSets<Local>) {\n+        // Nothing is live on function entry\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<Local>,\n+                        loc: Location) {\n+        let stmt = &self.mir[loc.block].statements[loc.statement_index];\n+\n+        match stmt.kind {\n+            StatementKind::StorageLive(l) => sets.gen(&l),\n+            StatementKind::StorageDead(l) => sets.kill(&l),\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         _sets: &mut BlockSets<Local>,\n+                         _loc: Location) {\n+        // Terminators have no effect\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             _in_out: &mut IdxSet<Local>,\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             _dest_lval: &mir::Lvalue) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeStorageLive<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeStorageLive<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = dead\n+    }\n+}"}, {"sha": "9fa5691d647b70015204c5c98d93cc11ee61c4c9", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -24,6 +24,7 @@ use std::mem;\n use std::path::PathBuf;\n use std::usize;\n \n+pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals};\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n@@ -351,6 +352,29 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n                           flow_state: &mut Self::FlowState);\n }\n \n+pub fn state_for_location<T: BitDenotation>(loc: Location,\n+                                            analysis: &T,\n+                                            result: &DataflowResults<T>)\n+    -> IdxSetBuf<T::Idx> {\n+    let mut entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n+\n+    {\n+        let mut sets = BlockSets {\n+            on_entry: &mut entry.clone(),\n+            kill_set: &mut entry.clone(),\n+            gen_set: &mut entry,\n+        };\n+\n+        for stmt in 0..loc.statement_index {\n+            let mut stmt_loc = loc;\n+            stmt_loc.statement_index = stmt;\n+            analysis.statement_effect(&mut sets, stmt_loc);\n+        }\n+    }\n+\n+    entry\n+}\n+\n pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation\n {\n     flow_state: DataflowState<O>,"}, {"sha": "78fe7b26ebfe0063434fe785a4dd08207b2329e6", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 204, "deletions": 173, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -38,7 +38,8 @@\n //! This pass computes the meaning of the state field and the MIR locals which are live\n //! across a suspension point. There are however two hardcoded generator states:\n //!     0 - Generator have not been resumed yet\n-//!     1 - Generator has been poisoned\n+//!     1 - Generator has returned / is completed\n+//!     2 - Generator has been poisoned\n //!\n //! It also rewrites `return x` and `yield y` as setting a new generator state and returning\n //! GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.\n@@ -49,35 +50,35 @@\n //! the action to take.\n //!\n //! One of them is the implementation of Generator::resume.\n-//! For generators which have already returned it panics.\n //! For generators with state 0 (unresumed) it starts the execution of the generator.\n-//! For generators with state 1 (poisoned) it panics.\n+//! For generators with state 1 (returned) and state 2 (poisoned) it panics.\n //! Otherwise it continues the execution from the last suspension point.\n //!\n //! The other function is the drop glue for the generator.\n-//! For generators which have already returned it does nothing.\n //! For generators with state 0 (unresumed) it drops the upvars of the generator.\n-//! For generators with state 1 (poisoned) it does nothing.\n+//! For generators with state 1 (returned) and state 2 (poisoned) it does nothing.\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::mir::visit::{LvalueContext, MutVisitor};\n+use rustc::mir::visit::{LvalueContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n use rustc::ty::subst::{Kind, Substs};\n use util::dump_mir;\n use util::liveness;\n use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use std::collections::HashMap;\n use std::borrow::Cow;\n use std::iter::once;\n use std::mem;\n use transform::simplify;\n use transform::no_landing_pads::no_landing_pads;\n+use dataflow::{self, MaybeStorageLive, state_for_location};\n \n pub struct StateTransform;\n \n@@ -126,6 +127,13 @@ fn self_arg() -> Local {\n     Local::new(1)\n }\n \n+struct SuspensionPoint {\n+    state: u32,\n+    resume: BasicBlock,\n+    drop: Option<BasicBlock>,\n+    storage_liveness: liveness::LocalSet,\n+}\n+\n struct TransformVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n@@ -137,18 +145,14 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     // Mapping from Local to (type of local, generator struct index)\n     remap: HashMap<Local, (Ty<'tcx>, usize)>,\n \n-    // The number of generator states. 0 is unresumed, 1 is poisoned. So this is initialized to 2\n-    bb_target_count: u32,\n+    // A map from a suspension point in a block to the locals which have live storage at that point\n+    storage_liveness: HashMap<BasicBlock, liveness::LocalSet>,\n \n-    // Map from a (which block to resume execution at, which block to use to drop the generator)\n-    // to a generator state\n-    bb_targets: HashMap<(BasicBlock, Option<BasicBlock>), u32>,\n+    // A list of suspension points, generated during the transform\n+    suspension_points: Vec<SuspensionPoint>,\n \n     // The original RETURN_POINTER local\n     new_ret_local: Local,\n-\n-    // The block to resume execution when for Return\n-    return_block: BasicBlock,\n }\n \n impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n@@ -225,33 +229,39 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n \n         let ret_val = match data.terminator().kind {\n             TerminatorKind::Return => Some((1,\n-                self.return_block,\n+                None,\n                 Operand::Consume(Lvalue::Local(self.new_ret_local)),\n                 None)),\n             TerminatorKind::Yield { ref value, resume, drop } => Some((0,\n-                resume,\n+                Some(resume),\n                 value.clone(),\n                 drop)),\n             _ => None\n         };\n \n         if let Some((state_idx, resume, v, drop)) = ret_val {\n-            let bb_idx = {\n-                let bb_targets = &mut self.bb_targets;\n-                let bb_target = &mut self.bb_target_count;\n-                *bb_targets.entry((resume, drop)).or_insert_with(|| {\n-                    let target = *bb_target;\n-                    *bb_target = target.checked_add(1).unwrap();\n-                    target\n-                })\n-            };\n             let source_info = data.terminator().source_info;\n-            data.statements.push(self.set_state(bb_idx, source_info));\n+            // We must assign the value first in case it gets declared dead below\n             data.statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(Lvalue::Local(RETURN_POINTER),\n                     self.make_state(state_idx, v)),\n             });\n+            let state = if let Some(resume) = resume { // Yield\n+                let state = 3 + self.suspension_points.len() as u32;\n+\n+                self.suspension_points.push(SuspensionPoint {\n+                    state,\n+                    resume,\n+                    drop,\n+                    storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n+                });\n+\n+                state\n+            } else { // Return\n+                 1 // state for returned\n+            };\n+            data.statements.push(self.set_state(state, source_info));\n             data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n         }\n \n@@ -286,16 +296,11 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n \n fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n                             mir: &mut Mir<'tcx>) -> Local {\n-    let source_info = SourceInfo {\n-        span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n-\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n         name: None,\n-        source_info,\n+        source_info: source_info(mir),\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -311,33 +316,84 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     new_ret_local\n }\n \n+struct StorageIgnored(liveness::LocalSet);\n+\n+impl<'tcx> Visitor<'tcx> for StorageIgnored {\n+    fn visit_statement(&mut self,\n+                       _block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       _location: Location) {\n+        match statement.kind {\n+            StatementKind::StorageLive(l) |\n+            StatementKind::StorageDead(l) => { self.0.remove(&l); }\n+            _ => (),\n+        }\n+    }\n+}\n+\n fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                mir: &Mir<'tcx>,\n-                                               source: MirSource) -> liveness::LocalSet {\n+                                               source: MirSource) ->\n+                                               (liveness::LocalSet,\n+                                                HashMap<BasicBlock, liveness::LocalSet>) {\n+    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let node_id = source.item_id();\n+    let analysis = MaybeStorageLive::new(mir);\n+    let storage_live =\n+        dataflow::do_dataflow(tcx, mir, node_id, &[], &dead_unwinds, analysis,\n+                              |bd, p| &bd.mir().local_decls[p]);\n+\n+    let mut ignored = StorageIgnored(IdxSetBuf::new_filled(mir.local_decls.len()));\n+    ignored.visit_mir(mir);\n+\n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let result = liveness::liveness_of_locals(mir);\n-    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &result);\n+    let liveness = liveness::liveness_of_locals(mir);\n+    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &liveness);\n+\n+    let mut storage_liveness_map = HashMap::new();\n \n     for (block, data) in mir.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            set.union(&result.outs[block]);\n+            let loc = Location {\n+                block: block,\n+                statement_index: data.statements.len(),\n+            };\n+\n+            let storage_liveness = state_for_location(loc, &analysis, &storage_live);\n+\n+            storage_liveness_map.insert(block, storage_liveness.clone());\n+\n+            let mut live_locals = storage_liveness;\n+\n+            // Mark locals without storage statements as always having live storage\n+            live_locals.union(&ignored.0);\n+\n+            // Locals live are live at this point only if they are used across suspension points\n+            // and their storage is live\n+            live_locals.intersect(&liveness.outs[block]);\n+\n+            // Add the locals life at this suspension point to the set of locals which live across\n+            // any suspension points\n+            set.union(&live_locals);\n         }\n     }\n \n     // The generator argument is ignored\n     set.remove(&self_arg());\n \n-    set\n+    (set, storage_liveness_map)\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource,\n                             interior: GeneratorInterior<'tcx>,\n                             mir: &mut Mir<'tcx>)\n-    -> (HashMap<Local, (Ty<'tcx>, usize)>, GeneratorLayout<'tcx>)\n+    -> (HashMap<Local, (Ty<'tcx>, usize)>,\n+        GeneratorLayout<'tcx>,\n+        HashMap<BasicBlock, liveness::LocalSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let live_locals = locals_live_across_suspend_points(tcx, mir, source);\n+    let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx, mir, source);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -381,12 +437,31 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fields: vars\n     };\n \n-    (remap, layout)\n+    (remap, layout, storage_liveness)\n }\n \n-fn insert_entry_point<'tcx>(mir: &mut Mir<'tcx>,\n-                            block: BasicBlockData<'tcx>) {\n-    mir.basic_blocks_mut().raw.insert(0, block);\n+fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           mir: &mut Mir<'tcx>,\n+                           cases: Vec<(u32, BasicBlock)>,\n+                           transform: &TransformVisitor<'a, 'tcx>) {\n+    let return_block = insert_return_block(mir);\n+\n+    let switch = TerminatorKind::SwitchInt {\n+        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n+        switch_ty: tcx.types.u32,\n+        values: Cow::from(cases.iter().map(|&(i, _)| ConstInt::U32(i)).collect::<Vec<_>>()),\n+        targets: cases.iter().map(|&(_, d)| d).chain(once(return_block)).collect(),\n+    };\n+\n+    let source_info = source_info(mir);\n+    mir.basic_blocks_mut().raw.insert(0, BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: switch,\n+        }),\n+        is_cleanup: false,\n+    });\n \n     let blocks = mir.basic_blocks_mut().iter_mut();\n \n@@ -458,46 +533,16 @@ fn create_generator_drop_shim<'a, 'tcx>(\n                 drop_clean: BasicBlock) -> Mir<'tcx> {\n     let mut mir = mir.clone();\n \n-    let source_info = SourceInfo {\n-        span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n+    let source_info = source_info(&mir);\n \n-    let return_block = BasicBlock::new(mir.basic_blocks().len());\n-    mir.basic_blocks_mut().push(BasicBlockData {\n-        statements: Vec::new(),\n-        terminator: Some(Terminator {\n-            source_info,\n-            kind: TerminatorKind::Return,\n-        }),\n-        is_cleanup: false,\n-    });\n-\n-    let mut cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(_, u), &s)| {\n-        u.map(|d| (s, d))\n-    }).collect();\n+    let mut cases = create_cases(&mut mir, transform, |point| point.drop);\n \n     cases.insert(0, (0, drop_clean));\n \n-    // The poisoned state 1 falls through to the default case which is just to return\n+    // The returned state (1) and the poisoned state (2) falls through to\n+    // the default case which is just to return\n \n-    let switch = TerminatorKind::SwitchInt {\n-        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n-        switch_ty: tcx.types.u32,\n-        values: Cow::from(cases.iter().map(|&(i, _)| {\n-                ConstInt::U32(i)\n-            }).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(once(return_block)).collect(),\n-    };\n-\n-    insert_entry_point(&mut mir, BasicBlockData {\n-        statements: Vec::new(),\n-        terminator: Some(Terminator {\n-            source_info,\n-            kind: switch,\n-        }),\n-        is_cleanup: false,\n-    });\n+    insert_switch(tcx, &mut mir, cases, &transform);\n \n     for block in mir.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n@@ -507,11 +552,6 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     }\n \n     // Replace the return variable\n-    let source_info = SourceInfo {\n-        span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n-\n     mir.return_ty = tcx.mk_nil();\n     mir.local_decls[RETURN_POINTER] = LocalDecl {\n         mutability: Mutability::Mut,\n@@ -548,8 +588,23 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     mir\n }\n \n-fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        mir: &mut Mir<'tcx>) {\n+fn insert_return_block<'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n+    let return_block = BasicBlock::new(mir.basic_blocks().len());\n+    let source_info = source_info(mir);\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false,\n+    });\n+    return_block\n+}\n+\n+fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                mir: &mut Mir<'tcx>,\n+                                message: AssertMessage<'tcx>) -> BasicBlock {\n     let assert_block = BasicBlock::new(mir.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n@@ -563,16 +618,12 @@ fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             },\n         }),\n         expected: true,\n-        msg: AssertMessage::GeneratorResumedAfterReturn,\n+        msg: message,\n         target: assert_block,\n         cleanup: None,\n     };\n \n-    let source_info = SourceInfo {\n-        span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n-\n+    let source_info = source_info(mir);\n     mir.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n@@ -581,11 +632,13 @@ fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }),\n         is_cleanup: false,\n     });\n+\n+    assert_block\n }\n \n fn create_generator_resume_function<'a, 'tcx>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        mut transform: TransformVisitor<'a, 'tcx>,\n+        transform: TransformVisitor<'a, 'tcx>,\n         def_id: DefId,\n         source: MirSource,\n         mir: &mut Mir<'tcx>) {\n@@ -597,61 +650,16 @@ fn create_generator_resume_function<'a, 'tcx>(\n         }\n     }\n \n-    let source_info = SourceInfo {\n-        span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n-\n-    let poisoned_block = BasicBlock::new(mir.basic_blocks().len());\n-\n-    let term = TerminatorKind::Assert {\n-        cond: Operand::Constant(box Constant {\n-            span: mir.span,\n-            ty: tcx.types.bool,\n-            literal: Literal::Value {\n-                value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(false),\n-                    ty: tcx.types.bool\n-                }),\n-            },\n-        }),\n-        expected: true,\n-        msg: AssertMessage::GeneratorResumedAfterPanic,\n-        target: transform.return_block,\n-        cleanup: None,\n-    };\n-\n-    mir.basic_blocks_mut().push(BasicBlockData {\n-        statements: Vec::new(),\n-        terminator: Some(Terminator {\n-            source_info,\n-            kind: term,\n-        }),\n-        is_cleanup: false,\n-    });\n-\n-    transform.bb_targets.insert((poisoned_block, None), 1);\n+    let mut cases = create_cases(mir, &transform, |point| Some(point.resume));\n \n-    let switch = TerminatorKind::SwitchInt {\n-        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n-        switch_ty: tcx.types.u32,\n-        values: Cow::from(transform.bb_targets.values().map(|&i| {\n-                ConstInt::U32(i)\n-            }).collect::<Vec<_>>()),\n-        targets: transform.bb_targets.keys()\n-            .map(|&(k, _)| k)\n-            .chain(once(transform.return_block))\n-            .collect(),\n-    };\n+    // Jump to the entry point on the 0 state\n+    cases.insert(0, (0, BasicBlock::new(0)));\n+    // Panic when resumed on the returned (1) state\n+    cases.insert(1, (1, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterReturn)));\n+    // Panic when resumed on the poisoned (2) state\n+    cases.insert(2, (2, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterPanic)));\n \n-    insert_entry_point(mir, BasicBlockData {\n-        statements: Vec::new(),\n-        terminator: Some(Terminator {\n-            source_info,\n-            kind: switch,\n-        }),\n-        is_cleanup: false,\n-    });\n+    insert_switch(tcx, mir, cases, &transform);\n \n     make_generator_state_argument_indirect(tcx, def_id, mir);\n \n@@ -664,21 +672,15 @@ fn create_generator_resume_function<'a, 'tcx>(\n     dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n }\n \n-fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n-    let source_info = SourceInfo {\n+fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n+    SourceInfo {\n         span: mir.span,\n         scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n+    }\n+}\n \n-    let return_block = BasicBlock::new(mir.basic_blocks().len());\n-    mir.basic_blocks_mut().push(BasicBlockData {\n-        statements: Vec::new(),\n-        terminator: Some(Terminator {\n-            source_info,\n-            kind: TerminatorKind::Return,\n-        }),\n-        is_cleanup: false,\n-    });\n+fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n+    let return_block = insert_return_block(mir);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     let drop_clean = BasicBlock::new(mir.basic_blocks().len());\n@@ -687,6 +689,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n         target: return_block,\n         unwind: None,\n     };\n+    let source_info = source_info(mir);\n     mir.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n@@ -699,6 +702,46 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n+fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n+                          transform: &TransformVisitor<'a, 'tcx>,\n+                          target: F) -> Vec<(u32, BasicBlock)>\n+    where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n+    let source_info = source_info(mir);\n+\n+    transform.suspension_points.iter().filter_map(|point| {\n+        // Find the target for this suspension point, if applicable\n+        target(point).map(|target| {\n+            let block = BasicBlock::new(mir.basic_blocks().len());\n+            let mut statements = Vec::new();\n+\n+            // Create StorageLive instructions for locals with live storage\n+            for i in 0..(mir.local_decls.len()) {\n+                let l = Local::new(i);\n+                if point.storage_liveness.contains(&l) && !transform.remap.contains_key(&l) {\n+                    statements.push(Statement {\n+                        source_info,\n+                        kind: StatementKind::StorageLive(l),\n+                    });\n+                }\n+            }\n+\n+            // Then jump to the real target\n+            mir.basic_blocks_mut().push(BasicBlockData {\n+                statements,\n+                terminator: Some(Terminator {\n+                    source_info,\n+                    kind: TerminatorKind::Goto {\n+                        target,\n+                    },\n+                }),\n+                is_cleanup: false,\n+            });\n+\n+            (point.state, block)\n+        })\n+    }).collect()\n+}\n+\n impl MirPass for StateTransform {\n     fn run_pass<'a, 'tcx>(&self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -736,16 +779,11 @@ impl MirPass for StateTransform {\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n-        let (remap, layout) = compute_layout(tcx, source, interior, mir);\n+        // `storage_liveness` tells us which locals have live storage at suspension points\n+        let (remap, layout, storage_liveness) = compute_layout(tcx, source, interior, mir);\n \n         let state_field = mir.upvar_decls.len();\n \n-        let mut bb_targets = HashMap::new();\n-\n-        // If we jump to the entry point, we should go to the initial 0 generator state.\n-        // FIXME: Could this result in the need for destruction for state 0?\n-        bb_targets.insert((BasicBlock::new(0), None), 0);\n-\n         // Run the transformation which converts Lvalues from Local to generator struct\n         // accesses for locals in `remap`.\n         // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n@@ -755,14 +793,10 @@ impl MirPass for StateTransform {\n             state_adt_ref,\n             state_substs,\n             remap,\n-            bb_target_count: 2,\n-            bb_targets,\n+            storage_liveness,\n+            suspension_points: Vec::new(),\n             new_ret_local,\n             state_field,\n-\n-            // For returns we will resume execution at the next added basic block.\n-            // This happens in `insert_panic_on_resume_after_return`\n-            return_block: BasicBlock::new(mir.basic_blocks().len()),\n         };\n         transform.visit_mir(mir);\n \n@@ -773,9 +807,6 @@ impl MirPass for StateTransform {\n         mir.spread_arg = None;\n         mir.generator_layout = Some(layout);\n \n-        // Panic if we resumed after returning\n-        insert_panic_on_resume_after_return(tcx, mir);\n-\n         // Insert `drop(generator_struct)` which is used to drop upvars for generators in\n         // the unresumed (0) state.\n         // This is expanded to a drop ladder in `elaborate_generator_drops`."}, {"sha": "9c6b0571e58c54003e09a62cef4dd01de74eee68", "filename": "src/test/run-pass/generator/match-bindings.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Ftest%2Frun-pass%2Fgenerator%2Fmatch-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc84cfa72b405c194228b53c4de3f6474204ec/src%2Ftest%2Frun-pass%2Fgenerator%2Fmatch-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fmatch-bindings.rs?ref=5dfc84cfa72b405c194228b53c4de3f6474204ec", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+enum Enum {\n+    A(String),\n+    B\n+}\n+\n+fn main() {\n+    || {\n+        loop {\n+            if let true = true {\n+                match Enum::A(String::new()) {\n+                    Enum::A(_var) => {}\n+                    Enum::B => {}\n+                }\n+            }\n+            yield;\n+        }\n+    };\n+}\n\\ No newline at end of file"}]}