{"sha": "c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMDQxNGY5ODBlYjNlODAxMDY0MGY2YzgzYTVlZjZmOGU2YWIwNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-14T22:28:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-14T22:28:59Z"}, "message": "auto merge of #6471 : gifnksm/rust/reform-rational, r=brson\n\n`std::ratio` module contains `BigRational` type, but the type is not usable by following reasons.\r\n* `Ratio::new` requires `T: Copy + Num + Ord`, but `BigInt` is not implicitly copyable, because it contains unique vector.\r\n* `BigInt` is not implements `Num`\r\n\r\nSo, I rewrite `Ratio` as follows.\r\n* `Ratio` requires `T: Clone + Integer + Ord`.\r\n  * `Copy` -> `Clone`: to be able to use `BigRational`\r\n  * `Num` -> `Integer`: It is incorrect that a rational number constructed by two non-integer numbers.\r\n* `BigInt` implements `Num` and `Orderable` which are required by `Integer` bound", "tree": {"sha": "1c7286df87d9beaa410a53fbdbcb714884d98e86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c7286df87d9beaa410a53fbdbcb714884d98e86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "html_url": "https://github.com/rust-lang/rust/commit/c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c30414f980eb3e8010640f6c83a5ef6f8e6ab047/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "043d02213e19c5a5cffb781e5a11accbe28bf0de", "url": "https://api.github.com/repos/rust-lang/rust/commits/043d02213e19c5a5cffb781e5a11accbe28bf0de", "html_url": "https://github.com/rust-lang/rust/commit/043d02213e19c5a5cffb781e5a11accbe28bf0de"}, {"sha": "da9c1fbf2740258fcb73a3d23bf3cf9d7d096189", "url": "https://api.github.com/repos/rust-lang/rust/commits/da9c1fbf2740258fcb73a3d23bf3cf9d7d096189", "html_url": "https://github.com/rust-lang/rust/commit/da9c1fbf2740258fcb73a3d23bf3cf9d7d096189"}], "stats": {"total": 210, "additions": 126, "deletions": 84}, "files": [{"sha": "c35415c53317cca3420ee9f1a99be5afb07eb10a", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c30414f980eb3e8010640f6c83a5ef6f8e6ab047/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30414f980eb3e8010640f6c83a5ef6f8e6ab047/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "patch": "@@ -17,7 +17,7 @@ A BigInt is a combination of BigUint and Sign.\n */\n \n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n-use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix};\n+use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n \n /**\n A BigDigit is a BigUint's composing element.\n@@ -144,6 +144,26 @@ impl FromStr for BigUint {\n     }\n }\n \n+impl Num for BigUint {}\n+\n+impl Orderable for BigUint {\n+    #[inline(always)]\n+    fn min(&self, other: &BigUint) -> BigUint {\n+        if self < other { self.clone() } else { other.clone() }\n+    }\n+\n+    #[inline(always)]\n+    fn max(&self, other: &BigUint) -> BigUint {\n+        if self > other { self.clone() } else { other.clone() }\n+    }\n+\n+    #[inline(always)]\n+    fn clamp(&self, mn: &BigUint, mx: &BigUint) -> BigUint {\n+        if self > mx { mx.clone() } else\n+        if self < mn { mn.clone() } else { self.clone() }\n+    }\n+}\n+\n impl Shl<uint, BigUint> for BigUint {\n     #[inline(always)]\n     fn shl(&self, rhs: &uint) -> BigUint {\n@@ -788,6 +808,26 @@ impl FromStr for BigInt {\n     }\n }\n \n+impl Num for BigInt {}\n+\n+impl Orderable for BigInt {\n+    #[inline(always)]\n+    fn min(&self, other: &BigInt) -> BigInt {\n+        if self < other { self.clone() } else { other.clone() }\n+    }\n+\n+    #[inline(always)]\n+    fn max(&self, other: &BigInt) -> BigInt {\n+        if self > other { self.clone() } else { other.clone() }\n+    }\n+\n+    #[inline(always)]\n+    fn clamp(&self, mn: &BigInt, mx: &BigInt) -> BigInt {\n+        if self > mx { mx.clone() } else\n+        if self < mn { mn.clone() } else { self.clone() }\n+    }\n+}\n+\n impl Shl<uint, BigInt> for BigInt {\n     #[inline(always)]\n     fn shl(&self, rhs: &uint) -> BigInt {"}, {"sha": "d57c642c5a29c1e339c12da48d0612f69135acd9", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 85, "deletions": 83, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c30414f980eb3e8010640f6c83a5ef6f8e6ab047/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30414f980eb3e8010640f6c83a5ef6f8e6ab047/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "patch": "@@ -30,7 +30,7 @@ pub type Rational64 = Ratio<i64>;\n /// Alias for arbitrary precision rationals.\n pub type BigRational = Ratio<BigInt>;\n \n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Ratio<T> {\n     /// Create a ratio representing the integer `t`.\n     #[inline(always)]\n@@ -57,53 +57,30 @@ impl<T: Copy + Num + Ord>\n \n     /// Put self into lowest terms, with denom > 0.\n     fn reduce(&mut self) {\n-        let g : T = gcd(self.numer, self.denom);\n+        let g : T = self.numer.gcd(&self.denom);\n \n-        self.numer /= g;\n-        self.denom /= g;\n+        // FIXME(#6050): overloaded operators force moves with generic types\n+        // self.numer /= g;\n+        self.numer = self.numer / g;\n+        // FIXME(#6050): overloaded operators force moves with generic types\n+        // self.denom /= g;\n+        self.denom = self.denom / g;\n \n         // keep denom positive!\n         if self.denom < Zero::zero() {\n             self.numer = -self.numer;\n             self.denom = -self.denom;\n         }\n     }\n+\n     /// Return a `reduce`d copy of self.\n     fn reduced(&self) -> Ratio<T> {\n-        let mut ret = copy *self;\n+        let mut ret = self.clone();\n         ret.reduce();\n         ret\n     }\n }\n \n-/**\n-Compute the greatest common divisor of two numbers, via Euclid's algorithm.\n-\n-The result can be negative.\n-*/\n-#[inline]\n-pub fn gcd_raw<T: Num>(n: T, m: T) -> T {\n-    let mut m = m, n = n;\n-    while m != Zero::zero() {\n-        let temp = m;\n-        m = n % temp;\n-        n = temp;\n-    }\n-    n\n-}\n-\n-/**\n-Compute the greatest common divisor of two numbers, via Euclid's algorithm.\n-\n-The result is always positive.\n-*/\n-#[inline]\n-pub fn gcd<T: Num + Ord>(n: T, m: T) -> T {\n-    let g = gcd_raw(n, m);\n-    if g < Zero::zero() { -g }\n-    else { g }\n-}\n-\n /* Comparisons */\n \n // comparing a/b and c/d is the same as comparing a*d and b*c, so we\n@@ -133,7 +110,7 @@ cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n \n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)\n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -142,7 +119,7 @@ impl<T: Copy + Num + Ord>\n }\n \n // (a/b) / (c/d) = (a*d)/(b*c)\n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -153,7 +130,7 @@ impl<T: Copy + Num + Ord>\n // Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n macro_rules! arith_impl {\n     (impl $imp:ident, $method:ident) => {\n-        impl<T: Copy + Num + Ord>\n+        impl<T: Clone + Integer + Ord>\n             $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n             #[inline]\n             fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -173,16 +150,16 @@ arith_impl!(impl Sub, sub)\n // a/b % c/d = (a*d % b*c)/(b*d)\n arith_impl!(impl Rem, rem)\n \n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Neg<Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn neg(&self) -> Ratio<T> {\n-        Ratio::new_raw(-self.numer, self.denom)\n+        Ratio::new_raw(-self.numer, self.denom.clone())\n     }\n }\n \n /* Constants */\n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Zero for Ratio<T> {\n     #[inline]\n     fn zero() -> Ratio<T> {\n@@ -195,19 +172,19 @@ impl<T: Copy + Num + Ord>\n     }\n }\n \n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     One for Ratio<T> {\n     #[inline]\n     fn one() -> Ratio<T> {\n         Ratio::new_raw(One::one(), One::one())\n     }\n }\n \n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Num for Ratio<T> {}\n \n /* Utils */\n-impl<T: Copy + Num + Ord>\n+impl<T: Clone + Integer + Ord>\n     Round for Ratio<T> {\n \n     fn floor(&self) -> Ratio<T> {\n@@ -241,14 +218,14 @@ impl<T: Copy + Num + Ord>\n     }\n \n     fn fract(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.numer % self.denom, self.denom)\n+        Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n     }\n }\n \n-impl<T: Copy + Num + Ord> Fractional for Ratio<T> {\n+impl<T: Clone + Integer + Ord> Fractional for Ratio<T> {\n     #[inline]\n     fn recip(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.denom, self.numer)\n+        Ratio::new_raw(self.denom.clone(), self.numer.clone())\n     }\n }\n \n@@ -266,7 +243,7 @@ impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     }\n }\n \n-impl<T: FromStr + Copy + Num + Ord>\n+impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n@@ -276,14 +253,14 @@ impl<T: FromStr + Copy + Num + Ord>\n             }\n         });\n         if split.len() < 2 { return None; }\n-        do FromStr::from_str(split[0]).chain |a| {\n-            do FromStr::from_str(split[1]).chain |b| {\n-                Some(Ratio::new(a,b))\n+        do FromStr::from_str::<T>(split[0]).chain |a| {\n+            do FromStr::from_str::<T>(split[1]).chain |b| {\n+                Some(Ratio::new(a.clone(), b.clone()))\n             }\n         }\n     }\n }\n-impl<T: FromStrRadix + Copy + Num + Ord>\n+impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n@@ -294,9 +271,9 @@ impl<T: FromStrRadix + Copy + Num + Ord>\n         });\n         if split.len() < 2 { None }\n         else {\n-            do FromStrRadix::from_str_radix(split[0], radix).chain |a| {\n-                do FromStrRadix::from_str_radix(split[1], radix).chain |b| {\n-                    Some(Ratio::new(a,b))\n+            do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {\n+                do FromStrRadix::from_str_radix::<T>(split[1], radix).chain |b| {\n+                    Some(Ratio::new(a.clone(), b.clone()))\n                 }\n             }\n         }\n@@ -306,7 +283,7 @@ impl<T: FromStrRadix + Copy + Num + Ord>\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use core::num::{Zero,One,FromStrRadix};\n+    use core::num::{Zero,One,FromStrRadix,IntConvertible};\n     use core::from_str::FromStr;\n \n     pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n@@ -316,16 +293,11 @@ mod test {\n     pub static _3_2: Rational = Ratio { numer: 3, denom: 2};\n     pub static _neg1_2: Rational =  Ratio { numer: -1, denom: 2};\n \n-    #[test]\n-    fn test_gcd() {\n-        assert_eq!(gcd(10,2),2);\n-        assert_eq!(gcd(10,3),1);\n-        assert_eq!(gcd(0,3),3);\n-        assert_eq!(gcd(3,3),3);\n-\n-        assert_eq!(gcd(3,-3), 3);\n-        assert_eq!(gcd(-6,3), 3);\n-        assert_eq!(gcd(-4,-2), 2);\n+    pub fn to_big(n: Rational) -> BigRational {\n+        Ratio::new(\n+            IntConvertible::from_int(n.numer),\n+            IntConvertible::from_int(n.denom)\n+        )\n     }\n \n     #[test]\n@@ -374,45 +346,75 @@ mod test {\n \n         #[test]\n         fn test_add() {\n-            assert_eq!(_1 + _1_2, _3_2);\n-            assert_eq!(_1 + _1, _2);\n-            assert_eq!(_1_2 + _3_2, _2);\n-            assert_eq!(_1_2 + _neg1_2, _0);\n+            fn test(a: Rational, b: Rational, c: Rational) {\n+                assert_eq!(a + b, c);\n+                assert_eq!(to_big(a) + to_big(b), to_big(c));\n+            }\n+\n+            test(_1, _1_2, _3_2);\n+            test(_1, _1, _2);\n+            test(_1_2, _3_2, _2);\n+            test(_1_2, _neg1_2, _0);\n         }\n \n         #[test]\n         fn test_sub() {\n-            assert_eq!(_1 - _1_2, _1_2);\n-            assert_eq!(_3_2 - _1_2, _1);\n-            assert_eq!(_1 - _neg1_2, _3_2);\n+            fn test(a: Rational, b: Rational, c: Rational) {\n+                assert_eq!(a - b, c);\n+                assert_eq!(to_big(a) - to_big(b), to_big(c))\n+            }\n+\n+            test(_1, _1_2, _1_2);\n+            test(_3_2, _1_2, _1);\n+            test(_1, _neg1_2, _3_2);\n         }\n \n         #[test]\n         fn test_mul() {\n-            assert_eq!(_1 * _1_2, _1_2);\n-            assert_eq!(_1_2 * _3_2, Ratio::new(3,4));\n-            assert_eq!(_1_2 * _neg1_2, Ratio::new(-1, 4));\n+            fn test(a: Rational, b: Rational, c: Rational) {\n+                assert_eq!(a * b, c);\n+                assert_eq!(to_big(a) * to_big(b), to_big(c))\n+            }\n+\n+            test(_1, _1_2, _1_2);\n+            test(_1_2, _3_2, Ratio::new(3,4));\n+            test(_1_2, _neg1_2, Ratio::new(-1, 4));\n         }\n \n         #[test]\n         fn test_div() {\n-            assert_eq!(_1 / _1_2, _2);\n-            assert_eq!(_3_2 / _1_2, _1 + _2);\n-            assert_eq!(_1 / _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n+            fn test(a: Rational, b: Rational, c: Rational) {\n+                assert_eq!(a / b, c);\n+                assert_eq!(to_big(a) / to_big(b), to_big(c))\n+            }\n+\n+            test(_1, _1_2, _2);\n+            test(_3_2, _1_2, _1 + _2);\n+            test(_1, _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n         }\n \n         #[test]\n         fn test_rem() {\n-            assert_eq!(_3_2 % _1, _1_2);\n-            assert_eq!(_2 % _neg1_2, _0);\n-            assert_eq!(_1_2 % _2,  _1_2);\n+            fn test(a: Rational, b: Rational, c: Rational) {\n+                assert_eq!(a % b, c);\n+                assert_eq!(to_big(a) % to_big(b), to_big(c))\n+            }\n+\n+            test(_3_2, _1, _1_2);\n+            test(_2, _neg1_2, _0);\n+            test(_1_2, _2,  _1_2);\n         }\n \n         #[test]\n         fn test_neg() {\n-            assert_eq!(-_0, _0);\n-            assert_eq!(-_1_2, _neg1_2);\n-            assert_eq!(-(-_1), _1);\n+            fn test(a: Rational, b: Rational) {\n+                assert_eq!(-a, b);\n+                assert_eq!(-to_big(a), to_big(b))\n+            }\n+\n+            test(_0, _0);\n+            test(_1_2, _neg1_2);\n+            test(-_1, _1);\n         }\n         #[test]\n         fn test_zero() {"}]}