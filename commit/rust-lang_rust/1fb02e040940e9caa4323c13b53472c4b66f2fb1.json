{"sha": "1fb02e040940e9caa4323c13b53472c4b66f2fb1", "node_id": "C_kwDOAAsO6NoAKDFmYjAyZTA0MDk0MGU5Y2FhNDMyM2MxM2I1MzQ3MmM0YjY2ZjJmYjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-26T04:28:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-26T04:28:41Z"}, "message": "Auto merge of #99745 - JohnTitor:rollup-lvrie64, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98211 (Implement `fs::get_path` for FreeBSD.)\n - #99353 (Slightly improve mismatched GAT where clause error)\n - #99593 (Suggest removing the tuple struct field for the unwrapped value)\n - #99615 (Remove some explicit `self.infcx` for `FnCtxt`, which already derefs into `InferCtxt`)\n - #99711 (Remove reachable coverage without counters)\n - #99718 (Avoid `&str`/`Symbol` to `String` conversions)\n - #99720 (Sync rustc_codegen_cranelift)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f73fc5344070462abc7e9752fcdffcdb8e72002f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f73fc5344070462abc7e9752fcdffcdb8e72002f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fb02e040940e9caa4323c13b53472c4b66f2fb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb02e040940e9caa4323c13b53472c4b66f2fb1", "html_url": "https://github.com/rust-lang/rust/commit/1fb02e040940e9caa4323c13b53472c4b66f2fb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fb02e040940e9caa4323c13b53472c4b66f2fb1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42dd106b6760f4dd793971053d1244db83361324", "url": "https://api.github.com/repos/rust-lang/rust/commits/42dd106b6760f4dd793971053d1244db83361324", "html_url": "https://github.com/rust-lang/rust/commit/42dd106b6760f4dd793971053d1244db83361324"}, {"sha": "640c3f730a998f7f5ba82ea4a2363d92064e7bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/640c3f730a998f7f5ba82ea4a2363d92064e7bc4", "html_url": "https://github.com/rust-lang/rust/commit/640c3f730a998f7f5ba82ea4a2363d92064e7bc4"}], "stats": {"total": 694, "additions": 474, "deletions": 220}, "files": [{"sha": "d88309e412ed0e596f1f4091dd500a96b65b2338", "filename": ".vscode/settings.json", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Fsettings.json?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -1,10 +1,9 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n-    \"rust-analyzer.assist.importGranularity\": \"module\",\n-    \"rust-analyzer.assist.importEnforceGranularity\": true,\n-    \"rust-analyzer.assist.importPrefix\": \"crate\",\n-    \"rust-analyzer.cargo.runBuildScripts\": true,\n+    \"rust-analyzer.imports.granularity.enforce\": true,\n+    \"rust-analyzer.imports.granularity.group\": \"module\",\n+    \"rust-analyzer.imports.prefix\": \"crate\",\n     \"rust-analyzer.cargo.features\": [\"unstable-features\"],\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "532049c858d4f4ce78218a816512d2a9c7acd9cb", "filename": "Cargo.lock", "status": "modified", "additions": 103, "deletions": 36, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -2,6 +2,17 @@\n # It is not intended for manual editing.\n version = 3\n \n+[[package]]\n+name = \"ahash\"\n+version = \"0.7.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fcb51a0695d8f838b1ee009b3fbf66bda078cd64590202a864a8f3e8c4315c47\"\n+dependencies = [\n+ \"getrandom\",\n+ \"once_cell\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.56\"\n@@ -25,6 +36,12 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"byteorder\"\n+version = \"1.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n+\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -33,68 +50,75 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed44413e7e2fe3260d0ed73e6956ab188b69c10ee92b892e401e0f4f6808c68b\"\n+checksum = \"749d0d6022c9038dccf480bdde2a38d435937335bf2bb0f14e815d94517cdce8\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b5d83f0f26bf213f971f45589d17e5b65e4861f9ed22392b0cbb6eaa5bd329c\"\n+checksum = \"e94370cc7b37bf652ccd8bb8f09bd900997f7ccf97520edfc75554bb5c4abbea\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n+ \"cranelift-isle\",\n  \"gimli\",\n  \"log\",\n- \"regalloc\",\n+ \"regalloc2\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6800dc386177df6ecc5a32680607ed8ba1fa0d31a2a59c8c61fbf44826b8191d\"\n+checksum = \"e0a3cea8fdab90e44018c5b9a1dfd460d8ee265ac354337150222a354628bdb6\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c961f85070985ebc8fcdb81b838a5cf842294d1e6ed4852446161c7e246fd455\"\n+checksum = \"5ac72f76f2698598951ab26d8c96eaa854810e693e7dd52523958b5909fde6b2\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2347b2b8d1d5429213668f2a8e36c85ee3c73984a2f6a79007e365d3e575e7ed\"\n+checksum = \"09eaeacfcd2356fe0e66b295e8f9d59fdd1ac3ace53ba50de14d628ec902f72d\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4cbcdbf7bed29e363568b778649b69dabc3d727256d5d25236096ef693757654\"\n+checksum = \"dba69c9980d5ffd62c18a2bde927855fcd7c8dc92f29feaf8636052662cbd99c\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"cranelift-isle\"\n+version = \"0.85.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d2920dc1e05cac40304456ed3301fde2c09bd6a9b0210bcfa2f101398d628d5b\"\n+\n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c769d4e0d76f59c8b2a3bf0477d89ee149bb0731b53fbb245ee081d49063095\"\n+checksum = \"1c3c5ed067f2c81577e431f3039148a9c187b33cc79e0d1731fede27d801ec56\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -110,19 +134,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0ab57d399a2401074bb0cc40b3031e420f3d66d46ec0cf21eeae53ac04bd73e2\"\n+checksum = \"eee6784303bf9af235237a4885f7417e09a35df896d38ea969a0081064b3ede4\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f4cdf93552e5ceb2e3c042829ebb4de4378492705f769eadc6a7c6c5251624c\"\n+checksum = \"f04dfa45f9b2a6f587c564d6b63388e00cd6589d2df6ea2758cf79e1a13285e6\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -131,9 +155,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf8e65f4839c26e6237fc0744911d79b0a2ac5e76b4e4eebd14db2b8d849fd31\"\n+checksum = \"0bf38b2c505db749276793116c0cb30bd096206c7810e471677a453134881881\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -152,6 +176,26 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"fxhash\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c\"\n+dependencies = [\n+ \"byteorder\",\n+]\n+\n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n [[package]]\n name = \"gimli\"\n version = \"0.26.1\"\n@@ -161,6 +205,15 @@ dependencies = [\n  \"indexmap\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+dependencies = [\n+ \"ahash\",\n+]\n+\n [[package]]\n name = \"hashbrown\"\n version = \"0.12.3\"\n@@ -174,14 +227,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown\",\n+ \"hashbrown 0.12.3\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.119\"\n+version = \"0.2.126\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1bf2e165bb3457c8e098ea76f3e3bc9db55f87aa90d52d0e6be741470916aaa4\"\n+checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n \n [[package]]\n name = \"libloading\"\n@@ -219,11 +272,12 @@ checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n \n [[package]]\n name = \"object\"\n-version = \"0.27.1\"\n+version = \"0.28.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"67ac1d3f9a1d3616fd9a60c8d74296f22406a238b6a72f5cc1e6f314df4ffbf9\"\n+checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n dependencies = [\n  \"crc32fast\",\n+ \"hashbrown 0.11.2\",\n  \"indexmap\",\n  \"memchr\",\n ]\n@@ -235,13 +289,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n \n [[package]]\n-name = \"regalloc\"\n-version = \"0.0.34\"\n+name = \"regalloc2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"62446b1d3ebf980bdc68837700af1d77b37bc430e524bf95319c6eada2a4cc02\"\n+checksum = \"4a8d23b35d7177df3b9d31ed8a9ab4bf625c668be77a319d4f5efd4a5257701c\"\n dependencies = [\n+ \"fxhash\",\n  \"log\",\n- \"rustc-hash\",\n+ \"slice-group-by\",\n  \"smallvec\",\n ]\n \n@@ -257,12 +312,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"rustc-hash\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n-\n [[package]]\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n@@ -283,6 +332,12 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"slice-group-by\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n+\n [[package]]\n name = \"smallvec\"\n version = \"1.8.1\"\n@@ -295,6 +350,18 @@ version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d7fa7e55043acb85fca6b3c01485a2eeb6b69c5d21002e273c79e465f43b7ac1\"\n \n+[[package]]\n+name = \"version_check\"\n+version = \"0.9.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.10.2+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.3.9\""}, {"sha": "61e977e3e69bfbd0ae0e23a4d82693a509e25d3e", "filename": "Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -8,15 +8,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.83.0\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.83.0\"\n-cranelift-module = \"0.83.0\"\n-cranelift-native = \"0.83.0\"\n-cranelift-jit = { version = \"0.83.0\", optional = true }\n-cranelift-object = \"0.83.0\"\n+cranelift-codegen = { version = \"0.85.3\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.85.3\"\n+cranelift-module = \"0.85.3\"\n+cranelift-native = \"0.85.3\"\n+cranelift-jit = { version = \"0.85.3\", optional = true }\n+cranelift-object = \"0.85.3\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.27.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.28.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\""}, {"sha": "7b2cdd273366f41ea8b21939395ba82e124b07ae", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -56,9 +56,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.72\"\n+version = \"0.1.75\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afdbb35d279238cf77f0c9e8d90ad50d6c7bff476ab342baafa29440f0f10bff\"\n+checksum = \"c6e3183e88f659a862835db8f4b67dbeed3d93e44dd4927eef78edb1c149d784\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -112,9 +112,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.12.1\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db0d4cf898abf0081f964436dc980e96670a0f36863e4b83aaacdb65c9d7ccc3\"\n+checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -123,20 +123,21 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.0\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ab7905ea95c6d9af62940f9d7dd9596d54c334ae2c15300c482051292d5637f\"\n+checksum = \"7668753748e445859e4e373c3d41117235d9feed578392f5a3a73efdc751ca4a\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n+ \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.125\"\n+version = \"0.2.126\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5916d2ae698f6de9bfb891ad7a8d65c09d232dc58cc4ac433c7da3b2fd84bc2b\"\n+checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "16cce83dd9c850f06222f5e0549fc30b538bb31f", "filename": "build_system/build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/build_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/build_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_sysroot.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -205,7 +205,7 @@ fn build_clif_sysroot_for_triple(\n     {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n-            if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" {\n+            if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" || ext == \"clif\" {\n                 continue;\n             }\n         } else {"}, {"sha": "8b6042a3d66380909f63bb727a4fcb08cce5fc5e", "filename": "example/mini_core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -458,7 +458,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n \n #[lang = \"panic\"]\n #[track_caller]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\n\\0\" as *const str as *const i8);\n         intrinsics::abort();\n@@ -497,7 +497,7 @@ pub trait Deref {\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n #[rustc_nonnull_optimization_guaranteed]\n-pub struct NonNull<T: ?Sized>(pub *mut T);\n+pub struct NonNull<T: ?Sized>(pub *const T);\n \n impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n@@ -521,7 +521,7 @@ impl<T: ?Sized> Drop for Box<T> {\n     }\n }\n \n-impl<T> Deref for Box<T> {\n+impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {"}, {"sha": "aa1f239bae23ec55bce6c5872f7eac3d37ae8355", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -124,6 +124,23 @@ fn call_return_u128_pair() {\n     return_u128_pair();\n }\n \n+#[repr(C)]\n+pub struct bool_11 {\n+    field0: bool,\n+    field1: bool,\n+    field2: bool,\n+    field3: bool,\n+    field4: bool,\n+    field5: bool,\n+    field6: bool,\n+    field7: bool,\n+    field8: bool,\n+    field9: bool,\n+    field10: bool,\n+}\n+\n+extern \"C\" fn bool_struct_in_11(arg0: bool_11) {}\n+\n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n     take_unique(Unique {\n@@ -134,6 +151,20 @@ fn main() {\n \n     call_return_u128_pair();\n \n+    bool_struct_in_11(bool_11 {\n+        field0: true,\n+        field1: true,\n+        field2: true,\n+        field3: true,\n+        field4: true,\n+        field5: true,\n+        field6: true,\n+        field7: true,\n+        field8: true,\n+        field9: true,\n+        field10: true,\n+    });\n+\n     let slice = &[0, 1] as &[i32];\n     let slice_ptr = slice as *const [i32] as *const i32;\n \n@@ -299,6 +330,17 @@ fn main() {\n     static REF1: &u8 = &42;\n     static REF2: &u8 = REF1;\n     assert_eq!(*REF1, *REF2);\n+\n+    extern \"C\" {\n+        type A;\n+    }\n+\n+    fn main() {\n+        let x: &A = unsafe { &*(1usize as *const A) };\n+\n+        assert_eq!(unsafe { intrinsics::size_of_val(x) }, 0);\n+        assert_eq!(unsafe { intrinsics::min_align_of_val(x) }, 1);\n+}\n }\n \n #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]"}, {"sha": "0b5b6cd55d720d4750060ecb81f75b83f76f4cf6", "filename": "example/std_example.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -128,6 +128,25 @@ fn main() {\n         0 => loop {},\n         v => panic(v),\n     };\n+\n+    if black_box(false) {\n+        // Based on https://github.com/rust-lang/rust/blob/2f320a224e827b400be25966755a621779f797cc/src/test/ui/debuginfo/debuginfo_with_uninhabitable_field_and_unsized.rs\n+        let _ = Foo::<dyn Send>::new();\n+\n+        #[allow(dead_code)]\n+        struct Foo<T: ?Sized> {\n+            base: Never,\n+            value: T,\n+        }\n+\n+        impl<T: ?Sized> Foo<T> {\n+            pub fn new() -> Box<Foo<T>> {\n+                todo!()\n+            }\n+        }\n+\n+        enum Never {}\n+    }\n }\n \n fn panic(_: u128) {"}, {"sha": "3ab395d89d50e884945dd045e080c922039c73aa", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-05-15\"\n+channel = \"nightly-2022-07-25\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "091bfa1e9926fac647315298b8c35c386f46b3d3", "filename": "scripts/setup_rust_fork.sh", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/scripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/scripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fsetup_rust_fork.sh?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -29,14 +29,15 @@ diff --git a/src/tools/compiletest/src/runtest.rs b/src/tools/compiletest/src/ru\n index 8431aa7b818..a3ff7e68ce5 100644\n --- a/src/tools/compiletest/src/runtest.rs\n +++ b/src/tools/compiletest/src/runtest.rs\n-@@ -3489,11 +3489,7 @@ fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> S\n-             .join(\"library\");\n-         normalize_path(&src_dir, \"$(echo '$SRC_DIR')\");\n+@@ -3489,12 +3489,7 @@ fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> S\n+         let compiler_src_dir = base_dir.join(\"compiler\");\n+         normalize_path(&compiler_src_dir, \"$(echo '$COMPILER_DIR')\");\n \n -        if let Some(virtual_rust_source_base_dir) =\n -            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from)\n -        {\n -            normalize_path(&virtual_rust_source_base_dir.join(\"library\"), \"$(echo '$SRC_DIR')\");\n+-            normalize_path(&virtual_rust_source_base_dir.join(\"compiler\"), \"$(echo '$COMPILER_DIR')\");\n -        }\n +        normalize_path(&Path::new(\"$(cd ../build_sysroot/sysroot_src/library; pwd)\"), \"$(echo '$SRC_DIR')\");\n \n@@ -62,3 +63,6 @@ deny-warnings = false\n verbose-tests = false\n EOF\n popd\n+\n+# FIXME remove once inline asm is fully supported\n+export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\""}, {"sha": "944787612d8bc206e1a29a7ab130518696ecc410", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -33,6 +33,7 @@ rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-typ\n rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n rm src/test/ui/generator/size-moved-locals.rs # same\n+rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n \n # vendor intrinsics\n rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n@@ -65,11 +66,13 @@ rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and n\n rm src/test/ui/target-feature/missing-plusminus.rs # error not implemented\n rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n+rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n \n # optimization tests\n # ==================\n-rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n+rm src/test/ui/codegen/issue-28950.rs # depends on stack size optimizations\n rm src/test/ui/codegen/init-large-type.rs # same\n+rm src/test/ui/issues/issue-40883.rs # same\n rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n \n # backend specific tests\n@@ -89,14 +92,13 @@ rm src/test/ui/consts/issue-33537.rs # same\n rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n rm -r src/test/run-make/unstable-flag-required # same\n rm -r src/test/run-make/rustdoc-* # same\n+rm -r src/test/run-make/issue-88756-default-output # same\n+rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n \n # genuine bugs\n # ============\n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n \n-rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n-rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n-\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n@@ -111,6 +113,8 @@ rm src/test/ui/backtrace.rs # TODO warning\n rm src/test/ui/empty_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n+# not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n+rm -r src/test/run-make/native-link-modifier-bundle\n \n echo \"[TEST] rustc test suite\"\n RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui,incremental}"}, {"sha": "815450f689e4ab50c4957a35d5ee90faf22ca7e9", "filename": "src/abi/mod.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -4,6 +4,7 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_target::abi::call::{Conv, FnAbi};\n@@ -69,7 +70,17 @@ pub(crate) fn import_function<'tcx>(\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name;\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module.declare_function(name, Linkage::Import, &sig).unwrap()\n+    match module.declare_function(name, Linkage::Import, &sig) {\n+        Ok(func_id) => func_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{name}` as function, but it was already declared as static\"\n+        )),\n+        Err(ModuleError::IncompatibleSignature(_, prev_sig, new_sig)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{name}` with signature {new_sig:?}, \\\n+             but it was already declared with signature {prev_sig:?}\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    }\n }\n \n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n@@ -182,6 +193,15 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     }\n \n     let fn_abi = fx.fn_abi.take().unwrap();\n+\n+    // FIXME implement variadics in cranelift\n+    if fn_abi.c_variadic {\n+        fx.tcx.sess.span_fatal(\n+            fx.mir.span,\n+            \"Defining variadic functions is not yet supported by Cranelift\",\n+        );\n+    }\n+\n     let mut arg_abis_iter = fn_abi.args.iter();\n \n     let func_params = fx\n@@ -376,9 +396,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_ty.fn_sig(fx.tcx), extra_args)\n     };\n \n-    let is_cold = instance\n-        .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n-        .unwrap_or(false);\n+    let is_cold = if fn_sig.abi == Abi::RustCold {\n+        true\n+    } else {\n+        instance\n+            .map(|inst| {\n+                fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD)\n+            })\n+            .unwrap_or(false)\n+    };\n     if is_cold {\n         fx.bcx.set_cold_block(fx.bcx.current_block().unwrap());\n         if let Some(destination_block) = target {"}, {"sha": "6c10baa53d415da6e32e64adebecab4d57a059d4", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -18,9 +18,9 @@ fn reg_to_abi_param(reg: Reg) -> AbiParam {\n     let clif_ty = match (reg.kind, reg.size.bytes()) {\n         (RegKind::Integer, 1) => types::I8,\n         (RegKind::Integer, 2) => types::I16,\n-        (RegKind::Integer, 4) => types::I32,\n-        (RegKind::Integer, 8) => types::I64,\n-        (RegKind::Integer, 16) => types::I128,\n+        (RegKind::Integer, 3..=4) => types::I32,\n+        (RegKind::Integer, 5..=8) => types::I64,\n+        (RegKind::Integer, 9..=16) => types::I128,\n         (RegKind::Float, 4) => types::F32,\n         (RegKind::Float, 8) => types::F64,\n         (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n@@ -48,23 +48,9 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         )\n     };\n \n-    if cast.prefix.iter().all(|x| x.is_none()) {\n-        // Simplify to a single unit when there is no prefix and size <= unit size\n-        if cast.rest.total <= cast.rest.unit.size {\n-            let clif_ty = match (cast.rest.unit.kind, cast.rest.unit.size.bytes()) {\n-                (RegKind::Integer, 1) => types::I8,\n-                (RegKind::Integer, 2) => types::I16,\n-                (RegKind::Integer, 3..=4) => types::I32,\n-                (RegKind::Integer, 5..=8) => types::I64,\n-                (RegKind::Integer, 9..=16) => types::I128,\n-                (RegKind::Float, 4) => types::F32,\n-                (RegKind::Float, 8) => types::F64,\n-                (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n-                _ => unreachable!(\"{:?}\", cast.rest.unit),\n-            };\n-            return smallvec![AbiParam::new(clif_ty)];\n-        }\n-    }\n+    // Note: Unlike the LLVM equivalent of this code we don't have separate branches for when there\n+    // is no prefix as a single unit, an array and a heterogeneous struct are not represented using\n+    // different types in Cranelift IR. Instead a single array of primitive types is used.\n \n     // Create list of fields in the main structure\n     let mut args = cast\n@@ -230,7 +216,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     is_owned: bool,\n ) -> SmallVec<[Value; 2]> {\n-    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty, 16);\n     match arg_abi.mode {\n         PassMode::Ignore => smallvec![],\n         PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],"}, {"sha": "c92c1051139542299ae933bbd904035e319a6307", "filename": "src/archive.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -86,7 +86,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         let mut entries = Vec::new();\n \n-        for (entry_name, entry) in self.entries {\n+        for (mut entry_name, entry) in self.entries {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n@@ -109,6 +109,23 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             };\n \n             if !self.no_builtin_ranlib {\n+                if symbol_table.contains_key(&entry_name) {\n+                    // The ar crate can't handle creating a symbol table in case of multiple archive\n+                    // members with the same name. Work around this by prepending a number until we\n+                    // get a unique name.\n+                    for i in 1.. {\n+                        let new_name = format!(\"{}_\", i)\n+                            .into_bytes()\n+                            .into_iter()\n+                            .chain(entry_name.iter().copied())\n+                            .collect::<Vec<_>>();\n+                        if !symbol_table.contains_key(&new_name) {\n+                            entry_name = new_name;\n+                            break;\n+                        }\n+                    }\n+                }\n+\n                 match object::File::parse(&*data) {\n                     Ok(object) => {\n                         symbol_table.insert("}, {"sha": "122e103ff62bc14262a1b91a7e38d4e293bba6e4", "filename": "src/base.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -175,10 +175,37 @@ fn compile_fn<'tcx>(\n         );\n     });\n \n+    #[cfg(any())] // This is never true\n+    let _clif_guard = {\n+        use std::fmt::Write;\n+\n+        let func_clone = context.func.clone();\n+        let clif_comments_clone = clif_comments.clone();\n+        let mut clif = String::new();\n+        for flag in module.isa().flags().iter() {\n+            writeln!(clif, \"set {}\", flag).unwrap();\n+        }\n+        write!(clif, \"target {}\", module.isa().triple().architecture.to_string()).unwrap();\n+        for isa_flag in module.isa().isa_flags().iter() {\n+            write!(clif, \" {}\", isa_flag).unwrap();\n+        }\n+        writeln!(clif, \"\\n\").unwrap();\n+        crate::PrintOnPanic(move || {\n+            let mut clif = clif.clone();\n+            ::cranelift_codegen::write::decorate_function(\n+                &mut &clif_comments_clone,\n+                &mut clif,\n+                &func_clone,\n+            )\n+            .unwrap();\n+            clif\n+        })\n+    };\n+\n     // Define function\n     tcx.sess.time(\"define function\", || {\n         context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module.define_function(func_id, context).unwrap()\n+        module.define_function(func_id, context).unwrap();\n     });\n \n     // Write optimized function to file for debugging\n@@ -815,15 +842,7 @@ pub(crate) fn codegen_place<'tcx>(\n     for elem in place.projection {\n         match elem {\n             PlaceElem::Deref => {\n-                if cplace.layout().ty.is_box() {\n-                    cplace = cplace\n-                        .place_field(fx, Field::new(0)) // Box<T> -> Unique<T>\n-                        .place_field(fx, Field::new(0)) // Unique<T> -> NonNull<T>\n-                        .place_field(fx, Field::new(0)) // NonNull<T> -> *mut T\n-                        .place_deref(fx);\n-                } else {\n-                    cplace = cplace.place_deref(fx);\n-                }\n+                cplace = cplace.place_deref(fx);\n             }\n             PlaceElem::Field(field, _ty) => {\n                 cplace = cplace.place_field(fx, field);"}, {"sha": "bad5d1f08a9cf5454766b36de3f2614e5a6020a4", "filename": "src/cast.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -149,17 +149,8 @@ pub(crate) fn clif_int_or_float_cast(\n         }\n \n         let is_not_nan = fx.bcx.ins().fcmp(FloatCC::Equal, from, from);\n-        if to_ty == types::I128 {\n-            // FIXME(bytecodealliance/wasmtime#3963): select.i128 on fcmp eq miscompiles\n-            let (lsb, msb) = fx.bcx.ins().isplit(val);\n-            let zero = fx.bcx.ins().iconst(types::I64, 0);\n-            let lsb = fx.bcx.ins().select(is_not_nan, lsb, zero);\n-            let msb = fx.bcx.ins().select(is_not_nan, msb, zero);\n-            fx.bcx.ins().iconcat(lsb, msb)\n-        } else {\n-            let zero = fx.bcx.ins().iconst(to_ty, 0);\n-            fx.bcx.ins().select(is_not_nan, val, zero)\n-        }\n+        let zero = fx.bcx.ins().iconst(to_ty, 0);\n+        fx.bcx.ins().select(is_not_nan, val, zero)\n     } else if from_ty.is_float() && to_ty.is_float() {\n         // float -> float\n         match (from_ty, to_ty) {"}, {"sha": "7f7fd0e9c579d17fb2d8a6fc7803c439bd7fc020", "filename": "src/constant.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -328,14 +328,18 @@ fn data_id_for_static(\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n-    let data_id = module\n-        .declare_data(\n-            &*symbol_name,\n-            linkage,\n-            is_mutable,\n-            attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n-        )\n-        .unwrap();\n+    let data_id = match module.declare_data(\n+        &*symbol_name,\n+        linkage,\n+        is_mutable,\n+        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+    ) {\n+        Ok(data_id) => data_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    };\n \n     if rlinkage.is_some() {\n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n@@ -441,7 +445,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n-                    let func_id = crate::abi::import_function(tcx, module, instance);\n+                    let func_id =\n+                        crate::abi::import_function(tcx, module, instance.polymorphize(tcx));\n                     let local_func_id = module.declare_func_in_data(func_id, &mut data_ctx);\n                     data_ctx.write_function_addr(offset.bytes() as u32, local_func_id);\n                     continue;"}, {"sha": "241de5e36530c8bbddb1bce99b2f4f2fe39fa23b", "filename": "src/inline_asm.rs", "status": "modified", "additions": 90, "deletions": 80, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -18,86 +18,96 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n-    if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n-        return;\n-    } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n-        && matches!(\n-            template[1],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-        && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-        && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n-        && matches!(\n-            template[6],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-    {\n-        assert_eq!(operands.len(), 4);\n-        let (leaf, eax_place) = match operands[1] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let ebx_place = match operands[0] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                        X86InlineAsmRegClass::reg\n-                    ))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-        let (sub_leaf, ecx_place) = match operands[2] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let edx_place = match operands[3] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n-\n-        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-        return;\n-    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n-        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n-        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+    if !template.is_empty() {\n+        if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+            && matches!(\n+                template[6],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+        {\n+            assert_eq!(operands.len(), 4);\n+            let (leaf, eax_place) = match operands[1] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let ebx_place = match operands[0] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n+                            X86InlineAsmRegClass::reg\n+                        ))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+            let (sub_leaf, ecx_place) = match operands[2] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let edx_place = match operands[3] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+            eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+            ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+            ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+            edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            return;\n+        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+            // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+            crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+        } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+            crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+        }\n     }\n \n     let mut inputs = Vec::new();"}, {"sha": "8d8db1da5818325eb55aeaf9acc6dd9f5e3c55f4", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -404,7 +404,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n         size_of_val, (c ptr) {\n             let layout = fx.layout_of(substs.type_at(0));\n-            let size = if layout.is_unsized() {\n+            // Note: Can't use is_unsized here as truly unsized types need to take the fixed size\n+            // branch\n+            let size = if let Abi::ScalarPair(_, _) = ptr.layout().abi {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 size\n@@ -418,7 +420,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n         min_align_of_val, (c ptr) {\n             let layout = fx.layout_of(substs.type_at(0));\n-            let align = if layout.is_unsized() {\n+            // Note: Can't use is_unsized here as truly unsized types need to take the fixed size\n+            // branch\n+            let align = if let Abi::ScalarPair(_, _) = ptr.layout().abi {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 align\n@@ -1145,6 +1149,20 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             // FIXME implement black_box semantics\n             ret.write_cvalue(fx, a);\n         };\n+\n+        // FIXME implement variadics in cranelift\n+        va_copy, (o _dest, o _src) {\n+            fx.tcx.sess.span_fatal(\n+                source_info.span,\n+                \"Defining variadic functions is not yet supported by Cranelift\",\n+            );\n+        };\n+        va_arg | va_end, (o _valist) {\n+            fx.tcx.sess.span_fatal(\n+                source_info.span,\n+                \"Defining variadic functions is not yet supported by Cranelift\",\n+            );\n+        };\n     }\n \n     let ret_block = fx.get_block(destination.unwrap());"}, {"sha": "568bb20a3f4a7614ab35b22a8931291695e824be", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -141,7 +141,11 @@ impl<'tcx> CodegenCx<'tcx> {\n \n         let unwind_context =\n             UnwindContext::new(isa, matches!(backend_config.codegen_mode, CodegenMode::Aot));\n-        let debug_context = if debug_info { Some(DebugContext::new(tcx, isa)) } else { None };\n+        let debug_context = if debug_info && !tcx.sess.target.options.is_like_windows {\n+            Some(DebugContext::new(tcx, isa))\n+        } else {\n+            None\n+        };\n         CodegenCx {\n             tcx,\n             global_asm: String::new(),\n@@ -243,6 +247,7 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     let enable_verifier = if backend_config.enable_verifier { \"true\" } else { \"false\" };\n     flags_builder.set(\"enable_verifier\", enable_verifier).unwrap();\n+    flags_builder.set(\"regalloc_checker\", enable_verifier).unwrap();\n \n     let tls_model = match target_triple.binary_format {\n         BinaryFormat::Elf => \"elf_gd\","}, {"sha": "c67b6e98b32c7daeeca8558ed2882f082cd0b103", "filename": "src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -109,7 +109,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n                 )\n                 .unwrap()\n-                .unwrap();\n+                .unwrap()\n+                .polymorphize(tcx);\n \n                 let report_name = tcx.symbol_name(report).name;\n                 let report_sig = get_function_sig(tcx, m.isa().triple(), report);"}, {"sha": "1d1ec21680e30a7dc981c262b4fc7b172b12a013", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -66,7 +66,7 @@ use rustc_session::config::OutputType;\n \n use crate::prelude::*;\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub(crate) struct CommentWriter {\n     enabled: bool,\n     global_comments: Vec<String>,\n@@ -237,6 +237,7 @@ pub(crate) fn write_clif_file<'tcx>(\n     func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n+    // FIXME work around filename too long errors\n     write_ir_file(\n         tcx,\n         || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),"}, {"sha": "052ca0a082b3c62261bea1e2d36a3a93936d84a4", "filename": "src/unsize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -153,11 +153,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n-    if !layout.is_unsized() {\n-        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n-        return (size, align);\n-    }\n+    assert!(layout.is_unsized() || layout.abi == Abi::Uninhabited);\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable"}, {"sha": "45ae2bd8f07cb1c28003790b49344db68481307d", "filename": "src/value_and_place.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb02e040940e9caa4323c13b53472c4b66f2fb1/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=1fb02e040940e9caa4323c13b53472c4b66f2fb1", "patch": "@@ -324,6 +324,12 @@ impl<'tcx> CPlace<'tcx> {\n             };\n         }\n \n+        if layout.size.bytes() >= u64::from(u32::MAX - 16) {\n+            fx.tcx\n+                .sess\n+                .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n+        }\n+\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n@@ -420,7 +426,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n-        assert_assignable(fx, from.layout().ty, self.layout().ty);\n+        assert_assignable(fx, from.layout().ty, self.layout().ty, 16);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n@@ -774,18 +780,25 @@ pub(crate) fn assert_assignable<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n+    limit: usize,\n ) {\n+    if limit == 0 {\n+        // assert_assignable exists solely to catch bugs in cg_clif. it isn't necessary for\n+        // soundness. don't attempt to check deep types to avoid exponential behavior in certain\n+        // cases.\n+        return;\n+    }\n     match (from_ty.kind(), to_ty.kind()) {\n         (ty::Ref(_, a, _), ty::Ref(_, b, _))\n         | (\n             ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n             ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n         ) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n         | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::FnPtr(_), ty::FnPtr(_)) => {\n             let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n@@ -815,25 +828,55 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Tuple(types_a), &ty::Tuple(types_b)) => {\n+            let mut types_a = types_a.iter();\n+            let mut types_b = types_b.iter();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n             if adt_def_a.did() == adt_def_b.did() =>\n         {\n             let mut types_a = substs_a.types();\n             let mut types_b = substs_b.types();\n             loop {\n                 match (types_a.next(), types_b.next()) {\n-                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n                     (None, None) => return,\n                     (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n                 }\n             }\n         }\n-        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b),\n+        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b, limit - 1),\n+        (&ty::Closure(def_id_a, substs_a), &ty::Closure(def_id_b, substs_b))\n+            if def_id_a == def_id_b =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n+        (ty::Param(_), _) | (_, ty::Param(_)) if fx.tcx.sess.opts.unstable_opts.polymorphize => {\n+            // No way to check if it is correct or not with polymorphization enabled\n+        }\n         _ => {\n             assert_eq!(\n-                from_ty, to_ty,\n+                from_ty,\n+                to_ty,\n                 \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                from_ty, to_ty, fx,\n+                from_ty.kind(),\n+                to_ty.kind(),\n+                fx,\n             );\n         }\n     }"}]}