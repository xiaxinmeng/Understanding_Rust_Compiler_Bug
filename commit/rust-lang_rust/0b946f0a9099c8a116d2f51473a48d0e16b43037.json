{"sha": "0b946f0a9099c8a116d2f51473a48d0e16b43037", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiOTQ2ZjBhOTA5OWM4YTExNmQyZjUxNDczYTQ4ZDBlMTZiNDMwMzc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-18T23:02:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-19T01:34:38Z"}, "message": "std: Stabilize task module.\n\nMost stable. deschedule/failing experimental because of concerns about\nnaming and desirability.\n\nAdds task::name() to replace deprecated task::with_name().", "tree": {"sha": "d0d4e40e4efacdcf813edc0e3de125de73fc4217", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0d4e40e4efacdcf813edc0e3de125de73fc4217"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b946f0a9099c8a116d2f51473a48d0e16b43037", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b946f0a9099c8a116d2f51473a48d0e16b43037", "html_url": "https://github.com/rust-lang/rust/commit/0b946f0a9099c8a116d2f51473a48d0e16b43037", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b946f0a9099c8a116d2f51473a48d0e16b43037/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf8bfde9d313f27dc72ba3a7d15618f6bbd93e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf8bfde9d313f27dc72ba3a7d15618f6bbd93e9d", "html_url": "https://github.com/rust-lang/rust/commit/cf8bfde9d313f27dc72ba3a7d15618f6bbd93e9d"}], "stats": {"total": 59, "additions": 37, "deletions": 22}, "files": [{"sha": "4b8c15a0152a39f2316070c172c82a578267131e", "filename": "src/libstd/task.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0b946f0a9099c8a116d2f51473a48d0e16b43037/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b946f0a9099c8a116d2f51473a48d0e16b43037/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=0b946f0a9099c8a116d2f51473a48d0e16b43037", "patch": "@@ -91,7 +91,7 @@\n //! # }\n //! ```\n \n-#![experimental]\n+#![stable]\n \n use any::Any;\n use comm::channel;\n@@ -104,7 +104,9 @@ use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n+use string::String;\n use sync::Future;\n+use to_str::ToString;\n \n /// A means of spawning a task\n pub trait Spawner {\n@@ -172,6 +174,7 @@ impl TaskBuilder<SiblingSpawner> {\n impl<S: Spawner> TaskBuilder<S> {\n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in failure messages.\n+    #[unstable = \"IntoMaybeOwned will probably change.\"]\n     pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> {\n         self.name = Some(name.into_maybe_owned());\n         self\n@@ -184,12 +187,14 @@ impl<S: Spawner> TaskBuilder<S> {\n     }\n \n     /// Redirect task-local stdout.\n+    #[experimental = \"May not want to make stdio overridable here.\"]\n     pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder<S> {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect task-local stderr.\n+    #[experimental = \"May not want to make stdio overridable here.\"]\n     pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder<S> {\n         self.stderr = Some(stderr);\n         self\n@@ -288,6 +293,7 @@ impl<S: Spawner> TaskBuilder<S> {\n     /// future returns `result::Ok` containing the value returned by the\n     /// function. If the child task fails then the future returns `result::Err`\n     /// containing the argument to `fail!(...)` as an `Any` trait object.\n+    #[experimental = \"Futures are experimental.\"]\n     pub fn try_future<T:Send>(self, f: proc():Send -> T)\n                               -> Future<Result<T, Box<Any + Send>>> {\n         // currently, the on_exit proc provided by librustrt only works for unit\n@@ -308,6 +314,7 @@ impl<S: Spawner> TaskBuilder<S> {\n \n     /// Execute a function in a newly-spawnedtask and block until the task\n     /// completes or fails. Equivalent to `.try_future(f).unwrap()`.\n+    #[unstable = \"Error type may change.\"]\n     pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n         self.try_future(f).unwrap()\n     }\n@@ -329,6 +336,7 @@ pub fn spawn(f: proc(): Send) {\n /// value of the function or an error if the task failed.\n ///\n /// This is equivalent to `TaskBuilder::new().try`.\n+#[unstable = \"Error type may change.\"]\n pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n     TaskBuilder::new().try(f)\n }\n@@ -337,6 +345,7 @@ pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n /// task's result.\n ///\n /// This is equivalent to `TaskBuilder::new().try_future`.\n+#[experimental = \"Futures are experimental.\"]\n pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> {\n     TaskBuilder::new().try_future(f)\n }\n@@ -345,6 +354,7 @@ pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Sen\n /* Lifecycle functions */\n \n /// Read the name of the current task.\n+#[deprecated = \"Use `task::name()`.\"]\n pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n@@ -355,7 +365,20 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     }\n }\n \n+/// Read the name of the current task.\n+#[stable]\n+pub fn name() -> Option<String> {\n+    use rt::task::Task;\n+\n+    let task = Local::borrow(None::<Task>);\n+    match task.name {\n+        Some(ref name) => Some(name.as_slice().to_string()),\n+        None => None\n+    }\n+}\n+\n /// Yield control to the task scheduler.\n+#[unstable = \"Name will change.\"]\n pub fn deschedule() {\n     use rt::local::Local;\n \n@@ -366,6 +389,7 @@ pub fn deschedule() {\n \n /// True if the running task is currently failing (e.g. will return `true` inside a\n /// destructor that is run while unwinding the stack after a call to `fail!()`).\n+#[unstable = \"May move to a different module.\"]\n pub fn failing() -> bool {\n     use rt::task::Task;\n     Local::borrow(None::<Task>).unwinder.unwinding()\n@@ -377,7 +401,6 @@ mod test {\n     use boxed::BoxAny;\n     use result;\n     use result::{Ok, Err};\n-    use str::StrAllocating;\n     use string::String;\n     use std::io::{ChanReader, ChanWriter};\n     use prelude::*;\n@@ -388,38 +411,30 @@ mod test {\n \n     #[test]\n     fn test_unnamed_task() {\n-        spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.is_none());\n-            })\n-        })\n+        try(proc() {\n+            assert!(name().is_none());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_owned_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        })\n+        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(proc() {\n+            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_static_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\").spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        })\n+        TaskBuilder::new().named(\"ada lovelace\").try(proc() {\n+            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        })\n+        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).try(proc() {\n+            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+        }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]"}]}