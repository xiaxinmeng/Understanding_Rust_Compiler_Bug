{"sha": "dfe021625adc0526385d776d3a7f495c437e2c7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZTAyMTYyNWFkYzA1MjYzODVkNzc2ZDNhN2Y0OTVjNDM3ZTJjN2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-14T00:51:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T01:29:14Z"}, "message": "liburl: Remove all uses of `~str` from `liburl`", "tree": {"sha": "e0105f888a3e1273cef5b42fc6ace1f320682230", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0105f888a3e1273cef5b42fc6ace1f320682230"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfe021625adc0526385d776d3a7f495c437e2c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe021625adc0526385d776d3a7f495c437e2c7e", "html_url": "https://github.com/rust-lang/rust/commit/dfe021625adc0526385d776d3a7f495c437e2c7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfe021625adc0526385d776d3a7f495c437e2c7e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ded860c0e89e6f33dece7f65bb71419b515314eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ded860c0e89e6f33dece7f65bb71419b515314eb", "html_url": "https://github.com/rust-lang/rust/commit/ded860c0e89e6f33dece7f65bb71419b515314eb"}], "stats": {"total": 617, "additions": 315, "deletions": 302}, "files": [{"sha": "a2e75e0bf9b1eb0c90a615461bac300c38280f4e", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 315, "deletions": 302, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/dfe021625adc0526385d776d3a7f495c437e2c7e/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe021625adc0526385d776d3a7f495c437e2c7e/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=dfe021625adc0526385d776d3a7f495c437e2c7e", "patch": "@@ -39,65 +39,67 @@ use std::uint;\n /// ```rust\n /// use url::{Url, UserInfo};\n ///\n-/// let url = Url { scheme: \"https\".to_owned(),\n-///                 user: Some(UserInfo { user: \"username\".to_owned(), pass: None }),\n-///                 host: \"example.com\".to_owned(),\n-///                 port: Some(\"8080\".to_owned()),\n-///                 path: \"/foo/bar\".to_owned(),\n-///                 query: vec!((\"baz\".to_owned(), \"qux\".to_owned())),\n-///                 fragment: Some(\"quz\".to_owned()) };\n+/// let url = Url { scheme: \"https\".to_strbuf(),\n+///                 user: Some(UserInfo { user: \"username\".to_strbuf(), pass: None }),\n+///                 host: \"example.com\".to_strbuf(),\n+///                 port: Some(\"8080\".to_strbuf()),\n+///                 path: \"/foo/bar\".to_strbuf(),\n+///                 query: vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf())),\n+///                 fragment: Some(\"quz\".to_strbuf()) };\n /// // https://username@example.com:8080/foo/bar?baz=qux#quz\n /// ```\n #[deriving(Clone, Eq, TotalEq)]\n pub struct Url {\n     /// The scheme part of a URL, such as `https` in the above example.\n-    pub scheme: ~str,\n+    pub scheme: StrBuf,\n     /// A URL subcomponent for user authentication.  `username` in the above example.\n     pub user: Option<UserInfo>,\n     /// A domain name or IP address.  For example, `example.com`.\n-    pub host: ~str,\n+    pub host: StrBuf,\n     /// A TCP port number, for example `8080`.\n-    pub port: Option<~str>,\n+    pub port: Option<StrBuf>,\n     /// The path component of a URL, for example `/foo/bar`.\n-    pub path: ~str,\n-    /// The query component of a URL.  `vec!((\"baz\".to_owned(), \"qux\".to_owned()))` represents the\n-    /// fragment `baz=qux` in the above example.\n+    pub path: StrBuf,\n+    /// The query component of a URL.\n+    /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n+    /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<~str>\n+    pub fragment: Option<StrBuf>\n }\n \n #[deriving(Clone, Eq)]\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n-    pub path: ~str,\n-    /// The query component of a URL.  `vec!((\"baz\".to_owned(), \"qux\".to_owned()))` represents the\n-    /// fragment `baz=qux` in the above example.\n+    pub path: StrBuf,\n+    /// The query component of a URL.\n+    /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n+    /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<~str>\n+    pub fragment: Option<StrBuf>\n }\n \n /// An optional subcomponent of a URI authority component.\n #[deriving(Clone, Eq, TotalEq)]\n pub struct UserInfo {\n     /// The user name.\n-    pub user: ~str,\n+    pub user: StrBuf,\n     /// Password or other scheme-specific authentication information.\n-    pub pass: Option<~str>\n+    pub pass: Option<StrBuf>\n }\n \n /// Represents the query component of a URI.\n-pub type Query = Vec<(~str, ~str)>;\n+pub type Query = Vec<(StrBuf, StrBuf)>;\n \n impl Url {\n-    pub fn new(scheme: ~str,\n+    pub fn new(scheme: StrBuf,\n                user: Option<UserInfo>,\n-               host: ~str,\n-               port: Option<~str>,\n-               path: ~str,\n+               host: StrBuf,\n+               port: Option<StrBuf>,\n+               path: StrBuf,\n                query: Query,\n-               fragment: Option<~str>)\n+               fragment: Option<StrBuf>)\n                -> Url {\n         Url {\n             scheme: scheme,\n@@ -112,9 +114,9 @@ impl Url {\n }\n \n impl Path {\n-    pub fn new(path: ~str,\n+    pub fn new(path: StrBuf,\n                query: Query,\n-               fragment: Option<~str>)\n+               fragment: Option<StrBuf>)\n                -> Path {\n         Path {\n             path: path,\n@@ -126,12 +128,12 @@ impl Path {\n \n impl UserInfo {\n     #[inline]\n-    pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+    pub fn new(user: StrBuf, pass: Option<StrBuf>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }\n \n-fn encode_inner(s: &str, full_url: bool) -> ~str {\n+fn encode_inner(s: &str, full_url: bool) -> StrBuf {\n     let mut rdr = BufReader::new(s.as_bytes());\n     let mut out = StrBuf::new();\n \n@@ -171,7 +173,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n@@ -189,7 +191,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  * println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n  * ```\n  */\n-pub fn encode(s: &str) -> ~str {\n+pub fn encode(s: &str) -> StrBuf {\n     encode_inner(s, true)\n }\n \n@@ -200,11 +202,11 @@ pub fn encode(s: &str) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n \n-pub fn encode_component(s: &str) -> ~str {\n+pub fn encode_component(s: &str) -> StrBuf {\n     encode_inner(s, false)\n }\n \n-fn decode_inner(s: &str, full_url: bool) -> ~str {\n+fn decode_inner(s: &str, full_url: bool) -> StrBuf {\n     let mut rdr = BufReader::new(s.as_bytes());\n     let mut out = StrBuf::new();\n \n@@ -247,7 +249,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n@@ -264,18 +266,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  * println!(\"{}\", url); // https://example.com/Rust (programming language)\n  * ```\n  */\n-pub fn decode(s: &str) -> ~str {\n+pub fn decode(s: &str) -> StrBuf {\n     decode_inner(s, true)\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-pub fn decode_component(s: &str) -> ~str {\n+pub fn decode_component(s: &str) -> StrBuf {\n     decode_inner(s, false)\n }\n \n-fn encode_plus(s: &str) -> ~str {\n+fn encode_plus(s: &str) -> StrBuf {\n     let mut rdr = BufReader::new(s.as_bytes());\n     let mut out = StrBuf::new();\n \n@@ -294,18 +296,18 @@ fn encode_plus(s: &str) -> ~str {\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-pub fn encode_form_urlencoded(m: &HashMap<~str, Vec<~str>>) -> ~str {\n+pub fn encode_form_urlencoded(m: &HashMap<StrBuf, Vec<StrBuf>>) -> StrBuf {\n     let mut out = StrBuf::new();\n     let mut first = true;\n \n     for (key, values) in m.iter() {\n-        let key = encode_plus(*key);\n+        let key = encode_plus(key.as_slice());\n \n         for value in values.iter() {\n             if first {\n@@ -315,21 +317,23 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, Vec<~str>>) -> ~str {\n                 first = false;\n             }\n \n-            out.push_str(format!(\"{}={}\", key, encode_plus(*value)));\n+            out.push_str(format!(\"{}={}\",\n+                                 key,\n+                                 encode_plus(value.as_slice())));\n         }\n     }\n \n-    out.into_owned()\n+    out\n }\n \n /**\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n #[allow(experimental)]\n-pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n+pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<StrBuf, Vec<StrBuf>> {\n     let mut rdr = BufReader::new(s);\n-    let mut m: HashMap<~str,Vec<~str>> = HashMap::new();\n+    let mut m: HashMap<StrBuf,Vec<StrBuf>> = HashMap::new();\n     let mut key = StrBuf::new();\n     let mut value = StrBuf::new();\n     let mut parsing_key = true;\n@@ -348,8 +352,8 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n                         None => vec!(),\n                     };\n \n-                    values.push(value.into_owned());\n-                    m.insert(key.into_owned(), values);\n+                    values.push(value);\n+                    m.insert(key, values);\n                 }\n \n                 parsing_key = true;\n@@ -386,15 +390,15 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n             None => vec!(),\n         };\n \n-        values.push(value.into_owned());\n-        m.insert(key.into_owned(), values);\n+        values.push(value);\n+        m.insert(key, values);\n     }\n \n     m\n }\n \n \n-fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n+fn split_char_first(s: &str, c: char) -> (StrBuf, StrBuf) {\n     let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n@@ -413,10 +417,10 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (s.slice(0, index).to_owned(), \"\".to_owned());\n+        return (s.slice(0, index).to_strbuf(), \"\".to_strbuf());\n     } else {\n-        return (s.slice(0, index).to_owned(),\n-             s.slice(index + mat, s.len()).to_owned());\n+        return (s.slice(0, index).to_strbuf(),\n+                s.slice(index + mat, s.len()).to_strbuf());\n     }\n }\n \n@@ -434,7 +438,8 @@ fn query_from_str(rawquery: &str) -> Query {\n     if !rawquery.is_empty() {\n         for p in rawquery.split('&') {\n             let (k, v) = split_char_first(p, '=');\n-            query.push((decode_component(k), decode_component(v)));\n+            query.push((decode_component(k.as_slice()),\n+                        decode_component(v.as_slice())));\n         };\n     }\n     return query;\n@@ -446,24 +451,24 @@ fn query_from_str(rawquery: &str) -> Query {\n  * # Example\n  *\n  * ```rust\n- * let query = vec!((\"title\".to_owned(), \"The Village\".to_owned()),\n-                    (\"north\".to_owned(), \"52.91\".to_owned()),\n-                    (\"west\".to_owned(), \"4.10\".to_owned()));\n+ * let query = vec!((\"title\".to_strbuf(), \"The Village\".to_strbuf()),\n+                    (\"north\".to_strbuf(), \"52.91\".to_strbuf()),\n+                    (\"west\".to_strbuf(), \"4.10\".to_strbuf()));\n  * println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n  * ```\n  */\n #[allow(unused_must_use)]\n-pub fn query_to_str(query: &Query) -> ~str {\n+pub fn query_to_str(query: &Query) -> StrBuf {\n     use std::io::MemWriter;\n     use std::str;\n \n     let mut writer = MemWriter::new();\n     for (i, &(ref k, ref v)) in query.iter().enumerate() {\n         if i != 0 { write!(&mut writer, \"&\"); }\n-        write!(&mut writer, \"{}={}\", encode_component(*k),\n-               encode_component(*v));\n+        write!(&mut writer, \"{}={}\", encode_component(k.as_slice()),\n+               encode_component(v.as_slice()));\n     }\n-    str::from_utf8_lossy(writer.unwrap().as_slice()).into_owned()\n+    str::from_utf8_lossy(writer.unwrap().as_slice()).to_strbuf()\n }\n \n /**\n@@ -478,35 +483,36 @@ pub fn query_to_str(query: &Query) -> ~str {\n  *\n  * let scheme = match get_scheme(\"https://example.com/\") {\n  *     Ok((sch, _)) => sch,\n- *     Err(_) => \"(None)\".to_owned(),\n+ *     Err(_) => \"(None)\".to_strbuf(),\n  * };\n  * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n  * ```\n  */\n-pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n+pub fn get_scheme(rawurl: &str) -> Result<(StrBuf, StrBuf), StrBuf> {\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => continue,\n           '0' .. '9' | '+' | '-' | '.' => {\n             if i == 0 {\n-                return Err(\"url: Scheme must begin with a letter.\".to_owned());\n+                return Err(\"url: Scheme must begin with a \\\n+                            letter.\".to_strbuf());\n             }\n             continue;\n           }\n           ':' => {\n             if i == 0 {\n-                return Err(\"url: Scheme cannot be empty.\".to_owned());\n+                return Err(\"url: Scheme cannot be empty.\".to_strbuf());\n             } else {\n-                return Ok((rawurl.slice(0,i).to_owned(),\n-                                rawurl.slice(i+1,rawurl.len()).to_owned()));\n+                return Ok((rawurl.slice(0,i).to_strbuf(),\n+                           rawurl.slice(i+1,rawurl.len()).to_strbuf()));\n             }\n           }\n           _ => {\n-            return Err(\"url: Invalid character in scheme.\".to_owned());\n+            return Err(\"url: Invalid character in scheme.\".to_strbuf());\n           }\n         }\n     };\n-    return Err(\"url: Scheme must be terminated with a colon.\".to_owned());\n+    return Err(\"url: Scheme must be terminated with a colon.\".to_strbuf());\n }\n \n #[deriving(Clone, Eq)]\n@@ -518,10 +524,10 @@ enum Input {\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n-    Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n+    Result<(Option<UserInfo>, StrBuf, Option<StrBuf>, StrBuf), StrBuf> {\n     if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n-        return Ok((None, \"\".to_owned(), None, rawurl.to_str()));\n+        return Ok((None, \"\".to_strbuf(), None, rawurl.to_str().to_strbuf()));\n     }\n \n     enum State {\n@@ -538,7 +544,7 @@ fn get_authority(rawurl: &str) ->\n     let mut input = Digit; // most restricted, start here.\n \n     let mut userinfo = None;\n-    let mut host = \"\".to_owned();\n+    let mut host = \"\".to_strbuf();\n     let mut port = None;\n \n     let mut colon_count = 0;\n@@ -565,7 +571,7 @@ fn get_authority(rawurl: &str) ->\n             // separators, don't change anything\n           }\n           _ => {\n-            return Err(\"Illegal character in authority\".to_owned());\n+            return Err(\"Illegal character in authority\".to_strbuf());\n           }\n         }\n \n@@ -582,15 +588,15 @@ fn get_authority(rawurl: &str) ->\n                 // multiple colons means ipv6 address.\n                 if input == Unreserved {\n                     return Err(\n-                        \"Illegal characters in IPv6 address.\".to_owned());\n+                        \"Illegal characters in IPv6 address.\".to_strbuf());\n                 }\n                 st = Ip6Host;\n               }\n               InHost => {\n                 pos = i;\n                 if input == Unreserved {\n                     // must be port\n-                    host = rawurl.slice(begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_strbuf();\n                     st = InPort;\n                 } else {\n                     // can't be sure whether this is an ipv6 address or a port\n@@ -599,19 +605,20 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Port => {\n                 if input == Unreserved {\n-                    return Err(\"Illegal characters in authority.\".to_owned());\n+                    return Err(\"Illegal characters in \\\n+                                authority.\".to_strbuf());\n                 }\n                 st = Ip6Host;\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = rawurl.slice(begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_strbuf();\n                     pos = i;\n                     st = InPort;\n                 }\n               }\n               _ => {\n-                return Err(\"Invalid ':' in authority.\".to_owned());\n+                return Err(\"Invalid ':' in authority.\".to_strbuf());\n               }\n             }\n             input = Digit; // reset input class\n@@ -622,18 +629,18 @@ fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = rawurl.slice(begin, i).to_owned();\n+                let user = rawurl.slice(begin, i).to_strbuf();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = rawurl.slice(begin, pos).to_owned();\n-                let pass = rawurl.slice(pos+1, i).to_owned();\n+                let user = rawurl.slice(begin, pos).to_strbuf();\n+                let pass = rawurl.slice(pos+1, i).to_strbuf();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n               _ => {\n-                return Err(\"Invalid '@' in authority.\".to_owned());\n+                return Err(\"Invalid '@' in authority.\".to_strbuf());\n               }\n             }\n             begin = i+1;\n@@ -650,34 +657,34 @@ fn get_authority(rawurl: &str) ->\n     // finish up\n     match st {\n       Start => {\n-        host = rawurl.slice(begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_strbuf();\n       }\n       PassHostPort | Ip6Port => {\n         if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_owned());\n+            return Err(\"Non-digit characters in port.\".to_strbuf());\n         }\n-        host = rawurl.slice(begin, pos).to_owned();\n-        port = Some(rawurl.slice(pos+1, end).to_owned());\n+        host = rawurl.slice(begin, pos).to_strbuf();\n+        port = Some(rawurl.slice(pos+1, end).to_strbuf());\n       }\n       Ip6Host | InHost => {\n-        host = rawurl.slice(begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_strbuf();\n       }\n       InPort => {\n         if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_owned());\n+            return Err(\"Non-digit characters in port.\".to_strbuf());\n         }\n-        port = Some(rawurl.slice(pos+1, end).to_owned());\n+        port = Some(rawurl.slice(pos+1, end).to_strbuf());\n       }\n     }\n \n-    let rest = rawurl.slice(end, len).to_owned();\n+    let rest = rawurl.slice(end, len).to_strbuf();\n     return Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: &str, authority: bool) ->\n-    Result<(~str, ~str), ~str> {\n+    Result<(StrBuf, StrBuf), StrBuf> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {\n@@ -691,24 +698,24 @@ fn get_path(rawurl: &str, authority: bool) ->\n             end = i;\n             break;\n           }\n-          _ => return Err(\"Invalid character in path.\".to_owned())\n+          _ => return Err(\"Invalid character in path.\".to_strbuf())\n         }\n     }\n \n     if authority {\n         if end != 0 && !rawurl.starts_with(\"/\") {\n             return Err(\"Non-empty path must begin with\\\n-                              '/' in presence of authority.\".to_owned());\n+                              '/' in presence of authority.\".to_strbuf());\n         }\n     }\n \n     return Ok((decode_component(rawurl.slice(0, end)),\n-                    rawurl.slice(end, len).to_owned()));\n+                    rawurl.slice(end, len).to_strbuf()));\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n-    Result<(Query, Option<~str>), ~str> {\n+    Result<(Query, Option<StrBuf>), StrBuf> {\n     if !rawurl.starts_with(\"?\") {\n         if rawurl.starts_with(\"#\") {\n             let f = decode_component(rawurl.slice(\n@@ -721,8 +728,11 @@ fn get_query_fragment(rawurl: &str) ->\n     }\n     let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n     let f = if r.len() != 0 {\n-        Some(decode_component(r)) } else { None };\n-    return Ok((query_from_str(q), f));\n+        Some(decode_component(r.as_slice()))\n+    } else {\n+        None\n+    };\n+    return Ok((query_from_str(q.as_slice()), f));\n }\n \n /**\n@@ -736,43 +746,43 @@ fn get_query_fragment(rawurl: &str) ->\n  *\n  * A `Url` struct type representing the URL.\n  */\n-pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n+pub fn from_str(rawurl: &str) -> Result<Url, StrBuf> {\n     // scheme\n     let (scheme, rest) = match get_scheme(rawurl) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     // authority\n-    let (userinfo, host, port, rest) = match get_authority(rest) {\n+    let (userinfo, host, port, rest) = match get_authority(rest.as_slice()) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     // path\n-    let has_authority = if host == \"\".to_owned() { false } else { true };\n-    let (path, rest) = match get_path(rest, has_authority) {\n+    let has_authority = host.len() > 0;\n+    let (path, rest) = match get_path(rest.as_slice(), has_authority) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest) {\n+    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n \n     Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n }\n \n-pub fn path_from_str(rawpath: &str) -> Result<Path, ~str> {\n+pub fn path_from_str(rawpath: &str) -> Result<Path, StrBuf> {\n     let (path, rest) = match get_path(rawpath, false) {\n         Ok(val) => val,\n         Err(e) => return Err(e)\n     };\n \n     // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest) {\n+    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n     };\n@@ -836,8 +846,9 @@ impl fmt::Show for Url {\n         }\n \n         match self.fragment {\n-            Some(ref fragment) => write!(f.buf, \"\\\\#{}\",\n-                                         encode_component(*fragment)),\n+            Some(ref fragment) => {\n+                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+            }\n             None => Ok(()),\n         }\n     }\n@@ -852,7 +863,7 @@ impl fmt::Show for Path {\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f.buf, \"\\\\#{}\", encode_component(*fragment))\n+                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(())\n         }\n@@ -877,53 +888,53 @@ impl<S: Writer> Hash<S> for Path {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\".to_owned());\n-    assert_eq!(v, \" sweet world\".to_owned());\n+    assert_eq!(u, \"hello\".to_strbuf());\n+    assert_eq!(v, \" sweet world\".to_strbuf());\n \n     let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\".to_owned());\n-    assert_eq!(v, \"\".to_owned());\n+    assert_eq!(u, \"hello sweet world\".to_strbuf());\n+    assert_eq!(v, \"\".to_strbuf());\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"user\".to_owned(), Some(\"pass\".to_owned()))));\n-    assert_eq!(h, \"rust-lang.org\".to_owned());\n+    assert_eq!(u, Some(UserInfo::new(\"user\".to_strbuf(), Some(\"pass\".to_strbuf()))));\n+    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n     assert!(p.is_none());\n-    assert_eq!(r, \"/something\".to_owned());\n+    assert_eq!(r, \"/something\".to_strbuf());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_owned());\n-    assert_eq!(p, Some(\"8000\".to_owned()));\n-    assert_eq!(r, \"?something\".to_owned());\n+    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n+    assert_eq!(p, Some(\"8000\".to_strbuf()));\n+    assert_eq!(r, \"?something\".to_strbuf());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_owned());\n+    assert_eq!(h, \"rust-lang.org\".to_strbuf());\n     assert!(p.is_none());\n-    assert_eq!(r, \"#blah\".to_owned());\n+    assert_eq!(r, \"#blah\".to_strbuf());\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n-    assert_eq!(p, Some(\"8000\".to_owned()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n+    assert_eq!(p, Some(\"8000\".to_strbuf()));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"us\".to_owned(), Some(\"p\".to_owned()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n-    assert_eq!(p, Some(\"8000\".to_owned()));\n+    assert_eq!(u, Some(UserInfo::new(\"us\".to_strbuf(), Some(\"p\".to_strbuf()))));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_strbuf());\n+    assert_eq!(p, Some(\"8000\".to_strbuf()));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -935,22 +946,22 @@ fn test_get_authority() {\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\".to_owned());\n+    assert_eq!(h, \"\".to_strbuf());\n     let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\".to_owned());\n+    assert_eq!(h, \"\".to_strbuf());\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert_eq!(p, \"/something+ orother\".to_owned());\n-    assert_eq!(r, \"\".to_owned());\n+    assert_eq!(p, \"/something+ orother\".to_strbuf());\n+    assert_eq!(r, \"\".to_strbuf());\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert_eq!(p, \"test@email.com\".to_owned());\n-    assert_eq!(r, \"#fragment\".to_owned());\n+    assert_eq!(p, \"test@email.com\".to_strbuf());\n+    assert_eq!(r, \"#fragment\".to_strbuf());\n     let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n-    assert_eq!(p, \"/gen/:addr=\".to_owned());\n-    assert_eq!(r, \"?q=v\".to_owned());\n+    assert_eq!(p, \"/gen/:addr=\".to_strbuf());\n+    assert_eq!(r, \"?q=v\".to_strbuf());\n \n     //failure cases\n     assert!(get_path(\"something?q\", true).is_err());\n@@ -966,87 +977,88 @@ mod tests {\n \n     #[test]\n     fn test_url_parse() {\n-        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\".to_owned();\n+        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert_eq!(&u.scheme, &\"http\".to_owned());\n-        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_owned(), Some(\"pass\".to_owned()))));\n-        assert_eq!(&u.host, &\"rust-lang.org\".to_owned());\n-        assert_eq!(&u.port, &Some(\"8080\".to_owned()));\n-        assert_eq!(&u.path, &\"/doc/~u\".to_owned());\n-        assert_eq!(&u.query, &vec!((\"s\".to_owned(), \"v\".to_owned())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_owned()));\n+        assert_eq!(&u.scheme, &\"http\".to_strbuf());\n+        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_strbuf(), Some(\"pass\".to_strbuf()))));\n+        assert_eq!(&u.host, &\"rust-lang.org\".to_strbuf());\n+        assert_eq!(&u.port, &Some(\"8080\".to_strbuf()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_strbuf());\n+        assert_eq!(&u.query, &vec!((\"s\".to_strbuf(), \"v\".to_strbuf())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_path_parse() {\n-        let path = \"/doc/~u?s=v#something\".to_owned();\n+        let path = \"/doc/~u?s=v#something\";\n \n         let up = path_from_str(path);\n         let u = up.unwrap();\n-        assert_eq!(&u.path, &\"/doc/~u\".to_owned());\n-        assert_eq!(&u.query, &vec!((\"s\".to_owned(), \"v\".to_owned())));\n-        assert_eq!(&u.fragment, &Some(\"something\".to_owned()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_strbuf());\n+        assert_eq!(&u.query, &vec!((\"s\".to_strbuf(), \"v\".to_strbuf())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_url_parse_host_slash() {\n-        let urlstr = \"http://0.42.42.42/\".to_owned();\n+        let urlstr = \"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.host == \"0.42.42.42\".to_owned());\n-        assert!(url.path == \"/\".to_owned());\n+        assert!(url.host == \"0.42.42.42\".to_strbuf());\n+        assert!(url.path == \"/\".to_strbuf());\n     }\n \n     #[test]\n     fn test_path_parse_host_slash() {\n-        let pathstr = \"/\".to_owned();\n+        let pathstr = \"/\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/\".to_owned());\n+        assert!(path.path == \"/\".to_strbuf());\n     }\n \n     #[test]\n     fn test_url_host_with_port() {\n-        let urlstr = \"scheme://host:1234\".to_owned();\n+        let urlstr = \"scheme://host:1234\";\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_owned());\n-        assert_eq!(&url.host, &\"host\".to_owned());\n-        assert_eq!(&url.port, &Some(\"1234\".to_owned()));\n-        assert_eq!(&url.path, &\"\".to_owned()); // is empty path really correct? Other tests think so\n-        let urlstr = \"scheme://host:1234/\".to_owned();\n+        assert_eq!(&url.scheme, &\"scheme\".to_strbuf());\n+        assert_eq!(&url.host, &\"host\".to_strbuf());\n+        assert_eq!(&url.port, &Some(\"1234\".to_strbuf()));\n+        // is empty path really correct? Other tests think so\n+        assert_eq!(&url.path, &\"\".to_strbuf());\n+        let urlstr = \"scheme://host:1234/\";\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &\"scheme\".to_owned());\n-        assert_eq!(&url.host, &\"host\".to_owned());\n-        assert_eq!(&url.port, &Some(\"1234\".to_owned()));\n-        assert_eq!(&url.path, &\"/\".to_owned());\n+        assert_eq!(&url.scheme, &\"scheme\".to_strbuf());\n+        assert_eq!(&url.host, &\"host\".to_strbuf());\n+        assert_eq!(&url.port, &Some(\"1234\".to_strbuf()));\n+        assert_eq!(&url.path, &\"/\".to_strbuf());\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n-        let urlstr = \"http://dotcom.com/file_name.html\".to_owned();\n+        let urlstr = \"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file_name.html\".to_owned());\n+        assert!(url.path == \"/file_name.html\".to_strbuf());\n     }\n \n     #[test]\n     fn test_path_with_underscores() {\n-        let pathstr = \"/file_name.html\".to_owned();\n+        let pathstr = \"/file_name.html\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file_name.html\".to_owned());\n+        assert!(path.path == \"/file_name.html\".to_strbuf());\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n-        let urlstr = \"http://dotcom.com/file-name.html\".to_owned();\n+        let urlstr = \"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == \"/file-name.html\".to_owned());\n+        assert!(url.path == \"/file-name.html\".to_strbuf());\n     }\n \n     #[test]\n     fn test_path_with_dashes() {\n-        let pathstr = \"/file-name.html\".to_owned();\n+        let pathstr = \"/file-name.html\";\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == \"/file-name.html\".to_owned());\n+        assert!(path.path == \"/file-name.html\".to_strbuf());\n     }\n \n     #[test]\n@@ -1062,217 +1074,217 @@ mod tests {\n \n     #[test]\n     fn test_full_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc?s=v#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org/doc?s=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org/doc#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?#something\".to_owned();\n-        let should_be = \"http://user:pass@rust-lang.org/doc#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), should_be);\n+        let url = \"http://user:pass@rust-lang.org/doc?#something\";\n+        let should_be = \"http://user:pass@rust-lang.org/doc#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), should_be);\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?q=v\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org/doc?q=v\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org/doc\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_with_port_parse_and_format() {\n-        let url = \"http://rust-lang.org:80/doc\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org:80/doc\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org?q=v#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://user:pass@rust-lang.org?q=v#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org#something\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"http://rust-lang.org#something\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_url_component_encoding() {\n-        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\".to_owned();\n+        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n-        assert!(u.path == \"/doc uments\".to_owned());\n-        assert!(u.query == vec!((\"ba%d \".to_owned(), \"#&+\".to_owned())));\n+        assert!(u.path == \"/doc uments\".to_strbuf());\n+        assert!(u.query == vec!((\"ba%d \".to_strbuf(), \"#&+\".to_strbuf())));\n     }\n \n     #[test]\n     fn test_path_component_encoding() {\n-        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\".to_owned();\n+        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n         let p = path_from_str(path).unwrap();\n-        assert!(p.path == \"/doc uments\".to_owned());\n-        assert!(p.query == vec!((\"ba%d \".to_owned(), \"#&+\".to_owned())));\n+        assert!(p.path == \"/doc uments\".to_strbuf());\n+        assert!(p.query == vec!((\"ba%d \".to_strbuf(), \"#&+\".to_strbuf())));\n     }\n \n     #[test]\n     fn test_url_without_authority() {\n-        let url = \"mailto:test@email.com\".to_owned();\n-        assert_eq!(from_str(url).unwrap().to_str(), url);\n+        let url = \"mailto:test@email.com\";\n+        assert_eq!(from_str(url).unwrap().to_str().as_slice(), url);\n     }\n \n     #[test]\n     fn test_encode() {\n-        assert_eq!(encode(\"\"), \"\".to_owned());\n-        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_owned());\n-        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_owned());\n-        assert_eq!(encode(\" \"), \"%20\".to_owned());\n-        assert_eq!(encode(\"!\"), \"!\".to_owned());\n-        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_owned());\n-        assert_eq!(encode(\"#\"), \"#\".to_owned());\n-        assert_eq!(encode(\"$\"), \"$\".to_owned());\n-        assert_eq!(encode(\"%\"), \"%25\".to_owned());\n-        assert_eq!(encode(\"&\"), \"&\".to_owned());\n-        assert_eq!(encode(\"'\"), \"%27\".to_owned());\n-        assert_eq!(encode(\"(\"), \"(\".to_owned());\n-        assert_eq!(encode(\")\"), \")\".to_owned());\n-        assert_eq!(encode(\"*\"), \"*\".to_owned());\n-        assert_eq!(encode(\"+\"), \"+\".to_owned());\n-        assert_eq!(encode(\",\"), \",\".to_owned());\n-        assert_eq!(encode(\"/\"), \"/\".to_owned());\n-        assert_eq!(encode(\":\"), \":\".to_owned());\n-        assert_eq!(encode(\";\"), \";\".to_owned());\n-        assert_eq!(encode(\"=\"), \"=\".to_owned());\n-        assert_eq!(encode(\"?\"), \"?\".to_owned());\n-        assert_eq!(encode(\"@\"), \"@\".to_owned());\n-        assert_eq!(encode(\"[\"), \"[\".to_owned());\n-        assert_eq!(encode(\"]\"), \"]\".to_owned());\n+        assert_eq!(encode(\"\"), \"\".to_strbuf());\n+        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_strbuf());\n+        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_strbuf());\n+        assert_eq!(encode(\" \"), \"%20\".to_strbuf());\n+        assert_eq!(encode(\"!\"), \"!\".to_strbuf());\n+        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_strbuf());\n+        assert_eq!(encode(\"#\"), \"#\".to_strbuf());\n+        assert_eq!(encode(\"$\"), \"$\".to_strbuf());\n+        assert_eq!(encode(\"%\"), \"%25\".to_strbuf());\n+        assert_eq!(encode(\"&\"), \"&\".to_strbuf());\n+        assert_eq!(encode(\"'\"), \"%27\".to_strbuf());\n+        assert_eq!(encode(\"(\"), \"(\".to_strbuf());\n+        assert_eq!(encode(\")\"), \")\".to_strbuf());\n+        assert_eq!(encode(\"*\"), \"*\".to_strbuf());\n+        assert_eq!(encode(\"+\"), \"+\".to_strbuf());\n+        assert_eq!(encode(\",\"), \",\".to_strbuf());\n+        assert_eq!(encode(\"/\"), \"/\".to_strbuf());\n+        assert_eq!(encode(\":\"), \":\".to_strbuf());\n+        assert_eq!(encode(\";\"), \";\".to_strbuf());\n+        assert_eq!(encode(\"=\"), \"=\".to_strbuf());\n+        assert_eq!(encode(\"?\"), \"?\".to_strbuf());\n+        assert_eq!(encode(\"@\"), \"@\".to_strbuf());\n+        assert_eq!(encode(\"[\"), \"[\".to_strbuf());\n+        assert_eq!(encode(\"]\"), \"]\".to_strbuf());\n     }\n \n     #[test]\n     fn test_encode_component() {\n-        assert_eq!(encode_component(\"\"), \"\".to_owned());\n+        assert_eq!(encode_component(\"\"), \"\".to_strbuf());\n         assert!(encode_component(\"http://example.com\") ==\n-            \"http%3A%2F%2Fexample.com\".to_owned());\n+            \"http%3A%2F%2Fexample.com\".to_strbuf());\n         assert!(encode_component(\"foo bar% baz\") ==\n-            \"foo%20bar%25%20baz\".to_owned());\n-        assert_eq!(encode_component(\" \"), \"%20\".to_owned());\n-        assert_eq!(encode_component(\"!\"), \"%21\".to_owned());\n-        assert_eq!(encode_component(\"#\"), \"%23\".to_owned());\n-        assert_eq!(encode_component(\"$\"), \"%24\".to_owned());\n-        assert_eq!(encode_component(\"%\"), \"%25\".to_owned());\n-        assert_eq!(encode_component(\"&\"), \"%26\".to_owned());\n-        assert_eq!(encode_component(\"'\"), \"%27\".to_owned());\n-        assert_eq!(encode_component(\"(\"), \"%28\".to_owned());\n-        assert_eq!(encode_component(\")\"), \"%29\".to_owned());\n-        assert_eq!(encode_component(\"*\"), \"%2A\".to_owned());\n-        assert_eq!(encode_component(\"+\"), \"%2B\".to_owned());\n-        assert_eq!(encode_component(\",\"), \"%2C\".to_owned());\n-        assert_eq!(encode_component(\"/\"), \"%2F\".to_owned());\n-        assert_eq!(encode_component(\":\"), \"%3A\".to_owned());\n-        assert_eq!(encode_component(\";\"), \"%3B\".to_owned());\n-        assert_eq!(encode_component(\"=\"), \"%3D\".to_owned());\n-        assert_eq!(encode_component(\"?\"), \"%3F\".to_owned());\n-        assert_eq!(encode_component(\"@\"), \"%40\".to_owned());\n-        assert_eq!(encode_component(\"[\"), \"%5B\".to_owned());\n-        assert_eq!(encode_component(\"]\"), \"%5D\".to_owned());\n+            \"foo%20bar%25%20baz\".to_strbuf());\n+        assert_eq!(encode_component(\" \"), \"%20\".to_strbuf());\n+        assert_eq!(encode_component(\"!\"), \"%21\".to_strbuf());\n+        assert_eq!(encode_component(\"#\"), \"%23\".to_strbuf());\n+        assert_eq!(encode_component(\"$\"), \"%24\".to_strbuf());\n+        assert_eq!(encode_component(\"%\"), \"%25\".to_strbuf());\n+        assert_eq!(encode_component(\"&\"), \"%26\".to_strbuf());\n+        assert_eq!(encode_component(\"'\"), \"%27\".to_strbuf());\n+        assert_eq!(encode_component(\"(\"), \"%28\".to_strbuf());\n+        assert_eq!(encode_component(\")\"), \"%29\".to_strbuf());\n+        assert_eq!(encode_component(\"*\"), \"%2A\".to_strbuf());\n+        assert_eq!(encode_component(\"+\"), \"%2B\".to_strbuf());\n+        assert_eq!(encode_component(\",\"), \"%2C\".to_strbuf());\n+        assert_eq!(encode_component(\"/\"), \"%2F\".to_strbuf());\n+        assert_eq!(encode_component(\":\"), \"%3A\".to_strbuf());\n+        assert_eq!(encode_component(\";\"), \"%3B\".to_strbuf());\n+        assert_eq!(encode_component(\"=\"), \"%3D\".to_strbuf());\n+        assert_eq!(encode_component(\"?\"), \"%3F\".to_strbuf());\n+        assert_eq!(encode_component(\"@\"), \"%40\".to_strbuf());\n+        assert_eq!(encode_component(\"[\"), \"%5B\".to_strbuf());\n+        assert_eq!(encode_component(\"]\"), \"%5D\".to_strbuf());\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert_eq!(decode(\"\"), \"\".to_owned());\n-        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_owned());\n-        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_owned());\n-        assert_eq!(decode(\"%20\"), \" \".to_owned());\n-        assert_eq!(decode(\"%21\"), \"%21\".to_owned());\n-        assert_eq!(decode(\"%22\"), \"%22\".to_owned());\n-        assert_eq!(decode(\"%23\"), \"%23\".to_owned());\n-        assert_eq!(decode(\"%24\"), \"%24\".to_owned());\n-        assert_eq!(decode(\"%25\"), \"%\".to_owned());\n-        assert_eq!(decode(\"%26\"), \"%26\".to_owned());\n-        assert_eq!(decode(\"%27\"), \"'\".to_owned());\n-        assert_eq!(decode(\"%28\"), \"%28\".to_owned());\n-        assert_eq!(decode(\"%29\"), \"%29\".to_owned());\n-        assert_eq!(decode(\"%2A\"), \"%2A\".to_owned());\n-        assert_eq!(decode(\"%2B\"), \"%2B\".to_owned());\n-        assert_eq!(decode(\"%2C\"), \"%2C\".to_owned());\n-        assert_eq!(decode(\"%2F\"), \"%2F\".to_owned());\n-        assert_eq!(decode(\"%3A\"), \"%3A\".to_owned());\n-        assert_eq!(decode(\"%3B\"), \"%3B\".to_owned());\n-        assert_eq!(decode(\"%3D\"), \"%3D\".to_owned());\n-        assert_eq!(decode(\"%3F\"), \"%3F\".to_owned());\n-        assert_eq!(decode(\"%40\"), \"%40\".to_owned());\n-        assert_eq!(decode(\"%5B\"), \"%5B\".to_owned());\n-        assert_eq!(decode(\"%5D\"), \"%5D\".to_owned());\n+        assert_eq!(decode(\"\"), \"\".to_strbuf());\n+        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_strbuf());\n+        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_strbuf());\n+        assert_eq!(decode(\"%20\"), \" \".to_strbuf());\n+        assert_eq!(decode(\"%21\"), \"%21\".to_strbuf());\n+        assert_eq!(decode(\"%22\"), \"%22\".to_strbuf());\n+        assert_eq!(decode(\"%23\"), \"%23\".to_strbuf());\n+        assert_eq!(decode(\"%24\"), \"%24\".to_strbuf());\n+        assert_eq!(decode(\"%25\"), \"%\".to_strbuf());\n+        assert_eq!(decode(\"%26\"), \"%26\".to_strbuf());\n+        assert_eq!(decode(\"%27\"), \"'\".to_strbuf());\n+        assert_eq!(decode(\"%28\"), \"%28\".to_strbuf());\n+        assert_eq!(decode(\"%29\"), \"%29\".to_strbuf());\n+        assert_eq!(decode(\"%2A\"), \"%2A\".to_strbuf());\n+        assert_eq!(decode(\"%2B\"), \"%2B\".to_strbuf());\n+        assert_eq!(decode(\"%2C\"), \"%2C\".to_strbuf());\n+        assert_eq!(decode(\"%2F\"), \"%2F\".to_strbuf());\n+        assert_eq!(decode(\"%3A\"), \"%3A\".to_strbuf());\n+        assert_eq!(decode(\"%3B\"), \"%3B\".to_strbuf());\n+        assert_eq!(decode(\"%3D\"), \"%3D\".to_strbuf());\n+        assert_eq!(decode(\"%3F\"), \"%3F\".to_strbuf());\n+        assert_eq!(decode(\"%40\"), \"%40\".to_strbuf());\n+        assert_eq!(decode(\"%5B\"), \"%5B\".to_strbuf());\n+        assert_eq!(decode(\"%5D\"), \"%5D\".to_strbuf());\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert_eq!(decode_component(\"\"), \"\".to_owned());\n-        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_owned());\n-        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_owned());\n-        assert_eq!(decode_component(\"%20\"), \" \".to_owned());\n-        assert_eq!(decode_component(\"%21\"), \"!\".to_owned());\n-        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_owned());\n-        assert_eq!(decode_component(\"%23\"), \"#\".to_owned());\n-        assert_eq!(decode_component(\"%24\"), \"$\".to_owned());\n-        assert_eq!(decode_component(\"%25\"), \"%\".to_owned());\n-        assert_eq!(decode_component(\"%26\"), \"&\".to_owned());\n-        assert_eq!(decode_component(\"%27\"), \"'\".to_owned());\n-        assert_eq!(decode_component(\"%28\"), \"(\".to_owned());\n-        assert_eq!(decode_component(\"%29\"), \")\".to_owned());\n-        assert_eq!(decode_component(\"%2A\"), \"*\".to_owned());\n-        assert_eq!(decode_component(\"%2B\"), \"+\".to_owned());\n-        assert_eq!(decode_component(\"%2C\"), \",\".to_owned());\n-        assert_eq!(decode_component(\"%2F\"), \"/\".to_owned());\n-        assert_eq!(decode_component(\"%3A\"), \":\".to_owned());\n-        assert_eq!(decode_component(\"%3B\"), \";\".to_owned());\n-        assert_eq!(decode_component(\"%3D\"), \"=\".to_owned());\n-        assert_eq!(decode_component(\"%3F\"), \"?\".to_owned());\n-        assert_eq!(decode_component(\"%40\"), \"@\".to_owned());\n-        assert_eq!(decode_component(\"%5B\"), \"[\".to_owned());\n-        assert_eq!(decode_component(\"%5D\"), \"]\".to_owned());\n+        assert_eq!(decode_component(\"\"), \"\".to_strbuf());\n+        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_strbuf());\n+        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_strbuf());\n+        assert_eq!(decode_component(\"%20\"), \" \".to_strbuf());\n+        assert_eq!(decode_component(\"%21\"), \"!\".to_strbuf());\n+        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_strbuf());\n+        assert_eq!(decode_component(\"%23\"), \"#\".to_strbuf());\n+        assert_eq!(decode_component(\"%24\"), \"$\".to_strbuf());\n+        assert_eq!(decode_component(\"%25\"), \"%\".to_strbuf());\n+        assert_eq!(decode_component(\"%26\"), \"&\".to_strbuf());\n+        assert_eq!(decode_component(\"%27\"), \"'\".to_strbuf());\n+        assert_eq!(decode_component(\"%28\"), \"(\".to_strbuf());\n+        assert_eq!(decode_component(\"%29\"), \")\".to_strbuf());\n+        assert_eq!(decode_component(\"%2A\"), \"*\".to_strbuf());\n+        assert_eq!(decode_component(\"%2B\"), \"+\".to_strbuf());\n+        assert_eq!(decode_component(\"%2C\"), \",\".to_strbuf());\n+        assert_eq!(decode_component(\"%2F\"), \"/\".to_strbuf());\n+        assert_eq!(decode_component(\"%3A\"), \":\".to_strbuf());\n+        assert_eq!(decode_component(\"%3B\"), \";\".to_strbuf());\n+        assert_eq!(decode_component(\"%3D\"), \"=\".to_strbuf());\n+        assert_eq!(decode_component(\"%3F\"), \"?\".to_strbuf());\n+        assert_eq!(decode_component(\"%40\"), \"@\".to_strbuf());\n+        assert_eq!(decode_component(\"%5B\"), \"[\".to_strbuf());\n+        assert_eq!(decode_component(\"%5D\"), \"]\".to_strbuf());\n     }\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_owned());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_strbuf());\n \n-        m.insert(\"\".to_owned(), vec!());\n-        m.insert(\"foo\".to_owned(), vec!());\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_owned());\n+        m.insert(\"\".to_strbuf(), vec!());\n+        m.insert(\"foo\".to_strbuf(), vec!());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_strbuf());\n \n         let mut m = HashMap::new();\n-        m.insert(\"foo\".to_owned(), vec!(\"bar\".to_owned(), \"123\".to_owned()));\n-        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_owned());\n+        m.insert(\"foo\".to_strbuf(), vec!(\"bar\".to_strbuf(), \"123\".to_strbuf()));\n+        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_strbuf());\n \n         let mut m = HashMap::new();\n-        m.insert(\"foo bar\".to_owned(), vec!(\"abc\".to_owned(), \"12 = 34\".to_owned()));\n+        m.insert(\"foo bar\".to_strbuf(), vec!(\"abc\".to_strbuf(), \"12 = 34\".to_strbuf()));\n         assert!(encode_form_urlencoded(&m) ==\n-            \"foo+bar=abc&foo+bar=12+%3D+34\".to_owned());\n+            \"foo+bar=abc&foo+bar=12+%3D+34\".to_strbuf());\n     }\n \n     #[test]\n@@ -1282,7 +1294,8 @@ mod tests {\n         let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n         let form = decode_form_urlencoded(s);\n         assert_eq!(form.len(), 2);\n-        assert_eq!(form.get(&\"a\".to_owned()), &vec!(\"1\".to_owned()));\n-        assert_eq!(form.get(&\"foo bar\".to_owned()), &vec!(\"abc\".to_owned(), \"12 = 34\".to_owned()));\n+        assert_eq!(form.get(&\"a\".to_strbuf()), &vec!(\"1\".to_strbuf()));\n+        assert_eq!(form.get(&\"foo bar\".to_strbuf()),\n+                   &vec!(\"abc\".to_strbuf(), \"12 = 34\".to_strbuf()));\n     }\n }"}]}