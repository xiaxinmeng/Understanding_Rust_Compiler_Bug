{"sha": "a0617eae68135b48a36e3fdf978cc6f951f92b6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNjE3ZWFlNjgxMzViNDhhMzZlM2ZkZjk3OGNjNmY5NTFmOTJiNmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-30T01:51:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-30T01:51:56Z"}, "message": "librustc: Eliminate most expressions of the form `a.b()` that are not method calls. rs=refactoring", "tree": {"sha": "e86ef30960a405e17e7cda1f802e567b187d2255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e86ef30960a405e17e7cda1f802e567b187d2255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0617eae68135b48a36e3fdf978cc6f951f92b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0617eae68135b48a36e3fdf978cc6f951f92b6e", "html_url": "https://github.com/rust-lang/rust/commit/a0617eae68135b48a36e3fdf978cc6f951f92b6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0617eae68135b48a36e3fdf978cc6f951f92b6e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38d7f65388fabf383d3e3a4e4c3a56403f57542", "url": "https://api.github.com/repos/rust-lang/rust/commits/b38d7f65388fabf383d3e3a4e4c3a56403f57542", "html_url": "https://github.com/rust-lang/rust/commit/b38d7f65388fabf383d3e3a4e4c3a56403f57542"}], "stats": {"total": 572, "additions": 296, "deletions": 276}, "files": [{"sha": "8497ac7e5655ab00d7d7427f47a642516c3d4acf", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -414,7 +414,7 @@ impl TaskBuilder {\n             mut notify_chan: move notify_chan,\n             sched: x.opts.sched\n         };\n-        spawn::spawn_raw(move opts, x.gen_body(move f));\n+        spawn::spawn_raw(move opts, (x.gen_body)(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A: Send>(arg: A, f: fn~(v: A)) {"}, {"sha": "2914eec61656c1a1305e7bf7bea28d0d905cac59", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -610,15 +610,15 @@ fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n                                         flav: ~str) -> ~str {\n     return mangle(ccx.sess,\n-                  vec::append_one(path, path_name(ccx.names(flav))));\n+                  vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n fn mangle_internal_name_by_path(ccx: @crate_ctxt, path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: ~str) -> ~str {\n-    return fmt!(\"%s_%u\", flav, ccx.names(flav).repr);\n+    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n \n // If the user wants an exe generated we need to invoke"}, {"sha": "df44083361e3e3c0389afaded3df87ae8d250a41", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -126,25 +126,25 @@ fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n }\n \n fn item_in_cfg(cx: ctxt, item: @ast::item) -> bool {\n-    return cx.in_cfg(item.attrs);\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn foreign_item_in_cfg(cx: ctxt, item: @ast::foreign_item) -> bool {\n-    return cx.in_cfg(item.attrs);\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn view_item_in_cfg(cx: ctxt, item: @ast::view_item) -> bool {\n-    return cx.in_cfg(item.attrs);\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn method_in_cfg(cx: ctxt, meth: @ast::method) -> bool {\n-    return cx.in_cfg(meth.attrs);\n+    return (cx.in_cfg)(meth.attrs);\n }\n \n fn trait_method_in_cfg(cx: ctxt, meth: &ast::trait_method) -> bool {\n     match *meth {\n-        ast::required(ref meth) => cx.in_cfg(meth.attrs),\n-        ast::provided(@ref meth) => cx.in_cfg(meth.attrs)\n+        ast::required(ref meth) => (cx.in_cfg)(meth.attrs),\n+        ast::provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n     }\n }\n "}, {"sha": "61a1615185ec818fdf5954d0de98e52d31b05c37", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -474,7 +474,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n            Some(it) => {\n-             ecx.encode_inlined_item(ecx, ebml_w, path, it);\n+             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n            }\n            None => {\n              encode_symbol(ecx, ebml_w, id);\n@@ -503,7 +503,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n     encode_self_type(ebml_w, m.self_ty.node);\n     if all_tps.len() > 0u || should_inline {\n-        ecx.encode_inlined_item(\n+        (ecx.encode_inlined_item)(\n            ecx, ebml_w, impl_path,\n            ii_method(local_def(parent_id), m));\n     } else {\n@@ -581,7 +581,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n         if tps.len() > 0u || should_inline(item.attrs) {\n-            ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n@@ -623,7 +623,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n             for enum_definition.variants.each |v| {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n-            ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n             encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n             encode_region_param(ecx, ebml_w, item);\n         }\n@@ -851,8 +851,8 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == foreign_abi_rust_intrinsic {\n-            ecx.encode_inlined_item(ecx, ebml_w, path,\n-                                    ii_foreign(nitem));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path,\n+                                      ii_foreign(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }"}, {"sha": "7b5571851a5961d3e18da817d23b197528cc1cc1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -67,9 +67,9 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n                 // Do not emit node ids that map to unexported names.  Those\n                 // are not helpful.\n                 if def_id.crate != local_crate ||\n-                    cx.reachable(def_id.node) {\n+                    (cx.reachable)(def_id.node) {\n                     w.write_char('\"');\n-                    w.write_str(cx.ds(def_id));\n+                    w.write_str((cx.ds)(def_id));\n                     w.write_char('|');\n                 }\n               }\n@@ -229,14 +229,14 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_enum(def, substs) => {\n         w.write_str(&\"t[\");\n-        w.write_str(cx.ds(def));\n+        w.write_str((cx.ds)(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_trait(def, substs, vstore) => {\n         w.write_str(&\"x[\");\n-        w.write_str(cx.ds(def));\n+        w.write_str((cx.ds)(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         enc_vstore(w, cx, vstore);\n@@ -293,7 +293,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_param({idx: id, def_id: did}) => {\n         w.write_char('p');\n-        w.write_str(cx.ds(did));\n+        w.write_str((cx.ds)(did));\n         w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n@@ -309,7 +309,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_class(def, substs) => {\n           debug!(\"~~~~ %s\", ~\"a[\");\n           w.write_str(&\"a[\");\n-          let s = cx.ds(def);\n+          let s = (cx.ds)(def);\n           debug!(\"~~~~ %s\", s);\n           w.write_str(s);\n           debug!(\"~~~~ %s\", ~\"|\");"}, {"sha": "25c43019e47bb8282929b1abd6287e90bcec5807", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -189,11 +189,11 @@ fn req_loans_in_expr(ex: @ast::expr,\n       ast::expr_while(cond, body) => {\n         // during the condition, can only root for the condition\n         self.root_ub = cond.id;\n-        vt.visit_expr(cond, self, vt);\n+        (vt.visit_expr)(cond, self, vt);\n \n         // during body, can only root for the body\n         self.root_ub = body.node.id;\n-        vt.visit_block(body, self, vt);\n+        (vt.visit_block)(body, self, vt);\n       }\n \n       // see explanation attached to the `root_ub` field:"}, {"sha": "e900b13b7c5e53f24f293831530071412410f843", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -22,13 +22,13 @@ fn check_item(sess: Session, ast_map: ast_map::map,\n               it: @item, &&_is_const: bool, v: visit::vt<bool>) {\n     match it.node {\n       item_const(_, ex) => {\n-        v.visit_expr(ex, true, v);\n+        (v.visit_expr)(ex, true, v);\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(enum_definition, _) => {\n         for enum_definition.variants.each |var| {\n             do option::iter(&var.node.disr_expr) |ex| {\n-                v.visit_expr(*ex, true, v);\n+                (v.visit_expr)(*ex, true, v);\n             }\n         }\n       }\n@@ -46,10 +46,10 @@ fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      pat_lit(a) => if !is_str(a) { v.visit_expr(a, true, v); },\n+      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, true, v); },\n       pat_range(a, b) => {\n-        if !is_str(a) { v.visit_expr(a, true, v); }\n-        if !is_str(b) { v.visit_expr(b, true, v); }\n+        if !is_str(a) { (v.visit_expr)(a, true, v); }\n+        if !is_str(b) { (v.visit_expr)(b, true, v); }\n       }\n       _ => visit::visit_pat(p, false, v)\n     }\n@@ -179,7 +179,7 @@ fn check_item_recursion(sess: Session, ast_map: ast_map::map,\n         visit_expr: visit_expr,\n         .. *visit::default_visitor()\n     });\n-    visitor.visit_item(it, env, visitor);\n+    (visitor.visit_item)(it, env, visitor);\n \n     fn visit_item(it: @item, &&env: env, v: visit::vt<env>) {\n         if (*env.idstack).contains(&(it.id)) {\n@@ -197,7 +197,7 @@ fn check_item_recursion(sess: Session, ast_map: ast_map::map,\n               Some(def_const(def_id)) => {\n                 match env.ast_map.get(def_id.node) {\n                   ast_map::node_item(it, _) => {\n-                    v.visit_item(it, env, v);\n+                    (v.visit_item)(it, env, v);\n                   }\n                   _ => fail ~\"const not bound to an item\"\n                 }"}, {"sha": "6372c2c53af0766011e413266a2da898bc181b36", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -4,29 +4,31 @@ use syntax::visit;\n type ctx = {in_loop: bool, can_ret: bool};\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n-    visit::visit_crate(*crate, {in_loop: false,can_ret: true}, visit::mk_vt(@{\n+    visit::visit_crate(*crate,\n+                       {in_loop: false, can_ret: true},\n+                       visit::mk_vt(@{\n         visit_item: |i, _cx, v| {\n             visit::visit_item(i, {in_loop: false, can_ret: true}, v);\n         },\n         visit_expr: |e: @expr, cx: ctx, v: visit::vt<ctx>| {\n             match e.node {\n               expr_while(e, b) => {\n-                v.visit_expr(e, cx, v);\n-                v.visit_block(b, {in_loop: true,.. cx}, v);\n+                (v.visit_expr)(e, cx, v);\n+                (v.visit_block)(b, {in_loop: true,.. cx}, v);\n               }\n               expr_loop(b, _) => {\n-                v.visit_block(b, {in_loop: true,.. cx}, v);\n+                (v.visit_block)(b, {in_loop: true,.. cx}, v);\n               }\n               expr_fn(_, _, _, _) => {\n                 visit::visit_expr(e, {in_loop: false, can_ret: true}, v);\n               }\n               expr_fn_block(_, b, _) => {\n-                v.visit_block(b, {in_loop: false, can_ret: false}, v);\n+                (v.visit_block)(b, {in_loop: false, can_ret: false}, v);\n               }\n               expr_loop_body(@{node: expr_fn_block(_, b, _), _}) => {\n                 let proto = ty::ty_fn_proto(ty::expr_ty(tcx, e));\n                 let blk = (proto == ProtoBorrowed);\n-                v.visit_block(b, {in_loop: true, can_ret: blk}, v);\n+                (v.visit_block)(b, {in_loop: true, can_ret: blk}, v);\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {"}, {"sha": "86f2748e4c4e98a3308a897cd4c7974fb67a7d60", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -76,7 +76,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n \n     let v = visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr,\n                            .. *visit::default_visitor()});\n-    v.visit_block(blk, 1, v);\n+    (v.visit_block)(blk, 1, v);\n     return @*refs;\n }\n "}, {"sha": "86136d60d54208c695ad489ec1da9f0981a4614c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -449,7 +449,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         visit_arm: check_arm,\n         .. *visit::default_visitor()\n     });\n-    check_vt.visit_block(body, lsets, check_vt);\n+    (check_vt.visit_block)(body, lsets, check_vt);\n     lsets.check_ret(id, sp, fk, entry_ln);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -1512,7 +1512,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n \n       expr_assign(l, r) => {\n         self.check_lvalue(l, vt);\n-        vt.visit_expr(r, self, vt);\n+        (vt.visit_expr)(r, self, vt);\n \n         visit::visit_expr(expr, self, vt);\n       }"}, {"sha": "fbbef2a3658ab421d9bb6a99e1aeb735cb404b5c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -584,11 +584,13 @@ fn determine_rp_in_fn(fk: visit::fn_kind,\n                       visitor: visit::vt<determine_rp_ctxt>) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n-            for decl.inputs.each |a| { visitor.visit_ty(a.ty, cx, visitor); }\n+            for decl.inputs.each |a| {\n+                (visitor.visit_ty)(a.ty, cx, visitor);\n+            }\n         }\n-        visitor.visit_ty(decl.output, cx, visitor);\n-        visitor.visit_ty_params(visit::tps_of_fn(fk), cx, visitor);\n-        visitor.visit_block(body, cx, visitor);\n+        (visitor.visit_ty)(decl.output, cx, visitor);\n+        (visitor.visit_ty_params)(visit::tps_of_fn(fk), cx, visitor);\n+        (visitor.visit_block)(body, cx, visitor);\n     }\n }\n \n@@ -695,7 +697,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.each |tp| {\n-                visitor.visit_ty(*tp, cx, visitor);\n+                (visitor.visit_ty)(*tp, cx, visitor);\n             }\n         }\n       }\n@@ -707,11 +709,11 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for f.decl.inputs.each |a| {\n-                    visitor.visit_ty(a.ty, cx, visitor);\n+                    (visitor.visit_ty)(a.ty, cx, visitor);\n                 }\n             }\n             visit::visit_ty_param_bounds(f.bounds, cx, visitor);\n-            visitor.visit_ty(f.decl.output, cx, visitor);\n+            (visitor.visit_ty)(f.decl.output, cx, visitor);\n         }\n       }\n \n@@ -725,10 +727,10 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n             do cx.with_ambient_variance(rv_invariant) {\n-                visitor.visit_ty(mt.ty, cx, visitor);\n+                (visitor.visit_ty)(mt.ty, cx, visitor);\n             }\n         } else {\n-            visitor.visit_ty(mt.ty, cx, visitor);\n+            (visitor.visit_ty)(mt.ty, cx, visitor);\n         }\n     }\n }"}, {"sha": "8f77e100f80e83b8236ba40bc0bdbb0968d31815", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -1039,7 +1039,7 @@ fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n-        cx.ccx.names(name)\n+        (cx.ccx.names)(name)\n     } else { special_idents::invalid };\n     let llbb: BasicBlockRef = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n@@ -2067,7 +2067,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n      None if substs.is_none() => {\n        let s = mangle_exported_name(\n            ccx,\n-           vec::append(path, ~[path_name(ccx.names(~\"dtor\"))]),\n+           vec::append(path, ~[path_name((ccx.names)(~\"dtor\"))]),\n            t);\n        ccx.item_symbols.insert(id, s);\n        s\n@@ -2081,7 +2081,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n            mangle_exported_name(\n                ccx,\n                vec::append(path,\n-                           ~[path_name(ccx.names(~\"dtor\"))]),\n+                           ~[path_name((ccx.names)(~\"dtor\"))]),\n                mono_ty)\n          }\n          None => {\n@@ -2253,7 +2253,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n                 m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n-    let pth = vec::append(*pth, ~[path_name(ccx.names(~\"meth\")),\n+    let pth = vec::append(*pth, ~[path_name((ccx.names)(~\"meth\")),\n                                   path_name(m.ident)]);\n     let llfn = register_fn_full(ccx, m.span, pth, id, mty);\n     set_inline_hint_if_appr(m.attrs, llfn);"}, {"sha": "73d6741feea795a9f37a92591360a829627502ca", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -1049,7 +1049,7 @@ fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n-        str::as_c_str(fmt!(\"str%u\", cx.names(~\"str\").repr),\n+        str::as_c_str(fmt!(\"str%u\", (cx.names)(~\"str\").repr),\n                     |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n@@ -1111,7 +1111,7 @@ fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef unsafe {\n \n fn C_shape(ccx: @crate_ctxt, bytes: ~[u8]) -> ValueRef {\n     let llshape = C_bytes_plus_null(bytes);\n-    let name = fmt!(\"shape%u\", ccx.names(~\"shape\").repr);\n+    let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n     let llglobal = str::as_c_str(name, |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });"}, {"sha": "f2bae5a8bc899603564285923c12ca1676351505", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -395,7 +395,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n                                cx.sess.str_of(\n-                                   cx.dbg_cx.get().names(~\"rec\")),\n+                                   (cx.dbg_cx.get().names)(~\"rec\")),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for fields.each |field| {\n@@ -747,10 +747,10 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn(_, decl, _, _) => {\n-            (dbg_cx.names(~\"fn\"), decl.output, expr.id)\n+            ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n           ast::expr_fn_block(decl, _, _) => {\n-            (dbg_cx.names(~\"fn\"), decl.output, expr.id)\n+            ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                                      ~\"create_function: \\"}, {"sha": "e21c2056db41b7d85945a465138942c2e7425581", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -605,7 +605,7 @@ fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n         // already correctly tagged with addrspaces.\n         return default_addrspace;\n     } else {\n-        return ccx.next_addrspace();\n+        return (ccx.next_addrspace)();\n     }\n }\n "}, {"sha": "4633310e60656c7d35e256c09d4578bc2ed856fe", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -607,7 +607,8 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n-    let vt_gvar = str::as_c_str(ccx.sess.str_of(ccx.names(~\"vtable\")), |buf| {\n+    let vt_gvar =\n+            str::as_c_str(ccx.sess.str_of((ccx.names)(~\"vtable\")), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n     });\n     llvm::LLVMSetInitializer(vt_gvar, tbl);"}, {"sha": "a05c42ee3fe0540e81f4efddb0d87ac1e7704bd8", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -125,7 +125,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let pt = vec::append(*pt,\n-                         ~[path_name(ccx.names(ccx.sess.str_of(name)))]);\n+                         ~[path_name((ccx.names)(ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n \n     let mk_lldecl = || {"}, {"sha": "7b03460bb7fc543144ea66f5220ba90b81bb698f", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -142,7 +142,7 @@ fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n           None    => { /* do nothing -- but should we fail here? */ }\n         }\n         for p.types.each |t| {\n-            v.visit_ty(*t, cx, v);\n+            (v.visit_ty)(*t, cx, v);\n         }\n       }\n       _ => visit::visit_ty(ty, cx, v)"}, {"sha": "14744c4cc9eb1fbcc564f0bf6fb2c827c2fcef03", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -297,5 +297,5 @@ fn handle_body(cx: ctx, body: blk) {\n         visit_item: |_i, _cx, _v| { },\n         ..*visit::default_visitor()\n     });\n-    v.visit_block(body, cx, v);\n+    (v.visit_block)(body, cx, v);\n }"}, {"sha": "32d7181b40d4150677fa1255a18c4feaecf2eb28", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -415,7 +415,7 @@ fn check_fn(ccx: @crate_ctxt,\n                                    visit_block: visit_block,\n                                    .. *visit::default_visitor()});\n \n-        visit.visit_block(body, (), visit);\n+        (visit.visit_block)(body, (), visit);\n     }\n }\n "}, {"sha": "b70c85474d596aec7b0aea3211fffaa4b8a94c19", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -90,7 +90,7 @@ impl @rcx {\n fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n     let v = regionck_visitor();\n-    v.visit_expr(e, @(move rcx), v);\n+    (v.visit_expr)(e, @(move rcx), v);\n     fcx.infcx().resolve_regions();\n }\n \n@@ -99,7 +99,7 @@ fn regionck_fn(fcx: @fn_ctxt,\n                blk: ast::blk) {\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n     let v = regionck_visitor();\n-    v.visit_block(blk, @(move rcx), v);\n+    (v.visit_block)(blk, @(move rcx), v);\n     fcx.infcx().resolve_regions();\n }\n \n@@ -132,7 +132,7 @@ fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n     // ref pattern, the variable is created with a suitable lower\n     // bound.\n     let e = rcx.errors_reported;\n-    v.visit_pat(l.node.pat, rcx, v);\n+    (v.visit_pat)(l.node.pat, rcx, v);\n     let def_map = rcx.fcx.ccx.tcx.def_map;\n     do pat_bindings(def_map, l.node.pat) |_bm, id, sp, _path| {\n         visit_node(id, sp, rcx);\n@@ -141,9 +141,9 @@ fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n         return; // if decl has errors, skip initializer expr\n     }\n \n-    v.visit_ty(l.node.ty, rcx, v);\n+    (v.visit_ty)(l.node.ty, rcx, v);\n     for l.node.init.each |i| {\n-        v.visit_expr(*i, rcx, v);\n+        (v.visit_expr)(*i, rcx, v);\n     }\n }\n "}, {"sha": "3ac94297191b45d744459c6227b4edfba640ded6", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -217,7 +217,7 @@ fn mk_visitor() -> visit::vt<wb_ctxt> {\n fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n-    visit.visit_expr(e, wbcx, visit);\n+    (visit.visit_expr)(e, wbcx, visit);\n     return wbcx.success;\n }\n \n@@ -227,7 +227,7 @@ fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n                            self_info: Option<self_info>) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n     let visit = mk_visitor();\n-    visit.visit_block(blk, wbcx, visit);\n+    (visit.visit_block)(blk, wbcx, visit);\n     for self_info.each |self_info| {\n         if self_info.explicit_self.node == ast::sty_static { break; }\n         resolve_type_vars_for_node(wbcx, self_info.explicit_self.span,"}, {"sha": "31ebc38c73ea4eda1d2a562ae6939640253b5162", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -31,7 +31,7 @@ fn run(\n         fold_impl: fold_impl,\n         .. *fold::default_any_fold(srv)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_crate("}, {"sha": "b44efdfaf249532d6dca3f06963c7979a34209cf", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -24,7 +24,7 @@ fn run(\n         fold_impl: fold_impl,\n         .. *fold::default_any_fold(())\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_item(fold: &fold::Fold<()>, +doc: doc::ItemDoc) -> doc::ItemDoc {"}, {"sha": "85e9aeb86f165755ece4c59ac3d988b0af13aa36", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -144,7 +144,7 @@ pub fn default_seq_fold_doc<T>(fold: &Fold<T>, +doc: doc::Doc) -> doc::Doc {\n         pages: do vec::map(doc.pages) |page| {\n             match *page {\n               doc::CratePage(doc) => {\n-                doc::CratePage(fold.fold_crate(fold, doc))\n+                doc::CratePage((fold.fold_crate)(fold, doc))\n               }\n               doc::ItemPage(doc) => {\n                 doc::ItemPage(fold_ItemTag(fold, doc))\n@@ -160,7 +160,7 @@ pub fn default_seq_fold_crate<T>(\n     +doc: doc::CrateDoc\n ) -> doc::CrateDoc {\n     {\n-        topmod: fold.fold_mod(fold, doc.topmod)\n+        topmod: (fold.fold_mod)(fold, doc.topmod)\n     }\n }\n \n@@ -177,7 +177,7 @@ pub fn default_any_fold_mod<T:Send Clone>(\n ) -> doc::ModDoc {\n     let fold_copy = fold.clone();\n     doc::ModDoc_({\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         items: par::map(doc.items, |ItemTag, move fold_copy| {\n             fold_ItemTag(&fold_copy, *ItemTag)\n         }),\n@@ -190,7 +190,7 @@ pub fn default_seq_fold_mod<T>(\n     +doc: doc::ModDoc\n ) -> doc::ModDoc {\n     doc::ModDoc_({\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         items: vec::map(doc.items, |ItemTag| {\n             fold_ItemTag(fold, *ItemTag)\n         }),\n@@ -204,7 +204,7 @@ pub fn default_par_fold_mod<T:Send Clone>(\n ) -> doc::ModDoc {\n     let fold_copy = fold.clone();\n     doc::ModDoc_({\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         items: par::map(doc.items, |ItemTag, move fold_copy| {\n             fold_ItemTag(&fold_copy, *ItemTag)\n         }),\n@@ -218,9 +218,9 @@ pub fn default_any_fold_nmod<T:Send Clone>(\n ) -> doc::NmodDoc {\n     let fold_copy = fold.clone();\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         fns: par::map(doc.fns, |FnDoc, move fold_copy| {\n-            fold_copy.fold_fn(&fold_copy, *FnDoc)\n+            (fold_copy.fold_fn)(&fold_copy, *FnDoc)\n         }),\n         .. doc\n     }\n@@ -231,9 +231,9 @@ pub fn default_seq_fold_nmod<T>(\n     +doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         fns: vec::map(doc.fns, |FnDoc| {\n-            fold.fold_fn(fold, *FnDoc)\n+            (fold.fold_fn)(fold, *FnDoc)\n         }),\n         .. doc\n     }\n@@ -245,9 +245,9 @@ pub fn default_par_fold_nmod<T:Send Clone>(\n ) -> doc::NmodDoc {\n     let fold_copy = fold.clone();\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         fns: par::map(doc.fns, |FnDoc, move fold_copy| {\n-            fold_copy.fold_fn(&fold_copy, *FnDoc)\n+            (fold_copy.fold_fn)(&fold_copy, *FnDoc)\n         }),\n         .. doc\n     }\n@@ -256,31 +256,31 @@ pub fn default_par_fold_nmod<T:Send Clone>(\n pub fn fold_ItemTag<T>(fold: &Fold<T>, +doc: doc::ItemTag) -> doc::ItemTag {\n     match doc {\n       doc::ModTag(ModDoc) => {\n-        doc::ModTag(fold.fold_mod(fold, ModDoc))\n+        doc::ModTag((fold.fold_mod)(fold, ModDoc))\n       }\n       doc::NmodTag(nModDoc) => {\n-        doc::NmodTag(fold.fold_nmod(fold, nModDoc))\n+        doc::NmodTag((fold.fold_nmod)(fold, nModDoc))\n       }\n       doc::FnTag(FnDoc) => {\n-        doc::FnTag(fold.fold_fn(fold, FnDoc))\n+        doc::FnTag((fold.fold_fn)(fold, FnDoc))\n       }\n       doc::ConstTag(ConstDoc) => {\n-        doc::ConstTag(fold.fold_const(fold, ConstDoc))\n+        doc::ConstTag((fold.fold_const)(fold, ConstDoc))\n       }\n       doc::EnumTag(EnumDoc) => {\n-        doc::EnumTag(fold.fold_enum(fold, EnumDoc))\n+        doc::EnumTag((fold.fold_enum)(fold, EnumDoc))\n       }\n       doc::TraitTag(TraitDoc) => {\n-        doc::TraitTag(fold.fold_trait(fold, TraitDoc))\n+        doc::TraitTag((fold.fold_trait)(fold, TraitDoc))\n       }\n       doc::ImplTag(ImplDoc) => {\n-        doc::ImplTag(fold.fold_impl(fold, ImplDoc))\n+        doc::ImplTag((fold.fold_impl)(fold, ImplDoc))\n       }\n       doc::TyTag(TyDoc) => {\n-        doc::TyTag(fold.fold_type(fold, TyDoc))\n+        doc::TyTag((fold.fold_type)(fold, TyDoc))\n       }\n       doc::StructTag(StructDoc) => {\n-        doc::StructTag(fold.fold_struct(fold, StructDoc))\n+        doc::StructTag((fold.fold_struct)(fold, StructDoc))\n       }\n     }\n }\n@@ -290,7 +290,7 @@ pub fn default_seq_fold_fn<T>(\n     +doc: doc::FnDoc\n ) -> doc::FnDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -300,7 +300,7 @@ pub fn default_seq_fold_const<T>(\n     +doc: doc::ConstDoc\n ) -> doc::ConstDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -310,7 +310,7 @@ pub fn default_seq_fold_enum<T>(\n     +doc: doc::EnumDoc\n ) -> doc::EnumDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -320,7 +320,7 @@ pub fn default_seq_fold_trait<T>(\n     +doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -330,7 +330,7 @@ pub fn default_seq_fold_impl<T>(\n     +doc: doc::ImplDoc\n ) -> doc::ImplDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -340,7 +340,7 @@ pub fn default_seq_fold_type<T>(\n     +doc: doc::TyDoc\n ) -> doc::TyDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -350,7 +350,7 @@ pub fn default_seq_fold_struct<T>(\n     +doc: doc::StructDoc\n ) -> doc::StructDoc {\n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }\n@@ -361,7 +361,7 @@ fn default_fold_should_produce_same_doc() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n-    let folded = fld.fold_doc(&fld, doc);\n+    let folded = (fld.fold_doc)(&fld, doc);\n     assert doc == folded;\n }\n \n@@ -371,7 +371,7 @@ fn default_fold_should_produce_same_consts() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n-    let folded = fld.fold_doc(&fld, doc);\n+    let folded = (fld.fold_doc)(&fld, doc);\n     assert doc == folded;\n }\n \n@@ -381,7 +381,7 @@ fn default_fold_should_produce_same_enums() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n-    let folded = fld.fold_doc(&fld, doc);\n+    let folded = (fld.fold_doc)(&fld, doc);\n     assert doc == folded;\n }\n \n@@ -391,6 +391,6 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());\n-    let folded = fld.fold_doc(&fld, doc);\n+    let folded = (fld.fold_doc)(&fld, doc);\n     assert doc == folded;\n }"}, {"sha": "07120440c9a29b3b9d271f660add19b4e2f7e3ed", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -21,7 +21,7 @@ fn run(\n         fold_nmod: fold_nmod,\n         .. *fold::default_any_fold(config)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_mod("}, {"sha": "0ba69a31b1eb7e00f56af37c0400eee7c4ca9925", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -38,9 +38,9 @@ fn run(\n     // Sort the items so mods come last. All mods will be\n     // output at the same header level so sorting mods last\n     // makes the headers come out nested correctly.\n-    let sorted_doc = sort_pass::mk_pass(\n+    let sorted_doc = (sort_pass::mk_pass(\n         ~\"mods last\", mods_last\n-    ).f(srv, doc);\n+    ).f)(srv, doc);\n \n     write_markdown(sorted_doc, move writer_factory);\n "}, {"sha": "307c7c2cd191d8840c6801abed4ba2584b461243", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -64,7 +64,7 @@ fn find_pages(doc: doc::Doc, page_chan: PageChan) {\n         fold_nmod: fold_nmod,\n         .. *fold::default_any_fold(NominalOp { op: page_chan })\n     });\n-    fold.fold_doc(&fold, doc);\n+    (fold.fold_doc)(&fold, doc);\n \n     comm::send(page_chan, None);\n }"}, {"sha": "0a61c4975287664829dfa911b6acdcf9ed769837", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -15,7 +15,7 @@ pub fn run_passes(\n         passno += 1;\n         log(debug, doc);\n         do time(pass.name) {\n-            pass.f(srv, doc)\n+            (pass.f)(srv, doc)\n         }\n     }\n }"}, {"sha": "41117949fa36013d07927f27985916cdc889c6a0", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -31,7 +31,7 @@ fn run(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n         fold_nmod: fold_nmod,\n         .. *fold::default_any_fold(move ctxt)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_item(fold: &fold::Fold<Ctxt>, +doc: doc::ItemDoc) -> doc::ItemDoc {\n@@ -50,7 +50,7 @@ fn fold_mod(fold: &fold::Fold<Ctxt>, +doc: doc::ModDoc) -> doc::ModDoc {\n     if !is_topmod { fold.ctxt.path.pop(); }\n \n     doc::ModDoc_({\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. *doc\n     })\n }\n@@ -61,7 +61,7 @@ fn fold_nmod(fold: &fold::Fold<Ctxt>, +doc: doc::NmodDoc) -> doc::NmodDoc {\n     fold.ctxt.path.pop();\n \n     {\n-        item: fold.fold_item(fold, doc.item),\n+        item: (fold.fold_item)(fold, doc.item),\n         .. doc\n     }\n }"}, {"sha": "f9348d881dac44dc618aad7dcef1a9568d4d7729", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -15,7 +15,7 @@ fn run(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n         fold_mod: fold_mod,\n         .. *fold::default_any_fold(srv)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_mod("}, {"sha": "2d60132b561dfacc542386e63d28417b7e243b9e", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -16,7 +16,7 @@ fn run(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n         fold_mod: fold_mod,\n         .. *fold::default_any_fold(srv)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_mod("}, {"sha": "56db1cf5730fafe99dc1aef96259540d81dc3e99", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -16,7 +16,7 @@ fn run(_srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n         fold_impl: fold_impl,\n         .. *fold::default_any_fold(())\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_item(fold: &fold::Fold<()>, +doc: doc::ItemDoc) -> doc::ItemDoc {"}, {"sha": "362842f7832767971d99f5636651e6024e12ad9c", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -27,7 +27,7 @@ fn run(\n         fold_mod: fold_mod,\n         .. *fold::default_any_fold(move lteq)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "4a090bab9baf6470151a2af6bf5853f26a7e9ca6", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -30,11 +30,11 @@ fn run(\n         fold_impl: fold_impl,\n         .. *fold::default_any_fold(move op)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn maybe_apply_op(op: NominalOp<Op>, s: Option<~str>) -> Option<~str> {\n-    s.map(|s| op.op(*s) )\n+    s.map(|s| (op.op)(*s) )\n }\n \n fn fold_item(\n@@ -56,8 +56,8 @@ fn apply_to_sections(\n     sections: ~[doc::Section]\n ) -> ~[doc::Section] {\n     par::map(sections, |section, copy op| {\n-        header: op.op(section.header),\n-        body: op.op(section.body)\n+        header: (op.op)(section.header),\n+        body: (op.op)(section.body)\n     })\n }\n "}, {"sha": "4d0ef1aefe1369a2b160322bcf5af65a5bdbd8bb", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -28,7 +28,7 @@ fn run(\n         fold_struct: fold_struct,\n         .. *fold::default_any_fold(srv)\n     });\n-    fold.fold_doc(&fold, doc)\n+    (fold.fold_doc)(&fold, doc)\n }\n \n fn fold_fn("}, {"sha": "96897790fcdba6f11702e614be256e68ea2a1889", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -1059,7 +1059,7 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     let kill_ch = (*server_data_ptr).kill_ch;\n     if (*server_data_ptr).active {\n         match status {\n-          0i32 => (*server_data_ptr).on_connect_cb(handle),\n+          0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n           _ => {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n             core::comm::send(kill_ch,"}, {"sha": "d0cd6ad54d1c7b3c3c571c48355dc335a99f2b63", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -369,8 +369,8 @@ impl inlined_item: inlined_item_utils {\n \n     fn accept<E>(e: E, v: visit::vt<E>) {\n         match self {\n-          ii_item(i) => v.visit_item(i, e, v),\n-          ii_foreign(i) => v.visit_foreign_item(i, e, v),\n+          ii_item(i) => (v.visit_item)(i, e, v),\n+          ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n           ii_dtor(dtor, _, tps, parent_id) => {\n               visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);"}, {"sha": "a8a013cb79cac8cb59d0beb0ba215bf0fca48901", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -74,11 +74,11 @@ impl codemap_t: span_handler {\n \n impl handler_t: handler {\n     fn fatal(msg: &str) -> ! {\n-        self.emit(None, msg, fatal);\n+        (self.emit)(None, msg, fatal);\n         fail;\n     }\n     fn err(msg: &str) {\n-        self.emit(None, msg, error);\n+        (self.emit)(None, msg, error);\n         self.bump_err_count();\n     }\n     fn bump_err_count() {\n@@ -98,17 +98,17 @@ impl handler_t: handler {\n         self.fatal(s);\n     }\n     fn warn(msg: &str) {\n-        self.emit(None, msg, warning);\n+        (self.emit)(None, msg, warning);\n     }\n     fn note(msg: &str) {\n-        self.emit(None, msg, note);\n+        (self.emit)(None, msg, note);\n     }\n     fn bug(msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n     fn unimpl(msg: &str) -> ! { self.bug(~\"unimplemented \" + msg); }\n     fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n-        self.emit(cmsp, msg, lvl);\n+        (self.emit)(cmsp, msg, lvl);\n     }\n }\n "}, {"sha": "c0bef1e6cde01766dff331d4d4e2a88b1b219c63", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -235,15 +235,15 @@ fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                                     given '%s'\", *extname,\n                                    *cx.parse_sess().interner.get(it.ident)));\n             }\n-            (expand.expander(cx, it.span, tts), expand.span)\n+            ((expand.expander)(cx, it.span, tts), expand.span)\n         }\n         Some(item_tt(expand)) => {\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n                                    *extname));\n             }\n-            (expand.expander(cx, it.span, it.ident, tts), expand.span)\n+            ((expand.expander)(cx, it.span, it.ident, tts), expand.span)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", *extname))"}, {"sha": "9a1f3e7f04e80970513dc43b949b547787fd40da", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -645,100 +645,100 @@ fn default_ast_fold() -> ast_fold_precursor {\n impl ast_fold_precursor: ast_fold {\n     /* naturally, a macro to write these would be nice */\n     fn fold_crate(c: crate) -> crate {\n-        let (n, s) = self.fold_crate(c.node, c.span, self as ast_fold);\n-        return {node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_crate)(c.node, c.span, self as ast_fold);\n+        return {node: n, span: (self.new_span)(s)};\n     }\n     fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n-        return @{node: self.fold_view_item(x.node, self as ast_fold),\n+        return @{node: (self.fold_view_item)(x.node, self as ast_fold),\n               attrs: vec::map(x.attrs, |a|\n                   fold_attribute_(*a, self as ast_fold)),\n               vis: x.vis,\n-              span: self.new_span(x.span)};\n+              span: (self.new_span)(x.span)};\n     }\n     fn fold_foreign_item(&&x: @foreign_item)\n         -> @foreign_item {\n-        return self.fold_foreign_item(x, self as ast_fold);\n+        return (self.fold_foreign_item)(x, self as ast_fold);\n     }\n     fn fold_item(&&i: @item) -> Option<@item> {\n-        return self.fold_item(i, self as ast_fold);\n+        return (self.fold_item)(i, self as ast_fold);\n     }\n     fn fold_struct_field(&&sf: @struct_field) -> @struct_field {\n         @{node: {kind: copy sf.node.kind,\n                  id: sf.node.id,\n                  ty: (self as ast_fold).fold_ty(sf.node.ty)},\n-          span: self.new_span(sf.span)}\n+          span: (self.new_span)(sf.span)}\n     }\n     fn fold_item_underscore(i: item_) ->\n        item_ {\n-        return self.fold_item_underscore(i, self as ast_fold);\n+        return (self.fold_item_underscore)(i, self as ast_fold);\n     }\n     fn fold_method(&&x: @method)\n         -> @method {\n-        return self.fold_method(x, self as ast_fold);\n+        return (self.fold_method)(x, self as ast_fold);\n     }\n     fn fold_block(x: blk) -> blk {\n-        let (n, s) = self.fold_block(x.node, x.span, self as ast_fold);\n-        return {node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_block)(x.node, x.span, self as ast_fold);\n+        return {node: n, span: (self.new_span)(s)};\n     }\n     fn fold_stmt(&&x: @stmt) -> @stmt {\n-        let (n, s) = self.fold_stmt(x.node, x.span, self as ast_fold);\n-        return @{node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_stmt)(x.node, x.span, self as ast_fold);\n+        return @{node: n, span: (self.new_span)(s)};\n     }\n     fn fold_arm(x: arm) -> arm {\n-        return self.fold_arm(x, self as ast_fold);\n+        return (self.fold_arm)(x, self as ast_fold);\n     }\n     fn fold_pat(&&x: @pat) -> @pat {\n-        let (n, s) =  self.fold_pat(x.node, x.span, self as ast_fold);\n-        return @{id: self.new_id(x.id),\n+        let (n, s) =  (self.fold_pat)(x.node, x.span, self as ast_fold);\n+        return @{id: (self.new_id)(x.id),\n               node: n,\n-              span: self.new_span(s)};\n+              span: (self.new_span)(s)};\n     }\n     fn fold_decl(&&x: @decl) -> @decl {\n-        let (n, s) = self.fold_decl(x.node, x.span, self as ast_fold);\n-        return @{node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_decl)(x.node, x.span, self as ast_fold);\n+        return @{node: n, span: (self.new_span)(s)};\n     }\n     fn fold_expr(&&x: @expr) -> @expr {\n-        let (n, s) = self.fold_expr(x.node, x.span, self as ast_fold);\n-        return @{id: self.new_id(x.id),\n-              callee_id: self.new_id(x.callee_id),\n+        let (n, s) = (self.fold_expr)(x.node, x.span, self as ast_fold);\n+        return @{id: (self.new_id)(x.id),\n+              callee_id: (self.new_id)(x.callee_id),\n               node: n,\n-              span: self.new_span(s)};\n+              span: (self.new_span)(s)};\n     }\n     fn fold_ty(&&x: @Ty) -> @Ty {\n-        let (n, s) = self.fold_ty(x.node, x.span, self as ast_fold);\n-        return @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_ty)(x.node, x.span, self as ast_fold);\n+        return @{id: (self.new_id)(x.id), node: n, span: (self.new_span)(s)};\n     }\n     fn fold_mod(x: _mod) -> _mod {\n-        return self.fold_mod(x, self as ast_fold);\n+        return (self.fold_mod)(x, self as ast_fold);\n     }\n     fn fold_foreign_mod(x: foreign_mod) ->\n        foreign_mod {\n-        return self.fold_foreign_mod(x, self as ast_fold);\n+        return (self.fold_foreign_mod)(x, self as ast_fold);\n     }\n     fn fold_variant(x: variant) ->\n        variant {\n-        let (n, s) = self.fold_variant(x.node, x.span, self as ast_fold);\n-        return {node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_variant)(x.node, x.span, self as ast_fold);\n+        return {node: n, span: (self.new_span)(s)};\n     }\n     fn fold_ident(&&x: ident) -> ident {\n-        return self.fold_ident(x, self as ast_fold);\n+        return (self.fold_ident)(x, self as ast_fold);\n     }\n     fn fold_path(&&x: @path) -> @path {\n-        @self.fold_path(*x, self as ast_fold)\n+        @(self.fold_path)(*x, self as ast_fold)\n     }\n     fn fold_local(&&x: @local) -> @local {\n-        let (n, s) = self.fold_local(x.node, x.span, self as ast_fold);\n-        return @{node: n, span: self.new_span(s)};\n+        let (n, s) = (self.fold_local)(x.node, x.span, self as ast_fold);\n+        return @{node: n, span: (self.new_span)(s)};\n     }\n     fn map_exprs(f: fn@(&&v: @expr) -> @expr, e: ~[@expr]) -> ~[@expr] {\n-        self.map_exprs(f, e)\n+        (self.map_exprs)(f, e)\n     }\n     fn new_id(node_id: ast::node_id) -> node_id {\n-        self.new_id(node_id)\n+        (self.new_id)(node_id)\n     }\n     fn new_span(span: span) -> span {\n-        self.new_span(span)\n+        (self.new_span)(span)\n     }\n }\n "}, {"sha": "5ad3c051c5977ec0615ada434d7d951e57bfd2b4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -453,7 +453,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n-    s.ann.pre(ann_node);\n+    (s.ann.pre)(ann_node);\n     match item.node {\n       ast::item_const(ty, expr) => {\n         head(s, visibility_qualified(item.vis, ~\"const\"));\n@@ -581,7 +581,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         fail ~\"invalid item-position syntax bit\"\n       }\n     }\n-    s.ann.post(ann_node);\n+    (s.ann.post)(ann_node);\n }\n \n fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n@@ -928,7 +928,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n     }\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n-    s.ann.pre(ann_node);\n+    (s.ann.pre)(ann_node);\n     match embedded {\n       block_block_fn => end(s),\n       block_normal => bopen(s)\n@@ -949,7 +949,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n       _ => ()\n     }\n     bclose_maybe_open(s, blk.span, indented, close_box);\n-    s.ann.post(ann_node);\n+    (s.ann.post)(ann_node);\n }\n \n fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n@@ -1055,7 +1055,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n-    s.ann.pre(ann_node);\n+    (s.ann.pre)(ann_node);\n     match expr.node {\n         ast::expr_vstore(e, v) => match v {\n             ast::expr_vstore_fixed(_) => {\n@@ -1415,7 +1415,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n           pclose(s);\n       }\n     }\n-    s.ann.post(ann_node);\n+    (s.ann.post)(ann_node);\n     end(s);\n }\n \n@@ -1500,7 +1500,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n fn print_pat(s: ps, &&pat: @ast::pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n-    s.ann.pre(ann_node);\n+    (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n@@ -1590,7 +1590,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         print_expr(s, end);\n       }\n     }\n-    s.ann.post(ann_node);\n+    (s.ann.post)(ann_node);\n }\n \n // Returns whether it printed anything"}, {"sha": "fbb1bc9117211d0a3edc33a3280d8f673c5df8c2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 117, "deletions": 102, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0617eae68135b48a36e3fdf978cc6f951f92b6e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a0617eae68135b48a36e3fdf978cc6f951f92b6e", "patch": "@@ -90,66 +90,69 @@ fn default_visitor<E>() -> visitor<E> {\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n-    v.visit_mod(c.node.module, c.span, crate_node_id, e, v);\n+    (v.visit_mod)(c.node.module, c.span, crate_node_id, e, v);\n }\n \n fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n-    for m.view_items.each |vi| { v.visit_view_item(*vi, e, v); }\n-    for m.items.each |i| { v.visit_item(*i, e, v); }\n+    for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n+    for m.items.each |i| { (v.visit_item)(*i, e, v); }\n }\n \n fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n \n fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n-    v.visit_pat(loc.node.pat, e, v);\n-    v.visit_ty(loc.node.ty, e, v);\n+    (v.visit_pat)(loc.node.pat, e, v);\n+    (v.visit_ty)(loc.node.ty, e, v);\n     match loc.node.init {\n       None => (),\n-      Some(ex) => v.visit_expr(ex, e, v)\n+      Some(ex) => (v.visit_expr)(ex, e, v)\n     }\n }\n \n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n-      item_const(t, ex) => { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n+      item_const(t, ex) => {\n+        (v.visit_ty)(t, e, v);\n+        (v.visit_expr)(ex, e, v);\n+      }\n       item_fn(decl, purity, tp, body) => {\n-        v.visit_fn(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n+        (v.visit_fn)(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n                               /* FIXME (#2543) */ copy tp,\n                               purity), decl, body,\n                    i.span, i.id, e, v);\n       }\n-      item_mod(m) => v.visit_mod(m, i.span, i.id, e, v),\n+      item_mod(m) => (v.visit_mod)(m, i.span, i.id, e, v),\n       item_foreign_mod(nm) => {\n-        for nm.view_items.each |vi| { v.visit_view_item(*vi, e, v); }\n-        for nm.items.each |ni| { v.visit_foreign_item(*ni, e, v); }\n+        for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n+        for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n       }\n       item_ty(t, tps) => {\n-        v.visit_ty(t, e, v);\n-        v.visit_ty_params(tps, e, v);\n+        (v.visit_ty)(t, e, v);\n+        (v.visit_ty_params)(tps, e, v);\n       }\n       item_enum(enum_definition, tps) => {\n-        v.visit_ty_params(tps, e, v);\n+        (v.visit_ty_params)(tps, e, v);\n         visit_enum_def(enum_definition, tps, e, v);\n       }\n       item_impl(tps, traits, ty, methods) => {\n-        v.visit_ty_params(tps, e, v);\n+        (v.visit_ty_params)(tps, e, v);\n         for traits.each |p| {\n             visit_path(p.path, e, v);\n         }\n-        v.visit_ty(ty, e, v);\n+        (v.visit_ty)(ty, e, v);\n         for methods.each |m| {\n             visit_method_helper(*m, e, v)\n         }\n       }\n       item_class(struct_def, tps) => {\n-        v.visit_ty_params(tps, e, v);\n-        v.visit_struct_def(struct_def, i.ident, tps, i.id, e, v);\n+        (v.visit_ty_params)(tps, e, v);\n+        (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n       }\n       item_trait(tps, traits, methods) => {\n-        v.visit_ty_params(tps, e, v);\n+        (v.visit_ty_params)(tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n         for methods.each |m| {\n-            v.visit_trait_method(*m, e, v);\n+            (v.visit_trait_method)(*m, e, v);\n         }\n       }\n       item_mac(m) => visit_mac(m, e, v)\n@@ -161,18 +164,18 @@ fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(variant_args) => {\n-                for variant_args.each |va| { v.visit_ty(va.ty, e, v); }\n+                for variant_args.each |va| { (v.visit_ty)(va.ty, e, v); }\n             }\n             struct_variant_kind(struct_def) => {\n-                v.visit_struct_def(struct_def, vr.node.name, tps,\n+                (v.visit_struct_def)(struct_def, vr.node.name, tps,\n                                    vr.node.id, e, v);\n             }\n             enum_variant_kind(enum_definition) => {\n                 visit_enum_def(enum_definition, tps, e, v);\n             }\n         }\n         // Visit the disr expr if it exists\n-        vr.node.disr_expr.iter(|ex| v.visit_expr(*ex, e, v));\n+        vr.node.disr_expr.iter(|ex| (v.visit_expr)(*ex, e, v));\n     }\n }\n \n@@ -182,21 +185,21 @@ fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n       ty_box(mt) | ty_uniq(mt) |\n       ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n-        v.visit_ty(mt.ty, e, v);\n+        (v.visit_ty)(mt.ty, e, v);\n       }\n       ty_rec(flds) => for flds.each |f| {\n-        v.visit_ty(f.node.mt.ty, e, v);\n+        (v.visit_ty)(f.node.mt.ty, e, v);\n       },\n       ty_tup(ts) => for ts.each |tt| {\n-        v.visit_ty(*tt, e, v);\n+        (v.visit_ty)(*tt, e, v);\n       },\n       ty_fn(f) => {\n-        for f.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n+        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n         visit_ty_param_bounds(f.bounds, e, v);\n-        v.visit_ty(f.decl.output, e, v);\n+        (v.visit_ty)(f.decl.output, e, v);\n       }\n       ty_path(p, _) => visit_path(p, e, v),\n-      ty_fixed_length_vec(mt, _) => v.visit_ty(mt.ty, e, v),\n+      ty_fixed_length_vec(mt, _) => (v.visit_ty)(mt.ty, e, v),\n       ty_nil |\n       ty_bot |\n       ty_mac(_) |\n@@ -205,55 +208,58 @@ fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n }\n \n fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n-    for p.types.each |tp| { v.visit_ty(*tp, e, v); }\n+    for p.types.each |tp| { (v.visit_ty)(*tp, e, v); }\n }\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n       pat_enum(path, children) => {\n         visit_path(path, e, v);\n         do option::iter(&children) |children| {\n-            for children.each |child| { v.visit_pat(*child, e, v); }}\n+            for children.each |child| { (v.visit_pat)(*child, e, v); }}\n       }\n       pat_rec(fields, _) => for fields.each |f| {\n-        v.visit_pat(f.pat, e, v)\n+        (v.visit_pat)(f.pat, e, v)\n       },\n       pat_struct(path, fields, _) => {\n         visit_path(path, e, v);\n         for fields.each |f| {\n-            v.visit_pat(f.pat, e, v);\n+            (v.visit_pat)(f.pat, e, v);\n         }\n       }\n       pat_tup(elts) => for elts.each |elt| {\n-        v.visit_pat(*elt, e, v)\n+        (v.visit_pat)(*elt, e, v)\n       },\n       pat_box(inner) | pat_uniq(inner) | pat_region(inner) =>\n-          v.visit_pat(inner, e, v),\n+          (v.visit_pat)(inner, e, v),\n       pat_ident(_, path, inner) => {\n           visit_path(path, e, v);\n-          do option::iter(&inner) |subpat| { v.visit_pat(*subpat, e, v)};\n+          do option::iter(&inner) |subpat| { (v.visit_pat)(*subpat, e, v)};\n+      }\n+      pat_lit(ex) => (v.visit_expr)(ex, e, v),\n+      pat_range(e1, e2) => {\n+        (v.visit_expr)(e1, e, v);\n+        (v.visit_expr)(e2, e, v);\n       }\n-      pat_lit(ex) => v.visit_expr(ex, e, v),\n-      pat_range(e1, e2) => { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }\n       pat_wild => ()\n     }\n }\n \n fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n       foreign_item_fn(fd, _, tps) => {\n-        v.visit_ty_params(tps, e, v);\n+        (v.visit_ty_params)(tps, e, v);\n         visit_fn_decl(fd, e, v);\n       }\n       foreign_item_const(t) => {\n-        v.visit_ty(t, e, v);\n+        (v.visit_ty)(t, e, v);\n       }\n     }\n }\n \n fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n     for vec::each(*bounds) |bound| {\n-        v.visit_ty(**bound, e, v)\n+        (v.visit_ty)(**bound, e, v)\n     }\n }\n \n@@ -265,25 +271,25 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n \n fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| {\n-        v.visit_pat(a.pat, e, v);\n-        v.visit_ty(a.ty, e, v);\n+        (v.visit_pat)(a.pat, e, v);\n+        (v.visit_ty)(a.ty, e, v);\n     }\n-    v.visit_ty(fd.output, e, v);\n+    (v.visit_ty)(fd.output, e, v);\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    v.visit_fn(fk_method(/* FIXME (#2543) */ copy m.ident,\n+    (v.visit_fn)(fk_method(/* FIXME (#2543) */ copy m.ident,\n                          /* FIXME (#2543) */ copy m.tps, m),\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: ~[ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n+    (v.visit_fn)(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n                        dtor.node.self_id, parent_id), ast_util::dtor_dec(),\n                dtor.node.body, dtor.span, dtor.node.id, e, v)\n \n@@ -292,30 +298,30 @@ fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: ~[ty_param],\n fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n                _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n-    v.visit_ty_params(tps_of_fn(fk), e, v);\n-    v.visit_block(body, e, v);\n+    (v.visit_ty_params)(tps_of_fn(fk), e, v);\n+    (v.visit_block)(body, e, v);\n }\n \n fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n-    for m.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n-    v.visit_ty_params(m.tps, e, v);\n-    v.visit_ty(m.decl.output, e, v);\n+    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+    (v.visit_ty_params)(m.tps, e, v);\n+    (v.visit_ty)(m.decl.output, e, v);\n }\n \n fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     match m {\n-      required(ty_m) => v.visit_ty_method(ty_m, e, v),\n+      required(ty_m) => (v.visit_ty_method)(ty_m, e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n \n fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n                        id: node_id, e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n-        v.visit_struct_field(*f, e, v);\n+        (v.visit_struct_field)(*f, e, v);\n     }\n     for sd.methods.each |m| {\n-        v.visit_struct_method(*m, e, v);\n+        (v.visit_struct_method)(*m, e, v);\n     }\n     for sd.traits.each |p| {\n         visit_path(p.path, e, v);\n@@ -326,7 +332,7 @@ fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n }\n \n fn visit_struct_field<E>(sf: @struct_field, e: E, v: vt<E>) {\n-    v.visit_ty(sf.node.ty, e, v);\n+    (v.visit_ty)(sf.node.ty, e, v);\n }\n \n fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n@@ -335,44 +341,44 @@ fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n \n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| {\n-        v.visit_view_item(*vi, e, v);\n+        (v.visit_view_item)(*vi, e, v);\n     }\n     for b.node.stmts.each |s| {\n-        v.visit_stmt(*s, e, v);\n+        (v.visit_stmt)(*s, e, v);\n     }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     match s.node {\n-      stmt_decl(d, _) => v.visit_decl(d, e, v),\n-      stmt_expr(ex, _) => v.visit_expr(ex, e, v),\n-      stmt_semi(ex, _) => v.visit_expr(ex, e, v),\n+      stmt_decl(d, _) => (v.visit_decl)(d, e, v),\n+      stmt_expr(ex, _) => (v.visit_expr)(ex, e, v),\n+      stmt_semi(ex, _) => (v.visit_expr)(ex, e, v),\n       stmt_mac(mac, _) => visit_mac(mac, e, v)\n     }\n }\n \n fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n       decl_local(locs) => for locs.each |loc| {\n-        v.visit_local(*loc, e, v)\n+        (v.visit_local)(*loc, e, v)\n       },\n-      decl_item(it) => v.visit_item(it, e, v)\n+      decl_item(it) => (v.visit_item)(it, e, v)\n     }\n }\n \n fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n-    match eo { None => (), Some(ex) => v.visit_expr(ex, e, v) }\n+    match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n }\n \n fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n-    for exprs.each |ex| { v.visit_expr(*ex, e, v); }\n+    for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     match m.node {\n       ast::mac_invoc(_, arg, _) => {\n-        option::map(&arg, |arg| v.visit_expr(*arg, e, v)); }\n+        option::map(&arg, |arg| (v.visit_expr)(*arg, e, v)); }\n       ast::mac_invoc_tt(*) => { /* no user-serviceable parts inside */ }\n       ast::mac_ellipsis => (),\n       ast::mac_aq(*) => { /* FIXME: maybe visit (Issue #2340) */ }\n@@ -382,86 +388,95 @@ fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n \n fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     match ex.node {\n-      expr_vstore(x, _) => v.visit_expr(x, e, v),\n+      expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n       expr_vec(es, _) => visit_exprs(es, e, v),\n       expr_repeat(element, count, _) => {\n-        v.visit_expr(element, e, v);\n-        v.visit_expr(count, e, v);\n+        (v.visit_expr)(element, e, v);\n+        (v.visit_expr)(count, e, v);\n       }\n       expr_rec(flds, base) => {\n-        for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n+        for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n       expr_struct(p, flds, base) => {\n         visit_path(p, e, v);\n-        for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n+        for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_tup(elts) => for elts.each |el| { v.visit_expr(*el, e, v); },\n+      expr_tup(elts) => for elts.each |el| { (v.visit_expr)(*el, e, v); },\n       expr_call(callee, args, _) => {\n         visit_exprs(args, e, v);\n-        v.visit_expr(callee, e, v);\n+        (v.visit_expr)(callee, e, v);\n       }\n       expr_binary(_, a, b) => {\n-        v.visit_expr(a, e, v); v.visit_expr(b, e, v);\n+        (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v);\n       }\n       expr_addr_of(_, x) | expr_unary(_, x) |\n       expr_loop_body(x) | expr_do_body(x) |\n-      expr_assert(x) => v.visit_expr(x, e, v),\n+      expr_assert(x) => (v.visit_expr)(x, e, v),\n       expr_lit(_) => (),\n-      expr_cast(x, t) => { v.visit_expr(x, e, v); v.visit_ty(t, e, v); }\n+      expr_cast(x, t) => { (v.visit_expr)(x, e, v); (v.visit_ty)(t, e, v); }\n       expr_if(x, b, eo) => {\n-        v.visit_expr(x, e, v);\n-        v.visit_block(b, e, v);\n+        (v.visit_expr)(x, e, v);\n+        (v.visit_block)(b, e, v);\n         visit_expr_opt(eo, e, v);\n       }\n-      expr_while(x, b) => { v.visit_expr(x, e, v); v.visit_block(b, e, v); }\n-      expr_loop(b, _) => v.visit_block(b, e, v),\n+      expr_while(x, b) => {\n+        (v.visit_expr)(x, e, v);\n+        (v.visit_block)(b, e, v);\n+      }\n+      expr_loop(b, _) => (v.visit_block)(b, e, v),\n       expr_match(x, arms) => {\n-        v.visit_expr(x, e, v);\n-        for arms.each |a| { v.visit_arm(*a, e, v); }\n+        (v.visit_expr)(x, e, v);\n+        for arms.each |a| { (v.visit_arm)(*a, e, v); }\n       }\n       expr_fn(proto, decl, body, cap_clause) => {\n-        v.visit_fn(fk_anon(proto, cap_clause), decl, body,\n-                   ex.span, ex.id, e, v);\n+        (v.visit_fn)(fk_anon(proto, cap_clause), decl, body,\n+                     ex.span, ex.id, e, v);\n       }\n       expr_fn_block(decl, body, cap_clause) => {\n-        v.visit_fn(fk_fn_block(cap_clause), decl, body,\n-                   ex.span, ex.id, e, v);\n-      }\n-      expr_block(b) => v.visit_block(b, e, v),\n-      expr_assign(a, b) => { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n-      expr_copy(a) => v.visit_expr(a, e, v),\n-      expr_unary_move(a) => v.visit_expr(a, e, v),\n-      expr_swap(a, b) => { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n+        (v.visit_fn)(fk_fn_block(cap_clause), decl, body,\n+                     ex.span, ex.id, e, v);\n+      }\n+      expr_block(b) => (v.visit_block)(b, e, v),\n+      expr_assign(a, b) => {\n+        (v.visit_expr)(b, e, v);\n+        (v.visit_expr)(a, e, v);\n+      }\n+      expr_copy(a) => (v.visit_expr)(a, e, v),\n+      expr_unary_move(a) => (v.visit_expr)(a, e, v),\n+      expr_swap(a, b) => { (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v); }\n       expr_assign_op(_, a, b) => {\n-        v.visit_expr(b, e, v);\n-        v.visit_expr(a, e, v);\n+        (v.visit_expr)(b, e, v);\n+        (v.visit_expr)(a, e, v);\n       }\n       expr_field(x, _, tys) => {\n-        v.visit_expr(x, e, v);\n-        for tys.each |tp| { v.visit_ty(*tp, e, v); }\n+        (v.visit_expr)(x, e, v);\n+        for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+      }\n+      expr_index(a, b) => {\n+        (v.visit_expr)(a, e, v);\n+        (v.visit_expr)(b, e, v);\n       }\n-      expr_index(a, b) => { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_path(p) => visit_path(p, e, v),\n       expr_fail(eo) => visit_expr_opt(eo, e, v),\n       expr_break(_) => (),\n       expr_again(_) => (),\n       expr_ret(eo) => visit_expr_opt(eo, e, v),\n       expr_log(_, lv, x) => {\n-        v.visit_expr(lv, e, v);\n-        v.visit_expr(x, e, v);\n+        (v.visit_expr)(lv, e, v);\n+        (v.visit_expr)(x, e, v);\n       }\n       expr_mac(mac) => visit_mac(mac, e, v),\n-      expr_paren(x) => v.visit_expr(x, e, v),\n+      expr_paren(x) => (v.visit_expr)(x, e, v),\n     }\n-    v.visit_expr_post(ex, e, v);\n+    (v.visit_expr_post)(ex, e, v);\n }\n \n fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n-    for a.pats.each |p| { v.visit_pat(*p, e, v); }\n+    for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n-    v.visit_block(a.body, e, v);\n+    (v.visit_block)(a.body, e, v);\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply"}]}