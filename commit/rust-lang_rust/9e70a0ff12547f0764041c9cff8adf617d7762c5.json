{"sha": "9e70a0ff12547f0764041c9cff8adf617d7762c5", "node_id": "C_kwDOAAsO6NoAKDllNzBhMGZmMTI1NDdmMDc2NDA0MWM5Y2ZmOGFkZjYxN2Q3NzYyYzU", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-10-05T17:17:57Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-10-05T17:21:32Z"}, "message": "Replace if_chain with let chains in `clippy::author` output", "tree": {"sha": "bb1b2c631291d05360029e73ee4407ca641ca1d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb1b2c631291d05360029e73ee4407ca641ca1d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e70a0ff12547f0764041c9cff8adf617d7762c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e70a0ff12547f0764041c9cff8adf617d7762c5", "html_url": "https://github.com/rust-lang/rust/commit/9e70a0ff12547f0764041c9cff8adf617d7762c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e70a0ff12547f0764041c9cff8adf617d7762c5/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e687bedac68aaacac7948a26ed13bea5b7f43427", "url": "https://api.github.com/repos/rust-lang/rust/commits/e687bedac68aaacac7948a26ed13bea5b7f43427", "html_url": "https://github.com/rust-lang/rust/commit/e687bedac68aaacac7948a26ed13bea5b7f43427"}], "stats": {"total": 807, "additions": 387, "deletions": 420}, "files": [{"sha": "0c052d86eda409dc1eb4fa3103f8e6b4ea4fdbae", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::{Ident, Symbol};\n+use std::cell::Cell;\n use std::fmt::{Display, Formatter, Write as _};\n \n declare_clippy_lint! {\n@@ -37,15 +38,13 @@ declare_clippy_lint! {\n     ///\n     /// ```rust,ignore\n     /// // ./tests/ui/new_lint.stdout\n-    /// if_chain! {\n-    ///     if let ExprKind::If(ref cond, ref then, None) = item.kind,\n-    ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.kind,\n-    ///     if let ExprKind::Path(ref path) = left.kind,\n-    ///     if let ExprKind::Lit(ref lit) = right.kind,\n-    ///     if let LitKind::Int(42, _) = lit.node,\n-    ///     then {\n-    ///         // report your lint here\n-    ///     }\n+    /// if ExprKind::If(ref cond, ref then, None) = item.kind\n+    ///     && let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.kind\n+    ///     && let ExprKind::Path(ref path) = left.kind\n+    ///     && let ExprKind::Lit(ref lit) = right.kind\n+    ///     && let LitKind::Int(42, _) = lit.node\n+    /// {\n+    ///     // report your lint here\n     /// }\n     /// ```\n     pub LINT_AUTHOR,\n@@ -91,15 +90,16 @@ macro_rules! field {\n     };\n }\n \n-fn prelude() {\n-    println!(\"if_chain! {{\");\n-}\n-\n-fn done() {\n-    println!(\"    then {{\");\n-    println!(\"        // report your lint here\");\n-    println!(\"    }}\");\n-    println!(\"}}\");\n+/// Print a condition of a let chain, `chain!(self, \"let Some(x) = y\")` will print\n+/// `if let Some(x) = y` on the first call and `    && let Some(x) = y` thereafter\n+macro_rules! chain {\n+    ($self:ident, $($t:tt)*) => {\n+        if $self.first.take() {\n+            println!(\"if {}\", format_args!($($t)*));\n+        } else {\n+            println!(\"    && {}\", format_args!($($t)*));\n+        }\n+    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for Author {\n@@ -149,9 +149,10 @@ fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n \n fn check_node(cx: &LateContext<'_>, hir_id: HirId, f: impl Fn(&PrintVisitor<'_, '_>)) {\n     if has_attr(cx, hir_id) {\n-        prelude();\n         f(&PrintVisitor::new(cx));\n-        done();\n+        println!(\"{{\");\n+        println!(\"    // report your lint here\");\n+        println!(\"}}\");\n     }\n }\n \n@@ -195,15 +196,18 @@ struct PrintVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     /// Fields are the current index that needs to be appended to pattern\n     /// binding names\n-    ids: std::cell::Cell<FxHashMap<&'static str, u32>>,\n+    ids: Cell<FxHashMap<&'static str, u32>>,\n+    /// Currently at the first condition in the if chain\n+    first: Cell<bool>,\n }\n \n #[allow(clippy::unused_self)]\n impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            ids: std::cell::Cell::default(),\n+            ids: Cell::default(),\n+            first: Cell::new(true),\n         }\n     }\n \n@@ -226,20 +230,20 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n     fn option<T: Copy>(&self, option: &Binding<Option<T>>, name: &'static str, f: impl Fn(&Binding<T>)) {\n         match option.value {\n-            None => out!(\"if {option}.is_none();\"),\n+            None => chain!(self, \"{option}.is_none()\"),\n             Some(value) => {\n                 let value = &self.bind(name, value);\n-                out!(\"if let Some({value}) = {option};\");\n+                chain!(self, \"let Some({value}) = {option}\");\n                 f(value);\n             },\n         }\n     }\n \n     fn slice<T>(&self, slice: &Binding<&[T]>, f: impl Fn(&Binding<&T>)) {\n         if slice.value.is_empty() {\n-            out!(\"if {slice}.is_empty();\");\n+            chain!(self, \"{slice}.is_empty()\");\n         } else {\n-            out!(\"if {slice}.len() == {};\", slice.value.len());\n+            chain!(self, \"{slice}.len() == {}\", slice.value.len());\n             for (i, value) in slice.value.iter().enumerate() {\n                 let name = format!(\"{slice}[{i}]\");\n                 f(&Binding { name, value });\n@@ -254,23 +258,23 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     }\n \n     fn ident(&self, ident: &Binding<Ident>) {\n-        out!(\"if {ident}.as_str() == {:?};\", ident.value.as_str());\n+        chain!(self, \"{ident}.as_str() == {:?}\", ident.value.as_str());\n     }\n \n     fn symbol(&self, symbol: &Binding<Symbol>) {\n-        out!(\"if {symbol}.as_str() == {:?};\", symbol.value.as_str());\n+        chain!(self, \"{symbol}.as_str() == {:?}\", symbol.value.as_str());\n     }\n \n     fn qpath(&self, qpath: &Binding<&QPath<'_>>) {\n         if let QPath::LangItem(lang_item, ..) = *qpath.value {\n-            out!(\"if matches!({qpath}, QPath::LangItem(LangItem::{lang_item:?}, _));\");\n+            chain!(self, \"matches!({qpath}, QPath::LangItem(LangItem::{lang_item:?}, _))\");\n         } else {\n-            out!(\"if match_qpath({qpath}, &[{}]);\", path_to_string(qpath.value));\n+            chain!(self, \"match_qpath({qpath}, &[{}])\", path_to_string(qpath.value));\n         }\n     }\n \n     fn lit(&self, lit: &Binding<&Lit>) {\n-        let kind = |kind| out!(\"if let LitKind::{kind} = {lit}.node;\");\n+        let kind = |kind| chain!(self, \"let LitKind::{kind} = {lit}.node\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }\n@@ -298,7 +302,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             LitKind::ByteStr(ref vec) => {\n                 bind!(self, vec);\n                 kind!(\"ByteStr(ref {vec})\");\n-                out!(\"if let [{:?}] = **{vec};\", vec.value);\n+                chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n             },\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n@@ -311,15 +315,15 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn arm(&self, arm: &Binding<&hir::Arm<'_>>) {\n         self.pat(field!(arm.pat));\n         match arm.value.guard {\n-            None => out!(\"if {arm}.guard.is_none();\"),\n+            None => chain!(self, \"{arm}.guard.is_none()\"),\n             Some(hir::Guard::If(expr)) => {\n                 bind!(self, expr);\n-                out!(\"if let Some(Guard::If({expr})) = {arm}.guard;\");\n+                chain!(self, \"let Some(Guard::If({expr})) = {arm}.guard\");\n                 self.expr(expr);\n             },\n             Some(hir::Guard::IfLet(let_expr)) => {\n                 bind!(self, let_expr);\n-                out!(\"if let Some(Guard::IfLet({let_expr}) = {arm}.guard;\");\n+                chain!(self, \"let Some(Guard::IfLet({let_expr}) = {arm}.guard\");\n                 self.pat(field!(let_expr.pat));\n                 self.expr(field!(let_expr.init));\n             },\n@@ -331,9 +335,10 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n         if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n             bind!(self, condition, body);\n-            out!(\n-                \"if let Some(higher::While {{ condition: {condition}, body: {body} }}) \\\n-                = higher::While::hir({expr});\"\n+            chain!(\n+                self,\n+                \"let Some(higher::While {{ condition: {condition}, body: {body} }}) \\\n+                = higher::While::hir({expr})\"\n             );\n             self.expr(condition);\n             self.expr(body);\n@@ -347,9 +352,10 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n         }) = higher::WhileLet::hir(expr.value)\n         {\n             bind!(self, let_pat, let_expr, if_then);\n-            out!(\n-                \"if let Some(higher::WhileLet {{ let_pat: {let_pat}, let_expr: {let_expr}, if_then: {if_then} }}) \\\n-                = higher::WhileLet::hir({expr});\"\n+            chain!(\n+                self,\n+                \"let Some(higher::WhileLet {{ let_pat: {let_pat}, let_expr: {let_expr}, if_then: {if_then} }}) \\\n+                = higher::WhileLet::hir({expr})\"\n             );\n             self.pat(let_pat);\n             self.expr(let_expr);\n@@ -359,17 +365,18 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n         if let Some(higher::ForLoop { pat, arg, body, .. }) = higher::ForLoop::hir(expr.value) {\n             bind!(self, pat, arg, body);\n-            out!(\n-                \"if let Some(higher::ForLoop {{ pat: {pat}, arg: {arg}, body: {body}, .. }}) \\\n-                = higher::ForLoop::hir({expr});\"\n+            chain!(\n+                self,\n+                \"let Some(higher::ForLoop {{ pat: {pat}, arg: {arg}, body: {body}, .. }}) \\\n+                = higher::ForLoop::hir({expr})\"\n             );\n             self.pat(pat);\n             self.expr(arg);\n             self.expr(body);\n             return;\n         }\n \n-        let kind = |kind| out!(\"if let ExprKind::{kind} = {expr}.kind;\");\n+        let kind = |kind| chain!(self, \"let ExprKind::{kind} = {expr}.kind\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }\n@@ -383,7 +390,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 // if it's a path\n                 if let Some(TyKind::Path(ref qpath)) = let_expr.value.ty.as_ref().map(|ty| &ty.kind) {\n                     bind!(self, qpath);\n-                    out!(\"if let TyKind::Path(ref {qpath}) = {let_expr}.ty.kind;\");\n+                    chain!(self, \"let TyKind::Path(ref {qpath}) = {let_expr}.ty.kind\");\n                     self.qpath(qpath);\n                 }\n                 self.expr(field!(let_expr.init));\n@@ -419,7 +426,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             ExprKind::Binary(op, left, right) => {\n                 bind!(self, op, left, right);\n                 kind!(\"Binary({op}, {left}, {right})\");\n-                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                chain!(self, \"BinOpKind::{:?} == {op}.node\", op.value.node);\n                 self.expr(left);\n                 self.expr(right);\n             },\n@@ -438,7 +445,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"Cast({expr}, {cast_ty})\");\n                 if let TyKind::Path(ref qpath) = cast_ty.value.kind {\n                     bind!(self, qpath);\n-                    out!(\"if let TyKind::Path(ref {qpath}) = {cast_ty}.kind;\");\n+                    chain!(self, \"let TyKind::Path(ref {qpath}) = {cast_ty}.kind\");\n                     self.qpath(qpath);\n                 }\n                 self.expr(expr);\n@@ -485,7 +492,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n                 bind!(self, fn_decl, body_id);\n                 kind!(\"Closure(CaptureBy::{capture_clause:?}, {fn_decl}, {body_id}, _, {movability})\");\n-                out!(\"if let {ret_ty} = {fn_decl}.output;\");\n+                chain!(self, \"let {ret_ty} = {fn_decl}.output\");\n                 self.body(body_id);\n             },\n             ExprKind::Yield(sub, source) => {\n@@ -509,7 +516,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             ExprKind::AssignOp(op, target, value) => {\n                 bind!(self, op, target, value);\n                 kind!(\"AssignOp({op}, {target}, {value})\");\n-                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                chain!(self, \"BinOpKind::{:?} == {op}.node\", op.value.node);\n                 self.expr(target);\n                 self.expr(value);\n             },\n@@ -573,10 +580,10 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"Repeat({value}, {length})\");\n                 self.expr(value);\n                 match length.value {\n-                    ArrayLen::Infer(..) => out!(\"if let ArrayLen::Infer(..) = length;\"),\n+                    ArrayLen::Infer(..) => chain!(self, \"let ArrayLen::Infer(..) = length\"),\n                     ArrayLen::Body(anon_const) => {\n                         bind!(self, anon_const);\n-                        out!(\"if let ArrayLen::Body({anon_const}) = {length};\");\n+                        chain!(self, \"let ArrayLen::Body({anon_const}) = {length}\");\n                         self.body(field!(anon_const.body));\n                     },\n                 }\n@@ -600,12 +607,12 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn body(&self, body_id: &Binding<hir::BodyId>) {\n         let expr = self.cx.tcx.hir().body(body_id.value).value;\n         bind!(self, expr);\n-        out!(\"let {expr} = &cx.tcx.hir().body({body_id}).value;\");\n+        chain!(self, \"{expr} = &cx.tcx.hir().body({body_id}).value\");\n         self.expr(expr);\n     }\n \n     fn pat(&self, pat: &Binding<&hir::Pat<'_>>) {\n-        let kind = |kind| out!(\"if let PatKind::{kind} = {pat}.kind;\");\n+        let kind = |kind| chain!(self, \"let PatKind::{kind} = {pat}.kind\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }\n@@ -688,7 +695,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     }\n \n     fn stmt(&self, stmt: &Binding<&hir::Stmt<'_>>) {\n-        let kind = |kind| out!(\"if let StmtKind::{kind} = {stmt}.kind;\");\n+        let kind = |kind| chain!(self, \"let StmtKind::{kind} = {stmt}.kind\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }"}, {"sha": "27ad538f24d8ce4ca06a41032ed0e701e70f4eb1", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,14 +1,12 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Cast(expr, cast_ty) = init.kind;\n-    if let TyKind::Path(ref qpath) = cast_ty.kind;\n-    if match_qpath(qpath, &[\"char\"]);\n-    if let ExprKind::Lit(ref lit) = expr.kind;\n-    if let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"x\";\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Cast(expr, cast_ty) = init.kind\n+    && let TyKind::Path(ref qpath) = cast_ty.kind\n+    && match_qpath(qpath, &[\"char\"])\n+    && let ExprKind::Lit(ref lit) = expr.kind\n+    && let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind\n+    && name.as_str() == \"x\"\n+{\n+    // report your lint here\n }"}, {"sha": "9de0550d81d0051654cab991cee3a6b240eaeb34", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,64 +1,58 @@\n-if_chain! {\n-    if let ExprKind::Block(block, None) = expr.kind;\n-    if block.stmts.len() == 3;\n-    if let StmtKind::Local(local) = block.stmts[0].kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Lit(ref lit) = init.kind;\n-    if let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"x\";\n-    if let StmtKind::Local(local1) = block.stmts[1].kind;\n-    if let Some(init1) = local1.init;\n-    if let ExprKind::Lit(ref lit1) = init1.kind;\n-    if let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local1.pat.kind;\n-    if name1.as_str() == \"_t\";\n-    if let StmtKind::Semi(e) = block.stmts[2].kind;\n-    if let ExprKind::Unary(UnOp::Neg, inner) = e.kind;\n-    if let ExprKind::Path(ref qpath) = inner.kind;\n-    if match_qpath(qpath, &[\"x\"]);\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Block(block, None) = expr.kind\n+    && block.stmts.len() == 3\n+    && let StmtKind::Local(local) = block.stmts[0].kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Lit(ref lit) = init.kind\n+    && let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind\n+    && name.as_str() == \"x\"\n+    && let StmtKind::Local(local1) = block.stmts[1].kind\n+    && let Some(init1) = local1.init\n+    && let ExprKind::Lit(ref lit1) = init1.kind\n+    && let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local1.pat.kind\n+    && name1.as_str() == \"_t\"\n+    && let StmtKind::Semi(e) = block.stmts[2].kind\n+    && let ExprKind::Unary(UnOp::Neg, inner) = e.kind\n+    && let ExprKind::Path(ref qpath) = inner.kind\n+    && match_qpath(qpath, &[\"x\"])\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::Block(block, None) = expr.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(local) = block.stmts[0].kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Call(func, args) = init.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if match_qpath(qpath, &[\"String\", \"new\"]);\n-    if args.is_empty();\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"expr\";\n-    if let Some(trailing_expr) = block.expr;\n-    if let ExprKind::Call(func1, args1) = trailing_expr.kind;\n-    if let ExprKind::Path(ref qpath1) = func1.kind;\n-    if match_qpath(qpath1, &[\"drop\"]);\n-    if args1.len() == 1;\n-    if let ExprKind::Path(ref qpath2) = args1[0].kind;\n-    if match_qpath(qpath2, &[\"expr\"]);\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Block(block, None) = expr.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Local(local) = block.stmts[0].kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Call(func, args) = init.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && match_qpath(qpath, &[\"String\", \"new\"])\n+    && args.is_empty()\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind\n+    && name.as_str() == \"expr\"\n+    && let Some(trailing_expr) = block.expr\n+    && let ExprKind::Call(func1, args1) = trailing_expr.kind\n+    && let ExprKind::Path(ref qpath1) = func1.kind\n+    && match_qpath(qpath1, &[\"drop\"])\n+    && args1.len() == 1\n+    && let ExprKind::Path(ref qpath2) = args1[0].kind\n+    && match_qpath(qpath2, &[\"expr\"])\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kind;\n-    if let FnRetTy::DefaultReturn(_) = fn_decl.output;\n-    let expr1 = &cx.tcx.hir().body(body_id).value;\n-    if let ExprKind::Call(func, args) = expr1.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _));\n-    if args.len() == 1;\n-    if let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind;\n-    if let FnRetTy::DefaultReturn(_) = fn_decl1.output;\n-    let expr2 = &cx.tcx.hir().body(body_id1).value;\n-    if let ExprKind::Block(block, None) = expr2.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kind\n+    && let FnRetTy::DefaultReturn(_) = fn_decl.output\n+    && expr1 = &cx.tcx.hir().body(body_id).value\n+    && let ExprKind::Call(func, args) = expr1.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _))\n+    && args.len() == 1\n+    && let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind\n+    && let FnRetTy::DefaultReturn(_) = fn_decl1.output\n+    && expr2 = &cx.tcx.hir().body(body_id1).value\n+    && let ExprKind::Block(block, None) = expr2.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }"}, {"sha": "f040f6330a64d8687bb53fb592b7342387e6c857", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,16 +1,14 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Call(func, args) = init.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if match_qpath(qpath, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n-    if args.len() == 2;\n-    if let ExprKind::Lit(ref lit) = args[0].kind;\n-    if let LitKind::Int(3, LitIntType::Unsuffixed) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = args[1].kind;\n-    if let LitKind::Int(4, LitIntType::Unsuffixed) = lit1.node;\n-    if let PatKind::Wild = local.pat.kind;\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Call(func, args) = init.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && match_qpath(qpath, &[\"{{root}}\", \"std\", \"cmp\", \"min\"])\n+    && args.len() == 2\n+    && let ExprKind::Lit(ref lit) = args[0].kind\n+    && let LitKind::Int(3, LitIntType::Unsuffixed) = lit.node\n+    && let ExprKind::Lit(ref lit1) = args[1].kind\n+    && let LitKind::Int(4, LitIntType::Unsuffixed) = lit1.node\n+    && let PatKind::Wild = local.pat.kind\n+{\n+    // report your lint here\n }"}, {"sha": "5d79618820d80595dd9db6a50bfebb3c42d7df90", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,50 +1,46 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::If(cond, then, Some(else_expr)) = init.kind;\n-    if let ExprKind::DropTemps(expr) = cond.kind;\n-    if let ExprKind::Lit(ref lit) = expr.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Block(block, None) = then.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Binary(op, left, right) = e.kind;\n-    if BinOpKind::Eq == op.node;\n-    if let ExprKind::Lit(ref lit1) = left.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Lit(ref lit2) = right.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit2.node;\n-    if block.expr.is_none();\n-    if let ExprKind::Block(block1, None) = else_expr.kind;\n-    if block1.stmts.len() == 1;\n-    if let StmtKind::Semi(e1) = block1.stmts[0].kind;\n-    if let ExprKind::Binary(op1, left1, right1) = e1.kind;\n-    if BinOpKind::Eq == op1.node;\n-    if let ExprKind::Lit(ref lit3) = left1.kind;\n-    if let LitKind::Int(2, LitIntType::Unsuffixed) = lit3.node;\n-    if let ExprKind::Lit(ref lit4) = right1.kind;\n-    if let LitKind::Int(2, LitIntType::Unsuffixed) = lit4.node;\n-    if block1.expr.is_none();\n-    if let PatKind::Wild = local.pat.kind;\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::If(cond, then, Some(else_expr)) = init.kind\n+    && let ExprKind::DropTemps(expr) = cond.kind\n+    && let ExprKind::Lit(ref lit) = expr.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Block(block, None) = then.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Binary(op, left, right) = e.kind\n+    && BinOpKind::Eq == op.node\n+    && let ExprKind::Lit(ref lit1) = left.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Lit(ref lit2) = right.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit2.node\n+    && block.expr.is_none()\n+    && let ExprKind::Block(block1, None) = else_expr.kind\n+    && block1.stmts.len() == 1\n+    && let StmtKind::Semi(e1) = block1.stmts[0].kind\n+    && let ExprKind::Binary(op1, left1, right1) = e1.kind\n+    && BinOpKind::Eq == op1.node\n+    && let ExprKind::Lit(ref lit3) = left1.kind\n+    && let LitKind::Int(2, LitIntType::Unsuffixed) = lit3.node\n+    && let ExprKind::Lit(ref lit4) = right1.kind\n+    && let LitKind::Int(2, LitIntType::Unsuffixed) = lit4.node\n+    && block1.expr.is_none()\n+    && let PatKind::Wild = local.pat.kind\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::If(cond, then, Some(else_expr)) = expr.kind;\n-    if let ExprKind::Let(let_expr) = cond.kind;\n-    if let PatKind::Lit(lit_expr) = let_expr.pat.kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Path(ref qpath) = let_expr.init.kind;\n-    if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, None) = then.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    if let ExprKind::Block(block1, None) = else_expr.kind;\n-    if block1.stmts.is_empty();\n-    if block1.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::If(cond, then, Some(else_expr)) = expr.kind\n+    && let ExprKind::Let(let_expr) = cond.kind\n+    && let PatKind::Lit(lit_expr) = let_expr.pat.kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Path(ref qpath) = let_expr.init.kind\n+    && match_qpath(qpath, &[\"a\"])\n+    && let ExprKind::Block(block, None) = then.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+    && let ExprKind::Block(block1, None) = else_expr.kind\n+    && block1.stmts.is_empty()\n+    && block1.expr.is_none()\n+{\n+    // report your lint here\n }"}, {"sha": "32a3127b85a3e3f50546165e796ef8864f0c160e", "filename": "tests/ui/author/issue_3849.stdout", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fissue_3849.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fissue_3849.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fissue_3849.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,14 +1,12 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Call(func, args) = init.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if match_qpath(qpath, &[\"std\", \"mem\", \"transmute\"]);\n-    if args.len() == 1;\n-    if let ExprKind::Path(ref qpath1) = args[0].kind;\n-    if match_qpath(qpath1, &[\"ZPTR\"]);\n-    if let PatKind::Wild = local.pat.kind;\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Call(func, args) = init.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && match_qpath(qpath, &[\"std\", \"mem\", \"transmute\"])\n+    && args.len() == 1\n+    && let ExprKind::Path(ref qpath1) = args[0].kind\n+    && match_qpath(qpath1, &[\"ZPTR\"])\n+    && let PatKind::Wild = local.pat.kind\n+{\n+    // report your lint here\n }"}, {"sha": "94a6436ed5479a0fe90f3ec26147199f229c8db3", "filename": "tests/ui/author/loop.stdout", "status": "modified", "additions": 95, "deletions": 107, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,113 +1,101 @@\n-if_chain! {\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = pat.kind;\n-    if name.as_str() == \"y\";\n-    if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    if fields[0].ident.as_str() == \"start\";\n-    if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.as_str() == \"end\";\n-    if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n-    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(local) = block.stmts[0].kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Path(ref qpath1) = init.kind;\n-    if match_qpath(qpath1, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n-    if name1.as_str() == \"z\";\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr)\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = pat.kind\n+    && name.as_str() == \"y\"\n+    && let ExprKind::Struct(qpath, fields, None) = arg.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::Range, _))\n+    && fields.len() == 2\n+    && fields[0].ident.as_str() == \"start\"\n+    && let ExprKind::Lit(ref lit) = fields[0].expr.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    && fields[1].ident.as_str() == \"end\"\n+    && let ExprKind::Lit(ref lit1) = fields[1].expr.kind\n+    && let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Local(local) = block.stmts[0].kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Path(ref qpath1) = init.kind\n+    && match_qpath(qpath1, &[\"y\"])\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind\n+    && name1.as_str() == \"z\"\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Wild = pat.kind;\n-    if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    if fields[0].ident.as_str() == \"start\";\n-    if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.as_str() == \"end\";\n-    if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n-    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr)\n+    && let PatKind::Wild = pat.kind\n+    && let ExprKind::Struct(qpath, fields, None) = arg.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::Range, _))\n+    && fields.len() == 2\n+    && fields[0].ident.as_str() == \"start\"\n+    && let ExprKind::Lit(ref lit) = fields[0].expr.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    && fields[1].ident.as_str() == \"end\"\n+    && let ExprKind::Lit(ref lit1) = fields[1].expr.kind\n+    && let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Wild = pat.kind;\n-    if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    if fields[0].ident.as_str() == \"start\";\n-    if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.as_str() == \"end\";\n-    if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n-    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if let Some(label) = destination.label;\n-    if label.ident.as_str() == \"'label\";\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr)\n+    && let PatKind::Wild = pat.kind\n+    && let ExprKind::Struct(qpath, fields, None) = arg.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::Range, _))\n+    && fields.len() == 2\n+    && fields[0].ident.as_str() == \"start\"\n+    && let ExprKind::Lit(ref lit) = fields[0].expr.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    && fields[1].ident.as_str() == \"end\"\n+    && let ExprKind::Lit(ref lit1) = fields[1].expr.kind\n+    && let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && let Some(label) = destination.label\n+    && label.ident.as_str() == \"'label\"\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::While { condition: condition, body: body }) = higher::While::hir(expr);\n-    if let ExprKind::Path(ref qpath) = condition.kind;\n-    if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::While { condition: condition, body: body }) = higher::While::hir(expr)\n+    && let ExprKind::Path(ref qpath) = condition.kind\n+    && match_qpath(qpath, &[\"a\"])\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::WhileLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then }) = higher::WhileLet::hir(expr);\n-    if let PatKind::Lit(lit_expr) = let_pat.kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Path(ref qpath) = let_expr.kind;\n-    if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, None) = if_then.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::WhileLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then }) = higher::WhileLet::hir(expr)\n+    && let PatKind::Lit(lit_expr) = let_pat.kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Path(ref qpath) = let_expr.kind\n+    && match_qpath(qpath, &[\"a\"])\n+    && let ExprKind::Block(block, None) = if_then.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::Loop(body, None, LoopSource::Loop, _) = expr.kind;\n-    if body.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = body.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if body.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Loop(body, None, LoopSource::Loop, _) = expr.kind\n+    && body.stmts.len() == 1\n+    && let StmtKind::Semi(e) = body.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && body.expr.is_none()\n+{\n+    // report your lint here\n }"}, {"sha": "88e2ca656a4f60a5ae8cd9f3392d5b5e6179bdfe", "filename": "tests/ui/author/matches.stdout", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fmatches.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fmatches.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,38 +1,36 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = init.kind;\n-    if let ExprKind::Lit(ref lit) = scrutinee.kind;\n-    if let LitKind::Int(42, LitIntType::Unsuffixed) = lit.node;\n-    if arms.len() == 3;\n-    if let PatKind::Lit(lit_expr) = arms[0].pat.kind;\n-    if let ExprKind::Lit(ref lit1) = lit_expr.kind;\n-    if let LitKind::Int(16, LitIntType::Unsuffixed) = lit1.node;\n-    if arms[0].guard.is_none();\n-    if let ExprKind::Lit(ref lit2) = arms[0].body.kind;\n-    if let LitKind::Int(5, LitIntType::Unsuffixed) = lit2.node;\n-    if let PatKind::Lit(lit_expr1) = arms[1].pat.kind;\n-    if let ExprKind::Lit(ref lit3) = lit_expr1.kind;\n-    if let LitKind::Int(17, LitIntType::Unsuffixed) = lit3.node;\n-    if arms[1].guard.is_none();\n-    if let ExprKind::Block(block, None) = arms[1].body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(local1) = block.stmts[0].kind;\n-    if let Some(init1) = local1.init;\n-    if let ExprKind::Lit(ref lit4) = init1.kind;\n-    if let LitKind::Int(3, LitIntType::Unsuffixed) = lit4.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local1.pat.kind;\n-    if name.as_str() == \"x\";\n-    if let Some(trailing_expr) = block.expr;\n-    if let ExprKind::Path(ref qpath) = trailing_expr.kind;\n-    if match_qpath(qpath, &[\"x\"]);\n-    if let PatKind::Wild = arms[2].pat.kind;\n-    if arms[2].guard.is_none();\n-    if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n-    if name1.as_str() == \"a\";\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = init.kind\n+    && let ExprKind::Lit(ref lit) = scrutinee.kind\n+    && let LitKind::Int(42, LitIntType::Unsuffixed) = lit.node\n+    && arms.len() == 3\n+    && let PatKind::Lit(lit_expr) = arms[0].pat.kind\n+    && let ExprKind::Lit(ref lit1) = lit_expr.kind\n+    && let LitKind::Int(16, LitIntType::Unsuffixed) = lit1.node\n+    && arms[0].guard.is_none()\n+    && let ExprKind::Lit(ref lit2) = arms[0].body.kind\n+    && let LitKind::Int(5, LitIntType::Unsuffixed) = lit2.node\n+    && let PatKind::Lit(lit_expr1) = arms[1].pat.kind\n+    && let ExprKind::Lit(ref lit3) = lit_expr1.kind\n+    && let LitKind::Int(17, LitIntType::Unsuffixed) = lit3.node\n+    && arms[1].guard.is_none()\n+    && let ExprKind::Block(block, None) = arms[1].body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Local(local1) = block.stmts[0].kind\n+    && let Some(init1) = local1.init\n+    && let ExprKind::Lit(ref lit4) = init1.kind\n+    && let LitKind::Int(3, LitIntType::Unsuffixed) = lit4.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local1.pat.kind\n+    && name.as_str() == \"x\"\n+    && let Some(trailing_expr) = block.expr\n+    && let ExprKind::Path(ref qpath) = trailing_expr.kind\n+    && match_qpath(qpath, &[\"x\"])\n+    && let PatKind::Wild = arms[2].pat.kind\n+    && arms[2].guard.is_none()\n+    && let ExprKind::Lit(ref lit5) = arms[2].body.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind\n+    && name1.as_str() == \"a\"\n+{\n+    // report your lint here\n }"}, {"sha": "c2a369610cc1b7cf0bf5635faed84c5999ebf3ed", "filename": "tests/ui/author/repeat.stdout", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Frepeat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Frepeat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Frepeat.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,12 +1,10 @@\n-if_chain! {\n-    if let ExprKind::Repeat(value, length) = expr.kind;\n-    if let ExprKind::Lit(ref lit) = value.kind;\n-    if let LitKind::Int(1, LitIntType::Unsigned(UintTy::U8)) = lit.node;\n-    if let ArrayLen::Body(anon_const) = length;\n-    let expr1 = &cx.tcx.hir().body(anon_const.body).value;\n-    if let ExprKind::Lit(ref lit1) = expr1.kind;\n-    if let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node;\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Repeat(value, length) = expr.kind\n+    && let ExprKind::Lit(ref lit) = value.kind\n+    && let LitKind::Int(1, LitIntType::Unsigned(UintTy::U8)) = lit.node\n+    && let ArrayLen::Body(anon_const) = length\n+    && expr1 = &cx.tcx.hir().body(anon_const.body).value\n+    && let ExprKind::Lit(ref lit1) = expr1.kind\n+    && let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node\n+{\n+    // report your lint here\n }"}, {"sha": "0b332d5e7d0e1e2c9b8b9cdb0fe41898dbe6b6d9", "filename": "tests/ui/author/struct.stdout", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9e70a0ff12547f0764041c9cff8adf617d7762c5/tests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.stdout?ref=9e70a0ff12547f0764041c9cff8adf617d7762c5", "patch": "@@ -1,64 +1,56 @@\n-if_chain! {\n-    if let ExprKind::Struct(qpath, fields, None) = expr.kind;\n-    if match_qpath(qpath, &[\"Test\"]);\n-    if fields.len() == 1;\n-    if fields[0].ident.as_str() == \"field\";\n-    if let ExprKind::If(cond, then, Some(else_expr)) = fields[0].expr.kind;\n-    if let ExprKind::DropTemps(expr1) = cond.kind;\n-    if let ExprKind::Lit(ref lit) = expr1.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Block(block, None) = then.kind;\n-    if block.stmts.is_empty();\n-    if let Some(trailing_expr) = block.expr;\n-    if let ExprKind::Lit(ref lit1) = trailing_expr.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block1, None) = else_expr.kind;\n-    if block1.stmts.is_empty();\n-    if let Some(trailing_expr1) = block1.expr;\n-    if let ExprKind::Lit(ref lit2) = trailing_expr1.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit2.node;\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Struct(qpath, fields, None) = expr.kind\n+    && match_qpath(qpath, &[\"Test\"])\n+    && fields.len() == 1\n+    && fields[0].ident.as_str() == \"field\"\n+    && let ExprKind::If(cond, then, Some(else_expr)) = fields[0].expr.kind\n+    && let ExprKind::DropTemps(expr1) = cond.kind\n+    && let ExprKind::Lit(ref lit) = expr1.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Block(block, None) = then.kind\n+    && block.stmts.is_empty()\n+    && let Some(trailing_expr) = block.expr\n+    && let ExprKind::Lit(ref lit1) = trailing_expr.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block1, None) = else_expr.kind\n+    && block1.stmts.is_empty()\n+    && let Some(trailing_expr1) = block1.expr\n+    && let ExprKind::Lit(ref lit2) = trailing_expr1.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit2.node\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let PatKind::Struct(ref qpath, fields, false) = arm.pat.kind;\n-    if match_qpath(qpath, &[\"Test\"]);\n-    if fields.len() == 1;\n-    if fields[0].ident.as_str() == \"field\";\n-    if let PatKind::Lit(lit_expr) = fields[0].pat.kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n-    if arm.guard.is_none();\n-    if let ExprKind::Block(block, None) = arm.body.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let PatKind::Struct(ref qpath, fields, false) = arm.pat.kind\n+    && match_qpath(qpath, &[\"Test\"])\n+    && fields.len() == 1\n+    && fields[0].ident.as_str() == \"field\"\n+    && let PatKind::Lit(lit_expr) = fields[0].pat.kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node\n+    && arm.guard.is_none()\n+    && let ExprKind::Block(block, None) = arm.body.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let PatKind::TupleStruct(ref qpath, fields, None) = arm.pat.kind;\n-    if match_qpath(qpath, &[\"TestTuple\"]);\n-    if fields.len() == 1;\n-    if let PatKind::Lit(lit_expr) = fields[0].kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n-    if arm.guard.is_none();\n-    if let ExprKind::Block(block, None) = arm.body.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let PatKind::TupleStruct(ref qpath, fields, None) = arm.pat.kind\n+    && match_qpath(qpath, &[\"TestTuple\"])\n+    && fields.len() == 1\n+    && let PatKind::Lit(lit_expr) = fields[0].kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node\n+    && arm.guard.is_none()\n+    && let ExprKind::Block(block, None) = arm.body.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind;\n-    if method_name.ident.as_str() == \"test\";\n-    if let ExprKind::Path(ref qpath) = receiver.kind;\n-    if match_qpath(qpath, &[\"test_method_call\"]);\n-    if args.is_empty();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind\n+    && method_name.ident.as_str() == \"test\"\n+    && let ExprKind::Path(ref qpath) = receiver.kind\n+    && match_qpath(qpath, &[\"test_method_call\"])\n+    && args.is_empty()\n+{\n+    // report your lint here\n }"}]}