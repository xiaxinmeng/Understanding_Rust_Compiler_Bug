{"sha": "cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTI5ZmM5ZjlkZTZjZjJkNDRkZjQ2ZmZjNGI0ZDZlNThlM2E1MDg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-05T15:04:59Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-05T16:03:38Z"}, "message": "Clean up translating of def_ids in metadata reader\n\nReduces the amount of closure allocation, and makes the code cleaner.", "tree": {"sha": "406fb29666fa3b769468fdd26260fa120234812f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/406fb29666fa3b769468fdd26260fa120234812f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "html_url": "https://github.com/rust-lang/rust/commit/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60ae1590af034755b5cb1e1e71f2240a710299a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ae1590af034755b5cb1e1e71f2240a710299a2", "html_url": "https://github.com/rust-lang/rust/commit/60ae1590af034755b5cb1e1e71f2240a710299a2"}], "stats": {"total": 337, "additions": 149, "deletions": 188}, "files": [{"sha": "167e6bbcbabd467036602dae0a532eb685c32bd6", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "patch": "@@ -260,7 +260,8 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n         // Now resolve the crates referenced by this crate\n         let cnum_map = resolve_crate_deps(e, cdata);\n \n-        let cmeta = {name: ident, data: cdata, cnum_map: cnum_map};\n+        let cmeta = @{name: ident, data: cdata,\n+                      cnum_map: cnum_map, cnum: cnum};\n \n         let cstore = e.sess.get_cstore();\n         cstore::set_crate_data(cstore, cnum, cmeta);"}, {"sha": "3b0eac2d3cef597430643e557b37903ee47cce48", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "patch": "@@ -58,32 +58,27 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n \n fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n     let cstore = tcx.sess.get_cstore();\n-    let cnum = def.crate;\n-    let cdata = cstore::get_crate_data(cstore, cnum).data;\n-    let resolver = bind translate_def_id(cstore, cnum, _);\n-    ret decoder::get_tag_variants(cdata, def, tcx, resolver)\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    ret decoder::get_tag_variants(cdata, def.node, tcx)\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option::t<ast::ident>)\n     -> @[@middle::resolve::_impl] {\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    let resolver = bind translate_def_id(cstore, def.crate, _);\n-    decoder::get_impls_for_mod(cdata, def, name, resolver)\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_impls_for_mod(cdata, def.node, name)\n }\n \n fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n     let cstore = tcx.sess.get_cstore();\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    let resolver = bind translate_def_id(cstore, def.crate, _);\n-    decoder::get_iface_methods(cdata, def, tcx, resolver)\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_iface_methods(cdata, def.node, tcx)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.get_cstore();\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    let resolver = bind translate_def_id(cstore, def.crate, _);\n-    decoder::get_type(cdata, def, tcx, resolver)\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_type(cdata, def.node, tcx)\n }\n \n fn get_item_name(cstore: cstore::cstore, cnum: int, id: int) -> ast::ident {\n@@ -94,34 +89,8 @@ fn get_item_name(cstore: cstore::cstore, cnum: int, id: int) -> ast::ident {\n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n     -> option::t<ty::t> {\n     let cstore = tcx.sess.get_cstore();\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    let resolver = bind translate_def_id(cstore, def.crate, _);\n-    decoder::get_impl_iface(cdata, def, tcx, resolver)\n-}\n-\n-// Translates a def_id from an external crate to a def_id for the current\n-// compilation environment. We use this when trying to load types from\n-// external crates - if those types further refer to types in other crates\n-// then we must translate the crate number from that encoded in the external\n-// crate to the correct local crate number.\n-fn translate_def_id(cstore: cstore::cstore, searched_crate: ast::crate_num,\n-                    def_id: ast::def_id) -> ast::def_id {\n-\n-    let ext_cnum = def_id.crate;\n-    let node_id = def_id.node;\n-\n-    assert (searched_crate != ast::local_crate);\n-    assert (ext_cnum != ast::local_crate);\n-\n-    let cmeta = cstore::get_crate_data(cstore, searched_crate);\n-\n-    let local_cnum =\n-        alt cmeta.cnum_map.find(ext_cnum) {\n-          option::some(n) { n }\n-          option::none. { fail \"didn't find a crate in the cnum_map\"; }\n-        };\n-\n-    ret {crate: local_cnum, node: node_id};\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_impl_iface(cdata, def.node, tcx)\n }\n \n // Local Variables:"}, {"sha": "de56aa236f535a6f0ca7f8d3c39cd9c82fda2d40", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "patch": "@@ -30,7 +30,10 @@ export get_dep_hashes;\n // own crate numbers.\n type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n \n-type crate_metadata = {name: str, data: @[u8], cnum_map: cnum_map};\n+type crate_metadata = @{name: str,\n+                        data: @[u8],\n+                        cnum_map: cnum_map,\n+                        cnum: ast::crate_num};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported tag variant, it's impossible for"}, {"sha": "a253e116fe8af45e7f606ceb96923e2be3093f70", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 65, "deletions": 70, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "patch": "@@ -1,14 +1,13 @@\n // Decoding metadata from a single crate's metadata\n \n-import core::{vec, option, str};\n import std::{ebml, io};\n import syntax::{ast, ast_util};\n import front::attr;\n import middle::ty;\n import common::*;\n-import tydecode::{parse_def_id, parse_ty_data};\n+import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n import syntax::print::pprust;\n-import cstore;\n+import cmd=cstore::crate_metadata;\n \n export get_symbol;\n export get_tag_variants;\n@@ -24,15 +23,13 @@ export list_crate_metadata;\n export crate_dep;\n export get_crate_deps;\n export get_crate_hash;\n-export external_resolver;\n export get_impls_for_mod;\n export get_iface_methods;\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n-type external_resolver = fn@(ast::def_id) -> ast::def_id;\n \n fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n    [ebml::doc] {\n@@ -91,66 +88,50 @@ fn variant_tag_id(d: ebml::doc) -> ast::def_id {\n     ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n-fn parse_external_def_id(this_cnum: ast::crate_num,\n-                         extres: external_resolver, s: str) ->\n-    ast::def_id {\n-    let buf = str::bytes(s);\n-    let external_def_id = parse_def_id(buf);\n-\n-\n-    // This item was defined in the crate we're searching if it's has the\n-    // local crate number, otherwise we need to search a different crate\n-    if external_def_id.crate == ast::local_crate {\n-        ret {crate: this_cnum, node: external_def_id.node};\n-    } else { ret extres(external_def_id); }\n-}\n-\n-fn doc_type(doc: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n-            extres: external_resolver) -> ty::t {\n+fn doc_type(doc: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = ebml::get_doc(doc, tag_items_data_item_type);\n-    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n-    parse_ty_data(tp.data, this_cnum, tp.start, def_parser, tcx)\n+    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, {|did|\n+        translate_def_id(cdata, did)\n+    })\n }\n \n-fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n-             extres: external_resolver) -> ty::t {\n-    let t = doc_type(item, this_cnum, tcx, extres);\n+fn item_type(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+    let t = doc_type(item, tcx, cdata);\n     if family_names_type(item_family(item)) {\n         ty::mk_named(tcx, t, @item_name(item))\n     } else { t }\n }\n \n-fn item_impl_iface(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n-                   extres: external_resolver) -> option::t<ty::t> {\n+fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n+    -> option::t<ty::t> {\n     let result = none;\n     ebml::tagged_docs(item, tag_impl_iface) {|ity|\n-        let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n-        let t = parse_ty_data(ity.data, this_cnum, ity.start, def_parser,\n-                              tcx);\n+        let t = parse_ty_data(ity.data, cdata.cnum, ity.start, tcx, {|did|\n+            translate_def_id(cdata, did)\n+        });\n         result = some(t);\n     }\n     result\n }\n \n-fn item_impl_iface_did(item: ebml::doc, this_cnum: ast::crate_num,\n-                       extres: external_resolver)\n+fn item_impl_iface_did(item: ebml::doc, cdata: cmd)\n     -> option::t<ast::def_id> {\n     let result = none;\n     ebml::tagged_docs(item, tag_impl_iface_did) {|doc|\n-        let s = str::unsafe_from_bytes(ebml::doc_data(doc));\n-        result = some(parse_external_def_id(this_cnum, extres, s));\n+        let did = translate_def_id(cdata, parse_def_id(ebml::doc_data(doc)));\n+        result = some(did);\n     }\n     result\n }\n \n-fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n-                        tcx: ty::ctxt, extres: external_resolver)\n+fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> @[ty::param_bounds] {\n     let bounds = [];\n-    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n-        bounds += [tydecode::parse_bounds_data(p.data, p.start,\n-                                               this_cnum, def_parser, tcx)];\n+        let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n+            translate_def_id(cdata, did)\n+        });\n+        bounds += [bd];\n     }\n     @bounds\n }\n@@ -162,13 +143,12 @@ fn item_ty_param_count(item: ebml::doc) -> uint {\n     n\n }\n \n-fn tag_variant_ids(item: ebml::doc, this_cnum: ast::crate_num) ->\n-   [ast::def_id] {\n+fn tag_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n     let ids: [ast::def_id] = [];\n     let v = tag_items_data_item_variant;\n     ebml::tagged_docs(item, v) {|p|\n         let ext = parse_def_id(ebml::doc_data(p));\n-        ids += [{crate: this_cnum, node: ext.node}];\n+        ids += [{crate: cdata.cnum, node: ext.node}];\n     };\n     ret ids;\n }\n@@ -230,12 +210,12 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n     ret def;\n }\n \n-fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n-            extres: external_resolver) -> ty::ty_param_bounds_and_ty {\n-    let item = lookup_item(def.node, data);\n-    let t = item_type(item, def.crate, tcx, extres);\n+fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+    -> ty::ty_param_bounds_and_ty {\n+    let item = lookup_item(id, cdata.data);\n+    let t = item_type(item, tcx, cdata);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, def.crate, tcx, extres)\n+        item_ty_param_bounds(item, tcx, cdata)\n     } else { @[] };\n     ret {bounds: tp_bounds, ty: t};\n }\n@@ -244,27 +224,25 @@ fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-fn get_impl_iface(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n-                  extres: external_resolver) -> option::t<ty::t> {\n-    item_impl_iface(lookup_item(def.node, data), def.crate, tcx, extres)\n+fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+    -> option::t<ty::t> {\n+    item_impl_iface(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(_data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n-                    extres: external_resolver) -> [ty::variant_info] {\n-    let external_crate_id = def.crate;\n-    let data =\n-        cstore::get_crate_data(tcx.sess.get_cstore(), external_crate_id).data;\n+fn get_tag_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+    -> [ty::variant_info] {\n+    let data = cdata.data;\n     let items = ebml::get_doc(ebml::new_doc(data), tag_items);\n-    let item = find_item(def.node, items);\n+    let item = find_item(id, items);\n     let infos: [ty::variant_info] = [];\n-    let variant_ids = tag_variant_ids(item, external_crate_id);\n+    let variant_ids = tag_variant_ids(item, cdata);\n     for did: ast::def_id in variant_ids {\n         let item = find_item(did.node, items);\n-        let ctor_ty = item_type(item, external_crate_id, tcx, extres);\n+        let ctor_ty = item_type(item, tcx, cdata);\n         let arg_tys: [ty::t] = [];\n         alt ty::struct(tcx, ctor_ty) {\n           ty::ty_fn(f) {\n@@ -290,31 +268,32 @@ fn item_impl_methods(data: @[u8], item: ebml::doc, base_tps: uint)\n     rslt\n }\n \n-fn get_impls_for_mod(data: @[u8], m_def: ast::def_id,\n-                     name: option::t<ast::ident>, extres: external_resolver)\n+fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n+                     name: option::t<ast::ident>)\n     -> @[@middle::resolve::_impl] {\n-    let mod_item = lookup_item(m_def.node, data), result = [];\n+    let data = cdata.data;\n+    let mod_item = lookup_item(m_id, data), result = [];\n     ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n-        let did = parse_external_def_id(\n-            m_def.crate, extres, str::unsafe_from_bytes(ebml::doc_data(doc)));\n+        let did = translate_def_id(cdata, parse_def_id(ebml::doc_data(doc)));\n         let item = lookup_item(did.node, data), nm = item_name(item);\n         if alt name { some(n) { n == nm } none. { true } } {\n             let base_tps = item_ty_param_count(doc);\n-            let i_did = item_impl_iface_did(item, m_def.crate, extres);\n+            let i_did = item_impl_iface_did(item, cdata);\n             result += [@{did: did, iface_did: i_did, ident: nm,\n                          methods: item_impl_methods(data, doc, base_tps)}];\n         }\n     }\n     @result\n }\n \n-fn get_iface_methods(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n-                     extres: external_resolver) -> @[ty::method] {\n-    let item = lookup_item(def.node, data), result = [];\n+fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+    -> @[ty::method] {\n+    let data = cdata.data;\n+    let item = lookup_item(id, data), result = [];\n     ebml::tagged_docs(item, tag_item_method) {|mth|\n-        let bounds = item_ty_param_bounds(mth, def.crate, tcx, extres);\n+        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n-        let ty = doc_type(mth, def.crate, tcx, extres);\n+        let ty = doc_type(mth, tcx, cdata);\n         let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f } };\n         result += [{ident: name, tps: bounds, fty: fty}];\n     }\n@@ -489,6 +468,22 @@ fn list_crate_metadata(bytes: @[u8], out: io::writer) {\n     list_crate_items(bytes, md, out);\n }\n \n+// Translates a def_id from an external crate to a def_id for the current\n+// compilation environment. We use this when trying to load types from\n+// external crates - if those types further refer to types in other crates\n+// then we must translate the crate number from that encoded in the external\n+// crate to the correct local crate number.\n+fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n+    if did.crate == ast::local_crate {\n+        ret {crate: cdata.cnum, node: did.node};\n+    }\n+\n+    alt cdata.cnum_map.find(did.crate) {\n+      option::some(n) { ret {crate: n, node: did.node}; }\n+      option::none. { fail \"didn't find a crate in the cnum_map\"; }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "4ba9ae3fadeb6ffdc5246a822c602fdeb0b98a3f", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 68, "deletions": 75, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=cc929fc9f9de6cf2d44df46ffc4b4d6e58e3a508", "patch": "@@ -8,16 +8,15 @@ import syntax::ast_util;\n import syntax::ast_util::respan;\n import middle::ty;\n \n-export parse_def_id;\n-export parse_ty_data;\n+export parse_ty_data, parse_def_id;\n export parse_bounds_data;\n \n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n // Callback to translate defs to strs or back:\n-type str_def = fn@(str) -> ast::def_id;\n+type conv_did = block(ast::def_id) -> ast::def_id;\n \n type pstate = {data: @[u8], crate: int, mutable pos: uint, tcx: ty::ctxt};\n \n@@ -31,12 +30,12 @@ fn next(st: @pstate) -> u8 {\n     ret ch;\n }\n \n-fn parse_ident(st: @pstate, sd: str_def, last: char) -> ast::ident {\n+fn parse_ident(st: @pstate, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { ret c == b; }\n-    ret parse_ident_(st, sd, bind is_last(last, _));\n+    ret parse_ident_(st, bind is_last(last, _));\n }\n \n-fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn@(char) -> bool) ->\n+fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n    ast::ident {\n     let rslt = \"\";\n     while !is_last(peek(st) as char) {\n@@ -46,28 +45,26 @@ fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn@(char) -> bool) ->\n }\n \n \n-fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, sd: str_def,\n-                 tcx: ty::ctxt) -> ty::t {\n+fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                 conv: conv_did) -> ty::t {\n     let st = @{data: data, crate: crate_num, mutable pos: pos, tcx: tcx};\n-    parse_ty(st, sd)\n+    parse_ty(st, conv)\n }\n \n-fn parse_ret_ty(st: @pstate, sd: str_def) -> (ast::ret_style, ty::t) {\n+fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n     alt peek(st) as char {\n       '!' { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n-      _ { (ast::return_val, parse_ty(st, sd)) }\n+      _ { (ast::return_val, parse_ty(st, conv)) }\n     }\n }\n \n-fn parse_constrs(st: @pstate, sd: str_def) -> [@ty::constr] {\n+fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr] {\n     let rslt: [@ty::constr] = [];\n     alt peek(st) as char {\n       ':' {\n         do  {\n             next(st);\n-            let one: @ty::constr =\n-                parse_constr::<uint>(st, sd, parse_constr_arg);\n-            rslt += [one];\n+            rslt += [parse_constr(st, conv, parse_constr_arg)];\n         } while peek(st) as char == ';'\n       }\n       _ { }\n@@ -76,43 +73,39 @@ fn parse_constrs(st: @pstate, sd: str_def) -> [@ty::constr] {\n }\n \n // FIXME less copy-and-paste\n-fn parse_ty_constrs(st: @pstate, sd: str_def) -> [@ty::type_constr] {\n+fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr] {\n     let rslt: [@ty::type_constr] = [];\n     alt peek(st) as char {\n       ':' {\n         do  {\n             next(st);\n-            let one: @ty::type_constr =\n-                parse_constr::<@path>(st, sd, parse_ty_constr_arg);\n-            rslt += [one];\n+            rslt += [parse_constr(st, conv, parse_ty_constr_arg)];\n         } while peek(st) as char == ';'\n       }\n       _ { }\n     }\n     ret rslt;\n }\n \n-fn parse_path(st: @pstate, sd: str_def) -> @ast::path {\n+fn parse_path(st: @pstate) -> @ast::path {\n     let idents: [ast::ident] = [];\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n-    idents += [parse_ident_(st, sd, is_last)];\n+    idents += [parse_ident_(st, is_last)];\n     while true {\n         alt peek(st) as char {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n                 ret @respan(ast_util::dummy_sp(),\n                             {global: false, idents: idents, types: []});\n-            } else { idents += [parse_ident_(st, sd, is_last)]; }\n+            } else { idents += [parse_ident_(st, is_last)]; }\n           }\n         }\n     }\n     fail \"parse_path: ill-formed path\";\n }\n \n-type arg_parser<T> = fn(@pstate, str_def) -> ast::constr_arg_general_<T>;\n-\n-fn parse_constr_arg(st: @pstate, _sd: str_def) -> ast::fn_constr_arg {\n+fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n     alt peek(st) as char {\n       '*' { st.pos += 1u; ret ast::carg_base; }\n       c {\n@@ -129,33 +122,33 @@ fn parse_constr_arg(st: @pstate, _sd: str_def) -> ast::fn_constr_arg {\n         }\n         /*\n           else {\n-          auto lit = parse_lit(st, sd, ',');\n+          auto lit = parse_lit(st, conv, ',');\n           args += [respan(st.span, ast::carg_lit(lit))];\n           }\n         */\n       }\n     }\n }\n \n-fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n-   ast::constr_arg_general_<@path> {\n+fn parse_ty_constr_arg(st: @pstate) -> ast::constr_arg_general_<@path> {\n     alt peek(st) as char {\n       '*' { st.pos += 1u; ret ast::carg_base; }\n-      c { ret ast::carg_ident(parse_path(st, sd)); }\n+      c { ret ast::carg_ident(parse_path(st)); }\n     }\n }\n \n-fn parse_constr<T: copy>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n-   @ty::constr_general<T> {\n+fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n+                         pser: block(@pstate) -> ast::constr_arg_general_<T>)\n+    -> @ty::constr_general<T> {\n     let sp = ast_util::dummy_sp(); // FIXME: use a real span\n     let args: [@sp_constr_arg<T>] = [];\n-    let pth = parse_path(st, sd);\n+    let pth = parse_path(st);\n     let ignore: char = next(st) as char;\n     assert (ignore == '(');\n-    let def = parse_def(st, sd);\n+    let def = parse_def(st, conv);\n     let an_arg: constr_arg_general_<T>;\n     do  {\n-        an_arg = pser(st, sd);\n+        an_arg = pser(st);\n         // FIXME use a real span\n         args += [@respan(sp, an_arg)];\n         ignore = next(st) as char;\n@@ -164,11 +157,11 @@ fn parse_constr<T: copy>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n     ret @respan(sp, {path: pth, args: args, id: def});\n }\n \n-fn parse_ty_rust_fn(st: @pstate, sd: str_def, p: ast::proto) -> ty::t {\n-    ret ty::mk_fn(st.tcx, {proto: p with parse_ty_fn(st, sd)});\n+fn parse_ty_rust_fn(st: @pstate, conv: conv_did, p: ast::proto) -> ty::t {\n+    ret ty::mk_fn(st.tcx, {proto: p with parse_ty_fn(st, conv)});\n }\n \n-fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n+fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n     alt next(st) as char {\n       'n' { ret ty::mk_nil(st.tcx); }\n       'z' { ret ty::mk_bot(st.tcx); }\n@@ -194,28 +187,28 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       'S' { ret ty::mk_str(st.tcx); }\n       't' {\n         assert (next(st) as char == '[');\n-        let def = parse_def(st, sd);\n+        let def = parse_def(st, conv);\n         let params: [ty::t] = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n+        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tag(st.tcx, def, params);\n       }\n       'x' {\n         assert (next(st) as char == '[');\n-        let def = parse_def(st, sd);\n+        let def = parse_def(st, conv);\n         let params: [ty::t] = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n+        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_iface(st.tcx, def, params);\n       }\n       'p' {\n-        let did = parse_def(st, sd);\n+        let did = parse_def(st, conv);\n         ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n-      '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n-      '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, sd)); }\n-      '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n-      'I' { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n+      '@' { ret ty::mk_box(st.tcx, parse_mt(st, conv)); }\n+      '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, conv)); }\n+      '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, conv)); }\n+      'I' { ret ty::mk_vec(st.tcx, parse_mt(st, conv)); }\n       'R' {\n         assert (next(st) as char == '[');\n         let fields: [ty::field] = [];\n@@ -225,32 +218,32 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n                 name += str::unsafe_from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n-            fields += [{ident: name, mt: parse_mt(st, sd)}];\n+            fields += [{ident: name, mt: parse_mt(st, conv)}];\n         }\n         st.pos = st.pos + 1u;\n         ret ty::mk_rec(st.tcx, fields);\n       }\n       'T' {\n         assert (next(st) as char == '[');\n         let params = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n+        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }\n       's' {\n-        ret parse_ty_rust_fn(st, sd, ast::proto_send);\n+        ret parse_ty_rust_fn(st, conv, ast::proto_send);\n       }\n       'F' {\n-        ret parse_ty_rust_fn(st, sd, ast::proto_shared(ast::sugar_normal));\n+        ret parse_ty_rust_fn(st, conv, ast::proto_shared(ast::sugar_normal));\n       }\n       'f' {\n-        ret parse_ty_rust_fn(st, sd, ast::proto_bare);\n+        ret parse_ty_rust_fn(st, conv, ast::proto_bare);\n       }\n       'B' {\n-        ret parse_ty_rust_fn(st, sd, ast::proto_block);\n+        ret parse_ty_rust_fn(st, conv, ast::proto_block);\n       }\n       'N' {\n-        let func = parse_ty_fn(st, sd);\n+        let func = parse_ty_fn(st, conv);\n         ret ty::mk_native_fn(st.tcx, func.inputs, func.output);\n       }\n       'O' {\n@@ -266,22 +259,22 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n                 name += str::unsafe_from_byte(next(st));\n             }\n             methods += [{ident: name, tps: @[],\n-                         fty: {proto: proto with parse_ty_fn(st, sd)}}];\n+                         fty: {proto: proto with parse_ty_fn(st, conv)}}];\n         }\n         st.pos += 1u;\n         ret ty::mk_obj(st.tcx, methods);\n       }\n       'r' {\n         assert (next(st) as char == '[');\n-        let def = parse_def(st, sd);\n-        let inner = parse_ty(st, sd);\n+        let def = parse_def(st, conv);\n+        let inner = parse_ty(st, conv);\n         let params: [ty::t] = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n+        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_res(st.tcx, def, inner, params);\n       }\n       'X' { ret ty::mk_var(st.tcx, parse_int(st)); }\n-      'E' { let def = parse_def(st, sd); ret ty::mk_native(st.tcx, def); }\n+      'E' { let def = parse_def(st, conv); ret ty::mk_native(st.tcx, def); }\n       'Y' { ret ty::mk_type(st.tcx); }\n       'y' { ret ty::mk_send_type(st.tcx); }\n       'C' { ret ty::mk_opaque_closure(st.tcx); }\n@@ -294,38 +287,38 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n           some(tt) { ret tt; }\n           none. {\n             let ps = @{pos: pos with *st};\n-            let tt = parse_ty(ps, sd);\n+            let tt = parse_ty(ps, conv);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n             ret tt;\n           }\n         }\n       }\n       'A' {\n         assert (next(st) as char == '[');\n-        let tt = parse_ty(st, sd);\n-        let tcs = parse_ty_constrs(st, sd);\n+        let tt = parse_ty(st, conv);\n+        let tcs = parse_ty_constrs(st, conv);\n         assert (next(st) as char == ']');\n         ret ty::mk_constr(st.tcx, tt, tcs);\n       }\n       c { #error(\"unexpected char in type string: %c\", c); fail;}\n     }\n }\n \n-fn parse_mt(st: @pstate, sd: str_def) -> ty::mt {\n+fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     let mut;\n     alt peek(st) as char {\n       'm' { next(st); mut = ast::mut; }\n       '?' { next(st); mut = ast::maybe_mut; }\n       _ { mut = ast::imm; }\n     }\n-    ret {ty: parse_ty(st, sd), mut: mut};\n+    ret {ty: parse_ty(st, conv), mut: mut};\n }\n \n-fn parse_def(st: @pstate, sd: str_def) -> ast::def_id {\n-    let def = \"\";\n-    while peek(st) as char != '|' { def += str::unsafe_from_byte(next(st)); }\n+fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n+    let def = [];\n+    while peek(st) as char != '|' { def += [next(st)]; }\n     st.pos = st.pos + 1u;\n-    ret sd(def);\n+    ret conv(parse_def_id(def));\n }\n \n fn parse_int(st: @pstate) -> int {\n@@ -354,7 +347,7 @@ fn parse_hex(st: @pstate) -> uint {\n     ret n;\n }\n \n-fn parse_ty_fn(st: @pstate, sd: str_def) -> ty::fn_ty {\n+fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     assert (next(st) as char == '[');\n     let inputs: [ty::arg] = [];\n     while peek(st) as char != ']' {\n@@ -366,11 +359,11 @@ fn parse_ty_fn(st: @pstate, sd: str_def) -> ty::fn_ty {\n           '#' { ast::by_val }\n         };\n         st.pos += 1u;\n-        inputs += [{mode: mode, ty: parse_ty(st, sd)}];\n+        inputs += [{mode: mode, ty: parse_ty(st, conv)}];\n     }\n     st.pos += 1u; // eat the ']'\n-    let cs = parse_constrs(st, sd);\n-    let (ret_style, ret_ty) = parse_ret_ty(st, sd);\n+    let cs = parse_constrs(st, conv);\n+    let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n     ret {proto: ast::proto_bare, inputs: inputs, output: ret_ty,\n          ret_style: ret_style, constraints: cs};\n }\n@@ -399,19 +392,19 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n }\n \n fn parse_bounds_data(data: @[u8], start: uint,\n-                     crate_num: int, sd: str_def, tcx: ty::ctxt)\n+                     crate_num: int, tcx: ty::ctxt, conv: conv_did)\n     -> @[ty::param_bound] {\n     let st = @{data: data, crate: crate_num, mutable pos: start, tcx: tcx};\n-    parse_bounds(st, sd)\n+    parse_bounds(st, conv)\n }\n \n-fn parse_bounds(st: @pstate, sd: str_def) -> @[ty::param_bound] {\n+fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound] {\n     let bounds = [];\n     while true {\n         bounds += [alt next(st) as char {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n-          'I' { ty::bound_iface(parse_ty(st, sd)) }\n+          'I' { ty::bound_iface(parse_ty(st, conv)) }\n           '.' { break; }\n         }];\n     }"}]}