{"sha": "c3454c000706176b61ef089107203766735348f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNDU0YzAwMDcwNjE3NmI2MWVmMDg5MTA3MjAzNzY2NzM1MzQ4Zjc=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-27T11:52:40Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-29T20:14:17Z"}, "message": "Check whether locals are too large instead of whether accesses into them are too large", "tree": {"sha": "3fb111f280a50fb8625f9d13653d59da1de0a4dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fb111f280a50fb8625f9d13653d59da1de0a4dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3454c000706176b61ef089107203766735348f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3454c000706176b61ef089107203766735348f7", "html_url": "https://github.com/rust-lang/rust/commit/c3454c000706176b61ef089107203766735348f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3454c000706176b61ef089107203766735348f7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8611e526b766ce188dc29bd49bf66ff17764ceea", "url": "https://api.github.com/repos/rust-lang/rust/commits/8611e526b766ce188dc29bd49bf66ff17764ceea", "html_url": "https://github.com/rust-lang/rust/commit/8611e526b766ce188dc29bd49bf66ff17764ceea"}], "stats": {"total": 116, "additions": 60, "deletions": 56}, "files": [{"sha": "9184173e402ead51fd3539eddc8757c6fdd1924b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 60, "deletions": 56, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c3454c000706176b61ef089107203766735348f7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3454c000706176b61ef089107203766735348f7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c3454c000706176b61ef089107203766735348f7", "patch": "@@ -34,7 +34,9 @@ use crate::interpret::{\n };\n use crate::transform::{MirPass, MirSource};\n \n-/// The maximum number of bytes that we'll allocate space for a return value.\n+/// The maximum number of bytes that we'll allocate space for a local or the return value.\n+/// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n+/// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n \n /// Macro for machine-specific `InterpError` without allocation.\n@@ -331,7 +333,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let can_const_prop = CanConstProp::check(body);\n+        // FIXME: `CanConstProp::check` computes the layout of all locals, return those layouts\n+        // so we can write them to `ecx.frame_mut().locals.layout, reducing the duplication in\n+        // `layout_of` query invocations.\n+        let can_const_prop = CanConstProp::check(tcx, param_env, body);\n         let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n         for (l, mode) in can_const_prop.iter_enumerated() {\n             if *mode == ConstPropMode::OnlyInsideOwnBlock {\n@@ -612,15 +617,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n-        place_layout: TyAndLayout<'tcx>,\n         source_info: SourceInfo,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        // #66397: Don't try to eval into large places as that can cause an OOM\n-        if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n-            return None;\n-        }\n-\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -893,7 +892,11 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// Returns true if `local` can be propagated\n-    fn check(body: &Body<'_>) -> IndexVec<Local, ConstPropMode> {\n+    fn check(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        body: &Body<'tcx>,\n+    ) -> IndexVec<Local, ConstPropMode> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n             found_assignment: BitSet::new_empty(body.local_decls.len()),\n@@ -903,6 +906,16 @@ impl CanConstProp {\n             ),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n+            let ty = body.local_decls[local].ty;\n+            match tcx.layout_of(param_env.and(ty)) {\n+                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n+                // Either the layout fails to compute, then we can't use this local anyway\n+                // or the local is too large, then we don't want to.\n+                _ => {\n+                    *val = ConstPropMode::NoPropagation;\n+                    continue;\n+                }\n+            }\n             // Cannot use args at all\n             // Cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n@@ -1018,61 +1031,52 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n-            let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n-            if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                let can_const_prop = self.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n-                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                    // type whose creation requires no write. E.g. a generator whose initial state\n-                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                    if let Some(value) = self.get_const(place) {\n-                        if self.should_const_prop(value) {\n-                            trace!(\"replacing {:?} with {:?}\", rval, value);\n-                            self.replace_with_const(rval, value, source_info);\n-                            if can_const_prop == ConstPropMode::FullConstProp\n-                                || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                            {\n-                                trace!(\"propagated into {:?}\", place);\n-                            }\n+            let can_const_prop = self.can_const_prop[place.local];\n+            if let Some(()) = self.const_prop(rval, source_info, place) {\n+                // This will return None if the above `const_prop` invocation only \"wrote\" a\n+                // type whose creation requires no write. E.g. a generator whose initial state\n+                // consists solely of uninitialized memory (so it doesn't capture any locals).\n+                if let Some(value) = self.get_const(place) {\n+                    if self.should_const_prop(value) {\n+                        trace!(\"replacing {:?} with {:?}\", rval, value);\n+                        self.replace_with_const(rval, value, source_info);\n+                        if can_const_prop == ConstPropMode::FullConstProp\n+                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                        {\n+                            trace!(\"propagated into {:?}\", place);\n                         }\n                     }\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n+                }\n+                match can_const_prop {\n+                    ConstPropMode::OnlyInsideOwnBlock => {\n+                        trace!(\n+                            \"found local restricted to its block. \\\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n+                            place.local\n+                        );\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        trace!(\"can't propagate into {:?}\", place);\n+                        if place.local != RETURN_PLACE {\n+                            Self::remove_const(&mut self.ecx, place.local);\n                         }\n-                        ConstPropMode::FullConstProp => {}\n                     }\n-                } else {\n-                    // Const prop failed, so erase the destination, ensuring that whatever happens\n-                    // from here on, does not know about the previous value.\n-                    // This is important in case we have\n-                    // ```rust\n-                    // let mut x = 42;\n-                    // x = SOME_MUTABLE_STATIC;\n-                    // // x must now be undefined\n-                    // ```\n-                    // FIXME: we overzealously erase the entire local, because that's easier to\n-                    // implement.\n-                    trace!(\n-                        \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                        place,\n-                    );\n-                    Self::remove_const(&mut self.ecx, place.local);\n+                    ConstPropMode::FullConstProp => {}\n                 }\n             } else {\n+                // Const prop failed, so erase the destination, ensuring that whatever happens\n+                // from here on, does not know about the previous value.\n+                // This is important in case we have\n+                // ```rust\n+                // let mut x = 42;\n+                // x = SOME_MUTABLE_STATIC;\n+                // // x must now be undefined\n+                // ```\n+                // FIXME: we overzealously erase the entire local, because that's easier to\n+                // implement.\n                 trace!(\n-                    \"cannot propagate into {:?}, because the type of the local is generic.\",\n+                    \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n                     place,\n                 );\n                 Self::remove_const(&mut self.ecx, place.local);"}]}