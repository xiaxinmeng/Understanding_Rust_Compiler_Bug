{"sha": "a65af017ca154dcb31dbbd405a75733d0348a25a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NWFmMDE3Y2ExNTRkY2IzMWRiYmQ0MDVhNzU3MzNkMDM0OGEyNWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-18T15:05:52Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-18T15:21:39Z"}, "message": "Remove tri.rs and four.rs\n\nCloses #1892", "tree": {"sha": "bec3b189ad9f5b3b13e943c095c1d43141f6a018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bec3b189ad9f5b3b13e943c095c1d43141f6a018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65af017ca154dcb31dbbd405a75733d0348a25a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65af017ca154dcb31dbbd405a75733d0348a25a", "html_url": "https://github.com/rust-lang/rust/commit/a65af017ca154dcb31dbbd405a75733d0348a25a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65af017ca154dcb31dbbd405a75733d0348a25a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fda7bb672134257c0466cd6b7bbf738963d2a130", "url": "https://api.github.com/repos/rust-lang/rust/commits/fda7bb672134257c0466cd6b7bbf738963d2a130", "html_url": "https://github.com/rust-lang/rust/commit/fda7bb672134257c0466cd6b7bbf738963d2a130"}], "stats": {"total": 562, "additions": 1, "deletions": 561}, "files": [{"sha": "e2565d673068ee2bcf85c1c3cab0190abdee19e8", "filename": "src/libstd/four.rs", "status": "removed", "additions": 0, "deletions": 307, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/fda7bb672134257c0466cd6b7bbf738963d2a130/src%2Flibstd%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda7bb672134257c0466cd6b7bbf738963d2a130/src%2Flibstd%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffour.rs?ref=fda7bb672134257c0466cd6b7bbf738963d2a130", "patch": "@@ -1,307 +0,0 @@\n-// -*- rust -*-\n-\n-#[doc = \"\n-The fourrternary Belnap relevance logic FOUR represented as ADT\n-\n-This allows reasoning with four logic values (true, false, none, both).\n-\n-Implementation: Truth values are represented using a single u8 and\n-all operations are done using bit operations which is fast\n-on current cpus.\n-\"];\n-\n-import tri;\n-\n-export four, none, true, false, both;\n-export not, and, or, xor, implies, implies_materially;\n-export eq, ne, is_true, is_false;\n-export from_str, to_str, all_values, to_trit, to_bit;\n-\n-#[doc = \"\n-The type of fourrternary logic values\n-\n-It may be thought of as  tuple `(y, x)` of two bools\n-\"]\n-type four = u8;\n-\n-const b0: u8  = 1u8;\n-const b1: u8  = 2u8;\n-const b01: u8 = 3u8;\n-\n-#[doc = \"Logic value `(0, 0)` for bottom (neither true or false)\"]\n-const none: four  = 0u8;\n-\n-#[doc = \"Logic value `(0, 1)` for truth\"]\n-const true: four  = 1u8;\n-\n-#[doc = \"Logic value `(1, 0)` for falsehood\"]\n-const false: four = 2u8;\n-\n-#[doc = \"Logic value `(1, 1)` for top (both true and false)\"]\n-const both: four = 3u8;\n-\n-#[doc = \"\n-Negation/Inverse\n-\n-Returns `'(v.y, v.x)`\n-\"]\n-pure fn not(v: four) -> four { ((v << 1u8) | (v >> 1u8)) & b01 }\n-\n-#[doc = \"\n-Conjunction\n-\n-Returns `(a.x | b.x, a.y & b.y)`\n-\"]\n-pure fn and(a: four, b: four) -> four { ((a & b) & b0) | ((a | b) & b1) }\n-\n-#[doc = \"\n-Disjunction\n-\n-Returns `(a.x & b.x, a.y | b.y)`\n-\"]\n-pure fn or(a: four, b: four) -> four { ((a | b) & b0) | ((a & b) & b1) }\n-\n-#[doc = \"\n-Classic exclusive or\n-\n-Returns `or(and(a, not(b)), and(not(a), b))`\n-\"]\n-pure fn xor(a: four, b: four) -> four { or(and(a, not(b)), and(not(a), b)) }\n-\n-#[doc = \"\n-Strong implication (from `a` strongly follows `b`)\n-\n-Returns `( x1 & y2, !x1 | x2)`\n-\"]\n-pure fn implies(a: four, b: four) -> four {\n-    ((a << 1u8) & b & b1) | (((!a) | b) & b0)\n-}\n-\n-#[doc = \"\n-Classic (material) implication in the logic\n-(from `a` materially follows `b`)\n-\n-Returns `or(not(a), b)`\n-\"]\n-pure fn implies_materially(a: four, b: four) -> four { or(not(a), b) }\n-\n-#[doc = \"\n-Returns true if truth values `a` and `b` are indistinguishable in the logic\n-\"]\n-pure fn eq(a: four, b: four) -> bool { a == b }\n-\n-#[doc = \"\n-Returns true if truth values `a` and `b` are distinguishable in the logic\n-\"]\n-pure fn ne(a: four, b: four) -> bool { a != b }\n-\n-#[doc = \"\n-Returns true if `v` represents truth in the logic (is `true` or `both`)\n-\"]\n-pure fn is_true(v: four) -> bool { (v & b0) != 0u8 }\n-\n-#[doc = \"\n-Returns true if `v` represents falsehood in the logic (is `false` or `none`)\n-\"]\n-pure fn is_false(v: four) -> bool { (v & b0) == 0u8 }\n-\n-#[doc = \"Parse logic value from `s`\"]\n-pure fn from_str(s: str) -> four {\n-    alt check s {\n-      \"none\" { none }\n-      \"false\" { four::false }\n-      \"true\" { four::true }\n-      \"both\" { both }\n-    }\n-}\n-\n-#[doc = \"Convert `v` into a string\"]\n-pure fn to_str(v: four) -> str {\n-    // FIXME replace with consts as soon as that works\n-    alt check v {\n-      0u8 { \"none\" }\n-      1u8 { \"true\" }\n-      2u8 { \"false\" }\n-      3u8 { \"both\" }\n-    }\n-}\n-\n-#[doc = \"\n-Iterates over all truth values by passing them to `blk` in an unspecified\n-order\n-\"]\n-fn all_values(blk: fn(v: four)) {\n-    blk(both);\n-    blk(four::true);\n-    blk(four::false);\n-    blk(none);\n-}\n-\n-#[doc = \"\n-Returns an `u8` whose first bit is set if `if_true(v)` holds\n-\"]\n-fn to_bit(v: four) -> u8 { v & b0 }\n-\n-#[doc = \"\n-Returns a trit of `v` (`both` and `none` are both coalesced into\n-`trit::unknown`)\n-\"]\n-fn to_trit(v: four) -> tri::tri { v & (v ^ not(v)) }\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    fn eq1(a: four, b: four) -> bool { four::eq(a , b) }\n-    fn ne1(a: four, b: four) -> bool { four::ne(a , b) }\n-\n-    fn eq2(a: four, b: four) -> bool { eq1( a, b ) && eq1( b, a ) }\n-\n-    #[test]\n-    fn test_four_req_eq() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                assert if a == b { eq1( a, b ) } else { ne1( a, b ) };\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_four_and_symmetry() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                assert eq1( four::and(a ,b), four::and(b, a) );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_four_xor_symmetry() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                assert eq1( four::and(a ,b), four::and(b, a) );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_four_or_symmetry() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                assert eq1( four::or(a ,b), four::or(b, a) );\n-            }\n-        }\n-    }\n-\n-    fn to_tup(v: four) -> (bool, bool) {\n-        alt check v {\n-          0u8 { (false, false) }\n-          1u8 { (false, true) }\n-          2u8 { (true, false) }\n-          3u8 { (true, true) }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_four_not() {\n-        four::all_values { |a|\n-            let (x, y) = to_tup(a);\n-            assert to_tup(four::not(a)) == (y, x);\n-        };\n-    }\n-\n-\n-    #[test]\n-    fn test_four_and() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                let (y1, x1) = to_tup(a);\n-                let (y2, x2) = to_tup(b);\n-                let (y3, x3) = to_tup(four::and(a, b));\n-\n-                assert (x3, y3) == (x1 && x2, y1 || y2);\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn test_four_or() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                let (y1, x1) = to_tup(a);\n-                let (y2, x2) = to_tup(b);\n-                let (y3, x3) = to_tup(four::or(a, b));\n-\n-                assert (x3, y3) == (x1 || x2, y1 && y2);\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn test_four_implies() {\n-        four::all_values { |a|\n-            four::all_values { |b|\n-                let (_, x1) = to_tup(a);\n-                let (y2, x2) = to_tup(b);\n-                let (y3, x3) = to_tup(four::implies(a, b));\n-\n-                assert (x3, y3) == (!x1 || x2, x1 && y2);\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn test_four_is_true() {\n-        assert !four::is_true(four::none);\n-        assert !four::is_true(four::false);\n-        assert four::is_true(four::true);\n-        assert four::is_true(four::both);\n-    }\n-\n-    #[test]\n-    fn test_four_is_false() {\n-        assert four::is_false(four::none);\n-        assert four::is_false(four::false);\n-        assert !four::is_false(four::true);\n-        assert !four::is_false(four::both);\n-    }\n-\n-    #[test]\n-    fn test_four_from_str() {\n-        four::all_values { |v|\n-            assert eq1( v, four::from_str(four::to_str(v)) );\n-        }\n-    }\n-\n-    #[test]\n-    fn test_four_to_str() {\n-        assert four::to_str(four::none) == \"none\";\n-        assert four::to_str(four::false) == \"false\";\n-        assert four::to_str(four::true) == \"true\" ;\n-        assert four::to_str(four::both) == \"both\";\n-    }\n-\n-    #[test]\n-    fn test_four_to_tri() {\n-        assert tri::eq( four::to_trit(four::true), tri::true );\n-        assert tri::eq( four::to_trit(four::false), tri::false );\n-        assert tri::eq( four::to_trit(four::none), tri::unknown );\n-        log(debug, four::to_trit(four::both));\n-        assert tri::eq( four::to_trit(four::both), tri::unknown );\n-    }\n-\n-    #[test]\n-    fn test_four_to_bit() {\n-        four::all_values { |v|\n-            assert four::to_bit(v) ==\n-                if four::is_true(v) { 1u8 } else { 0u8 };\n-        }\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "ab7128f4768a8db0dde2ef60c8c2d474a5ca4739", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a65af017ca154dcb31dbbd405a75733d0348a25a/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a65af017ca154dcb31dbbd405a75733d0348a25a/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=a65af017ca154dcb31dbbd405a75733d0348a25a", "patch": "@@ -14,7 +14,7 @@ use core(vers = \"0.2\");\n import core::*;\n \n export net, uv;\n-export c_vec, four, tri, util;\n+export c_vec, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope, arena;\n export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n@@ -33,8 +33,6 @@ mod uv_hl;\n // Utility modules\n \n mod c_vec;\n-mod four;\n-mod tri;\n mod util;\n \n "}, {"sha": "95eea29dc7e336a5ccc28be4568f666b7e5a2f86", "filename": "src/libstd/tri.rs", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/fda7bb672134257c0466cd6b7bbf738963d2a130/src%2Flibstd%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda7bb672134257c0466cd6b7bbf738963d2a130/src%2Flibstd%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftri.rs?ref=fda7bb672134257c0466cd6b7bbf738963d2a130", "patch": "@@ -1,251 +0,0 @@\n-// -*- rust -*-\n-\n-#[doc = \"\n-ADT for the ternary Kleene logic K3\n-\n-This allows reasoning with three logic values (true, false, unknown).\n-\n-Implementation: Truth values are represented using a single u8 and\n-all operations are done using bit operations which is fast\n-on current cpus.\n-\"];\n-\n-export tri, true, false, unknown;\n-export not, and, or, xor, implies, eq, ne, is_true, is_false;\n-export from_str, to_str, all_values, to_bit;\n-\n-#[doc = \"The type of ternary logic values\"]\n-type tri = u8;\n-\n-const b0: u8  = 1u8;\n-const b1: u8  = 2u8;\n-const b01: u8 = 3u8;\n-\n-#[doc = \"Logic value for unknown (maybe true xor maybe false)\"]\n-const unknown: tri = 0u8;\n-\n-#[doc = \"Logic value for truth\"]\n-const true: tri = 1u8;\n-\n-#[doc = \"Logic value for falsehood\"]\n-const false: tri = 2u8;\n-\n-#[doc = \"Negation/Inverse\"]\n-pure fn not(v: tri) -> tri { ((v << 1u8) | (v >> 1u8)) & b01 }\n-\n-#[doc = \"Conjunction\"]\n-pure fn and(a: tri, b: tri) -> tri { ((a | b) & b1) | ((a & b) & b0) }\n-\n-#[doc = \"Disjunction\"]\n-pure fn or(a: tri, b: tri) -> tri { ((a & b) & b1) | ((a | b) & b0) }\n-\n-#[doc = \"Exclusive or\"]\n-pure fn xor(a: tri, b: tri) -> tri {\n-    let anb = a & b;\n-    let aob = a & not(b);\n-    ret ((anb & b1) | (anb << 1u8) | (aob >> 1u8) | (aob & b0)) & b01;\n-}\n-\n-#[doc = \"Classic implication, i.e. from `a` follows `b`\"]\n-pure fn implies(a: tri, b: tri) -> tri {\n-    ret ((a & b1) >> 1u8) | (b & b0) | ((a << 1u8) & b & b1);\n-}\n-\n-#[doc = \"\n-# Return value\n-\n-true if truth values `a` and `b` are indistinguishable in the logic\n-\"]\n-pure fn eq(a: tri, b: tri) -> bool {  a == b }\n-\n-#[doc = \"\n-# Return value\n-\n-true if truth values `a` and `b` are distinguishable in the logic\n-\"]\n-pure fn ne(a: tri, b: tri) -> bool { a != b }\n-\n-#[doc = \"\n-# Return value\n-\n-true if `v` represents truth in the logic\n-\"]\n-pure fn is_true(v: tri) -> bool { v == tri::true }\n-\n-#[doc = \"\n-# Return value\n-\n-true if `v` represents false in the logic\n-\"]\n-pure fn is_false(v: tri) -> bool { v == tri::false }\n-\n-#[doc = \"\n-# Return value\n-\n-true if `v` represents the unknown state in the logic\n-\"]\n-pure fn is_unknown(v: tri) -> bool { v == unknown }\n-\n-#[doc = \"Parse logic value from `s`\"]\n-pure fn from_str(s: str) -> tri {\n-    alt check s {\n-      \"unknown\" { unknown }\n-      \"true\" { tri::true }\n-      \"false\" { tri::false }\n-    }\n-}\n-\n-#[doc = \"Convert `v` into a string\"]\n-pure fn to_str(v: tri) -> str {\n-    // FIXME replace with consts as soon as that works\n-    alt check v {\n-      0u8 { \"unknown\" }\n-      1u8 { \"true\" }\n-      2u8 { \"false\" }\n-    }\n-}\n-\n-#[doc = \"\n-Iterates over all truth values by passing them to `blk`\n-in an unspecified order\n-\"]\n-fn all_values(blk: fn(v: tri)) {\n-    blk(tri::false);\n-    blk(unknown);\n-    blk(tri::true);\n-}\n-\n-#[doc = \"\n-# Return value\n-\n-An u8 whose first bit is set if `if_true(v)` holds\n-\"]\n-fn to_bit(v: tri) -> u8 { v & b0 }\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    pure fn eq1(a: tri::tri, b: tri::tri) -> bool { tri::eq(a , b) }\n-    pure fn ne1(a: tri::tri, b: tri::tri) -> bool { tri::ne(a , b) }\n-\n-    pure fn eq2(a: tri::tri, b: tri::tri) -> bool {\n-        eq1( a, b ) && eq1( b, a )\n-    }\n-\n-    #[test]\n-    fn test_eq2() {\n-        tri::all_values { |a|\n-            tri::all_values { |b|\n-                assert if a == b { eq1( a, b ) } else { ne1( a, b ) }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_tri_and_symmetry() {\n-        tri::all_values { |a|\n-            tri::all_values { |b|\n-                assert eq1( tri::and(a ,b), tri::and(b, a) );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_tri_or_symmetry() {\n-        tri::all_values { |a|\n-            tri::all_values { |b|\n-                assert eq1( tri::or(a ,b), tri::or(b, a) );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_tri_xor_symmetry() {\n-        tri::all_values { |a|\n-            tri::all_values { |b|\n-                assert eq1( tri::xor(a ,b), tri::xor(b, a) );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_tri_not() {\n-        assert eq2( tri::not(tri::true), tri::false);\n-        assert eq2( tri::not(tri::unknown), tri::unknown);\n-        assert eq2( tri::not(tri::false), tri::true);\n-    }\n-\n-    #[test]\n-    fn test_tri_and() {\n-        assert eq2( tri::and(tri::true, tri::true), tri::true);\n-        assert eq2( tri::and(tri::true, tri::false), tri::false);\n-        assert eq2( tri::and(tri::true, tri::unknown), tri::unknown);\n-        assert eq2( tri::and(tri::false, tri::false), tri::false);\n-        assert eq2( tri::and(tri::false, tri::unknown), tri::false);\n-        assert eq2( tri::and(tri::unknown, tri::unknown), tri::unknown);\n-    }\n-\n-    #[test]\n-    fn test_tri_or() {\n-        assert eq2( tri::or(tri::true, tri::true), tri::true);\n-        assert eq2( tri::or(tri::true, tri::false), tri::true);\n-        assert eq2( tri::or(tri::true, tri::unknown), tri::true);\n-        assert eq2( tri::or(tri::false, tri::false), tri::false);\n-        assert eq2( tri::or(tri::false, tri::unknown), tri::unknown);\n-        assert eq2( tri::or(tri::unknown, tri::unknown), tri::unknown);\n-    }\n-\n-    #[test]\n-    fn test_tri_xor() {\n-        assert eq2( tri::xor(tri::true, tri::true), tri::false);\n-        assert eq2( tri::xor(tri::false, tri::false), tri::false);\n-        assert eq2( tri::xor(tri::true, tri::false), tri::true);\n-        assert eq2( tri::xor(tri::true, tri::unknown), tri::unknown);\n-        assert eq2( tri::xor(tri::false, tri::unknown), tri::unknown);\n-        assert eq2( tri::xor(tri::unknown, tri::unknown), tri::unknown);\n-    }\n-\n-    #[test]\n-    fn test_tri_implies() {\n-        assert eq2( tri::implies(tri::false, tri::false), tri::true);\n-        assert eq2( tri::implies(tri::false, tri::unknown), tri::true);\n-        assert eq2( tri::implies(tri::false, tri::true), tri::true);\n-\n-        assert eq2( tri::implies(tri::unknown, tri::false), tri::unknown);\n-        assert eq2( tri::implies(tri::unknown, tri::unknown), tri::unknown);\n-        assert eq2( tri::implies(tri::unknown, tri::true), tri::true);\n-\n-        assert eq2( tri::implies(tri::true, tri::false), tri::false);\n-        assert eq2( tri::implies(tri::true, tri::unknown), tri::unknown);\n-        assert eq2( tri::implies(tri::true, tri::true), tri::true);\n-    }\n-\n-    #[test]\n-    fn test_tri_from_str() {\n-        tri::all_values { |v|\n-            assert eq2( v, tri::from_str(tri::to_str(v)));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_tri_to_str() {\n-        assert tri::to_str(tri::false) == \"false\";\n-        assert tri::to_str(tri::unknown) == \"unknown\";\n-        assert tri::to_str(tri::true) == \"true\";\n-    }\n-\n-    #[test]\n-    fn test_tri_to_bit() {\n-        tri::all_values { |v|\n-            assert tri::to_bit(v) == if tri::is_true(v) { 1u8 } else { 0u8 };\n-        }\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}]}