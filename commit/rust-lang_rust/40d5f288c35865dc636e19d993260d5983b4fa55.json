{"sha": "40d5f288c35865dc636e19d993260d5983b4fa55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZDVmMjg4YzM1ODY1ZGM2MzZlMTlkOTkzMjYwZDU5ODNiNGZhNTU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-29T10:23:35Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T14:15:27Z"}, "message": "Check that type parameter bounds are interface types\n\nIssue #1227", "tree": {"sha": "7fa887a717e5a108274e55bc24f20f25ee2970e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fa887a717e5a108274e55bc24f20f25ee2970e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40d5f288c35865dc636e19d993260d5983b4fa55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40d5f288c35865dc636e19d993260d5983b4fa55", "html_url": "https://github.com/rust-lang/rust/commit/40d5f288c35865dc636e19d993260d5983b4fa55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40d5f288c35865dc636e19d993260d5983b4fa55/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ea175f23fb3aa35f430d55595b9564a5ab632f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ea175f23fb3aa35f430d55595b9564a5ab632f8", "html_url": "https://github.com/rust-lang/rust/commit/7ea175f23fb3aa35f430d55595b9564a5ab632f8"}], "stats": {"total": 141, "additions": 96, "deletions": 45}, "files": [{"sha": "8271c5d984929aa47aa7bb2565e11f59a19cbaff", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=40d5f288c35865dc636e19d993260d5983b4fa55", "patch": "@@ -129,11 +129,8 @@ fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n \n fn item_ty_param_count(item: ebml::doc) -> uint {\n     let n = 0u;\n-    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n-        for byte in ebml::doc_data(p) {\n-            if byte as char == '.' { n += 1u; }\n-        }\n-    }\n+    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n+                      {|_p| n += 1u; });\n     n\n }\n "}, {"sha": "0ecf2095e7e9886eae26f728b0de9d700f752661", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=40d5f288c35865dc636e19d993260d5983b4fa55", "patch": "@@ -202,9 +202,17 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         st.pos = st.pos + 1u;\n         ret ty::mk_tag(st.tcx, def, params);\n       }\n+      'x' {\n+        assert (next(st) as char == '[');\n+        let def = parse_def(st, sd);\n+        let params: [ty::t] = [];\n+        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n+        st.pos = st.pos + 1u;\n+        ret ty::mk_iface(st.tcx, def, params);\n+      }\n       'p' {\n-        let bounds = parse_bounds(st, sd);\n-        ret ty::mk_param(st.tcx, parse_int(st) as uint, bounds);\n+        let did = parse_def(st, sd);\n+        ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, sd)); }\n@@ -401,8 +409,7 @@ fn parse_bounds_data(data: @[u8], crate_num: int, sd: str_def, tcx: ty::ctxt)\n \n fn parse_bounds(st: @pstate, sd: str_def) -> @[ty::param_bound] {\n     let bounds = [];\n-    while peek(st) as char == '.' {\n-        next(st);\n+    while peek(st) != 0u8 {\n         bounds += [alt next(st) as char {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }"}, {"sha": "73d444727234951998f8e698ee71f6fda31ba843", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=40d5f288c35865dc636e19d993260d5983b4fa55", "patch": "@@ -126,6 +126,13 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         for t: ty::t in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n+      ty::ty_iface(def, tys) {\n+        w.write_str(\"x[\");\n+        w.write_str(cx.ds(def));\n+        w.write_char('|');\n+        for t: ty::t in tys { enc_ty(w, cx, t); }\n+        w.write_char(']');\n+      }\n       ty::ty_tup(ts) {\n         w.write_str(\"T[\");\n         for t in ts { enc_ty(w, cx, t); }\n@@ -176,9 +183,10 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n       }\n-      ty::ty_param(id, bounds) {\n+      ty::ty_param(id, did) {\n         w.write_char('p');\n-        enc_bounds(w, cx, bounds);\n+        w.write_str(cx.ds(did));\n+        w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n       ty::ty_type. { w.write_char('Y'); }\n@@ -265,7 +273,6 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n \n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n     for bound in *bs {\n-        w.write_char('.');\n         alt bound {\n           ty::bound_send. { w.write_char('S'); }\n           ty::bound_copy. { w.write_char('C'); }"}, {"sha": "99a112321c8f4d4970da231c8b0244a7682aaaa3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=40d5f288c35865dc636e19d993260d5983b4fa55", "patch": "@@ -4658,7 +4658,8 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        ty_param_substs += [ty::mk_param(ccx.tcx, i, @[])];\n+        ty_param_substs += [ty::mk_param(ccx.tcx, i,\n+                                         ast_util::local_def(tp.id))];\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(ccx, variant.node.id);"}, {"sha": "f893801d2f0e97b83a1ba239b2ecea5db5ade513", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=40d5f288c35865dc636e19d993260d5983b4fa55", "patch": "@@ -218,7 +218,7 @@ type ctxt =\n       needs_drop_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n-      tag_var_cache: hashmap<ast::def_id, @[variant_info]>,\n+      tag_var_cache: hashmap<def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n       ty_param_bounds: hashmap<def_id, @[param_bound]>};\n \n@@ -268,7 +268,7 @@ tag sty {\n     ty_tup([t]);\n     ty_var(int); // type variable\n \n-    ty_param(uint, @[param_bound]); // fn/tag type param\n+    ty_param(uint, def_id); // fn/tag type param\n \n     ty_type; // type_desc*\n     ty_send_type; // type_desc* that has been cloned into exchange heap\n@@ -624,7 +624,7 @@ fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n \n fn mk_var(cx: ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n \n-fn mk_param(cx: ctxt, n: uint, k: @[param_bound]) -> t {\n+fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n     ret gen_ty(cx, ty_param(n, k));\n }\n \n@@ -722,7 +722,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n \n tag fold_mode {\n     fm_var(fn@(int) -> t);\n-    fm_param(fn@(uint, @[param_bound]) -> t);\n+    fm_param(fn@(uint, def_id) -> t);\n     fm_general(fn@(t) -> t);\n }\n \n@@ -813,8 +813,8 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_var(id) {\n         alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n       }\n-      ty_param(id, k) {\n-        alt fld { fm_param(folder) { ty = folder(id, k); } _ {/* no-op */ } }\n+      ty_param(id, did) {\n+        alt fld { fm_param(folder) { ty = folder(id, did); } _ {/* no-op */ } }\n       }\n     }\n \n@@ -1083,7 +1083,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n       // Resources are always noncopyable.\n       ty_res(did, inner, tps) { kind_noncopyable }\n-      ty_param(_, bounds) { param_bounds_to_kind(bounds) }\n+      ty_param(_, did) { param_bounds_to_kind(cx.ty_param_bounds.get(did)) }\n       ty_constr(t, _) { type_kind(cx, t) }\n     };\n \n@@ -1131,7 +1131,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     }\n }\n \n-pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool {\n+pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n \n     /* type_structurally_contains can't be declared pure\n     because it takes a function argument. But it should be\n@@ -1141,15 +1141,9 @@ pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool {\n     actually checkable. It seems to me like a lot of properties\n     that the type context tracks about types should be immutable.)\n     */\n-    unchecked{\n-        type_structurally_contains(cx, ty,\n-                                   fn (sty: sty) -> bool {\n-                                       ret alt sty {\n-                                             ty_param(_, _) { true }\n-                                             _ { false }\n-                                           };\n-                                   })\n-    }\n+    type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n+        alt sty { ty_param(_, _) { true } _ { false }}\n+    })\n }\n \n // Returns true for noncopyable types and types where a copy of a value can be\n@@ -2205,7 +2199,14 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_param(_, _) { ret struct_cmp(cx, expected, actual); }\n+          ty::ty_param(expected_n, _) {\n+            alt struct(cx.tcx, actual) {\n+              ty::ty_param(actual_n, _) when expected_n == actual_n {\n+                ret ures_ok(expected);\n+              }\n+              _ { ret ures_err(terr_mismatch); }\n+            }\n+          }\n           ty::ty_tag(expected_id, expected_tps) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_tag(actual_id, actual_tps) {\n@@ -2627,8 +2628,7 @@ fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn@() -> int, typ: t,\n     let i = 0u;\n     while i < ty_param_count { *param_var_ids += [next_ty_var()]; i += 1u; }\n     fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n-              _next_ty_var: fn@() -> int, index: uint,\n-              _bounds: @[param_bound]) -> t {\n+              _next_ty_var: fn@() -> int, index: uint, _did: def_id) -> t {\n         if index < vec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids[index]);\n         } else {\n@@ -2647,9 +2647,8 @@ fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn@() -> int, typ: t,\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n-    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint,\n-                   _bounds: @[param_bound])\n-       -> t {\n+    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _did: def_id)\n+        -> t {\n         // FIXME: bounds check can fail\n         ret substs[idx];\n     }"}, {"sha": "313023ba108f661bd4dfb1a552622df7a9d08e0a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d5f288c35865dc636e19d993260d5983b4fa55/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=40d5f288c35865dc636e19d993260d5983b4fa55", "patch": "@@ -343,7 +343,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n           some(ast::def_native_ty(id)) { typ = getter(tcx, mode, id).ty; }\n           some(ast::def_ty_param(id, n)) {\n-            typ = ty::mk_param(tcx, n, tcx.ty_param_bounds.get(id));\n+            typ = ty::mk_param(tcx, n, id);\n           }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -625,8 +625,8 @@ fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n     -> {bounds: [@[ty::param_bound]], params: [ty::t]} {\n     let i = 0u, bounds = ty_param_bounds(tcx, m_collect, atps);\n     {bounds: bounds,\n-     params: vec::map(atps, {|_atp|\n-         let t = ty::mk_param(tcx, i, bounds[i]);\n+     params: vec::map(atps, {|atp|\n+         let t = ty::mk_param(tcx, i, local_def(atp.id));\n          i += 1u;\n          t\n      })}\n@@ -2666,13 +2666,16 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_fn(decl, _, body) {\n+      ast::item_fn(decl, tps, body) {\n+        check_ty_params(ccx, tps);\n         check_fn(ccx, ast::proto_bare, decl, body, it.id, none);\n       }\n-      ast::item_res(decl, _, body, dtor_id, _) {\n+      ast::item_res(decl, tps, body, dtor_id, _) {\n+        check_ty_params(ccx, tps);\n         check_fn(ccx, ast::proto_bare, decl, body, dtor_id, none);\n       }\n-      ast::item_obj(ob, _, _) {\n+      ast::item_obj(ob, tps, _) {\n+        check_ty_params(ccx, tps);\n         // We're entering an object, so gather up the info we need.\n         ccx.self_infos += [self_obj(ob.fields,\n                                     ccx.tcx.tcache.get(local_def(it.id)).ty)];\n@@ -2681,9 +2684,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         // Now remove the info from the stack.\n         vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(_, ifce, ty, ms) {\n+      ast::item_impl(tps, ifce, ty, ms) {\n+        check_ty_params(ccx, tps);\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n         let my_methods = vec::map(ms, {|m|\n+            check_ty_params(ccx, m.tps);\n             check_method(ccx, m);\n             ty_of_method(ccx.tcx, m_check, m)\n         });\n@@ -2717,10 +2722,43 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           _ {}\n         }\n       }\n+      ast::item_iface(tps, _) | ast::item_ty(_, tps) | ast::item_tag(_, tps) {\n+        check_ty_params(ccx, tps);\n+      }\n       _ {/* nothing to do */ }\n     }\n }\n \n+fn check_native_item(ccx: @crate_ctxt, it: @ast::native_item) {\n+    alt it.node {\n+      ast::native_item_fn(_, tps) { check_ty_params(ccx, tps); }\n+      _ {}\n+    }\n+}\n+\n+fn check_ty_params(ccx: @crate_ctxt, tps: [ast::ty_param]) {\n+    for tp in tps {\n+        let i = 0u;\n+        for bound in *tp.bounds {\n+            alt bound {\n+              ast::bound_iface(at) {\n+                let tbound = ccx.tcx.ty_param_bounds.get(local_def(tp.id))[i];\n+                let bound_ty = alt tbound { ty::bound_iface(t) { t } };\n+                alt ty::struct(ccx.tcx, bound_ty) {\n+                  ty::ty_iface(_, _) {}\n+                  _ {\n+                    ccx.tcx.sess.span_err(at.span, \"type parameter bounds \\\n+                                                    must be interface types\");\n+                  }\n+                }\n+              }\n+              _ {}\n+            }\n+            i += 1u;\n+        }\n+    }\n+}\n+\n fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n       ty::ty_vec(mt) {\n@@ -2778,8 +2816,10 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 method_map: std::map::new_int_hash(),\n                 tcx: tcx};\n     let visit =\n-        visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _)\n-                                      with *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _),\n+                                   visit_native_item:\n+                                       bind check_native_item(ccx, _)\n+                                   with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();"}]}