{"sha": "71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "node_id": "C_kwDOAAsO6NoAKDcxYjBlOTViODIxOWUzYTkzMGUxMDA5ZDRjNGZiZDFlYTM3OTljZTY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-28T11:08:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-28T11:08:35Z"}, "message": "Rollup merge of #99846 - TaKO8Ki:refactor-UnresolvedImportError, r=davidtwco\n\nRefactor `UnresolvedImportError`\n\nThis patch changes the type of `note` field in `UnresolvedImportError` to `Option<String>`.", "tree": {"sha": "0b398713281af3eaab8ee018b275e9bab9a163a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b398713281af3eaab8ee018b275e9bab9a163a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi4m4zCRBK7hj4Ov3rIwAAfRAIACFMomKrpKY9ypFahhbj19TP\nIvDp3tmDGqgitD0TMJs91t+rUXwGyTxuxXtfcK+QLkrCFzGAbDxmZZKJdAExLkPo\nC2Cx6vrPuYsTYxL9XOyVeE0FZY+85s53Smn1ehxlEnJ5ZI3KoyXj3UM6r5hkwz83\nXYTAmZTY9gNx7qfqNexUA4IAJprh1/RST1fyrfSMraRQtVJp+KQY+vmPXs26F6fZ\n8oDSEXyweyZfjkuE9LYZbkSIs50Tvh5WPaacJaGLa/MDHfXB9RYvhv6AKQ0w6Suw\nCnDvAZ+li7qRmfGqpQOFUdszO6ytGBRMOeeF7/gkQYOd7rzOrZ+QBifur3VSjyw=\n=1Jl/\n-----END PGP SIGNATURE-----\n", "payload": "tree 0b398713281af3eaab8ee018b275e9bab9a163a0\nparent 3a37c9a47eaf55cc76f313331f375559993b3ab1\nparent 2ce42eb79cb66d4e1fc80cdba9547b2603824537\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1659006515 +0530\ncommitter GitHub <noreply@github.com> 1659006515 +0530\n\nRollup merge of #99846 - TaKO8Ki:refactor-UnresolvedImportError, r=davidtwco\n\nRefactor `UnresolvedImportError`\n\nThis patch changes the type of `note` field in `UnresolvedImportError` to `Option<String>`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "html_url": "https://github.com/rust-lang/rust/commit/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a37c9a47eaf55cc76f313331f375559993b3ab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a37c9a47eaf55cc76f313331f375559993b3ab1", "html_url": "https://github.com/rust-lang/rust/commit/3a37c9a47eaf55cc76f313331f375559993b3ab1"}, {"sha": "2ce42eb79cb66d4e1fc80cdba9547b2603824537", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce42eb79cb66d4e1fc80cdba9547b2603824537", "html_url": "https://github.com/rust-lang/rust/commit/2ce42eb79cb66d4e1fc80cdba9547b2603824537"}], "stats": {"total": 48, "additions": 21, "deletions": 27}, "files": [{"sha": "a14a7fc0610cb989d99cc314be8a103e8b214e6e", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "patch": "@@ -1677,7 +1677,6 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Is this a possibly malformed start of a `macro_rules! foo` item definition?\n-\n     fn is_macro_rules_item(&mut self) -> IsMacroRulesItem {\n         if self.check_keyword(kw::MacroRules) {\n             let macro_rules_span = self.token.span;"}, {"sha": "22a307a15edc095bfd98dcb8e2a50d46890e0312", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "patch": "@@ -2023,7 +2023,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n         match (path.get(0), path.get(1)) {\n@@ -2058,12 +2058,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n         let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n+        if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n \n     /// Suggests a missing `crate::` if that resolves to an correct module.\n@@ -2077,20 +2077,20 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n         let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n                 path,\n-                vec![\n+                Some(\n                     \"`use` statements changed in Rust 2018; read more at \\\n                      <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n                      clarity.html>\"\n                         .to_string(),\n-                ],\n+                ),\n             ))\n         } else {\n             None\n@@ -2108,12 +2108,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n         let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n+        if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n \n     /// Suggests a missing external crate name if that resolves to an correct module.\n@@ -2130,7 +2130,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         if path[1].ident.span.rust_2015() {\n             return None;\n         }\n@@ -2151,7 +2151,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 name, path, result\n             );\n             if let PathResult::Module(..) = result {\n-                return Some((path, Vec::new()));\n+                return Some((path, None));\n             }\n         }\n \n@@ -2175,7 +2175,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         import: &'b Import<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n-    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n+    ) -> Option<(Option<Suggestion>, Option<String>)> {\n         let ModuleOrUniformRoot::Module(mut crate_module) = module else {\n             return None;\n         };\n@@ -2287,12 +2287,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 String::from(\"a macro with this name exists at the root of the crate\"),\n                 Applicability::MaybeIncorrect,\n             ));\n-            let note = vec![\n-                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n-                 at the root of the crate instead of the module where it is defined\"\n-                    .to_string(),\n-            ];\n-            Some((suggestion, note))\n+            Some((suggestion, Some(\"this could be because a macro annotated with `#[macro_export]` will be exported \\\n+            at the root of the crate instead of the module where it is defined\"\n+               .to_string())))\n         } else {\n             None\n         }"}, {"sha": "b89273990d8e58294df0af188e7c5063233941c3", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=71b0e95b8219e3a930e1009d4c4fbd1ea3799ce6", "patch": "@@ -336,7 +336,7 @@ impl<'a> Resolver<'a> {\n struct UnresolvedImportError {\n     span: Span,\n     label: Option<String>,\n-    note: Vec<String>,\n+    note: Option<String>,\n     suggestion: Option<Suggestion>,\n }\n \n@@ -427,7 +427,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let err = UnresolvedImportError {\n                     span: import.span,\n                     label: None,\n-                    note: Vec::new(),\n+                    note: None,\n                     suggestion: None,\n                 };\n                 if path.contains(\"::\") {\n@@ -463,10 +463,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n \n-        if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n-            for message in note {\n-                diag.note(message);\n-            }\n+        if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n+            diag.note(note);\n         }\n \n         for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n@@ -644,7 +642,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         None => UnresolvedImportError {\n                             span,\n                             label: Some(label),\n-                            note: Vec::new(),\n+                            note: None,\n                             suggestion,\n                         },\n                     };\n@@ -686,7 +684,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         return Some(UnresolvedImportError {\n                             span: import.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: Vec::new(),\n+                            note: None,\n                             suggestion: None,\n                         });\n                     }\n@@ -830,7 +828,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let (suggestion, note) =\n                     match self.check_for_module_export_macro(import, module, ident) {\n                         Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n-                        _ => (lev_suggestion, Vec::new()),\n+                        _ => (lev_suggestion, None),\n                     };\n \n                 let label = match module {"}]}