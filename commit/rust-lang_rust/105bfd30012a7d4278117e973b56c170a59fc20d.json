{"sha": "105bfd30012a7d4278117e973b56c170a59fc20d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNWJmZDMwMDEyYTdkNDI3ODExN2U5NzNiNTZjMTcwYTU5ZmMyMGQ=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-01-31T11:23:26Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-01-31T11:23:26Z"}, "message": "Reference: Purge `isize` from non-memory-related examples\n\nAlso explain integer fallback to `i32`.", "tree": {"sha": "af3970643d817300193e7aaf9330d00d9f76566e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af3970643d817300193e7aaf9330d00d9f76566e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/105bfd30012a7d4278117e973b56c170a59fc20d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/105bfd30012a7d4278117e973b56c170a59fc20d", "html_url": "https://github.com/rust-lang/rust/commit/105bfd30012a7d4278117e973b56c170a59fc20d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/105bfd30012a7d4278117e973b56c170a59fc20d/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "474b324eda10440d6568ef872a7307d38e7de95b", "url": "https://api.github.com/repos/rust-lang/rust/commits/474b324eda10440d6568ef872a7307d38e7de95b", "html_url": "https://github.com/rust-lang/rust/commit/474b324eda10440d6568ef872a7307d38e7de95b"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "778d98a6ae49d3341b838e965c9ea2053fda2425", "filename": "src/doc/reference.md", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/105bfd30012a7d4278117e973b56c170a59fc20d/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/105bfd30012a7d4278117e973b56c170a59fc20d/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=105bfd30012a7d4278117e973b56c170a59fc20d", "patch": "@@ -268,7 +268,7 @@ cases mentioned in [Number literals](#number-literals) below.\n ##### Suffixes\n | Integer | Floating-point |\n |---------|----------------|\n-| `is` (`isize`), `us` (`usize`), `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64` | `f32`, `f64` |\n+| `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `is` (`isize`), `us` (`usize`) | `f32`, `f64` |\n \n #### Character and string literals\n \n@@ -468,27 +468,29 @@ Like any literal, an integer literal may be followed (immediately,\n without any spaces) by an _integer suffix_, which forcibly sets the\n type of the literal. There are 10 valid values for an integer suffix:\n \n-* The `is` and `us` suffixes give the literal type `isize` or `usize`,\n-  respectively.\n * Each of the signed and unsigned machine types `u8`, `i8`,\n   `u16`, `i16`, `u32`, `i32`, `u64` and `i64`\n   give the literal the corresponding machine type.\n+* The `is` and `us` suffixes give the literal type `isize` or `usize`,\n+  respectively.\n \n The type of an _unsuffixed_ integer literal is determined by type inference.\n If an integer type can be _uniquely_ determined from the surrounding program\n context, the unsuffixed integer literal has that type. If the program context\n-underconstrains the type, it is considered a static type error; if the program\n-context overconstrains the type, it is also considered a static type error.\n+underconstrains the type, it defaults to the signed 32-bit integer `i32`; if\n+the program context overconstrains the type, it is considered a static type\n+error.\n \n Examples of integer literals of various forms:\n \n ```\n-123is;                             // type isize\n-123us;                             // type usize\n-123_us;                            // type usize\n+123i32;                            // type i32\n+123u32;                            // type u32\n+123_u32;                           // type u32\n 0xff_u8;                           // type u8\n 0o70_i16;                          // type i16\n 0b1111_1111_1001_0000_i32;         // type i32\n+0us;                               // type usize\n ```\n \n ##### Floating-point literals\n@@ -1135,8 +1137,8 @@ used as a type name.\n \n When a generic function is referenced, its type is instantiated based on the\n context of the reference. For example, calling the `iter` function defined\n-above on `[1, 2]` will instantiate type parameter `T` with `isize`, and require\n-the closure parameter to have type `fn(isize)`.\n+above on `[1, 2]` will instantiate type parameter `T` with `i32`, and require\n+the closure parameter to have type `fn(i32)`.\n \n The type parameters can also be explicitly supplied in a trailing\n [path](#paths) component after the function name. This might be necessary if\n@@ -2746,9 +2748,9 @@ constant expression that can be evaluated at compile time, such as a\n [literal](#literals) or a [static item](#static-items).\n \n ```\n-[1is, 2, 3, 4];\n+[1, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n-[0is; 128];            // array with 128 zeros\n+[0; 128];              // array with 128 zeros\n [0u8, 0u8, 0u8, 0u8];\n ```\n \n@@ -2921,7 +2923,7 @@ moves](#moved-and-copied-types) its right-hand operand to its left-hand\n operand.\n \n ```\n-# let mut x = 0is;\n+# let mut x = 0;\n # let y = 0;\n \n x = y;\n@@ -3307,11 +3309,11 @@ fn main() {\n ```\n \n Patterns can also dereference pointers by using the `&`, `&mut` and `box`\n-symbols, as appropriate. For example, these two matches on `x: &isize` are\n+symbols, as appropriate. For example, these two matches on `x: &i32` are\n equivalent:\n \n ```\n-# let x = &3is;\n+# let x = &3;\n let y = match *x { 0 => \"zero\", _ => \"some\" };\n let z = match x { &0 => \"zero\", _ => \"some\" };\n \n@@ -3332,7 +3334,7 @@ Multiple match patterns may be joined with the `|` operator. A range of values\n may be specified with `...`. For example:\n \n ```\n-# let x = 2is;\n+# let x = 2;\n \n let message = match x {\n   0 | 1  => \"not many\",\n@@ -3673,16 +3675,16 @@ The type of a closure mapping an input of type `A` to an output of type `B` is\n An example of creating and calling a closure:\n \n ```rust\n-let captured_var = 10is;\n+let captured_var = 10;\n \n let closure_no_args = |&:| println!(\"captured_var={}\", captured_var);\n \n-let closure_args = |&: arg: isize| -> isize {\n+let closure_args = |&: arg: i32| -> i32 {\n   println!(\"captured_var={}, arg={}\", captured_var, arg);\n   arg // Note lack of semicolon after 'arg'\n };\n \n-fn call_closure<F: Fn(), G: Fn(isize) -> isize>(c1: F, c2: G) {\n+fn call_closure<F: Fn(), G: Fn(i32) -> i32>(c1: F, c2: G) {\n   c1();\n   c2(2);\n }\n@@ -3714,7 +3716,7 @@ trait Printable {\n   fn stringify(&self) -> String;\n }\n \n-impl Printable for isize {\n+impl Printable for i32 {\n   fn stringify(&self) -> String { self.to_string() }\n }\n \n@@ -3723,7 +3725,7 @@ fn print(a: Box<Printable>) {\n }\n \n fn main() {\n-   print(Box::new(10is) as Box<Printable>);\n+   print(Box::new(10) as Box<Printable>);\n }\n ```\n "}]}