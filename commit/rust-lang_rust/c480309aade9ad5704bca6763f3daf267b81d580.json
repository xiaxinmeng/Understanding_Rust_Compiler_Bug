{"sha": "c480309aade9ad5704bca6763f3daf267b81d580", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ODAzMDlhYWRlOWFkNTcwNGJjYTY3NjNmM2RhZjI2N2I4MWQ1ODA=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T04:35:33Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T04:35:33Z"}, "message": "Get correct span", "tree": {"sha": "498fa57cf13c37e410a0dc76e08e73177014e9dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/498fa57cf13c37e410a0dc76e08e73177014e9dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c480309aade9ad5704bca6763f3daf267b81d580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c480309aade9ad5704bca6763f3daf267b81d580", "html_url": "https://github.com/rust-lang/rust/commit/c480309aade9ad5704bca6763f3daf267b81d580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c480309aade9ad5704bca6763f3daf267b81d580/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c20bf454c96c79bdd8ceb3a3fdb9d099fcdbfe74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c20bf454c96c79bdd8ceb3a3fdb9d099fcdbfe74", "html_url": "https://github.com/rust-lang/rust/commit/c20bf454c96c79bdd8ceb3a3fdb9d099fcdbfe74"}], "stats": {"total": 42, "additions": 24, "deletions": 18}, "files": [{"sha": "eafa537c309ee946238c1d78b770fe4d018cde74", "filename": "src/chains.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c480309aade9ad5704bca6763f3daf267b81d580/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c480309aade9ad5704bca6763f3daf267b81d580/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c480309aade9ad5704bca6763f3daf267b81d580", "patch": "@@ -65,6 +65,7 @@\n //!            .qux\n //! ```\n \n+use codemap::SpanUtils;\n use config::IndentStyle;\n use expr::rewrite_call;\n use macros::convert_try_mac;\n@@ -137,8 +138,8 @@ impl ChainItemKind {\n         }\n     }\n \n-    fn from_ast(expr: &ast::Expr) -> (ChainItemKind, Span) {\n-        match expr.node {\n+    fn from_ast(context: &RewriteContext, expr: &ast::Expr) -> (ChainItemKind, Span) {\n+        let (kind, span) = match expr.node {\n             ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n                 let types = if let Some(ref generic_args) = segment.args {\n                     if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n@@ -149,19 +150,25 @@ impl ChainItemKind {\n                 } else {\n                     vec![]\n                 };\n+                let span = mk_sp(expressions[0].span.hi(), expr.span.hi());\n                 let kind = ChainItemKind::MethodCall(segment.clone(), types, expressions.clone());\n-                (kind, expr.span)\n+                (kind, span)\n             }\n             ast::ExprKind::Field(ref nested, field) => {\n                 let kind = if Self::is_tup_field_access(expr) {\n                     ChainItemKind::TupleField(field, Self::is_tup_field_access(nested))\n                 } else {\n                     ChainItemKind::StructField(field)\n                 };\n-                (kind, expr.span)\n+                let span = mk_sp(nested.span.hi(), field.span.hi());\n+                (kind, span)\n             }\n-            _ => (ChainItemKind::Parent(expr.clone()), expr.span),\n-        }\n+            _ => return (ChainItemKind::Parent(expr.clone()), expr.span),\n+        };\n+\n+        // Remove comments from the span.\n+        let lo = context.snippet_provider.span_before(span, \".\");\n+        (kind, mk_sp(lo, span.hi()))\n     }\n }\n \n@@ -183,8 +190,8 @@ impl Rewrite for ChainItem {\n }\n \n impl ChainItem {\n-    fn new(expr: &ast::Expr, tries: usize) -> ChainItem {\n-        let (kind, span) = ChainItemKind::from_ast(expr);\n+    fn new(context: &RewriteContext, expr: &ast::Expr, tries: usize) -> ChainItem {\n+        let (kind, span) = ChainItemKind::from_ast(context, expr);\n         ChainItem { kind, tries, span }\n     }\n \n@@ -196,22 +203,17 @@ impl ChainItem {\n         context: &RewriteContext,\n         shape: Shape,\n     ) -> Option<String> {\n-        let (lo, type_str) = if types.is_empty() {\n-            (args[0].span.hi(), String::new())\n+        let type_str = if types.is_empty() {\n+            String::new()\n         } else {\n             let type_list = types\n                 .iter()\n                 .map(|ty| ty.rewrite(context, shape))\n                 .collect::<Option<Vec<_>>>()?;\n \n-            let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n-\n-            (types.last().unwrap().span().hi(), type_str)\n+            format!(\"::<{}>\", type_list.join(\", \"))\n         };\n-\n         let callee_str = format!(\".{}{}\", method_name, type_str);\n-        let span = mk_sp(lo, span.hi());\n-\n         rewrite_call(context, &callee_str, &args[1..], span, shape)\n     }\n }\n@@ -233,7 +235,7 @@ impl Chain {\n             match subexpr.node {\n                 ast::ExprKind::Try(_) => sub_tries += 1,\n                 _ => {\n-                    children.push(ChainItem::new(subexpr, sub_tries));\n+                    children.push(ChainItem::new(context, subexpr, sub_tries));\n                     sub_tries = 0;\n                 }\n             }"}, {"sha": "2e73fdcec135be55af54024ed7a193634d191824", "filename": "src/codemap.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c480309aade9ad5704bca6763f3daf267b81d580/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c480309aade9ad5704bca6763f3daf267b81d580/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=c480309aade9ad5704bca6763f3daf267b81d580", "patch": "@@ -51,7 +51,11 @@ impl<'a> SpanUtils for SnippetProvider<'a> {\n     }\n \n     fn span_before(&self, original: Span, needle: &str) -> BytePos {\n-        self.opt_span_before(original, needle).expect(\"bad span\")\n+        self.opt_span_before(original, needle).expect(&format!(\n+            \"bad span: {}: {}\",\n+            needle,\n+            self.span_to_snippet(original).unwrap()\n+        ))\n     }\n \n     fn opt_span_after(&self, original: Span, needle: &str) -> Option<BytePos> {"}]}