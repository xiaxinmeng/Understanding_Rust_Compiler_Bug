{"sha": "69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YTIzN2VkN2I0MDIyMWMwZjBiZjhkYzM3NzRmZGRjMzgzMmY2MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-23T11:46:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-23T11:46:41Z"}, "message": "auto merge of #7944 : blake2-ppc/rust/dlist-move-nodes, r=bblum\n\nFactor out internal methods to pop/push list nodes so that .merge() and .rotate_to_front(), .rotate_to_back() (new methods) can be implemented without allocating nodes.\r\n\r\nWith that, some cleanup changes to DList use of Option, and adding a missing Encodable implementation.", "tree": {"sha": "63fee2882353d025cdcce5c80eb50e0f0661f743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63fee2882353d025cdcce5c80eb50e0f0661f743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "html_url": "https://github.com/rust-lang/rust/commit/69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69a237ed7b40221c0f0bf8dc3774fddc3832f62d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfdb72dbbec1a26010b9222db1607e323bb33699", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfdb72dbbec1a26010b9222db1607e323bb33699", "html_url": "https://github.com/rust-lang/rust/commit/dfdb72dbbec1a26010b9222db1607e323bb33699"}, {"sha": "6e24b750e248078a0b3c86203a2e2a01cbf3cc23", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e24b750e248078a0b3c86203a2e2a01cbf3cc23", "html_url": "https://github.com/rust-lang/rust/commit/6e24b750e248078a0b3c86203a2e2a01cbf3cc23"}], "stats": {"total": 337, "additions": 199, "deletions": 138}, "files": [{"sha": "77060c4b11e34717b49bcf6cc4103ed6f3398b2e", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 186, "deletions": 138, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/69a237ed7b40221c0f0bf8dc3774fddc3832f62d/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a237ed7b40221c0f0bf8dc3774fddc3832f62d/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "patch": "@@ -23,7 +23,6 @@\n // the reverse direction.\n \n use std::cast;\n-use std::cmp;\n use std::ptr;\n use std::util;\n use std::iterator::{FromIterator, InvertIterator};\n@@ -102,6 +101,12 @@ impl<T> Clone for Rawlink<T> {\n     }\n }\n \n+impl<T> Node<T> {\n+    fn new(v: T) -> Node<T> {\n+        Node{value: v, next: None, prev: Rawlink::none()}\n+    }\n+}\n+\n /// Set the .prev field on `next`, then return `Some(next)`\n fn link_with_prev<T>(mut next: ~Node<T>, prev: Rawlink<Node<T>>) -> Link<T> {\n     next.prev = prev;\n@@ -131,6 +136,66 @@ impl<T> Mutable for DList<T> {\n     }\n }\n \n+// private methods\n+impl<T> DList<T> {\n+    /// Add a Node first in the list\n+    #[inline]\n+    fn push_front_node(&mut self, mut new_head: ~Node<T>) {\n+        match self.list_head {\n+            None => {\n+                self.list_tail = Rawlink::some(new_head);\n+                self.list_head = link_with_prev(new_head, Rawlink::none());\n+            }\n+            Some(ref mut head) => {\n+                new_head.prev = Rawlink::none();\n+                head.prev = Rawlink::some(new_head);\n+                util::swap(head, &mut new_head);\n+                head.next = Some(new_head);\n+            }\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the first Node and return it, or None if the list is empty\n+    #[inline]\n+    fn pop_front_node(&mut self) -> Option<~Node<T>> {\n+        do self.list_head.take().map_consume |mut front_node| {\n+            self.length -= 1;\n+            match front_node.next.take() {\n+                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n+                None => self.list_tail = Rawlink::none()\n+            }\n+            front_node\n+        }\n+    }\n+\n+    /// Add a Node last in the list\n+    #[inline]\n+    fn push_back_node(&mut self, mut new_tail: ~Node<T>) {\n+        match self.list_tail.resolve() {\n+            None => return self.push_front_node(new_tail),\n+            Some(tail) => {\n+                self.list_tail = Rawlink::some(new_tail);\n+                tail.next = link_with_prev(new_tail, Rawlink::some(tail));\n+            }\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the last Node and return it, or None if the list is empty\n+    #[inline]\n+    fn pop_back_node(&mut self) -> Option<~Node<T>> {\n+        do self.list_tail.resolve().map_consume_default(None) |tail| {\n+            self.length -= 1;\n+            self.list_tail = tail.prev;\n+            match tail.prev.resolve() {\n+                None => self.list_head.take(),\n+                Some(tail_prev) => tail_prev.next.take()\n+            }\n+        }\n+    }\n+}\n+\n impl<T> Deque<T> for DList<T> {\n     /// Provide a reference to the front element, or None if the list is empty\n     #[inline]\n@@ -156,83 +221,32 @@ impl<T> Deque<T> for DList<T> {\n         self.list_tail.resolve().map_mut(|tail| &mut tail.value)\n     }\n \n-    /// Add an element last in the list\n+    /// Add an element first in the list\n     ///\n     /// O(1)\n-    fn push_back(&mut self, elt: T) {\n-        match self.list_tail.resolve() {\n-            None => return self.push_front(elt),\n-            Some(tail) => {\n-                let mut new_tail = ~Node{value: elt, next: None, prev: self.list_tail};\n-                self.list_tail = Rawlink::some(new_tail);\n-                tail.next = Some(new_tail);\n-            }\n-        }\n-        self.length += 1;\n+    fn push_front(&mut self, elt: T) {\n+        self.push_front_node(~Node::new(elt))\n     }\n \n-    /// Remove the last element and return it, or None if the list is empty\n+    /// Remove the first element and return it, or None if the list is empty\n     ///\n     /// O(1)\n-    fn pop_back(&mut self) -> Option<T> {\n-        match self.list_tail.resolve() {\n-            None => None,\n-            Some(tail) => {\n-                self.length -= 1;\n-                let tail_own = match tail.prev.resolve() {\n-                    None => {\n-                        self.list_tail = Rawlink::none();\n-                        self.list_head.take_unwrap()\n-                    },\n-                    Some(tail_prev) => {\n-                        self.list_tail = tail.prev;\n-                        tail_prev.next.take_unwrap()\n-                    }\n-                };\n-                Some(tail_own.value)\n-            }\n-        }\n+    fn pop_front(&mut self) -> Option<T> {\n+        self.pop_front_node().map_consume(|~Node{value, _}| value)\n     }\n \n-    /// Add an element first in the list\n+    /// Add an element last in the list\n     ///\n     /// O(1)\n-    fn push_front(&mut self, elt: T) {\n-        let mut new_head = ~Node{value: elt, next: None, prev: Rawlink::none()};\n-        match self.list_head {\n-            None => {\n-                self.list_tail = Rawlink::some(new_head);\n-                self.list_head = Some(new_head);\n-            }\n-            Some(ref mut head) => {\n-                head.prev = Rawlink::some(new_head);\n-                util::swap(head, &mut new_head);\n-                head.next = Some(new_head);\n-            }\n-        }\n-        self.length += 1;\n+    fn push_back(&mut self, elt: T) {\n+        self.push_back_node(~Node::new(elt))\n     }\n \n-    /// Remove the first element and return it, or None if the list is empty\n+    /// Remove the last element and return it, or None if the list is empty\n     ///\n     /// O(1)\n-    fn pop_front(&mut self) -> Option<T> {\n-        match self.list_head.take() {\n-            None => None,\n-            Some(old_head) => {\n-                self.length -= 1;\n-                match *old_head {\n-                    Node{value: value, next: Some(next), prev: _} => {\n-                        self.list_head = link_with_prev(next, Rawlink::none());\n-                        Some(value)\n-                    }\n-                    Node{value: value, next: None, prev: _} => {\n-                        self.list_tail = Rawlink::none();\n-                        Some(value)\n-                    }\n-                }\n-            }\n-        }\n+    fn pop_back(&mut self) -> Option<T> {\n+        self.pop_back_node().map_consume(|~Node{value, _}| value)\n     }\n }\n \n@@ -243,6 +257,26 @@ impl<T> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n+    /// Move the last element to the front of the list.\n+    ///\n+    /// If the list is empty, do nothing.\n+    #[inline]\n+    pub fn rotate_forward(&mut self) {\n+        do self.pop_back_node().map_consume |tail| {\n+            self.push_front_node(tail)\n+        };\n+    }\n+\n+    /// Move the first element to the back of the list.\n+    ///\n+    /// If the list is empty, do nothing.\n+    #[inline]\n+    pub fn rotate_backward(&mut self) {\n+        do self.pop_front_node().map_consume |head| {\n+            self.push_back_node(head)\n+        };\n+    }\n+\n     /// Add all elements from `other` to the end of the list\n     ///\n     /// O(1)\n@@ -251,7 +285,7 @@ impl<T> DList<T> {\n             None => *self = other,\n             Some(tail) => {\n                 match other {\n-                    DList{list_head: None, list_tail: _, length: _} => return,\n+                    DList{list_head: None, _} => return,\n                     DList{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n                         tail.next = link_with_prev(node, self.list_tail);\n                         self.list_tail = o_tail;\n@@ -306,7 +340,7 @@ impl<T> DList<T> {\n                 if take_a {\n                     it.next();\n                 } else {\n-                    it.insert_next(other.pop_front().unwrap());\n+                    it.insert_next_node(other.pop_front_node().unwrap());\n                 }\n             }\n         }\n@@ -361,13 +395,13 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T: cmp::TotalOrd> DList<T> {\n+impl<T: Ord> DList<T> {\n     /// Insert `elt` sorted in ascending order\n     ///\n     /// O(N)\n     #[inline]\n     pub fn insert_ordered(&mut self, elt: T) {\n-        self.insert_when(elt, |a, b| a.cmp(b) != cmp::Less);\n+        self.insert_when(elt, |a, b| a >= b)\n     }\n }\n \n@@ -377,13 +411,10 @@ impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        match *self.head {\n-            None => None,\n-            Some(ref head) => {\n-                self.nelem -= 1;\n-                self.head = &head.next;\n-                Some(&head.value)\n-            }\n+        do self.head.map |head| {\n+            self.nelem -= 1;\n+            self.head = &head.next;\n+            &head.value\n         }\n     }\n \n@@ -399,13 +430,10 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        match self.tail.resolve() {\n-            None => None,\n-            Some(prev) => {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                Some(&prev.value)\n-            }\n+        do self.tail.resolve().map_consume |prev| {\n+            self.nelem -= 1;\n+            self.tail = prev.prev;\n+            &prev.value\n         }\n     }\n }\n@@ -416,16 +444,13 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        match self.head.resolve() {\n-            None => None,\n-            Some(next) => {\n-                self.nelem -= 1;\n-                self.head = match next.next {\n-                    Some(ref mut node) => Rawlink::some(&mut **node),\n-                    None => Rawlink::none(),\n-                };\n-                Some(&mut next.value)\n-            }\n+        do self.head.resolve().map_consume |next| {\n+            self.nelem -= 1;\n+            self.head = match next.next {\n+                Some(ref mut node) => Rawlink::some(&mut **node),\n+                None => Rawlink::none(),\n+            };\n+            &mut next.value\n         }\n     }\n \n@@ -441,53 +466,61 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n         if self.nelem == 0 {\n             return None;\n         }\n-        match self.tail.resolve() {\n-            None => None,\n-            Some(prev) => {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                Some(&mut prev.value)\n-            }\n+        do self.tail.resolve().map_consume |prev| {\n+            self.nelem -= 1;\n+            self.tail = prev.prev;\n+            &mut prev.value\n         }\n     }\n }\n \n \n /// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {\n-    /// Insert `elt` just after to the most recently yielded element\n+    /// Insert `elt` just after to the element most recently returned by `.next()`\n+    ///\n+    /// The inserted element does not appear in the iteration.\n     fn insert_next(&mut self, elt: A);\n \n     /// Provide a reference to the next element, without changing the iterator\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n-    fn insert_next(&mut self, elt: A) {\n-        // Insert an element before `self.head` so that it is between the\n+// private methods for MutDListIterator\n+impl<'self, A> MutDListIterator<'self, A> {\n+    fn insert_next_node(&mut self, mut ins_node: ~Node<A>) {\n+        // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n+        //\n+        // The inserted node will not appear in further iteration.\n         match self.head.resolve() {\n-            None => { self.list.push_back(elt); }\n+            None => { self.list.push_back_node(ins_node); }\n             Some(node) => {\n                 let prev_node = match node.prev.resolve() {\n-                    None => return self.list.push_front(elt),\n+                    None => return self.list.push_front_node(ins_node),\n                     Some(prev) => prev,\n                 };\n-                let mut ins_node = ~Node{value: elt, next: None, prev: Rawlink::none()};\n                 let node_own = prev_node.next.take_unwrap();\n                 ins_node.next = link_with_prev(node_own, Rawlink::some(ins_node));\n                 prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n                 self.list.length += 1;\n             }\n         }\n     }\n+}\n+\n+impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n+    #[inline]\n+    fn insert_next(&mut self, elt: A) {\n+        self.insert_next_node(~Node::new(elt))\n+    }\n \n     #[inline]\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n-        match self.head.resolve() {\n-            None => None,\n-            Some(head) => Some(&mut head.value),\n+        if self.nelem == 0 {\n+            return None\n         }\n+        self.head.resolve().map_consume(|head| &mut head.value)\n     }\n }\n \n@@ -679,6 +712,29 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_rotate() {\n+        let mut n = DList::new::<int>();\n+        n.rotate_backward(); check_links(&n);\n+        assert_eq!(n.len(), 0);\n+        n.rotate_forward(); check_links(&n);\n+        assert_eq!(n.len(), 0);\n+\n+        let v = ~[1,2,3,4,5];\n+        let mut m = list_from(v);\n+        m.rotate_backward(); check_links(&m);\n+        m.rotate_forward(); check_links(&m);\n+        assert_eq!(v.iter().collect::<~[&int]>(), m.iter().collect());\n+        m.rotate_forward(); check_links(&m);\n+        m.rotate_forward(); check_links(&m);\n+        m.pop_front(); check_links(&m);\n+        m.rotate_forward(); check_links(&m);\n+        m.rotate_backward(); check_links(&m);\n+        m.push_front(9); check_links(&m);\n+        m.rotate_forward(); check_links(&m);\n+        assert_eq!(~[3,9,5,1,2], m.consume_iter().collect());\n+    }\n+\n     #[test]\n     fn test_iterator() {\n         let m = generate_test();\n@@ -923,13 +979,6 @@ mod tests {\n             let _: DList<int> = v.iter().transform(|x| *x).collect();\n         }\n     }\n-    #[bench]\n-    fn bench_collect_into_vec(b: &mut test::BenchHarness) {\n-        let v = &[0, ..64];\n-        do b.iter {\n-            let _: ~[int] = v.iter().transform(|&x|x).collect();\n-        }\n-    }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n@@ -938,44 +987,50 @@ mod tests {\n             m.push_front(0);\n         }\n     }\n+\n     #[bench]\n-    fn bench_push_front_vec_size10(b: &mut test::BenchHarness) {\n-        let mut m = ~[0, ..10];\n+    fn bench_push_back(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n         do b.iter {\n-            m.unshift(0);\n-            m.pop(); // to keep it fair, dont' grow the vec\n+            m.push_back(0);\n         }\n     }\n \n     #[bench]\n-    fn bench_push_back(b: &mut test::BenchHarness) {\n+    fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n         let mut m = DList::new::<int>();\n         do b.iter {\n             m.push_back(0);\n+            m.pop_back();\n         }\n     }\n+\n     #[bench]\n-    fn bench_push_back_vec(b: &mut test::BenchHarness) {\n-        let mut m = ~[];\n+    fn bench_push_front_pop_front(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n         do b.iter {\n-            m.push(0);\n+            m.push_front(0);\n+            m.pop_front();\n         }\n     }\n \n     #[bench]\n-    fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n+    fn bench_rotate_forward(b: &mut test::BenchHarness) {\n         let mut m = DList::new::<int>();\n+        m.push_front(0);\n+        m.push_front(1);\n         do b.iter {\n-            m.push_back(0);\n-            m.pop_back();\n+            m.rotate_forward();\n         }\n     }\n+\n     #[bench]\n-    fn bench_push_back_pop_back_vec(b: &mut test::BenchHarness) {\n-        let mut m = ~[];\n+    fn bench_rotate_backward(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n+        m.push_front(0);\n+        m.push_front(1);\n         do b.iter {\n-            m.push(0);\n-            m.pop();\n+            m.rotate_backward();\n         }\n     }\n \n@@ -1011,12 +1066,5 @@ mod tests {\n             assert!(m.mut_rev_iter().len_() == 128);\n         }\n     }\n-    #[bench]\n-    fn bench_iter_vec(b: &mut test::BenchHarness) {\n-        let v = &[0, ..128];\n-        do b.iter {\n-            for v.iter().advance |_| {}\n-        }\n-    }\n }\n "}, {"sha": "600c7c10fec2e3e9c70df16ee7ffda9a4f35fef2", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69a237ed7b40221c0f0bf8dc3774fddc3832f62d/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a237ed7b40221c0f0bf8dc3774fddc3832f62d/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "patch": "@@ -662,6 +662,19 @@ impl<\n     }\n }\n \n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for DList<T> {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n+            for self.iter().enumerate().advance |(i, e)| {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+            }\n+        }\n+    }\n+}\n+\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n     fn decode(d: &mut D) -> DList<T> {\n         let mut list = DList::new();"}]}