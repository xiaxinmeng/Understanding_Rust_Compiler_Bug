{"sha": "c3ec1758571fdf75a4970f9f130b3b83d451ff62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZWMxNzU4NTcxZmRmNzVhNDk3MGY5ZjEzMGIzYjgzZDQ1MWZmNjI=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2017-11-10T17:05:29Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2017-11-14T08:12:08Z"}, "message": "Make create_temp_necessary a method", "tree": {"sha": "3b8a7d66c5a30f8c348729c62553a9a70bc08933", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b8a7d66c5a30f8c348729c62553a9a70bc08933"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3ec1758571fdf75a4970f9f130b3b83d451ff62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ec1758571fdf75a4970f9f130b3b83d451ff62", "html_url": "https://github.com/rust-lang/rust/commit/c3ec1758571fdf75a4970f9f130b3b83d451ff62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3ec1758571fdf75a4970f9f130b3b83d451ff62/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "html_url": "https://github.com/rust-lang/rust/commit/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5"}], "stats": {"total": 86, "additions": 40, "deletions": 46}, "files": [{"sha": "460af371e044c7fe451d90ab06927aa24583871d", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c3ec1758571fdf75a4970f9f130b3b83d451ff62/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ec1758571fdf75a4970f9f130b3b83d451ff62/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=c3ec1758571fdf75a4970f9f130b3b83d451ff62", "patch": "@@ -557,56 +557,14 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         callsite: &CallSite<'tcx>,\n         caller_mir: &mut Mir<'tcx>,\n     ) -> Vec<Operand<'tcx>> {\n-        // FIXME: Analysis of the usage of the arguments to avoid\n-        // unnecessary temporaries.\n-\n-        fn create_temp_if_necessary<'a, 'tcx: 'a>(\n-            arg: Operand<'tcx>,\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-            callsite: &CallSite<'tcx>,\n-            caller_mir: &mut Mir<'tcx>,\n-        ) -> Operand<'tcx> {\n-            if let Operand::Consume(Lvalue::Local(local)) = arg {\n-                if caller_mir.local_kind(local) == LocalKind::Temp {\n-                    // Reuse the operand if it's a temporary already\n-                    return arg;\n-                }\n-            }\n-\n-            debug!(\"Creating temp for argument {:?}\", arg);\n-            // Otherwise, create a temporary for the arg\n-            let arg = Rvalue::Use(arg);\n-\n-            let ty = arg.ty(caller_mir, tcx);\n-\n-            let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n-            let arg_tmp = caller_mir.local_decls.push(arg_tmp);\n-            let arg_tmp = Lvalue::Local(arg_tmp);\n-\n-            let stmt = Statement {\n-                source_info: callsite.location,\n-                kind: StatementKind::Assign(arg_tmp.clone(), arg),\n-            };\n-            caller_mir[callsite.bb].statements.push(stmt);\n-            Operand::Consume(arg_tmp)\n-        }\n-\n         let tcx = self.tcx;\n \n         // A closure is passed its self-type and a tuple like `(arg1, arg2, ...)`,\n         // hence mappings to tuple fields are needed.\n         if tcx.def_key(callsite.callee).disambiguated_data.data == DefPathData::ClosureExpr {\n             let mut args = args.into_iter();\n-\n-            let self_ = create_temp_if_necessary(args.next().unwrap(), tcx, callsite, caller_mir);\n-\n-            let tuple = if let Operand::Consume(lvalue) =\n-                create_temp_if_necessary(args.next().unwrap(), tcx, callsite, caller_mir)\n-            {\n-                lvalue\n-            } else {\n-                unreachable!()\n-            };\n+            let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n+            let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n             assert!(args.next().is_none());\n \n             let tuple_tys = if let ty::TyTuple(s, _) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n@@ -616,17 +574,53 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             };\n \n             let mut res = Vec::with_capacity(1 + tuple_tys.len());\n-            res.push(self_);\n+            res.push(Operand::Consume(self_));\n             res.extend(tuple_tys.iter().enumerate().map(|(i, ty)| {\n                 Operand::Consume(tuple.clone().field(Field::new(i), ty))\n             }));\n             res\n         } else {\n             args.into_iter()\n-                .map(|a| create_temp_if_necessary(a, tcx, callsite, caller_mir))\n+                .map(|a| Operand::Consume(self.create_temp_if_necessary(a, callsite, caller_mir)))\n                 .collect()\n         }\n     }\n+\n+    /// If `arg` is already a temporary, returns it. Otherwise, introduces a fresh\n+    /// temporary `T` and an instruction `T = arg`, and returns `T`.\n+    fn create_temp_if_necessary(\n+        &self,\n+        arg: Operand<'tcx>,\n+        callsite: &CallSite<'tcx>,\n+        caller_mir: &mut Mir<'tcx>,\n+    ) -> Lvalue<'tcx> {\n+        // FIXME: Analysis of the usage of the arguments to avoid\n+        // unnecessary temporaries.\n+\n+        if let Operand::Consume(Lvalue::Local(local)) = arg {\n+            if caller_mir.local_kind(local) == LocalKind::Temp {\n+                // Reuse the operand if it's a temporary already\n+                return Lvalue::Local(local);\n+            }\n+        }\n+\n+        debug!(\"Creating temp for argument {:?}\", arg);\n+        // Otherwise, create a temporary for the arg\n+        let arg = Rvalue::Use(arg);\n+\n+        let ty = arg.ty(caller_mir, self.tcx);\n+\n+        let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n+        let arg_tmp = caller_mir.local_decls.push(arg_tmp);\n+        let arg_tmp = Lvalue::Local(arg_tmp);\n+\n+        let stmt = Statement {\n+            source_info: callsite.location,\n+            kind: StatementKind::Assign(arg_tmp.clone(), arg),\n+        };\n+        caller_mir[callsite.bb].statements.push(stmt);\n+        arg_tmp\n+    }\n }\n \n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}]}