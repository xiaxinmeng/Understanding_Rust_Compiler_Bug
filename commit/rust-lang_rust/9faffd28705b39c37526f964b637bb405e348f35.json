{"sha": "9faffd28705b39c37526f964b637bb405e348f35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYWZmZDI4NzA1YjM5YzM3NTI2Zjk2NGI2MzdiYjQwNWUzNDhmMzU=", "commit": {"author": {"name": "KALPESH KRISHNA", "email": "kalpeshk2011@gmail.com", "date": "2016-03-08T05:33:30Z"}, "committer": {"name": "KALPESH KRISHNA", "email": "kalpeshk2011@gmail.com", "date": "2016-03-08T08:09:44Z"}, "message": "Adding symmetric lints and test cases", "tree": {"sha": "a0e8e3e939c4b71b61a1c259aec00389e0ba62dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0e8e3e939c4b71b61a1c259aec00389e0ba62dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9faffd28705b39c37526f964b637bb405e348f35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9faffd28705b39c37526f964b637bb405e348f35", "html_url": "https://github.com/rust-lang/rust/commit/9faffd28705b39c37526f964b637bb405e348f35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9faffd28705b39c37526f964b637bb405e348f35/comments", "author": {"login": "martiansideofthemoon", "id": 8805240, "node_id": "MDQ6VXNlcjg4MDUyNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8805240?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martiansideofthemoon", "html_url": "https://github.com/martiansideofthemoon", "followers_url": "https://api.github.com/users/martiansideofthemoon/followers", "following_url": "https://api.github.com/users/martiansideofthemoon/following{/other_user}", "gists_url": "https://api.github.com/users/martiansideofthemoon/gists{/gist_id}", "starred_url": "https://api.github.com/users/martiansideofthemoon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martiansideofthemoon/subscriptions", "organizations_url": "https://api.github.com/users/martiansideofthemoon/orgs", "repos_url": "https://api.github.com/users/martiansideofthemoon/repos", "events_url": "https://api.github.com/users/martiansideofthemoon/events{/privacy}", "received_events_url": "https://api.github.com/users/martiansideofthemoon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "martiansideofthemoon", "id": 8805240, "node_id": "MDQ6VXNlcjg4MDUyNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8805240?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martiansideofthemoon", "html_url": "https://github.com/martiansideofthemoon", "followers_url": "https://api.github.com/users/martiansideofthemoon/followers", "following_url": "https://api.github.com/users/martiansideofthemoon/following{/other_user}", "gists_url": "https://api.github.com/users/martiansideofthemoon/gists{/gist_id}", "starred_url": "https://api.github.com/users/martiansideofthemoon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martiansideofthemoon/subscriptions", "organizations_url": "https://api.github.com/users/martiansideofthemoon/orgs", "repos_url": "https://api.github.com/users/martiansideofthemoon/repos", "events_url": "https://api.github.com/users/martiansideofthemoon/events{/privacy}", "received_events_url": "https://api.github.com/users/martiansideofthemoon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6d409414ea82866bac7f4c7698c16f9884a1b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d409414ea82866bac7f4c7698c16f9884a1b9b", "html_url": "https://github.com/rust-lang/rust/commit/d6d409414ea82866bac7f4c7698c16f9884a1b9b"}], "stats": {"total": 79, "additions": 60, "deletions": 19}, "files": [{"sha": "2dccbfdb26ace1ad9c651045727c53df058c3d96", "filename": "src/overflow_check_conditional.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9faffd28705b39c37526f964b637bb405e348f35/src%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faffd28705b39c37526f964b637bb405e348f35/src%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow_check_conditional.rs?ref=9faffd28705b39c37526f964b637bb405e348f35", "patch": "@@ -1,14 +1,16 @@\n+#![allow(cyclomatic_complexity)]\n use rustc::lint::*;\n use rustc_front::hir::*;\n use utils::{span_lint};\n \n-/// **What it does:** This lint finds classic overflow checks.\n+/// **What it does:** This lint finds classic underflow / overflow checks.\n ///\n-/// **Why is this bad?** Most classic C overflow checks will fail in Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n+/// **Why is this bad?** Most classic C underflow / overflow checks will fail in Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n ///\n /// **Known problems:** None.\n ///\n /// **Example:** `a + b < a`\n+\n declare_lint!(pub OVERFLOW_CHECK_CONDITIONAL, Warn,\n               \"Using overflow checks which are likely to panic\");\n \n@@ -22,35 +24,50 @@ impl LintPass for OverflowCheckConditional {\n }\n \n impl LateLintPass for OverflowCheckConditional {\n+    // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain! {[\n         let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-        let BinOp_::BiLt = op.node,\n-        let Expr_::ExprBinary(ref op2, ref add1, ref add2) = first.node,\n-        let BinOp_::BiAdd = op2.node,\n-        let Expr_::ExprPath(_,ref path1) = add1.node,\n-        let Expr_::ExprPath(_, ref path2) = add2.node,\n+        let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n+        let Expr_::ExprPath(_,ref path1) = ident1.node,\n+        let Expr_::ExprPath(_, ref path2) = ident2.node,\n         let Expr_::ExprPath(_, ref path3) = second.node,\n         (&path1.segments[0]).identifier == (&path3.segments[0]).identifier || (&path2.segments[0]).identifier == (&path3.segments[0]).identifier,\n-        cx.tcx.expr_ty(add1).is_integral(),\n-        cx.tcx.expr_ty(add2).is_integral()\n+        cx.tcx.expr_ty(ident1).is_integral(),\n+        cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n-            span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditons that will fail in Rust.\");\n+            if let BinOp_::BiLt = op.node {\n+                if let BinOp_::BiAdd = op2.node {\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditons that will fail in Rust.\");\n+                }\n+            }\n+            if let BinOp_::BiGt = op.node {\n+                if let BinOp_::BiSub = op2.node {\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditons that will fail in Rust.\");\n+                }\n+            }\n         }}\n \n         if_let_chain! {[\n         let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-        let BinOp_::BiGt = op.node,\n-        let Expr_::ExprBinary(ref op2, ref sub1, ref sub2) = first.node,\n-        let BinOp_::BiSub = op2.node,\n-        let Expr_::ExprPath(_,ref path1) = sub1.node,\n-        let Expr_::ExprPath(_, ref path2) = sub2.node,\n-        let Expr_::ExprPath(_, ref path3) = second.node,\n+        let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n+        let Expr_::ExprPath(_,ref path1) = ident1.node,\n+        let Expr_::ExprPath(_, ref path2) = ident2.node,\n+        let Expr_::ExprPath(_, ref path3) = first.node,\n         (&path1.segments[0]).identifier == (&path3.segments[0]).identifier || (&path2.segments[0]).identifier == (&path3.segments[0]).identifier,\n-        cx.tcx.expr_ty(sub1).is_integral(),\n-        cx.tcx.expr_ty(sub2).is_integral()\n+        cx.tcx.expr_ty(ident1).is_integral(),\n+        cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n-            span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditons that will fail in Rust.\");\n+            if let BinOp_::BiGt = op.node {\n+                if let BinOp_::BiAdd = op2.node {\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditons that will fail in Rust.\");\n+                }\n+            }\n+            if let BinOp_::BiLt = op.node {\n+                if let BinOp_::BiSub = op2.node {\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditons that will fail in Rust.\");\n+                }\n+            }\n         }}\n     }\n }"}, {"sha": "df629146deecc63753800d136785d8e84d72f9f9", "filename": "tests/compile-fail/overflow_check_conditional.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9faffd28705b39c37526f964b637bb405e348f35/tests%2Fcompile-fail%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faffd28705b39c37526f964b637bb405e348f35/tests%2Fcompile-fail%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflow_check_conditional.rs?ref=9faffd28705b39c37526f964b637bb405e348f35", "patch": "@@ -9,21 +9,39 @@ fn main() {\n \tlet c: u32 = 3;\n \tif a + b < a { //~ERROR You are trying to use classic C overflow conditons that will fail in Rust.\n \n+\t}\n+\tif a > a + b { //~ERROR You are trying to use classic C overflow conditons that will fail in Rust.\n+\n \t}\n \tif a + b < b { //~ERROR You are trying to use classic C overflow conditons that will fail in Rust.\n \n+\t}\n+\tif b > a + b { //~ERROR You are trying to use classic C overflow conditons that will fail in Rust.\n+\n \t}\n \tif a - b > b { //~ERROR You are trying to use classic C underflow conditons that will fail in Rust.\n \n+\t}\n+\tif b < a - b { //~ERROR You are trying to use classic C underflow conditons that will fail in Rust.\n+\n \t}\n \tif a - b > a { //~ERROR You are trying to use classic C underflow conditons that will fail in Rust.\n \n+\t}\n+\tif a < a - b { //~ERROR You are trying to use classic C underflow conditons that will fail in Rust.\n+\n \t}\n \tif a + b < c {\n \n+\t}\n+\tif c > a + b {\n+\n \t}\n \tif a - b < c {\n \n+\t}\n+\tif c > a - b {\n+\n \t}\n \tlet i = 1.1;\n \tlet j = 2.2;\n@@ -32,6 +50,12 @@ fn main() {\n \t}\n \tif i - j < i {\n \n+\t}\n+\tif i > i + j {\n+\n+\t}\n+\tif i - j < i {\n+\n \t}\n }\n "}]}