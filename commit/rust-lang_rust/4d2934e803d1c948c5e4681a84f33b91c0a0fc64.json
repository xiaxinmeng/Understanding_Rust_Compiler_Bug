{"sha": "4d2934e803d1c948c5e4681a84f33b91c0a0fc64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMjkzNGU4MDNkMWM5NDhjNWU0NjgxYTg0ZjMzYjkxYzBhMGZjNjQ=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2018-11-12T16:19:55Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2018-11-12T16:19:59Z"}, "message": "Add forget_unsized only", "tree": {"sha": "9fb2a5d42e58cd9f67ebae815259f29fc7312fb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb2a5d42e58cd9f67ebae815259f29fc7312fb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d2934e803d1c948c5e4681a84f33b91c0a0fc64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d2934e803d1c948c5e4681a84f33b91c0a0fc64", "html_url": "https://github.com/rust-lang/rust/commit/4d2934e803d1c948c5e4681a84f33b91c0a0fc64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d2934e803d1c948c5e4681a84f33b91c0a0fc64/comments", "author": null, "committer": null, "parents": [{"sha": "f211581330399945802a227c4405fd92f983a2b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f211581330399945802a227c4405fd92f983a2b8", "html_url": "https://github.com/rust-lang/rust/commit/f211581330399945802a227c4405fd92f983a2b8"}], "stats": {"total": 122, "additions": 15, "deletions": 107}, "files": [{"sha": "f612f89e0826f4a7ca38ace6e5879a42b2df4da3", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 15, "deletions": 107, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4d2934e803d1c948c5e4681a84f33b91c0a0fc64/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d2934e803d1c948c5e4681a84f33b91c0a0fc64/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4d2934e803d1c948c5e4681a84f33b91c0a0fc64", "patch": "@@ -139,126 +139,34 @@ pub use intrinsics::transmute;\n /// [ub]: ../../reference/behavior-considered-undefined.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n-pub fn forget<T: ?Sized>(t: T) {\n-    unsafe { intrinsics::forget(t) }\n+pub fn forget<T>(t: T) {\n+    ManuallyDrop::new(t);\n }\n \n /// Takes ownership and \"forgets\" about the value **without running its destructor**.\n ///\n-/// Any resources the value manages, such as heap memory or a file handle, will linger\n-/// forever in an unreachable state. However, it does not guarantee that pointers\n-/// to this memory will remain valid.\n-///\n-/// * If you want to leak memory, see [`Box::leak`][leak].\n-/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n-/// * If you want to dispose of a value properly, running its destructor, see\n-/// [`mem::drop`][drop].\n-///\n-/// # Safety\n-///\n-/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n-/// do not include a guarantee that destructors will always run. For example,\n-/// a program can create a reference cycle using [`Rc`][rc], or call\n-/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n-/// `mem::forget` from safe code does not fundamentally change Rust's safety\n-/// guarantees.\n-///\n-/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n-/// so `forget` is only recommended for specialized use cases like those shown below.\n-///\n-/// Because forgetting a value is allowed, any `unsafe` code you write must\n-/// allow for this possibility. You cannot return a value and expect that the\n-/// caller will necessarily run the value's destructor.\n+/// This function works exactly the same as [`forget`], except it also accepts unsized values. It\n+/// will never be stabilized and is only available because we haven't decided to relax the bounds\n+/// on [`forget`] just yet.\n ///\n-/// [rc]: ../../std/rc/struct.Rc.html\n-/// [exit]: ../../std/process/fn.exit.html\n+/// [`forget`]: fn.forget.html\n ///\n /// # Examples\n ///\n-/// Leak an I/O object, never closing the file:\n-///\n-/// ```no_run\n-/// use std::mem;\n-/// use std::fs::File;\n-///\n-/// let file = File::open(\"foo.txt\").unwrap();\n-/// mem::forget(file);\n-/// ```\n-///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code.\n-///\n-/// ## Use case 1\n-///\n-/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n-/// You must either initialize or `forget` it on every computation path before\n-/// Rust drops it automatically, like at the end of a scope or after a panic.\n-/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # let some_condition = false;\n-/// unsafe {\n-///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n-///\n-///     if some_condition {\n-///         // Initialize the variable.\n-///         ptr::write(&mut uninit_vec, Vec::new());\n-///     } else {\n-///         // Forget the uninitialized value so its destructor doesn't run.\n-///         mem::forget(uninit_vec);\n-///     }\n-/// }\n /// ```\n+/// #![feature(forget_unsized)]\n ///\n-/// ## Use case 2\n-///\n-/// You have duplicated the bytes making up a value, without doing a proper\n-/// [`Clone`][clone]. You need the value's destructor to run only once,\n-/// because a double `free` is undefined behavior.\n-///\n-/// An example is a possible implementation of [`mem::swap`][swap]:\n-///\n-/// ```\n /// use std::mem;\n-/// use std::ptr;\n-///\n-/// # #[allow(dead_code)]\n-/// fn swap<T>(x: &mut T, y: &mut T) {\n-///     unsafe {\n-///         // Give ourselves some scratch space to work with\n-///         let mut t: T = mem::uninitialized();\n ///\n-///         // Perform the swap, `&mut` pointers never alias\n-///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n-///         ptr::copy_nonoverlapping(&*y, x, 1);\n-///         ptr::copy_nonoverlapping(&t, y, 1);\n-///\n-///         // y and t now point to the same thing, but we need to completely\n-///         // forget `t` because we do not want to run the destructor for `T`\n-///         // on its value, which is still owned somewhere outside this function.\n-///         mem::forget(t);\n-///     }\n-/// }\n+/// let f: Box<FnOnce()> = Box::new(|| ());\n+/// let f = *f;\n+/// mem::forget_unsized(f);\n /// ```\n-///\n-/// [drop]: fn.drop.html\n-/// [uninit]: fn.uninitialized.html\n-/// [clone]: ../clone/trait.Clone.html\n-/// [swap]: fn.swap.html\n-/// [FFI]: ../../book/first-edition/ffi.html\n-/// [box]: ../../std/boxed/struct.Box.html\n-/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n-/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n #[inline]\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn forget<T>(t: T) {\n-    ManuallyDrop::new(t);\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n+pub fn forget_unsized<T: ?Sized>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n }\n \n /// Returns the size of a type in bytes.\n@@ -881,7 +789,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// [`Copy`]: ../../std/marker/trait.Copy.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn drop<T: ?Sized>(_x: T) { }\n+pub fn drop<T>(_x: T) { }\n \n /// Interprets `src` as having type `&U`, and then reads `src` without moving\n /// the contained value."}]}