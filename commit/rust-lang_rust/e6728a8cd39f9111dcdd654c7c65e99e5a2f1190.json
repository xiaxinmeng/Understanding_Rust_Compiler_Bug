{"sha": "e6728a8cd39f9111dcdd654c7c65e99e5a2f1190", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NzI4YThjZDM5ZjkxMTFkY2RkNjU0YzdjNjVlOTllNWEyZjExOTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-13T11:39:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-13T11:39:03Z"}, "message": "Merge #8415\n\n8415: Fix faulty assertion when extracting function with macro call r=matklad a=brandondong\n\n**Reproduction:**\r\n```rust\r\nfn main() {\r\n    let n = 1;\r\n    let k = n * n;\r\n    dbg!(n);\r\n}\r\n```\r\n1. Select the second and third lines of the main function. Use the \"Extract into function\" code assist.\r\n2. Panic occurs in debug, error is logged in release: \"[ERROR ide_assists::handlers::extract_function] assertion failed: matches!(path, ast :: Expr :: PathExpr(_))\".\r\n3. Function generates successfully on release where the panic was bypassed.\r\n```rust\r\nfn fun_name(n: i32) {\r\n    let k = n * n;\r\n    dbg!(n);\r\n}\r\n```\r\n\r\n**Cause:**\r\n- The generated function will take `n` as a parameter. The extraction logic needs to search the usages of `n` to determine whether it is used mutably or not. The helper `path_element_of_reference` is called for each usage but the second usage is a macro call and fails the `Expr::PathExpr(_)` match assertion.\r\n- The caller of `path_element_of_reference` does implicitly assume it to be a `Expr::PathExpr(_)` in how it looks at its parent node for determining whether it is used mutably. This logic will not work for macros.\r\n- I'm not sure if there are any other cases besides macros where it could be something other than a `Expr::PathExpr(_)`. I tried various examples and could not find any.\r\n\r\n**Fix:**\r\n- Update assertion to include the macro case.\r\n- Add a FIXME to properly handle checking if a macro usage requires mutable access. For now, return false instead of running the existing logic that is tailored for `Expr::PathExpr(_)`'s.\n\nCo-authored-by: Brandon <brandondong604@hotmail.com>", "tree": {"sha": "2532d24e0c10c7e3284033df4256f7adf96d2e82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2532d24e0c10c7e3284033df4256f7adf96d2e82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6728a8cd39f9111dcdd654c7c65e99e5a2f1190", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgdYLXCRBK7hj4Ov3rIwAAdHIIABKli4KE4yXjjXvPcsXOJ08/\nVcNpeEjWOvnYn7SELMyIUjirHYWWqm5apcLl4PR7BzDKzdQaS7fsnTBpIGUSHbXQ\ndJvQd5nYyEuaDdtxZF2q083hfT0b/dtph5LO6d6jwaYOmQb3RLLIBvhnUHY5bxbX\n5RKIoLksm+7t5KVgBD+6E68B2VR8OGTonXPj1azrO0oH/9gZXe0iNmDkf851RZ/k\njhsdH+dc/rzWS2AdrdWPaTLOyIyICd8RVOexFCwWIz0TSMOixHEFsTWXCwg3Kyb+\nKy96N9xP6EHNp9TYopuBfgQrsNPfWRD94eCkBr9jhHdlDeB2jzipHxMymibLWhQ=\n=YQgK\n-----END PGP SIGNATURE-----\n", "payload": "tree 2532d24e0c10c7e3284033df4256f7adf96d2e82\nparent 0c02208fd8d9ff3ce8184e2eb5dba915d5b54656\nparent 09a78caca403f1b4be8711d00519094896928e58\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618313943 +0000\ncommitter GitHub <noreply@github.com> 1618313943 +0000\n\nMerge #8415\n\n8415: Fix faulty assertion when extracting function with macro call r=matklad a=brandondong\n\n**Reproduction:**\r\n```rust\r\nfn main() {\r\n    let n = 1;\r\n    let k = n * n;\r\n    dbg!(n);\r\n}\r\n```\r\n1. Select the second and third lines of the main function. Use the \"Extract into function\" code assist.\r\n2. Panic occurs in debug, error is logged in release: \"[ERROR ide_assists::handlers::extract_function] assertion failed: matches!(path, ast :: Expr :: PathExpr(_))\".\r\n3. Function generates successfully on release where the panic was bypassed.\r\n```rust\r\nfn fun_name(n: i32) {\r\n    let k = n * n;\r\n    dbg!(n);\r\n}\r\n```\r\n\r\n**Cause:**\r\n- The generated function will take `n` as a parameter. The extraction logic needs to search the usages of `n` to determine whether it is used mutably or not. The helper `path_element_of_reference` is called for each usage but the second usage is a macro call and fails the `Expr::PathExpr(_)` match assertion.\r\n- The caller of `path_element_of_reference` does implicitly assume it to be a `Expr::PathExpr(_)` in how it looks at its parent node for determining whether it is used mutably. This logic will not work for macros.\r\n- I'm not sure if there are any other cases besides macros where it could be something other than a `Expr::PathExpr(_)`. I tried various examples and could not find any.\r\n\r\n**Fix:**\r\n- Update assertion to include the macro case.\r\n- Add a FIXME to properly handle checking if a macro usage requires mutable access. For now, return false instead of running the existing logic that is tailored for `Expr::PathExpr(_)`'s.\n\nCo-authored-by: Brandon <brandondong604@hotmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6728a8cd39f9111dcdd654c7c65e99e5a2f1190", "html_url": "https://github.com/rust-lang/rust/commit/e6728a8cd39f9111dcdd654c7c65e99e5a2f1190", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6728a8cd39f9111dcdd654c7c65e99e5a2f1190/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c02208fd8d9ff3ce8184e2eb5dba915d5b54656", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c02208fd8d9ff3ce8184e2eb5dba915d5b54656", "html_url": "https://github.com/rust-lang/rust/commit/0c02208fd8d9ff3ce8184e2eb5dba915d5b54656"}, {"sha": "09a78caca403f1b4be8711d00519094896928e58", "url": "https://api.github.com/repos/rust-lang/rust/commits/09a78caca403f1b4be8711d00519094896928e58", "html_url": "https://github.com/rust-lang/rust/commit/09a78caca403f1b4be8711d00519094896928e58"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "059414274cb043429d1da1813536545540a43277", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e6728a8cd39f9111dcdd654c7c65e99e5a2f1190/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6728a8cd39f9111dcdd654c7c65e99e5a2f1190/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=e6728a8cd39f9111dcdd654c7c65e99e5a2f1190", "patch": "@@ -736,6 +736,14 @@ fn reference_is_exclusive(\n \n /// checks if this expr requires `&mut` access, recurses on field access\n fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Option<bool> {\n+    match expr {\n+        ast::Expr::MacroCall(_) => {\n+            // FIXME: expand macro and check output for mutable usages of the variable?\n+            return None;\n+        }\n+        _ => (),\n+    }\n+\n     let parent = expr.syntax().parent()?;\n \n     if let Some(bin_expr) = ast::BinExpr::cast(parent.clone()) {\n@@ -794,7 +802,7 @@ impl HasTokenAtOffset for SyntaxNode {\n     }\n }\n \n-/// find relevant `ast::PathExpr` for reference\n+/// find relevant `ast::Expr` for reference\n ///\n /// # Preconditions\n ///\n@@ -811,7 +819,11 @@ fn path_element_of_reference(\n         stdx::never!(false, \"cannot find path parent of variable usage: {:?}\", token);\n         None\n     })?;\n-    stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n+    stdx::always!(\n+        matches!(path, ast::Expr::PathExpr(_) | ast::Expr::MacroCall(_)),\n+        \"unexpected expression type for variable usage: {:?}\",\n+        path\n+    );\n     Some(path)\n }\n \n@@ -3462,4 +3474,36 @@ fn foo() -> Result<(), i64> {\n }\"##,\n         );\n     }\n+\n+    #[test]\n+    fn param_usage_in_macro() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+\n+fn foo() {\n+    let n = 1;\n+    $0let k = n * m!(n);$0\n+    let m = k + 1;\n+}\",\n+            r\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+\n+fn foo() {\n+    let n = 1;\n+    let k = fun_name(n);\n+    let m = k + 1;\n+}\n+\n+fn $0fun_name(n: i32) -> i32 {\n+    let k = n * m!(n);\n+    k\n+}\",\n+        );\n+    }\n }"}]}