{"sha": "bcb98bdc348ba58f2f8ba936412001eb9ebbeb14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYjk4YmRjMzQ4YmE1OGYyZjhiYTkzNjQxMjAwMWViOWViYmViMTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-07T12:55:08Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-08T20:58:41Z"}, "message": "canonicalize imports in map::block", "tree": {"sha": "37ae50f9db01d25ef7305b0aa4e107b9e6c8b112", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37ae50f9db01d25ef7305b0aa4e107b9e6c8b112"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcb98bdc348ba58f2f8ba936412001eb9ebbeb14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb98bdc348ba58f2f8ba936412001eb9ebbeb14", "html_url": "https://github.com/rust-lang/rust/commit/bcb98bdc348ba58f2f8ba936412001eb9ebbeb14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcb98bdc348ba58f2f8ba936412001eb9ebbeb14/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed6468da160bd67a2ce0573427f09a98daff8c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6468da160bd67a2ce0573427f09a98daff8c07", "html_url": "https://github.com/rust-lang/rust/commit/ed6468da160bd67a2ce0573427f09a98daff8c07"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "990acad2d50b22a9e1796bd81f4af5cf1d4a32b7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bcb98bdc348ba58f2f8ba936412001eb9ebbeb14/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcb98bdc348ba58f2f8ba936412001eb9ebbeb14/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=bcb98bdc348ba58f2f8ba936412001eb9ebbeb14", "patch": "@@ -12,8 +12,8 @@\n //! for the `Code` associated with a particular NodeId.\n \n use crate::hir::intravisit::FnKind;\n-use crate::hir::map;\n-use rustc_hir as ast;\n+use crate::hir::map::Map;\n+use rustc_hir as hir;\n use rustc_hir::{Expr, FnDecl, Node};\n use rustc_span::Span;\n use syntax::ast::{Attribute, Ident};\n@@ -39,37 +39,37 @@ trait MaybeFnLike {\n     fn is_fn_like(&self) -> bool;\n }\n \n-impl MaybeFnLike for ast::Item<'_> {\n+impl MaybeFnLike for hir::Item<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n-            ast::ItemKind::Fn(..) => true,\n+            hir::ItemKind::Fn(..) => true,\n             _ => false,\n         }\n     }\n }\n \n-impl MaybeFnLike for ast::ImplItem<'_> {\n+impl MaybeFnLike for hir::ImplItem<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n-            ast::ImplItemKind::Method(..) => true,\n+            hir::ImplItemKind::Method(..) => true,\n             _ => false,\n         }\n     }\n }\n \n-impl MaybeFnLike for ast::TraitItem<'_> {\n+impl MaybeFnLike for hir::TraitItem<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n-            ast::TraitItemKind::Method(_, ast::TraitMethod::Provided(_)) => true,\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n             _ => false,\n         }\n     }\n }\n \n-impl MaybeFnLike for ast::Expr<'_> {\n+impl MaybeFnLike for hir::Expr<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n-            ast::ExprKind::Closure(..) => true,\n+            hir::ExprKind::Closure(..) => true,\n             _ => false,\n         }\n     }\n@@ -85,21 +85,21 @@ pub enum Code<'a> {\n }\n \n impl<'a> Code<'a> {\n-    pub fn id(&self) -> ast::HirId {\n+    pub fn id(&self) -> hir::HirId {\n         match *self {\n             Code::FnLike(node) => node.id(),\n             Code::Expr(block) => block.hir_id,\n         }\n     }\n \n     /// Attempts to construct a Code from presumed FnLike or Expr node input.\n-    pub fn from_node(map: &map::Map<'a>, id: ast::HirId) -> Option<Code<'a>> {\n+    pub fn from_node(map: &Map<'a>, id: hir::HirId) -> Option<Code<'a>> {\n         match map.get(id) {\n-            map::Node::Block(_) => {\n+            Node::Block(_) => {\n                 //  Use the parent, hopefully an expression node.\n                 Code::from_node(map, map.get_parent_node(id))\n             }\n-            map::Node::Expr(expr) => Some(Code::Expr(expr)),\n+            Node::Expr(expr) => Some(Code::Expr(expr)),\n             node => FnLikeNode::from_node(node).map(Code::FnLike),\n         }\n     }\n@@ -109,12 +109,12 @@ impl<'a> Code<'a> {\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n     ident: Ident,\n-    decl: &'a ast::FnDecl<'a>,\n-    header: ast::FnHeader,\n-    vis: &'a ast::Visibility<'a>,\n-    generics: &'a ast::Generics<'a>,\n-    body: ast::BodyId,\n-    id: ast::HirId,\n+    decl: &'a hir::FnDecl<'a>,\n+    header: hir::FnHeader,\n+    vis: &'a hir::Visibility<'a>,\n+    generics: &'a hir::Generics<'a>,\n+    body: hir::BodyId,\n+    id: hir::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n@@ -123,17 +123,17 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl<'a>,\n-    body: ast::BodyId,\n-    id: ast::HirId,\n+    body: hir::BodyId,\n+    id: hir::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n     fn new(\n         d: &'a FnDecl<'a>,\n-        b: ast::BodyId,\n-        id: ast::HirId,\n+        b: hir::BodyId,\n+        id: hir::HirId,\n         s: Span,\n         attrs: &'a [Attribute],\n     ) -> Self {\n@@ -145,65 +145,65 @@ impl<'a> FnLikeNode<'a> {\n     /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n     pub fn from_node(node: Node<'_>) -> Option<FnLikeNode<'_>> {\n         let fn_like = match node {\n-            map::Node::Item(item) => item.is_fn_like(),\n-            map::Node::TraitItem(tm) => tm.is_fn_like(),\n-            map::Node::ImplItem(it) => it.is_fn_like(),\n-            map::Node::Expr(e) => e.is_fn_like(),\n+            Node::Item(item) => item.is_fn_like(),\n+            Node::TraitItem(tm) => tm.is_fn_like(),\n+            Node::ImplItem(it) => it.is_fn_like(),\n+            Node::Expr(e) => e.is_fn_like(),\n             _ => false,\n         };\n         fn_like.then_some(FnLikeNode { node })\n     }\n \n-    pub fn body(self) -> ast::BodyId {\n+    pub fn body(self) -> hir::BodyId {\n         self.handle(\n             |i: ItemFnParts<'a>| i.body,\n-            |_, _, _: &'a ast::FnSig<'a>, _, body: ast::BodyId, _, _| body,\n+            |_, _, _: &'a hir::FnSig<'a>, _, body: hir::BodyId, _, _| body,\n             |c: ClosureParts<'a>| c.body,\n         )\n     }\n \n     pub fn decl(self) -> &'a FnDecl<'a> {\n         self.handle(\n             |i: ItemFnParts<'a>| &*i.decl,\n-            |_, _, sig: &'a ast::FnSig<'a>, _, _, _, _| &sig.decl,\n+            |_, _, sig: &'a hir::FnSig<'a>, _, _, _, _| &sig.decl,\n             |c: ClosureParts<'a>| c.decl,\n         )\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(\n             |i: ItemFnParts<'_>| i.span,\n-            |_, _, _: &'a ast::FnSig<'a>, _, _, span, _| span,\n+            |_, _, _: &'a hir::FnSig<'a>, _, _, span, _| span,\n             |c: ClosureParts<'_>| c.span,\n         )\n     }\n \n-    pub fn id(self) -> ast::HirId {\n+    pub fn id(self) -> hir::HirId {\n         self.handle(\n             |i: ItemFnParts<'_>| i.id,\n-            |id, _, _: &'a ast::FnSig<'a>, _, _, _, _| id,\n+            |id, _, _: &'a hir::FnSig<'a>, _, _, _, _| id,\n             |c: ClosureParts<'_>| c.id,\n         )\n     }\n \n-    pub fn constness(self) -> ast::Constness {\n-        self.kind().header().map_or(ast::Constness::NotConst, |header| header.constness)\n+    pub fn constness(self) -> hir::Constness {\n+        self.kind().header().map_or(hir::Constness::NotConst, |header| header.constness)\n     }\n \n-    pub fn asyncness(self) -> ast::IsAsync {\n-        self.kind().header().map_or(ast::IsAsync::NotAsync, |header| header.asyncness)\n+    pub fn asyncness(self) -> hir::IsAsync {\n+        self.kind().header().map_or(hir::IsAsync::NotAsync, |header| header.asyncness)\n     }\n \n-    pub fn unsafety(self) -> ast::Unsafety {\n-        self.kind().header().map_or(ast::Unsafety::Normal, |header| header.unsafety)\n+    pub fn unsafety(self) -> hir::Unsafety {\n+        self.kind().header().map_or(hir::Unsafety::Normal, |header| header.unsafety)\n     }\n \n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.ident, p.generics, p.header, p.vis, p.attrs)\n         };\n         let closure = |c: ClosureParts<'a>| FnKind::Closure(c.attrs);\n-        let method = |_, ident: Ident, sig: &'a ast::FnSig<'a>, vis, _, _, attrs| {\n+        let method = |_, ident: Ident, sig: &'a hir::FnSig<'a>, vis, _, _, attrs| {\n             FnKind::Method(ident, sig, vis, attrs)\n         };\n         self.handle(item, method, closure)\n@@ -213,19 +213,19 @@ impl<'a> FnLikeNode<'a> {\n     where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(\n-            ast::HirId,\n+            hir::HirId,\n             Ident,\n-            &'a ast::FnSig<'a>,\n-            Option<&'a ast::Visibility<'a>>,\n-            ast::BodyId,\n+            &'a hir::FnSig<'a>,\n+            Option<&'a hir::Visibility<'a>>,\n+            hir::BodyId,\n             Span,\n             &'a [Attribute],\n         ) -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            map::Node::Item(i) => match i.kind {\n-                ast::ItemKind::Fn(ref sig, ref generics, block) => item_fn(ItemFnParts {\n+            Node::Item(i) => match i.kind {\n+                hir::ItemKind::Fn(ref sig, ref generics, block) => item_fn(ItemFnParts {\n                     id: i.hir_id,\n                     ident: i.ident,\n                     decl: &sig.decl,\n@@ -238,20 +238,20 @@ impl<'a> FnLikeNode<'a> {\n                 }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            map::Node::TraitItem(ti) => match ti.kind {\n-                ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n+            Node::TraitItem(ti) => match ti.kind {\n+                hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                     method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            map::Node::ImplItem(ii) => match ii.kind {\n-                ast::ImplItemKind::Method(ref sig, body) => {\n+            Node::ImplItem(ii) => match ii.kind {\n+                hir::ImplItemKind::Method(ref sig, body) => {\n                     method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                 }\n                 _ => bug!(\"impl method FnLikeNode that is not fn-like\"),\n             },\n-            map::Node::Expr(e) => match e.kind {\n-                ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) => {\n+            Node::Expr(e) => match e.kind {\n+                hir::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) => {\n                     closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs))\n                 }\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),"}]}