{"sha": "f48664068210b92f4884ee8e6fe8504dabcd4d9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ODY2NDA2ODIxMGI5MmY0ODg0ZWU4ZTZmZTg1MDRkYWJjZDRkOWE=", "commit": {"author": {"name": "Daiki Ihara", "email": "sasurau4@gmail.com", "date": "2020-12-03T15:05:39Z"}, "committer": {"name": "Daiki Ihara", "email": "sasurau4@gmail.com", "date": "2020-12-03T15:05:39Z"}, "message": "Extract tests module to file in ide_db crate", "tree": {"sha": "d01570897ca422d64b66481f18bc78fa7afd1835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d01570897ca422d64b66481f18bc78fa7afd1835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f48664068210b92f4884ee8e6fe8504dabcd4d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f48664068210b92f4884ee8e6fe8504dabcd4d9a", "html_url": "https://github.com/rust-lang/rust/commit/f48664068210b92f4884ee8e6fe8504dabcd4d9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f48664068210b92f4884ee8e6fe8504dabcd4d9a/comments", "author": {"login": "sasurau4", "id": 13580199, "node_id": "MDQ6VXNlcjEzNTgwMTk5", "avatar_url": "https://avatars.githubusercontent.com/u/13580199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sasurau4", "html_url": "https://github.com/sasurau4", "followers_url": "https://api.github.com/users/sasurau4/followers", "following_url": "https://api.github.com/users/sasurau4/following{/other_user}", "gists_url": "https://api.github.com/users/sasurau4/gists{/gist_id}", "starred_url": "https://api.github.com/users/sasurau4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sasurau4/subscriptions", "organizations_url": "https://api.github.com/users/sasurau4/orgs", "repos_url": "https://api.github.com/users/sasurau4/repos", "events_url": "https://api.github.com/users/sasurau4/events{/privacy}", "received_events_url": "https://api.github.com/users/sasurau4/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sasurau4", "id": 13580199, "node_id": "MDQ6VXNlcjEzNTgwMTk5", "avatar_url": "https://avatars.githubusercontent.com/u/13580199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sasurau4", "html_url": "https://github.com/sasurau4", "followers_url": "https://api.github.com/users/sasurau4/followers", "following_url": "https://api.github.com/users/sasurau4/following{/other_user}", "gists_url": "https://api.github.com/users/sasurau4/gists{/gist_id}", "starred_url": "https://api.github.com/users/sasurau4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sasurau4/subscriptions", "organizations_url": "https://api.github.com/users/sasurau4/orgs", "repos_url": "https://api.github.com/users/sasurau4/repos", "events_url": "https://api.github.com/users/sasurau4/events{/privacy}", "received_events_url": "https://api.github.com/users/sasurau4/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1306a43652d914035b2cf0b703f4bfd3451a33", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1306a43652d914035b2cf0b703f4bfd3451a33", "html_url": "https://github.com/rust-lang/rust/commit/5a1306a43652d914035b2cf0b703f4bfd3451a33"}], "stats": {"total": 2860, "additions": 1419, "deletions": 1441}, "files": [{"sha": "615fa7b0ee701d80cfb1521b9eb6862f5179525f", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 1, "deletions": 526, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -228,529 +228,4 @@ impl FnCallNode {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use crate::RootDatabase;\n-    use base_db::{fixture::ChangeFixture, FilePosition};\n-    use expect_test::{expect, Expect};\n-    use test_utils::{mark, RangeOrOffset};\n-\n-    /// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n-    pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n-        let change_fixture = ChangeFixture::parse(ra_fixture);\n-        let mut database = RootDatabase::default();\n-        database.apply_change(change_fixture.change);\n-        let (file_id, range_or_offset) =\n-            change_fixture.file_position.expect(\"expected a marker (<|>)\");\n-        let offset = match range_or_offset {\n-            RangeOrOffset::Range(_) => panic!(),\n-            RangeOrOffset::Offset(it) => it,\n-        };\n-        (database, FilePosition { file_id, offset })\n-    }\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let (db, position) = position(ra_fixture);\n-        let call_info = crate::call_info::call_info(&db, position);\n-        let actual = match call_info {\n-            Some(call_info) => {\n-                let docs = match &call_info.doc {\n-                    None => \"\".to_string(),\n-                    Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n-                };\n-                let params = call_info\n-                    .parameter_labels()\n-                    .enumerate()\n-                    .map(|(i, param)| {\n-                        if Some(i) == call_info.active_parameter {\n-                            format!(\"<{}>\", param)\n-                        } else {\n-                            param.to_string()\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n-            }\n-            None => String::new(),\n-        };\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args() {\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3<|>, ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3,<|> ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_empty() {\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_first_generics() {\n-        check(\n-            r#\"\n-fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-    where T: Copy + Display, U: Debug\n-{ x + y }\n-\n-fn bar() { foo(<|>3, ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: i32, y: {unknown}) -> u32\n-                (<x: i32>, y: {unknown})\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_no_params() {\n-        check(\n-            r#\"\n-fn foo<T>() -> T where T: Copy + Display {}\n-fn bar() { foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo() -> {unknown}\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_impl() {\n-        check(\n-            r#\"\n-struct F;\n-impl F { pub fn new() { } }\n-fn bar() {\n-    let _ : F = F::new(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                fn new()\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_self() {\n-        check(\n-            r#\"\n-struct S;\n-impl S { pub fn do_it(&self) {} }\n-\n-fn bar() {\n-    let s: S = S;\n-    s.do_it(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                fn do_it(&self)\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_with_arg() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-\n-fn main() { S.foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(&self, x: i32)\n-                (<x: i32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_with_arg_as_assoc_fn() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-\n-fn main() { S::foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(self: &S, x: i32)\n-                (<self: &S>, x: i32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_simple() {\n-        check(\n-            r#\"\n-/// test\n-// non-doc-comment\n-fn foo(j: u32) -> u32 {\n-    j\n-}\n-\n-fn bar() {\n-    let _ = foo(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                test\n-                ------\n-                fn foo(j: u32) -> u32\n-                (<j: u32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs() {\n-        check(\n-            r#\"\n-/// Adds one to the number given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let five = 5;\n-///\n-/// assert_eq!(6, my_crate::add_one(5));\n-/// ```\n-pub fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-\n-pub fn do() {\n-    add_one(<|>\n-}\"#,\n-            expect![[r##\"\n-                Adds one to the number given.\n-\n-                # Examples\n-\n-                ```\n-                let five = 5;\n-\n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-                ------\n-                fn add_one(x: i32) -> i32\n-                (<x: i32>)\n-            \"##]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_impl() {\n-        check(\n-            r#\"\n-struct addr;\n-impl addr {\n-    /// Adds one to the number given.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let five = 5;\n-    ///\n-    /// assert_eq!(6, my_crate::add_one(5));\n-    /// ```\n-    pub fn add_one(x: i32) -> i32 {\n-        x + 1\n-    }\n-}\n-\n-pub fn do_it() {\n-    addr {};\n-    addr::add_one(<|>);\n-}\n-\"#,\n-            expect![[r##\"\n-                Adds one to the number given.\n-\n-                # Examples\n-\n-                ```\n-                let five = 5;\n-\n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-                ------\n-                fn add_one(x: i32) -> i32\n-                (<x: i32>)\n-            \"##]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_from_actix() {\n-        check(\n-            r#\"\n-struct WriteHandler<E>;\n-\n-impl<E> WriteHandler<E> {\n-    /// Method is called when writer emits error.\n-    ///\n-    /// If this method returns `ErrorAction::Continue` writer processing\n-    /// continues otherwise stream processing stops.\n-    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n-        Running::Stop\n-    }\n-\n-    /// Method is called when writer finishes.\n-    ///\n-    /// By default this method stops actor's `Context`.\n-    fn finished(&mut self, ctx: &mut Self::Context) {\n-        ctx.stop()\n-    }\n-}\n-\n-pub fn foo(mut r: WriteHandler<()>) {\n-    r.finished(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                Method is called when writer finishes.\n-\n-                By default this method stops actor's `Context`.\n-                ------\n-                fn finished(&mut self, ctx: &mut {unknown})\n-                (<ctx: &mut {unknown}>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn call_info_bad_offset() {\n-        mark::check!(call_info_bad_offset);\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo <|> (3, ); }\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_nested_method_in_lambda() {\n-        check(\n-            r#\"\n-struct Foo;\n-impl Foo { fn bar(&self, _: u32) { } }\n-\n-fn bar(_: u32) { }\n-\n-fn main() {\n-    let foo = Foo;\n-    std::thread::spawn(move || foo.bar(<|>));\n-}\n-\"#,\n-            expect![[r#\"\n-                fn bar(&self, _: u32)\n-                (<_: u32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn works_for_tuple_structs() {\n-        check(\n-            r#\"\n-/// A cool tuple struct\n-struct S(u32, i32);\n-fn main() {\n-    let s = S(0, <|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                A cool tuple struct\n-                ------\n-                struct S(u32, i32)\n-                (u32, <i32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn generic_struct() {\n-        check(\n-            r#\"\n-struct S<T>(T);\n-fn main() {\n-    let s = S(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                struct S({unknown})\n-                (<{unknown}>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn works_for_enum_variants() {\n-        check(\n-            r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n-fn main() {\n-    let a = E::A(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                A Variant\n-                ------\n-                enum E::A(i32)\n-                (<i32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn cant_call_struct_record() {\n-        check(\n-            r#\"\n-struct S { x: u32, y: i32 }\n-fn main() {\n-    let s = S(<|>);\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn cant_call_enum_record() {\n-        check(\n-            r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n-fn main() {\n-    let a = E::C(<|>);\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn fn_signature_for_call_in_macro() {\n-        check(\n-            r#\"\n-macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n-fn foo() { }\n-id! {\n-    fn bar() { foo(<|>); }\n-}\n-\"#,\n-            expect![[r#\"\n-                fn foo()\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn call_info_for_lambdas() {\n-        check(\n-            r#\"\n-struct S;\n-fn foo(s: S) -> i32 { 92 }\n-fn main() {\n-    (|s| foo(s))(<|>)\n-}\n-        \"#,\n-            expect![[r#\"\n-                (S) -> i32\n-                (<S>)\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn call_info_for_fn_ptr() {\n-        check(\n-            r#\"\n-fn main(f: fn(i32, f64) -> char) {\n-    f(0, <|>)\n-}\n-        \"#,\n-            expect![[r#\"\n-                (i32, f64) -> char\n-                (i32, <f64>)\n-            \"#]],\n-        )\n-    }\n-}\n+mod tests;"}, {"sha": "9335aeaa5ff39a141fa6418bb924a2ccaa3b1719", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -0,0 +1,523 @@\n+use crate::RootDatabase;\n+use base_db::{fixture::ChangeFixture, FilePosition};\n+use expect_test::{expect, Expect};\n+use test_utils::{mark, RangeOrOffset};\n+\n+/// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n+pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n+    let change_fixture = ChangeFixture::parse(ra_fixture);\n+    let mut database = RootDatabase::default();\n+    database.apply_change(change_fixture.change);\n+    let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker (<|>)\");\n+    let offset = match range_or_offset {\n+        RangeOrOffset::Range(_) => panic!(),\n+        RangeOrOffset::Offset(it) => it,\n+    };\n+    (database, FilePosition { file_id, offset })\n+}\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let (db, position) = position(ra_fixture);\n+    let call_info = crate::call_info::call_info(&db, position);\n+    let actual = match call_info {\n+        Some(call_info) => {\n+            let docs = match &call_info.doc {\n+                None => \"\".to_string(),\n+                Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n+            };\n+            let params = call_info\n+                .parameter_labels()\n+                .enumerate()\n+                .map(|(i, param)| {\n+                    if Some(i) == call_info.active_parameter {\n+                        format!(\"<{}>\", param)\n+                    } else {\n+                        param.to_string()\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\", \");\n+            format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n+        }\n+        None => String::new(),\n+    };\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn test_fn_signature_two_args() {\n+    check(\n+        r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+    );\n+    check(\n+        r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3<|>, ); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+    );\n+    check(\n+        r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3,<|> ); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n+    );\n+    check(\n+        r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, <|>); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_two_args_empty() {\n+    check(\n+        r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_two_args_first_generics() {\n+    check(\n+        r#\"\n+fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n+    where T: Copy + Display, U: Debug\n+{ x + y }\n+\n+fn bar() { foo(<|>3, ); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(x: i32, y: {unknown}) -> u32\n+                (<x: i32>, y: {unknown})\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_no_params() {\n+    check(\n+        r#\"\n+fn foo<T>() -> T where T: Copy + Display {}\n+fn bar() { foo(<|>); }\n+\"#,\n+        expect![[r#\"\n+                fn foo() -> {unknown}\n+                ()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_for_impl() {\n+    check(\n+        r#\"\n+struct F;\n+impl F { pub fn new() { } }\n+fn bar() {\n+    let _ : F = F::new(<|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                fn new()\n+                ()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_for_method_self() {\n+    check(\n+        r#\"\n+struct S;\n+impl S { pub fn do_it(&self) {} }\n+\n+fn bar() {\n+    let s: S = S;\n+    s.do_it(<|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                fn do_it(&self)\n+                ()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_for_method_with_arg() {\n+    check(\n+        r#\"\n+struct S;\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+\n+fn main() { S.foo(<|>); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(&self, x: i32)\n+                (<x: i32>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_for_method_with_arg_as_assoc_fn() {\n+    check(\n+        r#\"\n+struct S;\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+\n+fn main() { S::foo(<|>); }\n+\"#,\n+        expect![[r#\"\n+                fn foo(self: &S, x: i32)\n+                (<self: &S>, x: i32)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_with_docs_simple() {\n+    check(\n+        r#\"\n+/// test\n+// non-doc-comment\n+fn foo(j: u32) -> u32 {\n+    j\n+}\n+\n+fn bar() {\n+    let _ = foo(<|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                test\n+                ------\n+                fn foo(j: u32) -> u32\n+                (<j: u32>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_with_docs() {\n+    check(\n+        r#\"\n+/// Adds one to the number given.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let five = 5;\n+///\n+/// assert_eq!(6, my_crate::add_one(5));\n+/// ```\n+pub fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+pub fn do() {\n+    add_one(<|>\n+}\"#,\n+        expect![[r##\"\n+                Adds one to the number given.\n+\n+                # Examples\n+\n+                ```\n+                let five = 5;\n+\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                fn add_one(x: i32) -> i32\n+                (<x: i32>)\n+            \"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_with_docs_impl() {\n+    check(\n+        r#\"\n+struct addr;\n+impl addr {\n+    /// Adds one to the number given.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let five = 5;\n+    ///\n+    /// assert_eq!(6, my_crate::add_one(5));\n+    /// ```\n+    pub fn add_one(x: i32) -> i32 {\n+        x + 1\n+    }\n+}\n+\n+pub fn do_it() {\n+    addr {};\n+    addr::add_one(<|>);\n+}\n+\"#,\n+        expect![[r##\"\n+                Adds one to the number given.\n+\n+                # Examples\n+\n+                ```\n+                let five = 5;\n+\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                fn add_one(x: i32) -> i32\n+                (<x: i32>)\n+            \"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_signature_with_docs_from_actix() {\n+    check(\n+        r#\"\n+struct WriteHandler<E>;\n+\n+impl<E> WriteHandler<E> {\n+    /// Method is called when writer emits error.\n+    ///\n+    /// If this method returns `ErrorAction::Continue` writer processing\n+    /// continues otherwise stream processing stops.\n+    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n+        Running::Stop\n+    }\n+\n+    /// Method is called when writer finishes.\n+    ///\n+    /// By default this method stops actor's `Context`.\n+    fn finished(&mut self, ctx: &mut Self::Context) {\n+        ctx.stop()\n+    }\n+}\n+\n+pub fn foo(mut r: WriteHandler<()>) {\n+    r.finished(<|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                Method is called when writer finishes.\n+\n+                By default this method stops actor's `Context`.\n+                ------\n+                fn finished(&mut self, ctx: &mut {unknown})\n+                (<ctx: &mut {unknown}>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn call_info_bad_offset() {\n+    mark::check!(call_info_bad_offset);\n+    check(\n+        r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo <|> (3, ); }\n+\"#,\n+        expect![[\"\"]],\n+    );\n+}\n+\n+#[test]\n+fn test_nested_method_in_lambda() {\n+    check(\n+        r#\"\n+struct Foo;\n+impl Foo { fn bar(&self, _: u32) { } }\n+\n+fn bar(_: u32) { }\n+\n+fn main() {\n+    let foo = Foo;\n+    std::thread::spawn(move || foo.bar(<|>));\n+}\n+\"#,\n+        expect![[r#\"\n+                fn bar(&self, _: u32)\n+                (<_: u32>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn works_for_tuple_structs() {\n+    check(\n+        r#\"\n+/// A cool tuple struct\n+struct S(u32, i32);\n+fn main() {\n+    let s = S(0, <|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S(u32, i32)\n+                (u32, <i32>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn generic_struct() {\n+    check(\n+        r#\"\n+struct S<T>(T);\n+fn main() {\n+    let s = S(<|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                struct S({unknown})\n+                (<{unknown}>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn works_for_enum_variants() {\n+    check(\n+        r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::A(<|>);\n+}\n+\"#,\n+        expect![[r#\"\n+                A Variant\n+                ------\n+                enum E::A(i32)\n+                (<i32>)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn cant_call_struct_record() {\n+    check(\n+        r#\"\n+struct S { x: u32, y: i32 }\n+fn main() {\n+    let s = S(<|>);\n+}\n+\"#,\n+        expect![[\"\"]],\n+    );\n+}\n+\n+#[test]\n+fn cant_call_enum_record() {\n+    check(\n+        r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::C(<|>);\n+}\n+\"#,\n+        expect![[\"\"]],\n+    );\n+}\n+\n+#[test]\n+fn fn_signature_for_call_in_macro() {\n+    check(\n+        r#\"\n+macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n+fn foo() { }\n+id! {\n+    fn bar() { foo(<|>); }\n+}\n+\"#,\n+        expect![[r#\"\n+                fn foo()\n+                ()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn call_info_for_lambdas() {\n+    check(\n+        r#\"\n+struct S;\n+fn foo(s: S) -> i32 { 92 }\n+fn main() {\n+    (|s| foo(s))(<|>)\n+}\n+        \"#,\n+        expect![[r#\"\n+                (S) -> i32\n+                (<S>)\n+            \"#]],\n+    )\n+}\n+\n+#[test]\n+fn call_info_for_fn_ptr() {\n+    check(\n+        r#\"\n+fn main(f: fn(i32, f64) -> char) {\n+    f(0, <|>)\n+}\n+        \"#,\n+        expect![[r#\"\n+                (i32, f64) -> char\n+                (i32, <f64>)\n+            \"#]],\n+    )\n+}"}, {"sha": "040843990d0d93a21c43d4283ccce5541166f6ca", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 1, "deletions": 638, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -573,641 +573,4 @@ fn find_insert_position(\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn insert_existing() {\n-        check_full(\"std::fs\", \"use std::fs;\", \"use std::fs;\")\n-    }\n-\n-    #[test]\n-    fn insert_start() {\n-        check_none(\n-            \"std::bar::AA\",\n-            r\"\n-use std::bar::B;\n-use std::bar::D;\n-use std::bar::F;\n-use std::bar::G;\",\n-            r\"\n-use std::bar::AA;\n-use std::bar::B;\n-use std::bar::D;\n-use std::bar::F;\n-use std::bar::G;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_start_indent() {\n-        mark::check!(insert_use_indent_after);\n-        check_none(\n-            \"std::bar::AA\",\n-            r\"\n-    use std::bar::B;\n-    use std::bar::D;\",\n-            r\"\n-    use std::bar::AA;\n-    use std::bar::B;\n-    use std::bar::D;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_middle() {\n-        check_none(\n-            \"std::bar::EE\",\n-            r\"\n-use std::bar::A;\n-use std::bar::D;\n-use std::bar::F;\n-use std::bar::G;\",\n-            r\"\n-use std::bar::A;\n-use std::bar::D;\n-use std::bar::EE;\n-use std::bar::F;\n-use std::bar::G;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_middle_indent() {\n-        check_none(\n-            \"std::bar::EE\",\n-            r\"\n-    use std::bar::A;\n-    use std::bar::D;\n-    use std::bar::F;\n-    use std::bar::G;\",\n-            r\"\n-    use std::bar::A;\n-    use std::bar::D;\n-    use std::bar::EE;\n-    use std::bar::F;\n-    use std::bar::G;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_end() {\n-        check_none(\n-            \"std::bar::ZZ\",\n-            r\"\n-use std::bar::A;\n-use std::bar::D;\n-use std::bar::F;\n-use std::bar::G;\",\n-            r\"\n-use std::bar::A;\n-use std::bar::D;\n-use std::bar::F;\n-use std::bar::G;\n-use std::bar::ZZ;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_end_indent() {\n-        mark::check!(insert_use_indent_before);\n-        check_none(\n-            \"std::bar::ZZ\",\n-            r\"\n-    use std::bar::A;\n-    use std::bar::D;\n-    use std::bar::F;\n-    use std::bar::G;\",\n-            r\"\n-    use std::bar::A;\n-    use std::bar::D;\n-    use std::bar::F;\n-    use std::bar::G;\n-    use std::bar::ZZ;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_middle_nested() {\n-        check_none(\n-            \"std::bar::EE\",\n-            r\"\n-use std::bar::A;\n-use std::bar::{D, Z}; // example of weird imports due to user\n-use std::bar::F;\n-use std::bar::G;\",\n-            r\"\n-use std::bar::A;\n-use std::bar::EE;\n-use std::bar::{D, Z}; // example of weird imports due to user\n-use std::bar::F;\n-use std::bar::G;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_middle_groups() {\n-        check_none(\n-            \"foo::bar::GG\",\n-            r\"\n-    use std::bar::A;\n-    use std::bar::D;\n-\n-    use foo::bar::F;\n-    use foo::bar::H;\",\n-            r\"\n-    use std::bar::A;\n-    use std::bar::D;\n-\n-    use foo::bar::F;\n-    use foo::bar::GG;\n-    use foo::bar::H;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_first_matching_group() {\n-        check_none(\n-            \"foo::bar::GG\",\n-            r\"\n-    use foo::bar::A;\n-    use foo::bar::D;\n-\n-    use std;\n-\n-    use foo::bar::F;\n-    use foo::bar::H;\",\n-            r\"\n-    use foo::bar::A;\n-    use foo::bar::D;\n-    use foo::bar::GG;\n-\n-    use std;\n-\n-    use foo::bar::F;\n-    use foo::bar::H;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_missing_group_std() {\n-        check_none(\n-            \"std::fmt\",\n-            r\"\n-    use foo::bar::A;\n-    use foo::bar::D;\",\n-            r\"\n-    use std::fmt;\n-\n-    use foo::bar::A;\n-    use foo::bar::D;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_missing_group_self() {\n-        check_none(\n-            \"self::fmt\",\n-            r\"\n-use foo::bar::A;\n-use foo::bar::D;\",\n-            r\"\n-use foo::bar::A;\n-use foo::bar::D;\n-\n-use self::fmt;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_no_imports() {\n-        check_full(\n-            \"foo::bar\",\n-            \"fn main() {}\",\n-            r\"use foo::bar;\n-\n-fn main() {}\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_empty_file() {\n-        // empty files will get two trailing newlines\n-        // this is due to the test case insert_no_imports above\n-        check_full(\n-            \"foo::bar\",\n-            \"\",\n-            r\"use foo::bar;\n-\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_empty_module() {\n-        mark::check!(insert_use_no_indent_after);\n-        check(\n-            \"foo::bar\",\n-            \"mod x {}\",\n-            r\"{\n-    use foo::bar;\n-}\",\n-            None,\n-            true,\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_after_inner_attr() {\n-        check_full(\n-            \"foo::bar\",\n-            r\"#![allow(unused_imports)]\",\n-            r\"#![allow(unused_imports)]\n-\n-use foo::bar;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn insert_after_inner_attr2() {\n-        check_full(\n-            \"foo::bar\",\n-            r\"#![allow(unused_imports)]\n-\n-#![no_std]\n-fn main() {}\",\n-            r\"#![allow(unused_imports)]\n-\n-#![no_std]\n-\n-use foo::bar;\n-fn main() {}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_after_single_line_inner_comments() {\n-        check_none(\n-            \"foo::bar::Baz\",\n-            \"//! Single line inner comments do not allow any code before them.\",\n-            r#\"//! Single line inner comments do not allow any code before them.\n-\n-use foo::bar::Baz;\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_after_multiline_inner_comments() {\n-        check_none(\n-            \"foo::bar::Baz\",\n-            r#\"/*! Multiline inner comments do not allow any code before them. */\n-\n-/*! Still an inner comment, cannot place any code before. */\n-fn main() {}\"#,\n-            r#\"/*! Multiline inner comments do not allow any code before them. */\n-\n-/*! Still an inner comment, cannot place any code before. */\n-\n-use foo::bar::Baz;\n-fn main() {}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn inserts_after_all_inner_items() {\n-        check_none(\n-            \"foo::bar::Baz\",\n-            r#\"#![allow(unused_imports)]\n-/*! Multiline line comment 2 */\n-\n-\n-//! Single line comment 1\n-#![no_std]\n-//! Single line comment 2\n-fn main() {}\"#,\n-            r#\"#![allow(unused_imports)]\n-/*! Multiline line comment 2 */\n-\n-\n-//! Single line comment 1\n-#![no_std]\n-//! Single line comment 2\n-\n-use foo::bar::Baz;\n-fn main() {}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups() {\n-        check_last(\"std::io\", r\"use std::fmt;\", r\"use std::{fmt, io};\")\n-    }\n-\n-    #[test]\n-    fn merge_groups_last() {\n-        check_last(\n-            \"std::io\",\n-            r\"use std::fmt::{Result, Display};\",\n-            r\"use std::fmt::{Result, Display};\n-use std::io;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_last_into_self() {\n-        check_last(\"foo::bar::baz\", r\"use foo::bar;\", r\"use foo::bar::{self, baz};\");\n-    }\n-\n-    #[test]\n-    fn merge_groups_full() {\n-        check_full(\n-            \"std::io\",\n-            r\"use std::fmt::{Result, Display};\",\n-            r\"use std::{fmt::{Result, Display}, io};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_long_full() {\n-        check_full(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::foo::bar::Qux;\",\n-            r\"use std::foo::bar::{Baz, Qux};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_long_last() {\n-        check_last(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::foo::bar::Qux;\",\n-            r\"use std::foo::bar::{Baz, Qux};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_long_full_list() {\n-        check_full(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::foo::bar::{Qux, Quux};\",\n-            r\"use std::foo::bar::{Baz, Quux, Qux};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_long_last_list() {\n-        check_last(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::foo::bar::{Qux, Quux};\",\n-            r\"use std::foo::bar::{Baz, Quux, Qux};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_long_full_nested() {\n-        check_full(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-            r\"use std::foo::bar::{Baz, Qux, quux::{Fez, Fizz}};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_long_last_nested() {\n-        check_last(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-            r\"use std::foo::bar::Baz;\n-use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_full_nested_deep() {\n-        check_full(\n-            \"std::foo::bar::quux::Baz\",\n-            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-            r\"use std::foo::bar::{Qux, quux::{Baz, Fez, Fizz}};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_full_nested_long() {\n-        check_full(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::{foo::bar::Qux};\",\n-            r\"use std::{foo::bar::{Baz, Qux}};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn merge_groups_last_nested_long() {\n-        check_full(\n-            \"std::foo::bar::Baz\",\n-            r\"use std::{foo::bar::Qux};\",\n-            r\"use std::{foo::bar::{Baz, Qux}};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn merge_groups_skip_pub() {\n-        check_full(\n-            \"std::io\",\n-            r\"pub use std::fmt::{Result, Display};\",\n-            r\"pub use std::fmt::{Result, Display};\n-use std::io;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_skip_pub_crate() {\n-        check_full(\n-            \"std::io\",\n-            r\"pub(crate) use std::fmt::{Result, Display};\",\n-            r\"pub(crate) use std::fmt::{Result, Display};\n-use std::io;\",\n-        )\n-    }\n-\n-    #[test]\n-    #[ignore] // FIXME: Support this\n-    fn split_out_merge() {\n-        check_last(\n-            \"std::fmt::Result\",\n-            r\"use std::{fmt, io};\",\n-            r\"use std::fmt::{self, Result};\n-use std::io;\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_into_module_import() {\n-        check_full(\n-            \"std::fmt::Result\",\n-            r\"use std::{fmt, io};\",\n-            r\"use std::{fmt::{self, Result}, io};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_groups_self() {\n-        check_full(\"std::fmt::Debug\", r\"use std::fmt;\", r\"use std::fmt::{self, Debug};\")\n-    }\n-\n-    #[test]\n-    fn merge_mod_into_glob() {\n-        check_full(\n-            \"token::TokenKind\",\n-            r\"use token::TokenKind::*;\",\n-            r\"use token::TokenKind::{*, self};\",\n-        )\n-        // FIXME: have it emit `use token::TokenKind::{self, *}`?\n-    }\n-\n-    #[test]\n-    fn merge_self_glob() {\n-        check_full(\"self\", r\"use self::*;\", r\"use self::{*, self};\")\n-        // FIXME: have it emit `use {self, *}`?\n-    }\n-\n-    #[test]\n-    fn merge_glob_nested() {\n-        check_full(\n-            \"foo::bar::quux::Fez\",\n-            r\"use foo::bar::{Baz, quux::*};\",\n-            r\"use foo::bar::{Baz, quux::{self::*, Fez}};\",\n-        )\n-    }\n-\n-    #[test]\n-    fn merge_nested_considers_first_segments() {\n-        check_full(\n-            \"hir_ty::display::write_bounds_like_dyn_trait\",\n-            r\"use hir_ty::{autoderef, display::{HirDisplayError, HirFormatter}, method_resolution};\",\n-            r\"use hir_ty::{autoderef, display::{HirDisplayError, HirFormatter, write_bounds_like_dyn_trait}, method_resolution};\",\n-        );\n-    }\n-\n-    #[test]\n-    fn skip_merge_last_too_long() {\n-        check_last(\n-            \"foo::bar\",\n-            r\"use foo::bar::baz::Qux;\",\n-            r\"use foo::bar;\n-use foo::bar::baz::Qux;\",\n-        );\n-    }\n-\n-    #[test]\n-    fn skip_merge_last_too_long2() {\n-        check_last(\n-            \"foo::bar::baz::Qux\",\n-            r\"use foo::bar;\",\n-            r\"use foo::bar;\n-use foo::bar::baz::Qux;\",\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_short_before_long() {\n-        check_none(\n-            \"foo::bar\",\n-            r\"use foo::bar::baz::Qux;\",\n-            r\"use foo::bar;\n-use foo::bar::baz::Qux;\",\n-        );\n-    }\n-\n-    #[test]\n-    fn merge_last_fail() {\n-        check_merge_only_fail(\n-            r\"use foo::bar::{baz::{Qux, Fez}};\",\n-            r\"use foo::bar::{baaz::{Quux, Feez}};\",\n-            MergeBehaviour::Last,\n-        );\n-    }\n-\n-    #[test]\n-    fn merge_last_fail1() {\n-        check_merge_only_fail(\n-            r\"use foo::bar::{baz::{Qux, Fez}};\",\n-            r\"use foo::bar::baaz::{Quux, Feez};\",\n-            MergeBehaviour::Last,\n-        );\n-    }\n-\n-    #[test]\n-    fn merge_last_fail2() {\n-        check_merge_only_fail(\n-            r\"use foo::bar::baz::{Qux, Fez};\",\n-            r\"use foo::bar::{baaz::{Quux, Feez}};\",\n-            MergeBehaviour::Last,\n-        );\n-    }\n-\n-    #[test]\n-    fn merge_last_fail3() {\n-        check_merge_only_fail(\n-            r\"use foo::bar::baz::{Qux, Fez};\",\n-            r\"use foo::bar::baaz::{Quux, Feez};\",\n-            MergeBehaviour::Last,\n-        );\n-    }\n-\n-    fn check(\n-        path: &str,\n-        ra_fixture_before: &str,\n-        ra_fixture_after: &str,\n-        mb: Option<MergeBehaviour>,\n-        module: bool,\n-    ) {\n-        let mut syntax = ast::SourceFile::parse(ra_fixture_before).tree().syntax().clone();\n-        if module {\n-            syntax = syntax.descendants().find_map(ast::Module::cast).unwrap().syntax().clone();\n-        }\n-        let file = super::ImportScope::from(syntax).unwrap();\n-        let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n-            .tree()\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::Path::cast)\n-            .unwrap();\n-\n-        let rewriter = insert_use(&file, path, mb);\n-        let result = rewriter.rewrite(file.as_syntax_node()).to_string();\n-        assert_eq_text!(&result, ra_fixture_after);\n-    }\n-\n-    fn check_full(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n-        check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Full), false)\n-    }\n-\n-    fn check_last(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n-        check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Last), false)\n-    }\n-\n-    fn check_none(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n-        check(path, ra_fixture_before, ra_fixture_after, None, false)\n-    }\n-\n-    fn check_merge_only_fail(ra_fixture0: &str, ra_fixture1: &str, mb: MergeBehaviour) {\n-        let use0 = ast::SourceFile::parse(ra_fixture0)\n-            .tree()\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::Use::cast)\n-            .unwrap();\n-\n-        let use1 = ast::SourceFile::parse(ra_fixture1)\n-            .tree()\n-            .syntax()\n-            .descendants()\n-            .find_map(ast::Use::cast)\n-            .unwrap();\n-\n-        let result = try_merge_imports(&use0, &use1, mb);\n-        assert_eq!(result.map(|u| u.to_string()), None);\n-    }\n-}\n+mod tests;"}, {"sha": "86bfa5b41ff703326f91d9aa23a66588810c0662", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "added", "additions": 620, "deletions": 0, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -0,0 +1,620 @@\n+use super::*;\n+\n+use test_utils::assert_eq_text;\n+\n+#[test]\n+fn insert_existing() {\n+    check_full(\"std::fs\", \"use std::fs;\", \"use std::fs;\")\n+}\n+\n+#[test]\n+fn insert_start() {\n+    check_none(\n+        \"std::bar::AA\",\n+        r\"\n+use std::bar::B;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+        r\"\n+use std::bar::AA;\n+use std::bar::B;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_start_indent() {\n+    mark::check!(insert_use_indent_after);\n+    check_none(\n+        \"std::bar::AA\",\n+        r\"\n+    use std::bar::B;\n+    use std::bar::D;\",\n+        r\"\n+    use std::bar::AA;\n+    use std::bar::B;\n+    use std::bar::D;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_middle() {\n+    check_none(\n+        \"std::bar::EE\",\n+        r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+        r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::EE;\n+use std::bar::F;\n+use std::bar::G;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_middle_indent() {\n+    check_none(\n+        \"std::bar::EE\",\n+        r\"\n+    use std::bar::A;\n+    use std::bar::D;\n+    use std::bar::F;\n+    use std::bar::G;\",\n+        r\"\n+    use std::bar::A;\n+    use std::bar::D;\n+    use std::bar::EE;\n+    use std::bar::F;\n+    use std::bar::G;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_end() {\n+    check_none(\n+        \"std::bar::ZZ\",\n+        r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+        r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\n+use std::bar::ZZ;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_end_indent() {\n+    mark::check!(insert_use_indent_before);\n+    check_none(\n+        \"std::bar::ZZ\",\n+        r\"\n+    use std::bar::A;\n+    use std::bar::D;\n+    use std::bar::F;\n+    use std::bar::G;\",\n+        r\"\n+    use std::bar::A;\n+    use std::bar::D;\n+    use std::bar::F;\n+    use std::bar::G;\n+    use std::bar::ZZ;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_middle_nested() {\n+    check_none(\n+        \"std::bar::EE\",\n+        r\"\n+use std::bar::A;\n+use std::bar::{D, Z}; // example of weird imports due to user\n+use std::bar::F;\n+use std::bar::G;\",\n+        r\"\n+use std::bar::A;\n+use std::bar::EE;\n+use std::bar::{D, Z}; // example of weird imports due to user\n+use std::bar::F;\n+use std::bar::G;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_middle_groups() {\n+    check_none(\n+        \"foo::bar::GG\",\n+        r\"\n+    use std::bar::A;\n+    use std::bar::D;\n+\n+    use foo::bar::F;\n+    use foo::bar::H;\",\n+        r\"\n+    use std::bar::A;\n+    use std::bar::D;\n+\n+    use foo::bar::F;\n+    use foo::bar::GG;\n+    use foo::bar::H;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_first_matching_group() {\n+    check_none(\n+        \"foo::bar::GG\",\n+        r\"\n+    use foo::bar::A;\n+    use foo::bar::D;\n+\n+    use std;\n+\n+    use foo::bar::F;\n+    use foo::bar::H;\",\n+        r\"\n+    use foo::bar::A;\n+    use foo::bar::D;\n+    use foo::bar::GG;\n+\n+    use std;\n+\n+    use foo::bar::F;\n+    use foo::bar::H;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_missing_group_std() {\n+    check_none(\n+        \"std::fmt\",\n+        r\"\n+    use foo::bar::A;\n+    use foo::bar::D;\",\n+        r\"\n+    use std::fmt;\n+\n+    use foo::bar::A;\n+    use foo::bar::D;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_missing_group_self() {\n+    check_none(\n+        \"self::fmt\",\n+        r\"\n+use foo::bar::A;\n+use foo::bar::D;\",\n+        r\"\n+use foo::bar::A;\n+use foo::bar::D;\n+\n+use self::fmt;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_no_imports() {\n+    check_full(\n+        \"foo::bar\",\n+        \"fn main() {}\",\n+        r\"use foo::bar;\n+\n+fn main() {}\",\n+    )\n+}\n+\n+#[test]\n+fn insert_empty_file() {\n+    // empty files will get two trailing newlines\n+    // this is due to the test case insert_no_imports above\n+    check_full(\n+        \"foo::bar\",\n+        \"\",\n+        r\"use foo::bar;\n+\n+\",\n+    )\n+}\n+\n+#[test]\n+fn insert_empty_module() {\n+    mark::check!(insert_use_no_indent_after);\n+    check(\n+        \"foo::bar\",\n+        \"mod x {}\",\n+        r\"{\n+    use foo::bar;\n+}\",\n+        None,\n+        true,\n+    )\n+}\n+\n+#[test]\n+fn insert_after_inner_attr() {\n+    check_full(\n+        \"foo::bar\",\n+        r\"#![allow(unused_imports)]\",\n+        r\"#![allow(unused_imports)]\n+\n+use foo::bar;\",\n+    )\n+}\n+\n+#[test]\n+fn insert_after_inner_attr2() {\n+    check_full(\n+        \"foo::bar\",\n+        r\"#![allow(unused_imports)]\n+\n+#![no_std]\n+fn main() {}\",\n+        r\"#![allow(unused_imports)]\n+\n+#![no_std]\n+\n+use foo::bar;\n+fn main() {}\",\n+    );\n+}\n+\n+#[test]\n+fn inserts_after_single_line_inner_comments() {\n+    check_none(\n+        \"foo::bar::Baz\",\n+        \"//! Single line inner comments do not allow any code before them.\",\n+        r#\"//! Single line inner comments do not allow any code before them.\n+\n+use foo::bar::Baz;\"#,\n+    );\n+}\n+\n+#[test]\n+fn inserts_after_multiline_inner_comments() {\n+    check_none(\n+        \"foo::bar::Baz\",\n+        r#\"/*! Multiline inner comments do not allow any code before them. */\n+\n+/*! Still an inner comment, cannot place any code before. */\n+fn main() {}\"#,\n+        r#\"/*! Multiline inner comments do not allow any code before them. */\n+\n+/*! Still an inner comment, cannot place any code before. */\n+\n+use foo::bar::Baz;\n+fn main() {}\"#,\n+    )\n+}\n+\n+#[test]\n+fn inserts_after_all_inner_items() {\n+    check_none(\n+        \"foo::bar::Baz\",\n+        r#\"#![allow(unused_imports)]\n+/*! Multiline line comment 2 */\n+\n+\n+//! Single line comment 1\n+#![no_std]\n+//! Single line comment 2\n+fn main() {}\"#,\n+        r#\"#![allow(unused_imports)]\n+/*! Multiline line comment 2 */\n+\n+\n+//! Single line comment 1\n+#![no_std]\n+//! Single line comment 2\n+\n+use foo::bar::Baz;\n+fn main() {}\"#,\n+    )\n+}\n+\n+#[test]\n+fn merge_groups() {\n+    check_last(\"std::io\", r\"use std::fmt;\", r\"use std::{fmt, io};\")\n+}\n+\n+#[test]\n+fn merge_groups_last() {\n+    check_last(\n+        \"std::io\",\n+        r\"use std::fmt::{Result, Display};\",\n+        r\"use std::fmt::{Result, Display};\n+use std::io;\",\n+    )\n+}\n+\n+#[test]\n+fn merge_last_into_self() {\n+    check_last(\"foo::bar::baz\", r\"use foo::bar;\", r\"use foo::bar::{self, baz};\");\n+}\n+\n+#[test]\n+fn merge_groups_full() {\n+    check_full(\n+        \"std::io\",\n+        r\"use std::fmt::{Result, Display};\",\n+        r\"use std::{fmt::{Result, Display}, io};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_long_full() {\n+    check_full(\"std::foo::bar::Baz\", r\"use std::foo::bar::Qux;\", r\"use std::foo::bar::{Baz, Qux};\")\n+}\n+\n+#[test]\n+fn merge_groups_long_last() {\n+    check_last(\"std::foo::bar::Baz\", r\"use std::foo::bar::Qux;\", r\"use std::foo::bar::{Baz, Qux};\")\n+}\n+\n+#[test]\n+fn merge_groups_long_full_list() {\n+    check_full(\n+        \"std::foo::bar::Baz\",\n+        r\"use std::foo::bar::{Qux, Quux};\",\n+        r\"use std::foo::bar::{Baz, Quux, Qux};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_long_last_list() {\n+    check_last(\n+        \"std::foo::bar::Baz\",\n+        r\"use std::foo::bar::{Qux, Quux};\",\n+        r\"use std::foo::bar::{Baz, Quux, Qux};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_long_full_nested() {\n+    check_full(\n+        \"std::foo::bar::Baz\",\n+        r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+        r\"use std::foo::bar::{Baz, Qux, quux::{Fez, Fizz}};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_long_last_nested() {\n+    check_last(\n+        \"std::foo::bar::Baz\",\n+        r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+        r\"use std::foo::bar::Baz;\n+use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_full_nested_deep() {\n+    check_full(\n+        \"std::foo::bar::quux::Baz\",\n+        r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+        r\"use std::foo::bar::{Qux, quux::{Baz, Fez, Fizz}};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_full_nested_long() {\n+    check_full(\n+        \"std::foo::bar::Baz\",\n+        r\"use std::{foo::bar::Qux};\",\n+        r\"use std::{foo::bar::{Baz, Qux}};\",\n+    );\n+}\n+\n+#[test]\n+fn merge_groups_last_nested_long() {\n+    check_full(\n+        \"std::foo::bar::Baz\",\n+        r\"use std::{foo::bar::Qux};\",\n+        r\"use std::{foo::bar::{Baz, Qux}};\",\n+    );\n+}\n+\n+#[test]\n+fn merge_groups_skip_pub() {\n+    check_full(\n+        \"std::io\",\n+        r\"pub use std::fmt::{Result, Display};\",\n+        r\"pub use std::fmt::{Result, Display};\n+use std::io;\",\n+    )\n+}\n+\n+#[test]\n+fn merge_groups_skip_pub_crate() {\n+    check_full(\n+        \"std::io\",\n+        r\"pub(crate) use std::fmt::{Result, Display};\",\n+        r\"pub(crate) use std::fmt::{Result, Display};\n+use std::io;\",\n+    )\n+}\n+\n+#[test]\n+#[ignore] // FIXME: Support this\n+fn split_out_merge() {\n+    check_last(\n+        \"std::fmt::Result\",\n+        r\"use std::{fmt, io};\",\n+        r\"use std::fmt::{self, Result};\n+use std::io;\",\n+    )\n+}\n+\n+#[test]\n+fn merge_into_module_import() {\n+    check_full(\"std::fmt::Result\", r\"use std::{fmt, io};\", r\"use std::{fmt::{self, Result}, io};\")\n+}\n+\n+#[test]\n+fn merge_groups_self() {\n+    check_full(\"std::fmt::Debug\", r\"use std::fmt;\", r\"use std::fmt::{self, Debug};\")\n+}\n+\n+#[test]\n+fn merge_mod_into_glob() {\n+    check_full(\"token::TokenKind\", r\"use token::TokenKind::*;\", r\"use token::TokenKind::{*, self};\")\n+    // FIXME: have it emit `use token::TokenKind::{self, *}`?\n+}\n+\n+#[test]\n+fn merge_self_glob() {\n+    check_full(\"self\", r\"use self::*;\", r\"use self::{*, self};\")\n+    // FIXME: have it emit `use {self, *}`?\n+}\n+\n+#[test]\n+fn merge_glob_nested() {\n+    check_full(\n+        \"foo::bar::quux::Fez\",\n+        r\"use foo::bar::{Baz, quux::*};\",\n+        r\"use foo::bar::{Baz, quux::{self::*, Fez}};\",\n+    )\n+}\n+\n+#[test]\n+fn merge_nested_considers_first_segments() {\n+    check_full(\n+        \"hir_ty::display::write_bounds_like_dyn_trait\",\n+        r\"use hir_ty::{autoderef, display::{HirDisplayError, HirFormatter}, method_resolution};\",\n+        r\"use hir_ty::{autoderef, display::{HirDisplayError, HirFormatter, write_bounds_like_dyn_trait}, method_resolution};\",\n+    );\n+}\n+\n+#[test]\n+fn skip_merge_last_too_long() {\n+    check_last(\n+        \"foo::bar\",\n+        r\"use foo::bar::baz::Qux;\",\n+        r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+    );\n+}\n+\n+#[test]\n+fn skip_merge_last_too_long2() {\n+    check_last(\n+        \"foo::bar::baz::Qux\",\n+        r\"use foo::bar;\",\n+        r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+    );\n+}\n+\n+#[test]\n+fn insert_short_before_long() {\n+    check_none(\n+        \"foo::bar\",\n+        r\"use foo::bar::baz::Qux;\",\n+        r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+    );\n+}\n+\n+#[test]\n+fn merge_last_fail() {\n+    check_merge_only_fail(\n+        r\"use foo::bar::{baz::{Qux, Fez}};\",\n+        r\"use foo::bar::{baaz::{Quux, Feez}};\",\n+        MergeBehaviour::Last,\n+    );\n+}\n+\n+#[test]\n+fn merge_last_fail1() {\n+    check_merge_only_fail(\n+        r\"use foo::bar::{baz::{Qux, Fez}};\",\n+        r\"use foo::bar::baaz::{Quux, Feez};\",\n+        MergeBehaviour::Last,\n+    );\n+}\n+\n+#[test]\n+fn merge_last_fail2() {\n+    check_merge_only_fail(\n+        r\"use foo::bar::baz::{Qux, Fez};\",\n+        r\"use foo::bar::{baaz::{Quux, Feez}};\",\n+        MergeBehaviour::Last,\n+    );\n+}\n+\n+#[test]\n+fn merge_last_fail3() {\n+    check_merge_only_fail(\n+        r\"use foo::bar::baz::{Qux, Fez};\",\n+        r\"use foo::bar::baaz::{Quux, Feez};\",\n+        MergeBehaviour::Last,\n+    );\n+}\n+\n+fn check(\n+    path: &str,\n+    ra_fixture_before: &str,\n+    ra_fixture_after: &str,\n+    mb: Option<MergeBehaviour>,\n+    module: bool,\n+) {\n+    let mut syntax = ast::SourceFile::parse(ra_fixture_before).tree().syntax().clone();\n+    if module {\n+        syntax = syntax.descendants().find_map(ast::Module::cast).unwrap().syntax().clone();\n+    }\n+    let file = super::ImportScope::from(syntax).unwrap();\n+    let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n+        .tree()\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::Path::cast)\n+        .unwrap();\n+\n+    let rewriter = insert_use(&file, path, mb);\n+    let result = rewriter.rewrite(file.as_syntax_node()).to_string();\n+    assert_eq_text!(&result, ra_fixture_after);\n+}\n+\n+fn check_full(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+    check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Full), false)\n+}\n+\n+fn check_last(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+    check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Last), false)\n+}\n+\n+fn check_none(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+    check(path, ra_fixture_before, ra_fixture_after, None, false)\n+}\n+\n+fn check_merge_only_fail(ra_fixture0: &str, ra_fixture1: &str, mb: MergeBehaviour) {\n+    let use0 = ast::SourceFile::parse(ra_fixture0)\n+        .tree()\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::Use::cast)\n+        .unwrap();\n+\n+    let use1 = ast::SourceFile::parse(ra_fixture1)\n+        .tree()\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::Use::cast)\n+        .unwrap();\n+\n+    let result = try_merge_imports(&use0, &use1, mb);\n+    assert_eq!(result.map(|u| u.to_string()), None);\n+}"}, {"sha": "41226305eaab8c138e1bdaa86b78d74a8be256e0", "filename": "crates/ide_db/src/line_index.rs", "status": "modified", "additions": 1, "deletions": 130, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fline_index.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -149,133 +149,4 @@ impl LineIndex {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_line_index() {\n-        let text = \"hello\\nworld\";\n-        let index = LineIndex::new(text);\n-        assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n-        assert_eq!(index.line_col(1.into()), LineCol { line: 0, col_utf16: 1 });\n-        assert_eq!(index.line_col(5.into()), LineCol { line: 0, col_utf16: 5 });\n-        assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 0 });\n-        assert_eq!(index.line_col(7.into()), LineCol { line: 1, col_utf16: 1 });\n-        assert_eq!(index.line_col(8.into()), LineCol { line: 1, col_utf16: 2 });\n-        assert_eq!(index.line_col(10.into()), LineCol { line: 1, col_utf16: 4 });\n-        assert_eq!(index.line_col(11.into()), LineCol { line: 1, col_utf16: 5 });\n-        assert_eq!(index.line_col(12.into()), LineCol { line: 1, col_utf16: 6 });\n-\n-        let text = \"\\nhello\\nworld\";\n-        let index = LineIndex::new(text);\n-        assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n-        assert_eq!(index.line_col(1.into()), LineCol { line: 1, col_utf16: 0 });\n-        assert_eq!(index.line_col(2.into()), LineCol { line: 1, col_utf16: 1 });\n-        assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 5 });\n-        assert_eq!(index.line_col(7.into()), LineCol { line: 2, col_utf16: 0 });\n-    }\n-\n-    #[test]\n-    fn test_char_len() {\n-        assert_eq!('\u30e1'.len_utf8(), 3);\n-        assert_eq!('\u30e1'.len_utf16(), 1);\n-    }\n-\n-    #[test]\n-    fn test_empty_index() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = 'x';\n-\",\n-        );\n-        assert_eq!(col_index.utf16_lines.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_single_char() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = '\u30e1';\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-\n-        // UTF-8 to UTF-16, no changes\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 22.into()), 20);\n-\n-        // UTF-16 to UTF-8, no changes\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21));\n-\n-        let col_index = LineIndex::new(\"a\ud801\udc0fb\");\n-        assert_eq!(col_index.utf16_to_utf8_col(0, 3), TextSize::from(5));\n-    }\n-\n-    #[test]\n-    fn test_string() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = \\\"\u30e1 \u30e1\\\";\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 2);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-        assert_eq!(col_index.utf16_lines[&1][1], Utf16Char { start: 21.into(), end: 24.into() });\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 21.into()), 19);\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 25.into()), 21);\n-\n-        assert!(col_index.utf8_to_utf16_col(2, 15.into()) == 15);\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n-\n-        // \u30e1 UTF-8: 0xE3 0x83 0xA1, UTF-16: 0x30E1\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 17), TextSize::from(17)); // first \u30e1 at 17..20\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextSize::from(20)); // space\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21)); // second \u30e1 at 21..24\n-\n-        assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextSize::from(15));\n-    }\n-\n-    #[test]\n-    fn test_splitlines() {\n-        fn r(lo: u32, hi: u32) -> TextRange {\n-            TextRange::new(lo.into(), hi.into())\n-        }\n-\n-        let text = \"a\\nbb\\nccc\\n\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 9)).collect::<Vec<_>>();\n-        let expected = vec![r(0, 2), r(2, 5), r(5, 9)];\n-        assert_eq!(actual, expected);\n-\n-        let text = \"\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 0)).collect::<Vec<_>>();\n-        let expected = vec![];\n-        assert_eq!(actual, expected);\n-\n-        let text = \"\\n\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 1)).collect::<Vec<_>>();\n-        let expected = vec![r(0, 1)];\n-        assert_eq!(actual, expected)\n-    }\n-}\n+mod tests;"}, {"sha": "05f7484e8feb3825b3104c2a25933637c43d359a", "filename": "crates/ide_db/src/line_index/tests.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fline_index%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Fline_index%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fline_index%2Ftests.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -0,0 +1,128 @@\n+use super::*;\n+\n+#[test]\n+fn test_line_index() {\n+    let text = \"hello\\nworld\";\n+    let index = LineIndex::new(text);\n+    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n+    assert_eq!(index.line_col(1.into()), LineCol { line: 0, col_utf16: 1 });\n+    assert_eq!(index.line_col(5.into()), LineCol { line: 0, col_utf16: 5 });\n+    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 0 });\n+    assert_eq!(index.line_col(7.into()), LineCol { line: 1, col_utf16: 1 });\n+    assert_eq!(index.line_col(8.into()), LineCol { line: 1, col_utf16: 2 });\n+    assert_eq!(index.line_col(10.into()), LineCol { line: 1, col_utf16: 4 });\n+    assert_eq!(index.line_col(11.into()), LineCol { line: 1, col_utf16: 5 });\n+    assert_eq!(index.line_col(12.into()), LineCol { line: 1, col_utf16: 6 });\n+\n+    let text = \"\\nhello\\nworld\";\n+    let index = LineIndex::new(text);\n+    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n+    assert_eq!(index.line_col(1.into()), LineCol { line: 1, col_utf16: 0 });\n+    assert_eq!(index.line_col(2.into()), LineCol { line: 1, col_utf16: 1 });\n+    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 5 });\n+    assert_eq!(index.line_col(7.into()), LineCol { line: 2, col_utf16: 0 });\n+}\n+\n+#[test]\n+fn test_char_len() {\n+    assert_eq!('\u30e1'.len_utf8(), 3);\n+    assert_eq!('\u30e1'.len_utf16(), 1);\n+}\n+\n+#[test]\n+fn test_empty_index() {\n+    let col_index = LineIndex::new(\n+        \"\n+const C: char = 'x';\n+\",\n+    );\n+    assert_eq!(col_index.utf16_lines.len(), 0);\n+}\n+\n+#[test]\n+fn test_single_char() {\n+    let col_index = LineIndex::new(\n+        \"\n+const C: char = '\u30e1';\n+\",\n+    );\n+\n+    assert_eq!(col_index.utf16_lines.len(), 1);\n+    assert_eq!(col_index.utf16_lines[&1].len(), 1);\n+    assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n+\n+    // UTF-8 to UTF-16, no changes\n+    assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n+\n+    // UTF-8 to UTF-16\n+    assert_eq!(col_index.utf8_to_utf16_col(1, 22.into()), 20);\n+\n+    // UTF-16 to UTF-8, no changes\n+    assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n+\n+    // UTF-16 to UTF-8\n+    assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21));\n+\n+    let col_index = LineIndex::new(\"a\ud801\udc0fb\");\n+    assert_eq!(col_index.utf16_to_utf8_col(0, 3), TextSize::from(5));\n+}\n+\n+#[test]\n+fn test_string() {\n+    let col_index = LineIndex::new(\n+        \"\n+const C: char = \\\"\u30e1 \u30e1\\\";\n+\",\n+    );\n+\n+    assert_eq!(col_index.utf16_lines.len(), 1);\n+    assert_eq!(col_index.utf16_lines[&1].len(), 2);\n+    assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n+    assert_eq!(col_index.utf16_lines[&1][1], Utf16Char { start: 21.into(), end: 24.into() });\n+\n+    // UTF-8 to UTF-16\n+    assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n+\n+    assert_eq!(col_index.utf8_to_utf16_col(1, 21.into()), 19);\n+    assert_eq!(col_index.utf8_to_utf16_col(1, 25.into()), 21);\n+\n+    assert!(col_index.utf8_to_utf16_col(2, 15.into()) == 15);\n+\n+    // UTF-16 to UTF-8\n+    assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n+\n+    // \u30e1 UTF-8: 0xE3 0x83 0xA1, UTF-16: 0x30E1\n+    assert_eq!(col_index.utf16_to_utf8_col(1, 17), TextSize::from(17)); // first \u30e1 at 17..20\n+    assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextSize::from(20)); // space\n+    assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21)); // second \u30e1 at 21..24\n+\n+    assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextSize::from(15));\n+}\n+\n+#[test]\n+fn test_splitlines() {\n+    fn r(lo: u32, hi: u32) -> TextRange {\n+        TextRange::new(lo.into(), hi.into())\n+    }\n+\n+    let text = \"a\\nbb\\nccc\\n\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 9)).collect::<Vec<_>>();\n+    let expected = vec![r(0, 2), r(2, 5), r(5, 9)];\n+    assert_eq!(actual, expected);\n+\n+    let text = \"\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 0)).collect::<Vec<_>>();\n+    let expected = vec![];\n+    assert_eq!(actual, expected);\n+\n+    let text = \"\\n\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 1)).collect::<Vec<_>>();\n+    let expected = vec![r(0, 1)];\n+    assert_eq!(actual, expected)\n+}"}, {"sha": "78a43f587ab0e5cf4730212b09f86f019d13f053", "filename": "crates/ide_db/src/traits.rs", "status": "modified", "additions": 1, "deletions": 147, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftraits.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -78,150 +78,4 @@ pub fn get_missing_assoc_items(\n }\n \n #[cfg(test)]\n-mod tests {\n-    use crate::RootDatabase;\n-    use base_db::{fixture::ChangeFixture, FilePosition};\n-    use expect_test::{expect, Expect};\n-    use hir::Semantics;\n-    use syntax::ast::{self, AstNode};\n-    use test_utils::RangeOrOffset;\n-\n-    /// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n-    pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n-        let change_fixture = ChangeFixture::parse(ra_fixture);\n-        let mut database = RootDatabase::default();\n-        database.apply_change(change_fixture.change);\n-        let (file_id, range_or_offset) =\n-            change_fixture.file_position.expect(\"expected a marker (<|>)\");\n-        let offset = match range_or_offset {\n-            RangeOrOffset::Range(_) => panic!(),\n-            RangeOrOffset::Offset(it) => it,\n-        };\n-        (database, FilePosition { file_id, offset })\n-    }\n-\n-    fn check_trait(ra_fixture: &str, expect: Expect) {\n-        let (db, position) = position(ra_fixture);\n-        let sema = Semantics::new(&db);\n-        let file = sema.parse(position.file_id);\n-        let impl_block: ast::Impl =\n-            sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();\n-        let trait_ = crate::traits::resolve_target_trait(&sema, &impl_block);\n-        let actual = match trait_ {\n-            Some(trait_) => trait_.name(&db).to_string(),\n-            None => String::new(),\n-        };\n-        expect.assert_eq(&actual);\n-    }\n-\n-    fn check_missing_assoc(ra_fixture: &str, expect: Expect) {\n-        let (db, position) = position(ra_fixture);\n-        let sema = Semantics::new(&db);\n-        let file = sema.parse(position.file_id);\n-        let impl_block: ast::Impl =\n-            sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();\n-        let items = crate::traits::get_missing_assoc_items(&sema, &impl_block);\n-        let actual = items\n-            .into_iter()\n-            .map(|item| item.name(&db).unwrap().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn resolve_trait() {\n-        check_trait(\n-            r#\"\n-pub trait Foo {\n-    fn bar();\n-}\n-impl Foo for u8 {\n-    <|>\n-}\n-            \"#,\n-            expect![[\"Foo\"]],\n-        );\n-        check_trait(\n-            r#\"\n-pub trait Foo {\n-    fn bar();\n-}\n-impl Foo for u8 {\n-    fn bar() {\n-        fn baz() {\n-            <|>\n-        }\n-        baz();\n-    }\n-}\n-            \"#,\n-            expect![[\"Foo\"]],\n-        );\n-        check_trait(\n-            r#\"\n-pub trait Foo {\n-    fn bar();\n-}\n-pub struct Bar;\n-impl Bar {\n-    <|>\n-}\n-            \"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn missing_assoc_items() {\n-        check_missing_assoc(\n-            r#\"\n-pub trait Foo {\n-    const FOO: u8;\n-    fn bar();\n-}\n-impl Foo for u8 {\n-    <|>\n-}\"#,\n-            expect![[r#\"\n-                FOO\n-                bar\"#]],\n-        );\n-\n-        check_missing_assoc(\n-            r#\"\n-pub trait Foo {\n-    const FOO: u8;\n-    fn bar();\n-}\n-impl Foo for u8 {\n-    const FOO: u8 = 10;\n-    <|>\n-}\"#,\n-            expect![[r#\"\n-                bar\"#]],\n-        );\n-\n-        check_missing_assoc(\n-            r#\"\n-pub trait Foo {\n-    const FOO: u8;\n-    fn bar();\n-}\n-impl Foo for u8 {\n-    const FOO: u8 = 10;\n-    fn bar() {<|>}\n-}\"#,\n-            expect![[r#\"\"#]],\n-        );\n-\n-        check_missing_assoc(\n-            r#\"\n-pub struct Foo;\n-impl Foo {\n-    fn bar() {<|>}\n-}\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-}\n+mod tests;"}, {"sha": "09c7ac3ec4a8f3816fd2107de79e0ae064da622c", "filename": "crates/ide_db/src/traits/tests.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48664068210b92f4884ee8e6fe8504dabcd4d9a/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs?ref=f48664068210b92f4884ee8e6fe8504dabcd4d9a", "patch": "@@ -0,0 +1,144 @@\n+use crate::RootDatabase;\n+use base_db::{fixture::ChangeFixture, FilePosition};\n+use expect_test::{expect, Expect};\n+use hir::Semantics;\n+use syntax::ast::{self, AstNode};\n+use test_utils::RangeOrOffset;\n+\n+/// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n+pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n+    let change_fixture = ChangeFixture::parse(ra_fixture);\n+    let mut database = RootDatabase::default();\n+    database.apply_change(change_fixture.change);\n+    let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker (<|>)\");\n+    let offset = match range_or_offset {\n+        RangeOrOffset::Range(_) => panic!(),\n+        RangeOrOffset::Offset(it) => it,\n+    };\n+    (database, FilePosition { file_id, offset })\n+}\n+\n+fn check_trait(ra_fixture: &str, expect: Expect) {\n+    let (db, position) = position(ra_fixture);\n+    let sema = Semantics::new(&db);\n+    let file = sema.parse(position.file_id);\n+    let impl_block: ast::Impl =\n+        sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();\n+    let trait_ = crate::traits::resolve_target_trait(&sema, &impl_block);\n+    let actual = match trait_ {\n+        Some(trait_) => trait_.name(&db).to_string(),\n+        None => String::new(),\n+    };\n+    expect.assert_eq(&actual);\n+}\n+\n+fn check_missing_assoc(ra_fixture: &str, expect: Expect) {\n+    let (db, position) = position(ra_fixture);\n+    let sema = Semantics::new(&db);\n+    let file = sema.parse(position.file_id);\n+    let impl_block: ast::Impl =\n+        sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();\n+    let items = crate::traits::get_missing_assoc_items(&sema, &impl_block);\n+    let actual = items\n+        .into_iter()\n+        .map(|item| item.name(&db).unwrap().to_string())\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn resolve_trait() {\n+    check_trait(\n+        r#\"\n+pub trait Foo {\n+    fn bar();\n+}\n+impl Foo for u8 {\n+    <|>\n+}\n+            \"#,\n+        expect![[\"Foo\"]],\n+    );\n+    check_trait(\n+        r#\"\n+pub trait Foo {\n+    fn bar();\n+}\n+impl Foo for u8 {\n+    fn bar() {\n+        fn baz() {\n+            <|>\n+        }\n+        baz();\n+    }\n+}\n+            \"#,\n+        expect![[\"Foo\"]],\n+    );\n+    check_trait(\n+        r#\"\n+pub trait Foo {\n+    fn bar();\n+}\n+pub struct Bar;\n+impl Bar {\n+    <|>\n+}\n+            \"#,\n+        expect![[\"\"]],\n+    );\n+}\n+\n+#[test]\n+fn missing_assoc_items() {\n+    check_missing_assoc(\n+        r#\"\n+pub trait Foo {\n+    const FOO: u8;\n+    fn bar();\n+}\n+impl Foo for u8 {\n+    <|>\n+}\"#,\n+        expect![[r#\"\n+                FOO\n+                bar\"#]],\n+    );\n+\n+    check_missing_assoc(\n+        r#\"\n+pub trait Foo {\n+    const FOO: u8;\n+    fn bar();\n+}\n+impl Foo for u8 {\n+    const FOO: u8 = 10;\n+    <|>\n+}\"#,\n+        expect![[r#\"\n+                bar\"#]],\n+    );\n+\n+    check_missing_assoc(\n+        r#\"\n+pub trait Foo {\n+    const FOO: u8;\n+    fn bar();\n+}\n+impl Foo for u8 {\n+    const FOO: u8 = 10;\n+    fn bar() {<|>}\n+}\"#,\n+        expect![[r#\"\"#]],\n+    );\n+\n+    check_missing_assoc(\n+        r#\"\n+pub struct Foo;\n+impl Foo {\n+    fn bar() {<|>}\n+}\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}"}]}