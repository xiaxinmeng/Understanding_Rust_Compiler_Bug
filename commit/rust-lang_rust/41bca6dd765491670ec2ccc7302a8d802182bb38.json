{"sha": "41bca6dd765491670ec2ccc7302a8d802182bb38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYmNhNmRkNzY1NDkxNjcwZWMyY2NjNzMwMmE4ZDgwMjE4MmJiMzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-17T00:19:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-28T22:48:49Z"}, "message": "Remove contraction. The contraction rules predated the notion of an\nempty region, and they complicate region inference to no particular end.\nThey also lead in some cases to spurious errors like #29048 (though in\nsome cases these errors are helpful in tracking down missing\nconstraints).", "tree": {"sha": "324d9a625794c24e697f9fe3a2db11bd8ede8161", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/324d9a625794c24e697f9fe3a2db11bd8ede8161"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41bca6dd765491670ec2ccc7302a8d802182bb38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41bca6dd765491670ec2ccc7302a8d802182bb38", "html_url": "https://github.com/rust-lang/rust/commit/41bca6dd765491670ec2ccc7302a8d802182bb38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41bca6dd765491670ec2ccc7302a8d802182bb38/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60ab57e56d0bbadb8b2643a03c6d8799048e8342", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ab57e56d0bbadb8b2643a03c6d8799048e8342", "html_url": "https://github.com/rust-lang/rust/commit/60ab57e56d0bbadb8b2643a03c6d8799048e8342"}], "stats": {"total": 370, "additions": 58, "deletions": 312}, "files": [{"sha": "6770ad415642f6ac4951992f58c2c1d7b0022509", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 18, "deletions": 291, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=41bca6dd765491670ec2ccc7302a8d802182bb38", "patch": "@@ -16,19 +16,16 @@ pub use self::UndoLogEntry::*;\n pub use self::CombineMapType::*;\n pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n-use self::Classification::*;\n \n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use middle::free_region::FreeRegionMap;\n-use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty::error::TypeError;\n-use middle::ty::relate::RelateResult;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -824,147 +821,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           }\n         }\n     }\n-\n-    fn glb_concrete_regions(&self,\n-                            free_regions: &FreeRegionMap,\n-                            a: Region,\n-                            b: Region)\n-                            -> RelateResult<'tcx, Region>\n-    {\n-        debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n-        match (a, b) {\n-            (ReLateBound(..), _) |\n-            (_, ReLateBound(..)) |\n-            (ReEarlyBound(..), _) |\n-            (_, ReEarlyBound(..)) => {\n-              self.tcx.sess.bug(\n-                  &format!(\"cannot relate bound region: GLB({:?}, {:?})\",\n-                          a,\n-                          b));\n-            }\n-\n-            (ReStatic, r) | (r, ReStatic) => {\n-                // static lives longer than everything else\n-                Ok(r)\n-            }\n-\n-            (ReEmpty, _) | (_, ReEmpty) => {\n-                // nothing lives shorter than everything else\n-                Ok(ReEmpty)\n-            }\n-\n-            (ReVar(v_id), _) |\n-            (_, ReVar(v_id)) => {\n-                self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[v_id.index as usize].span(),\n-                    &format!(\"glb_concrete_regions invoked with \\\n-                             non-concrete regions: {:?}, {:?}\",\n-                            a,\n-                            b));\n-            }\n-\n-            (ReFree(fr), ReScope(s_id)) |\n-            (ReScope(s_id), ReFree(fr)) => {\n-                let s = ReScope(s_id);\n-                // Free region is something \"at least as big as\n-                // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger\n-                // than the scope `s_id`, then we can say that the GLB\n-                // is the scope `s_id`.  Otherwise, as we do not know\n-                // big the free region is precisely, the GLB is undefined.\n-                if self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id) == fr.scope ||\n-                        free_regions.is_static(fr) {\n-                    Ok(s)\n-                } else {\n-                    Err(TypeError::RegionsNoOverlap(b, a))\n-                }\n-            }\n-\n-            (ReScope(a_id), ReScope(b_id)) => {\n-                self.intersect_scopes(a, b, a_id, b_id)\n-            }\n-\n-            (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n-                self.glb_free_regions(free_regions, a_fr, b_fr)\n-            }\n-\n-            // For these types, we cannot define any additional\n-            // relationship:\n-            (ReSkolemized(..), _) |\n-            (_, ReSkolemized(..)) => {\n-                if a == b {\n-                    Ok(a)\n-                } else {\n-                    Err(TypeError::RegionsNoOverlap(b, a))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Computes a region that is enclosed by both free region arguments, if any. Guarantees that\n-    /// if the same two regions are given as argument, in any order, a consistent result is\n-    /// returned.\n-    fn glb_free_regions(&self,\n-                        free_regions: &FreeRegionMap,\n-                        a: &FreeRegion,\n-                        b: &FreeRegion)\n-                        -> RelateResult<'tcx, ty::Region>\n-    {\n-        return match a.cmp(b) {\n-            Less => helper(self, free_regions, a, b),\n-            Greater => helper(self, free_regions, b, a),\n-            Equal => Ok(ty::ReFree(*a))\n-        };\n-\n-        fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n-                            free_regions: &FreeRegionMap,\n-                            a: &FreeRegion,\n-                            b: &FreeRegion) -> RelateResult<'tcx, ty::Region>\n-        {\n-            if free_regions.sub_free_region(*a, *b) {\n-                Ok(ty::ReFree(*a))\n-            } else if free_regions.sub_free_region(*b, *a) {\n-                Ok(ty::ReFree(*b))\n-            } else {\n-                this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n-                                      a.scope, b.scope)\n-            }\n-        }\n-    }\n-\n-    fn intersect_scopes(&self,\n-                        region_a: ty::Region,\n-                        region_b: ty::Region,\n-                        scope_a: region::CodeExtent,\n-                        scope_b: region::CodeExtent)\n-                        -> RelateResult<'tcx, Region>\n-    {\n-        // We want to generate the intersection of two\n-        // scopes or two free regions.  So, if one of\n-        // these scopes is a subscope of the other, return\n-        // it. Otherwise fail.\n-        debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n-               scope_a, scope_b, region_a, region_b);\n-        let r_id = self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b);\n-        if r_id == scope_a {\n-            Ok(ReScope(scope_b))\n-        } else if r_id == scope_b {\n-            Ok(ReScope(scope_a))\n-        } else {\n-            Err(TypeError::RegionsNoOverlap(region_a, region_b))\n-        }\n-    }\n }\n \n // ______________________________________________________________________\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum Classification { Expanding, Contracting }\n-\n #[derive(Copy, Clone, Debug)]\n-pub enum VarValue { NoValue, Value(Region), ErrorValue }\n+pub enum VarValue { Value(Region), ErrorValue }\n \n struct VarData {\n-    classification: Classification,\n     value: VarValue,\n }\n \n@@ -1005,12 +869,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn construct_var_data(&self) -> Vec<VarData> {\n         (0..self.num_vars() as usize).map(|_| {\n             VarData {\n-                // All nodes are initially classified as contracting; during\n-                // the expansion phase, we will shift the classification for\n-                // those nodes that have a concrete region predecessor to\n-                // Expanding.\n-                classification: Contracting,\n-                value: NoValue,\n+                value: Value(ty::ReEmpty),\n             }\n         }).collect()\n     }\n@@ -1062,11 +921,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n                 match var_data[a_vid.index as usize].value {\n-                  NoValue | ErrorValue => false,\n-                  Value(a_region) => {\n-                    let b_node = &mut var_data[b_vid.index as usize];\n-                    self.expand_node(free_regions, a_region, b_vid, b_node)\n-                  }\n+                    ErrorValue => false,\n+                    Value(a_region) => {\n+                        let b_node = &mut var_data[b_vid.index as usize];\n+                        self.expand_node(free_regions, a_region, b_vid, b_node)\n+                    }\n                 }\n               }\n               ConstrainVarSubReg(..) => {\n@@ -1100,16 +959,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             _ => { }\n         }\n \n-        b_data.classification = Expanding;\n         match b_data.value {\n-          NoValue => {\n-            debug!(\"Setting initial value of {:?} to {:?}\",\n-                   b_vid, a_region);\n-\n-            b_data.value = Value(a_region);\n-            return true;\n-          }\n-\n           Value(cur_region) => {\n             let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n             if lub == cur_region {\n@@ -1148,7 +998,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n                 match var_data[b_vid.index as usize].value {\n-                  NoValue | ErrorValue => false,\n+                  ErrorValue => false,\n                   Value(b_region) => {\n                     let a_data = &mut var_data[a_vid.index as usize];\n                     self.contract_node(free_regions, a_vid, a_data, b_region)\n@@ -1169,27 +1019,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n-               a_vid, a_data.value,\n-               a_data.classification, b_region);\n+        debug!(\"contract_node({:?} == {:?}, {:?})\",\n+               a_vid, a_data.value, b_region);\n \n         return match a_data.value {\n-            NoValue => {\n-                assert_eq!(a_data.classification, Contracting);\n-                a_data.value = Value(b_region);\n-                true // changed\n-            }\n-\n             ErrorValue => false, // no change\n-\n-            Value(a_region) => {\n-                match a_data.classification {\n-                    Expanding =>\n-                        check_node(self, free_regions, a_vid, a_data, a_region, b_region),\n-                    Contracting =>\n-                        adjust_node(self, free_regions, a_vid, a_data, a_region, b_region),\n-                }\n-            }\n+            Value(a_region) => check_node(self, free_regions, a_vid, a_data, a_region, b_region),\n         };\n \n         fn check_node(this: &RegionVarBindings,\n@@ -1209,37 +1044,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n             false\n         }\n-\n-        fn adjust_node(this: &RegionVarBindings,\n-                       free_regions: &FreeRegionMap,\n-                       a_vid: RegionVid,\n-                       a_data: &mut VarData,\n-                       a_region: Region,\n-                       b_region: Region)\n-                       -> bool {\n-            match this.glb_concrete_regions(free_regions, a_region, b_region) {\n-                Ok(glb) => {\n-                    if glb == a_region {\n-                        false\n-                    } else {\n-                        debug!(\"Contracting value of {:?} from {:?} to {:?}\",\n-                               a_vid,\n-                               a_region,\n-                               glb);\n-                        a_data.value = Value(glb);\n-                        true\n-                    }\n-                }\n-                Err(_) => {\n-                    debug!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n-                           a_vid,\n-                           a_region,\n-                           b_region);\n-                    a_data.value = ErrorValue;\n-                    false\n-                }\n-            }\n-        }\n     }\n \n     fn collect_concrete_region_errors(&self,\n@@ -1308,12 +1112,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 Value(_) => {\n                     /* Inference successful */\n                 }\n-                NoValue => {\n-                    /* Unconstrained inference: do not report an error\n-                       until the value of this variable is requested.\n-                       After all, sometimes we make region variables but never\n-                       really use their values. */\n-                }\n                 ErrorValue => {\n                     /* Inference impossible, this value contains\n                        inconsistent constraints.\n@@ -1339,18 +1137,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                        this portion of the code and think hard about it. =) */\n \n                     let node_vid = RegionVid { index: idx as u32 };\n-                    match var_data[idx].classification {\n-                        Expanding => {\n-                            self.collect_error_for_expanding_node(\n-                                free_regions, graph, var_data, &mut dup_vec,\n-                                node_vid, errors);\n-                        }\n-                        Contracting => {\n-                            self.collect_error_for_contracting_node(\n-                                free_regions, graph, var_data, &mut dup_vec,\n-                                node_vid, errors);\n-                        }\n-                    }\n+                    self.collect_error_for_expanding_node(\n+                        free_regions, graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n         }\n@@ -1396,19 +1184,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn collect_error_for_expanding_node(&self,\n                                         free_regions: &FreeRegionMap,\n                                         graph: &RegionGraph,\n-                                        var_data: &[VarData],\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n                                         errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::INCOMING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, graph::INCOMING, dup_vec);\n         let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::OUTGOING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, graph::OUTGOING, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n@@ -1459,59 +1244,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     upper_bounds));\n     }\n \n-    fn collect_error_for_contracting_node(\n-        &self,\n-        free_regions: &FreeRegionMap,\n-        graph: &RegionGraph,\n-        var_data: &[VarData],\n-        dup_vec: &mut [u32],\n-        node_idx: RegionVid,\n-        errors: &mut Vec<RegionResolutionError<'tcx>>)\n-    {\n-        // Errors in contracting nodes result from two upper-bounds\n-        // that have no intersection.\n-        let (upper_bounds, dup_found) =\n-            self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::OUTGOING, dup_vec);\n-\n-        if dup_found {\n-            return;\n-        }\n-\n-        for upper_bound_1 in &upper_bounds {\n-            for upper_bound_2 in &upper_bounds {\n-                match self.glb_concrete_regions(free_regions,\n-                                                upper_bound_1.region,\n-                                                upper_bound_2.region) {\n-                    Ok(_) => {}\n-                    Err(_) => {\n-                        let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n-                        debug!(\"region inference error at {:?} for {:?}: \\\n-                                SupSupConflict sub: {:?} sup: {:?}\",\n-                               origin, node_idx, upper_bound_1.region, upper_bound_2.region);\n-                        errors.push(SupSupConflict(\n-                            origin,\n-                            upper_bound_1.origin.clone(),\n-                            upper_bound_1.region,\n-                            upper_bound_2.origin.clone(),\n-                            upper_bound_2.region));\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n-            &format!(\"collect_error_for_contracting_node() could not find error \\\n-                     for var {:?}, upper_bounds={:?}\",\n-                    node_idx,\n-                    upper_bounds));\n-    }\n-\n     fn collect_concrete_regions(&self,\n                                 graph: &RegionGraph,\n-                                var_data: &[VarData],\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [u32])\n@@ -1536,7 +1270,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n-            let classification = var_data[node_idx.index as usize].classification;\n \n             // check whether we've visited this node on some previous walk\n             if dup_vec[node_idx.index as usize] == u32::MAX {\n@@ -1545,17 +1278,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 state.dup_found = true;\n             }\n \n-            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n-                    classification={:?})\",\n-                   orig_node_idx, node_idx, classification);\n+            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n+                   orig_node_idx, node_idx);\n \n             // figure out the direction from which this node takes its\n             // values, and search for concrete regions etc in that direction\n-            let dir = match classification {\n-                Expanding => graph::INCOMING,\n-                Contracting => graph::OUTGOING,\n-            };\n-\n+            let dir = graph::INCOMING;\n             process_edges(self, &mut state, graph, node_idx, dir);\n         }\n \n@@ -1638,7 +1366,6 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n     match values[rid.index as usize] {\n         Value(r) => r,\n-        NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error.\n     }\n }"}, {"sha": "4bbc22ef1a273d87bcaf3bfa55ab082ebd24b74b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=41bca6dd765491670ec2ccc7302a8d802182bb38", "patch": "@@ -351,6 +351,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                                    self.tcx().types.isize)\n     }\n \n+    pub fn t_rptr_empty(&self) -> Ty<'tcx> {\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReEmpty),\n+                                   self.tcx().types.isize)\n+    }\n+\n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n@@ -593,16 +598,15 @@ fn lub_free_free() {\n \n #[test]\n fn lub_returning_scope() {\n-    test_env(EMPTY_SOURCE_STR,\n-             errors(&[\"cannot infer an appropriate lifetime\"]), |env| {\n-                 env.create_simple_region_hierarchy();\n-                 let t_rptr_scope10 = env.t_rptr_scope(10);\n-                 let t_rptr_scope11 = env.t_rptr_scope(11);\n-\n-                 // this should generate an error when regions are resolved\n-                 env.make_lub_ty(env.t_fn(&[], t_rptr_scope10),\n-                                 env.t_fn(&[], t_rptr_scope11));\n-             })\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_scope10 = env.t_rptr_scope(10);\n+        let t_rptr_scope11 = env.t_rptr_scope(11);\n+        let t_rptr_empty = env.t_rptr_empty();\n+        env.check_lub(env.t_fn(&[t_rptr_scope10], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_scope11], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_empty], env.tcx().types.isize));\n+    });\n }\n \n #[test]"}, {"sha": "d89e5ee6006a440b8695a0072835a313559c2adf", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=41bca6dd765491670ec2ccc7302a8d802182bb38", "patch": "@@ -259,17 +259,30 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n         }\n         hir::PatRegion(ref inner, mutbl) => {\n-            let inner_ty = fcx.infcx().next_ty_var();\n-\n-            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-            let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-            let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n-\n+            let expected = fcx.infcx().shallow_resolve(expected);\n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 // `demand::subtype` would be good enough, but using\n                 // `eqtype` turns out to be equally general. See (*)\n                 // below for details.\n-                demand::eqtype(fcx, pat.span, expected, rptr_ty);\n+\n+                // Take region, inner-type from expected type if we\n+                // can, to avoid creating needless variables.  This\n+                // also helps with the bad interactions of the given\n+                // hack detailed in (*) below.\n+                let (rptr_ty, inner_ty) = match expected.sty {\n+                    ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n+                        (expected, mt.ty)\n+                    }\n+                    _ => {\n+                        let inner_ty = fcx.infcx().next_ty_var();\n+                        let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n+                        let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                        let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n+                        demand::eqtype(fcx, pat.span, expected, rptr_ty);\n+                        (rptr_ty, inner_ty)\n+                    }\n+                };\n+\n                 fcx.write_ty(pat.id, rptr_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {"}, {"sha": "7c6417e61d464de18791032f8d885a9f5b503855", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41bca6dd765491670ec2ccc7302a8d802182bb38/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=41bca6dd765491670ec2ccc7302a8d802182bb38", "patch": "@@ -1182,9 +1182,10 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[hir::Arg]) {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n-        debug!(\"arg_ty={:?} arg_cmt={:?}\",\n+        debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                arg_ty,\n-               arg_cmt);\n+               arg_cmt,\n+               arg);\n         link_pattern(rcx, mc, arg_cmt, &*arg.pat);\n     }\n }\n@@ -1527,9 +1528,10 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n {\n     let ty = rcx.resolve_type(ty);\n \n-    debug!(\"type_must_outlive(ty={:?}, region={:?})\",\n+    debug!(\"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n            ty,\n-           region);\n+           region,\n+           origin);\n \n     assert!(!ty.has_escaping_regions());\n "}]}