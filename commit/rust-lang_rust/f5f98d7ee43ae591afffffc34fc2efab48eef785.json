{"sha": "f5f98d7ee43ae591afffffc34fc2efab48eef785", "node_id": "C_kwDOAAsO6NoAKGY1Zjk4ZDdlZTQzYWU1OTFhZmZmZmZjMzRmYzJlZmFiNDhlZWY3ODU", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-12-13T18:47:28Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:27Z"}, "message": "Refactor drop_ranges\n\nSplits drop_ranges into drop_ranges::record_consumed_borrow,\ndrop_ranges::cfg_build, and drop_ranges::cfg_propagate. The top level\ndrop_ranges module has an entry point that does all the coordination of\nthe other three phases, using code original in generator_interior.", "tree": {"sha": "7a8421489c3df4eec301e3874dd80de360ca4459", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a8421489c3df4eec301e3874dd80de360ca4459"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5f98d7ee43ae591afffffc34fc2efab48eef785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f98d7ee43ae591afffffc34fc2efab48eef785", "html_url": "https://github.com/rust-lang/rust/commit/f5f98d7ee43ae591afffffc34fc2efab48eef785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5f98d7ee43ae591afffffc34fc2efab48eef785/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30e1b1e92e3a685567417f812e3a079a9d51422c", "url": "https://api.github.com/repos/rust-lang/rust/commits/30e1b1e92e3a685567417f812e3a079a9d51422c", "html_url": "https://github.com/rust-lang/rust/commit/30e1b1e92e3a685567417f812e3a079a9d51422c"}], "stats": {"total": 865, "additions": 455, "deletions": 410}, "files": [{"sha": "56b6dd9a284468311638cf1a30effccdbdfe8489", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=f5f98d7ee43ae591afffffc34fc2efab48eef785", "patch": "@@ -3,9 +3,8 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n-use self::drop_ranges::{DropRangeVisitor, DropRanges, ExprUseDelegate};\n+use self::drop_ranges::DropRanges;\n use super::FnCtxt;\n-use crate::expr_use_visitor::ExprUseVisitor;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n use rustc_hir as hir;\n@@ -187,42 +186,17 @@ pub fn resolve_interior<'a, 'tcx>(\n     kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n-\n-    let mut visitor = {\n-        let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n-\n-        // Run ExprUseVisitor to find where values are consumed.\n-        ExprUseVisitor::new(\n-            &mut expr_use_visitor,\n-            &fcx.infcx,\n-            def_id.expect_local(),\n-            fcx.param_env,\n-            &fcx.typeck_results.borrow(),\n-        )\n-        .consume_body(body);\n-\n-        let region_scope_tree = fcx.tcx.region_scope_tree(def_id);\n-        let mut drop_range_visitor = DropRangeVisitor::from_uses(\n-            expr_use_visitor,\n-            region_scope_tree.body_expr_count(body.id()).unwrap_or(0),\n-        );\n-        intravisit::walk_body(&mut drop_range_visitor, body);\n-\n-        let mut drop_ranges = drop_range_visitor.into_drop_ranges();\n-        drop_ranges.propagate_to_fixpoint();\n-\n-        InteriorVisitor {\n-            fcx,\n-            types: FxIndexSet::default(),\n-            region_scope_tree,\n-            expr_count: 0,\n-            kind,\n-            prev_unresolved_span: None,\n-            guard_bindings: <_>::default(),\n-            guard_bindings_set: <_>::default(),\n-            linted_values: <_>::default(),\n-            drop_ranges: drop_ranges,\n-        }\n+    let mut visitor = InteriorVisitor {\n+        fcx,\n+        types: FxIndexSet::default(),\n+        region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n+        expr_count: 0,\n+        kind,\n+        prev_unresolved_span: None,\n+        guard_bindings: <_>::default(),\n+        guard_bindings_set: <_>::default(),\n+        linted_values: <_>::default(),\n+        drop_ranges: drop_ranges::compute_drop_ranges(fcx, def_id, body),\n     };\n     intravisit::walk_body(&mut visitor, body);\n "}, {"sha": "d8bda36b14fe84f40412ce9cf2bab50be8874f2f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 27, "deletions": 372, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=f5f98d7ee43ae591afffffc34fc2efab48eef785", "patch": "@@ -12,180 +12,42 @@\n //! The end result is a data structure that maps the post-order index of each node in the HIR tree\n //! to a set of values that are known to be dropped at that location.\n \n-use std::collections::BTreeMap;\n-use std::fmt::Debug;\n-use std::mem::swap;\n-\n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use hir::{Expr, ExprKind, Guard, HirId, HirIdMap, HirIdSet, Node};\n-use rustc_graphviz as dot;\n+use self::cfg_build::DropRangeVisitor;\n+use self::record_consumed_borrow::ExprUseDelegate;\n+use crate::check::FnCtxt;\n+use hir::def_id::DefId;\n+use hir::{Body, HirId, HirIdMap, Node, intravisit};\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n-use rustc_middle::hir::place::{Place, PlaceBase};\n-use rustc_middle::ty;\n-\n-use crate::expr_use_visitor;\n-\n-/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n-///\n-/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n-/// record the parent expression, which is the point where the drop actually takes place.\n-pub struct ExprUseDelegate<'tcx> {\n-    hir: Map<'tcx>,\n-    /// Records the variables/expressions that are dropped by a given expression.\n-    ///\n-    /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n-    /// or values that are consumed by that expression.\n-    ///\n-    /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n-    /// not considered a drop of `x`, although it would be a drop of `x.y`.\n-    consumed_places: HirIdMap<HirIdSet>,\n-    /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n-    borrowed_places: HirIdSet,\n-}\n-\n-impl<'tcx> ExprUseDelegate<'tcx> {\n-    pub fn new(hir: Map<'tcx>) -> Self {\n-        Self { hir, consumed_places: <_>::default(), borrowed_places: <_>::default() }\n-    }\n-\n-    fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n-        if !self.consumed_places.contains_key(&consumer) {\n-            self.consumed_places.insert(consumer, <_>::default());\n-        }\n-        self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n-    }\n-}\n-\n-impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n-    fn consume(\n-        &mut self,\n-        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n-            Some(parent) => parent,\n-            None => place_with_id.hir_id,\n-        };\n-        debug!(\n-            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n-            place_with_id, diag_expr_id, parent\n-        );\n-        self.mark_consumed(parent, place_with_id.hir_id);\n-        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n-    }\n-\n-    fn borrow(\n-        &mut self,\n-        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: hir::HirId,\n-        _bk: rustc_middle::ty::BorrowKind,\n-    ) {\n-        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n-    }\n-\n-    fn mutate(\n-        &mut self,\n-        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: hir::HirId,\n-    ) {\n-    }\n-\n-    fn fake_read(\n-        &mut self,\n-        _place: expr_use_visitor::Place<'tcx>,\n-        _cause: rustc_middle::mir::FakeReadCause,\n-        _diag_expr_id: hir::HirId,\n-    ) {\n-    }\n-}\n-\n-/// Gives the hir_id associated with a place if one exists. This is the hir_id that we want to\n-/// track for a value in the drop range analysis.\n-fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n-    match place.base {\n-        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n-        PlaceBase::Local(hir_id)\n-        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n-    }\n-}\n-\n-/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n-/// HIR tree for which a value is dropped.\n-///\n-/// We are interested in points where a variables is dropped or initialized, and the control flow\n-/// of the code. We identify locations in code by their post-order traversal index, so it is\n-/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n-pub struct DropRangeVisitor<'tcx> {\n-    hir: Map<'tcx>,\n-    /// Maps a HirId to a set of HirIds that are dropped by that node.\n-    ///\n-    /// See also the more detailed comment on `ExprUseDelegate.consumed_places`.\n-    consumed_places: HirIdMap<HirIdSet>,\n-    borrowed_places: HirIdSet,\n-    drop_ranges: DropRanges,\n-    expr_count: usize,\n-}\n+use std::collections::BTreeMap;\n+use std::fmt::Debug;\n+use std::mem::swap;\n \n-impl<'tcx> DropRangeVisitor<'tcx> {\n-    pub fn from_uses(uses: ExprUseDelegate<'tcx>, num_exprs: usize) -> Self {\n-        debug!(\"consumed_places: {:?}\", uses.consumed_places);\n-        let drop_ranges = DropRanges::new(\n-            uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n-            &uses.hir,\n-            num_exprs,\n-        );\n-        Self {\n-            hir: uses.hir,\n-            consumed_places: uses.consumed_places,\n-            borrowed_places: uses.borrowed_places,\n-            drop_ranges,\n-            expr_count: 0,\n-        }\n-    }\n+mod cfg_build;\n+mod record_consumed_borrow;\n+mod cfg_propagate;\n+mod cfg_visualize;\n \n-    pub fn into_drop_ranges(self) -> DropRanges {\n-        self.drop_ranges\n-    }\n+pub fn compute_drop_ranges<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body: &'tcx Body<'tcx>,\n+) -> DropRanges {\n+    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n+    expr_use_visitor.consume_body(fcx, def_id, body);\n \n-    fn record_drop(&mut self, hir_id: HirId) {\n-        if self.borrowed_places.contains(&hir_id) {\n-            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n-        } else {\n-            debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n-            let count = self.expr_count;\n-            self.drop_ranges.drop_at(hir_id, count);\n-        }\n-    }\n+    let mut drop_range_visitor = DropRangeVisitor::from_uses(\n+        expr_use_visitor,\n+        fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0),\n+    );\n+    intravisit::walk_body(&mut drop_range_visitor, body);\n \n-    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n-    /// expressions. This method consumes a little deeper into the expression when needed.\n-    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n-        debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n-        let places = self\n-            .consumed_places\n-            .get(&expr.hir_id)\n-            .map_or(vec![], |places| places.iter().cloned().collect());\n-        for place in places {\n-            for_each_consumable(place, self.hir.find(place), |hir_id| self.record_drop(hir_id));\n-        }\n-    }\n+    let mut drop_ranges = drop_range_visitor.into_drop_ranges();\n+    drop_ranges.propagate_to_fixpoint();\n \n-    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n-        if let ExprKind::Path(hir::QPath::Resolved(\n-            _,\n-            hir::Path { res: hir::def::Res::Local(hir_id), .. },\n-        )) = expr.kind\n-        {\n-            let location = self.expr_count;\n-            debug!(\"reinitializing {:?} at {}\", hir_id, location);\n-            self.drop_ranges.reinit_at(*hir_id, location);\n-        } else {\n-            debug!(\"reinitializing {:?} is not supported\", expr);\n-        }\n-    }\n+    drop_ranges\n }\n \n /// Applies `f` to consumable portion of a HIR node.\n@@ -206,92 +68,6 @@ fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(H\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n-    type Map = intravisit::ErasedMap<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        let mut reinit = None;\n-        match expr.kind {\n-            ExprKind::If(test, if_true, if_false) => {\n-                self.visit_expr(test);\n-\n-                let fork = self.expr_count;\n-\n-                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n-                self.visit_expr(if_true);\n-                let true_end = self.expr_count;\n-\n-                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n-                if let Some(if_false) = if_false {\n-                    self.visit_expr(if_false);\n-                }\n-\n-                self.drop_ranges.add_control_edge(true_end, self.expr_count + 1);\n-            }\n-            ExprKind::Assign(lhs, rhs, _) => {\n-                self.visit_expr(lhs);\n-                self.visit_expr(rhs);\n-\n-                reinit = Some(lhs);\n-            }\n-            ExprKind::Loop(body, ..) => {\n-                let loop_begin = self.expr_count + 1;\n-                self.visit_block(body);\n-                self.drop_ranges.add_control_edge(self.expr_count, loop_begin);\n-            }\n-            ExprKind::Match(scrutinee, arms, ..) => {\n-                self.visit_expr(scrutinee);\n-\n-                let fork = self.expr_count;\n-                let arm_end_ids = arms\n-                    .iter()\n-                    .map(|hir::Arm { pat, body, guard, .. }| {\n-                        self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n-                        self.visit_pat(pat);\n-                        match guard {\n-                            Some(Guard::If(expr)) => self.visit_expr(expr),\n-                            Some(Guard::IfLet(pat, expr)) => {\n-                                self.visit_pat(pat);\n-                                self.visit_expr(expr);\n-                            }\n-                            None => (),\n-                        }\n-                        self.visit_expr(body);\n-                        self.expr_count\n-                    })\n-                    .collect::<Vec<_>>();\n-                arm_end_ids.into_iter().for_each(|arm_end| {\n-                    self.drop_ranges.add_control_edge(arm_end, self.expr_count + 1)\n-                });\n-            }\n-            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n-            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n-                self.drop_ranges.add_control_edge_hir_id(self.expr_count, target);\n-            }\n-\n-            _ => intravisit::walk_expr(self, expr),\n-        }\n-\n-        self.expr_count += 1;\n-        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_count);\n-        self.consume_expr(expr);\n-        if let Some(expr) = reinit {\n-            self.reinit_expr(expr);\n-        }\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n-        intravisit::walk_pat(self, pat);\n-\n-        // Increment expr_count here to match what InteriorVisitor expects.\n-        self.expr_count += 1;\n-    }\n-}\n-\n rustc_index::newtype_index! {\n     pub struct PostOrderId {\n         DEBUG_FORMAT = \"id({})\",\n@@ -426,127 +202,6 @@ impl DropRanges {\n         self.node_mut(location.into()).reinits.push(value);\n     }\n \n-    pub fn propagate_to_fixpoint(&mut self) {\n-        trace!(\"before fixpoint: {:#?}\", self);\n-        self.process_deferred_edges();\n-        let preds = self.compute_predecessors();\n-\n-        trace!(\"predecessors: {:#?}\", preds.iter_enumerated().collect::<BTreeMap<_, _>>());\n-\n-        let mut propagate = || {\n-            let mut changed = false;\n-            for id in self.nodes.indices() {\n-                let old_state = self.nodes[id].drop_state.clone();\n-                let mut new_state = if id.index() == 0 {\n-                    BitSet::new_empty(self.num_values())\n-                } else {\n-                    // If we are not the start node and we have no predecessors, treat\n-                    // everything as dropped because there's no way to get here anyway.\n-                    BitSet::new_filled(self.num_values())\n-                };\n-\n-                for pred in &preds[id] {\n-                    let state = &self.nodes[*pred].drop_state;\n-                    new_state.intersect(state);\n-                }\n-\n-                for drop in &self.nodes[id].drops {\n-                    new_state.insert(*drop);\n-                }\n-\n-                for reinit in &self.nodes[id].reinits {\n-                    new_state.remove(*reinit);\n-                }\n-\n-                changed |= old_state != new_state;\n-                self.nodes[id].drop_state = new_state;\n-            }\n-\n-            changed\n-        };\n-\n-        while propagate() {\n-            trace!(\"drop_state changed, re-running propagation\");\n-        }\n-\n-        trace!(\"after fixpoint: {:#?}\", self);\n-    }\n-\n-    fn compute_predecessors(&self) -> IndexVec<PostOrderId, Vec<PostOrderId>> {\n-        let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n-        for (id, node) in self.nodes.iter_enumerated() {\n-            if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n-                preds[id + 1].push(id);\n-            } else {\n-                for succ in &node.successors {\n-                    preds[*succ].push(id);\n-                }\n-            }\n-        }\n-        preds\n-    }\n-}\n-\n-impl<'a> dot::GraphWalk<'a> for DropRanges {\n-    type Node = PostOrderId;\n-\n-    type Edge = (PostOrderId, PostOrderId);\n-\n-    fn nodes(&'a self) -> dot::Nodes<'a, Self::Node> {\n-        self.nodes.iter_enumerated().map(|(i, _)| i).collect()\n-    }\n-\n-    fn edges(&'a self) -> dot::Edges<'a, Self::Edge> {\n-        self.nodes\n-            .iter_enumerated()\n-            .flat_map(|(i, node)| {\n-                if node.successors.len() == 0 {\n-                    vec![(i, i + 1)]\n-                } else {\n-                    node.successors.iter().map(move |&s| (i, s)).collect()\n-                }\n-            })\n-            .collect()\n-    }\n-\n-    fn source(&'a self, edge: &Self::Edge) -> Self::Node {\n-        edge.0\n-    }\n-\n-    fn target(&'a self, edge: &Self::Edge) -> Self::Node {\n-        edge.1\n-    }\n-}\n-\n-impl<'a> dot::Labeller<'a> for DropRanges {\n-    type Node = PostOrderId;\n-\n-    type Edge = (PostOrderId, PostOrderId);\n-\n-    fn graph_id(&'a self) -> dot::Id<'a> {\n-        dot::Id::new(\"drop_ranges\").unwrap()\n-    }\n-\n-    fn node_id(&'a self, n: &Self::Node) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"id{}\", n.index())).unwrap()\n-    }\n-\n-    fn node_label(&'a self, n: &Self::Node) -> dot::LabelText<'a> {\n-        dot::LabelText::LabelStr(\n-            format!(\n-                \"{:?}, local_id: {}\",\n-                n,\n-                self.post_order_map\n-                    .iter()\n-                    .find(|(_hir_id, &post_order_id)| post_order_id == n.index())\n-                    .map_or(\"<unknown>\".into(), |(hir_id, _)| format!(\n-                        \"{}\",\n-                        hir_id.local_id.index()\n-                    ))\n-            )\n-            .into(),\n-        )\n-    }\n }\n \n #[derive(Debug)]"}, {"sha": "594054fde9ae740db3d5447d39e2d56d8210bba2", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=f5f98d7ee43ae591afffffc34fc2efab48eef785", "patch": "@@ -0,0 +1,169 @@\n+use super::{for_each_consumable, record_consumed_borrow::ExprUseDelegate, DropRanges};\n+use hir::{\n+    intravisit::{self, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, Guard, HirId, HirIdMap, HirIdSet,\n+};\n+use rustc_hir as hir;\n+use rustc_middle::hir::map::Map;\n+\n+/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n+/// HIR tree for which a value is dropped.\n+///\n+/// We are interested in points where a variables is dropped or initialized, and the control flow\n+/// of the code. We identify locations in code by their post-order traversal index, so it is\n+/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n+pub struct DropRangeVisitor<'tcx> {\n+    hir: Map<'tcx>,\n+    /// Maps a HirId to a set of HirIds that are dropped by that node.\n+    ///\n+    /// See also the more detailed comment on `ExprUseDelegate.consumed_places`.\n+    consumed_places: HirIdMap<HirIdSet>,\n+    borrowed_places: HirIdSet,\n+    drop_ranges: DropRanges,\n+    expr_count: usize,\n+}\n+\n+impl<'tcx> DropRangeVisitor<'tcx> {\n+    pub fn from_uses(uses: ExprUseDelegate<'tcx>, num_exprs: usize) -> Self {\n+        debug!(\"consumed_places: {:?}\", uses.consumed_places);\n+        let drop_ranges = DropRanges::new(\n+            uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n+            &uses.hir,\n+            num_exprs,\n+        );\n+        Self {\n+            hir: uses.hir,\n+            consumed_places: uses.consumed_places,\n+            borrowed_places: uses.borrowed_places,\n+            drop_ranges,\n+            expr_count: 0,\n+        }\n+    }\n+\n+    pub fn into_drop_ranges(self) -> DropRanges {\n+        self.drop_ranges\n+    }\n+\n+    fn record_drop(&mut self, hir_id: HirId) {\n+        if self.borrowed_places.contains(&hir_id) {\n+            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n+        } else {\n+            debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n+            let count = self.expr_count;\n+            self.drop_ranges.drop_at(hir_id, count);\n+        }\n+    }\n+\n+    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n+    /// expressions. This method consumes a little deeper into the expression when needed.\n+    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n+        debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n+        let places = self\n+            .consumed_places\n+            .get(&expr.hir_id)\n+            .map_or(vec![], |places| places.iter().cloned().collect());\n+        for place in places {\n+            for_each_consumable(place, self.hir.find(place), |hir_id| self.record_drop(hir_id));\n+        }\n+    }\n+\n+    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n+        if let ExprKind::Path(hir::QPath::Resolved(\n+            _,\n+            hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+        )) = expr.kind\n+        {\n+            let location = self.expr_count;\n+            debug!(\"reinitializing {:?} at {}\", hir_id, location);\n+            self.drop_ranges.reinit_at(*hir_id, location);\n+        } else {\n+            debug!(\"reinitializing {:?} is not supported\", expr);\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut reinit = None;\n+        match expr.kind {\n+            ExprKind::If(test, if_true, if_false) => {\n+                self.visit_expr(test);\n+\n+                let fork = self.expr_count;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                self.visit_expr(if_true);\n+                let true_end = self.expr_count;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                if let Some(if_false) = if_false {\n+                    self.visit_expr(if_false);\n+                }\n+\n+                self.drop_ranges.add_control_edge(true_end, self.expr_count + 1);\n+            }\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                self.visit_expr(lhs);\n+                self.visit_expr(rhs);\n+\n+                reinit = Some(lhs);\n+            }\n+            ExprKind::Loop(body, ..) => {\n+                let loop_begin = self.expr_count + 1;\n+                self.visit_block(body);\n+                self.drop_ranges.add_control_edge(self.expr_count, loop_begin);\n+            }\n+            ExprKind::Match(scrutinee, arms, ..) => {\n+                self.visit_expr(scrutinee);\n+\n+                let fork = self.expr_count;\n+                let arm_end_ids = arms\n+                    .iter()\n+                    .map(|hir::Arm { pat, body, guard, .. }| {\n+                        self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                        self.visit_pat(pat);\n+                        match guard {\n+                            Some(Guard::If(expr)) => self.visit_expr(expr),\n+                            Some(Guard::IfLet(pat, expr)) => {\n+                                self.visit_pat(pat);\n+                                self.visit_expr(expr);\n+                            }\n+                            None => (),\n+                        }\n+                        self.visit_expr(body);\n+                        self.expr_count\n+                    })\n+                    .collect::<Vec<_>>();\n+                arm_end_ids.into_iter().for_each(|arm_end| {\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_count + 1)\n+                });\n+            }\n+            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n+            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n+                self.drop_ranges.add_control_edge_hir_id(self.expr_count, target);\n+            }\n+\n+            _ => intravisit::walk_expr(self, expr),\n+        }\n+\n+        self.expr_count += 1;\n+        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_count);\n+        self.consume_expr(expr);\n+        if let Some(expr) = reinit {\n+            self.reinit_expr(expr);\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        intravisit::walk_pat(self, pat);\n+\n+        // Increment expr_count here to match what InteriorVisitor expects.\n+        self.expr_count += 1;\n+    }\n+}"}, {"sha": "ea7b9106b9a80c7e020c4c29cc9e14b682e32fef", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_propagate.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=f5f98d7ee43ae591afffffc34fc2efab48eef785", "patch": "@@ -0,0 +1,67 @@\n+use std::collections::BTreeMap;\n+\n+use rustc_index::{bit_set::BitSet, vec::IndexVec};\n+\n+use super::{DropRanges, PostOrderId};\n+\n+impl DropRanges {\n+    pub fn propagate_to_fixpoint(&mut self) {\n+        trace!(\"before fixpoint: {:#?}\", self);\n+        self.process_deferred_edges();\n+        let preds = self.compute_predecessors();\n+\n+        trace!(\"predecessors: {:#?}\", preds.iter_enumerated().collect::<BTreeMap<_, _>>());\n+\n+        let mut propagate = || {\n+            let mut changed = false;\n+            for id in self.nodes.indices() {\n+                let old_state = self.nodes[id].drop_state.clone();\n+                let mut new_state = if id.index() == 0 {\n+                    BitSet::new_empty(self.num_values())\n+                } else {\n+                    // If we are not the start node and we have no predecessors, treat\n+                    // everything as dropped because there's no way to get here anyway.\n+                    BitSet::new_filled(self.num_values())\n+                };\n+\n+                for pred in &preds[id] {\n+                    let state = &self.nodes[*pred].drop_state;\n+                    new_state.intersect(state);\n+                }\n+\n+                for drop in &self.nodes[id].drops {\n+                    new_state.insert(*drop);\n+                }\n+\n+                for reinit in &self.nodes[id].reinits {\n+                    new_state.remove(*reinit);\n+                }\n+\n+                changed |= old_state != new_state;\n+                self.nodes[id].drop_state = new_state;\n+            }\n+\n+            changed\n+        };\n+\n+        while propagate() {\n+            trace!(\"drop_state changed, re-running propagation\");\n+        }\n+\n+        trace!(\"after fixpoint: {:#?}\", self);\n+    }\n+\n+    fn compute_predecessors(&self) -> IndexVec<PostOrderId, Vec<PostOrderId>> {\n+        let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n+        for (id, node) in self.nodes.iter_enumerated() {\n+            if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n+                preds[id + 1].push(id);\n+            } else {\n+                for succ in &node.successors {\n+                    preds[*succ].push(id);\n+                }\n+            }\n+        }\n+        preds\n+    }\n+}"}, {"sha": "ebbbec1c472b65c09288f52cdbc6a77dc36b3c81", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_visualize.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=f5f98d7ee43ae591afffffc34fc2efab48eef785", "patch": "@@ -0,0 +1,68 @@\n+//! Implementation of GraphWalk for DropRanges so we can visualize the control\n+//! flow graph when needed for debugging.\n+\n+use rustc_graphviz as dot;\n+\n+use super::{DropRanges, PostOrderId};\n+\n+impl<'a> dot::GraphWalk<'a> for DropRanges {\n+    type Node = PostOrderId;\n+\n+    type Edge = (PostOrderId, PostOrderId);\n+\n+    fn nodes(&'a self) -> dot::Nodes<'a, Self::Node> {\n+        self.nodes.iter_enumerated().map(|(i, _)| i).collect()\n+    }\n+\n+    fn edges(&'a self) -> dot::Edges<'a, Self::Edge> {\n+        self.nodes\n+            .iter_enumerated()\n+            .flat_map(|(i, node)| {\n+                if node.successors.len() == 0 {\n+                    vec![(i, i + 1)]\n+                } else {\n+                    node.successors.iter().map(move |&s| (i, s)).collect()\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    fn source(&'a self, edge: &Self::Edge) -> Self::Node {\n+        edge.0\n+    }\n+\n+    fn target(&'a self, edge: &Self::Edge) -> Self::Node {\n+        edge.1\n+    }\n+}\n+\n+impl<'a> dot::Labeller<'a> for DropRanges {\n+    type Node = PostOrderId;\n+\n+    type Edge = (PostOrderId, PostOrderId);\n+\n+    fn graph_id(&'a self) -> dot::Id<'a> {\n+        dot::Id::new(\"drop_ranges\").unwrap()\n+    }\n+\n+    fn node_id(&'a self, n: &Self::Node) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"id{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_label(&'a self, n: &Self::Node) -> dot::LabelText<'a> {\n+        dot::LabelText::LabelStr(\n+            format!(\n+                \"{:?}, local_id: {}\",\n+                n,\n+                self.post_order_map\n+                    .iter()\n+                    .find(|(_hir_id, &post_order_id)| post_order_id == n.index())\n+                    .map_or(\"<unknown>\".into(), |(hir_id, _)| format!(\n+                        \"{}\",\n+                        hir_id.local_id.index()\n+                    ))\n+            )\n+            .into(),\n+        )\n+    }\n+}"}, {"sha": "93bb58cd8a099481f11b2c4bd2759e6e46d731cf", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f98d7ee43ae591afffffc34fc2efab48eef785/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=f5f98d7ee43ae591afffffc34fc2efab48eef785", "patch": "@@ -0,0 +1,112 @@\n+use crate::{\n+    check::FnCtxt,\n+    expr_use_visitor::{self, ExprUseVisitor},\n+};\n+use hir::{HirId, HirIdMap, HirIdSet, Body, def_id::DefId};\n+use rustc_hir as hir;\n+use rustc_middle::hir::{\n+    map::Map,\n+    place::{Place, PlaceBase},\n+};\n+use rustc_middle::ty;\n+\n+/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n+///\n+/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n+/// record the parent expression, which is the point where the drop actually takes place.\n+pub struct ExprUseDelegate<'tcx> {\n+    pub(super) hir: Map<'tcx>,\n+    /// Records the variables/expressions that are dropped by a given expression.\n+    ///\n+    /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n+    /// or values that are consumed by that expression.\n+    ///\n+    /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n+    /// not considered a drop of `x`, although it would be a drop of `x.y`.\n+    pub(super) consumed_places: HirIdMap<HirIdSet>,\n+    /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n+    pub(super) borrowed_places: HirIdSet,\n+}\n+\n+impl<'tcx> ExprUseDelegate<'tcx> {\n+    pub fn new(hir: Map<'tcx>) -> Self {\n+        Self { hir, consumed_places: <_>::default(), borrowed_places: <_>::default() }\n+    }\n+\n+    pub fn consume_body(\n+        &mut self,\n+        fcx: &'_ FnCtxt<'_, 'tcx>,\n+        def_id: DefId,\n+        body: &'tcx Body<'tcx>,\n+    ) {\n+        // Run ExprUseVisitor to find where values are consumed.\n+        ExprUseVisitor::new(\n+            self,\n+            &fcx.infcx,\n+            def_id.expect_local(),\n+            fcx.param_env,\n+            &fcx.typeck_results.borrow(),\n+        )\n+        .consume_body(body);\n+    }\n+\n+    fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n+        if !self.consumed_places.contains_key(&consumer) {\n+            self.consumed_places.insert(consumer, <_>::default());\n+        }\n+        self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n+    }\n+}\n+\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n+    fn consume(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: HirId,\n+    ) {\n+        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+            Some(parent) => parent,\n+            None => place_with_id.hir_id,\n+        };\n+        debug!(\n+            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n+            place_with_id, diag_expr_id, parent\n+        );\n+        self.mark_consumed(parent, place_with_id.hir_id);\n+        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n+    }\n+\n+    fn borrow(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n+        _bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n+    }\n+\n+    fn mutate(\n+        &mut self,\n+        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: HirId,\n+    ) {\n+    }\n+\n+    fn fake_read(\n+        &mut self,\n+        _place: expr_use_visitor::Place<'tcx>,\n+        _cause: rustc_middle::mir::FakeReadCause,\n+        _diag_expr_id: HirId,\n+    ) {\n+    }\n+}\n+\n+/// Gives the hir_id associated with a place if one exists. This is the hir_id that we want to\n+/// track for a value in the drop range analysis.\n+fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n+    match place.base {\n+        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n+        PlaceBase::Local(hir_id)\n+        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n+    }\n+}"}]}