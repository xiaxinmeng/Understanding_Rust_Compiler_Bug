{"sha": "02d74a4852f9138dbabdfeab8ac31298226620fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZDc0YTQ4NTJmOTEzOGRiYWJkZmVhYjhhYzMxMjk4MjI2NjIwZmQ=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-06-18T19:16:47Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-06-20T01:35:24Z"}, "message": "Make trans_arg_datum fill a destination vector instead of returning its result\n\nThis makes it easier to support translating a single rust argument to\nmore than one llvm argument value later.", "tree": {"sha": "8ffa703d6ff8dd85fa0f924e1c393f55799fbef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ffa703d6ff8dd85fa0f924e1c393f55799fbef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02d74a4852f9138dbabdfeab8ac31298226620fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02d74a4852f9138dbabdfeab8ac31298226620fd", "html_url": "https://github.com/rust-lang/rust/commit/02d74a4852f9138dbabdfeab8ac31298226620fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02d74a4852f9138dbabdfeab8ac31298226620fd/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dea5a9608c5dd111b68cd03428f1d1f98fbec14b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dea5a9608c5dd111b68cd03428f1d1f98fbec14b", "html_url": "https://github.com/rust-lang/rust/commit/dea5a9608c5dd111b68cd03428f1d1f98fbec14b"}], "stats": {"total": 118, "additions": 57, "deletions": 61}, "files": [{"sha": "b25d6f2daaca93fe865bbd879895dfd488c078d5", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02d74a4852f9138dbabdfeab8ac31298226620fd/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d74a4852f9138dbabdfeab8ac31298226620fd/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=02d74a4852f9138dbabdfeab8ac31298226620fd", "patch": "@@ -45,32 +45,31 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n         let val = out_datum.val;\n         if is_rw {\n-            ext_inputs.push(unpack_result!(bcx, {\n-                callee::trans_arg_datum(bcx,\n-                                       expr_ty(bcx, &**out),\n-                                       out_datum,\n-                                       cleanup::CustomScope(temp_scope),\n-                                       callee::DontAutorefArg)\n-            }));\n+            bcx = callee::trans_arg_datum(bcx,\n+                                          expr_ty(bcx, &**out),\n+                                          out_datum,\n+                                          cleanup::CustomScope(temp_scope),\n+                                          callee::DontAutorefArg,\n+                                          &mut ext_inputs);\n             ext_constraints.push(i.to_string());\n         }\n         val\n \n     }).collect::<Vec<_>>();\n \n     // Now the input operands\n-    let mut inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n+    let mut inputs = Vec::new();\n+    for &(ref c, ref input) in &ia.inputs {\n         constraints.push((*c).clone());\n \n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n-        unpack_result!(bcx, {\n-            callee::trans_arg_datum(bcx,\n+        bcx = callee::trans_arg_datum(bcx,\n                                     expr_ty(bcx, &**input),\n                                     in_datum,\n                                     cleanup::CustomScope(temp_scope),\n-                                    callee::DontAutorefArg)\n-        })\n-    }).collect::<Vec<_>>();\n+                                    callee::DontAutorefArg,\n+                                    &mut inputs);\n+    }\n     inputs.push_all(&ext_inputs[..]);\n \n     // no failure occurred preparing operands, no need to cleanup"}, {"sha": "a77c5d8f606750a648c2a2df9d9613af50ee4353", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/02d74a4852f9138dbabdfeab8ac31298226620fd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d74a4852f9138dbabdfeab8ac31298226620fd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=02d74a4852f9138dbabdfeab8ac31298226620fd", "patch": "@@ -921,13 +921,12 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     // Translate the `self` argument first.\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n-        llargs.push(unpack_result!(bcx, {\n-            trans_arg_datum(bcx,\n-                            args[0],\n-                            arg_datum,\n-                            arg_cleanup_scope,\n-                            DontAutorefArg)\n-        }))\n+        bcx = trans_arg_datum(bcx,\n+                              args[0],\n+                              arg_datum,\n+                              arg_cleanup_scope,\n+                              DontAutorefArg,\n+                              llargs);\n     }\n \n     // Now untuple the rest of the arguments.\n@@ -945,21 +944,20 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                                                           tuple_expr.id));\n             let repr = adt::represent_type(bcx.ccx(), tuple_type);\n             let repr_ptr = &*repr;\n-            llargs.extend(field_types.iter().enumerate().map(|(i, field_type)| {\n+            for (i, field_type) in field_types.iter().enumerate() {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n                     field_type,\n                     |srcval| {\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n                     }).to_expr_datum();\n-                unpack_result!(bcx, trans_arg_datum(\n-                    bcx,\n-                    field_type,\n-                    arg_datum,\n-                    arg_cleanup_scope,\n-                    DontAutorefArg)\n-                )\n-            }));\n+                bcx = trans_arg_datum(bcx,\n+                                      field_type,\n+                                      arg_datum,\n+                                      arg_cleanup_scope,\n+                                      DontAutorefArg,\n+                                      llargs);\n+            }\n         }\n         _ => {\n             bcx.sess().span_bug(tuple_expr.span,\n@@ -982,13 +980,12 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n     let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &ty::ty_fn_args(fn_ty));\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n-        llargs.push(unpack_result!(bcx, {\n-            trans_arg_datum(bcx,\n-                            arg_tys[0],\n-                            arg_datum,\n-                            arg_cleanup_scope,\n-                            DontAutorefArg)\n-        }))\n+        bcx = trans_arg_datum(bcx,\n+                              arg_tys[0],\n+                              arg_datum,\n+                              arg_cleanup_scope,\n+                              DontAutorefArg,\n+                              llargs);\n     }\n \n     // Now untuple the rest of the arguments.\n@@ -998,13 +995,12 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n             for (i, &field_type) in field_types.iter().enumerate() {\n                 let arg_datum =\n                     unpack_datum!(bcx, expr::trans(bcx, arg_exprs[i + 1]));\n-                llargs.push(unpack_result!(bcx, {\n-                    trans_arg_datum(bcx,\n-                                    field_type,\n-                                    arg_datum,\n-                                    arg_cleanup_scope,\n-                                    DontAutorefArg)\n-                }))\n+                bcx = trans_arg_datum(bcx,\n+                                      field_type,\n+                                      arg_datum,\n+                                      arg_cleanup_scope,\n+                                      DontAutorefArg,\n+                                      llargs);\n             }\n         }\n         _ => {\n@@ -1061,11 +1057,10 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 };\n \n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n-                llargs.push(unpack_result!(bcx, {\n-                    trans_arg_datum(bcx, arg_ty, arg_datum,\n-                                    arg_cleanup_scope,\n-                                    DontAutorefArg)\n-                }));\n+                bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n+                                      arg_cleanup_scope,\n+                                      DontAutorefArg,\n+                                      llargs);\n             }\n         }\n         ArgOverloadedCall(arg_exprs) => {\n@@ -1079,19 +1074,17 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         ArgOverloadedOp(lhs, rhs, autoref) => {\n             assert!(!variadic);\n \n-            llargs.push(unpack_result!(bcx, {\n-                trans_arg_datum(bcx, arg_tys[0], lhs,\n-                                arg_cleanup_scope,\n-                                DontAutorefArg)\n-            }));\n+            bcx = trans_arg_datum(bcx, arg_tys[0], lhs,\n+                                  arg_cleanup_scope,\n+                                  DontAutorefArg,\n+                                  llargs);\n \n             assert_eq!(arg_tys.len(), 1 + rhs.len());\n             for (rhs, rhs_id) in rhs {\n-                llargs.push(unpack_result!(bcx, {\n-                    trans_arg_datum(bcx, arg_tys[1], rhs,\n-                                    arg_cleanup_scope,\n-                                    if autoref { DoAutorefArg(rhs_id) } else { DontAutorefArg })\n-                }));\n+                bcx = trans_arg_datum(bcx, arg_tys[1], rhs,\n+                                      arg_cleanup_scope,\n+                                      if autoref { DoAutorefArg(rhs_id) } else { DontAutorefArg },\n+                                      llargs);\n             }\n         }\n         ArgVals(vs) => {\n@@ -1112,8 +1105,9 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    formal_arg_ty: Ty<'tcx>,\n                                    arg_datum: Datum<'tcx, Expr>,\n                                    arg_cleanup_scope: cleanup::ScopeId,\n-                                   autoref_arg: AutorefArg)\n-                                   -> Result<'blk, 'tcx> {\n+                                   autoref_arg: AutorefArg,\n+                                   llargs: &mut Vec<ValueRef>)\n+                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n@@ -1164,5 +1158,8 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_string(val));\n-    Result::new(bcx, val)\n+\n+    llargs.push(val);\n+\n+    bcx\n }"}]}