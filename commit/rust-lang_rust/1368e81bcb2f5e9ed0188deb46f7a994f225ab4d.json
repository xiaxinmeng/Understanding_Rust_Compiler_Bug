{"sha": "1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNjhlODFiY2IyZjVlOWVkMDE4OGRlYjQ2ZjdhOTk0ZjIyNWFiNGQ=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-01-16T17:30:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-16T17:30:08Z"}, "message": "Rollup merge of #81021 - CraftSpider:rustdoc-remove-import, r=jyn514\n\nRemove doctree::Import\n\nPer the title. Part of cleaning up doctree", "tree": {"sha": "50e11f015ca1a6f4e1a05bf41a4aa8b7bda9d328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50e11f015ca1a6f4e1a05bf41a4aa8b7bda9d328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgAyKgCRBK7hj4Ov3rIwAAdHIIAHgFP07taDZ3Aiq/QMo5p3Qg\nRTV5HlFZjwNIURDKk+vl05bMuelFHjAH1uxKZa77hOu30svqbHoDAhCLdQ6R6MkD\naMrql3WHxi8AwaCz/MoflAqGhPX0JPpxjXJlUh8PS5TC9fT3KhBKas8GjZLQQ+Ir\nehQDQvRKZebylCBOETC19uI//1uAxLAQ2z9ZdzVN0Y7Au0+NMeyDVw3rA7FfyGhy\nzNA3XeeP7zBkFhYkaKTqAiKASeXzfXX/nZOFn84HFHNSy4WH4WF3Cjr+BDZggJN9\nsA3rkb7kqxOD3PDtw3MM45giVoRBf1bAwKhQvnx4iwa30ua3YRPaHG4VAvE8HdE=\n=YsOM\n-----END PGP SIGNATURE-----\n", "payload": "tree 50e11f015ca1a6f4e1a05bf41a4aa8b7bda9d328\nparent 4a48651b0e9503d1146ba39ebc7da76ce18d7376\nparent 31b17f513b79e7213f16c8acdcc38a5b9018d8a4\nauthor Mara Bos <m-ou.se@m-ou.se> 1610818208 +0000\ncommitter GitHub <noreply@github.com> 1610818208 +0000\n\nRollup merge of #81021 - CraftSpider:rustdoc-remove-import, r=jyn514\n\nRemove doctree::Import\n\nPer the title. Part of cleaning up doctree\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "html_url": "https://github.com/rust-lang/rust/commit/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a48651b0e9503d1146ba39ebc7da76ce18d7376", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a48651b0e9503d1146ba39ebc7da76ce18d7376", "html_url": "https://github.com/rust-lang/rust/commit/4a48651b0e9503d1146ba39ebc7da76ce18d7376"}, {"sha": "31b17f513b79e7213f16c8acdcc38a5b9018d8a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b17f513b79e7213f16c8acdcc38a5b9018d8a4", "html_url": "https://github.com/rust-lang/rust/commit/31b17f513b79e7213f16c8acdcc38a5b9018d8a4"}], "stats": {"total": 207, "additions": 91, "deletions": 116}, "files": [{"sha": "cafb65bc7f9cb03e8b512684f130398e7d3da74b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 85, "deletions": 91, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "patch": "@@ -219,7 +219,6 @@ impl Clean<ExternalCrate> for CrateNum {\n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n-        items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n@@ -2015,7 +2014,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n-                hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                     let items = item_ids\n                         .iter()\n                         .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n@@ -2034,6 +2033,9 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::ExternCrate(orig_name) => {\n                     return clean_extern_crate(item, name, orig_name, cx);\n                 }\n+                ItemKind::Use(path, kind) => {\n+                    return clean_use_statement(item, name, path, kind, cx);\n+                }\n                 _ => unreachable!(\"not yet converted\"),\n             };\n \n@@ -2155,105 +2157,97 @@ fn clean_extern_crate(\n     }]\n }\n \n-impl Clean<Vec<Item>> for doctree::Import<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        // We need this comparison because some imports (for std types for example)\n-        // are \"inserted\" as well but directly by the compiler and they should not be\n-        // taken into account.\n-        if self.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n-            return Vec::new();\n-        }\n-\n-        let (doc_meta_item, please_inline) = self.attrs.lists(sym::doc).get_word_attr(sym::inline);\n-        let pub_underscore = self.vis.node.is_pub() && self.name == kw::Underscore;\n-\n-        if pub_underscore && please_inline {\n-            rustc_errors::struct_span_err!(\n-                cx.tcx.sess,\n-                doc_meta_item.unwrap().span(),\n-                E0780,\n-                \"anonymous imports cannot be inlined\"\n-            )\n-            .span_label(self.span, \"anonymous import\")\n-            .emit();\n-        }\n+fn clean_use_statement(\n+    import: &hir::Item<'_>,\n+    name: Symbol,\n+    path: &hir::Path<'_>,\n+    kind: hir::UseKind,\n+    cx: &DocContext<'_>,\n+) -> Vec<Item> {\n+    // We need this comparison because some imports (for std types for example)\n+    // are \"inserted\" as well but directly by the compiler and they should not be\n+    // taken into account.\n+    if import.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n+        return Vec::new();\n+    }\n+\n+    let (doc_meta_item, please_inline) = import.attrs.lists(sym::doc).get_word_attr(sym::inline);\n+    let pub_underscore = import.vis.node.is_pub() && name == kw::Underscore;\n+\n+    if pub_underscore && please_inline {\n+        rustc_errors::struct_span_err!(\n+            cx.tcx.sess,\n+            doc_meta_item.unwrap().span(),\n+            E0780,\n+            \"anonymous imports cannot be inlined\"\n+        )\n+        .span_label(import.span, \"anonymous import\")\n+        .emit();\n+    }\n \n-        // We consider inlining the documentation of `pub use` statements, but we\n-        // forcefully don't inline if this is not public or if the\n-        // #[doc(no_inline)] attribute is present.\n-        // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let mut denied = !self.vis.node.is_pub()\n-            || pub_underscore\n-            || self.attrs.iter().any(|a| {\n-                a.has_name(sym::doc)\n-                    && match a.meta_item_list() {\n-                        Some(l) => {\n-                            attr::list_contains_name(&l, sym::no_inline)\n-                                || attr::list_contains_name(&l, sym::hidden)\n-                        }\n-                        None => false,\n+    // We consider inlining the documentation of `pub use` statements, but we\n+    // forcefully don't inline if this is not public or if the\n+    // #[doc(no_inline)] attribute is present.\n+    // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n+    let mut denied = !import.vis.node.is_pub()\n+        || pub_underscore\n+        || import.attrs.iter().any(|a| {\n+            a.has_name(sym::doc)\n+                && match a.meta_item_list() {\n+                    Some(l) => {\n+                        attr::list_contains_name(&l, sym::no_inline)\n+                            || attr::list_contains_name(&l, sym::hidden)\n                     }\n-            });\n-        // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n-        // crate in Rust 2018+\n-        let path = self.path.clean(cx);\n-        let inner = if self.glob {\n-            if !denied {\n-                let mut visited = FxHashSet::default();\n-                if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n-                    return items;\n+                    None => false,\n                 }\n+        });\n+\n+    // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n+    // crate in Rust 2018+\n+    let def_id = cx.tcx.hir().local_def_id(import.hir_id).to_def_id();\n+    let path = path.clean(cx);\n+    let inner = if kind == hir::UseKind::Glob {\n+        if !denied {\n+            let mut visited = FxHashSet::default();\n+            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n+                return items;\n             }\n-            Import::new_glob(resolve_use_source(cx, path), true)\n-        } else {\n-            let name = self.name;\n-            if !please_inline {\n-                if let Res::Def(DefKind::Mod, did) = path.res {\n-                    if !did.is_local() && did.index == CRATE_DEF_INDEX {\n-                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                        // were specifically asked for it\n-                        denied = true;\n-                    }\n+        }\n+        Import::new_glob(resolve_use_source(cx, path), true)\n+    } else {\n+        if !please_inline {\n+            if let Res::Def(DefKind::Mod, did) = path.res {\n+                if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                    // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                    // were specifically asked for it\n+                    denied = true;\n                 }\n             }\n-            if !denied {\n-                let mut visited = FxHashSet::default();\n+        }\n+        if !denied {\n+            let mut visited = FxHashSet::default();\n \n-                if let Some(mut items) = inline::try_inline(\n+            if let Some(mut items) = inline::try_inline(\n+                cx,\n+                cx.tcx.parent_module(import.hir_id).to_def_id(),\n+                path.res,\n+                name,\n+                Some(import.attrs),\n+                &mut visited,\n+            ) {\n+                items.push(Item::from_def_id_and_parts(\n+                    def_id,\n+                    None,\n+                    ImportItem(Import::new_simple(name, resolve_use_source(cx, path), false)),\n                     cx,\n-                    cx.tcx.parent_module(self.id).to_def_id(),\n-                    path.res,\n-                    name,\n-                    Some(self.attrs),\n-                    &mut visited,\n-                ) {\n-                    items.push(Item {\n-                        name: None,\n-                        attrs: box self.attrs.clean(cx),\n-                        source: self.span.clean(cx),\n-                        def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-                        visibility: self.vis.clean(cx),\n-                        kind: box ImportItem(Import::new_simple(\n-                            self.name,\n-                            resolve_use_source(cx, path),\n-                            false,\n-                        )),\n-                    });\n-                    return items;\n-                }\n+                ));\n+                return items;\n             }\n-            Import::new_simple(name, resolve_use_source(cx, path), true)\n-        };\n+        }\n+        Import::new_simple(name, resolve_use_source(cx, path), true)\n+    };\n \n-        vec![Item {\n-            name: None,\n-            attrs: box self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            kind: box ImportItem(inner),\n-        }]\n-    }\n+    vec![Item::from_def_id_and_parts(def_id, None, ImportItem(inner), cx)]\n }\n \n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {"}, {"sha": "f90623c03118b6ef8b462589a1888e1b38782327", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "patch": "@@ -2,7 +2,6 @@\n //! manner (and with prettier names) before cleaning.\n crate use self::StructType::*;\n \n-use rustc_ast as ast;\n use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n@@ -11,7 +10,6 @@ crate struct Module<'hir> {\n     crate name: Option<Symbol>,\n     crate where_outer: Span,\n     crate where_inner: Span,\n-    crate imports: Vec<Import<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n     // (item, renamed)\n@@ -28,7 +26,6 @@ impl Module<'hir> {\n             id: hir::CRATE_HIR_ID,\n             where_outer: rustc_span::DUMMY_SP,\n             where_inner: rustc_span::DUMMY_SP,\n-            imports: Vec::new(),\n             mods: Vec::new(),\n             items: Vec::new(),\n             foreigns: Vec::new(),\n@@ -48,17 +45,6 @@ crate enum StructType {\n     Unit,\n }\n \n-#[derive(Debug)]\n-crate struct Import<'hir> {\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate path: &'hir hir::Path<'hir>,\n-    crate glob: bool,\n-    crate span: Span,\n-}\n-\n crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "7d161ca3648ccabfd5630d597e0803f145212f7c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "patch": "@@ -316,15 +316,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                om.imports.push(Import {\n-                    name,\n-                    id: item.hir_id,\n-                    vis: &item.vis,\n-                    attrs: &item.attrs,\n-                    path,\n-                    glob: is_glob,\n-                    span: item.span,\n-                });\n+                om.items.push((item, renamed))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents("}, {"sha": "6a921266336e0add8cd8604af5058d8e8530c3ba", "filename": "src/test/rustdoc-json/compare.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Ftest%2Frustdoc-json%2Fcompare.py", "raw_url": "https://github.com/rust-lang/rust/raw/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Ftest%2Frustdoc-json%2Fcompare.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fcompare.py?ref=1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "patch": "@@ -7,6 +7,9 @@\n # and then create `yourtest.expected` by stripping unnecessary details from `yourtest.json`. If\n # you're on windows, replace `\\` with `/`.\n \n+# WARNING: The error messages produced by this may be misleading, in the case of list re-ordering\n+#          it may point to apparently unrelated keys.\n+\n import copy\n import sys\n import json"}, {"sha": "80070e75f1e5eae657ae68a5a33495d93bc67abe", "filename": "src/test/rustdoc-json/nested.expected", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Ftest%2Frustdoc-json%2Fnested.expected", "raw_url": "https://github.com/rust-lang/rust/raw/1368e81bcb2f5e9ed0188deb46f7a994f225ab4d/src%2Ftest%2Frustdoc-json%2Fnested.expected", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fnested.expected?ref=1368e81bcb2f5e9ed0188deb46f7a994f225ab4d", "patch": "@@ -41,8 +41,8 @@\n       \"inner\": {\n         \"is_crate\": false,\n         \"items\": [\n-          \"0:7\",\n-          \"0:4\"\n+          \"0:4\",\n+          \"0:7\"\n         ]\n       },\n       \"kind\": \"module\","}]}