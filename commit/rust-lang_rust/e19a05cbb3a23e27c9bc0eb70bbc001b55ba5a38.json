{"sha": "e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "node_id": "C_kwDOAAsO6NoAKGUxOWEwNWNiYjNhMjNlMjdjOWJjMGViNzBiYmMwMDFiNTViYTVhMzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T09:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T09:58:24Z"}, "message": "Auto merge of #8992 - kyoto7250:fix_8753, r=flip1995\n\nfeat(fix): Do not lint if the target code is inside a loop\n\nclose #8753\n\nwe consider the following code.\n\n```rust\nfn main() {\n    let vec = vec![1];\n    let w: Vec<usize> = vec.iter().map(|i| i * i).collect();  // <- once.\n\n    for i in 0..2 {\n        let _ = w.contains(&i);\n    }\n}\n```\n\nand the clippy will issue the following warning.\n\n```rust\nwarning: avoid using `collect()` when not needed\n --> src/main.rs:3:51\n  |\n3 |     let w: Vec<usize> = vec.iter().map(|i| i * i).collect();\n  |                                                   ^^^^^^^\n...\n6 |         let _ = w.contains(&i);\n  |                 -------------- the iterator could be used here instead\n  |\n  = note: `#[warn(clippy::needless_collect)]` on by default\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_collect\nhelp: check if the original Iterator contains an element instead of collecting then checking\n  |\n3 ~\n4 |\n5 |     for i in 0..2 {\n6 ~         let _ = vec.iter().map(|i| i * i).any(|x| x == i);\n```\n\nRewrite the code as indicated.\n\n```rust\nfn main() {\n    let vec = vec![1];\n\n    for i in 0..2 {\n        let _ = vec.iter().map(|i| i * i).any(|x| x == i);  // <- execute `map` every loop.\n    }\n}\n```\n\nthis code is valid in the compiler, but, it is different from the code before the rewrite.\nSo, we should not lint, If `collect` is outside of a loop.\n\nThank you in advance.\n\n---\n\nchangelog: Do not lint if the target code is inside a loop in `needless_collect`", "tree": {"sha": "e953aed47158951d23904067d829ad51367ba5af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e953aed47158951d23904067d829ad51367ba5af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "html_url": "https://github.com/rust-lang/rust/commit/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87b3afcd71c8c253196a503275be04856374ba4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/87b3afcd71c8c253196a503275be04856374ba4a", "html_url": "https://github.com/rust-lang/rust/commit/87b3afcd71c8c253196a503275be04856374ba4a"}, {"sha": "070b0350df41a65db066a66c2479ccd229627067", "url": "https://api.github.com/repos/rust-lang/rust/commits/070b0350df41a65db066a66c2479ccd229627067", "html_url": "https://github.com/rust-lang/rust/commit/070b0350df41a65db066a66c2479ccd229627067"}], "stats": {"total": 352, "additions": 346, "deletions": 6}, "files": [{"sha": "6d987f393fa5ce353c2d38dae517e5cdf18f1a6d", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "patch": "@@ -1,5 +1,6 @@\n use super::NEEDLESS_COLLECT;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -184,10 +185,19 @@ struct IterFunctionVisitor<'a, 'tcx> {\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block(&mut self, block: &'tcx Block<'tcx>) {\n         for (expr, hir_id) in block.stmts.iter().filter_map(get_expr_and_hir_id_from_stmt) {\n+            if check_loop_kind(expr).is_some() {\n+                continue;\n+            }\n             self.visit_block_expr(expr, hir_id);\n         }\n         if let Some(expr) = block.expr {\n-            self.visit_block_expr(expr, None);\n+            if let Some(loop_kind) = check_loop_kind(expr) {\n+                if let LoopKind::Conditional(block_expr) = loop_kind {\n+                    self.visit_block_expr(block_expr, None);\n+                }\n+            } else {\n+                self.visit_block_expr(expr, None);\n+            }\n         }\n     }\n \n@@ -264,6 +274,28 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     }\n }\n \n+enum LoopKind<'tcx> {\n+    Conditional(&'tcx Expr<'tcx>),\n+    Loop,\n+}\n+\n+fn check_loop_kind<'tcx>(expr: &Expr<'tcx>) -> Option<LoopKind<'tcx>> {\n+    if let Some(higher::WhileLet { let_expr, .. }) = higher::WhileLet::hir(expr) {\n+        return Some(LoopKind::Conditional(let_expr));\n+    }\n+    if let Some(higher::While { condition, .. }) = higher::While::hir(expr) {\n+        return Some(LoopKind::Conditional(condition));\n+    }\n+    if let Some(higher::ForLoop { arg, .. }) = higher::ForLoop::hir(expr) {\n+        return Some(LoopKind::Conditional(arg));\n+    }\n+    if let ExprKind::Loop { .. } = expr.kind {\n+        return Some(LoopKind::Loop);\n+    }\n+\n+    None\n+}\n+\n impl<'tcx> IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block_expr(&mut self, expr: &'tcx Expr<'tcx>, hir_id: Option<HirId>) {\n         self.current_statement_hir_id = hir_id;"}, {"sha": "5431f2ebc0a3d9782f6f384ae7e0aaec28e38555", "filename": "tests/compile-test.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "patch": "@@ -413,19 +413,21 @@ fn check_rustfix_coverage() {\n     if let Ok(missing_coverage_contents) = std::fs::read_to_string(missing_coverage_path) {\n         assert!(RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS.iter().is_sorted_by_key(Path::new));\n \n-        for rs_path in missing_coverage_contents.lines() {\n-            if Path::new(rs_path).starts_with(\"tests/ui/crashes\") {\n+        for rs_file in missing_coverage_contents.lines() {\n+            let rs_path = Path::new(rs_file);\n+            if rs_path.starts_with(\"tests/ui/crashes\") {\n                 continue;\n             }\n-            let filename = Path::new(rs_path).strip_prefix(\"tests/ui/\").unwrap();\n+            assert!(rs_path.starts_with(\"tests/ui/\"), \"{:?}\", rs_file);\n+            let filename = rs_path.strip_prefix(\"tests/ui/\").unwrap();\n             assert!(\n                 RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS\n                     .binary_search_by_key(&filename, Path::new)\n                     .is_ok(),\n                 \"`{}` runs `MachineApplicable` diagnostics but is missing a `run-rustfix` annotation. \\\n                 Please either add `// run-rustfix` at the top of the file or add the file to \\\n                 `RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS` in `tests/compile-test.rs`.\",\n-                rs_path,\n+                rs_file,\n             );\n         }\n     }"}, {"sha": "12a9ace1ee688679a5745698e314990480eda9f7", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "patch": "@@ -112,3 +112,192 @@ fn allow_test() {\n     let v = [1].iter().collect::<Vec<_>>();\n     v.into_iter().collect::<HashSet<_>>();\n }\n+\n+mod issue_8553 {\n+    fn test_for() {\n+        let vec = vec![1, 2];\n+        let w: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+\n+        for i in 0..2 {\n+            // Do not lint, because this method call is in the loop\n+            w.contains(&i);\n+        }\n+\n+        for i in 0..2 {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            // Do lint\n+            y.contains(&i);\n+            for j in 0..2 {\n+                // Do not lint, because this method call is in the loop\n+                z.contains(&j);\n+            }\n+        }\n+\n+        // Do not lint, because this variable is used.\n+        w.contains(&0);\n+    }\n+\n+    fn test_while() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut n = 0;\n+        while n > 1 {\n+            // Do not lint, because this method call is in the loop\n+            x.contains(&n);\n+            n += 1;\n+        }\n+\n+        while n > 2 {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            // Do lint\n+            y.contains(&n);\n+            n += 1;\n+            while n > 4 {\n+                // Do not lint, because this method call is in the loop\n+                z.contains(&n);\n+                n += 1;\n+            }\n+        }\n+    }\n+\n+    fn test_loop() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut n = 0;\n+        loop {\n+            if n < 1 {\n+                // Do not lint, because this method call is in the loop\n+                x.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        loop {\n+            if n < 2 {\n+                let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+                let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+                // Do lint\n+                y.contains(&n);\n+                n += 1;\n+                loop {\n+                    if n < 4 {\n+                        // Do not lint, because this method call is in the loop\n+                        z.contains(&n);\n+                        n += 1;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    fn test_while_let() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let optional = Some(0);\n+        let mut n = 0;\n+        while let Some(value) = optional {\n+            if n < 1 {\n+                // Do not lint, because this method call is in the loop\n+                x.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while let Some(value) = optional {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            if n < 2 {\n+                // Do lint\n+                y.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+\n+            while let Some(value) = optional {\n+                if n < 4 {\n+                    // Do not lint, because this method call is in the loop\n+                    z.contains(&n);\n+                    n += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn test_if_cond() {\n+        let vec = vec![1, 2];\n+        let v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        for _ in 0..w.len() {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_if_cond_false_case() {\n+        let vec = vec![1, 2];\n+        let v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        for _ in 0..w.len() {\n+            todo!();\n+        }\n+\n+        w.len();\n+    }\n+\n+    fn test_while_cond() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        while 1 == w.len() {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_while_cond_false_case() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        while 1 == w.len() {\n+            todo!();\n+        }\n+\n+        w.len();\n+    }\n+\n+    fn test_while_let_cond() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        while let Some(i) = Some(w.len()) {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_while_let_cond_false_case() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        while let Some(i) = Some(w.len()) {\n+            todo!();\n+        }\n+        w.len();\n+    }\n+}"}, {"sha": "9f0880cc6069d1449c7ec43d6386387deddcc5b7", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=e19a05cbb3a23e27c9bc0eb70bbc001b55ba5a38", "patch": "@@ -125,5 +125,122 @@ LL ~\n LL ~         sample.iter().count()\n    |\n \n-error: aborting due to 9 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:127:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |             y.contains(&i);\n+   |             -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             // Do lint\n+LL ~             vec.iter().map(|k| k * k).any(|x| x == i);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:152:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |             y.contains(&n);\n+   |             -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             // Do lint\n+LL ~             vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:181:63\n+   |\n+LL |                 let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                               ^^^^^^^\n+...\n+LL |                 y.contains(&n);\n+   |                 -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~                 \n+LL |                 let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |                 // Do lint\n+LL ~                 vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:217:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |                 y.contains(&n);\n+   |                 -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             if n < 2 {\n+LL |                 // Do lint\n+LL ~                 vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:242:26\n+   |\n+LL |         let w = v.iter().collect::<Vec<_>>();\n+   |                          ^^^^^^^\n+LL |         // Do lint\n+LL |         for _ in 0..w.len() {\n+   |                     ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         for _ in 0..v.iter().count() {\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:264:30\n+   |\n+LL |         let mut w = v.iter().collect::<Vec<_>>();\n+   |                              ^^^^^^^\n+LL |         // Do lint\n+LL |         while 1 == w.len() {\n+   |                    ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         while 1 == v.iter().count() {\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:286:30\n+   |\n+LL |         let mut w = v.iter().collect::<Vec<_>>();\n+   |                              ^^^^^^^\n+LL |         // Do lint\n+LL |         while let Some(i) = Some(w.len()) {\n+   |                                  ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         while let Some(i) = Some(v.iter().count()) {\n+   |\n+\n+error: aborting due to 16 previous errors\n "}]}