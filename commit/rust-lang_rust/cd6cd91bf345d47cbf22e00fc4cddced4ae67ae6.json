{"sha": "cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNmNkOTFiZjM0NWQ0N2NiZjIyZTAwZmM0Y2RkY2VkNGFlNjdhZTY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-12T21:27:01Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-12T21:27:01Z"}, "message": "Tidy up `recursive_merge` implementation", "tree": {"sha": "cd45394c56072ac51166a57c879b16568add07d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd45394c56072ac51166a57c879b16568add07d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "html_url": "https://github.com/rust-lang/rust/commit/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a898752881779a328462ad9f2db291073f2f134f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a898752881779a328462ad9f2db291073f2f134f", "html_url": "https://github.com/rust-lang/rust/commit/a898752881779a328462ad9f2db291073f2f134f"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "99f0b5b753c709e257de85d454574dcf41b5b3fb", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "patch": "@@ -120,7 +120,6 @@ pub(crate) fn insert_use(\n         }\n \n         if let ident_level @ 1..=usize::MAX = scope.indent_level().0 as usize {\n-            // FIXME: this alone doesnt properly re-align all cases\n             buf.push(make::tokens::whitespace(&\" \".repeat(4 * ident_level)).into());\n         }\n         buf.push(use_item.syntax().clone().into());\n@@ -164,44 +163,6 @@ pub(crate) fn try_merge_imports(\n     Some(old.with_use_tree(merged))\n }\n \n-/// Orders paths in the following way:\n-/// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n-/// FIXME: rustfmt sort lowercase idents before uppercase\n-fn path_cmp(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    let a = segment_iter(a);\n-    let b = segment_iter(b);\n-    let mut a_clone = a.clone();\n-    let mut b_clone = b.clone();\n-    match (\n-        a_clone.next().and_then(|ps| ps.self_token()).is_some() && a_clone.next().is_none(),\n-        b_clone.next().and_then(|ps| ps.self_token()).is_some() && b_clone.next().is_none(),\n-    ) {\n-        (true, true) => Ordering::Equal,\n-        (true, false) => Ordering::Less,\n-        (false, true) => Ordering::Greater,\n-        (false, false) => {\n-            // cmp_by would be useful for us here but that is currently unstable\n-            // cmp doesnt work due the lifetimes on text's return type\n-            a.zip(b)\n-                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n-                .find_map(|(a, b)| match a.text().cmp(b.text()) {\n-                    ord @ Ordering::Greater | ord @ Ordering::Less => Some(ord),\n-                    Ordering::Equal => None,\n-                })\n-                .unwrap_or(Ordering::Equal)\n-        }\n-    }\n-}\n-\n-fn path_cmp_opt(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n-    match (a, b) {\n-        (None, None) => Ordering::Equal,\n-        (None, Some(_)) => Ordering::Less,\n-        (Some(_), None) => Ordering::Greater,\n-        (Some(a), Some(b)) => path_cmp(&a, &b),\n-    }\n-}\n-\n pub(crate) fn try_merge_trees(\n     old: &ast::UseTree,\n     new: &ast::UseTree,\n@@ -216,17 +177,18 @@ pub(crate) fn try_merge_trees(\n     recursive_merge(&lhs, &rhs, merge).map(|(merged, _)| merged)\n }\n \n-/// Returns the merged tree and the number of children it has, which is required to check if the tree is allowed to be used for MergeBehaviour::Last\n+/// Recursively \"zips\" together lhs and rhs.\n fn recursive_merge(\n     lhs: &ast::UseTree,\n     rhs: &ast::UseTree,\n     merge: MergeBehaviour,\n-) -> Option<(ast::UseTree, usize)> {\n+) -> Option<(ast::UseTree, bool)> {\n     let mut use_trees = lhs\n         .use_tree_list()\n         .into_iter()\n         .flat_map(|list| list.use_trees())\n-        // check if any of the use trees are nested, if they are and the behaviour is last only we are not allowed to merge this\n+        // check if any of the use trees are nested, if they are and the behaviour is `last` we are not allowed to merge this\n+        // so early exit the iterator by using Option's Intoiterator impl\n         .map(|tree| match merge == MergeBehaviour::Last && tree.use_tree_list().is_some() {\n             true => None,\n             false => Some(tree),\n@@ -237,15 +199,17 @@ fn recursive_merge(\n         let rhs_path = rhs_t.path();\n         match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n             Ok(idx) => {\n-                let lhs_path = use_trees[idx].path()?;\n+                let lhs_t = &mut use_trees[idx];\n+                let lhs_path = lhs_t.path()?;\n                 let rhs_path = rhs_path?;\n                 let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n                 if lhs_prefix == lhs_path && rhs_prefix == rhs_path {\n-                    let tree_is_self =\n-                        |tree: ast::UseTree| tree.path().map(path_is_self).unwrap_or(false);\n+                    let tree_is_self = |tree: ast::UseTree| {\n+                        tree.path().as_ref().map(path_is_self).unwrap_or(false)\n+                    };\n                     // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n                     // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n-                    if use_trees[idx]\n+                    if lhs_t\n                         .use_tree_list()\n                         .xor(rhs_t.use_tree_list())\n                         .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n@@ -257,8 +221,8 @@ fn recursive_merge(\n                     // glob imports arent part of the use-tree lists so we need to special handle them here as well\n                     // this special handling is only required for when we merge a module import into a glob import of said module\n                     // see the `merge_self_glob` or `merge_mod_into_glob` tests\n-                    if use_trees[idx].star_token().is_some() || rhs_t.star_token().is_some() {\n-                        use_trees[idx] = make::use_tree(\n+                    if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n+                        *lhs_t = make::use_tree(\n                             make::path_unqualified(make::path_segment_self()),\n                             None,\n                             None,\n@@ -276,11 +240,14 @@ fn recursive_merge(\n                         continue;\n                     }\n                 }\n-                let lhs = use_trees[idx].split_prefix(&lhs_prefix);\n+                let lhs = lhs_t.split_prefix(&lhs_prefix);\n                 let rhs = rhs_t.split_prefix(&rhs_prefix);\n+                let this_has_children = use_trees.len() > 0;\n                 match recursive_merge(&lhs, &rhs, merge) {\n-                    Some((_, count))\n-                        if merge == MergeBehaviour::Last && use_trees.len() > 1 && count > 1 =>\n+                    Some((_, has_multiple_children))\n+                        if merge == MergeBehaviour::Last\n+                            && this_has_children\n+                            && has_multiple_children =>\n                     {\n                         return None\n                     }\n@@ -293,9 +260,8 @@ fn recursive_merge(\n             }\n         }\n     }\n-    let count = use_trees.len();\n-    let tl = make::use_tree_list(use_trees);\n-    Some((lhs.with_use_tree_list(tl), count))\n+    let has_multiple_children = use_trees.len() > 1;\n+    Some((lhs.with_use_tree_list(make::use_tree_list(use_trees)), has_multiple_children))\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -306,7 +272,7 @@ fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Pa\n     loop {\n         match (lhs_curr.segment(), rhs_curr.segment()) {\n             (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n-            _ => break,\n+            _ => break res,\n         }\n         res = Some((lhs_curr.clone(), rhs_curr.clone()));\n \n@@ -315,17 +281,16 @@ fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Pa\n                 lhs_curr = lhs;\n                 rhs_curr = rhs;\n             }\n-            _ => break,\n+            _ => break res,\n         }\n     }\n-\n-    res\n }\n \n-fn path_is_self(path: ast::Path) -> bool {\n+fn path_is_self(path: &ast::Path) -> bool {\n     path.segment().and_then(|seg| seg.self_token()).is_some() && path.qualifier().is_none()\n }\n \n+#[inline]\n fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n     first_path(path).segment()\n }\n@@ -339,6 +304,41 @@ fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Cl\n     successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n }\n \n+/// Orders paths in the following way:\n+/// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n+// FIXME: rustfmt sort lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n+// which is `self` and `super` first, then identifier imports with lowercase ones first, then glob imports and at last list imports.\n+// Example foo::{self, foo, baz, Baz, Qux, *, {Bar}}\n+fn path_cmp(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    match (path_is_self(a), path_is_self(b)) {\n+        (true, true) => Ordering::Equal,\n+        (true, false) => Ordering::Less,\n+        (false, true) => Ordering::Greater,\n+        (false, false) => {\n+            let a = segment_iter(a);\n+            let b = segment_iter(b);\n+            // cmp_by would be useful for us here but that is currently unstable\n+            // cmp doesnt work due the lifetimes on text's return type\n+            a.zip(b)\n+                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n+                .find_map(|(a, b)| match a.text().cmp(b.text()) {\n+                    ord @ Ordering::Greater | ord @ Ordering::Less => Some(ord),\n+                    Ordering::Equal => None,\n+                })\n+                .unwrap_or(Ordering::Equal)\n+        }\n+    }\n+}\n+\n+fn path_cmp_opt(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n+    match (a, b) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(a), Some(b)) => path_cmp(&a, &b),\n+    }\n+}\n+\n /// What type of merges are allowed.\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum MergeBehaviour {\n@@ -924,6 +924,6 @@ use foo::bar::baz::Qux;\",\n             .unwrap();\n \n         let result = try_merge_imports(&use0, &use1, mb);\n-        assert_eq!(result, None);\n+        assert_eq!(result.map(|u| u.to_string()), None);\n     }\n }"}]}