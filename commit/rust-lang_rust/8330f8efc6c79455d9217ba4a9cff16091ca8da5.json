{"sha": "8330f8efc6c79455d9217ba4a9cff16091ca8da5", "node_id": "C_kwDOAAsO6NoAKDgzMzBmOGVmYzZjNzk0NTVkOTIxN2JhNGE5Y2ZmMTYwOTFjYThkYTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T13:35:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T13:35:44Z"}, "message": "Auto merge of #12958 - zachs18:async_closure, r=Veykril\n\nfix: Fix return type of async closures.\n\nMay fix #12957", "tree": {"sha": "b75daf66e83bc1bed2ab84f261e73dd8c4f794b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75daf66e83bc1bed2ab84f261e73dd8c4f794b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8330f8efc6c79455d9217ba4a9cff16091ca8da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8330f8efc6c79455d9217ba4a9cff16091ca8da5", "html_url": "https://github.com/rust-lang/rust/commit/8330f8efc6c79455d9217ba4a9cff16091ca8da5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8330f8efc6c79455d9217ba4a9cff16091ca8da5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16f0517922c220e5b0aaac2ff50459578d6dfec", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16f0517922c220e5b0aaac2ff50459578d6dfec", "html_url": "https://github.com/rust-lang/rust/commit/c16f0517922c220e5b0aaac2ff50459578d6dfec"}, {"sha": "3bf07a5f040be32cafe89977372f271673894a61", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf07a5f040be32cafe89977372f271673894a61", "html_url": "https://github.com/rust-lang/rust/commit/3bf07a5f040be32cafe89977372f271673894a61"}], "stats": {"total": 157, "additions": 114, "deletions": 43}, "files": [{"sha": "fedaf39559858099094328286961bf44b7842bf2", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=8330f8efc6c79455d9217ba4a9cff16091ca8da5", "patch": "@@ -499,6 +499,8 @@ impl ExprCollector<'_> {\n                         Movability::Movable\n                     };\n                     ClosureKind::Generator(movability)\n+                } else if e.async_token().is_some() {\n+                    ClosureKind::Async\n                 } else {\n                     ClosureKind::Closure\n                 };"}, {"sha": "5a9b825a2530bd5c7bf7bd8d15f5fd444b4f84b5", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=8330f8efc6c79455d9217ba4a9cff16091ca8da5", "patch": "@@ -360,8 +360,14 @@ impl<'a> Printer<'a> {\n                 w!(self, \"]\");\n             }\n             Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n-                if let ClosureKind::Generator(Movability::Static) = closure_kind {\n-                    w!(self, \"static \");\n+                match closure_kind {\n+                    ClosureKind::Generator(Movability::Static) => {\n+                        w!(self, \"static \");\n+                    }\n+                    ClosureKind::Async => {\n+                        w!(self, \"async \");\n+                    }\n+                    _ => (),\n                 }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {"}, {"sha": "19fa6b25419e112cc92987a85d9a1308112b0bfd", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=8330f8efc6c79455d9217ba4a9cff16091ca8da5", "patch": "@@ -245,6 +245,7 @@ pub enum Expr {\n pub enum ClosureKind {\n     Closure,\n     Generator(Movability),\n+    Async,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]"}, {"sha": "ee186673ee130ab8d13daca76e82319c47aac6c0", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8330f8efc6c79455d9217ba4a9cff16091ca8da5", "patch": "@@ -275,7 +275,23 @@ impl<'a> InferenceContext<'a> {\n                     Some(type_ref) => self.make_ty(type_ref),\n                     None => self.table.new_type_var(),\n                 };\n-                sig_tys.push(ret_ty.clone());\n+                if let ClosureKind::Async = closure_kind {\n+                    // Use the first type parameter as the output type of future.\n+                    // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                    let impl_trait_id =\n+                        crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                    let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n+                    sig_tys.push(\n+                        TyKind::OpaqueType(\n+                            opaque_ty_id,\n+                            Substitution::from1(Interner, ret_ty.clone()),\n+                        )\n+                        .intern(Interner),\n+                    );\n+                } else {\n+                    sig_tys.push(ret_ty.clone());\n+                }\n+\n                 let sig_ty = TyKind::Function(FnPointer {\n                     num_binders: 0,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n@@ -286,33 +302,38 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .intern(Interner);\n \n-                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n-                    // FIXME: report error when there are more than 1 parameter.\n-                    let resume_ty = match sig_tys.first() {\n-                        // When `sig_tys.len() == 1` the first type is the return type, not the\n-                        // first parameter type.\n-                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n-                        _ => self.result.standard_types.unit.clone(),\n-                    };\n-                    let yield_ty = self.table.new_type_var();\n-\n-                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n-                        .push(resume_ty.clone())\n-                        .push(yield_ty.clone())\n-                        .push(ret_ty.clone())\n-                        .build();\n+                let (ty, resume_yield_tys) = match closure_kind {\n+                    ClosureKind::Generator(_) => {\n+                        // FIXME: report error when there are more than 1 parameter.\n+                        let resume_ty = match sig_tys.first() {\n+                            // When `sig_tys.len() == 1` the first type is the return type, not the\n+                            // first parameter type.\n+                            Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                            _ => self.result.standard_types.unit.clone(),\n+                        };\n+                        let yield_ty = self.table.new_type_var();\n+\n+                        let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                            .push(resume_ty.clone())\n+                            .push(yield_ty.clone())\n+                            .push(ret_ty.clone())\n+                            .build();\n \n-                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n-                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+                        let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                        let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n \n-                    (generator_ty, Some((resume_ty, yield_ty)))\n-                } else {\n-                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                    let closure_ty =\n-                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                            .intern(Interner);\n+                        (generator_ty, Some((resume_ty, yield_ty)))\n+                    }\n+                    ClosureKind::Closure | ClosureKind::Async => {\n+                        let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                        let closure_ty = TyKind::Closure(\n+                            closure_id,\n+                            Substitution::from1(Interner, sig_ty.clone()),\n+                        )\n+                        .intern(Interner);\n \n-                    (closure_ty, None)\n+                        (closure_ty, None)\n+                    }\n                 };\n \n                 // Eagerly try to relate the closure type with the expected\n@@ -321,7 +342,7 @@ impl<'a> InferenceContext<'a> {\n                 self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n-                for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n+                for (arg_pat, arg_ty) in args.iter().zip(&sig_tys) {\n                     self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n "}, {"sha": "da76d7fd83f76a0987f0d27284dbe49e8a409acc", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8330f8efc6c79455d9217ba4a9cff16091ca8da5/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8330f8efc6c79455d9217ba4a9cff16091ca8da5", "patch": "@@ -82,6 +82,46 @@ async fn test() {\n     );\n }\n \n+#[test]\n+fn infer_async_closure() {\n+    check_types(\n+        r#\"\n+//- minicore: future, option\n+async fn test() {\n+    let f = async move |x: i32| x + 42;\n+    f;\n+//  ^ |i32| -> impl Future<Output = i32>\n+    let a = f(4);\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let f = async move || 42;\n+    f;\n+//  ^ || -> impl Future<Output = i32>\n+    let a = f();\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let b = ((async move || {})()).await;\n+    b;\n+//  ^ ()\n+    let c = async move || {\n+        let y = None;\n+        y\n+    //  ^ Option<u64>\n+    };\n+    let _: Option<u64> = c().await;\n+    c;\n+//  ^ || -> impl Future<Output = Option<u64>>\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn auto_sized_async_block() {\n     check_no_mismatches(\n@@ -493,29 +533,30 @@ fn tuple_struct_with_fn() {\n         r#\"\n struct S(fn(u32) -> u64);\n fn test() -> u64 {\n-    let a = S(|i| 2*i);\n+    let a = S(|i| 2*i as u64);\n     let b = a.0(4);\n     a.0(2)\n }\"#,\n         expect![[r#\"\n-            43..101 '{     ...0(2) }': u64\n+            43..108 '{     ...0(2) }': u64\n             53..54 'a': S\n             57..58 'S': S(fn(u32) -> u64) -> S\n-            57..67 'S(|i| 2*i)': S\n-            59..66 '|i| 2*i': |u32| -> u64\n+            57..74 'S(|i| ...s u64)': S\n+            59..73 '|i| 2*i as u64': |u32| -> u64\n             60..61 'i': u32\n-            63..64 '2': u32\n-            63..66 '2*i': u32\n+            63..64 '2': u64\n+            63..73 '2*i as u64': u64\n             65..66 'i': u32\n-            77..78 'b': u64\n-            81..82 'a': S\n-            81..84 'a.0': fn(u32) -> u64\n-            81..87 'a.0(4)': u64\n-            85..86 '4': u32\n-            93..94 'a': S\n-            93..96 'a.0': fn(u32) -> u64\n-            93..99 'a.0(2)': u64\n-            97..98 '2': u32\n+            65..73 'i as u64': u64\n+            84..85 'b': u64\n+            88..89 'a': S\n+            88..91 'a.0': fn(u32) -> u64\n+            88..94 'a.0(4)': u64\n+            92..93 '4': u32\n+            100..101 'a': S\n+            100..103 'a.0': fn(u32) -> u64\n+            100..106 'a.0(2)': u64\n+            104..105 '2': u32\n         \"#]],\n     );\n }"}]}