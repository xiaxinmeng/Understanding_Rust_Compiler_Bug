{"sha": "453ad8122c975dc82f6090f0c755d38932ccefc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1M2FkODEyMmM5NzVkYzgyZjYwOTBmMGM3NTVkMzg5MzJjY2VmYzU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-07T20:50:34Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-08T08:18:12Z"}, "message": "make `for_all_relevant_impls` O(1) again\n\nA change in #41911 had made `for_all_relevant_impls` do a linear scan over\nall impls, instead of using an HashMap. Use an HashMap again to avoid\nquadratic blowup when there is a large number of structs with impls.\n\nI think this fixes #43141 completely, but I want better measurements in\norder to be sure. As a perf patch, please don't roll this up.", "tree": {"sha": "d9d66de97f4cae1f3c907a5201c283b4522aeb46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9d66de97f4cae1f3c907a5201c283b4522aeb46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/453ad8122c975dc82f6090f0c755d38932ccefc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/453ad8122c975dc82f6090f0c755d38932ccefc5", "html_url": "https://github.com/rust-lang/rust/commit/453ad8122c975dc82f6090f0c755d38932ccefc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/453ad8122c975dc82f6090f0c755d38932ccefc5/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f558543bf2c8e9c056443c144ca9c3ff98f0f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f558543bf2c8e9c056443c144ca9c3ff98f0f3", "html_url": "https://github.com/rust-lang/rust/commit/e8f558543bf2c8e9c056443c144ca9c3ff98f0f3"}], "stats": {"total": 215, "additions": 77, "deletions": 138}, "files": [{"sha": "65c0a9f8ffd58383c09fea1186cc8326b70c1275", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -278,8 +278,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut self_match_impls = vec![];\n         let mut fuzzy_match_impls = vec![];\n \n-        self.tcx.trait_def(trait_ref.def_id)\n-            .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n+        self.tcx.for_each_relevant_impl(\n+            trait_ref.def_id, trait_self_ty, |def_id| {\n                 let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n@@ -396,10 +396,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                               trait_ref.skip_binder().self_ty(),\n                                               true);\n         let mut impl_candidates = Vec::new();\n-        let trait_def = self.tcx.trait_def(trait_ref.def_id());\n \n         match simp {\n-            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+            Some(simp) => self.tcx.for_each_impl(trait_ref.def_id(), |def_id| {\n                 let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let imp_simp = fast_reject::simplify_type(self.tcx,\n                                                           imp.self_ty(),\n@@ -411,7 +410,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 impl_candidates.push(imp);\n             }),\n-            None => trait_def.for_each_impl(self.tcx, |def_id| {\n+            None => self.tcx.for_each_impl(trait_ref.def_id(), |def_id| {\n                 impl_candidates.push(\n                     self.tcx.impl_trait_ref(def_id).unwrap());\n             })"}, {"sha": "c2feb54c4dbe65e294c8e8358f753f61dca085ba", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -1576,10 +1576,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n-        let def = self.tcx().trait_def(obligation.predicate.def_id());\n-\n-        def.for_each_relevant_impl(\n-            self.tcx(),\n+        self.tcx().for_each_relevant_impl(\n+            obligation.predicate.def_id(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n                 self.probe(|this, snapshot| { /* [1] */"}, {"sha": "7c916e162a4fffcaef56ef60a2fa21074737dc61", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -300,7 +300,8 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                                       -> Rc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n-    let mut trait_impls: Vec<DefId> = tcx.trait_impls_of(trait_id).iter().collect();\n+    let mut trait_impls = Vec::new();\n+    tcx.for_each_impl(trait_id, |impl_did| trait_impls.push(impl_did));\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by"}, {"sha": "5d25ce2fbeca39824fd8d46f180cc2aac81a9189", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -470,12 +470,6 @@ impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::relevant_trait_impls_for<'tcx> {\n-    fn describe(tcx: TyCtxt, (def_id, ty): (DefId, SimplifiedType)) -> String {\n-        format!(\"relevant impls for: `({}, {:?})`\", tcx.item_path_str(def_id), ty)\n-    }\n-}\n-\n impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n@@ -966,10 +960,7 @@ define_maps! { <'tcx>\n     [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] is_mir_available: IsMirAvailable(DefId) -> bool,\n \n-    [] trait_impls_of: TraitImpls(DefId) -> ty::trait_def::TraitImpls,\n-    // Note that TraitDef::for_each_relevant_impl() will do type simplication for you.\n-    [] relevant_trait_impls_for: relevant_trait_impls_for((DefId, SimplifiedType))\n-        -> ty::trait_def::TraitImpls,\n+    [] trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n     [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] is_object_safe: ObjectSafety(DefId) -> bool,\n \n@@ -1049,10 +1040,6 @@ fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::CrateVariances\n }\n \n-fn relevant_trait_impls_for<'tcx>((def_id, t): (DefId, SimplifiedType)) -> DepConstructor<'tcx> {\n-    DepConstructor::RelevantTraitImpls(def_id, t)\n-}\n-\n fn is_copy_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     DepConstructor::IsCopy\n }"}, {"sha": "7f4aedb5f14bb7bc0b9f88a59767222b3ed8a116", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -2507,7 +2507,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         param_env,\n         trait_of_item,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n-        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }\n@@ -2517,7 +2516,6 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n         adt_sized_constraint,\n         adt_dtorck_constraint,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n-        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         param_env,\n         ..*providers\n     };"}, {"sha": "9990472c6b4caa60eb52ff8019f4a42ae2141326", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 64, "deletions": 104, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir;\n use hir::def_id::DefId;\n use hir::map::DefPathHash;\n use traits::specialization_graph;\n use ty::fast_reject;\n use ty::fold::TypeFoldable;\n use ty::{Ty, TyCtxt};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n use std::rc::Rc;\n-use hir;\n \n /// A trait's definition with type information.\n pub struct TraitDef {\n@@ -36,60 +39,12 @@ pub struct TraitDef {\n     pub def_path_hash: DefPathHash,\n }\n \n-// We don't store the list of impls in a flat list because each cached list of\n-// `relevant_impls_for` we would then duplicate all blanket impls. By keeping\n-// blanket and non-blanket impls separate, we can share the list of blanket\n-// impls.\n-#[derive(Clone)]\n pub struct TraitImpls {\n-    blanket_impls: Rc<Vec<DefId>>,\n-    non_blanket_impls: Rc<Vec<DefId>>,\n+    blanket_impls: Vec<DefId>,\n+    /// Impls indexed by their simplified self-type, for fast lookup.\n+    non_blanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n }\n \n-impl TraitImpls {\n-    pub fn iter(&self) -> TraitImplsIter {\n-        TraitImplsIter {\n-            blanket_impls: self.blanket_impls.clone(),\n-            non_blanket_impls: self.non_blanket_impls.clone(),\n-            index: 0\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct TraitImplsIter {\n-    blanket_impls: Rc<Vec<DefId>>,\n-    non_blanket_impls: Rc<Vec<DefId>>,\n-    index: usize,\n-}\n-\n-impl Iterator for TraitImplsIter {\n-    type Item = DefId;\n-\n-    fn next(&mut self) -> Option<DefId> {\n-        if self.index < self.blanket_impls.len() {\n-            let bi_index = self.index;\n-            self.index += 1;\n-            Some(self.blanket_impls[bi_index])\n-        } else {\n-            let nbi_index = self.index - self.blanket_impls.len();\n-            if nbi_index < self.non_blanket_impls.len() {\n-                self.index += 1;\n-                Some(self.non_blanket_impls[nbi_index])\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let items_left = (self.blanket_impls.len() + self.non_blanket_impls.len()) - self.index;\n-        (items_left, Some(items_left))\n-    }\n-}\n-\n-impl ExactSizeIterator for TraitImplsIter {}\n-\n impl<'a, 'gcx, 'tcx> TraitDef {\n     pub fn new(def_id: DefId,\n                unsafety: hir::Unsafety,\n@@ -111,20 +66,36 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                      -> specialization_graph::Ancestors {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n+}\n \n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n-        for impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn for_each_impl<F: FnMut(DefId)>(self, def_id: DefId, mut f: F) {\n+        let impls = self.trait_impls_of(def_id);\n+\n+        for &impl_def_id in impls.blanket_impls.iter() {\n             f(impl_def_id);\n         }\n+\n+        for v in impls.non_blanket_impls.values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n     }\n \n     /// Iterate over every impl that could possibly match the\n     /// self-type `self_ty`.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(self,\n+                                                   def_id: DefId,\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {\n+        let impls = self.trait_impls_of(def_id);\n+\n+        for &impl_def_id in impls.blanket_impls.iter() {\n+            f(impl_def_id);\n+        }\n+\n         // simplify_type(.., false) basically replaces type parameters and\n         // projections with infer-variables. This is, of course, done on\n         // the impl trait-ref when it is instantiated, but not on the\n@@ -137,23 +108,39 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         // replace `S` with anything - this impl of course can't be\n         // selected, and as there are hundreds of similar impls,\n         // considering them would significantly harm performance.\n-        let relevant_impls = if let Some(simplified_self_ty) =\n-                fast_reject::simplify_type(tcx, self_ty, true) {\n-            tcx.relevant_trait_impls_for((self.def_id, simplified_self_ty))\n-        } else {\n-            tcx.trait_impls_of(self.def_id)\n-        };\n \n-        for impl_def_id in relevant_impls.iter() {\n-            f(impl_def_id);\n+        // This depends on the set of all impls for the trait. That is\n+        // unfortunate. When we get red-green recompilation, we would like\n+        // to have a way of knowing whether the set of relevant impls\n+        // changed. The most naive\n+        // way would be to compute the Vec of relevant impls and see whether\n+        // it differs between compilations. That shouldn't be too slow by\n+        // itself - we do quite a bit of work for each relevant impl anyway.\n+        //\n+        // If we want to be faster, we could have separate queries for\n+        // blanket and non-blanket impls, and compare them separately.\n+        //\n+        // I think we'll cross that bridge when we get to it.\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, true) {\n+            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n+                }\n+            }\n+        } else {\n+            for v in impls.non_blanket_impls.values() {\n+                for &impl_def_id in v {\n+                    f(impl_def_id);\n+                }\n+            }\n         }\n     }\n }\n \n // Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n-                                                -> TraitImpls {\n+                                                -> Rc<TraitImpls> {\n     let remote_impls = if trait_id.is_local() {\n         // Traits defined in the current crate can't have impls in upstream\n         // crates, so we don't bother querying the cstore.\n@@ -163,7 +150,7 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let mut blanket_impls = Vec::new();\n-    let mut non_blanket_impls = Vec::new();\n+    let mut non_blanket_impls = FxHashMap();\n \n     let local_impls = tcx.hir\n                          .trait_impls(trait_id)\n@@ -176,47 +163,20 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             continue\n         }\n \n-        if fast_reject::simplify_type(tcx, impl_self_ty, false).is_some() {\n-            non_blanket_impls.push(impl_def_id);\n+        if let Some(simplified_self_ty) =\n+            fast_reject::simplify_type(tcx, impl_self_ty, false)\n+        {\n+            non_blanket_impls\n+                .entry(simplified_self_ty)\n+                .or_insert(vec![])\n+                .push(impl_def_id);\n         } else {\n             blanket_impls.push(impl_def_id);\n         }\n     }\n \n-    TraitImpls {\n-        blanket_impls: Rc::new(blanket_impls),\n-        non_blanket_impls: Rc::new(non_blanket_impls),\n-    }\n-}\n-\n-// Query provider for `relevant_trait_impls_for`.\n-pub(super) fn relevant_trait_impls_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    (trait_id, self_ty): (DefId, fast_reject::SimplifiedType))\n-    -> TraitImpls\n-{\n-    let all_trait_impls = tcx.trait_impls_of(trait_id);\n-\n-    let relevant: Vec<DefId> = all_trait_impls\n-        .non_blanket_impls\n-        .iter()\n-        .cloned()\n-        .filter(|&impl_def_id| {\n-            let impl_self_ty = tcx.type_of(impl_def_id);\n-            let impl_simple_self_ty = fast_reject::simplify_type(tcx,\n-                                                                 impl_self_ty,\n-                                                                 false).unwrap();\n-            impl_simple_self_ty == self_ty\n-        })\n-        .collect();\n-\n-    if all_trait_impls.non_blanket_impls.len() == relevant.len() {\n-        // If we didn't filter anything out, re-use the existing vec.\n-        all_trait_impls\n-    } else {\n-        TraitImpls {\n-            blanket_impls: all_trait_impls.blanket_impls.clone(),\n-            non_blanket_impls: Rc::new(relevant),\n-        }\n-    }\n+    Rc::new(TraitImpls {\n+        blanket_impls: blanket_impls,\n+        non_blanket_impls: non_blanket_impls,\n+    })\n }"}, {"sha": "d1c73831545416c1c8b0376dbb2e78fe7f890cec", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -422,7 +422,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n-        self.trait_def(drop_trait).for_each_relevant_impl(self, ty, |impl_did| {\n+        self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n             if let Some(item) = self.associated_items(impl_did).next() {\n                 if let Ok(()) = validate(self, impl_did) {\n                     dtor_did = Some(item.def_id);"}, {"sha": "db27fa874f4e91091b900d610845cd3acc891c58", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -542,9 +542,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let debug_def = cx.tcx.trait_def(debug);\n             let mut impls = NodeSet();\n-            debug_def.for_each_impl(cx.tcx, |d| {\n+            cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_to_def_id() {\n                     if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def) {\n                         impls.insert(node_id);"}, {"sha": "8321d9b99ae8d63ba3ea7cf05d7375431d119770", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -244,8 +244,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 let mut span = None;\n \n                 self.tcx\n-                    .trait_def(drop_trait_id)\n-                    .for_each_relevant_impl(self.tcx, self.mir.return_ty, |impl_did| {\n+                    .for_each_relevant_impl(drop_trait_id, self.mir.return_ty, |impl_did| {\n                         self.tcx.hir\n                             .as_local_node_id(impl_did)\n                             .and_then(|impl_node_id| self.tcx.hir.find(impl_node_id))"}, {"sha": "881fc7a137095b0d01a92ec2d7b024e88cb9d073", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453ad8122c975dc82f6090f0c755d38932ccefc5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=453ad8122c975dc82f6090f0c755d38932ccefc5", "patch": "@@ -736,10 +736,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                      import_id: Option<ast::NodeId>,\n                                                      trait_def_id: DefId,\n                                                      item: ty::AssociatedItem) {\n-        let trait_def = self.tcx.trait_def(trait_def_id);\n-\n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n-        trait_def.for_each_impl(self.tcx, |impl_def_id| {\n+        self.tcx.for_each_impl(trait_def_id, |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n                                                                   impl_def_id={:?}\",\n                    trait_def_id,"}]}