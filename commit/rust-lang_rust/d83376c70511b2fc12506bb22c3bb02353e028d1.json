{"sha": "d83376c70511b2fc12506bb22c3bb02353e028d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4MzM3NmM3MDUxMWIyZmMxMjUwNmJiMjJjM2JiMDIzNTNlMDI4ZDE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-26T10:24:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-26T10:24:58Z"}, "message": "Rollup merge of #55167 - nnethercote:is_missing_ctors_empty, r=varkor\n\nAdd a \"cheap\" mode for `compute_missing_ctors`.\n\n`compute_missing_ctors` produces a vector. It is called a lot, but the\nvector is almost always only checked for emptiness.\n\nThis commit introduces a specialized variant of `compute_missing_ctors`\n(called `is_missing_ctors_empty`) that determines if the resulting set\nwould be empty, and changes the callsite so that `compute_missing_ctors`\nis only called in the rare cases where it is needed. The code\nduplication is unfortunate but I can't see a better way to do it.\n\nThis change reduces instruction counts for several benchmarks up to 2%.\n\nr? @varkor", "tree": {"sha": "353af037de8376b9dbacb2bee255e5a95e0701e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/353af037de8376b9dbacb2bee255e5a95e0701e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d83376c70511b2fc12506bb22c3bb02353e028d1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb0ut6CRBK7hj4Ov3rIwAAdHIIAATnpEJRAqnwFpMO9Q2G+Lkj\nzlXxAOg4etFybssUsPbu6nn3Mx25LcWCQOy9peNyH6FeI/80PlBv6PVaF2SeSIW+\nXgEW8S86cB1JAkh/G8FtlPZ1ME9S+dRLwnz/V3iF7fYHHd3glg5gFo+XlhKD4Ybc\nJGfhKCk5QqfCxQ3CN/0+D3b2AJr+S6xbImoQLhKcXTFtpbuVQkB2MioU9wHCurUG\nes1eyvBaetg+UBB1PmTwAPfiffHoSQY4YSlVo68QW5fd00LpAglX5IK6wbVkyaMv\nm9QH5Dp5GbotEnBJK0vqdyQfK2a04EY4IgXI9HTFU+c417blC/KRCJbhxePW7+A=\n=Pwpr\n-----END PGP SIGNATURE-----\n", "payload": "tree 353af037de8376b9dbacb2bee255e5a95e0701e2\nparent 4212896dcaf14003579644a058145939078799a1\nparent b5336c0b9755f635db4eafba6254e192ee451e6a\nauthor kennytm <kennytm@gmail.com> 1540549498 +0800\ncommitter GitHub <noreply@github.com> 1540549498 +0800\n\nRollup merge of #55167 - nnethercote:is_missing_ctors_empty, r=varkor\n\nAdd a \"cheap\" mode for `compute_missing_ctors`.\n\n`compute_missing_ctors` produces a vector. It is called a lot, but the\nvector is almost always only checked for emptiness.\n\nThis commit introduces a specialized variant of `compute_missing_ctors`\n(called `is_missing_ctors_empty`) that determines if the resulting set\nwould be empty, and changes the callsite so that `compute_missing_ctors`\nis only called in the rare cases where it is needed. The code\nduplication is unfortunate but I can't see a better way to do it.\n\nThis change reduces instruction counts for several benchmarks up to 2%.\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d83376c70511b2fc12506bb22c3bb02353e028d1", "html_url": "https://github.com/rust-lang/rust/commit/d83376c70511b2fc12506bb22c3bb02353e028d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d83376c70511b2fc12506bb22c3bb02353e028d1/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4212896dcaf14003579644a058145939078799a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4212896dcaf14003579644a058145939078799a1", "html_url": "https://github.com/rust-lang/rust/commit/4212896dcaf14003579644a058145939078799a1"}, {"sha": "b5336c0b9755f635db4eafba6254e192ee451e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5336c0b9755f635db4eafba6254e192ee451e6a", "html_url": "https://github.com/rust-lang/rust/commit/b5336c0b9755f635db4eafba6254e192ee451e6a"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "d53bb1dc4d63a255e12ee4add8dcd8200e605339", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d83376c70511b2fc12506bb22c3bb02353e028d1/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d83376c70511b2fc12506bb22c3bb02353e028d1/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d83376c70511b2fc12506bb22c3bb02353e028d1", "patch": "@@ -931,12 +931,37 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-// Return a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+// A request for missing constructor data in terms of either:\n+// - whether or not there any missing constructors; or\n+// - the actual set of missing constructors.\n+#[derive(PartialEq)]\n+enum MissingCtorsInfo {\n+    Emptiness,\n+    Ctors,\n+}\n+\n+// Used by `compute_missing_ctors`.\n+#[derive(Debug, PartialEq)]\n+enum MissingCtors<'tcx> {\n+    Empty,\n+    NonEmpty,\n+\n+    // Note that the Vec can be empty.\n+    Ctors(Vec<Constructor<'tcx>>),\n+}\n+\n+// When `info` is `MissingCtorsInfo::Ctors`, compute a set of constructors\n+// equivalent to `all_ctors \\ used_ctors`. When `info` is\n+// `MissingCtorsInfo::Emptiness`, just determines if that set is empty or not.\n+// (The split logic gives a performance win, because we always need to know if\n+// the set is empty, but we rarely need the full set, and it can be expensive\n+// to compute the full set.)\n fn compute_missing_ctors<'a, 'tcx: 'a>(\n+    info: MissingCtorsInfo,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n     used_ctors: &Vec<Constructor<'tcx>>,\n-) -> Vec<Constructor<'tcx>> {\n+) -> MissingCtors<'tcx> {\n     let mut missing_ctors = vec![];\n \n     for req_ctor in all_ctors {\n@@ -965,10 +990,22 @@ fn compute_missing_ctors<'a, 'tcx: 'a>(\n         // We add `refined_ctors` instead of `req_ctor`, because then we can\n         // provide more detailed error information about precisely which\n         // ranges have been omitted.\n-        missing_ctors.extend(refined_ctors);\n+        if info == MissingCtorsInfo::Emptiness {\n+            if !refined_ctors.is_empty() {\n+                // The set is non-empty; return early.\n+                return MissingCtors::NonEmpty;\n+            }\n+        } else {\n+            missing_ctors.extend(refined_ctors);\n+        }\n     }\n \n-    missing_ctors\n+    if info == MissingCtorsInfo::Emptiness {\n+        // If we reached here, the set is empty.\n+        MissingCtors::Empty\n+    } else {\n+        MissingCtors::Ctors(missing_ctors)\n+    }\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n@@ -1081,20 +1118,23 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // feature flag is not present, so this is only\n         // needed for that case.\n \n-        // Find those constructors that are not matched by any non-wildcard patterns in the\n-        // current column.\n-        let missing_ctors = compute_missing_ctors(cx.tcx, &all_ctors, &used_ctors);\n+        // Missing constructors are those that are not matched by any\n+        // non-wildcard patterns in the current column. We always determine if\n+        // the set is empty, but we only fully construct them on-demand,\n+        // because they're rarely used and can be big.\n+        let cheap_missing_ctors =\n+            compute_missing_ctors(MissingCtorsInfo::Emptiness, cx.tcx, &all_ctors, &used_ctors);\n \n         let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-        debug!(\"missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-               missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n+        debug!(\"cheap_missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n+               cheap_missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n         // `_` constructor for the type, so we can never match over all constructors.\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n \n-        if missing_ctors.is_empty() && !is_non_exhaustive {\n+        if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n             split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -1165,15 +1205,22 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             witness\n                         }).collect()\n                     } else {\n-                        pats.into_iter().flat_map(|witness| {\n-                            missing_ctors.iter().map(move |ctor| {\n-                                // Extends the witness with a \"wild\" version of this\n-                                // constructor, that matches everything that can be built with\n-                                // it. For example, if `ctor` is a `Constructor::Variant` for\n-                                // `Option::Some`, this pushes the witness for `Some(_)`.\n-                                witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                            })\n-                        }).collect()\n+                        let expensive_missing_ctors =\n+                            compute_missing_ctors(MissingCtorsInfo::Ctors, cx.tcx, &all_ctors,\n+                                                  &used_ctors);\n+                        if let MissingCtors::Ctors(missing_ctors) = expensive_missing_ctors {\n+                            pats.into_iter().flat_map(|witness| {\n+                                missing_ctors.iter().map(move |ctor| {\n+                                    // Extends the witness with a \"wild\" version of this\n+                                    // constructor, that matches everything that can be built with\n+                                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                                    // `Option::Some`, this pushes the witness for `Some(_)`.\n+                                    witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                                })\n+                            }).collect()\n+                        } else {\n+                            bug!(\"cheap missing ctors\")\n+                        }\n                     };\n                     UsefulWithWitness(new_witnesses)\n                 }"}]}