{"sha": "55ab0c602e391537f5e1a84a617fdd817e6a4200", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YWIwYzYwMmUzOTE1MzdmNWUxYTg0YTYxN2ZkZDgxN2U2YTQyMDA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T12:12:14Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T12:12:14Z"}, "message": "Merge #339\n\n339: Fix assertion error for literals with suffixes r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "3adb0077bd7d7a34376d87cbb0ae7ea5b942d532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3adb0077bd7d7a34376d87cbb0ae7ea5b942d532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55ab0c602e391537f5e1a84a617fdd817e6a4200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55ab0c602e391537f5e1a84a617fdd817e6a4200", "html_url": "https://github.com/rust-lang/rust/commit/55ab0c602e391537f5e1a84a617fdd817e6a4200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55ab0c602e391537f5e1a84a617fdd817e6a4200/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3", "html_url": "https://github.com/rust-lang/rust/commit/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3"}, {"sha": "49b0fe20ab6aa752df3764908b7c21f4b1827e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/49b0fe20ab6aa752df3764908b7c21f4b1827e52", "html_url": "https://github.com/rust-lang/rust/commit/49b0fe20ab6aa752df3764908b7c21f4b1827e52"}], "stats": {"total": 730, "additions": 354, "deletions": 376}, "files": [{"sha": "349733f3fbf8eac7c7aebf24c7cca6c49122ca84", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -1,13 +1,7 @@\n mod parser;\n-mod byte;\n-mod byte_string;\n-mod char;\n mod string;\n \n pub use self::{\n-    byte::parse_byte_literal,\n-    byte_string::parse_byte_string_literal,\n-    char::parse_char_literal,\n-    parser::{CharComponent, CharComponentKind, StringComponent, StringComponentKind},\n-    string::parse_string_literal,\n+    parser::{StringComponent, StringComponentKind},\n+    string::{parse_string_literal, parse_char_literal, parse_byte_literal, parse_byte_string_literal},\n };"}, {"sha": "b3228d6ca150da5f6faf8d81f8620abdead1cd70", "filename": "crates/ra_syntax/src/string_lexing/byte.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte.rs?ref=dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3", "patch": "@@ -1,51 +0,0 @@\n-use super::parser::Parser;\n-use super::CharComponent;\n-\n-pub fn parse_byte_literal(src: &str) -> ByteComponentIterator {\n-    ByteComponentIterator {\n-        parser: Parser::new(src),\n-        has_closing_quote: false,\n-    }\n-}\n-\n-pub struct ByteComponentIterator<'a> {\n-    parser: Parser<'a>,\n-    pub has_closing_quote: bool,\n-}\n-\n-impl<'a> Iterator for ByteComponentIterator<'a> {\n-    type Item = CharComponent;\n-    fn next(&mut self) -> Option<CharComponent> {\n-        if self.parser.pos == 0 {\n-            assert!(\n-                self.parser.advance() == 'b',\n-                \"Byte literal should start with a `b`\"\n-            );\n-\n-            assert!(\n-                self.parser.advance() == '\\'',\n-                \"Byte literal should start with a `b`, followed by a quote\"\n-            );\n-        }\n-\n-        if let Some(component) = self.parser.parse_char_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some('\\'') {\n-            self.parser.advance();\n-            self.has_closing_quote = true;\n-        }\n-\n-        assert!(\n-            self.parser.peek() == None,\n-            \"byte literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n-            self.parser.src,\n-            self.parser.pos,\n-            self.parser.src.len()\n-        );\n-\n-        None\n-    }\n-}"}, {"sha": "a6056159b266784113bf945c4a54073321bf259c", "filename": "crates/ra_syntax/src/string_lexing/byte_string.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte_string.rs?ref=dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3", "patch": "@@ -1,51 +0,0 @@\n-use super::parser::Parser;\n-use super::StringComponent;\n-\n-pub fn parse_byte_string_literal(src: &str) -> ByteStringComponentIterator {\n-    ByteStringComponentIterator {\n-        parser: Parser::new(src),\n-        has_closing_quote: false,\n-    }\n-}\n-\n-pub struct ByteStringComponentIterator<'a> {\n-    parser: Parser<'a>,\n-    pub has_closing_quote: bool,\n-}\n-\n-impl<'a> Iterator for ByteStringComponentIterator<'a> {\n-    type Item = StringComponent;\n-    fn next(&mut self) -> Option<StringComponent> {\n-        if self.parser.pos == 0 {\n-            assert!(\n-                self.parser.advance() == 'b',\n-                \"byte string literal should start with a `b`\"\n-            );\n-\n-            assert!(\n-                self.parser.advance() == '\"',\n-                \"byte string literal should start with a `b`, followed by double quotes\"\n-            );\n-        }\n-\n-        if let Some(component) = self.parser.parse_string_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some('\"') {\n-            self.parser.advance();\n-            self.has_closing_quote = true;\n-        }\n-\n-        assert!(\n-            self.parser.peek() == None,\n-            \"byte string literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n-            self.parser.src,\n-            self.parser.pos,\n-            self.parser.src.len()\n-        );\n-\n-        None\n-    }\n-}"}, {"sha": "e018131768ad82c1d28d65fae8d4c3fb89a0e3b4", "filename": "crates/ra_syntax/src/string_lexing/char.rs", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fchar.rs?ref=dbf03b674e7e1a49d9b32ec5ed656df2aedd3ed3", "patch": "@@ -1,176 +0,0 @@\n-use super::parser::Parser;\n-use super::CharComponent;\n-\n-pub fn parse_char_literal(src: &str) -> CharComponentIterator {\n-    CharComponentIterator {\n-        parser: Parser::new(src),\n-        has_closing_quote: false,\n-    }\n-}\n-\n-pub struct CharComponentIterator<'a> {\n-    parser: Parser<'a>,\n-    pub has_closing_quote: bool,\n-}\n-\n-impl<'a> Iterator for CharComponentIterator<'a> {\n-    type Item = CharComponent;\n-    fn next(&mut self) -> Option<CharComponent> {\n-        if self.parser.pos == 0 {\n-            assert!(\n-                self.parser.advance() == '\\'',\n-                \"char literal should start with a quote\"\n-            );\n-        }\n-\n-        if let Some(component) = self.parser.parse_char_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some('\\'') {\n-            self.parser.advance();\n-            self.has_closing_quote = true;\n-        }\n-\n-        assert!(\n-            self.parser.peek() == None,\n-            \"char literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n-            self.parser.src,\n-            self.parser.pos,\n-            self.parser.src.len()\n-        );\n-\n-        None\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use rowan::TextRange;\n-    use crate::string_lexing::{\n-        CharComponent,\n-        CharComponentKind::*,\n-};\n-\n-    fn parse(src: &str) -> (bool, Vec<CharComponent>) {\n-        let component_iterator = &mut super::parse_char_literal(src);\n-        let components: Vec<_> = component_iterator.collect();\n-        (component_iterator.has_closing_quote, components)\n-    }\n-\n-    fn unclosed_char_component(src: &str) -> CharComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(!has_closing_quote, \"char should not have closing quote\");\n-        assert!(components.len() == 1);\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_component(src: &str) -> CharComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(\n-            components.len() == 1,\n-            \"Literal: {}\\nComponents: {:#?}\",\n-            src,\n-            components\n-        );\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_components(src: &str) -> Vec<CharComponent> {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        components\n-    }\n-\n-    fn range_closed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n-    }\n-\n-    fn range_unclosed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32).into())\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes() {\n-        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = closed_char_component(&escape_sequence);\n-            let expected_range = range_closed(&escape_sequence);\n-            assert_eq!(component.kind, UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes_unclosed() {\n-        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = unclosed_char_component(&escape_sequence);\n-            let expected_range = range_unclosed(&escape_sequence);\n-            assert_eq!(component.kind, UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_empty_char() {\n-        let (has_closing_quote, components) = parse(\"''\");\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(components.len() == 0);\n-    }\n-\n-    #[test]\n-    fn test_unclosed_char() {\n-        let component = unclosed_char_component(\"'a\");\n-        assert!(component.kind == CodePoint);\n-        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n-    }\n-\n-    #[test]\n-    fn test_digit_escapes() {\n-        let literals = &[r\"\", r\"5\", r\"55\"];\n-\n-        for literal in literals {\n-            let lit_text = format!(r\"'\\x{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == AsciiCodeEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-\n-        // More than 2 digits starts a new codepoint\n-        let components = closed_char_components(r\"'\\x555'\");\n-        assert!(components.len() == 2);\n-        assert!(components[1].kind == CodePoint);\n-    }\n-\n-    #[test]\n-    fn test_ascii_escapes() {\n-        let literals = &[\n-            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n-            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n-        ];\n-\n-        for literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == AsciiEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_no_escapes() {\n-        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n-\n-        for &literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == CodePoint);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-}"}, {"sha": "14c6015c2a9168d1e245a84c05587b4a6a3b586a", "filename": "crates/ra_syntax/src/string_lexing/parser.rs", "status": "modified", "additions": 32, "deletions": 60, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -1,15 +1,16 @@\n use rowan::{TextRange, TextUnit};\n \n-use self::CharComponentKind::*;\n+use self::StringComponentKind::*;\n \n pub struct Parser<'a> {\n+    pub(super) quote: u8,\n     pub(super) src: &'a str,\n     pub(super) pos: usize,\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(src: &'a str) -> Parser<'a> {\n-        Parser { src, pos: 0 }\n+    pub fn new(src: &'a str, quote: u8) -> Parser<'a> {\n+        Parser { quote, src, pos: 0 }\n     }\n \n     // Utility methods\n@@ -42,7 +43,7 @@ impl<'a> Parser<'a> {\n \n     // Char parsing methods\n \n-    fn parse_unicode_escape(&mut self, start: TextUnit) -> CharComponent {\n+    fn parse_unicode_escape(&mut self, start: TextUnit) -> StringComponent {\n         match self.peek() {\n             Some('{') => {\n                 self.advance();\n@@ -56,16 +57,16 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let end = self.get_pos();\n-                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n+                StringComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n             }\n             Some(_) | None => {\n                 let end = self.get_pos();\n-                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n+                StringComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n             }\n         }\n     }\n \n-    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> CharComponent {\n+    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> StringComponent {\n         let code_start = self.get_pos();\n         while let Some(next) = self.peek() {\n             if next == '\\'' || (self.get_pos() - code_start == 2.into()) {\n@@ -76,12 +77,12 @@ impl<'a> Parser<'a> {\n         }\n \n         let end = self.get_pos();\n-        CharComponent::new(TextRange::from_to(start, end), AsciiCodeEscape)\n+        StringComponent::new(TextRange::from_to(start, end), AsciiCodeEscape)\n     }\n \n-    fn parse_escape(&mut self, start: TextUnit) -> CharComponent {\n+    fn parse_escape(&mut self, start: TextUnit) -> StringComponent {\n         if self.peek().is_none() {\n-            return CharComponent::new(TextRange::from_to(start, start), AsciiEscape);\n+            return StringComponent::new(TextRange::from_to(start, start), AsciiEscape);\n         }\n \n         let next = self.advance();\n@@ -90,29 +91,7 @@ impl<'a> Parser<'a> {\n         match next {\n             'x' => self.parse_ascii_code_escape(start),\n             'u' => self.parse_unicode_escape(start),\n-            _ => CharComponent::new(range, AsciiEscape),\n-        }\n-    }\n-\n-    pub fn parse_char_component(&mut self) -> Option<CharComponent> {\n-        let next = self.peek()?;\n-\n-        // Ignore character close\n-        if next == '\\'' {\n-            return None;\n-        }\n-\n-        let start = self.get_pos();\n-        self.advance();\n-\n-        if next == '\\\\' {\n-            Some(self.parse_escape(start))\n-        } else {\n-            let end = self.get_pos();\n-            Some(CharComponent::new(\n-                TextRange::from_to(start, end),\n-                CodePoint,\n-            ))\n+            _ => StringComponent::new(range, AsciiEscape),\n         }\n     }\n \n@@ -131,11 +110,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_string_component(&mut self) -> Option<StringComponent> {\n+    pub fn parse_component(&mut self) -> Option<StringComponent> {\n         let next = self.peek()?;\n \n         // Ignore string close\n-        if next == '\"' {\n+        if next == self.quote as char {\n             return None;\n         }\n \n@@ -145,21 +124,31 @@ impl<'a> Parser<'a> {\n         if next == '\\\\' {\n             // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n             // before falling back to parsing char escapes\n-            self.parse_ignore_newline(start).or_else(|| {\n-                let char_component = self.parse_escape(start);\n-                Some(StringComponent::new(\n-                    char_component.range,\n-                    StringComponentKind::Char(char_component.kind),\n-                ))\n-            })\n+            if self.quote == b'\"' {\n+                if let Some(component) = self.parse_ignore_newline(start) {\n+                    return Some(component);\n+                }\n+            }\n+\n+            Some(self.parse_escape(start))\n         } else {\n             let end = self.get_pos();\n             Some(StringComponent::new(\n                 TextRange::from_to(start, end),\n-                StringComponentKind::Char(CodePoint),\n+                CodePoint,\n             ))\n         }\n     }\n+\n+    pub fn parse_suffix(&mut self) -> Option<TextRange> {\n+        let start = self.get_pos();\n+        let _ = self.peek()?;\n+        while let Some(_) = self.peek() {\n+            self.advance();\n+        }\n+        let end = self.get_pos();\n+        Some(TextRange::from_to(start, end))\n+    }\n }\n \n #[derive(Debug, Eq, PartialEq, Clone)]\n@@ -177,23 +166,6 @@ impl StringComponent {\n #[derive(Debug, Eq, PartialEq, Clone)]\n pub enum StringComponentKind {\n     IgnoreNewline,\n-    Char(CharComponentKind),\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub struct CharComponent {\n-    pub range: TextRange,\n-    pub kind: CharComponentKind,\n-}\n-\n-impl CharComponent {\n-    fn new(range: TextRange, kind: CharComponentKind) -> CharComponent {\n-        CharComponent { range, kind }\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub enum CharComponentKind {\n     CodePoint,\n     AsciiEscape,\n     AsciiCodeEscape,"}, {"sha": "064f085447fef857552f03c9a6b204295dd5c74c", "filename": "crates/ra_syntax/src/string_lexing/string.rs", "status": "modified", "additions": 189, "deletions": 8, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -1,41 +1,92 @@\n-use super::parser::Parser;\n-use super::StringComponent;\n+use crate::{\n+    TextRange,\n+    string_lexing::{\n+    parser::Parser,\n+    StringComponent,\n+}};\n \n pub fn parse_string_literal(src: &str) -> StringComponentIterator {\n     StringComponentIterator {\n-        parser: Parser::new(src),\n+        parser: Parser::new(src, b'\"'),\n         has_closing_quote: false,\n+        suffix: None,\n+        prefix: None,\n+        quote: b'\"',\n+    }\n+}\n+\n+pub fn parse_byte_string_literal(src: &str) -> StringComponentIterator {\n+    StringComponentIterator {\n+        parser: Parser::new(src, b'\"'),\n+        has_closing_quote: false,\n+        suffix: None,\n+        prefix: Some(b'b'),\n+        quote: b'\"',\n+    }\n+}\n+\n+pub fn parse_char_literal(src: &str) -> StringComponentIterator {\n+    StringComponentIterator {\n+        parser: Parser::new(src, b'\\''),\n+        has_closing_quote: false,\n+        suffix: None,\n+        prefix: None,\n+        quote: b'\\'',\n+    }\n+}\n+\n+pub fn parse_byte_literal(src: &str) -> StringComponentIterator {\n+    StringComponentIterator {\n+        parser: Parser::new(src, b'\\''),\n+        has_closing_quote: false,\n+        suffix: None,\n+        prefix: Some(b'b'),\n+        quote: b'\\'',\n     }\n }\n \n pub struct StringComponentIterator<'a> {\n     parser: Parser<'a>,\n     pub has_closing_quote: bool,\n+    pub suffix: Option<TextRange>,\n+    prefix: Option<u8>,\n+    quote: u8,\n }\n \n impl<'a> Iterator for StringComponentIterator<'a> {\n     type Item = StringComponent;\n     fn next(&mut self) -> Option<StringComponent> {\n         if self.parser.pos == 0 {\n+            if let Some(prefix) = self.prefix {\n+                assert!(\n+                    self.parser.advance() == prefix as char,\n+                    \"literal should start with a {:?}\",\n+                    prefix as char,\n+                );\n+            }\n             assert!(\n-                self.parser.advance() == '\"',\n-                \"string literal should start with double quotes\"\n+                self.parser.advance() == self.quote as char,\n+                \"literal should start with a {:?}\",\n+                self.quote as char,\n             );\n         }\n \n-        if let Some(component) = self.parser.parse_string_component() {\n+        if let Some(component) = self.parser.parse_component() {\n             return Some(component);\n         }\n \n         // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some('\"') {\n+        if self.parser.peek() == Some(self.quote as char) {\n             self.parser.advance();\n             self.has_closing_quote = true;\n+            if let Some(range) = self.parser.parse_suffix() {\n+                self.suffix = Some(range);\n+            }\n         }\n \n         assert!(\n             self.parser.peek() == None,\n-            \"string literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n+            \"literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n             self.parser.src,\n             self.parser.pos,\n             self.parser.src.len()\n@@ -44,3 +95,133 @@ impl<'a> Iterator for StringComponentIterator<'a> {\n         None\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use rowan::TextRange;\n+    use crate::string_lexing::{\n+        StringComponent,\n+        StringComponentKind::*,\n+};\n+\n+    fn parse(src: &str) -> (bool, Vec<StringComponent>) {\n+        let component_iterator = &mut super::parse_char_literal(src);\n+        let components: Vec<_> = component_iterator.collect();\n+        (component_iterator.has_closing_quote, components)\n+    }\n+\n+    fn unclosed_char_component(src: &str) -> StringComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(!has_closing_quote, \"char should not have closing quote\");\n+        assert!(components.len() == 1);\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_component(src: &str) -> StringComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(\n+            components.len() == 1,\n+            \"Literal: {}\\nComponents: {:#?}\",\n+            src,\n+            components\n+        );\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_components(src: &str) -> Vec<StringComponent> {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        components\n+    }\n+\n+    fn range_closed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n+    }\n+\n+    fn range_unclosed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32).into())\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes() {\n+        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = closed_char_component(&escape_sequence);\n+            let expected_range = range_closed(&escape_sequence);\n+            assert_eq!(component.kind, UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes_unclosed() {\n+        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = unclosed_char_component(&escape_sequence);\n+            let expected_range = range_unclosed(&escape_sequence);\n+            assert_eq!(component.kind, UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_empty_char() {\n+        let (has_closing_quote, components) = parse(\"''\");\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(components.len() == 0);\n+    }\n+\n+    #[test]\n+    fn test_unclosed_char() {\n+        let component = unclosed_char_component(\"'a\");\n+        assert!(component.kind == CodePoint);\n+        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n+    }\n+\n+    #[test]\n+    fn test_digit_escapes() {\n+        let literals = &[r\"\", r\"5\", r\"55\"];\n+\n+        for literal in literals {\n+            let lit_text = format!(r\"'\\x{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == AsciiCodeEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+\n+        // More than 2 digits starts a new codepoint\n+        let components = closed_char_components(r\"'\\x555'\");\n+        assert!(components.len() == 2);\n+        assert!(components[1].kind == CodePoint);\n+    }\n+\n+    #[test]\n+    fn test_ascii_escapes() {\n+        let literals = &[\n+            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n+            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n+        ];\n+\n+        for literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == AsciiEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_no_escapes() {\n+        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n+\n+        for &literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == CodePoint);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+}"}, {"sha": "0a2b6afbc785ee496016d35a3d6fb84bd68b7f48", "filename": "crates/ra_syntax/src/utils.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -1,10 +1,13 @@\n-use crate::{SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent};\n+use crate::{SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent, AstNode};\n use std::fmt::Write;\n use std::str;\n \n /// Parse a file and create a string representation of the resulting parse tree.\n pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n-    let mut errors: Vec<_> = syntax.root_data().to_vec();\n+    let mut errors: Vec<_> = match syntax.ancestors().find_map(SourceFileNode::cast) {\n+        Some(file) => file.owned().errors(),\n+        None => syntax.root_data().to_vec(),\n+    };\n     errors.sort_by_key(|e| e.offset());\n     let mut err_pos = 0;\n     let mut level = 0;"}, {"sha": "d0897eeedb6f9d4bca775421e1d4c0c70cdd1e16", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -2,7 +2,7 @@\n \n use crate::{\n     ast::{self, AstNode},\n-    string_lexing::{self, CharComponentKind},\n+    string_lexing::{self, StringComponentKind},\n     TextRange,\n     validation::char,\n     yellow::{\n@@ -27,6 +27,13 @@ pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>)\n         errors.push(SyntaxError::new(UnclosedByte, literal_range));\n     }\n \n+    if let Some(range) = components.suffix {\n+        errors.push(SyntaxError::new(\n+            InvalidSuffix,\n+            range + literal_range.start(),\n+        ));\n+    }\n+\n     if len == 0 {\n         errors.push(SyntaxError::new(EmptyByte, literal_range));\n     }\n@@ -38,11 +45,11 @@ pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>)\n \n pub(super) fn validate_byte_component(\n     text: &str,\n-    kind: CharComponentKind,\n+    kind: StringComponentKind,\n     range: TextRange,\n     errors: &mut Vec<SyntaxError>,\n ) {\n-    use self::CharComponentKind::*;\n+    use self::StringComponentKind::*;\n     match kind {\n         AsciiEscape => validate_byte_escape(text, range, errors),\n         AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n@@ -63,6 +70,7 @@ pub(super) fn validate_byte_component(\n                 errors.push(SyntaxError::new(ByteOutOfRange, range));\n             }\n         }\n+        IgnoreNewline => { /* always valid */ }\n     }\n }\n "}, {"sha": "f7a4fb156af3ef77d0ff58d1532877c5d7b75feb", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -17,21 +17,28 @@ pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<\n         let range = component.range + literal_range.start();\n \n         match component.kind {\n-            StringComponentKind::Char(kind) => {\n+            StringComponentKind::IgnoreNewline => { /* always valid */ }\n+            _ => {\n                 // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n                 let text = &literal_text[component.range];\n                 match text {\n                     \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n-                    _ => byte::validate_byte_component(text, kind, range, errors),\n+                    _ => byte::validate_byte_component(text, component.kind, range, errors),\n                 }\n             }\n-            StringComponentKind::IgnoreNewline => { /* always valid */ }\n         }\n     }\n \n     if !components.has_closing_quote {\n         errors.push(SyntaxError::new(UnclosedString, literal_range));\n     }\n+\n+    if let Some(range) = components.suffix {\n+        errors.push(SyntaxError::new(\n+            InvalidSuffix,\n+            range + literal_range.start(),\n+        ));\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "19cd3830f09a57f4a5ff95b3f890a77d89434d48", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -6,7 +6,7 @@ use arrayvec::ArrayString;\n \n use crate::{\n     ast::{self, AstNode},\n-    string_lexing::{self, CharComponentKind},\n+    string_lexing::{self, StringComponentKind},\n     TextRange,\n     yellow::{\n         SyntaxError,\n@@ -30,6 +30,13 @@ pub(super) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>)\n         errors.push(SyntaxError::new(UnclosedChar, literal_range));\n     }\n \n+    if let Some(range) = components.suffix {\n+        errors.push(SyntaxError::new(\n+            InvalidSuffix,\n+            range + literal_range.start(),\n+        ));\n+    }\n+\n     if len == 0 {\n         errors.push(SyntaxError::new(EmptyChar, literal_range));\n     }\n@@ -41,12 +48,12 @@ pub(super) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>)\n \n pub(super) fn validate_char_component(\n     text: &str,\n-    kind: CharComponentKind,\n+    kind: StringComponentKind,\n     range: TextRange,\n     errors: &mut Vec<SyntaxError>,\n ) {\n     // Validate escapes\n-    use self::CharComponentKind::*;\n+    use self::StringComponentKind::*;\n     match kind {\n         AsciiEscape => validate_ascii_escape(text, range, errors),\n         AsciiCodeEscape => validate_ascii_code_escape(text, range, errors),\n@@ -57,6 +64,7 @@ pub(super) fn validate_char_component(\n                 errors.push(SyntaxError::new(UnescapedCodepoint, range));\n             }\n         }\n+        StringComponentKind::IgnoreNewline => { /* always valid */ }\n     }\n }\n "}, {"sha": "1371bb1f0d5ac0af7487b9f3bde6d94a6f6e64b7", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -1,6 +1,6 @@\n use crate::{\n     ast::{self, AstNode},\n-    string_lexing::{self, StringComponentKind},\n+    string_lexing,\n     yellow::{\n         SyntaxError,\n         SyntaxErrorKind::*,\n@@ -16,22 +16,24 @@ pub(crate) fn validate_string_node(node: ast::String, errors: &mut Vec<SyntaxErr\n     for component in &mut components {\n         let range = component.range + literal_range.start();\n \n-        match component.kind {\n-            StringComponentKind::Char(kind) => {\n-                // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n-                let text = &literal_text[component.range];\n-                match text {\n-                    \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n-                    _ => char::validate_char_component(text, kind, range, errors),\n-                }\n-            }\n-            StringComponentKind::IgnoreNewline => { /* always valid */ }\n+        // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n+        let text = &literal_text[component.range];\n+        match text {\n+            \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n+            _ => char::validate_char_component(text, component.kind, range, errors),\n         }\n     }\n \n     if !components.has_closing_quote {\n         errors.push(SyntaxError::new(UnclosedString, literal_range));\n     }\n+\n+    if let Some(range) = components.suffix {\n+        errors.push(SyntaxError::new(\n+            InvalidSuffix,\n+            range + literal_range.start(),\n+        ));\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "534f3511e3f05a022fbdcb67cee75932dafd9f35", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -93,6 +93,7 @@ pub enum SyntaxErrorKind {\n     OverlongUnicodeEscape,\n     UnicodeEscapeOutOfRange,\n     UnclosedString,\n+    InvalidSuffix,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -134,6 +135,7 @@ impl fmt::Display for SyntaxErrorKind {\n             }\n             UnicodeEscapeOutOfRange => write!(f, \"Unicode escape code should be at most 0x10FFFF\"),\n             UnclosedString => write!(f, \"Unclosed string literal\"),\n+            InvalidSuffix => write!(f, \"Invalid literal suffix\"),\n             ParseError(msg) => write!(f, \"{}\", msg.0),\n         }\n     }"}, {"sha": "261aad1fb6b402f13d3a192bebcef9d28e963ea8", "filename": "crates/ra_syntax/tests/data/parser/err/0030_string_suffixes.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.rs?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let _ = 'c'u32;\n+    let _ = \"string\"invalid;\n+    let _ = b'b'_suff;\n+    let _ = b\"bs\"invalid;\n+}"}, {"sha": "dc10e9ee7d7594d8dd22dd7b96b1c30c515c3e7a", "filename": "crates/ra_syntax/tests/data/parser/err/0030_string_suffixes.txt", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/55ab0c602e391537f5e1a84a617fdd817e6a4200/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0030_string_suffixes.txt?ref=55ab0c602e391537f5e1a84a617fdd817e6a4200", "patch": "@@ -0,0 +1,73 @@\n+SOURCE_FILE@[0; 112)\n+  FN_DEF@[0; 111)\n+    FN_KW@[0; 2)\n+    WHITESPACE@[2; 3)\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"main\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8)\n+      R_PAREN@[8; 9)\n+    WHITESPACE@[9; 10)\n+    BLOCK@[10; 111)\n+      L_CURLY@[10; 11)\n+      WHITESPACE@[11; 16)\n+      LET_STMT@[16; 27)\n+        LET_KW@[16; 19)\n+        WHITESPACE@[19; 20)\n+        PLACEHOLDER_PAT@[20; 21)\n+          UNDERSCORE@[20; 21)\n+        WHITESPACE@[21; 22)\n+        EQ@[22; 23)\n+        WHITESPACE@[23; 24)\n+        LITERAL@[24; 27)\n+          CHAR@[24; 27)\n+          err: `expected SEMI`\n+      EXPR_STMT@[27; 31)\n+        PATH_EXPR@[27; 30)\n+          PATH@[27; 30)\n+            PATH_SEGMENT@[27; 30)\n+              NAME_REF@[27; 30)\n+                IDENT@[27; 30) \"u32\"\n+        SEMI@[30; 31)\n+      WHITESPACE@[31; 36)\n+      LET_STMT@[36; 60)\n+        LET_KW@[36; 39)\n+        WHITESPACE@[39; 40)\n+        PLACEHOLDER_PAT@[40; 41)\n+          UNDERSCORE@[40; 41)\n+        WHITESPACE@[41; 42)\n+        EQ@[42; 43)\n+        WHITESPACE@[43; 44)\n+        LITERAL@[44; 59)\n+          STRING@[44; 59)\n+          err: `Invalid literal suffix`\n+        SEMI@[59; 60)\n+      WHITESPACE@[60; 65)\n+      LET_STMT@[65; 83)\n+        LET_KW@[65; 68)\n+        WHITESPACE@[68; 69)\n+        PLACEHOLDER_PAT@[69; 70)\n+          UNDERSCORE@[69; 70)\n+        WHITESPACE@[70; 71)\n+        EQ@[71; 72)\n+        WHITESPACE@[72; 73)\n+        LITERAL@[73; 82)\n+          BYTE@[73; 82)\n+          err: `Invalid literal suffix`\n+        SEMI@[82; 83)\n+      WHITESPACE@[83; 88)\n+      LET_STMT@[88; 109)\n+        LET_KW@[88; 91)\n+        WHITESPACE@[91; 92)\n+        PLACEHOLDER_PAT@[92; 93)\n+          UNDERSCORE@[92; 93)\n+        WHITESPACE@[93; 94)\n+        EQ@[94; 95)\n+        WHITESPACE@[95; 96)\n+        LITERAL@[96; 108)\n+          BYTE_STRING@[96; 108)\n+          err: `Invalid literal suffix`\n+        SEMI@[108; 109)\n+      WHITESPACE@[109; 110)\n+      R_CURLY@[110; 111)\n+  WHITESPACE@[111; 112)"}]}