{"sha": "4b1cb73f1d45f69e0f00a66754616c61b3166c47", "node_id": "C_kwDOAAsO6NoAKDRiMWNiNzNmMWQ0NWY2OWUwZjAwYTY2NzU0NjE2YzYxYjMxNjZjNDc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-05T20:12:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-05T20:12:29Z"}, "message": "Rollup merge of #90597 - nikomatsakis:issue-90465, r=wesleywiser\n\nWarn for variables that are no longer captured\n\nr? `@wesleywiser`\n\ncc `@rust-lang/wg-rfc-2229`\n\nFixes #90465", "tree": {"sha": "632561a633bf777153b09edc77c30ca35208879d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/632561a633bf777153b09edc77c30ca35208879d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b1cb73f1d45f69e0f00a66754616c61b3166c47", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhhZAtCRBK7hj4Ov3rIwAAUPUIADfd2ykIMl7i1yR14ZTobFjj\nmi8wUUwJElF6LiZUUZunvJ2FTtkvAxSozgU3X4r2jIoa/35ELkHzGTuJxbxcIhaJ\n29a6X6AUpqGmj90Ztcm5DLTf8SjjtCvd+d33lIsHhieMD8Iieh4wOw6+dk/BseD9\n7abwhoICcM15N3I9xWkrZNXIjIKs2ISjYqQh5LVGgdhnxnU/7u0WMJcnfvrm9m2H\nT7YQTrWTOvU7A7oo1laREGRSiayNucUnROkCSdhUDhLtGtzyPvw7RtwqTjxdpvN/\n+Kcz/ZgGDAdF4y6gDBJpPfJtNte4Qju+VmA+SoWTqI89KxH3rtESBEhIpt+i0vo=\n=Kgwf\n-----END PGP SIGNATURE-----\n", "payload": "tree 632561a633bf777153b09edc77c30ca35208879d\nparent cd24ffb266c84ec195c10a76f0889edb84adf4a2\nparent 4154e8acf045a13bf57bc9b3c487f838f17230c8\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1636143149 +0100\ncommitter GitHub <noreply@github.com> 1636143149 +0100\n\nRollup merge of #90597 - nikomatsakis:issue-90465, r=wesleywiser\n\nWarn for variables that are no longer captured\n\nr? `@wesleywiser`\n\ncc `@rust-lang/wg-rfc-2229`\n\nFixes #90465\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1cb73f1d45f69e0f00a66754616c61b3166c47", "html_url": "https://github.com/rust-lang/rust/commit/4b1cb73f1d45f69e0f00a66754616c61b3166c47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b1cb73f1d45f69e0f00a66754616c61b3166c47/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd24ffb266c84ec195c10a76f0889edb84adf4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd24ffb266c84ec195c10a76f0889edb84adf4a2", "html_url": "https://github.com/rust-lang/rust/commit/cd24ffb266c84ec195c10a76f0889edb84adf4a2"}, {"sha": "4154e8acf045a13bf57bc9b3c487f838f17230c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4154e8acf045a13bf57bc9b3c487f838f17230c8", "html_url": "https://github.com/rust-lang/rust/commit/4154e8acf045a13bf57bc9b3c487f838f17230c8"}], "stats": {"total": 475, "additions": 328, "deletions": 147}, "files": [{"sha": "774d8078e52ca31171213b8070848902040aae07", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 153, "deletions": 78, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -86,18 +86,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Intermediate format to store the hir_id pointing to the use that resulted in the\n /// corresponding place being captured and a String which contains the captured value's\n /// name (i.e: a.b.c)\n-type CapturesInfo = (Option<hir::HirId>, String);\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+enum UpvarMigrationInfo {\n+    /// We previously captured all of `x`, but now we capture some sub-path.\n+    CapturingPrecise { source_expr: Option<hir::HirId>, var_name: String },\n+    CapturingNothing {\n+        // where the variable appears in the closure (but is not captured)\n+        use_span: Span,\n+    },\n+}\n+\n+/// Reasons that we might issue a migration warning.\n+#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+struct MigrationWarningReason {\n+    /// When we used to capture `x` in its entirety, we implemented the auto-trait(s)\n+    /// in this vec, but now we don't.\n+    auto_traits: Vec<&'static str>,\n+\n+    /// When we used to capture `x` in its entirety, we would execute some destructors\n+    /// at a different time.\n+    drop_order: bool,\n+}\n+\n+impl MigrationWarningReason {\n+    fn migration_message(&self) -> String {\n+        let base = \"changes to closure capture in Rust 2021 will affect\";\n+        if !self.auto_traits.is_empty() && self.drop_order {\n+            format!(\"{} drop order and which traits the closure implements\", base)\n+        } else if self.drop_order {\n+            format!(\"{} drop order\", base)\n+        } else {\n+            format!(\"{} which traits the closure implements\", base)\n+        }\n+    }\n+}\n \n-/// Intermediate format to store information needed to generate migration lint. The tuple\n-/// contains the hir_id pointing to the use that resulted in the\n-/// corresponding place being captured, a String which contains the captured value's\n-/// name (i.e: a.b.c) and a String which contains the reason why migration is needed for that\n-/// capture\n-type MigrationNeededForCapture = (Option<hir::HirId>, String, String);\n+/// Intermediate format to store information needed to generate a note in the migration lint.\n+struct MigrationLintNote {\n+    captures_info: UpvarMigrationInfo,\n+\n+    /// reasons why migration is needed for this capture\n+    reason: MigrationWarningReason,\n+}\n \n /// Intermediate format to store the hir id of the root variable and a HashSet containing\n /// information on why the root variable should be fully captured\n-type MigrationDiagnosticInfo = (hir::HirId, Vec<MigrationNeededForCapture>);\n+struct NeededMigration {\n+    var_hir_id: hir::HirId,\n+    diagnostics_info: Vec<MigrationLintNote>,\n+}\n \n struct InferBorrowKindVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -707,47 +744,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                  closure_head_span,\n                 |lint| {\n                     let mut diagnostics_builder = lint.build(\n-                        format!(\n-                            \"changes to closure capture in Rust 2021 will affect {}\",\n-                            reasons\n-                        )\n-                        .as_str(),\n+                        &reasons.migration_message(),\n                     );\n-                    for (var_hir_id, diagnostics_info) in need_migrations.iter() {\n+                    for NeededMigration { var_hir_id, diagnostics_info } in &need_migrations {\n                         // Labels all the usage of the captured variable and why they are responsible\n                         // for migration being needed\n-                        for (captured_hir_id, captured_name, reasons) in diagnostics_info.iter() {\n-                            if let Some(captured_hir_id) = captured_hir_id {\n-                                let cause_span = self.tcx.hir().span(*captured_hir_id);\n-                                diagnostics_builder.span_label(cause_span, format!(\"in Rust 2018, this closure captures all of `{}`, but in Rust 2021, it will only capture `{}`\",\n-                                    self.tcx.hir().name(*var_hir_id),\n-                                    captured_name,\n-                                ));\n+                        for lint_note in diagnostics_info.iter() {\n+                            match &lint_note.captures_info {\n+                                UpvarMigrationInfo::CapturingPrecise { source_expr: Some(capture_expr_id), var_name: captured_name } => {\n+                                    let cause_span = self.tcx.hir().span(*capture_expr_id);\n+                                    diagnostics_builder.span_label(cause_span, format!(\"in Rust 2018, this closure captures all of `{}`, but in Rust 2021, it will only capture `{}`\",\n+                                        self.tcx.hir().name(*var_hir_id),\n+                                        captured_name,\n+                                    ));\n+                                }\n+                                UpvarMigrationInfo::CapturingNothing { use_span } => {\n+                                    diagnostics_builder.span_label(*use_span, format!(\"in Rust 2018, this causes the closure to capture `{}`, but in Rust 2021, it has no effect\",\n+                                        self.tcx.hir().name(*var_hir_id),\n+                                    ));\n+                                }\n+\n+                                _ => { }\n                             }\n \n                             // Add a label pointing to where a captured variable affected by drop order\n                             // is dropped\n-                            if reasons.contains(\"drop order\") {\n+                            if lint_note.reason.drop_order {\n                                 let drop_location_span = drop_location_span(self.tcx, &closure_hir_id);\n \n-                                diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{}` is dropped here, but in Rust 2021, only `{}` will be dropped here as part of the closure\",\n-                                    self.tcx.hir().name(*var_hir_id),\n-                                    captured_name,\n-                                ));\n+                                match &lint_note.captures_info {\n+                                    UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n+                                        diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{}` is dropped here, but in Rust 2021, only `{}` will be dropped here as part of the closure\",\n+                                            self.tcx.hir().name(*var_hir_id),\n+                                            captured_name,\n+                                        ));\n+                                    }\n+                                    UpvarMigrationInfo::CapturingNothing { use_span: _ } => {\n+                                        diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{v}` is dropped here along with the closure, but in Rust 2021 `{v}` is not part of the closure\",\n+                                            v = self.tcx.hir().name(*var_hir_id),\n+                                        ));\n+                                    }\n+                                }\n                             }\n \n                             // Add a label explaining why a closure no longer implements a trait\n-                            if reasons.contains(\"trait implementation\") {\n-                                let missing_trait = &reasons[..reasons.find(\"trait implementation\").unwrap() - 1];\n-\n-                                diagnostics_builder.span_label(closure_head_span, format!(\"in Rust 2018, this closure implements {} as `{}` implements {}, but in Rust 2021, this closure will no longer implement {} as `{}` does not implement {}\",\n-                                    missing_trait,\n-                                    self.tcx.hir().name(*var_hir_id),\n-                                    missing_trait,\n-                                    missing_trait,\n-                                    captured_name,\n-                                    missing_trait,\n-                                ));\n+                            for &missing_trait in &lint_note.reason.auto_traits {\n+                                // not capturing something anymore cannot cause a trait to fail to be implemented:\n+                                match &lint_note.captures_info {\n+                                    UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n+                                        let var_name = self.tcx.hir().name(*var_hir_id);\n+                                        diagnostics_builder.span_label(closure_head_span, format!(\"\\\n+                                        in Rust 2018, this closure implements {missing_trait} \\\n+                                        as `{var_name}` implements {missing_trait}, but in Rust 2021, \\\n+                                        this closure will no longer implement {missing_trait} \\\n+                                        because `{var_name}` is not fully captured \\\n+                                        and `{captured_name}` does not implement {missing_trait}\"));\n+                                    }\n+\n+                                    // Cannot happen: if we don't capture a variable, we impl strictly more traits\n+                                    UpvarMigrationInfo::CapturingNothing { use_span } => span_bug!(*use_span, \"missing trait from not capturing something\"),\n+                                }\n                             }\n                         }\n                     }\n@@ -840,25 +896,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Combines all the reasons for 2229 migrations\n     fn compute_2229_migrations_reasons(\n         &self,\n-        auto_trait_reasons: FxHashSet<&str>,\n-        drop_reason: bool,\n-    ) -> String {\n-        let mut reasons = String::new();\n-\n-        if !auto_trait_reasons.is_empty() {\n-            reasons = format!(\n-                \"{} trait implementation for closure\",\n-                auto_trait_reasons.clone().into_iter().collect::<Vec<&str>>().join(\", \")\n-            );\n-        }\n+        auto_trait_reasons: FxHashSet<&'static str>,\n+        drop_order: bool,\n+    ) -> MigrationWarningReason {\n+        let mut reasons = MigrationWarningReason::default();\n \n-        if !auto_trait_reasons.is_empty() && drop_reason {\n-            reasons = format!(\"{} and \", reasons);\n+        for auto_trait in auto_trait_reasons {\n+            reasons.auto_traits.push(auto_trait);\n         }\n \n-        if drop_reason {\n-            reasons = format!(\"{}drop order\", reasons);\n-        }\n+        reasons.drop_order = drop_order;\n \n         reasons\n     }\n@@ -874,7 +921,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         var_hir_id: hir::HirId,\n         closure_clause: hir::CaptureBy,\n-    ) -> Option<FxHashMap<CapturesInfo, FxHashSet<&str>>> {\n+    ) -> Option<FxHashMap<UpvarMigrationInfo, FxHashSet<&'static str>>> {\n         let auto_traits_def_id = vec![\n             self.tcx.lang_items().clone_trait(),\n             self.tcx.lang_items().sync_trait(),\n@@ -963,7 +1010,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             if !capture_problems.is_empty() {\n                 problematic_captures.insert(\n-                    (capture.info.path_expr_id, capture.to_string(self.tcx)),\n+                    UpvarMigrationInfo::CapturingPrecise {\n+                        source_expr: capture.info.path_expr_id,\n+                        var_name: capture.to_string(self.tcx),\n+                    },\n                     capture_problems,\n                 );\n             }\n@@ -986,32 +1036,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// This function only returns a HashSet of CapturesInfo for significant drops. If there\n     /// are no significant drops than None is returned\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations_for_drop(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n-    ) -> Option<FxHashSet<CapturesInfo>> {\n+    ) -> Option<FxHashSet<UpvarMigrationInfo>> {\n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+            debug!(\"does not have significant drop\");\n             return None;\n         }\n \n         let Some(root_var_min_capture_list) = min_captures.and_then(|m| m.get(&var_hir_id)) else {\n             // The upvar is mentioned within the closure but no path starting from it is\n-            // used.\n+            // used. This occurs when you have (e.g.)\n+            //\n+            // ```\n+            // let x = move || {\n+            //     let _ = y;\n+            // });\n+            // ```\n+            debug!(\"no path starting from it is used\");\n+\n \n             match closure_clause {\n                 // Only migrate if closure is a move closure\n-                hir::CaptureBy::Value => return Some(FxHashSet::default()),\n+                hir::CaptureBy::Value => {\n+                    let mut diagnostics_info = FxHashSet::default();\n+                    let upvars = self.tcx.upvars_mentioned(closure_def_id).expect(\"must be an upvar\");\n+                    let upvar = upvars[&var_hir_id];\n+                    diagnostics_info.insert(UpvarMigrationInfo::CapturingNothing { use_span: upvar.span });\n+                    return Some(diagnostics_info);\n+                }\n                 hir::CaptureBy::Ref => {}\n             }\n \n             return None;\n         };\n+        debug!(?root_var_min_capture_list);\n \n         let mut projections_list = Vec::new();\n         let mut diagnostics_info = FxHashSet::default();\n@@ -1021,19 +1088,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Only care about captures that are moved into the closure\n                 ty::UpvarCapture::ByValue(..) => {\n                     projections_list.push(captured_place.place.projections.as_slice());\n-                    diagnostics_info.insert((\n-                        captured_place.info.path_expr_id,\n-                        captured_place.to_string(self.tcx),\n-                    ));\n+                    diagnostics_info.insert(UpvarMigrationInfo::CapturingPrecise {\n+                        source_expr: captured_place.info.path_expr_id,\n+                        var_name: captured_place.to_string(self.tcx),\n+                    });\n                 }\n                 ty::UpvarCapture::ByRef(..) => {}\n             }\n         }\n \n+        debug!(?projections_list);\n+        debug!(?diagnostics_info);\n+\n         let is_moved = !projections_list.is_empty();\n+        debug!(?is_moved);\n \n         let is_not_completely_captured =\n             root_var_min_capture_list.iter().any(|capture| !capture.place.projections.is_empty());\n+        debug!(?is_not_completely_captured);\n \n         if is_moved\n             && is_not_completely_captured\n@@ -1066,15 +1138,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Returns a tuple containing a vector of MigrationDiagnosticInfo, as well as a String\n     /// containing the reason why root variables whose HirId is contained in the vector should\n     /// be captured\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> (Vec<MigrationDiagnosticInfo>, String) {\n+    ) -> (Vec<NeededMigration>, MigrationWarningReason) {\n         let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) else {\n-            return (Vec::new(), String::new());\n+            return (Vec::new(), MigrationWarningReason::default());\n         };\n \n         let mut need_migrations = Vec::new();\n@@ -1083,7 +1156,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Perform auto-trait analysis\n         for (&var_hir_id, _) in upvars.iter() {\n-            let mut responsible_captured_hir_ids = Vec::new();\n+            let mut diagnostics_info = Vec::new();\n \n             let auto_trait_diagnostic = if let Some(diagnostics_info) =\n                 self.compute_2229_migrations_for_trait(min_captures, var_hir_id, closure_clause)\n@@ -1115,34 +1188,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let mut capture_diagnostic = capture_diagnostic.into_iter().collect::<Vec<_>>();\n             capture_diagnostic.sort();\n-            for captured_info in capture_diagnostic.iter() {\n+            for captures_info in capture_diagnostic {\n                 // Get the auto trait reasons of why migration is needed because of that capture, if there are any\n                 let capture_trait_reasons =\n-                    if let Some(reasons) = auto_trait_diagnostic.get(captured_info) {\n+                    if let Some(reasons) = auto_trait_diagnostic.get(&captures_info) {\n                         reasons.clone()\n                     } else {\n                         FxHashSet::default()\n                     };\n \n                 // Check if migration is needed because of drop reorder as a result of that capture\n-                let capture_drop_reorder_reason = drop_reorder_diagnostic.contains(captured_info);\n+                let capture_drop_reorder_reason = drop_reorder_diagnostic.contains(&captures_info);\n \n                 // Combine all the reasons of why the root variable should be captured as a result of\n                 // auto trait implementation issues\n                 auto_trait_migration_reasons.extend(capture_trait_reasons.clone());\n \n-                responsible_captured_hir_ids.push((\n-                    captured_info.0,\n-                    captured_info.1.clone(),\n-                    self.compute_2229_migrations_reasons(\n+                diagnostics_info.push(MigrationLintNote {\n+                    captures_info,\n+                    reason: self.compute_2229_migrations_reasons(\n                         capture_trait_reasons,\n                         capture_drop_reorder_reason,\n                     ),\n-                ));\n+                });\n             }\n \n-            if !capture_diagnostic.is_empty() {\n-                need_migrations.push((var_hir_id, responsible_captured_hir_ids));\n+            if !diagnostics_info.is_empty() {\n+                need_migrations.push(NeededMigration { var_hir_id, diagnostics_info });\n             }\n         }\n         (\n@@ -2087,6 +2159,7 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+#[instrument(level = \"debug\", skip(tcx))]\n fn should_do_rust_2021_incompatible_closure_captures_analysis(\n     tcx: TyCtxt<'_>,\n     closure_id: hir::HirId,\n@@ -2102,10 +2175,12 @@ fn should_do_rust_2021_incompatible_closure_captures_analysis(\n /// - s2: Comma separated names of the variables being migrated.\n fn migration_suggestion_for_2229(\n     tcx: TyCtxt<'_>,\n-    need_migrations: &Vec<MigrationDiagnosticInfo>,\n+    need_migrations: &Vec<NeededMigration>,\n ) -> (String, String) {\n-    let need_migrations_variables =\n-        need_migrations.iter().map(|(v, _)| var_name(tcx, *v)).collect::<Vec<_>>();\n+    let need_migrations_variables = need_migrations\n+        .iter()\n+        .map(|NeededMigration { var_hir_id: v, .. }| var_name(tcx, *v))\n+        .collect::<Vec<_>>();\n \n     let migration_ref_concat =\n         need_migrations_variables.iter().map(|v| format!(\"&{}\", v)).collect::<Vec<_>>().join(\", \");"}, {"sha": "4e0b18e72338ad881e95e67d708c90dcd70b56fa", "filename": "src/test/ui/closures/2229_closure_analysis/issue-90465.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.fixed?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+#![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE lint level is defined here\n+\n+fn main() {\n+    struct Foo(u32);\n+    impl Drop for Foo {\n+        fn drop(&mut self) {\n+            println!(\"dropped {}\", self.0);\n+        }\n+    }\n+\n+    let f0 = Foo(0);\n+    let f1 = Foo(1);\n+\n+    let c0 = move || {\n+        let _ = &f0;\n+        //~^ ERROR changes to closure capture in Rust 2021 will affect drop order\n+        //~| NOTE for more information\n+        let _ = f0;\n+        //~^ NOTE in Rust 2018, this causes the closure to capture `f0`, but in Rust 2021, it has no effect\n+    };\n+\n+    let c1 = move || {\n+        let _ = &f1;\n+    };\n+\n+    println!(\"dropping 0\");\n+    drop(c0);\n+    println!(\"dropping 1\");\n+    drop(c1);\n+    println!(\"dropped all\");\n+}\n+//~^ NOTE in Rust 2018, `f0` is dropped here along with the closure, but in Rust 2021 `f0` is not part of the closure"}, {"sha": "466e6dbabc5021ac47d7748c57cb2787909e5bca", "filename": "src/test/ui/closures/2229_closure_analysis/issue-90465.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.rs?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+\n+#![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE lint level is defined here\n+\n+fn main() {\n+    struct Foo(u32);\n+    impl Drop for Foo {\n+        fn drop(&mut self) {\n+            println!(\"dropped {}\", self.0);\n+        }\n+    }\n+\n+    let f0 = Foo(0);\n+    let f1 = Foo(1);\n+\n+    let c0 = move || {\n+        //~^ ERROR changes to closure capture in Rust 2021 will affect drop order\n+        //~| NOTE for more information\n+        let _ = f0;\n+        //~^ NOTE in Rust 2018, this causes the closure to capture `f0`, but in Rust 2021, it has no effect\n+    };\n+\n+    let c1 = move || {\n+        let _ = &f1;\n+    };\n+\n+    println!(\"dropping 0\");\n+    drop(c0);\n+    println!(\"dropping 1\");\n+    drop(c1);\n+    println!(\"dropped all\");\n+}\n+//~^ NOTE in Rust 2018, `f0` is dropped here along with the closure, but in Rust 2021 `f0` is not part of the closure"}, {"sha": "3e921dc0f8a664f299e8fb2be5a31811234de677", "filename": "src/test/ui/closures/2229_closure_analysis/issue-90465.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.stderr?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -0,0 +1,26 @@\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/issue-90465.rs:17:14\n+   |\n+LL |     let c0 = move || {\n+   |              ^^^^^^^\n+...\n+LL |         let _ = f0;\n+   |                 -- in Rust 2018, this causes the closure to capture `f0`, but in Rust 2021, it has no effect\n+...\n+LL | }\n+   | - in Rust 2018, `f0` is dropped here along with the closure, but in Rust 2021 `f0` is not part of the closure\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-90465.rs:3:9\n+   |\n+LL | #![deny(rust_2021_incompatible_closure_captures)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `f0` to be fully captured\n+   |\n+LL ~     let c0 = move || {\n+LL +         let _ = &f0;\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "26703fbf81193603e2a471b5a5d055b20bcc93db", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -20,8 +20,8 @@ fn test_send_trait() {\n     let mut f = 10;\n     let fptr = SendPointer(&mut f as *mut i32);\n     thread::spawn(move || { let _ = &fptr; unsafe {\n-        //~^ ERROR: `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n@@ -40,8 +40,9 @@ fn test_sync_trait() {\n     let f = CustomInt(&mut f as *mut i32);\n     let fptr = SyncPointer(f);\n     thread::spawn(move || { let _ = &fptr; unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n@@ -65,8 +66,8 @@ fn test_clone_trait() {\n     let f = U(S(Foo(0)), T(0));\n     let c = || {\n         let _ = &f;\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         let f_1 = f.1;"}, {"sha": "932db51d437130699e7256ef92cf104542b34940", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -20,8 +20,8 @@ fn test_send_trait() {\n     let mut f = 10;\n     let fptr = SendPointer(&mut f as *mut i32);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n@@ -40,8 +40,9 @@ fn test_sync_trait() {\n     let f = CustomInt(&mut f as *mut i32);\n     let fptr = SyncPointer(f);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n@@ -64,8 +65,8 @@ impl Clone for U {\n fn test_clone_trait() {\n     let f = U(S(Foo(0)), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         let f_1 = f.1;"}, {"sha": "ee4907bb755cc115005945b6af0d7fa14e964da4", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -1,8 +1,8 @@\n-error: changes to closure capture in Rust 2021 will affect `Send` trait implementation for closure\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n   --> $DIR/auto_traits.rs:22:19\n    |\n LL |     thread::spawn(move || unsafe {\n-   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n+   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0` does not implement `Send`\n ...\n LL |         *fptr.0 = 20;\n    |         ------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`\n@@ -23,11 +23,14 @@ LL |\n LL |         *fptr.0 = 20;\n  ...\n \n-error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n   --> $DIR/auto_traits.rs:42:19\n    |\n LL |     thread::spawn(move || unsafe {\n-   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+   |                   ^^^^^^^^^^^^^^\n+   |                   |\n+   |                   in Rust 2018, this closure implements `Sync` as `fptr` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr` is not fully captured and `fptr.0.0` does not implement `Sync`\n+   |                   in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0.0` does not implement `Send`\n ...\n LL |         *fptr.0.0 = 20;\n    |         --------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`\n@@ -40,14 +43,14 @@ LL |\n LL |\n LL |\n LL |\n-LL |         *fptr.0.0 = 20;\n+LL |\n  ...\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/auto_traits.rs:66:13\n+error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+  --> $DIR/auto_traits.rs:67:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f` is not fully captured and `f.1` does not implement `Clone`\n ...\n LL |         let f_1 = f.1;\n    |                   --- in Rust 2018, this closure captures all of `f`, but in Rust 2021, it will only capture `f.1`"}, {"sha": "7df0dd76b44564b768e8989ece9e037c962d9136", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.fixed", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -19,8 +19,9 @@ where\n     let f = panic::AssertUnwindSafe(f);\n     let result = panic::catch_unwind(move || {\n         let _ = &f;\n-        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`\n+        //~| NOTE: in Rust 2018, this closure implements `RefUnwindSafe`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         f.0()"}, {"sha": "d02fac7c66952606048a19827fcd9c37050b3c23", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -18,8 +18,9 @@ where\n {\n     let f = panic::AssertUnwindSafe(f);\n     let result = panic::catch_unwind(move || {\n-        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`\n+        //~| NOTE: in Rust 2018, this closure implements `RefUnwindSafe`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         f.0()"}, {"sha": "74f85b6ebaac50e5f3de999ef10a17f90740d93d", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -1,8 +1,11 @@\n-error: changes to closure capture in Rust 2021 will affect `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n   --> $DIR/mir_calls_to_shims.rs:20:38\n    |\n LL |     let result = panic::catch_unwind(move || {\n-   |                                      ^^^^^^^ in Rust 2018, this closure implements `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+   |                                      ^^^^^^^\n+   |                                      |\n+   |                                      in Rust 2018, this closure implements `UnwindSafe` as `f` implements `UnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe` because `f` is not fully captured and `f.0` does not implement `UnwindSafe`\n+   |                                      in Rust 2018, this closure implements `RefUnwindSafe` as `f` implements `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `RefUnwindSafe` because `f` is not fully captured and `f.0` does not implement `RefUnwindSafe`\n ...\n LL |         f.0()\n    |         --- in Rust 2018, this closure captures all of `f`, but in Rust 2021, it will only capture `f.0`"}, {"sha": "2b86b0ddade2367196e542f83ac91b65cfc2b2b7", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -18,7 +18,6 @@ impl Foo {\n     }\n }\n \n-\n struct S(Foo);\n \n #[derive(Clone)]\n@@ -37,8 +36,8 @@ fn test_multi_issues() {\n     let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n         let _ = (&f1, &f2);\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1`, `f2` to be fully captured\n         let _f_1 = f1.0;\n@@ -57,8 +56,8 @@ fn test_capturing_all_disjoint_fields_individually() {\n     let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n         let _ = &f1;\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_1 = f1.0;\n@@ -83,9 +82,9 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.2` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -103,8 +102,8 @@ fn test_capturing_several_disjoint_fields_individually_2() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -136,9 +135,10 @@ fn test_multi_traits_issues() {\n     let mut f2 = 10;\n     let fptr2 = SendPointer(&mut f2 as *mut i32);\n     thread::spawn(move || { let _ = (&fptr1, &fptr2); unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr2.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n         *fptr1.0.0 = 20;"}, {"sha": "3cac4abfad7c2a5def2e614517d6d30684481719", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -18,7 +18,6 @@ impl Foo {\n     }\n }\n \n-\n struct S(Foo);\n \n #[derive(Clone)]\n@@ -36,8 +35,8 @@ fn test_multi_issues() {\n     let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1`, `f2` to be fully captured\n         let _f_1 = f1.0;\n@@ -55,8 +54,8 @@ fn test_multi_issues() {\n fn test_capturing_all_disjoint_fields_individually() {\n     let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_1 = f1.0;\n@@ -80,9 +79,9 @@ impl Clone for U1 {\n fn test_capturing_several_disjoint_fields_individually_1() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.2` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -99,8 +98,8 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n fn test_capturing_several_disjoint_fields_individually_2() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -132,9 +131,10 @@ fn test_multi_traits_issues() {\n     let mut f2 = 10;\n     let fptr2 = SendPointer(&mut f2 as *mut i32);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr2.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n         *fptr1.0.0 = 20;"}, {"sha": "0008f1b2c07ed5811544fd27f9767c75c6bcfec0", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b1cb73f1d45f69e0f00a66754616c61b3166c47/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=4b1cb73f1d45f69e0f00a66754616c61b3166c47", "patch": "@@ -1,8 +1,8 @@\n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:38:13\n+error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:37:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n ...\n LL |         let _f_1 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -25,11 +25,11 @@ LL ~     let c = || {\n LL +         let _ = (&f1, &f2);\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:57:13\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:56:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n ...\n LL |         let _f_1 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -41,14 +41,14 @@ LL ~     let c = || {\n LL +         let _ = &f1;\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:82:13\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:81:13\n    |\n LL |     let c = || {\n    |             ^^\n    |             |\n-   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n-   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.2` does not implement `Clone`\n+   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n+   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.2` does not implement `Clone`\n ...\n LL |         let _f_0 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -63,11 +63,11 @@ LL ~     let c = || {\n LL +         let _ = &f1;\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:101:13\n+error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:100:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n ...\n LL |         let _f_0 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -88,14 +88,15 @@ LL ~     let c = || {\n LL +         let _ = &f1;\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:134:19\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:133:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^\n    |                   |\n-   |                   in Rust 2018, this closure implements `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n-   |                   in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr2.0` does not implement `Send`\n+   |                   in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Sync`\n+   |                   in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Send`\n+   |                   in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr2` is not fully captured and `fptr2.0` does not implement `Send`\n ...\n LL |         *fptr1.0.0 = 20;\n    |         ---------- in Rust 2018, this closure captures all of `fptr1`, but in Rust 2021, it will only capture `fptr1.0.0`"}]}