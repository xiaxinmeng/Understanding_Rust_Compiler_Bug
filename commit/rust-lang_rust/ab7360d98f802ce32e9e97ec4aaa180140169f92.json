{"sha": "ab7360d98f802ce32e9e97ec4aaa180140169f92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNzM2MGQ5OGY4MDJjZTMyZTllOTdlYzRhYWExODAxNDAxNjlmOTI=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-04T18:48:17Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-04T18:48:17Z"}, "message": "refactor suggest_traits_to_import", "tree": {"sha": "46339b3fad4659f87df23272e67c09d064090425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46339b3fad4659f87df23272e67c09d064090425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7360d98f802ce32e9e97ec4aaa180140169f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7360d98f802ce32e9e97ec4aaa180140169f92", "html_url": "https://github.com/rust-lang/rust/commit/ab7360d98f802ce32e9e97ec4aaa180140169f92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7360d98f802ce32e9e97ec4aaa180140169f92/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6318d24ad8440fa30428b405be1174478e9536e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6318d24ad8440fa30428b405be1174478e9536e3", "html_url": "https://github.com/rust-lang/rust/commit/6318d24ad8440fa30428b405be1174478e9536e3"}], "stats": {"total": 104, "additions": 49, "deletions": 55}, "files": [{"sha": "857cc972559e499c7aa17fd8836ff9bee5d25dd9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ab7360d98f802ce32e9e97ec4aaa180140169f92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7360d98f802ce32e9e97ec4aaa180140169f92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ab7360d98f802ce32e9e97ec4aaa180140169f92", "patch": "@@ -947,65 +947,59 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                !unsatisfied_predicates.iter().any(|(p, _)| match p {\n-                        // Hide traits if they are present in predicates as they can be fixed without\n-                        // having to implement them.\n-                        ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n-                        ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n-                        _ => true,\n-                    }) && (type_is_local || info.def_id.is_local())\n-                        && self\n-                            .associated_item(info.def_id, item_name, Namespace::ValueNS)\n-                            .filter(|item| {\n-                                if let ty::AssocKind::Fn = item.kind {\n-                                    let id = item.def_id.as_local().map(|def_id| {\n-                                        self.tcx.hir().as_local_hir_id(def_id)\n-                                    });\n-                                    if let Some(hir::Node::TraitItem(hir::TraitItem {\n-                                        kind: hir::TraitItemKind::Fn(fn_sig, method),\n-                                        ..\n-                                    })) = id.map(|id| self.tcx.hir().get(id))\n+                unsatisfied_predicates.iter().all(|(p, _)| match p {\n+                    // Hide traits if they are present in predicates as they can be fixed without\n+                    // having to implement them.\n+                    ty::Predicate::Trait(t, _) => t.def_id() == info.def_id,\n+                    ty::Predicate::Projection(p) => p.item_def_id() == info.def_id,\n+                    _ => false,\n+                }) && (type_is_local || info.def_id.is_local())\n+                    && self\n+                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n+                        .filter(|item| {\n+                            if let ty::AssocKind::Fn = item.kind {\n+                                let id = item\n+                                    .def_id\n+                                    .as_local()\n+                                    .map(|def_id| self.tcx.hir().as_local_hir_id(def_id));\n+                                if let Some(hir::Node::TraitItem(hir::TraitItem {\n+                                    kind: hir::TraitItemKind::Fn(fn_sig, method),\n+                                    ..\n+                                })) = id.map(|id| self.tcx.hir().get(id))\n+                                {\n+                                    let self_first_arg = match method {\n+                                        hir::TraitFn::Required([ident, ..]) => {\n+                                            ident.name == kw::SelfLower\n+                                        }\n+                                        hir::TraitFn::Provided(body_id) => {\n+                                            self.tcx.hir().body(*body_id).params.first().map_or(\n+                                                false,\n+                                                |param| {\n+                                                    matches!(\n+                                                        param.pat.kind,\n+                                                        hir::PatKind::Binding(_, _, ident, _)\n+                                                            if ident.name == kw::SelfLower\n+                                                    )\n+                                                },\n+                                            )\n+                                        }\n+                                        _ => false,\n+                                    };\n+\n+                                    if !fn_sig.decl.implicit_self.has_implicit_self()\n+                                        && self_first_arg\n                                     {\n-                                        let self_first_arg = match method {\n-                                            hir::TraitFn::Required([ident, ..]) => {\n-                                                ident.name == kw::SelfLower\n-                                            }\n-                                            hir::TraitFn::Provided(body_id) => {\n-                                                match &self.tcx.hir().body(*body_id).params[..] {\n-                                                    [hir::Param {\n-                                                        pat:\n-                                                            hir::Pat {\n-                                                                kind:\n-                                                                    hir::PatKind::Binding(\n-                                                                        _,\n-                                                                        _,\n-                                                                        ident,\n-                                                                        ..,\n-                                                                    ),\n-                                                                ..\n-                                                            },\n-                                                        ..\n-                                                    }, ..] => ident.name == kw::SelfLower,\n-                                                    _ => false,\n-                                                }\n-                                            }\n-                                            _ => false,\n-                                        };\n-\n-                                        if !fn_sig.decl.implicit_self.has_implicit_self()\n-                                            && self_first_arg\n-                                        {\n-                                            if let Some(ty) = fn_sig.decl.inputs.get(0) {\n-                                                arbitrary_rcvr.push(ty.span);\n-                                            }\n-                                            return false;\n+                                        if let Some(ty) = fn_sig.decl.inputs.get(0) {\n+                                            arbitrary_rcvr.push(ty.span);\n                                         }\n+                                        return false;\n                                     }\n                                 }\n-                                // We only want to suggest public or local traits (#45781).\n-                                item.vis == ty::Visibility::Public || info.def_id.is_local()\n-                            })\n-                            .is_some()\n+                            }\n+                            // We only want to suggest public or local traits (#45781).\n+                            item.vis == ty::Visibility::Public || info.def_id.is_local()\n+                        })\n+                        .is_some()\n             })\n             .collect::<Vec<_>>();\n         for span in &arbitrary_rcvr {"}]}