{"sha": "749349fc9f7b12f212bca9ba2297e463328cb701", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OTM0OWZjOWY3YjEyZjIxMmJjYTliYTIyOTdlNDYzMzI4Y2I3MDE=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-03-14T00:42:23Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-04-02T01:25:57Z"}, "message": "Refactor async fn return type lowering\n\nasync fn now lowers directly to an existential type declaration\nrather than reusing the `impl Trait` return type lowering.\n\nAs part of this, it lowers all argument-position elided lifetimes\nusing the in-band-lifetimes machinery, creating fresh parameter\nnames for each of them, using each lifetime parameter as a generic\nargument to the generated existential type.\n\nThis doesn't currently successfully allow multiple\nargument-position elided lifetimes since `existential type`\ndoesn't yet support multiple lifetimes where neither outlive\nthe other. This requires a separate fix.", "tree": {"sha": "7fe6b270bbd786330dd0c6adc6dada8407f8f172", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fe6b270bbd786330dd0c6adc6dada8407f8f172"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/749349fc9f7b12f212bca9ba2297e463328cb701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/749349fc9f7b12f212bca9ba2297e463328cb701", "html_url": "https://github.com/rust-lang/rust/commit/749349fc9f7b12f212bca9ba2297e463328cb701", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/749349fc9f7b12f212bca9ba2297e463328cb701/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f694222887cf31f51e68927716c25736e62f037f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f694222887cf31f51e68927716c25736e62f037f", "html_url": "https://github.com/rust-lang/rust/commit/f694222887cf31f51e68927716c25736e62f037f"}], "stats": {"total": 889, "additions": 553, "deletions": 336}, "files": [{"sha": "c2265eeb30d741d40d6b964146d647a398e6f385", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -490,7 +490,11 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n-        ItemKind::Existential(ExistTy { ref generics, ref bounds, impl_trait_fn: _ }) => {\n+        ItemKind::Existential(ExistTy {\n+            ref generics,\n+            ref bounds,\n+            ..\n+        }) => {\n             visitor.visit_id(item.hir_id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);"}, {"sha": "2a255523676784cc9e556cbb29ca72e03220e94c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 377, "deletions": 284, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -66,7 +66,7 @@ use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -318,6 +318,49 @@ enum AnonymousLifetimeMode {\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n     PassThrough,\n+\n+    /// Used in the return types of `async fn` where there exists\n+    /// exactly one argument-position elided lifetime.\n+    ///\n+    /// In `async fn`, we lower the arguments types using the `CreateParameter`\n+    /// mode, meaning that non-`dyn` elided lifetimes are assigned a fresh name.\n+    /// If any corresponding elided lifetimes appear in the output, we need to\n+    /// replace them with references to the fresh name assigned to the corresponding\n+    /// elided lifetime in the arguments.\n+    ///\n+    /// For **Modern cases**, replace the anonymous parameter with a\n+    /// reference to a specific freshly-named lifetime that was\n+    /// introduced in argument\n+    ///\n+    /// For **Dyn Bound** cases, pass responsibility to\n+    /// `resole_lifetime` code.\n+    Replace(LtReplacement),\n+}\n+\n+/// The type of elided lifetime replacement to perform on `async fn` return types.\n+#[derive(Copy, Clone)]\n+enum LtReplacement {\n+    /// Fresh name introduced by the single non-dyn elided lifetime\n+    /// in the arguments of the async fn.\n+    Some(ParamName),\n+\n+    /// There is no single non-dyn elided lifetime because no lifetimes\n+    /// appeared in the arguments.\n+    NoLifetimes,\n+\n+    /// There is no single non-dyn elided lifetime because multiple\n+    /// lifetimes appeared in the arguments.\n+    MultipleLifetimes,\n+}\n+\n+/// Calculates the `LtReplacement` to use for elided lifetimes in the return\n+/// type based on the fresh elided lifetimes introduced in argument position.\n+fn get_elided_lt_replacement(arg_position_lifetimes: &[(Span, ParamName)]) -> LtReplacement {\n+    match arg_position_lifetimes {\n+        [] => LtReplacement::NoLifetimes,\n+        [(_span, param)] => LtReplacement::Some(*param),\n+        _ => LtReplacement::MultipleLifetimes,\n+    }\n }\n \n struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n@@ -778,53 +821,63 @@ impl<'a> LoweringContext<'a> {\n \n         let params = lifetimes_to_define\n             .into_iter()\n-            .map(|(span, hir_name)| {\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n-\n-                // Get the name we'll use to make the def-path. Note\n-                // that collisions are ok here and this shouldn't\n-                // really show up for end-user.\n-                let (str_name, kind) = match hir_name {\n-                    ParamName::Plain(ident) => (\n-                        ident.as_interned_str(),\n-                        hir::LifetimeParamKind::InBand,\n-                    ),\n-                    ParamName::Fresh(_) => (\n-                        keywords::UnderscoreLifetime.name().as_interned_str(),\n-                        hir::LifetimeParamKind::Elided,\n-                    ),\n-                    ParamName::Error => (\n-                        keywords::UnderscoreLifetime.name().as_interned_str(),\n-                        hir::LifetimeParamKind::Error,\n-                    ),\n-                };\n-\n-                // Add a definition for the in-band lifetime def.\n-                self.resolver.definitions().create_def_with_parent(\n-                    parent_id.index,\n-                    node_id,\n-                    DefPathData::LifetimeParam(str_name),\n-                    DefIndexAddressSpace::High,\n-                    Mark::root(),\n-                    span,\n-                );\n-\n-                hir::GenericParam {\n-                    hir_id,\n-                    name: hir_name,\n-                    attrs: hir_vec![],\n-                    bounds: hir_vec![],\n-                    span,\n-                    pure_wrt_drop: false,\n-                    kind: hir::GenericParamKind::Lifetime { kind }\n-                }\n-            })\n+            .map(|(span, hir_name)| self.lifetime_to_generic_param(\n+                span, hir_name, parent_id.index,\n+            ))\n             .chain(in_band_ty_params.into_iter())\n             .collect();\n \n         (params, res)\n     }\n \n+    /// Converts a lifetime into a new generic parameter.\n+    fn lifetime_to_generic_param(\n+        &mut self,\n+        span: Span,\n+        hir_name: ParamName,\n+        parent_index: DefIndex,\n+    ) -> hir::GenericParam {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n+        // Get the name we'll use to make the def-path. Note\n+        // that collisions are ok here and this shouldn't\n+        // really show up for end-user.\n+        let (str_name, kind) = match hir_name {\n+            ParamName::Plain(ident) => (\n+                ident.as_interned_str(),\n+                hir::LifetimeParamKind::InBand,\n+            ),\n+            ParamName::Fresh(_) => (\n+                keywords::UnderscoreLifetime.name().as_interned_str(),\n+                hir::LifetimeParamKind::Elided,\n+            ),\n+            ParamName::Error => (\n+                keywords::UnderscoreLifetime.name().as_interned_str(),\n+                hir::LifetimeParamKind::Error,\n+            ),\n+        };\n+\n+        // Add a definition for the in-band lifetime def.\n+        self.resolver.definitions().create_def_with_parent(\n+            parent_index,\n+            node_id,\n+            DefPathData::LifetimeParam(str_name),\n+            DefIndexAddressSpace::High,\n+            Mark::root(),\n+            span,\n+        );\n+\n+        hir::GenericParam {\n+            hir_id,\n+            name: hir_name,\n+            attrs: hir_vec![],\n+            bounds: hir_vec![],\n+            span,\n+            pure_wrt_drop: false,\n+            kind: hir::GenericParamKind::Lifetime { kind }\n+        }\n+    }\n+\n     /// When there is a reference to some lifetime `'a`, and in-band\n     /// lifetimes are enabled, then we want to push that lifetime into\n     /// the vector of names to define later. In that case, it will get\n@@ -928,6 +981,13 @@ impl<'a> LoweringContext<'a> {\n             |this| {\n                 this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n                     let mut params = Vec::new();\n+                    // Note: it is necessary to lower generics *before* calling `f`.\n+                    // When lowering `async fn`, there's a final step when lowering\n+                    // the return type that assumes that all in-scope lifetimes have\n+                    // already been added to either `in_scope_lifetimes` or\n+                    // `lifetimes_to_define`. If we swapped the order of these two,\n+                    // in-band-lifetimes introduced by generics or where-clauses\n+                    // wouldn't have been added yet.\n                     let generics = this.lower_generics(\n                         generics,\n                         ImplTraitContext::Universal(&mut params),\n@@ -1426,42 +1486,62 @@ impl<'a> LoweringContext<'a> {\n \n         self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n             let LoweredNodeId { node_id: _, hir_id } = lctx.next_id();\n-            let exist_ty_item_kind = hir::ItemKind::Existential(hir::ExistTy {\n+            let exist_ty_item = hir::ExistTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n                         hir_id,\n-                        predicates: Vec::new().into(),\n+                        predicates: hir_vec![],\n                     },\n                     span,\n                 },\n                 bounds: hir_bounds,\n                 impl_trait_fn: fn_def_id,\n-            });\n-            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n-            // Generate an `existential type Foo: Trait;` declaration.\n-            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n-\n-            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n-            let exist_ty_item = hir::Item {\n-                hir_id: exist_ty_id.hir_id,\n-                ident: keywords::Invalid.ident(),\n-                attrs: Default::default(),\n-                node: exist_ty_item_kind,\n-                vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n-                span: exist_ty_span,\n+                origin: hir::ExistTyOrigin::ReturnImplTrait,\n             };\n \n-            // Insert the item into the global list. This usually happens\n-            // automatically for all AST items. But this existential type item\n-            // does not actually exist in the AST.\n-            lctx.insert_item(exist_ty_item);\n+            trace!(\"exist ty from impl trait def index: {:#?}\", exist_ty_def_index);\n+            let exist_ty_id = lctx.generate_existential_type(\n+                exist_ty_node_id,\n+                exist_ty_item,\n+                span,\n+                exist_ty_span,\n+            );\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n             hir::TyKind::Def(hir::ItemId { id: exist_ty_id.hir_id }, lifetimes)\n         })\n     }\n \n+    /// Registers a new existential type with the proper NodeIds and\n+    /// returns the lowered node ID for the existential type.\n+    fn generate_existential_type(\n+        &mut self,\n+        exist_ty_node_id: NodeId,\n+        exist_ty_item: hir::ExistTy,\n+        span: Span,\n+        exist_ty_span: Span,\n+    ) -> LoweredNodeId {\n+        let exist_ty_item_kind = hir::ItemKind::Existential(exist_ty_item);\n+        let exist_ty_id = self.lower_node_id(exist_ty_node_id);\n+        // Generate an `existential type Foo: Trait;` declaration.\n+        trace!(\"registering existential type with id {:#?}\", exist_ty_id);\n+        let exist_ty_item = hir::Item {\n+            hir_id: exist_ty_id.hir_id,\n+            ident: keywords::Invalid.ident(),\n+            attrs: Default::default(),\n+            node: exist_ty_item_kind,\n+            vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n+            span: exist_ty_span,\n+        };\n+\n+        // Insert the item into the global item list. This usually happens\n+        // automatically for all AST items. But this existential type item\n+        // does not actually exist in the AST.\n+        self.insert_item(exist_ty_item);\n+        exist_ty_id\n+    }\n+\n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n         exist_ty_id: NodeId,\n@@ -1569,9 +1649,6 @@ impl<'a> LoweringContext<'a> {\n                         name,\n                     }));\n \n-                    // We need to manually create the ids here, because the\n-                    // definitions will go into the explicit `existential type`\n-                    // declaration and thus need to have their owner set to that item\n                     let def_node_id = self.context.sess.next_node_id();\n                     let LoweredNodeId { node_id: _, hir_id } =\n                         self.context.lower_node_id_with_owner(def_node_id, self.exist_ty_id);\n@@ -2108,23 +2185,42 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n     ) -> P<hir::FnDecl> {\n-        let inputs = decl.inputs\n-            .iter()\n-            .map(|arg| {\n-                if let Some((_, ref mut ibty)) = in_band_ty_params {\n-                    self.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n-                } else {\n-                    self.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n-                }\n-            })\n-            .collect::<HirVec<_>>();\n+        let lt_mode = if make_ret_async.is_some() {\n+            // In `async fn`, argument-position elided lifetimes\n+            // must be transformed into fresh generic parameters so that\n+            // they can be applied to the existential return type.\n+            AnonymousLifetimeMode::CreateParameter\n+        } else {\n+            self.anonymous_lifetime_mode\n+        };\n+\n+        // Remember how many lifetimes were already around so that we can\n+        // only look at the lifetime parameters introduced by the arguments.\n+        let lifetime_count_before_args = self.lifetimes_to_define.len();\n+        let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n+            decl.inputs\n+                .iter()\n+                .map(|arg| {\n+                    if let Some((_, ibty)) = &mut in_band_ty_params {\n+                        this.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n+                    } else {\n+                        this.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n+                    }\n+                })\n+                .collect::<HirVec<_>>()\n+        });\n \n         let output = if let Some(ret_id) = make_ret_async {\n+            // Calculate the `LtReplacement` to use for any return-position elided\n+            // lifetimes based on the elided lifetime parameters introduced in the args.\n+            let lt_replacement = get_elided_lt_replacement(\n+                &self.lifetimes_to_define[lifetime_count_before_args..]\n+            );\n             self.lower_async_fn_ret_ty(\n-                &inputs,\n                 &decl.output,\n                 in_band_ty_params.expect(\"make_ret_async but no fn_def_id\").0,\n                 ret_id,\n+                lt_replacement,\n             )\n         } else {\n             match decl.output {\n@@ -2173,233 +2269,171 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    // Transform `-> T` into `-> impl Future<Output = T>` for `async fn`\n+    // Transform `-> T` for `async fn` into -> ExistTy { .. }\n+    // combined with the following definition of `ExistTy`:\n+    //\n+    // existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n     //\n-    // fn_span: the span of the async function declaration. Used for error reporting.\n     // inputs: lowered types of arguments to the function. Used to collect lifetimes.\n     // output: unlowered output type (`T` in `-> T`)\n     // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n+    // exist_ty_node_id: NodeId of the existential type that should be created.\n+    // elided_lt_replacement: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n-        inputs: &[hir::Ty],\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n-        return_impl_trait_id: NodeId,\n+        exist_ty_node_id: NodeId,\n+        elided_lt_replacement: LtReplacement,\n     ) -> hir::FunctionRetTy {\n-        // Get lifetimes used in the input arguments to the function. Our output type must also\n-        // have the same lifetime.\n-        // FIXME(cramertj): multiple different lifetimes are not allowed because\n-        // `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither is a subset\n-        // of the other. We really want some new lifetime that is a subset of all input lifetimes,\n-        // but that doesn't exist at the moment.\n-\n-        struct AsyncFnLifetimeCollector<'r, 'a: 'r> {\n-            context: &'r mut LoweringContext<'a>,\n-            // Lifetimes bound by HRTB.\n-            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n-            // Whether to count elided lifetimes.\n-            // Disabled inside of `Fn` or `fn` syntax.\n-            collect_elided_lifetimes: bool,\n-            // The lifetime found.\n-            // Multiple different or elided lifetimes cannot appear in async fn for now.\n-            output_lifetime: Option<(hir::LifetimeName, Span)>,\n-        }\n-\n-        impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for AsyncFnLifetimeCollector<'r, 'a> {\n-            fn nested_visit_map<'this>(\n-                &'this mut self,\n-            ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n-                hir::intravisit::NestedVisitorMap::None\n-            }\n+        let span = output.span();\n \n-            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs) {\n-                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n-                if parameters.parenthesized {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-                    hir::intravisit::walk_generic_args(self, span, parameters);\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    hir::intravisit::walk_generic_args(self, span, parameters);\n-                }\n-            }\n-\n-            fn visit_ty(&mut self, t: &'v hir::Ty) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax.\n-                if let &hir::TyKind::BareFn(_) = &t.node {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-\n-                    // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                    // to be able to later fully undo their introduction.\n-                    let old_len = self.currently_bound_lifetimes.len();\n-                    hir::intravisit::walk_ty(self, t);\n-                    self.currently_bound_lifetimes.truncate(old_len);\n-\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    hir::intravisit::walk_ty(self, t);\n-                }\n-            }\n+        let exist_ty_span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Async,\n+            span,\n+            None,\n+        );\n \n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &'v hir::PolyTraitRef,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                // to be able to later fully undo their introduction.\n-                let old_len = self.currently_bound_lifetimes.len();\n-                hir::intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.currently_bound_lifetimes.truncate(old_len);\n-            }\n+        let exist_ty_def_index = self\n+            .resolver\n+            .definitions()\n+            .opt_def_index(exist_ty_node_id)\n+            .unwrap();\n \n-            fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n-                 // Record the introduction of 'a in `for<'a> ...`\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n-                    let lt_name = hir::LifetimeName::Param(param.name);\n-                    self.currently_bound_lifetimes.push(lt_name);\n-                }\n+        self.allocate_hir_id_counter(exist_ty_node_id);\n \n-                hir::intravisit::walk_generic_param(self, param);\n-            }\n+        let (exist_ty_node_id, lifetime_params) = self.with_hir_id_owner(exist_ty_node_id, |this| {\n+            let future_bound = this.with_anonymous_lifetime_mode(\n+                AnonymousLifetimeMode::Replace(elided_lt_replacement),\n+                |this| this.lower_async_fn_output_type_to_future_bound(\n+                    output,\n+                    fn_def_id,\n+                    span,\n+                ),\n+            );\n \n-            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-                let name = match lifetime.name {\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n-                        if self.collect_elided_lifetimes {\n-                            // Use `'_` for both implicit and underscore lifetimes in\n-                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n-                            hir::LifetimeName::Underscore\n-                        } else {\n-                            return;\n-                        }\n-                    }\n-                    hir::LifetimeName::Param(_) => lifetime.name,\n-                    hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n-                };\n+            // Calculate all the lifetimes that should be captured\n+            // by the existential type. This should include all in-scope\n+            // lifetime parameters, including those defined in-band.\n+            //\n+            // Note: this must be done after lowering the output type,\n+            // as the output type may introduce new in-band lifetimes.\n+            let lifetime_params: Vec<(Span, ParamName)> =\n+                this.in_scope_lifetimes\n+                    .iter().cloned()\n+                    .map(|ident| (ident.span, ParamName::Plain(ident)))\n+                    .chain(this.lifetimes_to_define.iter().cloned())\n+                    .collect();\n \n-                if !self.currently_bound_lifetimes.contains(&name) {\n-                    if let Some((current_lt_name, current_lt_span)) = self.output_lifetime {\n-                        // We don't currently have a reliable way to desugar `async fn` with\n-                        // multiple potentially unrelated input lifetimes into\n-                        // `-> impl Trait + 'lt`, so we report an error in this case.\n-                        if current_lt_name != name {\n-                            struct_span_err!(\n-                                self.context.sess,\n-                                MultiSpan::from_spans(vec![current_lt_span, lifetime.span]),\n-                                E0709,\n-                                \"multiple different lifetimes used in arguments of `async fn`\",\n-                            )\n-                                .span_label(current_lt_span, \"first lifetime here\")\n-                                .span_label(lifetime.span, \"different lifetime here\")\n-                                .help(\"`async fn` can only accept borrowed values \\\n-                                      with identical lifetimes\")\n-                                .emit()\n-                        } else if current_lt_name.is_elided() && name.is_elided() {\n-                            struct_span_err!(\n-                                self.context.sess,\n-                                MultiSpan::from_spans(vec![current_lt_span, lifetime.span]),\n-                                E0707,\n-                                \"multiple elided lifetimes used in arguments of `async fn`\",\n-                            )\n-                                .span_label(current_lt_span, \"first lifetime here\")\n-                                .span_label(lifetime.span, \"different lifetime here\")\n-                                .help(\"consider giving these arguments named lifetimes\")\n-                                .emit()\n-                        }\n-                    } else {\n-                        self.output_lifetime = Some((name, lifetime.span));\n-                    }\n-                }\n-            }\n-        }\n+            let generic_params =\n+                lifetime_params\n+                    .iter().cloned()\n+                    .map(|(span, hir_name)| {\n+                        this.lifetime_to_generic_param(span, hir_name, exist_ty_def_index)\n+                    })\n+                    .collect();\n \n-        let bound_lifetime = {\n-            let mut lifetime_collector = AsyncFnLifetimeCollector {\n-                context: self,\n-                currently_bound_lifetimes: Vec::new(),\n-                collect_elided_lifetimes: true,\n-                output_lifetime: None,\n+            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n+            let exist_ty_item = hir::ExistTy {\n+                generics: hir::Generics {\n+                    params: generic_params,\n+                    where_clause: hir::WhereClause {\n+                        hir_id,\n+                        predicates: hir_vec![],\n+                    },\n+                    span,\n+                },\n+                bounds: hir_vec![future_bound],\n+                impl_trait_fn: Some(fn_def_id),\n+                origin: hir::ExistTyOrigin::AsyncFn,\n             };\n \n-            for arg in inputs {\n-                hir::intravisit::walk_ty(&mut lifetime_collector, arg);\n-            }\n-            lifetime_collector.output_lifetime\n-        };\n+            trace!(\"exist ty from async fn def index: {:#?}\", exist_ty_def_index);\n+            let exist_ty_id = this.generate_existential_type(\n+                exist_ty_node_id,\n+                exist_ty_item,\n+                span,\n+                exist_ty_span,\n+            );\n \n-        let span = match output {\n-            FunctionRetTy::Ty(ty) => ty.span,\n-            FunctionRetTy::Default(span) => *span,\n-        };\n+            (exist_ty_id.node_id, lifetime_params)\n+        });\n \n-        let impl_trait_ty = self.lower_existential_impl_trait(\n-            span, Some(fn_def_id), return_impl_trait_id, |this| {\n-            let output_ty = match output {\n-                FunctionRetTy::Ty(ty) => {\n-                    this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n-                }\n-                FunctionRetTy::Default(span) => {\n-                    let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-                    P(hir::Ty {\n+        let generic_args =\n+            lifetime_params\n+                .iter().cloned()\n+                .map(|(span, hir_name)| {\n+                    let LoweredNodeId { node_id: _, hir_id  } = self.next_id();\n+                    GenericArg::Lifetime(hir::Lifetime {\n                         hir_id,\n-                        node: hir::TyKind::Tup(hir_vec![]),\n-                        span: *span,\n+                        span,\n+                        name: hir::LifetimeName::Param(hir_name),\n                     })\n-                }\n-            };\n-\n-            // \"<Output = T>\"\n-            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-            let future_params = P(hir::GenericArgs {\n-                args: hir_vec![],\n-                bindings: hir_vec![hir::TypeBinding {\n-                    ident: Ident::from_str(FN_OUTPUT_NAME),\n-                    ty: output_ty,\n-                    hir_id,\n-                    span,\n-                }],\n-                parenthesized: false,\n-            });\n+                })\n+                .collect();\n \n-            let future_path =\n-                this.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+        let exist_ty_hir_id = self.lower_node_id(exist_ty_node_id).hir_id;\n+        let exist_ty_ref = hir::TyKind::Def(hir::ItemId { id: exist_ty_hir_id }, generic_args);\n \n-            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-            let mut bounds = vec![\n-                hir::GenericBound::Trait(\n-                    hir::PolyTraitRef {\n-                        trait_ref: hir::TraitRef {\n-                            path: future_path,\n-                            hir_ref_id: hir_id,\n-                        },\n-                        bound_generic_params: hir_vec![],\n-                        span,\n-                    },\n-                    hir::TraitBoundModifier::None\n-                ),\n-            ];\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+        hir::FunctionRetTy::Return(P(hir::Ty {\n+            node: exist_ty_ref,\n+            span,\n+            hir_id,\n+        }))\n+    }\n \n-            if let Some((name, span)) = bound_lifetime {\n-                let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-                bounds.push(hir::GenericBound::Outlives(\n-                    hir::Lifetime { hir_id, name, span }));\n+    /// Turns `-> T` into `Future<Output = T>`\n+    fn lower_async_fn_output_type_to_future_bound(\n+        &mut self,\n+        output: &FunctionRetTy,\n+        fn_def_id: DefId,\n+        span: Span,\n+    ) -> hir::GenericBound {\n+        // Compute the `T` in `Future<Output = T>` from the return type.\n+        let output_ty = match output {\n+            FunctionRetTy::Ty(ty) => {\n+                self.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n             }\n+            FunctionRetTy::Default(ret_ty_span) => {\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+                P(hir::Ty {\n+                    hir_id,\n+                    node: hir::TyKind::Tup(hir_vec![]),\n+                    span: *ret_ty_span,\n+                })\n+            }\n+        };\n \n-            hir::HirVec::from(bounds)\n-        });\n-\n+        // \"<Output = T>\"\n         let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n-        let impl_trait_ty = P(hir::Ty {\n-            node: impl_trait_ty,\n-            span,\n-            hir_id,\n+        let future_params = P(hir::GenericArgs {\n+            args: hir_vec![],\n+            bindings: hir_vec![hir::TypeBinding {\n+                ident: Ident::from_str(FN_OUTPUT_NAME),\n+                ty: output_ty,\n+                hir_id,\n+                span,\n+            }],\n+            parenthesized: false,\n         });\n \n-        hir::FunctionRetTy::Return(impl_trait_ty)\n+        // ::std::future::Future<future_params>\n+        let future_path =\n+            self.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+        hir::GenericBound::Trait(\n+            hir::PolyTraitRef {\n+                trait_ref: hir::TraitRef {\n+                    path: future_path,\n+                    hir_ref_id: hir_id,\n+                },\n+                bound_generic_params: hir_vec![],\n+                span,\n+            },\n+            hir::TraitBoundModifier::None,\n+        )\n     }\n \n     fn lower_param_bound(\n@@ -2437,6 +2471,11 @@ impl<'a> LoweringContext<'a> {\n                     }\n \n                     AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n+\n+                    AnonymousLifetimeMode::Replace(replacement) => {\n+                        let LoweredNodeId { node_id: _, hir_id  } = self.lower_node_id(l.id);\n+                        self.replace_elided_lifetime(hir_id, span, replacement)\n+                    }\n                 },\n             ident => {\n                 self.maybe_collect_in_band_lifetime(ident);\n@@ -2461,6 +2500,39 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    /// Replace a return-position elided lifetime with the elided lifetime\n+    /// from the arguments.\n+    fn replace_elided_lifetime(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        replacement: LtReplacement,\n+    ) -> hir::Lifetime {\n+        let multiple_or_none = match replacement {\n+            LtReplacement::Some(name) => {\n+                return hir::Lifetime {\n+                    hir_id,\n+                    span,\n+                    name: hir::LifetimeName::Param(name),\n+                };\n+            }\n+            LtReplacement::MultipleLifetimes => \"multiple\",\n+            LtReplacement::NoLifetimes => \"none\",\n+        };\n+\n+        let mut err = crate::middle::resolve_lifetime::report_missing_lifetime_specifiers(\n+            self.sess,\n+            span,\n+            1,\n+        );\n+        err.note(&format!(\n+            \"return-position elided lifetimes require exactly one \\\n+             input-position elided lifetime, found {}.\", multiple_or_none));\n+        err.emit();\n+\n+        hir::Lifetime { hir_id, span, name: hir::LifetimeName::Error }\n+    }\n+\n     fn lower_generic_params(\n         &mut self,\n         params: &[GenericParam],\n@@ -2941,6 +3013,7 @@ impl<'a> LoweringContext<'a> {\n                 generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 bounds: self.lower_param_bounds(b, ImplTraitContext::disallowed()),\n                 impl_trait_fn: None,\n+                origin: hir::ExistTyOrigin::ExistentialType,\n             }),\n             ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n@@ -5083,7 +5156,8 @@ impl<'a> LoweringContext<'a> {\n     /// with no explicit lifetime.\n     fn elided_ref_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n-            // Intercept when we are in an impl header and introduce an in-band lifetime.\n+            // Intercept when we are in an impl header or async fn and introduce an in-band\n+            // lifetime.\n             // Hence `impl Foo for &u32` becomes `impl<'f> Foo for &'f u32` for some fresh\n             // `'f`.\n             AnonymousLifetimeMode::CreateParameter => {\n@@ -5099,6 +5173,10 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n \n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n+\n+            AnonymousLifetimeMode::Replace(replacement) => {\n+                self.new_replacement_lifetime(replacement, span)\n+            }\n         }\n     }\n \n@@ -5133,28 +5211,29 @@ impl<'a> LoweringContext<'a> {\n     /// sorts of cases are deprecated. This may therefore report a warning or an\n     /// error, depending on the mode.\n     fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n+        (0..count)\n+            .map(|_| self.elided_path_lifetime(span))\n+            .collect()\n+    }\n+\n+    fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n             // N.B., We intentionally ignore the create-parameter mode here\n             // and instead \"pass through\" to resolve-lifetimes, which will then\n             // report an error. This is because we don't want to support\n             // impl elision for deprecated forms like\n             //\n             //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-            AnonymousLifetimeMode::CreateParameter => {}\n+            AnonymousLifetimeMode::CreateParameter |\n+            // This is the normal case.\n+            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n \n-            AnonymousLifetimeMode::ReportError => {\n-                return (0..count)\n-                    .map(|_| self.new_error_lifetime(None, span))\n-                    .collect();\n+            AnonymousLifetimeMode::Replace(replacement) => {\n+                self.new_replacement_lifetime(replacement, span)\n             }\n \n-            // This is the normal case.\n-            AnonymousLifetimeMode::PassThrough => {}\n+            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n         }\n-\n-        (0..count)\n-            .map(|_| self.new_implicit_lifetime(span))\n-            .collect()\n     }\n \n     /// Invoked to create the lifetime argument(s) for an elided trait object\n@@ -5184,11 +5263,25 @@ impl<'a> LoweringContext<'a> {\n \n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => {}\n+\n+            // We don't need to do any replacement here as this lifetime\n+            // doesn't refer to an elided lifetime elsewhere in the function\n+            // signature.\n+            AnonymousLifetimeMode::Replace(_) => {}\n         }\n \n         self.new_implicit_lifetime(span)\n     }\n \n+    fn new_replacement_lifetime(\n+        &mut self,\n+        replacement: LtReplacement,\n+        span: Span,\n+    ) -> hir::Lifetime {\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+        self.replace_elided_lifetime(hir_id, span, replacement)\n+    }\n+\n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n "}, {"sha": "58a27d3f78eec3fb98379d9f2ad4d18d18cd2ce5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -1799,6 +1799,18 @@ pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n+    pub origin: ExistTyOrigin,\n+}\n+\n+/// Where the existential type came from\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub enum ExistTyOrigin {\n+    /// `existential type Foo: Trait;`\n+    ExistentialType,\n+    /// `-> impl Trait`\n+    ReturnImplTrait,\n+    /// `async fn`\n+    AsyncFn,\n }\n \n /// The various kinds of types recognized by the compiler."}, {"sha": "be9460ad86fc4524384b06298379242fec9222df", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -67,6 +67,9 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// the fn body). (Ultimately, writeback is responsible for this\n     /// check.)\n     pub has_required_region_bounds: bool,\n+\n+    /// The origin of the existential type\n+    pub origin: hir::ExistTyOrigin,\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -326,14 +329,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // There are two regions (`lr` and\n                         // `subst_arg`) which are not relatable. We can't\n                         // find a best choice.\n-                        self.tcx\n+                        let context_name = match opaque_defn.origin {\n+                            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n+                            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n+                            hir::ExistTyOrigin::AsyncFn => \"async fn\",\n+                        };\n+                        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n+                        let mut err = self.tcx\n                             .sess\n-                            .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n-                            .span_label(\n-                                span,\n-                                format!(\"neither `{}` nor `{}` outlives the other\", lr, subst_arg),\n-                            )\n-                            .emit();\n+                            .struct_span_err(span, &msg);\n+\n+                        let lr_name = lr.to_string();\n+                        let subst_arg_name = subst_arg.to_string();\n+                        let label_owned;\n+                        let label = match (&*lr_name, &*subst_arg_name) {\n+                            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n+                            _ => {\n+                                label_owned = format!(\n+                                    \"neither `{}` nor `{}` outlives the other\",\n+                                    lr_name,\n+                                    subst_arg_name,\n+                                );\n+                                &label_owned\n+                            }\n+                        };\n+                        err.span_label(span, label);\n+\n+                        if let hir::ExistTyOrigin::AsyncFn = opaque_defn.origin {\n+                            err.note(\"multiple unrelated lifetimes are not allowed in \\\n+                                     `async fn`.\");\n+                            err.note(\"if you're using argument-position elided lifetimes, consider \\\n+                                switching to a single named lifetime.\");\n+                        }\n+                        err.emit();\n \n                         least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n                         break;\n@@ -692,39 +720,49 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             parent_def_id == tcx.hir()\n                                                 .local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let in_definition_scope = match tcx.hir().find_by_hir_id(opaque_hir_id) {\n+                        let (in_definition_scope, origin) =\n+                            match tcx.hir().find_by_hir_id(opaque_hir_id)\n+                        {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n+                                    origin,\n                                     ..\n-                                }) => parent == self.parent_def_id,\n+                                }) => (parent == self.parent_def_id, origin),\n                                 // named existential types\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: None,\n+                                    origin,\n                                     ..\n-                                }) => may_define_existential_type(\n-                                    tcx,\n-                                    self.parent_def_id,\n-                                    opaque_hir_id,\n+                                }) => (\n+                                    may_define_existential_type(\n+                                        tcx,\n+                                        self.parent_def_id,\n+                                        opaque_hir_id,\n+                                    ),\n+                                    origin,\n                                 ),\n-                                _ => def_scope_default(),\n+                                _ => (def_scope_default(), hir::ExistTyOrigin::ExistentialType),\n                             },\n                             Some(Node::ImplItem(item)) => match item.node {\n-                                hir::ImplItemKind::Existential(_) => may_define_existential_type(\n-                                    tcx,\n-                                    self.parent_def_id,\n-                                    opaque_hir_id,\n+                                hir::ImplItemKind::Existential(_) => (\n+                                    may_define_existential_type(\n+                                        tcx,\n+                                        self.parent_def_id,\n+                                        opaque_hir_id,\n+                                    ),\n+                                    hir::ExistTyOrigin::ExistentialType,\n                                 ),\n-                                _ => def_scope_default(),\n+                                _ => (def_scope_default(), hir::ExistTyOrigin::ExistentialType),\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n                                 tcx.hir().hir_to_string(opaque_hir_id),\n                             ),\n                         };\n                         if in_definition_scope {\n-                            return self.fold_opaque_ty(ty, def_id, substs);\n+                            return self.fold_opaque_ty(ty, def_id, substs, origin);\n                         }\n \n                         debug!(\n@@ -746,6 +784,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n+        origin: hir::ExistTyOrigin,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n@@ -795,6 +834,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                 substs,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),\n+                origin,\n             },\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);"}, {"sha": "3306bcae2123d648c5731c70a8cc64721c4de763", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -2891,7 +2891,7 @@ fn insert_late_bound_lifetimes(\n     }\n }\n \n-fn report_missing_lifetime_specifiers(\n+pub fn report_missing_lifetime_specifiers(\n     sess: &Session,\n     span: Span,\n     count: usize,"}, {"sha": "f92fa2e9799adfdc9da72b04122398a42a64bb9b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -1979,6 +1979,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     ref bounds,\n                     impl_trait_fn,\n                     ref generics,\n+                    origin: _,\n                 }) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);"}, {"sha": "72af51629927d79a814db3a596d922a74060807a", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -79,6 +79,11 @@ async fn async_fn(x: u8) -> u8 {\n     x\n }\n \n+async fn generic_async_fn<T>(x: T) -> T {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n async fn async_fn_with_borrow(x: &u8) -> u8 {\n     await!(wake_and_yield_once());\n     *x\n@@ -96,14 +101,21 @@ fn async_fn_with_impl_future_named_lifetime<'a>(x: &'a u8) -> impl Future<Output\n     }\n }\n \n-async fn async_fn_with_named_lifetime_multiple_args<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n+/* FIXME(cramertj) support when `existential type T<'a, 'b>:;` works\n+async fn async_fn_multiple_args(x: &u8, _y: &u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+*/\n+\n+async fn async_fn_multiple_args_named_lifetime<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n     await!(wake_and_yield_once());\n     *x\n }\n \n fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n     async move {\n-        await!(async_fn_with_borrow(&y))\n+        await!(async_fn_with_borrow_named_lifetime(&y))\n     }\n }\n \n@@ -162,6 +174,7 @@ fn main() {\n         async_nonmove_block,\n         async_closure,\n         async_fn,\n+        generic_async_fn,\n         async_fn_with_internal_borrow,\n         Foo::async_method,\n         |x| {\n@@ -170,15 +183,14 @@ fn main() {\n             }\n         },\n     }\n-\n     test_with_borrow! {\n         async_block_with_borrow_named_lifetime,\n         async_fn_with_borrow,\n         async_fn_with_borrow_named_lifetime,\n         async_fn_with_impl_future_named_lifetime,\n         |x| {\n             async move {\n-                await!(async_fn_with_named_lifetime_multiple_args(x, x))\n+                await!(async_fn_multiple_args_named_lifetime(x, x))\n             }\n         },\n     }"}, {"sha": "fccc4fdb9172591a51f2e92d7f5db1d47d71517a", "filename": "src/test/ui/async-fn-multiple-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -5,7 +5,7 @@\n use std::ops::Add;\n \n async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n-//~^ ERROR multiple different lifetimes used in arguments of `async fn`\n+//~^ ERROR ambiguous lifetime bound in `async fn`\n \n async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n     _: impl for<'a> Add<&'a u8>,\n@@ -14,7 +14,6 @@ async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n ) {}\n \n async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-//~^ ERROR multiple elided lifetimes used\n-//~^^ ERROR missing lifetime specifier\n+//~^ ambiguous lifetime bound in `async fn`\n \n fn main() {}"}, {"sha": "8c3ee2bed830b7bb88cc3990f95b480dc337a625", "filename": "src/test/ui/async-fn-multiple-lifetimes.stderr", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -1,32 +1,20 @@\n-error[E0709]: multiple different lifetimes used in arguments of `async fn`\n-  --> $DIR/async-fn-multiple-lifetimes.rs:7:47\n+error: ambiguous lifetime bound in `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:7:65\n    |\n LL | async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n-   |                                               ^^         ^^ different lifetime here\n-   |                                               |\n-   |                                               first lifetime here\n+   |                                                                 ^ neither `'a` nor `'b` outlives the other\n    |\n-   = help: `async fn` can only accept borrowed values with identical lifetimes\n+   = note: multiple unrelated lifetimes are not allowed in `async fn`.\n+   = note: if you're using argument-position elided lifetimes, consider switching to a single named lifetime.\n \n-error[E0707]: multiple elided lifetimes used in arguments of `async fn`\n-  --> $DIR/async-fn-multiple-lifetimes.rs:16:39\n+error: ambiguous lifetime bound in `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:16:52\n    |\n LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-   |                                       ^       ^ different lifetime here\n-   |                                       |\n-   |                                       first lifetime here\n+   |                                                    ^ the elided lifetimes here do not outlive one another\n    |\n-   = help: consider giving these arguments named lifetimes\n+   = note: multiple unrelated lifetimes are not allowed in `async fn`.\n+   = note: if you're using argument-position elided lifetimes, consider switching to a single named lifetime.\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/async-fn-multiple-lifetimes.rs:16:39\n-   |\n-LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-   |                                       ^ expected lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `_` or `_`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0106, E0707, E0709.\n-For more information about an error, try `rustc --explain E0106`."}, {"sha": "b2624ec92a184c75df4663601e95a0db0982611f", "filename": "src/test/ui/issues/issue-54974.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -0,0 +1,16 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+use std::sync::Arc;\n+\n+trait SomeTrait: Send + Sync + 'static {\n+    fn do_something(&self);\n+}\n+\n+async fn my_task(obj: Arc<SomeTrait>) {\n+    unimplemented!()\n+}\n+\n+fn main() {}"}, {"sha": "6160fbabd96d747556d3d9aaac3437305f843fc4", "filename": "src/test/ui/issues/issue-55324.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -0,0 +1,14 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+use std::future::Future;\n+\n+#[allow(unused)]\n+async fn foo<F: Future<Output = i32>>(x: &i32, future: F) -> i32 {\n+    let y = await!(future);\n+    *x + y\n+}\n+\n+fn main() {}"}, {"sha": "559899194fbe74b00e23566107b991ad4a8eec7f", "filename": "src/test/ui/issues/issue-58885.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+struct Xyz {\n+    a: u64,\n+}\n+\n+trait Foo {}\n+\n+impl Xyz {\n+    async fn do_sth<'a>(\n+        &'a self, foo: &'a dyn Foo\n+    ) -> bool\n+    {\n+        true\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a310653fbce4886492bff22dded2b4618c83a6e8", "filename": "src/test/ui/issues/issue-59001.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749349fc9f7b12f212bca9ba2297e463328cb701/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs?ref=749349fc9f7b12f212bca9ba2297e463328cb701", "patch": "@@ -0,0 +1,17 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+use std::future::Future;\n+\n+#[allow(unused)]\n+async fn enter<'a, F, R>(mut callback: F)\n+where\n+    F: FnMut(&'a mut i32) -> R,\n+    R: Future<Output = ()> + 'a,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() {}"}]}