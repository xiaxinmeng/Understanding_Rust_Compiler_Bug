{"sha": "7b33f7e3e77794e8a44d07d97bc7b62ab9f79981", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMzNmN2UzZTc3Nzk0ZThhNDRkMDdkOTdiYzdiNjJhYjlmNzk5ODE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-20T05:26:36Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-11-02T02:37:10Z"}, "message": "Optimize ObligationForest's NodeState handling.\n\nThis commit partially inlines two functions, `find_cycles_from_node` and\n`mark_as_waiting_from`, at two call sites in order to avoid function\nunnecessary function calls on hot paths.\n\nIt also fully inlines and removes `is_popped`.\n\nThese changes speeds up rustc-benchmarks/inflate-0.1.0 by about 2% when\ndoing debug builds with a stage1 compiler.", "tree": {"sha": "e7a8351f03748b8e79e2b226a0c7d84df2c71978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7a8351f03748b8e79e2b226a0c7d84df2c71978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b33f7e3e77794e8a44d07d97bc7b62ab9f79981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b33f7e3e77794e8a44d07d97bc7b62ab9f79981", "html_url": "https://github.com/rust-lang/rust/commit/7b33f7e3e77794e8a44d07d97bc7b62ab9f79981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b33f7e3e77794e8a44d07d97bc7b62ab9f79981/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4497196ba56e5839bf4ef674851fd06d942c5544", "url": "https://api.github.com/repos/rust-lang/rust/commits/4497196ba56e5839bf4ef674851fd06d942c5544", "html_url": "https://github.com/rust-lang/rust/commit/4497196ba56e5839bf4ef674851fd06d942c5544"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "a2bfa784e8aed0725ca6e50034fd096d3b2703a7", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7b33f7e3e77794e8a44d07d97bc7b62ab9f79981/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b33f7e3e77794e8a44d07d97bc7b62ab9f79981/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=7b33f7e3e77794e8a44d07d97bc7b62ab9f79981", "patch": "@@ -377,8 +377,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n     {\n         let mut stack = self.scratch.take().unwrap();\n \n-        for node in 0..self.nodes.len() {\n-            self.find_cycles_from_node(&mut stack, processor, node);\n+        for index in 0..self.nodes.len() {\n+            // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n+            // hot and the state is almost always `Pending` or `Waiting`. It's\n+            // a win to handle the no-op cases immediately to avoid the cost of\n+            // the function call.\n+            let state = self.nodes[index].state.get();\n+            match state {\n+                NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n+                _ => self.find_cycles_from_node(&mut stack, processor, index),\n+            }\n         }\n \n         self.scratch = Some(stack);\n@@ -476,7 +484,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n         trace\n     }\n \n-    /// Marks all nodes that depend on a pending node as NodeState;:Waiting.\n+    #[inline]\n+    fn mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+        if let Some(parent) = node.parent {\n+            self.mark_as_waiting_from(&self.nodes[parent.get()]);\n+        }\n+\n+        for dependent in &node.dependents {\n+            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+        }\n+    }\n+\n+    /// Marks all nodes that depend on a pending node as NodeState::Waiting.\n     fn mark_as_waiting(&self) {\n         for node in &self.nodes {\n             if node.state.get() == NodeState::Waiting {\n@@ -486,27 +505,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &self.nodes {\n             if node.state.get() == NodeState::Pending {\n-                self.mark_as_waiting_from(node)\n+                self.mark_neighbors_as_waiting_from(node);\n             }\n         }\n     }\n \n     fn mark_as_waiting_from(&self, node: &Node<O>) {\n         match node.state.get() {\n-            NodeState::Pending | NodeState::Done => {},\n             NodeState::Waiting | NodeState::Error | NodeState::OnDfsStack => return,\n-            NodeState::Success => {\n-                node.state.set(NodeState::Waiting);\n-            }\n-        }\n-\n-        if let Some(parent) = node.parent {\n-            self.mark_as_waiting_from(&self.nodes[parent.get()]);\n+            NodeState::Success => node.state.set(NodeState::Waiting),\n+            NodeState::Pending | NodeState::Done => {},\n         }\n \n-        for dependent in &node.dependents {\n-            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n-        }\n+        self.mark_neighbors_as_waiting_from(node);\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts\n@@ -532,28 +543,28 @@ impl<O: ForestObligation> ObligationForest<O> {\n         //     self.nodes[i..] are unchanged\n         for i in 0..self.nodes.len() {\n             match self.nodes[i].state.get() {\n+                NodeState::Pending | NodeState::Waiting => {\n+                    if dead_nodes > 0 {\n+                        self.nodes.swap(i, i - dead_nodes);\n+                        node_rewrites[i] -= dead_nodes;\n+                    }\n+                }\n                 NodeState::Done => {\n                     self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n                     // FIXME(HashMap): why can't I get my key back?\n                     self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                    node_rewrites[i] = nodes_len;\n+                    dead_nodes += 1;\n                 }\n                 NodeState::Error => {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n                     self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    node_rewrites[i] = nodes_len;\n+                    dead_nodes += 1;\n                 }\n-                _ => {}\n-            }\n-\n-            if self.nodes[i].is_popped() {\n-                node_rewrites[i] = nodes_len;\n-                dead_nodes += 1;\n-            } else {\n-                if dead_nodes > 0 {\n-                    self.nodes.swap(i, i - dead_nodes);\n-                    node_rewrites[i] -= dead_nodes;\n-                }\n+                NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n         }\n \n@@ -633,12 +644,4 @@ impl<O> Node<O> {\n             dependents: vec![],\n         }\n     }\n-\n-    fn is_popped(&self) -> bool {\n-        match self.state.get() {\n-            NodeState::Pending | NodeState::Waiting => false,\n-            NodeState::Error | NodeState::Done => true,\n-            NodeState::OnDfsStack | NodeState::Success => unreachable!()\n-        }\n-    }\n }"}]}