{"sha": "b1b6b33c6dbae1c72eebc50ba86a267704c2fade", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYjZiMzNjNmRiYWUxYzcyZWViYzUwYmE4NmEyNjc3MDRjMmZhZGU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-20T04:15:03Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-21T19:19:27Z"}, "message": "Some basic error correction in the parser after a dot", "tree": {"sha": "691d025c92f45ff9cd30c8a662f4d21475bbf4ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/691d025c92f45ff9cd30c8a662f4d21475bbf4ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1b6b33c6dbae1c72eebc50ba86a267704c2fade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1b6b33c6dbae1c72eebc50ba86a267704c2fade", "html_url": "https://github.com/rust-lang/rust/commit/b1b6b33c6dbae1c72eebc50ba86a267704c2fade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1b6b33c6dbae1c72eebc50ba86a267704c2fade/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6ba7fee97e6834f3a72281f88621c10bd562669", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ba7fee97e6834f3a72281f88621c10bd562669", "html_url": "https://github.com/rust-lang/rust/commit/c6ba7fee97e6834f3a72281f88621c10bd562669"}], "stats": {"total": 104, "additions": 62, "deletions": 42}, "files": [{"sha": "34b94b883a4dcfd3cc51a18e9bed057061d3832d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 42, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b1b6b33c6dbae1c72eebc50ba86a267704c2fade/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b6b33c6dbae1c72eebc50ba86a267704c2fade/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b1b6b33c6dbae1c72eebc50ba86a267704c2fade", "patch": "@@ -2355,6 +2355,55 @@ impl<'a> Parser<'a> {\n         )\n     }\n \n+    // Assuming we have just parsed `.foo` (i.e., a dot and an ident), continue\n+    // parsing into an expression.\n+    fn parse_dot_suffix(&mut self, ident: Ident, ident_span: Span, self_value: P<Expr>) -> PResult<'a, P<Expr>> {\n+        let (_, tys, bindings) = if self.eat(&token::ModSep) {\n+            try!(self.expect_lt());\n+            try!(self.parse_generic_values_after_lt())\n+        } else {\n+            (Vec::new(), Vec::new(), Vec::new())\n+        };\n+\n+        if !bindings.is_empty() {\n+            let last_span = self.last_span;\n+            self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n+        }\n+\n+        let lo = self_value.span.lo;\n+\n+        Ok(match self.token {\n+            // expr.f() method call.\n+            token::OpenDelim(token::Paren) => {\n+                let mut es = try!(self.parse_unspanned_seq(\n+                    &token::OpenDelim(token::Paren),\n+                    &token::CloseDelim(token::Paren),\n+                    seq_sep_trailing_allowed(token::Comma),\n+                    |p| Ok(try!(p.parse_expr()))\n+                ));\n+                let hi = self.last_span.hi;\n+\n+                es.insert(0, self_value);\n+                let id = spanned(ident_span.lo, ident_span.hi, ident);\n+                let nd = self.mk_method_call(id, tys, es);\n+                self.mk_expr(lo, hi, nd, None)\n+            }\n+            // Field access.\n+            _ => {\n+                if !tys.is_empty() {\n+                    let last_span = self.last_span;\n+                    self.span_err(last_span,\n+                                  \"field expressions may not \\\n+                                   have type parameters\");\n+                }\n+\n+                let id = spanned(ident_span.lo, ident_span.hi, ident);\n+                let field = self.mk_field(self_value, id);\n+                self.mk_expr(lo, ident_span.hi, field, None)\n+            }\n+        })\n+    }\n+\n     fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let lo = e.span.lo;\n@@ -2364,50 +2413,11 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Dot) {\n                 match self.token {\n                   token::Ident(i, _) => {\n-                    let dot = self.last_span.hi;\n+                    let dot_pos = self.last_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n-                    let (_, tys, bindings) = if self.eat(&token::ModSep) {\n-                        try!(self.expect_lt());\n-                        try!(self.parse_generic_values_after_lt())\n-                    } else {\n-                        (Vec::new(), Vec::new(), Vec::new())\n-                    };\n-\n-                    if !bindings.is_empty() {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n-                    }\n \n-                    // expr.f() method call\n-                    match self.token {\n-                        token::OpenDelim(token::Paren) => {\n-                            let mut es = try!(self.parse_unspanned_seq(\n-                                &token::OpenDelim(token::Paren),\n-                                &token::CloseDelim(token::Paren),\n-                                seq_sep_trailing_allowed(token::Comma),\n-                                |p| Ok(try!(p.parse_expr()))\n-                            ));\n-                            hi = self.last_span.hi;\n-\n-                            es.insert(0, e);\n-                            let id = spanned(dot, hi, i);\n-                            let nd = self.mk_method_call(id, tys, es);\n-                            e = self.mk_expr(lo, hi, nd, None);\n-                        }\n-                        _ => {\n-                            if !tys.is_empty() {\n-                                let last_span = self.last_span;\n-                                self.span_err(last_span,\n-                                              \"field expressions may not \\\n-                                               have type parameters\");\n-                            }\n-\n-                            let id = spanned(dot, hi, i);\n-                            let field = self.mk_field(e, id);\n-                            e = self.mk_expr(lo, hi, field, None);\n-                        }\n-                    }\n+                    e = try!(self.parse_dot_suffix(i, mk_sp(dot_pos, hi), e));\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n@@ -2452,7 +2462,17 @@ impl<'a> Parser<'a> {\n                     self.abort_if_errors();\n \n                   }\n-                  _ => return self.unexpected()\n+                  _ => {\n+                    // TODO special case lifetime\n+                    // FIXME Could factor this out into non_fatal_unexpected or something.\n+                    let actual = self.this_token_to_string();\n+                    self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n+\n+                    let dot_pos = self.last_span.hi;\n+                    e = try!(self.parse_dot_suffix(special_idents::invalid,\n+                                                   mk_sp(dot_pos, dot_pos),\n+                                                   e));\n+                  }\n                 }\n                 continue;\n             }"}]}