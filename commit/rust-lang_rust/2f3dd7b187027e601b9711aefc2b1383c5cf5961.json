{"sha": "2f3dd7b187027e601b9711aefc2b1383c5cf5961", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmM2RkN2IxODcwMjdlNjAxYjk3MTFhZWZjMmIxMzgzYzVjZjU5NjE=", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-05-24T22:39:39Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-05-29T19:05:44Z"}, "message": "Remove remaining calls to `as_local_node_id`", "tree": {"sha": "10fc648b50c7b6dd1b8759605f93205ae2419c7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10fc648b50c7b6dd1b8759605f93205ae2419c7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f3dd7b187027e601b9711aefc2b1383c5cf5961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3dd7b187027e601b9711aefc2b1383c5cf5961", "html_url": "https://github.com/rust-lang/rust/commit/2f3dd7b187027e601b9711aefc2b1383c5cf5961", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f3dd7b187027e601b9711aefc2b1383c5cf5961/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96dd4690c3aa70ec312448c3f2d50e6dc6fb87df", "url": "https://api.github.com/repos/rust-lang/rust/commits/96dd4690c3aa70ec312448c3f2d50e6dc6fb87df", "html_url": "https://github.com/rust-lang/rust/commit/96dd4690c3aa70ec312448c3f2d50e6dc6fb87df"}], "stats": {"total": 93, "additions": 50, "deletions": 43}, "files": [{"sha": "47d10f86d03e27550d2a33e89bcce69c55d9c22c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=2f3dd7b187027e601b9711aefc2b1383c5cf5961", "patch": "@@ -1321,12 +1321,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                     .get_partial_res(bound_pred.bounded_ty.id)\n                                     .map(|d| d.base_res())\n                                 {\n-                                    if let Some(node_id) =\n-                                        self.resolver.definitions().as_local_node_id(def_id)\n-                                    {\n+                                    if let Some(def_id) = def_id.as_local() {\n                                         for param in &generics.params {\n                                             if let GenericParamKind::Type { .. } = param.kind {\n-                                                if node_id == param.id {\n+                                                if def_id\n+                                                    == self\n+                                                        .resolver\n+                                                        .definitions()\n+                                                        .local_def_id(param.id)\n+                                                {\n                                                     add_bounds\n                                                         .entry(param.id)\n                                                         .or_default()"}, {"sha": "c8971c2f9adbd465f6e53395574f1c9c14dcb98b", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=2f3dd7b187027e601b9711aefc2b1383c5cf5961", "patch": "@@ -332,17 +332,6 @@ impl Definitions {\n         })\n     }\n \n-    #[inline]\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if let Some(def_id) = def_id.as_local() {\n-            let node_id = self.def_id_to_node_id[def_id];\n-            if node_id != ast::DUMMY_NODE_ID {\n-                return Some(node_id);\n-            }\n-        }\n-        None\n-    }\n-\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n         self.local_def_id_to_hir_id(def_id)"}, {"sha": "9ee3d989bf3f1e1275290c48cd7efde613672800", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2f3dd7b187027e601b9711aefc2b1383c5cf5961", "patch": "@@ -25,7 +25,7 @@ use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::SyntaxExtension;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def::{self, *};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::bug;\n use rustc_middle::hir::exports::Export;\n@@ -1150,31 +1150,37 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     // Mark the given macro as unused unless its name starts with `_`.\n     // Macro uses will remove items from this set, and the remaining\n     // items will be reported as `unused_macros`.\n-    fn insert_unused_macro(&mut self, ident: Ident, node_id: NodeId, span: Span) {\n+    fn insert_unused_macro(\n+        &mut self,\n+        ident: Ident,\n+        def_id: LocalDefId,\n+        node_id: NodeId,\n+        span: Span,\n+    ) {\n         if !ident.as_str().starts_with('_') {\n-            self.r.unused_macros.insert(node_id, span);\n+            self.r.unused_macros.insert(def_id, (node_id, span));\n         }\n     }\n \n     fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n+        let def_id = self.r.definitions.local_def_id(item.id);\n         let (ext, ident, span, macro_rules) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.macro_rules)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n-                    self.r.proc_macro_stubs.insert(item.id);\n+                    self.r.proc_macro_stubs.insert(def_id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n                 }\n                 None => return parent_scope.macro_rules,\n             },\n             _ => unreachable!(),\n         };\n \n-        let def_id = self.r.definitions.local_def_id(item.id);\n         let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id.to_def_id());\n         self.r.macro_map.insert(def_id.to_def_id(), ext);\n         self.r.local_macro_def_scopes.insert(def_id, parent_scope.module);\n@@ -1196,7 +1202,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n-                self.insert_unused_macro(ident, item.id, span);\n+                self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n             MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n                 parent_macro_rules_scope: parent_scope.macro_rules,\n@@ -1214,7 +1220,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 _ => self.resolve_visibility(&item.vis),\n             };\n             if vis != ty::Visibility::Public {\n-                self.insert_unused_macro(ident, item.id, span);\n+                self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n             self.parent_scope.macro_rules"}, {"sha": "3b49b3b6ff7d274274594292bfb568f56b99785f", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=2f3dd7b187027e601b9711aefc2b1383c5cf5961", "patch": "@@ -1621,11 +1621,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n             let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let node_id = this.r.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n             let suggestion =\n                 if res.is_none() { this.report_missing_type_error(path) } else { None };\n-            this.r.use_injections.push(UseError { err, candidates, node_id, better, suggestion });\n+            this.r.use_injections.push(UseError { err, candidates, def_id, better, suggestion });\n             PartialRes::new(Res::Err)\n         };\n "}, {"sha": "b50f9fe8e907dce0081dfcf549303471fa1670e1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2f3dd7b187027e601b9711aefc2b1383c5cf5961", "patch": "@@ -23,7 +23,7 @@ use rustc_ast::ast::{self, FloatTy, IntTy, NodeId, UintTy};\n use rustc_ast::ast::{Crate, CRATE_NODE_ID};\n use rustc_ast::ast::{ItemKind, Path};\n use rustc_ast::attr;\n-use rustc_ast::node_id::{NodeMap, NodeSet};\n+use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast_pretty::pprust;\n@@ -253,21 +253,31 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-struct UsePlacementFinder {\n-    target_module: NodeId,\n+struct UsePlacementFinder<'d> {\n+    definitions: &'d Definitions,\n+    target_module: LocalDefId,\n     span: Option<Span>,\n     found_use: bool,\n }\n \n-impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n-        let mut finder = UsePlacementFinder { target_module, span: None, found_use: false };\n-        visit::walk_crate(&mut finder, krate);\n-        (finder.span, finder.found_use)\n+impl<'d> UsePlacementFinder<'d> {\n+    fn check(\n+        definitions: &'d Definitions,\n+        krate: &Crate,\n+        target_module: DefId,\n+    ) -> (Option<Span>, bool) {\n+        if let Some(target_module) = target_module.as_local() {\n+            let mut finder =\n+                UsePlacementFinder { definitions, target_module, span: None, found_use: false };\n+            visit::walk_crate(&mut finder, krate);\n+            (finder.span, finder.found_use)\n+        } else {\n+            (None, false)\n+        }\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n+impl<'tcx, 'd> Visitor<'tcx> for UsePlacementFinder<'d> {\n     fn visit_mod(\n         &mut self,\n         module: &'tcx ast::Mod,\n@@ -278,7 +288,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n         if self.span.is_some() {\n             return;\n         }\n-        if node_id != self.target_module {\n+        if self.definitions.local_def_id(node_id) != self.target_module {\n             visit::walk_mod(self, module);\n             return;\n         }\n@@ -611,7 +621,7 @@ struct UseError<'a> {\n     /// Attach `use` statements for these candidates.\n     candidates: Vec<ImportSuggestion>,\n     /// The `NodeId` of the module to place the use-statements in.\n-    node_id: NodeId,\n+    def_id: DefId,\n     /// Whether the diagnostic should state that it's \"better\".\n     better: bool,\n     /// Extra free form suggestion. Currently used to suggest new type parameter.\n@@ -926,8 +936,8 @@ pub struct Resolver<'a> {\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     local_macro_def_scopes: FxHashMap<LocalDefId, Module<'a>>,\n     ast_transform_scopes: FxHashMap<ExpnId, Module<'a>>,\n-    unused_macros: NodeMap<Span>,\n-    proc_macro_stubs: NodeSet,\n+    unused_macros: FxHashMap<LocalDefId, (NodeId, Span)>,\n+    proc_macro_stubs: FxHashSet<LocalDefId>,\n     /// Traces collected during macro resolution and validated when it's complete.\n     single_segment_macro_resolutions:\n         Vec<(Ident, MacroKind, ParentScope<'a>, Option<&'a NameBinding<'a>>)>,\n@@ -2567,10 +2577,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, node_id, better, suggestion } in\n+        for UseError { mut err, candidates, def_id, better, suggestion } in\n             self.use_injections.drain(..)\n         {\n-            let (span, found_use) = UsePlacementFinder::check(krate, node_id);\n+            let (span, found_use) = UsePlacementFinder::check(&self.definitions, krate, def_id);\n             if !candidates.is_empty() {\n                 diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n             } else if let Some((span, msg, sugg, appl)) = suggestion {"}, {"sha": "394d8dc4e1135ded2ba2984c11b9237823302792", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3dd7b187027e601b9711aefc2b1383c5cf5961/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=2f3dd7b187027e601b9711aefc2b1383c5cf5961", "patch": "@@ -333,7 +333,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn check_unused_macros(&mut self) {\n-        for (&node_id, &span) in self.unused_macros.iter() {\n+        for (_, &(node_id, span)) in self.unused_macros.iter() {\n             self.lint_buffer.buffer_lint(UNUSED_MACROS, node_id, span, \"unused macro definition\");\n         }\n     }\n@@ -416,9 +416,9 @@ impl<'a> Resolver<'a> {\n \n         match res {\n             Res::Def(DefKind::Macro(_), def_id) => {\n-                if let Some(node_id) = self.definitions.as_local_node_id(def_id) {\n-                    self.unused_macros.remove(&node_id);\n-                    if self.proc_macro_stubs.contains(&node_id) {\n+                if let Some(def_id) = def_id.as_local() {\n+                    self.unused_macros.remove(&def_id);\n+                    if self.proc_macro_stubs.contains(&def_id) {\n                         self.session.span_err(\n                             path.span,\n                             \"can't use a procedural macro from the same crate that defines it\","}]}