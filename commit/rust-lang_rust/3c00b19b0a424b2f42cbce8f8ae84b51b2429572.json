{"sha": "3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "node_id": "C_kwDOAAsO6NoAKDNjMDBiMTliMGE0MjRiMmY0MmNiY2U4ZjhhZTg0YjUxYjI0Mjk1NzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-21T18:37:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-21T18:37:10Z"}, "message": "Auto merge of #13771 - noritada:feature/release-notes-on-github-releases, r=lnicola\n\nAdd xtask for publishing release notes in Markdown on GitHub Releases from a changelog in AsciiDoc\n\nThis PR provides `xtask publish-release-notes` to convert a changelog written in AsciiDoc to Markdown and update descriptions (release notes) of a corresponding entry on GitHub Releases.\n\nThis AsciiDoc parser is not capable of processing every AsciiDoc document, but I have surveyed a set of existing changelog entries and have confirmed that the following notations used can be converted properly. In the future, I would like to improve the parser to accept any AsciiDoc.  Alternatively, the parser could be moved out of the project.\n\nYour feedback would be appreciated!\n\nCloses #13191\n\n### Supported AsciiDoc syntax\n\nmany occurrences\n- [x] documentation header\n- [x] section header\n- [x] `*`-prefixed basic unordered single level list item\n- [x] list continuation using `+`\n- [x] block image macro `image::...[]` with empty alt\n- [x] block image macro `image::...[]` with non-empty alt\n- [x] block video marco `video::...[]` with `options=loop`\n- [x] inline hard line break `+`\n- [x] inline custom macro `commit:...[]`\n- [x] inline custom macro `release:...[]`\n- [x] inline custom macro `pr:...[]`\n- [x] inline unconstrained bold text `**...**`\n- [x] inline constrained monospace ``` `...`  ```\n\n[thisweek/_posts/2019-07-24-changelog-0.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/tree/src/thisweek/_posts#:~:text=2019%2D07%2D24%2Dchangelog%2D0.adoc)\n- [x] paragraphs\n- [x] mixture of `*` and `-` for unordered list item prefix\n- [x] inline external link `https://...[]`\n\n[thisweek/_posts/2020-01-13-changelog-7.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/tree/src/thisweek/_posts#:~:text=2020%2D01%2D13%2Dchangelog%2D7.adoc)\n- [x] list item with multiline principal text with indent\n- [x] inline image macro `image:...[]`\n\n[thisweek/_posts/2020-03-02-changelog-14.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/blob/src/thisweek/_posts/2020-03-02-changelog-14.adoc)\n- [x] empty lines between list items\n- [x] nested unordered list item with `**`\n- [x] inline macro `kbd:[...]`\n\n[thisweek/_posts/2020-03-16-changelog-16.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/blob/src/thisweek/_posts/2020-03-16-changelog-16.adoc)\n- [x] `[source]`-prefixed listing\n\n[thisweek/_posts/2020-04-06-changelog-19.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/blob/src/thisweek/_posts/2020-04-06-changelog-19.adoc)\n- [x] list item with multiline principal text without indent\n- [x] `[source,lang]`-prefixed listing\n- [x] `.`-prefiexed ordered list item\n- [x] list item immediately after list continuation paragraph without an empty line in between\n\n[thisweek/_posts/2020-04-20-changelog-21.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/blob/src/thisweek/_posts/2020-04-20-changelog-21.adoc)\n- [x] title line for block image\n\n[thisweek/_posts/2020-12-21-changelog-56.adoc](https://github.com/rust-analyzer/rust-analyzer.github.io/blob/src/thisweek/_posts/2020-12-21-changelog-56.adoc)\n- [x] block video `video::...[]` with `options=\"autoplay,loop\"`", "tree": {"sha": "aec726bbd9e165f91b264395630d3fad43e53b4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aec726bbd9e165f91b264395630d3fad43e53b4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "html_url": "https://github.com/rust-lang/rust/commit/3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "761b127c473f8324bc9fe46a3fb502bb0a8ba6ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/761b127c473f8324bc9fe46a3fb502bb0a8ba6ba", "html_url": "https://github.com/rust-lang/rust/commit/761b127c473f8324bc9fe46a3fb502bb0a8ba6ba"}, {"sha": "fccc094712c734de24ba87ed3f4290fa17632a8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fccc094712c734de24ba87ed3f4290fa17632a8b", "html_url": "https://github.com/rust-lang/rust/commit/fccc094712c734de24ba87ed3f4290fa17632a8b"}], "stats": {"total": 935, "additions": 932, "deletions": 3}, "files": [{"sha": "cdab6b09928cd207a3e64acc7989e54b7a12aa4c", "filename": "docs/dev/README.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -200,7 +200,7 @@ Look for `fn benchmark_xxx` tests for a quick way to reproduce performance probl\n \n ## Release Process\n \n-Release process is handled by `release`, `dist` and `promote` xtasks, `release` being the main one.\n+Release process is handled by `release`, `dist`, `publish-release-notes` and `promote` xtasks, `release` being the main one.\n \n `release` assumes that you have checkouts of `rust-analyzer`, `rust-analyzer.github.io`, and `rust-lang/rust` in the same directory:\n \n@@ -231,8 +231,9 @@ Release steps:\n    * create a new changelog in `rust-analyzer.github.io`\n 3. While the release is in progress, fill in the changelog\n 4. Commit & push the changelog\n-5. Tweet\n-6. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's subtree.\n+5. Run `cargo xtask publish-release-notes <CHANGELOG>` -- this will convert the changelog entry in AsciiDoc to Markdown and update the body of GitHub Releases entry.\n+6. Tweet\n+7. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's subtree.\n    Self-approve the PR.\n \n If the GitHub Actions release fails because of a transient problem like a timeout, you can re-run the job from the Actions console."}, {"sha": "21004797014e8645ce89c95a1cfbf01d4ed40fdc", "filename": "xtask/src/flags.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fflags.rs?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -34,6 +34,13 @@ xflags::xflags! {\n         cmd dist {\n             optional --client-patch-version version: String\n         }\n+        /// Read a changelog AsciiDoc file and update the GitHub Releases entry in Markdown.\n+        cmd publish-release-notes {\n+            /// Only run conversion and show the result.\n+            optional --dry-run\n+            /// Target changelog file.\n+            required changelog: String\n+        }\n         cmd metrics {\n             optional --dry-run\n         }\n@@ -59,6 +66,7 @@ pub enum XtaskCmd {\n     Release(Release),\n     Promote(Promote),\n     Dist(Dist),\n+    PublishReleaseNotes(PublishReleaseNotes),\n     Metrics(Metrics),\n     Bb(Bb),\n }\n@@ -90,6 +98,13 @@ pub struct Dist {\n     pub client_patch_version: Option<String>,\n }\n \n+#[derive(Debug)]\n+pub struct PublishReleaseNotes {\n+    pub changelog: String,\n+\n+    pub dry_run: bool,\n+}\n+\n #[derive(Debug)]\n pub struct Metrics {\n     pub dry_run: bool,"}, {"sha": "6a45033ada3ba7e92ce7c6339111f3f188b3557f", "filename": "xtask/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -15,6 +15,7 @@ mod flags;\n mod install;\n mod release;\n mod dist;\n+mod publish;\n mod metrics;\n \n use anyhow::bail;\n@@ -36,6 +37,7 @@ fn main() -> anyhow::Result<()> {\n         flags::XtaskCmd::Release(cmd) => cmd.run(sh),\n         flags::XtaskCmd::Promote(cmd) => cmd.run(sh),\n         flags::XtaskCmd::Dist(cmd) => cmd.run(sh),\n+        flags::XtaskCmd::PublishReleaseNotes(cmd) => cmd.run(sh),\n         flags::XtaskCmd::Metrics(cmd) => cmd.run(sh),\n         flags::XtaskCmd::Bb(cmd) => {\n             {"}, {"sha": "79b5f3d2f61b7eaf552c06b0978278d0b276eb1b", "filename": "xtask/src/publish.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fpublish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fpublish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpublish.rs?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -0,0 +1,109 @@\n+mod notes;\n+\n+use crate::flags;\n+use anyhow::{anyhow, bail, Result};\n+use std::env;\n+use xshell::{cmd, Shell};\n+\n+impl flags::PublishReleaseNotes {\n+    pub(crate) fn run(self, sh: &Shell) -> Result<()> {\n+        let asciidoc = sh.read_file(&self.changelog)?;\n+        let mut markdown = notes::convert_asciidoc_to_markdown(std::io::Cursor::new(&asciidoc))?;\n+        let file_name = check_file_name(self.changelog)?;\n+        let tag_name = &file_name[0..10];\n+        let original_changelog_url = create_original_changelog_url(&file_name);\n+        let additional_paragraph =\n+            format!(\"\\nSee also [original changelog]({original_changelog_url}).\");\n+        markdown.push_str(&additional_paragraph);\n+        if self.dry_run {\n+            println!(\"{markdown}\");\n+        } else {\n+            update_release(sh, tag_name, &markdown)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn check_file_name<P: AsRef<std::path::Path>>(path: P) -> Result<String> {\n+    let file_name = path\n+        .as_ref()\n+        .file_name()\n+        .ok_or_else(|| anyhow!(\"file name is not specified as `changelog`\"))?\n+        .to_string_lossy();\n+\n+    let mut chars = file_name.chars();\n+    if file_name.len() >= 10\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap() == '-'\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap() == '-'\n+        && chars.next().unwrap().is_ascii_digit()\n+        && chars.next().unwrap().is_ascii_digit()\n+    {\n+        Ok(file_name.to_string())\n+    } else {\n+        bail!(\"unexpected file name format; no date information prefixed\")\n+    }\n+}\n+\n+fn create_original_changelog_url(file_name: &str) -> String {\n+    let year = &file_name[0..4];\n+    let month = &file_name[5..7];\n+    let day = &file_name[8..10];\n+    let mut stem = &file_name[11..];\n+    if let Some(stripped) = stem.strip_suffix(\".adoc\") {\n+        stem = stripped;\n+    }\n+    format!(\"https://rust-analyzer.github.io/thisweek/{year}/{month}/{day}/{stem}.html\")\n+}\n+\n+fn update_release(sh: &Shell, tag_name: &str, release_notes: &str) -> Result<()> {\n+    let token = match env::var(\"GITHUB_TOKEN\") {\n+        Ok(token) => token,\n+        Err(_) => bail!(\"Please obtain a personal access token from https://github.com/settings/tokens and set the `GITHUB_TOKEN` environment variable.\"),\n+    };\n+    let accept = \"Accept: application/vnd.github+json\";\n+    let authorization = format!(\"Authorization: Bearer {token}\");\n+    let api_version = \"X-GitHub-Api-Version: 2022-11-28\";\n+    let release_url = \"https://api.github.com/repos/rust-lang/rust-analyzer/releases\";\n+\n+    let release_json = cmd!(\n+        sh,\n+        \"curl -sf -H {accept} -H {authorization} -H {api_version} {release_url}/tags/{tag_name}\"\n+    )\n+    .read()?;\n+    let release_id = cmd!(sh, \"jq .id\").stdin(release_json).read()?;\n+\n+    let mut patch = String::new();\n+    write_json::object(&mut patch)\n+        .string(\"tag_name\", tag_name)\n+        .string(\"target_commitish\", \"master\")\n+        .string(\"name\", tag_name)\n+        .string(\"body\", release_notes)\n+        .bool(\"draft\", false)\n+        .bool(\"prerelease\", false);\n+    let _ = cmd!(\n+        sh,\n+        \"curl -sf -X PATCH -H {accept} -H {authorization} -H {api_version} {release_url}/{release_id} -d {patch}\"\n+    )\n+    .read()?;\n+\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn original_changelog_url_creation() {\n+        let input = \"2019-07-24-changelog-0.adoc\";\n+        let actual = create_original_changelog_url(input);\n+        let expected = \"https://rust-analyzer.github.io/thisweek/2019/07/24/changelog-0.html\";\n+        assert_eq!(actual, expected);\n+    }\n+}"}, {"sha": "c30267295bf41b4e74dc8a65390b2b3d9d39d602", "filename": "xtask/src/publish/notes.rs", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fpublish%2Fnotes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Fsrc%2Fpublish%2Fnotes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpublish%2Fnotes.rs?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -0,0 +1,631 @@\n+use anyhow::{anyhow, bail};\n+use std::{\n+    borrow::Cow,\n+    io::{BufRead, Lines},\n+    iter::Peekable,\n+};\n+\n+const LISTING_DELIMITER: &str = \"----\";\n+const IMAGE_BLOCK_PREFIX: &str = \"image::\";\n+const VIDEO_BLOCK_PREFIX: &str = \"video::\";\n+\n+struct Converter<'a, 'b, R: BufRead> {\n+    iter: &'a mut Peekable<Lines<R>>,\n+    output: &'b mut String,\n+}\n+\n+impl<'a, 'b, R: BufRead> Converter<'a, 'b, R> {\n+    fn new(iter: &'a mut Peekable<Lines<R>>, output: &'b mut String) -> Self {\n+        Self { iter, output }\n+    }\n+\n+    fn process(&mut self) -> anyhow::Result<()> {\n+        self.process_document_header()?;\n+        self.skip_blank_lines()?;\n+        self.output.push('\\n');\n+\n+        loop {\n+            let line = self.iter.peek().unwrap().as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+            if get_title(line).is_some() {\n+                let line = self.iter.next().unwrap().unwrap();\n+                let (level, title) = get_title(&line).unwrap();\n+                self.write_title(level, title);\n+            } else if get_list_item(line).is_some() {\n+                self.process_list()?;\n+            } else if line.starts_with('[') {\n+                self.process_source_code_block(0)?;\n+            } else if line.starts_with(LISTING_DELIMITER) {\n+                self.process_listing_block(None, 0)?;\n+            } else if line.starts_with('.') {\n+                self.process_block_with_title(0)?;\n+            } else if line.starts_with(IMAGE_BLOCK_PREFIX) {\n+                self.process_image_block(None, 0)?;\n+            } else if line.starts_with(VIDEO_BLOCK_PREFIX) {\n+                self.process_video_block(None, 0)?;\n+            } else {\n+                self.process_paragraph(0, |line| line.is_empty())?;\n+            }\n+\n+            self.skip_blank_lines()?;\n+            if self.iter.peek().is_none() {\n+                break;\n+            }\n+            self.output.push('\\n');\n+        }\n+        Ok(())\n+    }\n+\n+    fn process_document_header(&mut self) -> anyhow::Result<()> {\n+        self.process_document_title()?;\n+\n+        while let Some(line) = self.iter.next() {\n+            let line = line?;\n+            if line.is_empty() {\n+                break;\n+            }\n+            if !line.starts_with(':') {\n+                self.write_line(&line, 0)\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn process_document_title(&mut self) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if let Some((level, title)) = get_title(&line) {\n+                let title = process_inline_macros(title)?;\n+                if level == 1 {\n+                    self.write_title(level, &title);\n+                    return Ok(());\n+                }\n+            }\n+        }\n+        bail!(\"document title not found\")\n+    }\n+\n+    fn process_list(&mut self) -> anyhow::Result<()> {\n+        let mut nesting = ListNesting::new();\n+        while let Some(line) = self.iter.peek() {\n+            let line = line.as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+\n+            if get_list_item(line).is_some() {\n+                let line = self.iter.next().unwrap()?;\n+                let line = process_inline_macros(&line)?;\n+                let (marker, item) = get_list_item(&line).unwrap();\n+                nesting.set_current(marker);\n+                self.write_list_item(item, &nesting);\n+                self.process_paragraph(nesting.indent(), |line| {\n+                    line.is_empty() || get_list_item(line).is_some() || line == \"+\"\n+                })?;\n+            } else if line == \"+\" {\n+                let _ = self.iter.next().unwrap()?;\n+                let line = self\n+                    .iter\n+                    .peek()\n+                    .ok_or_else(|| anyhow!(\"list continuation unexpectedly terminated\"))?;\n+                let line = line.as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+\n+                let indent = nesting.indent();\n+                if line.starts_with('[') {\n+                    self.write_line(\"\", 0);\n+                    self.process_source_code_block(indent)?;\n+                } else if line.starts_with(LISTING_DELIMITER) {\n+                    self.write_line(\"\", 0);\n+                    self.process_listing_block(None, indent)?;\n+                } else if line.starts_with('.') {\n+                    self.write_line(\"\", 0);\n+                    self.process_block_with_title(indent)?;\n+                } else if line.starts_with(IMAGE_BLOCK_PREFIX) {\n+                    self.write_line(\"\", 0);\n+                    self.process_image_block(None, indent)?;\n+                } else if line.starts_with(VIDEO_BLOCK_PREFIX) {\n+                    self.write_line(\"\", 0);\n+                    self.process_video_block(None, indent)?;\n+                } else {\n+                    self.write_line(\"\", 0);\n+                    let current = nesting.current().unwrap();\n+                    self.process_paragraph(indent, |line| {\n+                        line.is_empty()\n+                            || get_list_item(line).filter(|(m, _)| m == current).is_some()\n+                            || line == \"+\"\n+                    })?;\n+                }\n+            } else {\n+                break;\n+            }\n+            self.skip_blank_lines()?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn process_source_code_block(&mut self, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if let Some(styles) = line.strip_prefix(\"[source\").and_then(|s| s.strip_suffix(']')) {\n+                let mut styles = styles.split(',');\n+                if !styles.next().unwrap().is_empty() {\n+                    bail!(\"not a source code block\");\n+                }\n+                let language = styles.next();\n+                return self.process_listing_block(language, level);\n+            }\n+        }\n+        bail!(\"not a source code block\")\n+    }\n+\n+    fn process_listing_block(&mut self, style: Option<&str>, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if line == LISTING_DELIMITER {\n+                self.write_indent(level);\n+                self.output.push_str(\"```\");\n+                if let Some(style) = style {\n+                    self.output.push_str(style);\n+                }\n+                self.output.push('\\n');\n+                while let Some(line) = self.iter.next() {\n+                    let line = line?;\n+                    if line == LISTING_DELIMITER {\n+                        self.write_line(\"```\", level);\n+                        return Ok(());\n+                    } else {\n+                        self.write_line(&line, level);\n+                    }\n+                }\n+                bail!(\"listing block is not terminated\")\n+            }\n+        }\n+        bail!(\"not a listing block\")\n+    }\n+\n+    fn process_block_with_title(&mut self, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            let title =\n+                line.strip_prefix('.').ok_or_else(|| anyhow!(\"extraction of the title failed\"))?;\n+\n+            let line = self\n+                .iter\n+                .peek()\n+                .ok_or_else(|| anyhow!(\"target block for the title is not found\"))?;\n+            let line = line.as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+            if line.starts_with(IMAGE_BLOCK_PREFIX) {\n+                return self.process_image_block(Some(title), level);\n+            } else if line.starts_with(VIDEO_BLOCK_PREFIX) {\n+                return self.process_video_block(Some(title), level);\n+            } else {\n+                bail!(\"title for that block type is not supported\");\n+            }\n+        }\n+        bail!(\"not a title\")\n+    }\n+\n+    fn process_image_block(&mut self, caption: Option<&str>, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if let Some((url, attrs)) = parse_media_block(&line, IMAGE_BLOCK_PREFIX) {\n+                let alt = if let Some(stripped) =\n+                    attrs.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                {\n+                    stripped\n+                } else {\n+                    attrs\n+                };\n+                if let Some(caption) = caption {\n+                    self.write_caption_line(caption, level);\n+                }\n+                self.write_indent(level);\n+                self.output.push_str(\"![\");\n+                self.output.push_str(alt);\n+                self.output.push_str(\"](\");\n+                self.output.push_str(url);\n+                self.output.push_str(\")\\n\");\n+                return Ok(());\n+            }\n+        }\n+        bail!(\"not a image block\")\n+    }\n+\n+    fn process_video_block(&mut self, caption: Option<&str>, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if let Some((url, attrs)) = parse_media_block(&line, VIDEO_BLOCK_PREFIX) {\n+                let html_attrs = match attrs {\n+                    \"options=loop\" => \"controls loop\",\n+                    r#\"options=\"autoplay,loop\"\"# => \"autoplay controls loop\",\n+                    _ => bail!(\"unsupported video syntax\"),\n+                };\n+                if let Some(caption) = caption {\n+                    self.write_caption_line(caption, level);\n+                }\n+                self.write_indent(level);\n+                self.output.push_str(r#\"<video src=\"\"#);\n+                self.output.push_str(url);\n+                self.output.push_str(r#\"\" \"#);\n+                self.output.push_str(html_attrs);\n+                self.output.push_str(\">Your browser does not support the video tag.</video>\\n\");\n+                return Ok(());\n+            }\n+        }\n+        bail!(\"not a video block\")\n+    }\n+\n+    fn process_paragraph<P>(&mut self, level: usize, predicate: P) -> anyhow::Result<()>\n+    where\n+        P: Fn(&str) -> bool,\n+    {\n+        while let Some(line) = self.iter.peek() {\n+            let line = line.as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+            if predicate(line) {\n+                break;\n+            }\n+\n+            self.write_indent(level);\n+            let line = self.iter.next().unwrap()?;\n+            let line = line.trim_start();\n+            let line = process_inline_macros(line)?;\n+            if let Some(stripped) = line.strip_suffix('+') {\n+                self.output.push_str(stripped);\n+                self.output.push('\\\\');\n+            } else {\n+                self.output.push_str(&line);\n+            }\n+            self.output.push('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn skip_blank_lines(&mut self) -> anyhow::Result<()> {\n+        while let Some(line) = self.iter.peek() {\n+            if !line.as_deref().unwrap().is_empty() {\n+                break;\n+            }\n+            self.iter.next().unwrap()?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_title(&mut self, indent: usize, title: &str) {\n+        for _ in 0..indent {\n+            self.output.push('#');\n+        }\n+        self.output.push(' ');\n+        self.output.push_str(title);\n+        self.output.push('\\n');\n+    }\n+\n+    fn write_list_item(&mut self, item: &str, nesting: &ListNesting) {\n+        let (marker, indent) = nesting.marker();\n+        self.write_indent(indent);\n+        self.output.push_str(marker);\n+        self.output.push_str(item);\n+        self.output.push('\\n');\n+    }\n+\n+    fn write_caption_line(&mut self, caption: &str, indent: usize) {\n+        self.write_indent(indent);\n+        self.output.push('_');\n+        self.output.push_str(caption);\n+        self.output.push_str(\"_\\\\\\n\");\n+    }\n+\n+    fn write_indent(&mut self, indent: usize) {\n+        for _ in 0..indent {\n+            self.output.push(' ');\n+        }\n+    }\n+\n+    fn write_line(&mut self, line: &str, indent: usize) {\n+        self.write_indent(indent);\n+        self.output.push_str(line);\n+        self.output.push('\\n');\n+    }\n+}\n+\n+pub(crate) fn convert_asciidoc_to_markdown<R>(input: R) -> anyhow::Result<String>\n+where\n+    R: BufRead,\n+{\n+    let mut output = String::new();\n+    let mut iter = input.lines().peekable();\n+\n+    let mut converter = Converter::new(&mut iter, &mut output);\n+    converter.process()?;\n+\n+    Ok(output)\n+}\n+\n+fn get_title(line: &str) -> Option<(usize, &str)> {\n+    strip_prefix_symbol(line, '=')\n+}\n+\n+fn get_list_item(line: &str) -> Option<(ListMarker, &str)> {\n+    const HYPHEN_MARKER: &str = \"- \";\n+    if let Some(text) = line.strip_prefix(HYPHEN_MARKER) {\n+        Some((ListMarker::Hyphen, text))\n+    } else if let Some((count, text)) = strip_prefix_symbol(line, '*') {\n+        Some((ListMarker::Asterisk(count), text))\n+    } else if let Some((count, text)) = strip_prefix_symbol(line, '.') {\n+        Some((ListMarker::Dot(count), text))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn strip_prefix_symbol(line: &str, symbol: char) -> Option<(usize, &str)> {\n+    let mut iter = line.chars();\n+    if iter.next()? != symbol {\n+        return None;\n+    }\n+    let mut count = 1;\n+    loop {\n+        match iter.next() {\n+            Some(ch) if ch == symbol => {\n+                count += 1;\n+            }\n+            Some(' ') => {\n+                break;\n+            }\n+            _ => return None,\n+        }\n+    }\n+    Some((count, iter.as_str()))\n+}\n+\n+fn parse_media_block<'a>(line: &'a str, prefix: &str) -> Option<(&'a str, &'a str)> {\n+    if let Some(line) = line.strip_prefix(prefix) {\n+        if let Some((url, rest)) = line.split_once('[') {\n+            if let Some(attrs) = rest.strip_suffix(']') {\n+                return Some((url, attrs));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+#[derive(Debug)]\n+struct ListNesting(Vec<ListMarker>);\n+\n+impl ListNesting {\n+    fn new() -> Self {\n+        Self(Vec::<ListMarker>::with_capacity(6))\n+    }\n+\n+    fn current(&mut self) -> Option<&ListMarker> {\n+        self.0.last()\n+    }\n+\n+    fn set_current(&mut self, marker: ListMarker) {\n+        let Self(markers) = self;\n+        if let Some(index) = markers.iter().position(|m| *m == marker) {\n+            markers.truncate(index + 1);\n+        } else {\n+            markers.push(marker);\n+        }\n+    }\n+\n+    fn indent(&self) -> usize {\n+        self.0.iter().map(|m| m.in_markdown().len()).sum()\n+    }\n+\n+    fn marker(&self) -> (&str, usize) {\n+        let Self(markers) = self;\n+        let indent = markers.iter().take(markers.len() - 1).map(|m| m.in_markdown().len()).sum();\n+        let marker = match markers.last() {\n+            None => \"\",\n+            Some(marker) => marker.in_markdown(),\n+        };\n+        (marker, indent)\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum ListMarker {\n+    Asterisk(usize),\n+    Hyphen,\n+    Dot(usize),\n+}\n+\n+impl ListMarker {\n+    fn in_markdown(&self) -> &str {\n+        match self {\n+            ListMarker::Asterisk(_) => \"- \",\n+            ListMarker::Hyphen => \"- \",\n+            ListMarker::Dot(_) => \"1. \",\n+        }\n+    }\n+}\n+\n+fn process_inline_macros(line: &str) -> anyhow::Result<Cow<'_, str>> {\n+    let mut chars = line.char_indices();\n+    loop {\n+        let (start, end, a_macro) = match get_next_line_component(&mut chars) {\n+            Component::None => break,\n+            Component::Text => continue,\n+            Component::Macro(s, e, m) => (s, e, m),\n+        };\n+        let mut src = line.chars();\n+        let mut processed = String::new();\n+        for _ in 0..start {\n+            processed.push(src.next().unwrap());\n+        }\n+        processed.push_str(a_macro.process()?.as_str());\n+        for _ in start..end {\n+            let _ = src.next().unwrap();\n+        }\n+        let mut pos = end;\n+\n+        loop {\n+            let (start, end, a_macro) = match get_next_line_component(&mut chars) {\n+                Component::None => break,\n+                Component::Text => continue,\n+                Component::Macro(s, e, m) => (s, e, m),\n+            };\n+            for _ in pos..start {\n+                processed.push(src.next().unwrap());\n+            }\n+            processed.push_str(a_macro.process()?.as_str());\n+            for _ in start..end {\n+                let _ = src.next().unwrap();\n+            }\n+            pos = end;\n+        }\n+        for ch in src {\n+            processed.push(ch);\n+        }\n+        return Ok(Cow::Owned(processed));\n+    }\n+    Ok(Cow::Borrowed(line))\n+}\n+\n+fn get_next_line_component(chars: &mut std::str::CharIndices<'_>) -> Component {\n+    let (start, mut macro_name) = match chars.next() {\n+        None => return Component::None,\n+        Some((_, ch)) if ch == ' ' || !ch.is_ascii() => return Component::Text,\n+        Some((pos, ch)) => (pos, String::from(ch)),\n+    };\n+    loop {\n+        match chars.next() {\n+            None => return Component::None,\n+            Some((_, ch)) if ch == ' ' || !ch.is_ascii() => return Component::Text,\n+            Some((_, ':')) => break,\n+            Some((_, ch)) => macro_name.push(ch),\n+        }\n+    }\n+\n+    let mut macro_target = String::new();\n+    loop {\n+        match chars.next() {\n+            None => return Component::None,\n+            Some((_, ' ')) => return Component::Text,\n+            Some((_, '[')) => break,\n+            Some((_, ch)) => macro_target.push(ch),\n+        }\n+    }\n+\n+    let mut attr_value = String::new();\n+    let end = loop {\n+        match chars.next() {\n+            None => return Component::None,\n+            Some((pos, ']')) => break pos + 1,\n+            Some((_, ch)) => attr_value.push(ch),\n+        }\n+    };\n+\n+    Component::Macro(start, end, Macro::new(macro_name, macro_target, attr_value))\n+}\n+\n+enum Component {\n+    None,\n+    Text,\n+    Macro(usize, usize, Macro),\n+}\n+\n+struct Macro {\n+    name: String,\n+    target: String,\n+    attrs: String,\n+}\n+\n+impl Macro {\n+    fn new(name: String, target: String, attrs: String) -> Self {\n+        Self { name, target, attrs }\n+    }\n+\n+    fn process(&self) -> anyhow::Result<String> {\n+        let name = &self.name;\n+        let text = match name.as_str() {\n+            \"https\" => {\n+                let url = &self.target;\n+                let anchor_text = &self.attrs;\n+                format!(\"[{anchor_text}](https:{url})\")\n+            }\n+            \"image\" => {\n+                let url = &self.target;\n+                let alt = &self.attrs;\n+                format!(\"![{alt}]({url})\")\n+            }\n+            \"kbd\" => {\n+                let keys = self.attrs.split('+').map(|k| Cow::Owned(format!(\"<kbd>{k}</kbd>\")));\n+                keys.collect::<Vec<_>>().join(\"+\")\n+            }\n+            \"pr\" => {\n+                let pr = &self.target;\n+                let url = format!(\"https://github.com/rust-analyzer/rust-analyzer/pull/{pr}\");\n+                format!(\"[`#{pr}`]({url})\")\n+            }\n+            \"commit\" => {\n+                let hash = &self.target;\n+                let short = &hash[0..7];\n+                let url = format!(\"https://github.com/rust-analyzer/rust-analyzer/commit/{hash}\");\n+                format!(\"[`{short}`]({url})\")\n+            }\n+            \"release\" => {\n+                let date = &self.target;\n+                let url = format!(\"https://github.com/rust-analyzer/rust-analyzer/releases/{date}\");\n+                format!(\"[`{date}`]({url})\")\n+            }\n+            _ => bail!(\"macro not supported: {name}\"),\n+        };\n+        Ok(text)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use std::fs::read_to_string;\n+\n+    #[test]\n+    fn test_asciidoc_to_markdown_conversion() {\n+        let input = read_to_string(\"test_data/input.adoc\").unwrap();\n+        let expected = read_to_string(\"test_data/expected.md\").unwrap();\n+        let actual = convert_asciidoc_to_markdown(std::io::Cursor::new(&input)).unwrap();\n+\n+        assert_eq!(actual, expected);\n+    }\n+\n+    macro_rules! test_inline_macro_processing {\n+        ($((\n+            $name:ident,\n+            $input:expr,\n+            $expected:expr\n+        ),)*) => ($(\n+            #[test]\n+            fn $name() {\n+                let input = $input;\n+                let actual = process_inline_macros(&input).unwrap();\n+                let expected = $expected;\n+                assert_eq!(actual, expected)\n+            }\n+        )*);\n+    }\n+\n+    test_inline_macro_processing! {\n+        (inline_macro_processing_for_empty_line, \"\", \"\"),\n+        (inline_macro_processing_for_line_with_no_macro, \"foo bar\", \"foo bar\"),\n+        (\n+            inline_macro_processing_for_macro_in_line_start,\n+            \"kbd::[Ctrl+T] foo\",\n+            \"<kbd>Ctrl</kbd>+<kbd>T</kbd> foo\"\n+        ),\n+        (\n+            inline_macro_processing_for_macro_in_line_end,\n+            \"foo kbd::[Ctrl+T]\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd>\"\n+        ),\n+        (\n+            inline_macro_processing_for_macro_in_the_middle_of_line,\n+            \"foo kbd::[Ctrl+T] foo\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd> foo\"\n+        ),\n+        (\n+            inline_macro_processing_for_several_macros,\n+            \"foo kbd::[Ctrl+T] foo kbd::[Enter] foo\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd> foo <kbd>Enter</kbd> foo\"\n+        ),\n+        (\n+            inline_macro_processing_for_several_macros_without_text_in_between,\n+            \"foo kbd::[Ctrl+T]kbd::[Enter] foo\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd><kbd>Enter</kbd> foo\"\n+        ),\n+    }\n+}"}, {"sha": "19c940c67bdc52ebcac6eea58a8a826c7c8a5b97", "filename": "xtask/test_data/expected.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Ftest_data%2Fexpected.md", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Ftest_data%2Fexpected.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftest_data%2Fexpected.md?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -0,0 +1,81 @@\n+# Changelog #256\n+\n+Hello!\n+\n+Commit: [`0123456`](https://github.com/rust-analyzer/rust-analyzer/commit/0123456789abcdef0123456789abcdef01234567) \\\n+Release: [`2022-01-01`](https://github.com/rust-analyzer/rust-analyzer/releases/2022-01-01)\n+\n+## New Features\n+\n+- **BREAKING** [`#1111`](https://github.com/rust-analyzer/rust-analyzer/pull/1111) shortcut <kbd>ctrl</kbd>+<kbd>r</kbd>\n+  - hyphen-prefixed list item\n+- nested list item\n+  - `foo` -> `foofoo`\n+  - `bar` -> `barbar`\n+- listing in the secondary level\n+  1. install\n+  1. add to config\n+\n+     ```json\n+     {\"foo\":\"bar\"}\n+     ```\n+- list item with continuation\n+\n+  ![](https://example.com/animation.gif)\n+\n+  ![alt text](https://example.com/animation.gif)\n+\n+  <video src=\"https://example.com/movie.mp4\" controls loop>Your browser does not support the video tag.</video>\n+\n+  <video src=\"https://example.com/movie.mp4\" autoplay controls loop>Your browser does not support the video tag.</video>\n+\n+  _Image_\\\n+  ![](https://example.com/animation.gif)\n+\n+  _Video_\\\n+  <video src=\"https://example.com/movie.mp4\" controls loop>Your browser does not support the video tag.</video>\n+\n+  ```bash\n+  rustup update nightly\n+  ```\n+\n+  ```\n+  This is a plain listing.\n+  ```\n+- single line item followed by empty lines\n+- multiline list\n+  item followed by empty lines\n+- multiline list\n+  item with indent\n+- multiline list\n+  item not followed by empty lines\n+- multiline list\n+  item followed by different marker\n+  - foo\n+  - bar\n+- multiline list\n+  item followed by list continuation\n+\n+  paragraph\n+  paragraph\n+\n+## Another Section\n+\n+- foo bar baz\n+- list item with an inline image\n+  ![](https://example.com/animation.gif)\n+\n+The highlight of the month is probably [`#1111`](https://github.com/rust-analyzer/rust-analyzer/pull/1111).\n+See [online manual](https://example.com/manual) for more information.\n+\n+```bash\n+rustup update nightly\n+```\n+\n+```\n+rustup update nightly\n+```\n+\n+```\n+This is a plain listing.\n+```"}, {"sha": "105bd8df0db76cb3db95e79f9d2222ee642a1a0c", "filename": "xtask/test_data/input.adoc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Ftest_data%2Finput.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/3c00b19b0a424b2f42cbce8f8ae84b51b2429572/xtask%2Ftest_data%2Finput.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftest_data%2Finput.adoc?ref=3c00b19b0a424b2f42cbce8f8ae84b51b2429572", "patch": "@@ -0,0 +1,90 @@\n+= Changelog #256\n+:sectanchors:\n+:page-layout: post\n+\n+Hello!\n+\n+Commit: commit:0123456789abcdef0123456789abcdef01234567[] +\n+Release: release:2022-01-01[]\n+\n+== New Features\n+\n+* **BREAKING** pr:1111[] shortcut kbd:[ctrl+r]\n+- hyphen-prefixed list item\n+* nested list item\n+** `foo` -> `foofoo`\n+** `bar` -> `barbar`\n+* listing in the secondary level\n+. install\n+. add to config\n++\n+[source,json]\n+----\n+{\"foo\":\"bar\"}\n+----\n+* list item with continuation\n++\n+image::https://example.com/animation.gif[]\n++\n+image::https://example.com/animation.gif[\"alt text\"]\n++\n+video::https://example.com/movie.mp4[options=loop]\n++\n+video::https://example.com/movie.mp4[options=\"autoplay,loop\"]\n++\n+.Image\n+image::https://example.com/animation.gif[]\n++\n+.Video\n+video::https://example.com/movie.mp4[options=loop]\n++\n+[source,bash]\n+----\n+rustup update nightly\n+----\n++\n+----\n+This is a plain listing.\n+----\n+* single line item followed by empty lines\n+\n+* multiline list\n+item followed by empty lines\n+\n+* multiline list\n+  item with indent\n+\n+* multiline list\n+item not followed by empty lines\n+* multiline list\n+item followed by different marker\n+** foo\n+** bar\n+* multiline list\n+item followed by list continuation\n++\n+paragraph\n+paragraph\n+\n+== Another Section\n+\n+* foo bar baz\n+* list item with an inline image\n+  image:https://example.com/animation.gif[]\n+\n+The highlight of the month is probably pr:1111[].\n+See https://example.com/manual[online manual] for more information.\n+\n+[source,bash]\n+----\n+rustup update nightly\n+----\n+\n+[source]\n+----\n+rustup update nightly\n+----\n+\n+----\n+This is a plain listing.\n+----"}]}