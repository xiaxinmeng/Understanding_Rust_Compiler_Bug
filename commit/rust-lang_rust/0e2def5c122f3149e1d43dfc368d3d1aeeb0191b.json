{"sha": "0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "node_id": "C_kwDOAAsO6NoAKDBlMmRlZjVjMTIyZjMxNDllMWQ0M2RmYzM2OGQzZDFhZWViMDE5MWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-06T22:20:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-06T22:20:11Z"}, "message": "Auto merge of #2054 - m-ou-se:futex-wait-bitset, r=RalfJung\n\nAdd support for FUTEX_{WAIT,WAKE}_BITSET\n\nFUTEX_WAIT_BITSET and FUTEX_WAKE_BITSET are extensions of FUTEX_WAIT and FUTEX_WAKE that allow tagging each waiting thread with up to 32 'labels', and then only wake up threads that match certain labels. The non-bitset operations behave like their bitset was fully set (u32::MAX), meaning that they'll wait for anything, and wake up anything.\n\nThe only other difference is that FUTEX_WAIT_BITSET uses an absolute timeout instead of an relative timeout like FUTEX_WAIT.\n\nOften, FUTEX_WAIT_BITSET is used not for its bitset functionality, but only for its absolute timeout functionality. It is then used with a bitset of u32::MAX.\n\n~~This adds support for only that use case to Miri, as that's all `std` currently needs. Any other bitset is still unsupported.~~\n\nUpdate: This adds full support for both these syscalls.", "tree": {"sha": "5b8c2eeacdaa42d25c6494f0d36dbae85276a4dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b8c2eeacdaa42d25c6494f0d36dbae85276a4dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "html_url": "https://github.com/rust-lang/rust/commit/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb01df538e30cf63bdcbadad61828940ca8ec578", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb01df538e30cf63bdcbadad61828940ca8ec578", "html_url": "https://github.com/rust-lang/rust/commit/fb01df538e30cf63bdcbadad61828940ca8ec578"}, {"sha": "4fdda315cc1d2175a1c49617eb342cdffe8c351f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdda315cc1d2175a1c49617eb342cdffe8c351f", "html_url": "https://github.com/rust-lang/rust/commit/4fdda315cc1d2175a1c49617eb342cdffe8c351f"}], "stats": {"total": 184, "additions": 165, "deletions": 19}, "files": [{"sha": "60b8609f73b469b1324f6d711c5244b70b4ed33e", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "patch": "@@ -1 +1 @@\n-f262ca12aac76152c4b46cefcf8300f0249a5eb2\n+306ba8357fb36212b7d30efb9eb9e41659ac1445"}, {"sha": "9350ad6ba94d45a92864ef65f3db2944adcf533d", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 68, "deletions": 12, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "patch": "@@ -36,7 +36,9 @@ pub fn futex<'tcx>(\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n+    let futex_wait_bitset = this.eval_libc_i32(\"FUTEX_WAIT_BITSET\")?;\n     let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n+    let futex_wake_bitset = this.eval_libc_i32(\"FUTEX_WAKE_BITSET\")?;\n     let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\")?;\n \n     // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n@@ -45,12 +47,37 @@ pub fn futex<'tcx>(\n         // FUTEX_WAIT: (int *addr, int op = FUTEX_WAIT, int val, const timespec *timeout)\n         // Blocks the thread if *addr still equals val. Wakes up when FUTEX_WAKE is called on the same address,\n         // or *timeout expires. `timeout == null` for an infinite timeout.\n-        op if op & !futex_realtime == futex_wait => {\n-            if args.len() < 5 {\n-                throw_ub_format!(\n-                    \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\",\n-                    args.len()\n-                );\n+        //\n+        // FUTEX_WAIT_BITSET: (int *addr, int op = FUTEX_WAIT_BITSET, int val, const timespec *timeout, int *_ignored, unsigned int bitset)\n+        // This is identical to FUTEX_WAIT, except:\n+        //  - The timeout is absolute rather than relative.\n+        //  - You can specify the bitset to selecting what WAKE operations to respond to.\n+        op if op & !futex_realtime == futex_wait || op & !futex_realtime == futex_wait_bitset => {\n+            let wait_bitset = op & !futex_realtime == futex_wait_bitset;\n+\n+            let bitset = if wait_bitset {\n+                if args.len() != 7 {\n+                    throw_ub_format!(\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT_BITSET`: got {}, expected 7\",\n+                        args.len()\n+                    );\n+                }\n+                this.read_scalar(&args[6])?.to_u32()?\n+            } else {\n+                if args.len() < 5 {\n+                    throw_ub_format!(\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\",\n+                        args.len()\n+                    );\n+                }\n+                u32::MAX\n+            };\n+\n+            if bitset == 0 {\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n+                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                return Ok(());\n             }\n \n             // `deref_operand` but not actually dereferencing the ptr yet (it might be NULL!).\n@@ -70,10 +97,20 @@ pub fn futex<'tcx>(\n                         return Ok(());\n                     }\n                 };\n-                Some(if op & futex_realtime != 0 {\n-                    Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n+                Some(if wait_bitset {\n+                    // FUTEX_WAIT_BITSET uses an absolute timestamp.\n+                    if op & futex_realtime != 0 {\n+                        Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n+                    } else {\n+                        Time::Monotonic(this.machine.time_anchor.checked_add(duration).unwrap())\n+                    }\n                 } else {\n-                    Time::Monotonic(Instant::now().checked_add(duration).unwrap())\n+                    // FUTEX_WAIT uses a relative timestamp.\n+                    if op & futex_realtime != 0 {\n+                        Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n+                    } else {\n+                        Time::Monotonic(Instant::now().checked_add(duration).unwrap())\n+                    }\n                 })\n             };\n             // Check the pointer for alignment and validity.\n@@ -108,7 +145,7 @@ pub fn futex<'tcx>(\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread);\n+                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n@@ -140,10 +177,29 @@ pub fn futex<'tcx>(\n         // Wakes at most `val` threads waiting on the futex at `addr`.\n         // Returns the amount of threads woken up.\n         // Does not access the futex value at *addr.\n-        op if op == futex_wake => {\n+        // FUTEX_WAKE_BITSET: (int *addr, int op = FUTEX_WAKE, int val, const timespect *_unused, int *_unused, unsigned int bitset)\n+        // Same as FUTEX_WAKE, but allows you to specify a bitset to select which threads to wake up.\n+        op if op == futex_wake || op == futex_wake_bitset => {\n+            let bitset = if op == futex_wake_bitset {\n+                if args.len() != 7 {\n+                    throw_ub_format!(\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAKE_BITSET`: got {}, expected 7\",\n+                        args.len()\n+                    );\n+                }\n+                this.read_scalar(&args[6])?.to_u32()?\n+            } else {\n+                u32::MAX\n+            };\n+            if bitset == 0 {\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n+                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                return Ok(());\n+            }\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?) {\n+                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?, bitset) {\n                     this.unblock_thread(thread);\n                     this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;"}, {"sha": "9007f25ce5c700ed17c2555fc9a38fde57ce1842", "filename": "src/sync.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "patch": "@@ -144,6 +144,8 @@ struct Futex {\n struct FutexWaiter {\n     /// The thread that is waiting on this futex.\n     thread: ThreadId,\n+    /// The bitset used by FUTEX_*_BITSET, or u32::MAX for other operations.\n+    bitset: u32,\n }\n \n /// The state of all synchronization variables.\n@@ -486,15 +488,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.condvars[id].waiters.retain(|waiter| waiter.thread != thread);\n     }\n \n-    fn futex_wait(&mut self, addr: u64, thread: ThreadId) {\n+    fn futex_wait(&mut self, addr: u64, thread: ThreadId, bitset: u32) {\n         let this = self.eval_context_mut();\n         let futex = &mut this.machine.threads.sync.futexes.entry(addr).or_default();\n         let waiters = &mut futex.waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(FutexWaiter { thread });\n+        waiters.push_back(FutexWaiter { thread, bitset });\n     }\n \n-    fn futex_wake(&mut self, addr: u64) -> Option<ThreadId> {\n+    fn futex_wake(&mut self, addr: u64, bitset: u32) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n@@ -504,13 +506,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(data_race) = data_race {\n             data_race.validate_lock_release(&mut futex.data_race, current_thread);\n         }\n-        let res = futex.waiters.pop_front().map(|waiter| {\n+\n+        // Wake up the first thread in the queue that matches any of the bits in the bitset.\n+        futex.waiters.iter().position(|w| w.bitset & bitset != 0).map(|i| {\n+            let waiter = futex.waiters.remove(i).unwrap();\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&futex.data_race, waiter.thread);\n             }\n             waiter.thread\n-        });\n-        res\n+        })\n     }\n \n     fn futex_remove_waiter(&mut self, addr: u64, thread: ThreadId) {"}, {"sha": "fb7c022929bd7e363d3b5d3ce956ff82fd7af761", "filename": "tests/run-pass/concurrency/linux-futex.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2def5c122f3149e1d43dfc368d3d1aeeb0191b/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs?ref=0e2def5c122f3149e1d43dfc368d3d1aeeb0191b", "patch": "@@ -7,6 +7,7 @@\n #![feature(rustc_private)]\n extern crate libc;\n \n+use std::mem::MaybeUninit;\n use std::ptr;\n use std::thread;\n use std::time::{Duration, Instant};\n@@ -93,6 +94,42 @@ fn wait_timeout() {\n     assert!((200..1000).contains(&start.elapsed().as_millis()));\n }\n \n+fn wait_absolute_timeout() {\n+    let start = Instant::now();\n+\n+    // Get the current monotonic timestamp as timespec.\n+    let mut timeout = unsafe {\n+        let mut now: MaybeUninit<libc::timespec> = MaybeUninit::uninit();\n+        assert_eq!(libc::clock_gettime(libc::CLOCK_MONOTONIC, now.as_mut_ptr()), 0);\n+        now.assume_init()\n+    };\n+\n+    // Add 200ms.\n+    timeout.tv_nsec += 200_000_000;\n+    if timeout.tv_nsec > 1_000_000_000 {\n+        timeout.tv_nsec -= 1_000_000_000;\n+        timeout.tv_sec += 1;\n+    }\n+\n+    let futex: i32 = 123;\n+\n+    // Wait for 200ms from now, with nobody waking us up early.\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &futex as *const i32,\n+            libc::FUTEX_WAIT_BITSET,\n+            123,\n+            &timeout,\n+            0,\n+            u32::MAX,\n+        ), -1);\n+        assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n+    }\n+\n+    assert!((200..1000).contains(&start.elapsed().as_millis()));\n+}\n+\n fn wait_wake() {\n     let start = Instant::now();\n \n@@ -123,10 +160,59 @@ fn wait_wake() {\n     assert!((200..1000).contains(&start.elapsed().as_millis()));\n }\n \n+fn wait_wake_bitset() {\n+    let start = Instant::now();\n+\n+    static FUTEX: i32 = 0;\n+\n+    thread::spawn(move || {\n+        thread::sleep(Duration::from_millis(200));\n+        unsafe {\n+            assert_eq!(libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAKE_BITSET,\n+                10, // Wake up at most 10 threads.\n+                0,\n+                0,\n+                0b1001, // bitset\n+            ), 0); // Didn't match any thread.\n+        }\n+        thread::sleep(Duration::from_millis(200));\n+        unsafe {\n+            assert_eq!(libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAKE_BITSET,\n+                10, // Wake up at most 10 threads.\n+                0,\n+                0,\n+                0b0110, // bitset\n+            ), 1); // Woken up one thread.\n+        }\n+    });\n+\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &FUTEX as *const i32,\n+            libc::FUTEX_WAIT_BITSET,\n+            0,\n+            ptr::null::<libc::timespec>(),\n+            0,\n+            0b0100, // bitset\n+        ), 0);\n+    }\n+\n+    assert!((400..1000).contains(&start.elapsed().as_millis()));\n+}\n+\n fn main() {\n     wake_nobody();\n     wake_dangling();\n     wait_wrong_val();\n     wait_timeout();\n+    wait_absolute_timeout();\n     wait_wake();\n+    wait_wake_bitset();\n }"}]}