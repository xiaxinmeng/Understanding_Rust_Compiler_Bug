{"sha": "02365fe753708534229ff780e80133e256f3bbe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMzY1ZmU3NTM3MDg1MzQyMjlmZjc4MGU4MDEzM2UyNTZmM2JiZTM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-29T17:06:23Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-04T13:56:04Z"}, "message": "Change successor{,_mut} to return a Vec\n\nThis helps to avoid the unpleasant restriction of being unable to have multiple successors in\nnon-contiguous block of memory.", "tree": {"sha": "06c0967e54f0c776c95aec42677ed73ffe6e8a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06c0967e54f0c776c95aec42677ed73ffe6e8a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02365fe753708534229ff780e80133e256f3bbe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02365fe753708534229ff780e80133e256f3bbe3", "html_url": "https://github.com/rust-lang/rust/commit/02365fe753708534229ff780e80133e256f3bbe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02365fe753708534229ff780e80133e256f3bbe3/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "432460a6fc92e8baecbc4fa175345e78232fe2ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/432460a6fc92e8baecbc4fa175345e78232fe2ed", "html_url": "https://github.com/rust-lang/rust/commit/432460a6fc92e8baecbc4fa175345e78232fe2ed"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "ed6c4e80c2d828b952e253e9c98df1615b1e3ceb", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/02365fe753708534229ff780e80133e256f3bbe3/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02365fe753708534229ff780e80133e256f3bbe3/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=02365fe753708534229ff780e80133e256f3bbe3", "patch": "@@ -8,21 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use graphviz::IntoCow;\n use middle::const_eval::ConstVal;\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n-use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_front::hir::InlineAsm;\n-use syntax::ast::{self, Name};\n-use syntax::codemap::Span;\n-use graphviz::IntoCow;\n use std::ascii;\n-use std::borrow::Cow;\n+use std::borrow::{Cow};\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n+use syntax::ast::{self, Name};\n+use syntax::codemap::Span;\n \n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -335,29 +334,31 @@ impl<'tcx> CallKind<'tcx> {\n }\n \n impl<'tcx> Terminator<'tcx> {\n-    pub fn successors(&self) -> &[BasicBlock] {\n+    pub fn successors(&self) -> Cow<[BasicBlock]> {\n         use self::Terminator::*;\n         match *self {\n-            Goto { target: ref b } => slice::ref_slice(b),\n-            If { targets: ref b, .. } => b.as_slice(),\n-            Switch { targets: ref b, .. } => b,\n-            SwitchInt { targets: ref b, .. } => b,\n-            Resume => &[],\n-            Return => &[],\n-            Call { ref kind, .. } => kind.successors(),\n+            Goto { target: ref b } => slice::ref_slice(b).into_cow(),\n+            If { targets: (b1, b2), .. } => vec![b1, b2].into_cow(),\n+            Switch { targets: ref b, .. } => b[..].into_cow(),\n+            SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n+            Resume => (&[]).into_cow(),\n+            Return => (&[]).into_cow(),\n+            Call { ref kind, .. } => kind.successors()[..].into_cow(),\n         }\n     }\n \n-    pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n+    // FIXME: no mootable cow. I\u2019m honestly not sure what a \u201ccow\u201d between `&mut [BasicBlock]` and\n+    // `Vec<&mut BasicBlock>` would look like in the first place.\n+    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n         use self::Terminator::*;\n         match *self {\n-            Goto { target: ref mut b } => slice::mut_ref_slice(b),\n-            If { targets: ref mut b, .. } => b.as_mut_slice(),\n-            Switch { targets: ref mut b, .. } => b,\n-            SwitchInt { targets: ref mut b, .. } => b,\n-            Resume => &mut [],\n-            Return => &mut [],\n-            Call { ref mut kind, .. } => kind.successors_mut(),\n+            Goto { target: ref mut b } => vec![b],\n+            If { targets: (ref mut b1, ref mut b2), .. } => vec![b1, b2],\n+            Switch { targets: ref mut b, .. } => b.iter_mut().collect(),\n+            SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n+            Resume => Vec::new(),\n+            Return => Vec::new(),\n+            Call { ref mut kind, .. } => kind.successors_mut().iter_mut().collect(),\n         }\n     }\n }\n@@ -445,22 +446,22 @@ impl<'tcx> Terminator<'tcx> {\n         use self::Terminator::*;\n         match *self {\n             Return | Resume => vec![],\n-            Goto { .. } => vec![\"\".into_cow()],\n-            If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n+            Goto { .. } => vec![\"\".into()],\n+            If { .. } => vec![\"true\".into(), \"false\".into()],\n             Switch { ref adt_def, .. } => {\n                 adt_def.variants\n                        .iter()\n-                       .map(|variant| variant.name.to_string().into_cow())\n+                       .map(|variant| variant.name.to_string().into())\n                        .collect()\n             }\n             SwitchInt { ref values, .. } => {\n                 values.iter()\n                       .map(|const_val| {\n                           let mut buf = String::new();\n                           fmt_const_val(&mut buf, const_val).unwrap();\n-                          buf.into_cow()\n+                          buf.into()\n                       })\n-                      .chain(iter::once(String::from(\"otherwise\").into_cow()))\n+                      .chain(iter::once(String::from(\"otherwise\").into()))\n                       .collect()\n             }\n             Call { ref kind, .. } => match *kind {"}, {"sha": "365fca23dda7018bbea484f78bbee5e6f03adf1c", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02365fe753708534229ff780e80133e256f3bbe3/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02365fe753708534229ff780e80133e256f3bbe3/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=02365fe753708534229ff780e80133e256f3bbe3", "patch": "@@ -86,4 +86,3 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).terminator = Some(terminator);\n     }\n }\n-"}, {"sha": "9d4c73b90f81a6fef0c5caf06003c34298fcd59f", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02365fe753708534229ff780e80133e256f3bbe3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02365fe753708534229ff780e80133e256f3bbe3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=02365fe753708534229ff780e80133e256f3bbe3", "patch": "@@ -29,7 +29,7 @@ impl SimplifyCfg {\n \n         let mut worklist = vec![START_BLOCK];\n         while let Some(bb) = worklist.pop() {\n-            for succ in mir.basic_block_data(bb).terminator().successors() {\n+            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n                 if !seen[succ.index()] {\n                     seen[succ.index()] = true;\n                     worklist.push(*succ);"}]}