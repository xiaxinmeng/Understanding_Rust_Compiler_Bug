{"sha": "0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYjFhYzBmOWY3YmY5OGVhOGFiNWNjYmQ2ZWYzMTlkZWNjNDFhNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-14T19:01:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-14T19:01:22Z"}, "message": "auto merge of #7788 : MarkJr94/rust/from_iter, r=cmr\n\nAdded Iterators for HashMap/Set, TreeMap/Set, TrieMap/Set, and PriorityQueue as per Issue #7626", "tree": {"sha": "273268a2048fe1c4c1e41750f8fac87d1d7810f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/273268a2048fe1c4c1e41750f8fac87d1d7810f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "html_url": "https://github.com/rust-lang/rust/commit/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c35ab322ff2f26962a3550fffc2fa4154224b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c35ab322ff2f26962a3550fffc2fa4154224b64", "html_url": "https://github.com/rust-lang/rust/commit/1c35ab322ff2f26962a3550fffc2fa4154224b64"}, {"sha": "bbe03da9c6bad23d8e09077461c1616872e1aca0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe03da9c6bad23d8e09077461c1616872e1aca0", "html_url": "https://github.com/rust-lang/rust/commit/bbe03da9c6bad23d8e09077461c1616872e1aca0"}], "stats": {"total": 204, "additions": 189, "deletions": 15}, "files": [{"sha": "58bf4ba92472578c6081ccb7045ec8f98b476beb", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "patch": "@@ -16,6 +16,7 @@\n use std::unstable::intrinsics::{move_val_init, init};\n use std::util::{replace, swap};\n use std::vec;\n+use std::iterator::FromIterator;\n \n /// A priority queue implemented with a binary heap\n pub struct PriorityQueue<T> {\n@@ -191,6 +192,21 @@ impl<'self, T> Iterator<&'self T> for PriorityQueueIterator<'self, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+impl<T: Ord, Iter: Iterator<T>> FromIterator<T, Iter> for PriorityQueue<T> {\n+    pub fn from_iterator(iter: &mut Iter) -> PriorityQueue<T> {\n+        let (lower, _) = iter.size_hint();\n+\n+        let mut q = PriorityQueue::new();\n+        q.reserve_at_least(lower);\n+\n+        for iter.advance |elem| {\n+            q.push(elem);\n+        }\n+\n+        q\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use sort::merge_sort;\n@@ -341,4 +357,15 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_empty_replace() { let mut heap = PriorityQueue::new(); heap.replace(5); }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[9u, 8, 7, 6, 5, 4, 3, 2, 1];\n+\n+        let mut q: PriorityQueue<uint> = xs.rev_iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |&x| {\n+            assert_eq!(q.pop(), x);\n+        }\n+    }\n }"}, {"sha": "f1fe7acb00f836bba4cb6c020bcfe51333d68012", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "patch": "@@ -15,6 +15,7 @@\n \n use std::num;\n use std::util::{swap, replace};\n+use std::iterator::FromIterator;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -699,6 +700,30 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n     };\n }\n \n+impl<K: TotalOrd, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for TreeMap<K, V> {\n+    pub fn from_iterator(iter: &mut T) -> TreeMap<K, V> {\n+        let mut map = TreeMap::new();\n+\n+        for iter.advance |(k, v)| {\n+            map.insert(k, v);\n+        }\n+\n+        map\n+    }\n+}\n+\n+impl<T: TotalOrd, Iter: Iterator<T>> FromIterator<T, Iter> for TreeSet<T> {\n+    pub fn from_iterator(iter: &mut Iter) -> TreeSet<T> {\n+        let mut set = TreeSet::new();\n+\n+        for iter.advance |elem| {\n+            set.insert(elem);\n+        }\n+\n+        set\n+    }\n+}\n+\n #[cfg(test)]\n mod test_treemap {\n \n@@ -1017,6 +1042,17 @@ mod test_treemap {\n             i += 1;\n         }\n     }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: TreeMap<int, int> = xs.iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |&(k, v)| {\n+            assert_eq!(map.find(&k), Some(&v));\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -1244,4 +1280,15 @@ mod test_set {\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: TreeSet<int> = xs.iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |x: &int| {\n+            assert!(set.contains(x));\n+        }\n+    }\n }"}, {"sha": "0e31e47d56b2742548356b3759dd7b708180a216", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "patch": "@@ -18,7 +18,7 @@\n use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator, IteratorUtil, FromIterator};\n use num;\n use option::{None, Option, Some};\n use rand::RngUtil;\n@@ -612,6 +612,18 @@ impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     }\n }\n \n+impl<K: Eq + Hash, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for HashMap<K, V> {\n+    pub fn from_iterator(iter: &mut T) -> HashMap<K, V> {\n+        let (lower, _) = iter.size_hint();\n+        let mut map = HashMap::with_capacity(lower);\n+\n+        for iter.advance |(k, v)| {\n+            map.insert(k, v);\n+        }\n+\n+        map\n+    }\n+}\n \n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n@@ -727,6 +739,20 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n }\n \n+impl<K: Eq + Hash, T: Iterator<K>> FromIterator<K, T> for HashSet<K> {\n+    pub fn from_iterator(iter: &mut T) -> HashSet<K> {\n+        let (lower, _) = iter.size_hint();\n+        let mut set = HashSet::with_capacity(lower);\n+\n+        for iter.advance |k| {\n+            set.insert(k);\n+        }\n+\n+        set\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod test_map {\n     use container::{Container, Map, Set};\n@@ -939,6 +965,17 @@ mod test_map {\n \n         assert_eq!(m.find_equiv(&(\"qux\")), None);\n     }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: HashMap<int, int> = xs.iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |&(k, v)| {\n+            assert_eq!(map.find(&k), Some(&v));\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -1120,4 +1157,15 @@ mod test_set {\n         }\n         assert_eq!(i, expected.len());\n     }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: HashSet<int> = xs.iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |x: &int| {\n+            assert!(set.contains(x));\n+        }\n+    }\n }"}, {"sha": "3882ab0de63331de15a4fd970effce5990c30cd3", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=0cb1ac0f9f7bf98ea8ab5ccbd6ef319decc41a72", "patch": "@@ -11,7 +11,7 @@\n //! An ordered map and set for integer keys implemented as a radix trie\n \n use prelude::*;\n-use iterator::IteratorUtil;\n+use iterator::{IteratorUtil, FromIterator};\n use uint;\n use util::{swap, replace};\n \n@@ -173,6 +173,18 @@ impl<T> TrieMap<T> {\n     }\n }\n \n+impl<T, Iter: Iterator<(uint, T)>> FromIterator<(uint, T), Iter> for TrieMap<T> {\n+    pub fn from_iterator(iter: &mut Iter) -> TrieMap<T> {\n+        let mut map = TrieMap::new();\n+\n+        for iter.advance |(k, v)| {\n+            map.insert(k, v);\n+        }\n+\n+        map\n+    }\n+}\n+\n #[allow(missing_doc)]\n pub struct TrieSet {\n     priv map: TrieMap<()>\n@@ -232,6 +244,18 @@ impl TrieSet {\n     }\n }\n \n+impl<Iter: Iterator<uint>> FromIterator<uint, Iter> for TrieSet {\n+    pub fn from_iterator(iter: &mut Iter) -> TrieSet {\n+        let mut set = TrieSet::new();\n+\n+        for iter.advance |elem| {\n+            set.insert(elem);\n+        }\n+\n+        set\n+    }\n+}\n+\n struct TrieNode<T> {\n     count: uint,\n     children: [Child<T>, ..SIZE]\n@@ -384,7 +408,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n }\n \n #[cfg(test)]\n-mod tests {\n+mod test_map {\n     use super::*;\n     use core::option::{Some, None};\n     use uint;\n@@ -512,6 +536,39 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_swap() {\n+        let mut m = TrieMap::new();\n+        assert_eq!(m.swap(1, 2), None);\n+        assert_eq!(m.swap(1, 3), Some(2));\n+        assert_eq!(m.swap(1, 4), Some(3));\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = TrieMap::new();\n+        m.insert(1, 2);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[(1u, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: TrieMap<int> = xs.iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |&(k, v)| {\n+            assert_eq!(map.find(&k), Some(&v));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_set {\n+    use super::*;\n+    use uint;\n+\n     #[test]\n     fn test_sane_chunk() {\n         let x = 1;\n@@ -535,18 +592,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_swap() {\n-        let mut m = TrieMap::new();\n-        assert_eq!(m.swap(1, 2), None);\n-        assert_eq!(m.swap(1, 3), Some(2));\n-        assert_eq!(m.swap(1, 4), Some(3));\n-    }\n+    fn test_from_iter() {\n+        let xs = ~[9u, 8, 7, 6, 5, 4, 3, 2, 1];\n \n-    #[test]\n-    fn test_pop() {\n-        let mut m = TrieMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        let set: TrieSet = xs.iter().transform(|&x| x).collect();\n+\n+        for xs.iter().advance |x| {\n+            assert!(set.contains(x));\n+        }\n     }\n }"}]}