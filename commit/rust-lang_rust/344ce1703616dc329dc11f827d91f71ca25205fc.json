{"sha": "344ce1703616dc329dc11f827d91f71ca25205fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NGNlMTcwMzYxNmRjMzI5ZGMxMWY4MjdkOTFmNzFjYTI1MjA1ZmM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-21T23:41:05Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:20:12Z"}, "message": "rustc: de-@ debuginfo.", "tree": {"sha": "b94c64db6a32cc777a2c1c2727d976f8f678f5f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b94c64db6a32cc777a2c1c2727d976f8f678f5f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/344ce1703616dc329dc11f827d91f71ca25205fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/344ce1703616dc329dc11f827d91f71ca25205fc", "html_url": "https://github.com/rust-lang/rust/commit/344ce1703616dc329dc11f827d91f71ca25205fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/344ce1703616dc329dc11f827d91f71ca25205fc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "url": "https://api.github.com/repos/rust-lang/rust/commits/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "html_url": "https://github.com/rust-lang/rust/commit/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "d1c1eb8443a6e113ffa229b54a6c89968417df72", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/344ce1703616dc329dc11f827d91f71ca25205fc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344ce1703616dc329dc11f827d91f71ca25205fc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=344ce1703616dc329dc11f827d91f71ca25205fc", "patch": "@@ -57,7 +57,7 @@ For example, the following simple type for a singly-linked list...\n ```\n struct List {\n     value: int,\n-    tail: Option<@List>,\n+    tail: Option<~List>,\n }\n ```\n \n@@ -66,8 +66,8 @@ will generate the following callstack with a naive DFS algorithm:\n ```\n describe(t = List)\n   describe(t = int)\n-  describe(t = Option<@List>)\n-    describe(t = @List)\n+  describe(t = Option<~List>)\n+    describe(t = ~List)\n       describe(t = List) // at the beginning again...\n       ...\n ```\n@@ -144,7 +144,7 @@ use util::ppaux;\n \n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n+use std::rc::{Rc, Weak};\n use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n@@ -181,7 +181,7 @@ pub struct CrateDebugContext {\n     created_files: RefCell<HashMap<~str, DIFile>>,\n     created_types: RefCell<HashMap<uint, DIType>>,\n     created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n-    namespace_map: RefCell<HashMap<Vec<ast::Name> , @NamespaceTreeNode>>,\n+    namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n     composite_types_completed: RefCell<HashSet<DIType>>,\n@@ -2831,14 +2831,14 @@ fn populate_scope_map(cx: &CrateContext,\n struct NamespaceTreeNode {\n     name: ast::Name,\n     scope: DIScope,\n-    parent: Option<@NamespaceTreeNode>,\n+    parent: Option<Weak<NamespaceTreeNode>>,\n }\n \n impl NamespaceTreeNode {\n     fn mangled_name_of_contained_item(&self, item_name: &str) -> ~str {\n         fn fill_nested(node: &NamespaceTreeNode, output: &mut StrBuf) {\n             match node.parent {\n-                Some(parent) => fill_nested(parent, output),\n+                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n@@ -2855,7 +2855,7 @@ impl NamespaceTreeNode {\n     }\n }\n \n-fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNode {\n+fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n     ty::with_path(cx.tcx(), def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n@@ -2867,7 +2867,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n         let mut path = krate.move_iter().chain(path).peekable();\n \n         let mut current_key = Vec::new();\n-        let mut parent_node: Option<@NamespaceTreeNode> = None;\n+        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n \n         // Create/Lookup namespace for each element of the path.\n         loop {\n@@ -2891,7 +2891,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n                 None => {\n                     // create and insert\n                     let parent_scope = match parent_node {\n-                        Some(node) => node.scope,\n+                        Some(ref node) => node.scope,\n                         None => ptr::null()\n                     };\n                     let namespace_name = token::get_name(name);\n@@ -2908,14 +2908,14 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n                         }\n                     });\n \n-                    let node = @NamespaceTreeNode {\n+                    let node = Rc::new(NamespaceTreeNode {\n                         name: name,\n                         scope: scope,\n-                        parent: parent_node,\n-                    };\n+                        parent: parent_node.map(|parent| parent.downgrade()),\n+                    });\n \n                     debug_context(cx).namespace_map.borrow_mut()\n-                                     .insert(current_key.clone(), node);\n+                                     .insert(current_key.clone(), node.clone());\n \n                     node\n                 }"}]}