{"sha": "f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YmZkYzk1NDQ1MTgwYWVlNTc5ZGNhY2M2ZTZiZGM0ZTZlY2Y1NmY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-02-16T15:17:01Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-02-17T14:18:33Z"}, "message": "Move the show_usize marker function to a static\n\nCurrently, function items are always tagged unnamed_addr, which means that\ncasting a function to a function pointer is not guaranteed to produce a\ndeterministic address. However, once a function pointer is created, we do expect\nthat to remain stable. So, this changes the show_usize function to a static\ncontaining a function pointer and uses that for comparisons.\n\nNotably, a *static* may have 'unstable' address, but the function pointer within\nit must be constant.\n\nResolves issue 58320.", "tree": {"sha": "6fe6da3b410876a8212136d6795de6e247529f2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fe6da3b410876a8212136d6795de6e247529f2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f", "html_url": "https://github.com/rust-lang/rust/commit/f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34ef8f5441d5335c4177abd622383ed34a6e9315", "url": "https://api.github.com/repos/rust-lang/rust/commits/34ef8f5441d5335c4177abd622383ed34a6e9315", "html_url": "https://github.com/rust-lang/rust/commit/34ef8f5441d5335c4177abd622383ed34a6e9315"}], "stats": {"total": 23, "additions": 16, "deletions": 7}, "files": [{"sha": "993b1073493e9dd731b54217675dc6da4fd0d5fb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f6bfdc95445180aee579dcacc6e6bdc4e6ecf56f", "patch": "@@ -255,12 +255,19 @@ pub struct ArgumentV1<'a> {\n     formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n }\n \n-impl<'a> ArgumentV1<'a> {\n-    #[inline(never)]\n-    fn show_usize(x: &usize, f: &mut Formatter<'_>) -> Result {\n-        Display::fmt(x, f)\n-    }\n+// This gurantees a single stable value for the function pointer associated with\n+// indices/counts in the formatting infrastructure.\n+//\n+// Note that a function defined as such would not be correct as functions are\n+// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n+// address is not considered important to LLVM and as such the as_usize cast\n+// could have been miscompiled. In practice, we never call as_usize on non-usize\n+// containing data (as a matter of static generation of the formatting\n+// arguments), so this is merely an additional check.\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |_, _| loop {};\n \n+impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n@@ -270,11 +277,13 @@ impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-        ArgumentV1::new(x, ArgumentV1::show_usize)\n+        ArgumentV1::new(x, USIZE_MARKER)\n     }\n \n     fn as_usize(&self) -> Option<usize> {\n-        if self.formatter as usize == ArgumentV1::show_usize as usize {\n+        if self.formatter as usize == USIZE_MARKER as usize {\n+            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n+            // the value is a usize, so this is safe\n             Some(unsafe { *(self.value as *const _ as *const usize) })\n         } else {\n             None"}]}