{"sha": "c22ce2806c3198c9a2b90b78d00c5451593c833f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMmNlMjgwNmMzMTk4YzlhMmI5MGI3OGQwMGM1NDUxNTkzYzgzM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-04T05:37:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-04T05:37:44Z"}, "message": "Auto merge of #61510 - Centril:rollup-bvi95y2, r=Centril\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #61135 (Fix documentation of `Rc::make_mut` regarding `rc::Weak`.)\n - #61404 (miri unsizing: fix projecting into a field of an operand)\n - #61409 (Fix an ICE with a const argument in a trait)\n - #61413 (Re-implement async fn drop order lowering )\n - #61419 (Add an unusual-conversion example to to_uppercase)\n - #61420 (Succinctify splice docs)\n - #61444 (Suggest using `as_ref` on `*const T`)\n - #61446 (On TerminatorKind::DropAndReplace still handle unused_mut correctly)\n - #61485 (azure: retry s3 upload if it fails)\n - #61489 (ci: Reenable step timings on AppVeyor)\n - #61496 (Do not panic in tidy on unbalanced parentheses in cfg's)\n - #61497 (Treat 0 as special value for codegen-units-std)\n - #61499 (Add regression test for existential type ICE #53457)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "cddcdf9c039932b2d5d48e4e3a8c05ffd865c54c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cddcdf9c039932b2d5d48e4e3a8c05ffd865c54c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c22ce2806c3198c9a2b90b78d00c5451593c833f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c22ce2806c3198c9a2b90b78d00c5451593c833f", "html_url": "https://github.com/rust-lang/rust/commit/c22ce2806c3198c9a2b90b78d00c5451593c833f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c22ce2806c3198c9a2b90b78d00c5451593c833f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7c4aa804c4f26ba6de8a39d3c8eea88e8b8938", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7c4aa804c4f26ba6de8a39d3c8eea88e8b8938", "html_url": "https://github.com/rust-lang/rust/commit/dc7c4aa804c4f26ba6de8a39d3c8eea88e8b8938"}, {"sha": "5baa58ea5f6d69e07054a3dde21e7b0ef8c75a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5baa58ea5f6d69e07054a3dde21e7b0ef8c75a1b", "html_url": "https://github.com/rust-lang/rust/commit/5baa58ea5f6d69e07054a3dde21e7b0ef8c75a1b"}], "stats": {"total": 1450, "additions": 607, "deletions": 843}, "files": [{"sha": "cfa28a6a1d70fafdce8eb50be879a3475914cf92", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -118,6 +118,7 @@ steps:\n # bucket.\n - bash: |\n     set -e\n+    source src/ci/shared.sh\n     if [ \"$AGENT_OS\" = \"Linux\" ]; then\n         rm -rf obj/build/dist/doc\n         upload_dir=obj/build/dist\n@@ -130,7 +131,7 @@ steps:\n     if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n         deploy_dir=rustc-builds-alt\n     fi\n-    aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n+    retry aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n   env:\n     AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n   condition: and(succeeded(), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))"}, {"sha": "edeb07fda1d59d923dc1f32403568ac927c57806", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -11,7 +11,6 @@ use std::process;\n use std::cmp;\n \n use build_helper::t;\n-use num_cpus;\n use toml;\n use serde::Deserialize;\n use crate::cache::{INTERNER, Interned};\n@@ -401,7 +400,7 @@ impl Config {\n         config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.jobs = flags.jobs;\n+        config.jobs = flags.jobs.map(threads_from_config);\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n@@ -583,13 +582,8 @@ impl Config {\n \n             set(&mut config.rust_codegen_backends_dir, rust.codegen_backends_dir.clone());\n \n-            match rust.codegen_units {\n-                Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n-                Some(n) => config.rust_codegen_units = Some(n),\n-                None => {}\n-            }\n-\n-            config.rust_codegen_units_std = rust.codegen_units_std;\n+            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n+            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n         }\n \n         if let Some(ref t) = toml.target {\n@@ -688,3 +682,10 @@ fn set<T>(field: &mut T, val: Option<T>) {\n         *field = v;\n     }\n }\n+\n+fn threads_from_config(v: u32) -> u32 {\n+    match v {\n+        0 => num_cpus::get() as u32,\n+        n => n,\n+    }\n+}"}, {"sha": "323d53f2bec85d8f1debb4135bf8860ed7d2f911", "filename": "src/ci/shared.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -35,6 +35,8 @@ function isOSX {\n function getCIBranch {\n   if [ \"$TRAVIS\" = \"true\" ]; then\n     echo \"$TRAVIS_BRANCH\"\n+  elif [ \"$APPVEYOR\" = \"True\" ]; then\n+    echo \"$APPVEYOR_REPO_BRANCH\"\n   else\n     echo \"$BUILD_SOURCEBRANCHNAME\"\n   fi;"}, {"sha": "c827e218b2fb35f445572993f1fa6c3bd4ea2052", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -580,15 +580,18 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n+    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// referred to as clone-on-write.\n     ///\n-    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n+    /// pointers to this value will be dissassociated.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [get_mut]: struct.Rc.html#method.get_mut\n+    /// See also [`get_mut`], which will fail rather than cloning.\n+    ///\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -607,6 +610,23 @@ impl<T: Clone> Rc<T> {\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n+    ///\n+    /// [`Weak`] pointers will be dissassociated:\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut data = Rc::new(75);\n+    /// let weak = Rc::downgrade(&data);\n+    ///\n+    /// assert!(75 == *data);\n+    /// assert!(75 == *weak.upgrade().unwrap());\n+    ///\n+    /// *Rc::make_mut(&mut data) += 1;\n+    ///\n+    /// assert!(76 == *data);\n+    /// assert!(weak.upgrade().is_none());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn make_mut(this: &mut Self) -> &mut T {"}, {"sha": "0c7d2b837a39ac5b9a8537677bec8ee3657f3052", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -431,6 +431,13 @@ impl str {\n     ///\n     /// assert_eq!(new_year, new_year.to_uppercase());\n     /// ```\n+    ///\n+    /// One character can become multiple:\n+    /// ```\n+    /// let s = \"tsch\u00fc\u00df\";\n+    ///\n+    /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n+    /// ```\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());"}, {"sha": "92fe0834dd029bd37225a6ce397bae636f24d7e2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -2018,16 +2018,14 @@ impl<T> Vec<T> {\n     /// with the given `replace_with` iterator and yields the removed items.\n     /// `replace_with` does not need to be the same length as `range`.\n     ///\n-    /// Note 1: The element range is removed even if the iterator is not\n-    /// consumed until the end.\n+    /// The element range is removed even if the iterator is not consumed until the end.\n     ///\n-    /// Note 2: It is unspecified how many elements are removed from the vector,\n+    /// It is unspecified how many elements are removed from the vector\n     /// if the `Splice` value is leaked.\n     ///\n-    /// Note 3: The input iterator `replace_with` is only consumed\n-    /// when the `Splice` value is dropped.\n+    /// The input iterator `replace_with` is only consumed when the `Splice` value is dropped.\n     ///\n-    /// Note 4: This is optimal if:\n+    /// This is optimal if:\n     ///\n     /// * The tail (elements in the vector after `range`) is empty,\n     /// * or `replace_with` yields fewer elements than `range`\u2019s length"}, {"sha": "9cf365addca9bb060e3a5c941d1c38d0c3230fd9", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -262,9 +262,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_pat(&mut self, p: &'v Pat) {\n         walk_pat(self, p)\n     }\n-    fn visit_argument_source(&mut self, s: &'v ArgSource) {\n-        walk_argument_source(self, s)\n-    }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n@@ -402,17 +399,10 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n     for argument in &body.arguments {\n         visitor.visit_id(argument.hir_id);\n         visitor.visit_pat(&argument.pat);\n-        visitor.visit_argument_source(&argument.source);\n     }\n     visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_argument_source<'v, V: Visitor<'v>>(visitor: &mut V, source: &'v ArgSource) {\n-    if let ArgSource::AsyncFn(pat) = source {\n-        visitor.visit_pat(pat);\n-    }\n-}\n-\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition."}, {"sha": "14a6e93341e3290c3b988dbcdae837962c2f66a4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 246, "deletions": 224, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -50,6 +50,7 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_data_structures::sync::Lrc;\n \n use std::collections::{BTreeSet, BTreeMap};\n use std::mem;\n@@ -58,17 +59,17 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::Span;\n+use syntax_pos::{edition, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -465,32 +466,6 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n-            fn visit_fn(&mut self, fk: visit::FnKind<'lcx>, fd: &'lcx FnDecl, s: Span, _: NodeId) {\n-                if fk.header().map(|h| h.asyncness.node.is_async()).unwrap_or(false) {\n-                    // Don't visit the original pattern for async functions as it will be\n-                    // replaced.\n-                    for arg in &fd.inputs {\n-                        if let ArgSource::AsyncFn(pat) = &arg.source { self.visit_pat(pat); }\n-                        self.visit_ty(&arg.ty)\n-                    }\n-                    self.visit_fn_ret_ty(&fd.output);\n-\n-                    match fk {\n-                        visit::FnKind::ItemFn(_, decl, _, body) => {\n-                            self.visit_fn_header(decl);\n-                            self.visit_block(body)\n-                        },\n-                        visit::FnKind::Method(_, sig, _, body) => {\n-                            self.visit_fn_header(&sig.header);\n-                            self.visit_block(body)\n-                        },\n-                        visit::FnKind::Closure(body) => self.visit_expr(body),\n-                    }\n-                } else {\n-                    visit::walk_fn(self, fk, fd, s)\n-                }\n-            }\n-\n             fn visit_item(&mut self, item: &'lcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -806,7 +781,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, value: hir::Expr, arguments: HirVec<hir::Arg>) -> hir::BodyId {\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n         if self.is_generator && self.is_async_body {\n             span_err!(\n                 self.sess,\n@@ -855,6 +830,27 @@ impl<'a> LoweringContext<'a> {\n         self.sess.diagnostic()\n     }\n \n+    /// Reuses the span but adds information like the kind of the desugaring and features that are\n+    /// allowed inside this span.\n+    fn mark_span_with_reason(\n+        &self,\n+        reason: CompilerDesugaringKind,\n+        span: Span,\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    ) -> Span {\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(source_map::ExpnInfo {\n+            call_site: span,\n+            def_site: Some(span),\n+            format: source_map::CompilerDesugaring(reason),\n+            allow_internal_unstable,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition: edition::Edition::from_session(),\n+        });\n+        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n+    }\n+\n     fn with_anonymous_lifetime_mode<R>(\n         &mut self,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n@@ -1125,27 +1121,21 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_is_async_body = mem::replace(&mut self.is_async_body, true);\n+        let capture_clause = self.lower_capture_clause(capture_clause);\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n             None => FunctionRetTy::Default(span),\n         };\n-        let decl = FnDecl {\n+        let ast_decl = FnDecl {\n             inputs: vec![],\n             output,\n             c_variadic: false\n         };\n-        // Lower the arguments before the body otherwise the body will call `lower_res` expecting\n-        // the argument to have been assigned an id already.\n-        let arguments = self.lower_args(Some(&decl));\n-        let body_expr = body(self);\n-        let body_id = self.record_body(body_expr, arguments);\n-        self.is_generator = prev_is_generator;\n-        self.is_async_body = prev_is_async_body;\n-\n-        let capture_clause = self.lower_capture_clause(capture_clause);\n-        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n+        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n+        let body_id = self.lower_fn_body(&ast_decl, |this| {\n+            this.is_async_body = true;\n+            body(this)\n+        });\n         let generator = hir::Expr {\n             hir_id: self.lower_node_id(closure_node_id),\n             node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n@@ -1154,7 +1144,7 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n         };\n \n-        let unstable_span = self.sess.source_map().mark_span_with_reason(\n+        let unstable_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n             Some(vec![sym::gen_future].into()),\n@@ -1164,18 +1154,32 @@ impl<'a> LoweringContext<'a> {\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n-    fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n-    where\n-        F: FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n-    {\n-        let prev_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_async = mem::replace(&mut self.is_async_body, false);\n-        let arguments = self.lower_args(decl);\n-        let result = f(self);\n-        let r = self.record_body(result, arguments);\n-        self.is_generator = prev_generator;\n-        self.is_async_body = prev_async;\n-        return r;\n+    fn lower_body(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+    ) -> hir::BodyId {\n+        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n+        let prev_is_async_body = mem::replace(&mut self.is_async_body, false);\n+        let (arguments, result) = f(self);\n+        let body_id = self.record_body(arguments, result);\n+        self.is_generator = prev_is_generator;\n+        self.is_async_body = prev_is_async_body;\n+        body_id\n+    }\n+\n+    fn lower_fn_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+    ) -> hir::BodyId {\n+        self.lower_body(|this| (\n+            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            body(this),\n+        ))\n+    }\n+\n+    fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n+        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n     }\n \n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n@@ -1561,7 +1565,7 @@ impl<'a> LoweringContext<'a> {\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile as\n         // frequently opened issues show.\n-        let exist_ty_span = self.sess.source_map().mark_span_with_reason(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n             span,\n             None,\n@@ -2266,40 +2270,21 @@ impl<'a> LoweringContext<'a> {\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n-            source: self.lower_local_source(l.source),\n+            source: hir::LocalSource::Normal,\n         }, ids)\n     }\n \n-    fn lower_local_source(&mut self, ls: LocalSource) -> hir::LocalSource {\n-        match ls {\n-            LocalSource::Normal => hir::LocalSource::Normal,\n-            LocalSource::AsyncFn => hir::LocalSource::AsyncFn,\n-        }\n-    }\n-\n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n         match m {\n             Mutability::Mutable => hir::MutMutable,\n             Mutability::Immutable => hir::MutImmutable,\n         }\n     }\n \n-    fn lower_args(&mut self, decl: Option<&FnDecl>) -> HirVec<hir::Arg> {\n-        decl.map_or(hir_vec![], |decl| decl.inputs.iter().map(|x| self.lower_arg(x)).collect())\n-    }\n-\n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         hir::Arg {\n             hir_id: self.lower_node_id(arg.id),\n             pat: self.lower_pat(&arg.pat),\n-            source: self.lower_arg_source(&arg.source),\n-        }\n-    }\n-\n-    fn lower_arg_source(&mut self, source: &ArgSource) -> hir::ArgSource {\n-        match source {\n-            ArgSource::Normal => hir::ArgSource::Normal,\n-            ArgSource::AsyncFn(pat) => hir::ArgSource::AsyncFn(self.lower_pat(pat)),\n         }\n     }\n \n@@ -2435,7 +2420,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::FunctionRetTy {\n         let span = output.span();\n \n-        let exist_ty_span = self.sess.source_map().mark_span_with_reason(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n             None,\n@@ -2998,11 +2983,14 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+    fn lower_block_with_stmts(\n+        &mut self,\n+        b: &Block,\n+        targeted_by_break: bool,\n+        mut stmts: Vec<hir::Stmt>,\n+    ) -> P<hir::Block> {\n         let mut expr = None;\n \n-        let mut stmts = vec![];\n-\n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n                 if let StmtKind::Expr(ref e) = stmt.node {\n@@ -3025,56 +3013,136 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_async_body(\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+        self.lower_block_with_stmts(b, targeted_by_break, vec![])\n+    }\n+\n+    fn lower_maybe_async_body(\n         &mut self,\n         decl: &FnDecl,\n-        asyncness: &IsAsync,\n+        asyncness: IsAsync,\n         body: &Block,\n     ) -> hir::BodyId {\n-        self.lower_body(Some(&decl), |this| {\n-            if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n-                let mut body = body.clone();\n+        let closure_id = match asyncness {\n+            IsAsync::Async { closure_id, .. } => closure_id,\n+            IsAsync::NotAsync => return self.lower_fn_body(&decl, |this| {\n+                let body = this.lower_block(body, false);\n+                this.expr_block(body, ThinVec::new())\n+            }),\n+        };\n \n-                // Async function arguments are lowered into the closure body so that they are\n-                // captured and so that the drop order matches the equivalent non-async functions.\n-                //\n-                //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-                //       async move {\n-                //       }\n-                //     }\n-                //\n-                //     // ...becomes...\n-                //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n-                //       async move {\n-                //         let __arg2 = __arg2;\n-                //         let <pattern> = __arg2;\n-                //         let __arg1 = __arg1;\n-                //         let <pattern> = __arg1;\n-                //         let __arg0 = __arg0;\n-                //         let <pattern> = __arg0;\n-                //       }\n-                //     }\n+        self.lower_body(|this| {\n+            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut statements: Vec<hir::Stmt> = Vec::new();\n+\n+            // Async function arguments are lowered into the closure body so that they are\n+            // captured and so that the drop order matches the equivalent non-async functions.\n+            //\n+            // from:\n+            //\n+            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+            //       async move {\n+            //       }\n+            //     }\n+            //\n+            // into:\n+            //\n+            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+            //       async move {\n+            //         let __arg2 = __arg2;\n+            //         let <pattern> = __arg2;\n+            //         let __arg1 = __arg1;\n+            //         let <pattern> = __arg1;\n+            //         let __arg0 = __arg0;\n+            //         let <pattern> = __arg0;\n+            //       }\n+            //     }\n+            //\n+            // If `<pattern>` is a simple ident, then it is lowered to a single\n+            // `let <pattern> = <pattern>;` statement as an optimization.\n+            for (index, argument) in decl.inputs.iter().enumerate() {\n+                let argument = this.lower_arg(argument);\n+                let span = argument.pat.span;\n+\n+                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n+                let (ident, is_simple_argument) = match argument.pat.node {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n+                        (ident, true),\n+                    _ => {\n+                        // Replace the ident for bindings that aren't simple.\n+                        let name = format!(\"__arg{}\", index);\n+                        let ident = Ident::from_str(&name);\n+\n+                        (ident, false)\n+                    },\n+                };\n+\n+                let desugared_span =\n+                    this.mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n                 //\n-                // If `<pattern>` is a simple ident, then it is lowered to a single\n-                // `let <pattern> = <pattern>;` statement as an optimization.\n-                for a in arguments.iter().rev() {\n-                    if let Some(pat_stmt) = a.pat_stmt.clone() {\n-                        body.stmts.insert(0, pat_stmt);\n-                    }\n-                    body.stmts.insert(0, a.move_stmt.clone());\n-                }\n+                // If this is the simple case, this argument will end up being the same as the\n+                // original argument, but with a different pattern id.\n+                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n+                let new_argument = hir::Arg {\n+                    hir_id: argument.hir_id,\n+                    pat: new_argument_pat,\n+                };\n \n-                let async_expr = this.make_async_expr(\n-                    CaptureBy::Value, *closure_id, None, body.span,\n-                    |this| {\n-                        let body = this.lower_block(&body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n-                this.expr(body.span, async_expr, ThinVec::new())\n-            } else {\n-                let body = this.lower_block(body, false);\n-                this.expr_block(body, ThinVec::new())\n+                if is_simple_argument {\n+                    // If this is the simple case, then we only insert one statement that is\n+                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n+                    // `HirId`s are densely assigned.\n+                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let stmt = this.stmt_let_pat(\n+                        desugared_span, Some(P(expr)), argument.pat, hir::LocalSource::AsyncFn);\n+                    statements.push(stmt);\n+                } else {\n+                    // If this is not the simple case, then we construct two statements:\n+                    //\n+                    // ```\n+                    // let __argN = __argN;\n+                    // let <pat> = __argN;\n+                    // ```\n+                    //\n+                    // The first statement moves the argument into the closure and thus ensures\n+                    // that the drop order is correct.\n+                    //\n+                    // The second statement creates the bindings that the user wrote.\n+\n+                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n+                    // because the user may have specified a `ref mut` binding in the next\n+                    // statement.\n+                    let (move_pat, move_id) = this.pat_ident_binding_mode(\n+                        desugared_span, ident, hir::BindingAnnotation::Mutable);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_stmt = this.stmt_let_pat(\n+                        desugared_span, Some(P(move_expr)), move_pat, hir::LocalSource::AsyncFn);\n+\n+                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n+                    // argument's pattern so that `HirId`s are densely assigned.\n+                    let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n+                    let pattern_stmt = this.stmt_let_pat(\n+                        desugared_span, Some(P(pattern_expr)), argument.pat,\n+                        hir::LocalSource::AsyncFn);\n+\n+                    statements.push(move_stmt);\n+                    statements.push(pattern_stmt);\n+                };\n+\n+                arguments.push(new_argument);\n             }\n+\n+            let async_expr = this.make_async_expr(\n+                CaptureBy::Value, closure_id, None, body.span,\n+                |this| {\n+                    let body = this.lower_block_with_stmts(body, false, statements);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n \n@@ -3098,7 +3166,6 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Static(\n                     self.lower_ty(\n                         t,\n@@ -3109,11 +3176,10 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     ),\n                     self.lower_mutability(m),\n-                    value,\n+                    self.lower_const_body(e),\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Const(\n                     self.lower_ty(\n                         t,\n@@ -3123,50 +3189,31 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n-                    value\n+                    self.lower_const_body(e)\n                 )\n             }\n-            ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n+            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n-                    let mut lower_fn = |decl: &FnDecl| {\n-                        // Note: we don't need to change the return type from `T` to\n-                        // `impl Future<Output = T>` here because lower_body\n-                        // only cares about the input argument patterns in the function\n-                        // declaration (decl), not the return types.\n-                        let body_id = this.lower_async_body(&decl, &header.asyncness.node, body);\n-\n-                        let (generics, fn_decl) = this.add_in_band_defs(\n-                            generics,\n-                            fn_def_id,\n-                            AnonymousLifetimeMode::PassThrough,\n-                            |this, idty| this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id, idty)),\n-                                true,\n-                                header.asyncness.node.opt_return_id()\n-                            ),\n-                        );\n \n-                        (body_id, generics, fn_decl)\n-                    };\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n+                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n \n-                    let (body_id, generics, fn_decl) = if let IsAsync::Async {\n-                        arguments, ..\n-                    } = &header.asyncness.node {\n-                        let mut decl = decl.clone();\n-                        // Replace the arguments of this async function with the generated\n-                        // arguments that will be moved into the closure.\n-                        for (i, a) in arguments.clone().drain(..).enumerate() {\n-                            if let Some(arg) = a.arg {\n-                                decl.inputs[i] = arg;\n-                            }\n-                        }\n-                        lower_fn(&decl)\n-                    } else {\n-                        lower_fn(decl)\n-                    };\n+                    let (generics, fn_decl) = this.add_in_band_defs(\n+                        generics,\n+                        fn_def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, idty| this.lower_fn_decl(\n+                            &decl,\n+                            Some((fn_def_id, idty)),\n+                            true,\n+                            header.asyncness.node.opt_return_id()\n+                        ),\n+                    );\n \n                     hir::ItemKind::Fn(\n                         fn_decl,\n@@ -3548,7 +3595,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_ty(ty, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n-                        .map(|x| self.lower_body(None, |this| this.lower_expr(x))),\n+                        .map(|x| self.lower_const_body(x)),\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n@@ -3563,7 +3610,7 @@ impl<'a> LoweringContext<'a> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n             TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                let body_id = self.lower_fn_body(&sig.decl, |this| {\n                     let body = this.lower_block(body, false);\n                     this.expr_block(body, ThinVec::new())\n                 });\n@@ -3627,48 +3674,26 @@ impl<'a> LoweringContext<'a> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, node) = match i.node {\n-            ImplItemKind::Const(ref ty, ref expr) => {\n-                let body_id = self.lower_body(None, |this| this.lower_expr(expr));\n-                (\n-                    self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                    hir::ImplItemKind::Const(\n-                        self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                        body_id,\n-                    ),\n-                )\n-            }\n+            ImplItemKind::Const(ref ty, ref expr) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    self.lower_const_body(expr),\n+                ),\n+            ),\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let mut lower_method = |sig: &MethodSig| {\n-                    let body_id = self.lower_async_body(\n-                        &sig.decl, &sig.header.asyncness.node, body\n-                    );\n-                    let impl_trait_return_allow = !self.is_in_trait_impl;\n-                    let (generics, sig) = self.lower_method_sig(\n-                        &i.generics,\n-                        sig,\n-                        impl_item_def_id,\n-                        impl_trait_return_allow,\n-                        sig.header.asyncness.node.opt_return_id(),\n-                    );\n-                    (body_id, generics, sig)\n-                };\n-\n-                let (body_id, generics, sig) = if let IsAsync::Async {\n-                    ref arguments, ..\n-                } = sig.header.asyncness.node {\n-                    let mut sig = sig.clone();\n-                    // Replace the arguments of this async function with the generated\n-                    // arguments that will be moved into the closure.\n-                    for (i, a) in arguments.clone().drain(..).enumerate() {\n-                        if let Some(arg) = a.arg {\n-                            sig.decl.inputs[i] = arg;\n-                        }\n-                    }\n-                    lower_method(&sig)\n-                } else {\n-                    lower_method(sig)\n-                };\n                 self.current_item = Some(i.span);\n+                let body_id = self.lower_maybe_async_body(\n+                    &sig.decl, sig.header.asyncness.node, body\n+                );\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    impl_item_def_id,\n+                    impl_trait_return_allow,\n+                    sig.header.asyncness.node.opt_return_id(),\n+                );\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -3860,7 +3885,7 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics, hir::MethodSig) {\n-        let header = self.lower_fn_header(&sig.header);\n+        let header = self.lower_fn_header(sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n             fn_def_id,\n@@ -3882,10 +3907,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_header(&mut self, h: &FnHeader) -> hir::FnHeader {\n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n             unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(&h.asyncness.node),\n+            asyncness: self.lower_asyncness(h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n             abi: h.abi,\n         }\n@@ -3905,7 +3930,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_asyncness(&mut self, a: &IsAsync) -> hir::IsAsync {\n+    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n         match a {\n             IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n@@ -4064,7 +4089,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_new_scopes(|this| {\n             hir::AnonConst {\n                 hir_id: this.lower_node_id(c.id),\n-                body: this.lower_body(None, |this| this.lower_expr(&c.value)),\n+                body: this.lower_const_body(&c.value),\n             }\n         })\n     }\n@@ -4151,10 +4176,7 @@ impl<'a> LoweringContext<'a> {\n                 let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n \n                 // Lower condition:\n-                let span_block = self\n-                    .sess\n-                    .source_map()\n-                    .mark_span_with_reason(IfTemporary, cond.span, None);\n+                let span_block = self.mark_span_with_reason(IfTemporary, cond.span, None);\n                 let cond = self.lower_expr(cond);\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }` to preserve drop\n                 // semantics since `if cond { ... }` don't let temporaries live outside of `cond`.\n@@ -4184,7 +4206,7 @@ impl<'a> LoweringContext<'a> {\n             }),\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n-                    let unstable_span = this.sess.source_map().mark_span_with_reason(\n+                    let unstable_span = this.mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n                         Some(vec![sym::try_trait].into()),\n@@ -4222,7 +4244,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Await(_origin, ref expr) => self.lower_await(e.span, expr),\n             ExprKind::Closure(\n-                capture_clause, ref asyncness, movability, ref decl, ref body, fn_decl_span\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n@@ -4255,12 +4277,12 @@ impl<'a> LoweringContext<'a> {\n \n                         // Transform `async |x: u8| -> X { ... }` into\n                         // `|x: u8| future_from_generator(|| -> X { ... })`.\n-                        let body_id = this.lower_body(Some(&outer_decl), |this| {\n+                        let body_id = this.lower_fn_body(&outer_decl, |this| {\n                             let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, *closure_id, async_ret_ty, body.span,\n+                                capture_clause, closure_id, async_ret_ty, body.span,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });\n@@ -4281,7 +4303,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_new_scopes(|this| {\n                         this.current_item = Some(fn_decl_span);\n                         let mut is_generator = false;\n-                        let body_id = this.lower_body(Some(decl), |this| {\n+                        let body_id = this.lower_fn_body(decl, |this| {\n                             let e = this.lower_expr(body);\n                             is_generator = this.is_generator;\n                             e\n@@ -4616,7 +4638,7 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let mut head = self.lower_expr(head);\n                 let head_sp = head.span;\n-                let desugared_span = self.sess.source_map().mark_span_with_reason(\n+                let desugared_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::ForLoop,\n                     head_sp,\n                     None,\n@@ -4770,13 +4792,13 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span = self.sess.source_map().mark_span_with_reason(\n+                let unstable_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n                     Some(vec![sym::try_trait].into()),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n-                let try_span = self.sess.source_map().mark_span_with_reason(\n+                let try_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n                     Some(vec![sym::try_trait].into()),\n@@ -5573,12 +5595,12 @@ impl<'a> LoweringContext<'a> {\n             err.emit();\n             return hir::ExprKind::Err;\n         }\n-        let span = self.sess.source_map().mark_span_with_reason(\n+        let span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n             None,\n         );\n-        let gen_future_span = self.sess.source_map().mark_span_with_reason(\n+        let gen_future_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n             Some(vec![sym::gen_future].into()),"}, {"sha": "a4484c81738983c53d434ec3be8086d6c5f78ec4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -64,17 +64,16 @@ impl<'a> DefCollector<'a> {\n         id: NodeId,\n         name: Name,\n         span: Span,\n-        header: &'a FnHeader,\n+        header: &FnHeader,\n         generics: &'a Generics,\n         decl: &'a FnDecl,\n         body: &'a Block,\n     ) {\n-        let (closure_id, return_impl_trait_id, arguments) = match &header.asyncness.node {\n+        let (closure_id, return_impl_trait_id) = match header.asyncness.node {\n             IsAsync::Async {\n                 closure_id,\n                 return_impl_trait_id,\n-                arguments,\n-            } => (closure_id, return_impl_trait_id, arguments),\n+            } => (closure_id, return_impl_trait_id),\n             _ => unreachable!(),\n         };\n \n@@ -83,38 +82,16 @@ impl<'a> DefCollector<'a> {\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, span);\n         return self.with_parent(fn_def, |this| {\n-            this.create_def(*return_impl_trait_id, DefPathData::ImplTrait, span);\n+            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n \n             visit::walk_generics(this, generics);\n-\n-            // Walk the generated arguments for the `async fn`.\n-            for (i, a) in arguments.iter().enumerate() {\n-                use visit::Visitor;\n-                if let Some(arg) = &a.arg {\n-                    this.visit_ty(&arg.ty);\n-                } else {\n-                    this.visit_ty(&decl.inputs[i].ty);\n-                }\n-            }\n-\n-            // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n-            // replaced.\n-            visit::walk_fn_ret_ty(this, &decl.output);\n+            visit::walk_fn_decl(this, decl);\n \n             let closure_def = this.create_def(\n-                *closure_id, DefPathData::ClosureExpr, span,\n+                closure_id, DefPathData::ClosureExpr, span,\n             );\n             this.with_parent(closure_def, |this| {\n-                use visit::Visitor;\n-                // Walk each of the generated statements before the regular block body.\n-                for a in arguments {\n-                    this.visit_stmt(&a.move_stmt);\n-                    if let Some(pat_stmt) = &a.pat_stmt {\n-                        this.visit_stmt(&pat_stmt);\n-                    }\n-                }\n-\n-                visit::walk_block(this, &body);\n+                visit::walk_block(this, body);\n             })\n         })\n     }\n@@ -302,7 +279,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(_, ref asyncness, ..) => {\n+            ExprKind::Closure(_, asyncness, ..) => {\n                 let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           expr.span);\n@@ -311,7 +288,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let async_def = self.create_def(*closure_id,\n+                    let async_def = self.create_def(closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     expr.span);\n                     self.parent_def = Some(async_def);"}, {"sha": "65fc56f2c48787e8d1747f4aa912d549bd214888", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -1929,26 +1929,6 @@ pub struct InlineAsm {\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub hir_id: HirId,\n-    pub source: ArgSource,\n-}\n-\n-impl Arg {\n-    /// Returns the pattern representing the original binding for this argument.\n-    pub fn original_pat(&self) -> &P<Pat> {\n-        match &self.source {\n-            ArgSource::Normal => &self.pat,\n-            ArgSource::AsyncFn(pat) => &pat,\n-        }\n-    }\n-}\n-\n-/// Represents the source of an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ArgSource {\n-    /// Argument as specified by the user.\n-    Normal,\n-    /// Generated argument from `async fn` lowering, contains the original binding pattern.\n-    AsyncFn(P<Pat>),\n }\n \n /// Represents the header (not the body) of a function declaration."}, {"sha": "ecdcb4bbf114a44de9a37f4c530c3d4ef42748b8", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -86,12 +86,12 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.original_pat().simple_ident() {\n+        let span_label_var1 = match anon_arg_sup.pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.original_pat().simple_ident() {\n+        let span_label_var2 = match anon_arg_sub.pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "0efc124e31fee10350238d7be32f935ef6639813", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.original_pat().simple_ident() {\n+        let (error_var, span_label_var) = match arg.pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "c5c6c4b944700c0fdef79fb6a6a9debda17d9528", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -1335,30 +1335,6 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n         run_early_pass!(self, check_mac, mac);\n     }\n-\n-    fn visit_fn_header(&mut self, header: &'a ast::FnHeader) {\n-        // Unlike in HIR lowering and name resolution, the `AsyncArgument` statements are not added\n-        // to the function body and the arguments do not replace those in the declaration. They are\n-        // still visited manually here so that buffered lints can be emitted.\n-        if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n-            for a in arguments {\n-                // Visit the argument..\n-                if let Some(arg) = &a.arg {\n-                    self.visit_pat(&arg.pat);\n-                    if let ast::ArgSource::AsyncFn(pat) = &arg.source {\n-                        self.visit_pat(pat);\n-                    }\n-                    self.visit_ty(&arg.ty);\n-                }\n-\n-                // ..and the statement.\n-                self.visit_stmt(&a.move_stmt);\n-                if let Some(pat_stmt) = &a.pat_stmt {\n-                    self.visit_stmt(&pat_stmt);\n-                }\n-            }\n-        }\n-    }\n }\n \n struct LateLintPassObjects<'a> {"}, {"sha": "7c57c50595bc8db00ac47645db65b10a0a97c325", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -2414,9 +2414,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 have_bound_regions,\n             } = info;\n \n-            let help_name = if let Some(body) = parent {\n-                let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.original_pat().hir_id))\n+            let help_name = if let Some(ident) = parent.and_then(|body| {\n+                self.tcx.hir().body(body).arguments[index].pat.simple_ident()\n+            }) {\n+                format!(\"`{}`\", ident)\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };"}, {"sha": "4a4787337ab582d92b2fffc82fafc21d0c22a59a", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -52,6 +52,19 @@ struct GatherUsedMutsVisitor<'visit, 'cx: 'visit, 'gcx: 'tcx, 'tcx: 'cx> {\n     mbcx: &'visit mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n }\n \n+impl GatherUsedMutsVisitor<'_, '_, '_, '_> {\n+    fn remove_never_initialized_mut_locals(&mut self, into: &Place<'_>) {\n+        // Remove any locals that we found were initialized from the\n+        // `never_initialized_mut_locals` set. At the end, the only remaining locals will\n+        // be those that were never initialized - we will consider those as being used as\n+        // they will either have been removed by unreachable code optimizations; or linted\n+        // as unused variables.\n+        if let Some(local) = into.base_local() {\n+            let _ = self.never_initialized_mut_locals.remove(&local);\n+        }\n+    }\n+}\n+\n impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'gcx, 'tcx> {\n     fn visit_terminator_kind(\n         &mut self,\n@@ -61,14 +74,10 @@ impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'c\n         debug!(\"visit_terminator_kind: kind={:?}\", kind);\n         match &kind {\n             TerminatorKind::Call { destination: Some((into, _)), .. } => {\n-                if let Some(local) = into.base_local() {\n-                    debug!(\n-                        \"visit_terminator_kind: kind={:?} local={:?} \\\n-                         never_initialized_mut_locals={:?}\",\n-                        kind, local, self.never_initialized_mut_locals\n-                    );\n-                    let _ = self.never_initialized_mut_locals.remove(&local);\n-                }\n+                self.remove_never_initialized_mut_locals(&into);\n+            },\n+            TerminatorKind::DropAndReplace { location, .. } => {\n+                self.remove_never_initialized_mut_locals(&location);\n             },\n             _ => {},\n         }\n@@ -81,19 +90,14 @@ impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'c\n     ) {\n         match &statement.kind {\n             StatementKind::Assign(into, _) => {\n-                // Remove any locals that we found were initialized from the\n-                // `never_initialized_mut_locals` set. At the end, the only remaining locals will\n-                // be those that were never initialized - we will consider those as being used as\n-                // they will either have been removed by unreachable code optimizations; or linted\n-                // as unused variables.\n                 if let Some(local) = into.base_local() {\n                     debug!(\n                         \"visit_statement: statement={:?} local={:?} \\\n                          never_initialized_mut_locals={:?}\",\n                         statement, local, self.never_initialized_mut_locals\n                     );\n-                    let _ = self.never_initialized_mut_locals.remove(&local);\n                 }\n+                self.remove_never_initialized_mut_locals(into);\n             },\n             _ => {},\n         }"}, {"sha": "91106ebd77e070d63ac9c6d3ff8bc5b1c922edb4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -126,6 +126,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n                             opt_ty_info = None;\n                             self_arg = None;\n                         }\n+\n                         ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&*arg.pat), self_arg)\n                     });\n \n@@ -614,10 +615,7 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'gcx>(Ty<'gcx>,\n-                     Option<Span>,\n-                     Option<&'gcx hir::Pat>,\n-                     Option<ImplicitSelfKind>);\n+struct ArgInfo<'gcx>(Ty<'gcx>, Option<Span>, Option<&'gcx hir::Pat>, Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: hir::HirId,\n@@ -883,21 +881,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // debuginfo and so that error reporting knows that this is a user\n             // variable. For any other pattern the pattern introduces new\n             // variables which will be named instead.\n-            let mut name = None;\n-            if let Some(pat) = pattern {\n-                match pat.node {\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _)\n-                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, _) => {\n-                        name = Some(ident.name);\n-                    }\n-                    _ => (),\n-                }\n-            }\n-\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span: pattern.map_or(self.fn_span, |pat| pat.span)\n+            let (name, span) = if let Some(pat) = pattern {\n+                (pat.simple_ident().map(|ident| ident.name), pat.span)\n+            } else {\n+                (None, self.fn_span)\n             };\n+\n+            let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span, };\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n@@ -932,7 +922,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n-                    PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n+                    PatternKind::Binding {\n+                        mutability,\n+                        var,\n+                        mode: BindingMode::ByValue,\n+                        subpattern: None,\n+                        ..\n+                    } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].is_user_variable =\n                             if let Some(kind) = self_binding {"}, {"sha": "ff7a9984da4ee164d11a58741a5dd3b67b591fba", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{InterpretCx, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n+use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -306,6 +306,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"Unsizing {:?} into {:?}\", src, dest);\n         match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, d, _)) |\n             (&ty::Ref(_, s, _), &ty::RawPtr(TypeAndMut { ty: d, .. })) |\n@@ -335,20 +336,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     if dst_field.layout.is_zst() {\n                         continue;\n                     }\n-                    let src_field = match src.try_as_mplace() {\n-                        Ok(mplace) => {\n-                            let src_field = self.mplace_field(mplace, i as u64)?;\n-                            src_field.into()\n-                        }\n-                        Err(..) => {\n-                            let src_field_layout = src.layout.field(self, i)?;\n-                            // this must be a field covering the entire thing\n-                            assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(src_field_layout.size, src.layout.size);\n-                            // just sawp out the layout\n-                            OpTy::from(ImmTy { imm: src.to_immediate(), layout: src_field_layout })\n-                        }\n-                    };\n+                    let src_field = self.operand_field(src, i as u64)?;\n                     if src_field.layout.ty == dst_field.layout.ty {\n                         self.copy_op(src_field, dst_field)?;\n                     } else {"}, {"sha": "89c4a9106a4773a7dbc593b8d2842b87b58a74b6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -222,7 +222,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_trait_fn_not_async(&self, span: Span, asyncness: &IsAsync) {\n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n         if asyncness.is_async() {\n             struct_span_err!(self.session, span, E0706,\n                              \"trait fns cannot be declared `async`\").emit()\n@@ -561,7 +561,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_trait_fn_not_async(impl_item.span, &sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n                 }\n             }\n@@ -633,7 +633,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n-                        self.check_trait_fn_not_async(trait_item.span, &sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {"}, {"sha": "f084d3b9f28c3a4c8c7dae9793f215a4fd24cf58", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -948,16 +948,6 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n         intravisit::walk_pat(self, pat);\n     }\n-\n-    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1147,16 +1137,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n-\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {"}, {"sha": "99abe69017da729245d96620c4576ded94a23c87", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -855,15 +855,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 _: NodeId)\n     {\n         debug!(\"(resolving function) entering function\");\n-        let (rib_kind, asyncness) = match function_kind {\n-            FnKind::ItemFn(_, ref header, ..) =>\n-                (FnItemRibKind, &header.asyncness.node),\n-            FnKind::Method(_, ref sig, _, _) =>\n-                (AssocItemRibKind, &sig.header.asyncness.node),\n-            FnKind::Closure(_) =>\n-                // Async closures aren't resolved through `visit_fn`-- they're\n-                // processed separately\n-                (NormalRibKind, &IsAsync::NotAsync),\n+        let rib_kind = match function_kind {\n+            FnKind::ItemFn(..) => FnItemRibKind,\n+            FnKind::Method(..) => AssocItemRibKind,\n+            FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n@@ -874,45 +869,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n \n         // Add each argument to the rib.\n         let mut bindings_list = FxHashMap::default();\n-        let mut add_argument = |argument: &ast::Arg| {\n+        for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n             self.visit_ty(&argument.ty);\n-            debug!(\"(resolving function) recorded argument\");\n-        };\n \n-        // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n-        // normal arguments.\n-        if let IsAsync::Async { ref arguments, .. } = asyncness {\n-            for (i, a) in arguments.iter().enumerate() {\n-                if let Some(arg) = &a.arg {\n-                    add_argument(&arg);\n-                } else {\n-                    add_argument(&declaration.inputs[i]);\n-                }\n-            }\n-        } else {\n-            for a in &declaration.inputs { add_argument(a); }\n+            debug!(\"(resolving function) recorded argument\");\n         }\n-\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n         match function_kind {\n-            FnKind::ItemFn(.., body) | FnKind::Method(.., body) => {\n-                if let IsAsync::Async { ref arguments, .. } = asyncness {\n-                    let mut body = body.clone();\n-                    // Insert the generated statements into the body before attempting to\n-                    // resolve names.\n-                    for a in arguments.iter().rev() {\n-                        if let Some(pat_stmt) = a.pat_stmt.clone() {\n-                            body.stmts.insert(0, pat_stmt);\n-                        }\n-                        body.stmts.insert(0, a.move_stmt.clone());\n-                    }\n-                    self.visit_block(&body);\n-                } else {\n-                    self.visit_block(body);\n-                }\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n             }\n             FnKind::Closure(body) => {\n                 self.visit_expr(body);\n@@ -4178,7 +4148,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if !ident.is_gensymed() && filter_fn(binding.res()) {\n+                    if filter_fn(binding.res()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.res().article(),\n@@ -4196,7 +4166,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n-                    if !ident.is_gensymed() && filter_fn(res) {\n+                    if filter_fn(res) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: res.article(),\n@@ -4226,7 +4196,7 @@ impl<'a> Resolver<'a> {\n                                             },\n                                         );\n \n-                                        if !ident.is_gensymed() && filter_fn(crate_mod) {\n+                                        if filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4249,15 +4219,13 @@ impl<'a> Resolver<'a> {\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types\n-                        .iter()\n-                        .map(|(name, _)| {\n-                            TypoSuggestion {\n-                                candidate: *name,\n-                                article: \"a\",\n-                                kind: \"primitive type\",\n-                            }\n-                        })\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n+                        TypoSuggestion {\n+                            candidate: *name,\n+                            article: \"a\",\n+                            kind: \"primitive type\",\n+                        }\n+                    })\n                 )\n             }\n         } else {"}, {"sha": "db8b5eacd94d9321f2f7e7b9b1175f927590e693", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -374,7 +374,7 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, ref header, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n                 let mut text = String::new();\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");"}, {"sha": "f05e0d31582fa20cd3204446ba63c2c77fc96096", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -324,6 +324,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 );\n                             }\n                         }\n+                        if let ty::RawPtr(_) = &actual.sty {\n+                            err.note(\"try using `<*const T>::as_ref()` to get a reference to the \\\n+                                      type behind the pointer: https://doc.rust-lang.org/std/\\\n+                                      primitive.pointer.html#method.as_ref\");\n+                        }\n                         err\n                     }\n                 } else {"}, {"sha": "3ada80b3e8b7015e03df59364917ae815ec77cbd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -1009,16 +1009,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 _: hir::BodyId, _: Span, _: hir::HirId) { }\n-\n-    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n /// When `check_fn` is invoked on a generator (i.e., a body that"}, {"sha": "6f8682e64671c3fb4afe381816858d7c0f7c907d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -311,16 +311,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         let ty = self.resolve(&ty, &hir_ty.span);\n         self.write_ty_to_tables(hir_ty.hir_id, ty);\n     }\n-\n-    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "3034cacf6253f966a98d1971db00de78995358ba", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 82, "deletions": 73, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -1335,88 +1335,97 @@ pub fn checked_type_of<'a, 'tcx>(\n \n                 Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n                 Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) => {\n+                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) |\n+                Node::TraitRef(..) => {\n                     let path = match parent_node {\n-                        Node::Ty(&hir::Ty { node: hir::TyKind::Path(ref path), .. }) |\n-                        Node::Expr(&hir::Expr { node: ExprKind::Path(ref path), .. }) => {\n-                            path\n+                        Node::Ty(&hir::Ty {\n+                            node: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        })\n+                        | Node::Expr(&hir::Expr {\n+                            node: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        }) => {\n+                            Some(&**path)\n                         }\n                         Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n-                            &*path\n+                            if let QPath::Resolved(_, ref path) = **path {\n+                                Some(&**path)\n+                            } else {\n+                                None\n+                            }\n                         }\n-                        _ => unreachable!(),\n+                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(path),\n+                        _ => None,\n                     };\n \n-                    match path {\n-                        QPath::Resolved(_, ref path) => {\n-                            let arg_index = path.segments.iter()\n-                                .filter_map(|seg| seg.args.as_ref())\n-                                .map(|generic_args| generic_args.args.as_ref())\n-                                .find_map(|args| {\n-                                    args.iter()\n-                                        .filter(|arg| arg.is_const())\n-                                        .enumerate()\n-                                        .filter(|(_, arg)| arg.id() == hir_id)\n-                                        .map(|(index, _)| index)\n-                                        .next()\n-                                })\n-                                .or_else(|| {\n-                                    if !fail {\n-                                        None\n-                                    } else {\n-                                        bug!(\"no arg matching AnonConst in path\")\n-                                    }\n-                                })?;\n-\n-                            // We've encountered an `AnonConst` in some path, so we need to\n-                            // figure out which generic parameter it corresponds to and return\n-                            // the relevant type.\n-                            let generics = match path.res {\n-                                Res::Def(DefKind::Ctor(..), def_id) =>\n-                                    tcx.generics_of(tcx.parent(def_id).unwrap()),\n-                                Res::Def(_, def_id) =>\n-                                    tcx.generics_of(def_id),\n-                                Res::Err =>\n-                                    return Some(tcx.types.err),\n-                                _ if !fail =>\n-                                    return None,\n-                                x => {\n-                                    tcx.sess.delay_span_bug(\n-                                        DUMMY_SP,\n-                                        &format!(\n-                                            \"unexpected const parent path def {:?}\", x\n-                                        ),\n-                                    );\n-                                    return Some(tcx.types.err);\n+                    if let Some(path) = path {\n+                        let arg_index = path.segments.iter()\n+                            .filter_map(|seg| seg.args.as_ref())\n+                            .map(|generic_args| generic_args.args.as_ref())\n+                            .find_map(|args| {\n+                                args.iter()\n+                                    .filter(|arg| arg.is_const())\n+                                    .enumerate()\n+                                    .filter(|(_, arg)| arg.id() == hir_id)\n+                                    .map(|(index, _)| index)\n+                                    .next()\n+                            })\n+                            .or_else(|| {\n+                                if !fail {\n+                                    None\n+                                } else {\n+                                    bug!(\"no arg matching AnonConst in path\")\n                                 }\n-                            };\n-\n-                            generics.params.iter()\n-                                .filter(|param| {\n-                                    if let ty::GenericParamDefKind::Const = param.kind {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                                .nth(arg_index)\n-                                .map(|param| tcx.type_of(param.def_id))\n-                                // This is no generic parameter associated with the arg. This is\n-                                // probably from an extra arg where one is not needed.\n-                                .unwrap_or(tcx.types.err)\n-                        }\n-                        x => {\n-                            if !fail {\n-                                return None;\n+                            })?;\n+\n+                        // We've encountered an `AnonConst` in some path, so we need to\n+                        // figure out which generic parameter it corresponds to and return\n+                        // the relevant type.\n+                        let generics = match path.res {\n+                            Res::Def(DefKind::Ctor(..), def_id) => {\n+                                tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"unexpected const parent path {:?}\", x\n-                                ),\n-                            );\n-                            tcx.types.err\n+                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                            Res::Err => return Some(tcx.types.err),\n+                            _ if !fail => return None,\n+                            res => {\n+                                tcx.sess.delay_span_bug(\n+                                    DUMMY_SP,\n+                                    &format!(\n+                                        \"unexpected const parent path def {:?}\",\n+                                        res,\n+                                    ),\n+                                );\n+                                return Some(tcx.types.err);\n+                            }\n+                        };\n+\n+                        generics.params.iter()\n+                            .filter(|param| {\n+                                if let ty::GenericParamDefKind::Const = param.kind {\n+                                    true\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                            .nth(arg_index)\n+                            .map(|param| tcx.type_of(param.def_id))\n+                            // This is no generic parameter associated with the arg. This is\n+                            // probably from an extra arg where one is not needed.\n+                            .unwrap_or(tcx.types.err)\n+                    } else {\n+                        if !fail {\n+                            return None;\n                         }\n+                        tcx.sess.delay_span_bug(\n+                            DUMMY_SP,\n+                            &format!(\n+                                \"unexpected const parent path {:?}\",\n+                                parent_node,\n+                            ),\n+                        );\n+                        return Some(tcx.types.err);\n                     }\n                 }\n "}, {"sha": "0c00b3b20b5b3f36c8391580f64206e67b6960f7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -2019,7 +2019,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 Argument {\n-                    name: name_from_pat(&body.arguments[i].original_pat()),\n+                    name: name_from_pat(&body.arguments[i].pat),\n                     type_: ty.clean(cx),\n                 }\n             }).collect()"}, {"sha": "b8a10d90c3c0afe10974137fa06b5238d4a5e05a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -879,17 +879,6 @@ pub struct Local {\n     pub id: NodeId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n-    /// Origin of this local variable.\n-    pub source: LocalSource,\n-}\n-\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n-pub enum LocalSource {\n-    /// Local was parsed from source.\n-    Normal,\n-    /// Within `ast::IsAsync::Async`, a local is generated that will contain the moved arguments\n-    /// of an `async fn`.\n-    AsyncFn,\n }\n \n /// An arm of a 'match'.\n@@ -1770,16 +1759,6 @@ pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n-    pub source: ArgSource,\n-}\n-\n-/// The source of an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ArgSource {\n-    /// Argument as written by the user.\n-    Normal,\n-    /// Argument from `async fn` lowering, contains the original binding pattern.\n-    AsyncFn(P<Pat>),\n }\n \n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n@@ -1839,7 +1818,6 @@ impl Arg {\n             }),\n             ty,\n             id: DUMMY_NODE_ID,\n-            source: ArgSource::Normal,\n         };\n         match eself.node {\n             SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n@@ -1894,52 +1872,31 @@ pub enum Unsafety {\n     Normal,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct AsyncArgument {\n-    /// `__arg0`\n-    pub ident: Ident,\n-    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`. Only if\n-    /// argument is not a simple binding.\n-    pub arg: Option<Arg>,\n-    /// `let __arg0 = __arg0;` statement to be inserted at the start of the block.\n-    pub move_stmt: Stmt,\n-    /// `let <pat> = __arg0;` statement to be inserted at the start of the block, after matching\n-    /// move statement. Only if argument is not a simple binding.\n-    pub pat_stmt: Option<Stmt>,\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async {\n         closure_id: NodeId,\n         return_impl_trait_id: NodeId,\n-        /// This field stores the arguments and statements that are used in HIR lowering to\n-        /// ensure that `async fn` arguments are dropped at the correct time.\n-        ///\n-        /// The argument and statements here are generated at parse time as they are required in\n-        /// both the hir lowering, def collection and name resolution and this stops them needing\n-        /// to be created in each place.\n-        arguments: Vec<AsyncArgument>,\n     },\n     NotAsync,\n }\n \n impl IsAsync {\n-    pub fn is_async(&self) -> bool {\n-        if let IsAsync::Async { .. } = *self {\n+    pub fn is_async(self) -> bool {\n+        if let IsAsync::Async { .. } = self {\n             true\n         } else {\n             false\n         }\n     }\n \n     /// In ths case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(&self) -> Option<NodeId> {\n+    pub fn opt_return_id(self) -> Option<NodeId> {\n         match self {\n             IsAsync::Async {\n                 return_impl_trait_id,\n                 ..\n-            } => Some(*return_impl_trait_id),\n+            } => Some(return_impl_trait_id),\n             IsAsync::NotAsync => None,\n         }\n     }\n@@ -2279,7 +2236,7 @@ impl Item {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: Spanned<IsAsync>,"}, {"sha": "47c79f8466a95c486983fc5f1b33a4409865a562", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -516,7 +516,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -545,7 +544,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -563,7 +561,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -971,8 +968,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::Arg {\n             ty,\n             pat: arg_pat,\n-            id: ast::DUMMY_NODE_ID,\n-            source: ast::ArgSource::Normal,\n+            id: ast::DUMMY_NODE_ID\n         }\n     }\n "}, {"sha": "c56c156182bd66089c3202bc7aa72d41003ae508", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -101,13 +101,6 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n         self.expanded_fragments.remove(&id).unwrap()\n     }\n-\n-    fn next_id(&mut self, id: &mut ast::NodeId) {\n-        if self.monotonic {\n-            assert_eq!(*id, ast::DUMMY_NODE_ID);\n-            *id = self.cx.resolver.next_node_id()\n-        }\n-    }\n }\n \n impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n@@ -189,19 +182,9 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         noop_visit_block(block, self);\n \n         for stmt in block.stmts.iter_mut() {\n-            self.next_id(&mut stmt.id);\n-        }\n-    }\n-\n-    fn visit_asyncness(&mut self, a: &mut ast::IsAsync) {\n-        noop_visit_asyncness(a, self);\n-\n-        if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n-            for argument in arguments.iter_mut() {\n-                self.next_id(&mut argument.move_stmt.id);\n-                if let Some(ref mut pat_stmt) = &mut argument.pat_stmt {\n-                    self.next_id(&mut pat_stmt.id);\n-                }\n+            if self.monotonic {\n+                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                stmt.id = self.cx.resolver.next_node_id();\n             }\n         }\n     }"}, {"sha": "757513098995be60379061d73adeb29c129ba635", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -207,10 +207,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_local(l, self);\n     }\n \n-    fn visit_local_source(&mut self, l: &mut LocalSource) {\n-        noop_visit_local_source(l, self);\n-    }\n-\n     fn visit_mac(&mut self, _mac: &mut Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // N.B., see note about macros above. If you really want a visitor that\n@@ -234,10 +230,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_arg(a, self);\n     }\n \n-    fn visit_arg_source(&mut self, a: &mut ArgSource) {\n-        noop_visit_arg_source(a, self);\n-    }\n-\n     fn visit_generics(&mut self, generics: &mut Generics) {\n         noop_visit_generics(generics, self);\n     }\n@@ -522,17 +514,13 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(args: &mut Parenth\n }\n \n pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n-    let Local { id, pat, ty, init, span, attrs, source } = local.deref_mut();\n+    let Local { id, pat, ty, init, span, attrs } = local.deref_mut();\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(ty, |ty| vis.visit_ty(ty));\n     visit_opt(init, |init| vis.visit_expr(init));\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n-    vis.visit_local_source(source);\n-}\n-\n-pub fn noop_visit_local_source<T: MutVisitor>(_local_source: &mut LocalSource, _vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n@@ -571,18 +559,10 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty, source }: &mut Arg, vis: &mut T) {\n+pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty }: &mut Arg, vis: &mut T) {\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     vis.visit_ty(ty);\n-    vis.visit_arg_source(source);\n-}\n-\n-pub fn noop_visit_arg_source<T: MutVisitor>(source: &mut ArgSource, vis: &mut T) {\n-    match source {\n-        ArgSource::Normal => {},\n-        ArgSource::AsyncFn(pat) => vis.visit_pat(pat),\n-    }\n }\n \n pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n@@ -690,25 +670,9 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n \n pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T) {\n     match asyncness {\n-        IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n+        IsAsync::Async { closure_id, return_impl_trait_id } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n-            for AsyncArgument { ident, arg, pat_stmt, move_stmt } in arguments.iter_mut() {\n-                vis.visit_ident(ident);\n-                if let Some(arg) = arg {\n-                    vis.visit_arg(arg);\n-                }\n-                visit_clobber(move_stmt, |stmt| {\n-                    vis.flat_map_stmt(stmt)\n-                        .expect_one(\"expected visitor to produce exactly one item\")\n-                });\n-                visit_opt(pat_stmt, |stmt| {\n-                    visit_clobber(stmt, |stmt| {\n-                        vis.flat_map_stmt(stmt)\n-                            .expect_one(\"expected visitor to produce exactly one item\")\n-                    })\n-                });\n-            }\n         }\n         IsAsync::NotAsync => {}\n     }"}, {"sha": "5df22f28797a4813a49d7530e517e1f2f123de3d", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -27,7 +27,7 @@ crate fn dummy_arg(ident: Ident) -> Arg {\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n-    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal }\n+    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n }\n \n pub enum Error {"}, {"sha": "ae1e5116c676e884847f1715be28fc1cd2ac15e2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 132, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -1,9 +1,9 @@\n // ignore-tidy-filelength\n \n-use crate::ast::{AngleBracketedArgs, AsyncArgument, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n-use crate::ast::{Mod, AnonConst, Arg, ArgSource, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n+use crate::ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n use crate::ast::Block;\n use crate::ast::{BlockCheckMode, CaptureBy, Movability};\n use crate::ast::{Constness, Crate};\n@@ -16,7 +16,7 @@ use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n use crate::ast::{Label, Lifetime};\n-use crate::ast::{Local, LocalSource};\n+use crate::ast::Local;\n use crate::ast::MacStmtStyle;\n use crate::ast::{Mac, Mac_, MacDelimiter};\n use crate::ast::{MutTy, Mutability};\n@@ -51,7 +51,7 @@ use crate::parse::diagnostics::{Error, dummy_arg};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n-use syntax_pos::{Span, BytePos, DUMMY_SP, FileName, hygiene::CompilerDesugaringKind};\n+use syntax_pos::{Span, BytePos, DUMMY_SP, FileName};\n use log::debug;\n \n use std::borrow::Cow;\n@@ -1126,7 +1126,6 @@ impl<'a> Parser<'a> {\n             IsAsync::Async {\n                 closure_id: ast::DUMMY_NODE_ID,\n                 return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                arguments: Vec::new(),\n             }\n         } else {\n             IsAsync::NotAsync\n@@ -1185,12 +1184,12 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n \n-            let mut decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n+            let decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n                 // This is somewhat dubious; We don't want to allow\n                 // argument names to be left off if there is a\n                 // definition...\n@@ -1199,7 +1198,6 @@ impl<'a> Parser<'a> {\n                 p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n-            self.construct_async_arguments(&mut asyncness, &mut decl);\n \n             let sig = ast::MethodSig {\n                 header: FnHeader {\n@@ -1563,7 +1561,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal })\n+        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n     }\n \n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n@@ -1581,8 +1579,7 @@ impl<'a> Parser<'a> {\n         Ok(Arg {\n             ty: t,\n             pat,\n-            id: ast::DUMMY_NODE_ID,\n-            source: ast::ArgSource::Normal,\n+            id: ast::DUMMY_NODE_ID\n         })\n     }\n \n@@ -4213,7 +4210,6 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n             attrs,\n-            source: LocalSource::Normal,\n         }))\n     }\n \n@@ -5244,9 +5240,13 @@ impl<'a> Parser<'a> {\n                     // FIXME(const_generics): to distinguish between idents for types and consts,\n                     // we should introduce a GenericArg::Ident in the AST and distinguish when\n                     // lowering to the HIR. For now, idents for const args are not permitted.\n-                    return Err(\n-                        self.fatal(\"identifiers may currently not be used for const generics\")\n-                    );\n+                    if self.token.is_keyword(kw::True) || self.token.is_keyword(kw::False) {\n+                        self.parse_literal_maybe_minus()?\n+                    } else {\n+                        return Err(\n+                            self.fatal(\"identifiers may currently not be used for const generics\")\n+                        );\n+                    }\n                 } else {\n                     self.parse_literal_maybe_minus()?\n                 };\n@@ -5660,16 +5660,15 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n-                     mut asyncness: Spanned<IsAsync>,\n+                     asyncness: Spanned<IsAsync>,\n                      constness: Spanned<Constness>,\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n-        let mut decl = self.parse_fn_decl(allow_c_variadic)?;\n+        let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        self.construct_async_arguments(&mut asyncness, &mut decl);\n         let header = FnHeader { unsafety, asyncness, constness, abi };\n         Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n     }\n@@ -5849,14 +5848,13 @@ impl<'a> Parser<'a> {\n             Ok((Ident::invalid(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let mut decl = self.parse_fn_decl_with_self(|p| {\n+            let decl = self.parse_fn_decl_with_self(|p| {\n                 p.parse_arg_general(true, true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n-            self.construct_async_arguments(&mut asyncness, &mut decl);\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n@@ -7218,7 +7216,6 @@ impl<'a> Parser<'a> {\n                                     respan(async_span, IsAsync::Async {\n                                         closure_id: ast::DUMMY_NODE_ID,\n                                         return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                                        arguments: Vec::new(),\n                                     }),\n                                     respan(fn_span, Constness::NotConst),\n                                     Abi::Rust)?;\n@@ -7849,116 +7846,6 @@ impl<'a> Parser<'a> {\n             Applicability::MaybeIncorrect,\n         ).emit();\n     }\n-\n-    /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n-    /// into the generated closure so that they are dropped when the future is polled and not when\n-    /// it is created.\n-    ///\n-    /// The arguments of the function are replaced in HIR lowering with the arguments created by\n-    /// this function and the statements created here are inserted at the top of the closure body.\n-    fn construct_async_arguments(&mut self, asyncness: &mut Spanned<IsAsync>, decl: &mut FnDecl) {\n-        // FIXME(davidtwco): This function should really live in the HIR lowering but because\n-        // the types constructed here need to be used in parts of resolve so that the correct\n-        // locals are considered upvars, it is currently easier for it to live here in the parser,\n-        // where it can be constructed once.\n-        if let IsAsync::Async { ref mut arguments, .. } = asyncness.node {\n-            for (index, input) in decl.inputs.iter_mut().enumerate() {\n-                let id = ast::DUMMY_NODE_ID;\n-                let span = input.pat.span;\n-                let desugared_span = self.sess.source_map()\n-                    .mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n-\n-                // Construct a name for our temporary argument.\n-                let name = format!(\"__arg{}\", index);\n-                let ident = Ident::from_str(&name).gensym();\n-\n-                // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n-                // statement.\n-                let (binding_mode, ident, is_simple_pattern) = match input.pat.node {\n-                    PatKind::Ident(binding_mode @ BindingMode::ByValue(_), ident, _) => {\n-                        // Simple patterns like this don't have a generated argument, but they are\n-                        // moved into the closure with a statement, so any `mut` bindings on the\n-                        // argument will be unused. This binding mode can't be removed, because\n-                        // this would affect the input to procedural macros, but they can have\n-                        // their span marked as being the result of a compiler desugaring so\n-                        // that they aren't linted against.\n-                        input.pat.span = desugared_span;\n-\n-                        (binding_mode, ident, true)\n-                    }\n-                    _ => (BindingMode::ByValue(Mutability::Mutable), ident, false),\n-                };\n-\n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function if it isn't a simple pattern.\n-                let arg = if is_simple_pattern {\n-                    None\n-                } else {\n-                    Some(Arg {\n-                        ty: input.ty.clone(),\n-                        id,\n-                        pat: P(Pat {\n-                            id,\n-                            node: PatKind::Ident(\n-                                BindingMode::ByValue(Mutability::Immutable), ident, None,\n-                            ),\n-                            span: desugared_span,\n-                        }),\n-                        source: ArgSource::AsyncFn(input.pat.clone()),\n-                    })\n-                };\n-\n-                // Construct a `let __argN = __argN;` statement to insert at the top of the\n-                // async closure. This makes sure that the argument is captured by the closure and\n-                // that the drop order is correct.\n-                let move_local = Local {\n-                    pat: P(Pat {\n-                        id,\n-                        node: PatKind::Ident(binding_mode, ident, None),\n-                        span: desugared_span,\n-                    }),\n-                    // We explicitly do not specify the type for this statement. When the user's\n-                    // argument type is `impl Trait` then this would require the\n-                    // `impl_trait_in_bindings` feature to also be present for that same type to\n-                    // be valid in this binding. At the time of writing (13 Mar 19),\n-                    // `impl_trait_in_bindings` is not stable.\n-                    ty: None,\n-                    init: Some(P(Expr {\n-                        id,\n-                        node: ExprKind::Path(None, ast::Path {\n-                            span,\n-                            segments: vec![PathSegment { ident, id, args: None }],\n-                        }),\n-                        span,\n-                        attrs: ThinVec::new(),\n-                    })),\n-                    id,\n-                    span,\n-                    attrs: ThinVec::new(),\n-                    source: LocalSource::AsyncFn,\n-                };\n-\n-                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n-                // async closure if this isn't a simple pattern.\n-                let pat_stmt = if is_simple_pattern {\n-                    None\n-                } else {\n-                    Some(Stmt {\n-                        id,\n-                        node: StmtKind::Local(P(Local {\n-                            pat: input.pat.clone(),\n-                            ..move_local.clone()\n-                        })),\n-                        span,\n-                    })\n-                };\n-\n-                let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n-                arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n-            }\n-        }\n-    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "b81dc53ef6836061b2a5b107b4da3cf994e00534", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -357,7 +357,7 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n-                     header: &ast::FnHeader,\n+                     header: ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n                      -> String {\n@@ -1040,7 +1040,7 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n-                self.print_fn(decl, &ast::FnHeader::default(),\n+                self.print_fn(decl, ast::FnHeader::default(),\n                               Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n@@ -1170,7 +1170,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, ref header, ref param_names, ref body) => {\n+            ast::ItemKind::Fn(ref decl, header, ref param_names, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n@@ -1522,7 +1522,7 @@ impl<'a> State<'a> {\n                             vis: &ast::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      &m.header,\n+                      m.header,\n                       Some(ident),\n                       &generics,\n                       vis)\n@@ -2113,7 +2113,7 @@ impl<'a> State<'a> {\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n             ast::ExprKind::Closure(\n-                capture_clause, ref asyncness, movability, ref decl, ref body, _) => {\n+                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n                 self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n@@ -2710,7 +2710,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    header: &ast::FnHeader,\n+                    header: ast::FnHeader,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     vis: &ast::Visibility) -> io::Result<()> {\n@@ -2765,7 +2765,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_asyncness(&mut self, asyncness: &ast::IsAsync) -> io::Result<()> {\n+    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n+                                -> io::Result<()> {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\")?;\n         }\n@@ -3037,7 +3038,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      &ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n+                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n@@ -3100,7 +3101,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                header: &ast::FnHeader,\n+                                header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(visibility_qualified(vis, \"\"))?;\n \n@@ -3109,7 +3110,7 @@ impl<'a> State<'a> {\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        self.print_asyncness(&header.asyncness.node)?;\n+        self.print_asyncness(header.asyncness.node)?;\n         self.print_unsafety(header.unsafety)?;\n \n         if header.abi != Abi::Rust {\n@@ -3158,7 +3159,7 @@ mod tests {\n             assert_eq!(\n                 fun_to_string(\n                     &decl,\n-                    &ast::FnHeader {\n+                    ast::FnHeader {\n                         unsafety: ast::Unsafety::Normal,\n                         constness: source_map::dummy_spanned(ast::Constness::NotConst),\n                         asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),"}, {"sha": "a21d2df416206fc3c44534800ea3d2ff79d7a070", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -935,27 +935,6 @@ impl SourceMap {\n \n         None\n     }\n-\n-    /// Reuses the span but adds information like the kind of the desugaring and features that are\n-    /// allowed inside this span.\n-    pub fn mark_span_with_reason(\n-        &self,\n-        reason: hygiene::CompilerDesugaringKind,\n-        span: Span,\n-        allow_internal_unstable: Option<Lrc<[symbol::Symbol]>>,\n-    ) -> Span {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: span,\n-            def_site: Some(span),\n-            format: CompilerDesugaring(reason),\n-            allow_internal_unstable,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: edition::Edition::from_session(),\n-        });\n-        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n-    }\n }\n \n impl SourceMapper for SourceMap {"}, {"sha": "eb516b5c7c62fd7e5e07fcb865a1a206187ca509", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -544,9 +544,6 @@ pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionR\n pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n-        if let ArgSource::AsyncFn(pat) = &argument.source {\n-            visitor.visit_pat(pat);\n-        }\n         visitor.visit_ty(&argument.ty)\n     }\n     visitor.visit_fn_ret_ty(&function_declaration.output)"}, {"sha": "44ddbb98809b4f0d217bc234df31b15071520e35", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -129,7 +129,6 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n         attrs: ThinVec::new(),\n-        source: ast::LocalSource::Normal,\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "8b939b43b8bd406fdfb717943131a4300419440a", "filename": "src/test/ui/async-await/issues/issue-61187.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,9 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+fn main() {\n+}\n+\n+async fn response(data: Vec<u8>) {\n+    data.reverse(); //~ ERROR E0596\n+}"}, {"sha": "a03142263202ef304fb469d94a9b465444952d3f", "filename": "src/test/ui/async-await/issues/issue-61187.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,11 @@\n+error[E0596]: cannot borrow `data` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-61187.rs:8:5\n+   |\n+LL | async fn response(data: Vec<u8>) {\n+   |                   ---- help: consider changing this to be mutable: `mut data`\n+LL |     data.reverse();\n+   |     ^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "091fe904826d4e1939cfb2509db1739445ab8312", "filename": "src/test/ui/const-generics/condition-in-trait-const-arg.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+trait IsZeroTrait<const IS_ZERO: bool>{}\n+\n+impl IsZeroTrait<{0u8 == 0u8}> for () {}\n+\n+impl IsZeroTrait<true> for ((),) {}\n+\n+fn main() {}"}, {"sha": "7c85651e7082f5746afd56b1f4ac8475397b9638", "filename": "src/test/ui/const-generics/condition-in-trait-const-arg.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/condition-in-trait-const-arg.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "150a8015cbc756190e7c25e9799cf166327e5c3c", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/infinite-impl-trait-issue-38064.rs"}, {"sha": "fb48ecd12b6d1c29cc209f9e51abbbdb08662da3", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/infinite-impl-trait-issue-38064.stderr"}, {"sha": "2bff01be9b813a4e515297abd07d9cd9a14747f8", "filename": "src/test/ui/impl-trait/issues/issue-21659-show-relevant-trait-impls-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-21659-show-relevant-trait-impls-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-21659-show-relevant-trait-impls-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-21659-show-relevant-trait-impls-3.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-21659-show-relevant-trait-impls-3.rs"}, {"sha": "666418f6ee2c15f9945764dd4425108be480dc49", "filename": "src/test/ui/impl-trait/issues/issue-21659-show-relevant-trait-impls-3.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-21659-show-relevant-trait-impls-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-21659-show-relevant-trait-impls-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-21659-show-relevant-trait-impls-3.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-21659-show-relevant-trait-impls-3.stderr"}, {"sha": "2da15ac5b6e7e24239eff34999792c97135d26c6", "filename": "src/test/ui/impl-trait/issues/issue-42479.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-42479.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-42479.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-42479.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-42479.rs"}, {"sha": "13671b8dbf448f2d4ef92d24fca8a987edf9f059", "filename": "src/test/ui/impl-trait/issues/issue-49376.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-49376.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-49376.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-49376.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-49376.rs"}, {"sha": "eb4456a0d592e1a37d4da91fe2e965d993ba9baa", "filename": "src/test/ui/impl-trait/issues/issue-52128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-52128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-52128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-52128.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-52128.rs"}, {"sha": "3f6a4fb2787155ead6f76e5d2c484f5eaf9ec389", "filename": "src/test/ui/impl-trait/issues/issue-53457.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-53457.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-53457.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-53457.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(existential_type)]\n+\n+existential type X: Clone;\n+\n+fn bar<F: Fn(&i32) + Clone>(f: F) -> F {\n+    f\n+}\n+\n+fn foo() -> X {\n+    bar(|x| ())\n+}\n+\n+fn main() {}"}, {"sha": "50646edd61a8585f6de31b7dd87dc062839e21e1", "filename": "src/test/ui/impl-trait/issues/issue-55608-captures-empty-region.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-55608-captures-empty-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-55608-captures-empty-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-55608-captures-empty-region.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.rs"}, {"sha": "11f1a392239dcdeb491afbe0b5615ad47e49398e", "filename": "src/test/ui/impl-trait/issues/issue-57464-unexpected-regions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57464-unexpected-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57464-unexpected-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57464-unexpected-regions.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57464-unexpected-regions.rs"}, {"sha": "5eef6a39325fee8e1466b0576548283cc6b82b58", "filename": "src/test/ui/impl-trait/issues/issue-57979-deeply-nested-impl-trait-in-assoc-proj.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57979-deeply-nested-impl-trait-in-assoc-proj.rs"}, {"sha": "b9a1a4fa80a2ba7dbb7ec1b623da936b84361801", "filename": "src/test/ui/impl-trait/issues/issue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57979-deeply-nested-impl-trait-in-assoc-proj.stderr"}, {"sha": "84fcb5e2880a79c017aac5e7bd209f5def992e42", "filename": "src/test/ui/impl-trait/issues/issue-57979-impl-trait-in-path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-impl-trait-in-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-impl-trait-in-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-impl-trait-in-path.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57979-impl-trait-in-path.rs"}, {"sha": "982ecba291f793f8576d876a698806f1e48f73cd", "filename": "src/test/ui/impl-trait/issues/issue-57979-impl-trait-in-path.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-impl-trait-in-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-impl-trait-in-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-impl-trait-in-path.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57979-impl-trait-in-path.stderr"}, {"sha": "5c20ffc7c6724d887b8d5cc630cfa2decdda3eab", "filename": "src/test/ui/impl-trait/issues/issue-57979-nested-impl-trait-in-assoc-proj.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-nested-impl-trait-in-assoc-proj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-nested-impl-trait-in-assoc-proj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-nested-impl-trait-in-assoc-proj.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57979-nested-impl-trait-in-assoc-proj.rs"}, {"sha": "508aea243213275ab2fe3b81f8db5f2c5cc3521f", "filename": "src/test/ui/impl-trait/issues/issue-57979-nested-impl-trait-in-assoc-proj.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-nested-impl-trait-in-assoc-proj.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-nested-impl-trait-in-assoc-proj.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-57979-nested-impl-trait-in-assoc-proj.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/issue-57979-nested-impl-trait-in-assoc-proj.stderr"}, {"sha": "e434e10bf89d774434b89688ee10491280c47384", "filename": "src/test/ui/impl-trait/issues/universal-issue-48703.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/universal-issue-48703.rs"}, {"sha": "527bbd5f30fef02003b0c05645bf552d80e45bd7", "filename": "src/test/ui/impl-trait/issues/universal-issue-48703.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/universal-issue-48703.stderr"}, {"sha": "d3d561621fc2d0ddfbee03a2a0e7822348c63e03", "filename": "src/test/ui/impl-trait/issues/universal-turbofish-in-method-issue-50950.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/universal-turbofish-in-method-issue-50950.rs"}, {"sha": "e2e6581fcf9152d4c8e0661b1cf900fafbef8565", "filename": "src/test/ui/impl-trait/issues/universal-turbofish-in-method-issue-50950.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "previous_filename": "src/test/ui/impl-trait/universal-turbofish-in-method-issue-50950.stderr"}, {"sha": "79f6c91d9ac97dd0b899a224a202851fc39f0592", "filename": "src/test/ui/issues/issue-21596.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fissues%2Fissue-21596.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fissues%2Fissue-21596.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21596.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x = 8u8;\n+    let z: *const u8 = &x;\n+    println!(\"{}\", z.to_string());  //~ ERROR E0599\n+}"}, {"sha": "07d29f30e988a760c92503be7d28c67bf9db4b16", "filename": "src/test/ui/issues/issue-21596.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fissues%2Fissue-21596.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fissues%2Fissue-21596.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21596.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,13 @@\n+error[E0599]: no method named `to_string` found for type `*const u8` in the current scope\n+  --> $DIR/issue-21596.rs:4:22\n+   |\n+LL |     println!(\"{}\", z.to_string());\n+   |                      ^^^^^^^^^\n+   |\n+   = note: try using `<*const T>::as_ref()` to get a reference to the type behind the pointer: https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref\n+   = note: the method `to_string` exists but the following trait bounds were not satisfied:\n+           `*const u8 : std::string::ToString`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "44c8e9f7256f54d89141ba98eaa169c1a40786d9", "filename": "src/test/ui/nll/issue-61424.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fnll%2Fissue-61424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fnll%2Fissue-61424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61424.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,7 @@\n+#![deny(unused_mut)]\n+\n+fn main() {\n+    let mut x; //~ ERROR: variable does not need to be mutable\n+    x = String::new();\n+    dbg!(x);\n+}"}, {"sha": "ae336b2fe1c03d9194baedac8ec8761255e81d68", "filename": "src/test/ui/nll/issue-61424.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fnll%2Fissue-61424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Fnll%2Fissue-61424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61424.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -0,0 +1,16 @@\n+error: variable does not need to be mutable\n+  --> $DIR/issue-61424.rs:4:9\n+   |\n+LL |     let mut x;\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-61424.rs:1:9\n+   |\n+LL | #![deny(unused_mut)]\n+   |         ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ef9e7e39df0bcf593918664cb827b08c55c35ec2", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -30,7 +30,7 @@ error[E0106]: missing lifetime specifier\n LL | fn foo2(_: &'_ u8, y: &'_ u8) -> &'_ u8 { y }\n    |                                   ^^ expected lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `_` or `y`\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from argument 1 or `y`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "d4a6cf73bf98c2cae7ab5bb4dbcd8779cc965a7d", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22ce2806c3198c9a2b90b78d00c5451593c833f/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=c22ce2806c3198c9a2b90b78d00c5451593c833f", "patch": "@@ -204,7 +204,7 @@ fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n         succeeds_non_ident && preceeds_whitespace_and_paren\n     });\n \n-    cfgs.map(|i| {\n+    cfgs.flat_map(|i| {\n         let mut depth = 0;\n         let contents_from = &contents[i..];\n         for (j, byte) in contents_from.bytes().enumerate() {\n@@ -215,13 +215,15 @@ fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n                 b')' => {\n                     depth -= 1;\n                     if depth == 0 {\n-                        return (i, &contents_from[..=j]);\n+                        return Some((i, &contents_from[..=j]));\n                     }\n                 }\n                 _ => { }\n             }\n         }\n \n-        unreachable!()\n+        // if the parentheses are unbalanced just ignore this cfg -- it'll be caught when attempting\n+        // to run the compiler, and there's no real reason to lint it separately here\n+        None\n     }).collect()\n }"}]}