{"sha": "4d615dba0e913d807b38e893ec51e2bf6ea40287", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjE1ZGJhMGU5MTNkODA3YjM4ZTg5M2VjNTFlMmJmNmVhNDAyODc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-17T16:05:11Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-17T16:05:11Z"}, "message": "Initial commit", "tree": {"sha": "738fe39df546f75dfd2926ccc91106d4a88ca6cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/738fe39df546f75dfd2926ccc91106d4a88ca6cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d615dba0e913d807b38e893ec51e2bf6ea40287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d615dba0e913d807b38e893ec51e2bf6ea40287", "html_url": "https://github.com/rust-lang/rust/commit/4d615dba0e913d807b38e893ec51e2bf6ea40287", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d615dba0e913d807b38e893ec51e2bf6ea40287/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [], "stats": {"total": 733, "additions": 733, "deletions": 0}, "files": [{"sha": "02ca9dcf64f2abd6f2f6c4c9cd387e9053269a28", "filename": ".gitignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,3 @@\n+/target\n+**/*.rs.bk\n+*.rlib"}, {"sha": "e215ad0343124273ce506077ceecd174a78eb4fa", "filename": "Cargo.lock", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,147 @@\n+[[package]]\n+name = \"cretonne\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cretonne-codegen 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cretonne-frontend 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cretonne-codegen\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cretonne-entity 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"target-lexicon 0.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cretonne-entity\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"cretonne-frontend\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cretonne-codegen 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"dtoa\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"failure\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"failure_derive\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"quote\"\n+version = \"0.3.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"rustc_codegen_cretonne\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cretonne 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.66\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.20\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"0.11.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"synom\"\n+version = \"0.11.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"synstructure\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"target-lexicon\"\n+version = \"0.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[metadata]\n+\"checksum cretonne 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"83e1f8d40914cb726d41a49df9554f200b47f36a03c46e5d6044e9dc8a8a47cd\"\n+\"checksum cretonne-codegen 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"312ba69a70bebc54789bd0e28414987b5bcd1173263f6afbd0ee8519b84da4ac\"\n+\"checksum cretonne-entity 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0be57790fb6db92704951e37981f5e0121e7bfa077c7b48177317bf63795ba4\"\n+\"checksum cretonne-frontend 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14b0fe88b2bc5b71df2ce460761063da21731926e6b554c84d8b937de6640875\"\n+\"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n+\"checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82\"\n+\"checksum failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7cdda555bb90c9bb67a3b670a0f42de8e73f5981524123ad8578aafec8ddb8b\"\n+\"checksum itoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c069bbec61e1ca5a596166e55dfe4773ff745c3d16b700013bcaff9a6df2c682\"\n+\"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n+\"checksum serde 1.0.66 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e9a2d9a9ac5120e0f768801ca2b58ad6eec929dc9d1d616c162f208869c2ce95\"\n+\"checksum serde_json 1.0.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc97cccc2959f39984524026d760c08ef0dd5f0f5948c8d31797dbfae458c875\"\n+\"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n+\"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n+\"checksum synstructure 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a761d12e6d8dcb4dcf952a7a89b475e3a9d69e4a69307e01a470977642914bd\"\n+\"checksum target-lexicon 0.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71b0a95ba4eff593189d912039fba46ce6ca1876ea6c16830e15340919d0a250\"\n+\"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\""}, {"sha": "72859b0d7ccf471f9502ee37d65778e757217b46", "filename": "Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"rustc_codegen_cretonne\"\n+version = \"0.1.0\"\n+authors = [\"bjorn3 <bjorn3@users.noreply.github.com>\"]\n+\n+[lib]\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+cretonne = \"0.11.0\""}, {"sha": "5193ef20a1158fbf7b1ce90fa3dd3f1d058a460e", "filename": "build.sh", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,3 @@\n+cargo build || exit 1\n+\n+rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cretonne.dylib example.rs --crate-type lib"}, {"sha": "0962f150635375de5398a5c4be07fb1a33ecb165", "filename": "example.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example.rs?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,44 @@\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized {}\n+\n+#[lang=\"copy\"]\n+trait Copy {}\n+\n+#[lang=\"freeze\"]\n+trait Freeze {}\n+\n+#[lang=\"mul\"]\n+trait Mul<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Mul for u8 {\n+    type Output = u8;\n+\n+    fn mul(self, rhs: u8) -> u8 {\n+        self * rhs\n+    }\n+}\n+\n+#[lang=\"panic\"]\n+fn panic(_expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n+    loop {}\n+}\n+\n+fn abc(a: u8) -> u8 {\n+    a * 2\n+}\n+\n+fn bcd(b: bool, a: u8) -> u8 {\n+    if b {\n+        a * 2\n+    } else {\n+        a * 3\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "bf867e0ae5b6c08df1118a2ece970677bc479f1b", "filename": "rust-toolchain", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1 @@\n+nightly"}, {"sha": "e8356d89f79f780ff10afb753df784f08e4c5e11", "filename": "src/base.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,349 @@\n+use syntax::ast::{IntTy, UintTy};\n+use rustc_mir::monomorphize::MonoItem;\n+\n+use cretonne::prelude::*;\n+use cretonne::codegen::ir::{\n+    ExternalName,\n+    function::Function,\n+};\n+\n+use std::any::Any;\n+use std::collections::HashMap;\n+\n+use prelude::*;\n+\n+pub struct Translated {\n+    f: Function,\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+struct Variable(Local);\n+\n+impl EntityRef for Variable {\n+    fn new(u: usize) -> Self {\n+        Variable(Local::new(u))\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0.index()\n+    }\n+}\n+\n+enum CValue {\n+    ByRef(Value),\n+    ByVal(Value),\n+}\n+\n+impl CValue {\n+    fn force_stack<'a, 'tcx: 'a>(self, ccx: &mut CodegenCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n+        match self {\n+            CValue::ByRef(value) => value,\n+            CValue::ByVal(value) => {\n+                let layout = ccx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                let stack_slot = ccx.bcx.create_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: layout.size.bytes() as u32,\n+                    offset: None,\n+                });\n+                ccx.bcx.ins().stack_store(value, stack_slot, 0);\n+                ccx.bcx.ins().stack_addr(types::I64, stack_slot, 0)\n+            }\n+        }\n+    }\n+\n+    fn load_value<'a, 'tcx: 'a>(self, ccx: &mut CodegenCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n+        match self {\n+            CValue::ByRef(value) => {\n+                let cton_ty = cton_type_from_ty(ty);\n+                ccx.bcx.ins().load(cton_ty, MemFlags::new(), value, 0)\n+            }\n+            CValue::ByVal(value) => value,\n+        }\n+    }\n+}\n+\n+pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n+    let link_meta = ::build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n+    let metadata = tcx.encode_metadata(&link_meta);\n+\n+    let mut translated_mono_items = Vec::new();\n+\n+    for mono_item in\n+        collector::collect_crate_mono_items(\n+            tcx,\n+            collector::MonoItemCollectionMode::Eager\n+        ).0 {\n+        match mono_item {\n+            MonoItem::Fn(Instance {\n+                def: InstanceDef::Item(def_id),\n+                substs,\n+            }) => {\n+                let sig = tcx.fn_sig(def_id);\n+                let sig = tcx.subst_and_normalize_erasing_regions(substs, ParamEnv::reveal_all(), &sig);\n+                let mut f = Function::with_name_signature(ext_name_from_did(def_id), cton_sig_from_fn_sig(sig.skip_binder()));\n+\n+                trans_fn(tcx, &mut f, def_id, substs);\n+\n+                let mut mir = ::std::io::Cursor::new(Vec::new());\n+                ::rustc_mir::util::write_mir_pretty(tcx, Some(def_id), &mut mir).unwrap();\n+                let mut cton = String::new();\n+                ::cretonne::codegen::write_function(&mut cton, &f, None).unwrap();\n+                tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner()), cton));\n+\n+                translated_mono_items.push(Translated {\n+                    f,\n+                });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    Box::new(::OngoingCodegen {\n+        metadata: metadata,\n+        translated_mono_items,\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n+    })\n+}\n+\n+struct CodegenCtxt<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    bcx: FunctionBuilder<'a, Variable>,\n+    mir: &'tcx Mir<'tcx>,\n+    ebb_map: HashMap<BasicBlock, Ebb>,\n+    args_map: HashMap<Local, Value>,\n+}\n+\n+impl<'f, 'tcx> CodegenCtxt<'f, 'tcx> {\n+    fn get_ebb(&self, bb: BasicBlock) -> Ebb {\n+        *self.ebb_map.get(&bb).unwrap()\n+    }\n+\n+    fn get_local(&mut self, local: Local) -> Value {\n+        match self.mir.local_kind(local) {\n+            LocalKind::Arg => *self.args_map.get(&local).unwrap(),\n+            LocalKind::ReturnPointer => *self.args_map.get(&RETURN_PLACE).unwrap(),\n+            LocalKind::Temp | LocalKind::Var => self.bcx.use_var(Variable(local)),\n+        }\n+    }\n+}\n+\n+fn trans_fn<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: &mut Function, def_id: DefId, substs: &Substs) {\n+    let mir = tcx.optimized_mir(def_id);\n+    let mut func_ctx = FunctionBuilderContext::new();\n+    let mut bcx: FunctionBuilder<Variable> = FunctionBuilder::new(f, &mut func_ctx);\n+\n+    let start_ebb = bcx.create_ebb();\n+    bcx.switch_to_block(start_ebb);\n+    let mut ebb_map: HashMap<BasicBlock, Ebb> = HashMap::new();\n+    for (bb, _bb_data) in mir.basic_blocks().iter_enumerated() {\n+        ebb_map.insert(bb, bcx.create_ebb());\n+    }\n+\n+    let mut args_map: HashMap<Local, Value> = HashMap::new();\n+    for arg in Some(RETURN_PLACE).into_iter().chain(mir.args_iter()) {\n+        let ty = types::I64;\n+        args_map.insert(arg, bcx.append_ebb_param(start_ebb, ty));\n+    }\n+\n+    for local in mir.vars_and_temps_iter() {\n+        let layout = tcx.layout_of(ParamEnv::reveal_all().and(mir.local_decls[local].ty)).unwrap();\n+        let stack_slot = bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+        let ty = types::I64;\n+        bcx.declare_var(Variable(local), ty);\n+        let val = bcx.ins().stack_addr(ty, stack_slot, 0);\n+        bcx.def_var(Variable(local), val);\n+    }\n+    bcx.ins().jump(*ebb_map.get(&START_BLOCK).unwrap(), &[]);\n+\n+    let mut ccx = CodegenCtxt {\n+        tcx,\n+        bcx,\n+        mir,\n+        ebb_map,\n+        args_map,\n+    };\n+    let ccx = &mut ccx;\n+\n+    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n+        let ebb = ccx.get_ebb(bb);\n+        ccx.bcx.switch_to_block(ebb);\n+\n+        for stmt in &bb_data.statements {\n+            trans_stmt(ccx, stmt);\n+        }\n+\n+        match &bb_data.terminator().kind {\n+            TerminatorKind::Goto { target } => {\n+                let ebb = ccx.get_ebb(*target);\n+                ccx.bcx.ins().jump(ebb, &[]);\n+            }\n+            TerminatorKind::Return => {\n+                ccx.bcx.ins().return_(&[]);\n+            }\n+            TerminatorKind::Assert { cond, expected, msg, target, cleanup } => {\n+                let cond_ty = cond.ty(&ccx.mir.local_decls, ccx.tcx);\n+                let cond = trans_operand(ccx, cond).load_value(ccx, cond_ty);\n+                let target = ccx.get_ebb(*target);\n+                if *expected {\n+                    ccx.bcx.ins().brz(cond, target, &[]);\n+                } else {\n+                    ccx.bcx.ins().brnz(cond, target, &[]);\n+                }\n+                ccx.bcx.ins().trap(TrapCode::User(!0));\n+            }\n+\n+            TerminatorKind::SwitchInt { discr, switch_ty, values, targets } => {\n+                let discr_ty = discr.ty(&ccx.mir.local_decls, ccx.tcx);\n+                let discr = trans_operand(ccx, discr).load_value(ccx, discr_ty);\n+                let mut jt_data = JumpTableData::new();\n+                for (i, value) in values.iter().enumerate() {\n+                    let ebb = ccx.get_ebb(targets[i]);\n+                    jt_data.set_entry(*value as usize, ebb);\n+                }\n+                let mut jump_table = ccx.bcx.create_jump_table(jt_data);\n+                ccx.bcx.ins().br_table(discr, jump_table);\n+                let otherwise_ebb = ccx.get_ebb(targets[targets.len() - 1]);\n+                ccx.bcx.ins().jump(otherwise_ebb, &[]);\n+            }\n+            _ => {\n+                unimplemented!();\n+            }\n+        }\n+    }\n+\n+    ccx.bcx.seal_all_blocks();\n+    ccx.bcx.finalize();\n+}\n+\n+fn trans_stmt<'a, 'tcx: 'a>(ccx: &mut CodegenCtxt<'a, 'tcx>, stmt: &Statement<'tcx>) {\n+    match &stmt.kind {\n+        StatementKind::Assign(place, rval) => {\n+            let ty = place.ty(&ccx.mir.local_decls, ccx.tcx);\n+            let lval = trans_place(ccx, place);\n+            let rval = trans_rval(ccx, rval);\n+            do_memcpy(ccx, lval, ty);\n+        }\n+        StatementKind::StorageLive(_) | StatementKind::StorageDead(_) | StatementKind::Nop => {}\n+        _ => unimplemented!(\"stmt {:?}\", stmt),\n+    }\n+}\n+\n+fn trans_place<'a, 'tcx: 'a>(ccx: &mut CodegenCtxt<'a, 'tcx>, place: &Place<'tcx>) -> Value {\n+    match place {\n+        Place::Local(local) => ccx.get_local(*local),\n+        Place::Projection(projection) => {\n+            let base = trans_place(ccx, &projection.base);\n+            match projection.elem {\n+                ProjectionElem::Field(field, ty) => {\n+                    let layout = ccx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                    ccx.bcx.ins().iconst(types::I64, 0) // unimplemented =====================================================\n+                }\n+                _ => unimplemented!(\"projection {:?}\", projection),\n+            }\n+        }\n+        place => unimplemented!(\"place {:?}\", place),\n+    }\n+}\n+\n+fn trans_rval<'a, 'tcx: 'a>(ccx: &mut CodegenCtxt<'a, 'tcx>, rval: &Rvalue<'tcx>) -> Value {\n+    match rval {\n+        Rvalue::Use(operand) => {\n+            let operand_ty = operand.ty(&ccx.mir.local_decls, ccx.tcx);\n+            trans_operand(ccx, operand).force_stack(ccx, operand_ty)\n+        },\n+        Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n+            match bin_op {\n+                BinOp::Mul => {\n+                    let ty = lhs.ty(&ccx.mir.local_decls, ccx.tcx);\n+                    let lhs_ty = lhs.ty(&ccx.mir.local_decls, ccx.tcx);\n+                    let lhs = trans_operand(ccx, lhs).load_value(ccx, lhs_ty);\n+                    let rhs_ty = rhs.ty(&ccx.mir.local_decls, ccx.tcx);\n+                    let rhs = trans_operand(ccx, rhs).load_value(ccx, rhs_ty);\n+                    match ty.sty {\n+                        TypeVariants::TyUint(_) => {\n+                            ccx.bcx.ins().imul(lhs, rhs)\n+                        }\n+                        _ => unimplemented!(),\n+                    }\n+                }\n+                bin_op => unimplemented!(\"checked bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n+            }\n+        }\n+        rval => unimplemented!(\"{:?}\", rval),\n+    }\n+}\n+\n+fn trans_operand<'a, 'tcx>(ccx: &mut CodegenCtxt<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue {\n+    match operand {\n+        Operand::Move(place) => CValue::ByRef(trans_place(ccx, place)),\n+        Operand::Constant(const_) => {\n+            match const_.literal {\n+                Literal::Value { value } => {\n+                    let layout = ccx.tcx.layout_of(ParamEnv::empty().and(const_.ty)).unwrap();\n+                    let bits = value.to_scalar().unwrap().to_bits(layout.size).unwrap();\n+                    match const_.ty.sty {\n+                        TypeVariants::TyUint(_) => {\n+                            let iconst = ccx.bcx.ins().iconst(cton_type_from_ty(const_.ty), bits as u64 as i64);\n+                            CValue::ByVal(iconst)\n+                        }\n+                        _ => unimplemented!(),\n+                    }\n+                }\n+                _ => unimplemented!()\n+            }\n+        }\n+        operand => unimplemented!(\"operand {:?}\", operand),\n+    }\n+}\n+\n+fn ext_name_from_did(def_id: DefId) -> ExternalName {\n+    ExternalName::user(def_id.krate.as_u32(), def_id.index.as_raw_u32())\n+}\n+\n+fn cton_sig_from_fn_sig(sig: &FnSig) -> Signature {\n+    let inputs = sig.inputs();\n+    let output = sig.output();\n+    assert!(!sig.variadic, \"Variadic function are not yet supported\");\n+    let call_conv = match sig.abi {\n+        _ => CallConv::SystemV,\n+    };\n+    Signature {\n+        params: Some(types::I64).into_iter() // First param is palce to put return val\n+            .chain(inputs.into_iter().map(|_| types::I64))\n+            .map(AbiParam::new).collect(),\n+        returns: vec![],\n+        call_conv,\n+        argument_bytes: None,\n+    }\n+}\n+\n+fn cton_type_from_ty(ty: Ty) -> types::Type {\n+    match ty.sty {\n+        TypeVariants::TyBool => types::B1,\n+        TypeVariants::TyUint(size) => {\n+            match size {\n+                UintTy::U8 => types::I8,\n+                UintTy::U16 => types::I16,\n+                UintTy::U32 => types::I32,\n+                UintTy::U64 => types::I64,\n+                UintTy::U128 => unimplemented!(),\n+                UintTy::Usize => unimplemented!(),\n+            }\n+        }\n+        TypeVariants::TyInt(size) => {\n+            match size {\n+                IntTy::I8 => types::I8,\n+                IntTy::I16 => types::I16,\n+                IntTy::I32 => types::I32,\n+                IntTy::I64 => types::I64,\n+                IntTy::I128 => unimplemented!(),\n+                IntTy::Isize => unimplemented!(),\n+            }\n+        }\n+        _ => unimplemented!(\"Cton type from {:?}\", ty),\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "5389c0b9ec9973d1fabc0830926d5eeb6a786688", "filename": "src/lib.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/4d615dba0e913d807b38e893ec51e2bf6ea40287/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d615dba0e913d807b38e893ec51e2bf6ea40287/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4d615dba0e913d807b38e893ec51e2bf6ea40287", "patch": "@@ -0,0 +1,176 @@\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+extern crate rustc_mir;\n+extern crate rustc_codegen_utils;\n+extern crate rustc_incremental;\n+extern crate rustc_data_structures;\n+\n+extern crate cretonne;\n+\n+use syntax::symbol::Symbol;\n+use rustc::session::{\n+    CompileIncomplete,\n+    config::{\n+        CrateType,\n+        OutputFilenames,\n+    },\n+};\n+use rustc::middle::cstore::{MetadataLoader, EncodedMetadata};\n+use rustc::dep_graph::DepGraph;\n+use rustc::ty::maps::Providers;\n+use rustc_codegen_utils::codegen_backend::{CodegenBackend, NoLlvmMetadataLoader};\n+use rustc_codegen_utils::link::{out_filename, build_link_meta};\n+\n+use std::any::Any;\n+use std::sync::{mpsc, Arc};\n+use std::fs::File;\n+use std::io::Write;\n+\n+mod base;\n+\n+mod prelude {\n+    pub use rustc::session::Session;\n+    pub use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+    pub use rustc::ty::{TyCtxt, Ty, TypeVariants, Instance, InstanceDef, ParamEnv, FnSig, subst::Substs};\n+    pub use rustc::mir::*;\n+    pub use rustc_mir::monomorphize::collector;\n+    pub use rustc_data_structures::{\n+        sync::Lrc,\n+        indexed_vec::Idx,\n+    };\n+}\n+\n+use prelude::*;\n+\n+struct CretonneCodegenBackend(());\n+\n+struct OngoingCodegen {\n+    metadata: EncodedMetadata,\n+    translated_mono_items: Vec<base::Translated>,\n+    crate_name: Symbol,\n+}\n+\n+impl CretonneCodegenBackend {\n+    fn new() -> Box<CodegenBackend> {\n+        Box::new(CretonneCodegenBackend(()))\n+    }\n+}\n+\n+impl CodegenBackend for CretonneCodegenBackend {\n+    fn init(&self, sess: &Session) {\n+        for cty in sess.opts.crate_types.iter() {\n+            match *cty {\n+                CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n+                CrateType::CrateTypeExecutable => {},\n+                _ => {\n+                    sess.parse_sess.span_diagnostic.warn(\n+                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n+                    );\n+                },\n+            }\n+        }\n+    }\n+\n+    fn metadata_loader(&self) -> Box<MetadataLoader + Sync> {\n+        Box::new(NoLlvmMetadataLoader)\n+    }\n+\n+    fn provide(&self, providers: &mut Providers) {\n+        rustc_codegen_utils::symbol_names::provide(providers);\n+\n+        providers.target_features_whitelist = |_tcx, _cnum| {\n+            /*Lrc::new(rustc_codegen_utils::llvm_target_features::all_known_features()\n+                .map(|(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .collect())*/\n+            Lrc::new(Default::default())\n+        };\n+        providers.is_reachable_non_generic = |_tcx, _defid| true;\n+        providers.exported_symbols = |_tcx, _crate| Arc::new(Vec::new());\n+        providers.wasm_custom_sections = |_tcx, _crate| Lrc::new(Vec::new());\n+    }\n+    fn provide_extern(&self, providers: &mut Providers) {\n+        providers.is_reachable_non_generic = |_tcx, _defid| true;\n+    }\n+\n+    fn codegen_crate<'a, 'tcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Box<Any> {\n+        use rustc_mir::monomorphize::item::MonoItem;\n+\n+        rustc_codegen_utils::check_for_rustc_errors_attr(tcx);\n+        rustc_codegen_utils::symbol_names_test::report_symbol_names(tcx);\n+        rustc_incremental::assert_dep_graph(tcx);\n+        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+        rustc_mir::monomorphize::assert_symbols_are_distinct(tcx,\n+            collector::collect_crate_mono_items(\n+                tcx,\n+                collector::MonoItemCollectionMode::Eager\n+            ).0.iter()\n+        );\n+        //::rustc::middle::dependency_format::calculate(tcx);\n+        let _ = tcx.link_args(LOCAL_CRATE);\n+        let _ = tcx.native_libraries(LOCAL_CRATE);\n+        for mono_item in\n+            collector::collect_crate_mono_items(\n+                tcx,\n+                collector::MonoItemCollectionMode::Eager\n+            ).0 {\n+            match mono_item {\n+                MonoItem::Fn(inst) => {\n+                    let def_id = inst.def_id();\n+                    if def_id.is_local()  {\n+                        let _ = inst.def.is_inline(tcx);\n+                        let _ = tcx.codegen_fn_attrs(def_id);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        tcx.sess.abort_if_errors();\n+\n+        base::trans_crate(tcx)\n+    }\n+\n+    fn join_codegen_and_link(\n+        &self,\n+        ongoing_codegen: Box<Any>,\n+        sess: &Session,\n+        _dep_graph: &DepGraph,\n+        outputs: &OutputFilenames,\n+    ) -> Result<(), CompileIncomplete> {\n+        if true {\n+            unimplemented!();\n+        }\n+\n+        let ongoing_codegen = ongoing_codegen.downcast::<OngoingCodegen>()\n+            .expect(\"Expected MetadataOnlyCodegenBackend's OngoingCodegen, found Box<Any>\");\n+        for &crate_type in sess.opts.crate_types.iter() {\n+            if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n+                continue;\n+            }\n+            let output_name =\n+                out_filename(sess, crate_type, &outputs, &ongoing_codegen.crate_name.as_str());\n+            let metadata = &ongoing_codegen.metadata.raw_data;\n+            let mut file = File::create(&output_name).unwrap();\n+            file.write_all(metadata).unwrap();\n+        }\n+\n+        sess.abort_if_errors();\n+        if !sess.opts.crate_types.contains(&CrateType::CrateTypeRlib)\n+            && !sess.opts.crate_types.contains(&CrateType::CrateTypeDylib)\n+        {\n+            sess.fatal(\"Executables are not supported by the metadata-only backend.\");\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// This is the entrypoint for a hot plugged rustc_codegen_cretonne\n+#[no_mangle]\n+pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n+    CretonneCodegenBackend::new()\n+}\n\\ No newline at end of file"}]}