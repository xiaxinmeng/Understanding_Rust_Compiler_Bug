{"sha": "a4e0fe2b02f76ef10d908d234fb48ad583e373c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZTBmZTJiMDJmNzZlZjEwZDkwOGQyMzRmYjQ4YWQ1ODNlMzczYzY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-11T08:52:49Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-11T08:52:49Z"}, "message": "Allow attributes to stay on the same line with fields", "tree": {"sha": "7af32b0e641bdbcd3e87ff8629a91b4bdd36df0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7af32b0e641bdbcd3e87ff8629a91b4bdd36df0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4e0fe2b02f76ef10d908d234fb48ad583e373c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e0fe2b02f76ef10d908d234fb48ad583e373c6", "html_url": "https://github.com/rust-lang/rust/commit/a4e0fe2b02f76ef10d908d234fb48ad583e373c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4e0fe2b02f76ef10d908d234fb48ad583e373c6/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0af19985fcf9ac94079025ab116c804eff959d67", "url": "https://api.github.com/repos/rust-lang/rust/commits/0af19985fcf9ac94079025ab116c804eff959d67", "html_url": "https://github.com/rust-lang/rust/commit/0af19985fcf9ac94079025ab116c804eff959d67"}], "stats": {"total": 241, "additions": 118, "deletions": 123}, "files": [{"sha": "302d15ee8aaadb36419b76678ba7b4cef6289b11", "filename": "src/items.rs", "status": "modified", "additions": 86, "deletions": 115, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/a4e0fe2b02f76ef10d908d234fb48ad583e373c6/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e0fe2b02f76ef10d908d234fb48ad583e373c6/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a4e0fe2b02f76ef10d908d234fb48ad583e373c6", "patch": "@@ -18,7 +18,8 @@ use syntax::codemap::{BytePos, Span};\n \n use {Indent, Shape, Spanned};\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{contains_comment, recover_comment_removed, rewrite_comment, FindUncommented};\n+use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n+              rewrite_comment, FindUncommented};\n use config::{BraceStyle, Config, Density, IndentStyle, ReturnIndent, Style};\n use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n            rewrite_call_inner, ExprType};\n@@ -28,8 +29,9 @@ use rewrite::{Rewrite, RewriteContext};\n use types::join_bounds;\n use utils::{colon_spaces, contains_skip, end_typaram, first_line_width, format_abi,\n             format_constness, format_defaultness, format_mutability, format_unsafety,\n-            format_visibility, last_line_used_width, last_line_width, mk_sp, semicolon_for_expr,\n-            stmt_expr, trim_newlines, trimmed_last_line_width, wrap_str};\n+            format_visibility, is_attributes_extendable, last_line_contains_single_line_comment,\n+            last_line_used_width, last_line_width, mk_sp, semicolon_for_expr, stmt_expr,\n+            trim_newlines, trimmed_last_line_width, wrap_str};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n \n@@ -501,32 +503,19 @@ impl<'a> FmtVisitor<'a> {\n \n         let context = self.get_context();\n         let indent = self.block_indent;\n-        let mut result = try_opt!(\n-            field\n-                .node\n-                .attrs\n-                .rewrite(&context, Shape::indented(indent, self.config))\n-        );\n-        if !result.is_empty() {\n-            let shape = Shape {\n-                width: context.config.max_width(),\n-                indent: self.block_indent,\n-                offset: self.block_indent.alignment,\n-            };\n-            let missing_comment = rewrite_missing_comment_on_field(\n-                &context,\n-                shape,\n-                field.node.attrs[field.node.attrs.len() - 1].span.hi,\n-                field.span.lo,\n-                &mut result,\n-            ).unwrap_or(String::new());\n-            result.push_str(&missing_comment);\n-        }\n+        let shape = Shape::indented(indent, self.config);\n+        let attrs_str = try_opt!(field.node.attrs.rewrite(&context, shape));\n+        let lo = field\n+            .node\n+            .attrs\n+            .last()\n+            .map_or(field.span.lo, |attr| attr.span.hi);\n+        let span = mk_sp(lo, field.span.lo);\n \n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) | ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n-                format_struct(\n+                try_opt!(format_struct(\n                     &context,\n                     \"\",\n                     field.node.name,\n@@ -536,29 +525,37 @@ impl<'a> FmtVisitor<'a> {\n                     field.span,\n                     indent,\n                     Some(self.config.struct_variant_width()),\n-                )\n+                ))\n             }\n-            ast::VariantData::Unit(..) => {\n-                let tag = if let Some(ref expr) = field.node.disr_expr {\n+            ast::VariantData::Unit(..) => if let Some(ref expr) = field.node.disr_expr {\n+                let one_line_width =\n+                    field.node.name.to_string().len() + self.snippet(expr.span).len() + 3;\n+                if one_line_width <= shape.width {\n                     format!(\"{} = {}\", field.node.name, self.snippet(expr.span))\n                 } else {\n-                    field.node.name.to_string()\n-                };\n-\n-                wrap_str(\n-                    tag,\n-                    self.config.max_width(),\n-                    Shape::indented(indent, self.config),\n-                )\n-            }\n+                    format!(\n+                        \"{}\\n{}{}\",\n+                        field.node.name,\n+                        shape\n+                            .indent\n+                            .block_indent(self.config)\n+                            .to_string(self.config),\n+                        self.snippet(expr.span)\n+                    )\n+                }\n+            } else {\n+                String::from(field.node.name.to_string())\n+            },\n         };\n \n-        if let Some(variant_str) = variant_body {\n-            result.push_str(&variant_str);\n-            Some(result)\n-        } else {\n-            None\n-        }\n+        combine_strs_with_missing_comments(\n+            &context,\n+            &attrs_str,\n+            &variant_body,\n+            span,\n+            shape,\n+            is_attributes_extendable(&attrs_str),\n+        )\n     }\n }\n \n@@ -1369,68 +1366,15 @@ fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n     )\n }\n \n-fn rewrite_missing_comment_on_field(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    lo: BytePos,\n-    hi: BytePos,\n-    result: &mut String,\n-) -> Option<String> {\n-    let possibly_comment_snippet = context.snippet(mk_sp(lo, hi));\n-    let newline_index = possibly_comment_snippet.find('\\n');\n-    let comment_index = possibly_comment_snippet.find('/');\n-    match (newline_index, comment_index) {\n-        (Some(i), Some(j)) if i > j => result.push(' '),\n-        _ => {\n-            result.push('\\n');\n-            result.push_str(&shape.indent.to_string(context.config));\n-        }\n-    }\n-    let trimmed = possibly_comment_snippet.trim();\n-    if trimmed.is_empty() {\n-        None\n-    } else {\n-        rewrite_comment(trimmed, false, shape, context.config).map(|s| {\n-            format!(\"{}\\n{}\", s, shape.indent.to_string(context.config))\n-        })\n-    }\n-}\n-\n pub fn rewrite_struct_field_prefix(\n     context: &RewriteContext,\n     field: &ast::StructField,\n-    shape: Shape,\n ) -> Option<String> {\n     let vis = format_visibility(&field.vis);\n-    let mut attr_str = try_opt!(\n-        field\n-            .attrs\n-            .rewrite(context, Shape::indented(shape.indent, context.config))\n-    );\n-    // Try format missing comments after attributes\n-    let missing_comment = if !field.attrs.is_empty() {\n-        rewrite_missing_comment_on_field(\n-            context,\n-            shape,\n-            field.attrs[field.attrs.len() - 1].span.hi,\n-            field.span.lo,\n-            &mut attr_str,\n-        ).unwrap_or(String::new())\n-    } else {\n-        String::new()\n-    };\n-\n     let type_annotation_spacing = type_annotation_spacing(context.config);\n     Some(match field.ident {\n-        Some(name) => format!(\n-            \"{}{}{}{}{}:\",\n-            attr_str,\n-            missing_comment,\n-            vis,\n-            name,\n-            type_annotation_spacing.0\n-        ),\n-        None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n+        Some(name) => format!(\"{}{}{}:\", vis, name, type_annotation_spacing.0),\n+        None => format!(\"{}\", vis),\n     })\n }\n \n@@ -1466,55 +1410,86 @@ pub fn rewrite_struct_field(\n     }\n \n     let type_annotation_spacing = type_annotation_spacing(context.config);\n-    let prefix = try_opt!(rewrite_struct_field_prefix(context, field, shape));\n+    let prefix = try_opt!(rewrite_struct_field_prefix(context, field));\n \n-    // Try to put everything on a single line.\n-    let last_line_width = last_line_width(&prefix);\n+    let attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n+    let missing_span = if field.attrs.is_empty() {\n+        mk_sp(field.span.lo, field.span.lo)\n+    } else {\n+        mk_sp(field.attrs.last().unwrap().span.hi, field.span.lo)\n+    };\n     let mut spacing = String::from(if field.ident.is_some() {\n         type_annotation_spacing.1\n     } else {\n         \"\"\n     });\n-    let lhs_offset = lhs_max_width.checked_sub(last_line_width).unwrap_or(0);\n+    // Try to put everything on a single line.\n+    let attr_prefix = try_opt!(combine_strs_with_missing_comments(\n+        context,\n+        &attrs_str,\n+        &prefix,\n+        missing_span,\n+        shape,\n+        is_attributes_extendable(&attrs_str),\n+    ));\n+    let overhead = last_line_width(&attr_prefix);\n+    let lhs_offset = lhs_max_width.checked_sub(overhead).unwrap_or(0);\n     for _ in 0..lhs_offset {\n         spacing.push(' ');\n     }\n-    let ty_rewritten = rewrite_struct_field_type(context, last_line_width, field, &spacing, shape);\n+    // In this extreme case we will be missing a space betweeen an attribute and a field.\n+    if prefix.is_empty() && !attrs_str.is_empty() && is_attributes_extendable(&attrs_str) &&\n+        spacing.is_empty()\n+    {\n+        spacing.push(' ');\n+    }\n+    let ty_rewritten = rewrite_struct_field_type(context, overhead, field, &spacing, shape);\n     if let Some(ref ty) = ty_rewritten {\n         if !ty.contains('\\n') {\n-            return Some(prefix + &ty);\n+            return Some(attr_prefix + &ty);\n         }\n     }\n \n     // We must use multiline.\n+    let last_line_width = last_line_width(&prefix);\n+    let ty_rewritten = rewrite_struct_field_type(context, last_line_width, field, &spacing, shape);\n+\n     let type_offset = shape.indent.block_indent(context.config);\n     let rewrite_type_in_next_line = || {\n         field\n             .ty\n             .rewrite(context, Shape::indented(type_offset, context.config))\n     };\n \n-    match ty_rewritten {\n+    let field_str = match ty_rewritten {\n         // If we start from the next line and type fits in a single line, then do so.\n         Some(ref ty) => match rewrite_type_in_next_line() {\n-            Some(ref new_ty) if !new_ty.contains('\\n') => Some(format!(\n+            Some(ref new_ty) if !new_ty.contains('\\n') => format!(\n                 \"{}\\n{}{}\",\n                 prefix,\n                 type_offset.to_string(&context.config),\n                 &new_ty\n-            )),\n-            _ => Some(prefix + &ty),\n+            ),\n+            _ => prefix + &ty,\n         },\n         _ => {\n             let ty = try_opt!(rewrite_type_in_next_line());\n-            Some(format!(\n+            format!(\n                 \"{}\\n{}{}\",\n                 prefix,\n                 type_offset.to_string(&context.config),\n                 &ty\n-            ))\n+            )\n         }\n-    }\n+    };\n+    combine_strs_with_missing_comments(\n+        context,\n+        &attrs_str,\n+        &field_str,\n+        missing_span,\n+        shape,\n+        is_attributes_extendable(&attrs_str),\n+    )\n }\n \n pub fn rewrite_static(\n@@ -2148,10 +2123,6 @@ impl WhereClauseOption {\n     }\n }\n \n-fn last_line_contains_single_line_comment(s: &str) -> bool {\n-    s.lines().last().map_or(false, |l| l.contains(\"//\"))\n-}\n-\n fn rewrite_args(\n     context: &RewriteContext,\n     args: &[ast::Arg],"}, {"sha": "1a62cad77570dc218eddae1082ea096c6c486f52", "filename": "src/vertical.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a4e0fe2b02f76ef10d908d234fb48ad583e373c6/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e0fe2b02f76ef10d908d234fb48ad583e373c6/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=a4e0fe2b02f76ef10d908d234fb48ad583e373c6", "patch": "@@ -17,12 +17,12 @@ use syntax::codemap::{BytePos, Span};\n \n use {Indent, Shape, Spanned};\n use codemap::SpanUtils;\n-use comment::contains_comment;\n+use comment::{combine_strs_with_missing_comments, contains_comment};\n use expr::rewrite_field;\n use items::{rewrite_struct_field, rewrite_struct_field_prefix};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator};\n use rewrite::{Rewrite, RewriteContext};\n-use utils::{contains_skip, mk_sp};\n+use utils::{contains_skip, is_attributes_extendable, mk_sp};\n \n pub trait AlignedItem {\n     fn skip(&self) -> bool;\n@@ -46,7 +46,22 @@ impl AlignedItem for ast::StructField {\n     }\n \n     fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        rewrite_struct_field_prefix(context, self, shape)\n+        let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        let missing_span = if self.attrs.is_empty() {\n+            mk_sp(self.span.lo, self.span.lo)\n+        } else {\n+            mk_sp(self.attrs.last().unwrap().span.hi, self.span.lo)\n+        };\n+        rewrite_struct_field_prefix(context, self).and_then(|field_str| {\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &field_str,\n+                missing_span,\n+                shape,\n+                is_attributes_extendable(&attrs_str),\n+            )\n+        })\n     }\n \n     fn rewrite_aligned_item(\n@@ -69,12 +84,21 @@ impl AlignedItem for ast::Field {\n     }\n \n     fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let mut attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n-        if !attrs_str.is_empty() {\n-            attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n-        };\n+        let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n         let name = &self.ident.node.to_string();\n-        Some(format!(\"{}{}\", attrs_str, name))\n+        let missing_span = if self.attrs.is_empty() {\n+            mk_sp(self.span.lo, self.span.lo)\n+        } else {\n+            mk_sp(self.attrs.last().unwrap().span.hi, self.span.lo)\n+        };\n+        combine_strs_with_missing_comments(\n+            context,\n+            &attrs_str,\n+            name,\n+            missing_span,\n+            shape,\n+            is_attributes_extendable(&attrs_str),\n+        )\n     }\n \n     fn rewrite_aligned_item("}]}