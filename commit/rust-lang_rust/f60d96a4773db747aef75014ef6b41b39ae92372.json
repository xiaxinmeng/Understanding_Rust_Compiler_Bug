{"sha": "f60d96a4773db747aef75014ef6b41b39ae92372", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MGQ5NmE0NzczZGI3NDdhZWY3NTAxNGVmNmI0MWIzOWFlOTIzNzI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-03T21:25:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-06T20:21:18Z"}, "message": "Support custom attributes when macro modularization is enabled", "tree": {"sha": "1d90abf7907b1f9a687d6a4687b56cd86b917f79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d90abf7907b1f9a687d6a4687b56cd86b917f79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f60d96a4773db747aef75014ef6b41b39ae92372", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f60d96a4773db747aef75014ef6b41b39ae92372", "html_url": "https://github.com/rust-lang/rust/commit/f60d96a4773db747aef75014ef6b41b39ae92372", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f60d96a4773db747aef75014ef6b41b39ae92372/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84562e019e3061c79879487ace098a652d19490", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84562e019e3061c79879487ace098a652d19490", "html_url": "https://github.com/rust-lang/rust/commit/c84562e019e3061c79879487ace098a652d19490"}], "stats": {"total": 213, "additions": 108, "deletions": 105}, "files": [{"sha": "0be1bf3011e78dcc21801915fce229c0b22fc322", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -630,7 +630,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn get_macro(&mut self, def: Def) -> Lrc<SyntaxExtension> {\n         let def_id = match def {\n             Def::Macro(def_id, ..) => def_id,\n-            Def::NonMacroAttr(..) => return Lrc::new(SyntaxExtension::NonMacroAttr),\n+            Def::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n+                mark_used: attr_kind == NonMacroAttrKind::Tool,\n+            }),\n             _ => panic!(\"expected `Def::Macro` or `Def::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {"}, {"sha": "d96967725f45ef82fee21afc34f04a5c40ff7bb7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -3485,8 +3485,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let binding = if let Some(module) = module {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n-                    .map(MacroBinding::binding)\n+                assert!(ns == TypeNS);\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used, record_used,\n+                                                        false, path_span).map(MacroBinding::binding)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -4549,6 +4550,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let result = self.resolve_lexical_macro_path_segment(ident,\n                                                                  MacroNS,\n                                                                  false,\n+                                                                 false,\n+                                                                 true,\n                                                                  attr.path.span);\n             if let Ok(binding) = result {\n                 if let SyntaxExtension::AttrProcMacro(..) = *binding.binding().get_macro(self) {"}, {"sha": "b0fec11bf5813a6e1e32de417f7f0b8af567b0ea", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -331,18 +331,29 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         } else if let Def::NonMacroAttr(attr_kind) = def {\n             let is_attr_invoc =\n                 if let InvocationKind::Attr { .. } = invoc.kind { true } else { false };\n+            let path = invoc.path().expect(\"no path for non-macro attr\");\n             match attr_kind {\n-                NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper if is_attr_invoc => {\n+                NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper |\n+                NonMacroAttrKind::Custom if is_attr_invoc => {\n                     if attr_kind == NonMacroAttrKind::Tool &&\n                        !self.session.features_untracked().tool_attributes {\n                         feature_err(&self.session.parse_sess, \"tool_attributes\",\n                                     invoc.span(), GateIssue::Language,\n                                     \"tool attributes are unstable\").emit();\n                     }\n-                    return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr)));\n+                    if attr_kind == NonMacroAttrKind::Custom &&\n+                       !self.session.features_untracked().custom_attribute {\n+                        let msg = format!(\"The attribute `{}` is currently unknown to the compiler \\\n+                                           and may have meaning added to it in the future\", path);\n+                        feature_err(&self.session.parse_sess, \"custom_attribute\", invoc.span(),\n+                                    GateIssue::Language, &msg).emit();\n+                    }\n+                    return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr {\n+                        mark_used: attr_kind == NonMacroAttrKind::Tool,\n+                    })));\n                 }\n                 _ => {\n-                    self.report_non_macro_attr(invoc.path_span(), def);\n+                    self.report_non_macro_attr(path.span, def);\n                     return Err(Determinacy::Determined);\n                 }\n             }\n@@ -418,43 +429,42 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         };\n \n         let path = attr.as_ref().unwrap().path.clone();\n-        let mut determinacy = Determinacy::Determined;\n-        match self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force) {\n-            Ok(def) => return Ok(def),\n-            Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n-            Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n-            Err(Determinacy::Determined) => {}\n+        let def = self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force);\n+        if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = def {} else {\n+            return def;\n         }\n \n-        // Ok at this point we've determined that the `attr` above doesn't\n-        // actually resolve at this time, so we may want to report an error.\n-        // It could be the case, though, that `attr` won't ever resolve! If\n-        // there's a custom derive that could be used it might declare `attr` as\n-        // a custom attribute accepted by the derive. In this case we don't want\n-        // to report this particular invocation as unresolved, but rather we'd\n-        // want to move on to the next invocation.\n+        // At this point we've found that the `attr` is determinately unresolved and thus can be\n+        // interpreted as a custom attribute. Normally custom attributes are feature gated, but\n+        // it may be a custom attribute whitelisted by a derive macro and they do not require\n+        // a feature gate.\n         //\n-        // This loop here looks through all of the derive annotations in scope\n-        // and tries to resolve them. If they themselves successfully resolve\n-        // *and* the resolve mentions that this attribute's name is a registered\n-        // custom attribute then we return that custom attribute as the resolution result.\n-        let attr_name = match path.segments.len() {\n-            1 => path.segments[0].ident.name,\n-            _ => return Err(determinacy),\n-        };\n+        // So here we look through all of the derive annotations in scope and try to resolve them.\n+        // If they themselves successfully resolve *and* one of the resolved derive macros\n+        // whitelists this attribute's name, then this is a registered attribute and we can convert\n+        // it from a \"generic custom attrite\" into a \"known derive helper attribute\".\n+        enum ConvertToDeriveHelper { Yes, No, DontKnow }\n+        let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n+        let attr_name = path.segments[0].ident.name;\n         for path in traits {\n             match self.resolve_macro(scope, path, MacroKind::Derive, force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n-                        return Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper));\n+                        convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n+                        break\n                     }\n                 },\n-                Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n+                Err(Determinacy::Undetermined) =>\n+                    convert_to_derive_helper = ConvertToDeriveHelper::DontKnow,\n                 Err(Determinacy::Determined) => {}\n             }\n         }\n \n-        Err(determinacy)\n+        match convert_to_derive_helper {\n+            ConvertToDeriveHelper::Yes => Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)),\n+            ConvertToDeriveHelper::No => def,\n+            ConvertToDeriveHelper::DontKnow => Err(Determinacy::determined(force)),\n+        }\n     }\n \n     fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -537,10 +547,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, force,\n+                                                          kind == MacroKind::Attr, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n-                Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n-                Err(_) => {\n+                Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n+                Err(Determinacy::Determined) => {\n                     self.found_unresolved_macro = true;\n                     Err(Determinacy::Determined)\n                 }\n@@ -561,6 +572,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                               mut ident: Ident,\n                                               ns: Namespace,\n                                               record_used: bool,\n+                                              force: bool,\n+                                              is_attr: bool,\n                                               path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n         // General principles:\n@@ -591,6 +604,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // 3. Builtin attributes (closed, controlled).\n \n         assert!(ns == TypeNS  || ns == MacroNS);\n+        let force = force || record_used;\n         ident = ident.modern();\n \n         // Names from inner scope that can't shadow names from outer scopes, e.g.\n@@ -764,7 +778,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 Err(Determinacy::Determined) => {\n                     continue_search!();\n                 }\n-                Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n+                Err(Determinacy::Undetermined) => return Err(Determinacy::determined(force)),\n             }\n         }\n \n@@ -773,7 +787,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             return Ok(previous_result);\n         }\n \n-        if record_used { Err(Determinacy::Determined) } else { Err(Determinacy::Undetermined) }\n+        let determinacy = Determinacy::determined(force);\n+        if determinacy == Determinacy::Determined && is_attr {\n+            // For attributes interpret determinate \"no solution\" as a custom attribute.\n+            let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n+                           ty::Visibility::Public, ident.span, Mark::root())\n+                           .to_name_binding(self.arenas);\n+            Ok(MacroBinding::Global(binding))\n+        } else {\n+            Err(determinacy)\n+        }\n     }\n \n     pub fn resolve_legacy_scope(&mut self,\n@@ -857,7 +880,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let span = ident.span;\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, true,\n+                                                                     kind == MacroKind::Attr, span);\n \n             let check_consistency = |this: &Self, binding: MacroBinding| {\n                 if let Some(def) = def {"}, {"sha": "de391ee4219a470b0a427abdf8aec917e4d435d7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -589,7 +589,7 @@ impl MacroKind {\n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n     /// A trivial \"extension\" that does nothing, only keeps the attribute and marks it as known.\n-    NonMacroAttr,\n+    NonMacroAttr { mark_used: bool },\n \n     /// A syntax extension that is attached to an item and creates new items\n     /// based upon it.\n@@ -670,7 +670,7 @@ impl SyntaxExtension {\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::ProcMacro { .. } =>\n                 MacroKind::Bang,\n-            SyntaxExtension::NonMacroAttr |\n+            SyntaxExtension::NonMacroAttr { .. } |\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |\n             SyntaxExtension::AttrProcMacro(..) =>\n@@ -700,7 +700,7 @@ impl SyntaxExtension {\n             SyntaxExtension::AttrProcMacro(.., edition) |\n             SyntaxExtension::ProcMacroDerive(.., edition) => edition,\n             // Unstable legacy stuff\n-            SyntaxExtension::NonMacroAttr |\n+            SyntaxExtension::NonMacroAttr { .. } |\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |\n@@ -739,6 +739,12 @@ pub enum Determinacy {\n     Undetermined,\n }\n \n+impl Determinacy {\n+    pub fn determined(determined: bool) -> Determinacy {\n+        if determined { Determinacy::Determined } else { Determinacy::Undetermined }\n+    }\n+}\n+\n pub struct DummyResolver;\n \n impl Resolver for DummyResolver {"}, {"sha": "72e0abfea8bd0621e177c532b3a5fb9f7676da06", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -244,12 +244,12 @@ impl Invocation {\n         }\n     }\n \n-    pub fn path_span(&self) -> Span {\n+    pub fn path(&self) -> Option<&Path> {\n         match self.kind {\n-            InvocationKind::Bang { ref mac, .. } => mac.node.path.span,\n-            InvocationKind::Attr { attr: Some(ref attr), .. } => attr.path.span,\n-            InvocationKind::Attr { attr: None, .. } => DUMMY_SP,\n-            InvocationKind::Derive { ref path, .. } => path.span,\n+            InvocationKind::Bang { ref mac, .. } => Some(&mac.node.path),\n+            InvocationKind::Attr { attr: Some(ref attr), .. } => Some(&attr.path),\n+            InvocationKind::Attr { attr: None, .. } => None,\n+            InvocationKind::Derive { ref path, .. } => Some(path),\n         }\n     }\n }\n@@ -548,7 +548,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        attr::mark_used(&attr);\n+        if let NonMacroAttr { mark_used: false } = *ext {} else {\n+            attr::mark_used(&attr);\n+        }\n         invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n             call_site: attr.span,\n             def_site: None,\n@@ -560,7 +562,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         });\n \n         match *ext {\n-            NonMacroAttr => {\n+            NonMacroAttr { .. } => {\n                 attr::mark_known(&attr);\n                 let item = item.map_attrs(|mut attrs| { attrs.push(attr); attrs });\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n@@ -810,7 +812,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n \n             MultiDecorator(..) | MultiModifier(..) |\n-            AttrProcMacro(..) | SyntaxExtension::NonMacroAttr => {\n+            AttrProcMacro(..) | SyntaxExtension::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n@@ -1487,7 +1489,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         };\n \n         if attr.is_some() || !traits.is_empty()  {\n-            if !self.cx.ecfg.macros_in_extern_enabled() {\n+            if !self.cx.ecfg.macros_in_extern_enabled() &&\n+               !self.cx.ecfg.custom_attribute_enabled() {\n                 if let Some(ref attr) = attr {\n                     emit_feature_err(&self.cx.parse_sess, \"macros_in_extern\", attr.span,\n                                      GateIssue::Language, explain);\n@@ -1668,6 +1671,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_custom_derive = custom_derive,\n         fn enable_format_args_nl = format_args_nl,\n         fn macros_in_extern_enabled = macros_in_extern,\n+        fn custom_attribute_enabled = custom_attribute,\n         fn proc_macro_mod = proc_macro_mod,\n         fn proc_macro_gen = proc_macro_gen,\n         fn proc_macro_expr = proc_macro_expr,"}, {"sha": "3f4ee8342565cf1e9ebb1d20b9d36bd91fd64ddb", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 42, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -32,7 +32,7 @@ use attr;\n use codemap::Spanned;\n use edition::{ALL_EDITIONS, Edition};\n use syntax_pos::{Span, DUMMY_SP};\n-use errors::{DiagnosticBuilder, Handler, FatalError};\n+use errors::{DiagnosticBuilder, Handler};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use symbol::{keywords, Symbol};\n@@ -83,8 +83,10 @@ macro_rules! declare_features {\n             }\n \n             pub fn use_extern_macros(&self) -> bool {\n-                // The `decl_macro` and `tool_attributes` features imply `use_extern_macros`.\n-                self.use_extern_macros || self.decl_macro || self.tool_attributes\n+                // The `decl_macro`, `tool_attributes` and `custom_attributes`\n+                // features imply `use_extern_macros`.\n+                self.use_extern_macros || self.decl_macro ||\n+                self.tool_attributes || self.custom_attribute\n             }\n         }\n     };\n@@ -1898,9 +1900,6 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     }\n \n     let mut features = Features::new();\n-\n-    let mut feature_checker = FeatureChecker::default();\n-\n     let mut edition_enabled_features = FxHashMap();\n \n     for &(name, .., f_edition, set) in ACTIVE_FEATURES.iter() {\n@@ -1989,45 +1988,9 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         }\n     }\n \n-    feature_checker.check(span_handler);\n-\n     features\n }\n \n-/// A collector for mutually exclusive and interdependent features and their flag spans.\n-#[derive(Default)]\n-struct FeatureChecker {\n-    use_extern_macros: Option<Span>,\n-    custom_attribute: Option<Span>,\n-}\n-\n-impl FeatureChecker {\n-    // If this method turns out to be a hotspot due to branching,\n-    // the branching can be eliminated by modifying `set!()` to set these spans\n-    // only for the features that need to be checked for mutual exclusion.\n-    fn collect(&mut self, features: &Features, span: Span) {\n-        if features.use_extern_macros() {\n-            // If self.use_extern_macros is None, set to Some(span)\n-            self.use_extern_macros = self.use_extern_macros.or(Some(span));\n-        }\n-\n-        if features.custom_attribute {\n-            self.custom_attribute = self.custom_attribute.or(Some(span));\n-        }\n-    }\n-\n-    fn check(self, handler: &Handler) {\n-        if let (Some(pm_span), Some(ca_span)) = (self.use_extern_macros, self.custom_attribute) {\n-            handler.struct_span_err(pm_span, \"Cannot use `#![feature(use_extern_macros)]` and \\\n-                                              `#![feature(custom_attribute)] at the same time\")\n-                .span_note(ca_span, \"`#![feature(custom_attribute)]` declared here\")\n-                .emit();\n-\n-            FatalError.raise();\n-        }\n-    }\n-}\n-\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,"}, {"sha": "896817bb85832f11ffe35885afd41aeb9be2d07b", "filename": "src/test/compile-fail/stmt_expr_attrs_no_feature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     #[attr]\n     fn a() {}\n \n-    #[attr]\n+    #[attr] //~ ERROR attributes on expressions are experimental\n     {\n \n     }"}, {"sha": "2d97e160f49144a40080c8050082c284858d9c06", "filename": "src/test/ui/tool-attributes-disabled-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -11,9 +11,5 @@\n // If macro modularization (`use_extern_macros`) is not enabled,\n // then tool attributes are treated as custom attributes.\n \n-// compile-pass\n-\n-#![feature(custom_attribute)]\n-\n-#[rustfmt::bar]\n+#[rustfmt::bar] //~ ERROR attribute `rustfmt::bar` is currently unknown to the compiler\n fn main() {}"}, {"sha": "b327773dd6adcf619bcd9313068325e2b1b5957a", "filename": "src/test/ui/tool-attributes-disabled-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-disabled-2.stderr?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: The attribute `rustfmt::bar` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/tool-attributes-disabled-2.rs:14:1\n+   |\n+LL | #[rustfmt::bar] //~ ERROR attribute `rustfmt::bar` is currently unknown to the compiler\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "7a6b9ae9943bc99c818d3d8cdf095c939e3e5981", "filename": "src/test/ui/tool-attributes-misplaced-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.rs?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tool_attributes)]\n+#![feature(tool_attributes, custom_attribute)]\n \n type A = rustfmt; //~ ERROR expected type, found tool module `rustfmt`\n type B = rustfmt::skip; //~ ERROR expected type, found tool attribute `rustfmt::skip`\n \n #[derive(rustfmt)] //~ ERROR cannot find derive macro `rustfmt` in this scope\n struct S;\n \n-#[rustfmt] //~ ERROR cannot find attribute macro `rustfmt` in this scope\n+#[rustfmt] // OK, interpreted as a custom attribute\n fn check() {}\n \n #[rustfmt::skip] // OK"}, {"sha": "60188aebce77cff6fb2cb84299b2d0ee6f8a6407", "filename": "src/test/ui/tool-attributes-misplaced-1.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f60d96a4773db747aef75014ef6b41b39ae92372/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes-misplaced-1.stderr?ref=f60d96a4773db747aef75014ef6b41b39ae92372", "patch": "@@ -4,12 +4,6 @@ error: cannot find derive macro `rustfmt` in this scope\n LL | #[derive(rustfmt)] //~ ERROR cannot find derive macro `rustfmt` in this scope\n    |          ^^^^^^^\n \n-error: cannot find attribute macro `rustfmt` in this scope\n-  --> $DIR/tool-attributes-misplaced-1.rs:19:3\n-   |\n-LL | #[rustfmt] //~ ERROR cannot find attribute macro `rustfmt` in this scope\n-   |   ^^^^^^^\n-\n error: cannot find macro `rustfmt!` in this scope\n   --> $DIR/tool-attributes-misplaced-1.rs:25:5\n    |\n@@ -40,7 +34,7 @@ error[E0423]: expected value, found tool attribute `rustfmt::skip`\n LL |     rustfmt::skip; //~ ERROR expected value, found tool attribute `rustfmt::skip`\n    |     ^^^^^^^^^^^^^ not a value\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n \n Some errors occurred: E0423, E0573.\n For more information about an error, try `rustc --explain E0423`."}]}