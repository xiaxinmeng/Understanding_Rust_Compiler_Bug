{"sha": "ab19d4a515366ab68b73af3f9a55db52d5542a06", "node_id": "C_kwDOAAsO6NoAKGFiMTlkNGE1MTUzNjZhYjY4YjczYWYzZjlhNTVkYjUyZDU1NDJhMDY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-21T21:03:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-21T21:03:17Z"}, "message": "Rollup merge of #93046 - est31:let_else, r=davidtwco\n\nUse let_else in even more places\n\nFollowup of #89933, #91018, #91481.", "tree": {"sha": "75d62d47faea1f961402cbd1e87f8c9ffd89da8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75d62d47faea1f961402cbd1e87f8c9ffd89da8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab19d4a515366ab68b73af3f9a55db52d5542a06", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6x+VCRBK7hj4Ov3rIwAAU8wIABqS/ZNapuPxmYgynHZghsNJ\nGVVtDxqS/luBOn2X9Tp19JQIhJInqh06xk22sRHG0nZn7CpHrsNpEuj+b7VsbXEs\n4UcRh3J4zm8tDTpqW8tyhyqFQo9B1khg0k50uCcpgtTgg1E8yhju6lu9qsF7Zzz8\n1h/93dtsj7x53/i+ukwwxjf0G3zwXUpNzA2Asu1CqP9OC7YCVE+UuubkyzpUFaRE\n1f5SXCU37RO0bBggW+SSpL6diZJxZAuspafDxnwAzrpcagAHutiFFX97BhicnegZ\nOvyXI6We7zGSPMfRQqm8HDkmaxY5Y1vSflAlSSRuPNTxnB8A/jlzRdnEtZlFF0M=\n=Ru6q\n-----END PGP SIGNATURE-----\n", "payload": "tree 75d62d47faea1f961402cbd1e87f8c9ffd89da8c\nparent 1f3a2dd0b1990bbb2e225f3b341a225e171f6c91\nparent b2dd1377c7b2624391d82b0eee2c988e090dd311\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642798997 +0100\ncommitter GitHub <noreply@github.com> 1642798997 +0100\n\nRollup merge of #93046 - est31:let_else, r=davidtwco\n\nUse let_else in even more places\n\nFollowup of #89933, #91018, #91481.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab19d4a515366ab68b73af3f9a55db52d5542a06", "html_url": "https://github.com/rust-lang/rust/commit/ab19d4a515366ab68b73af3f9a55db52d5542a06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab19d4a515366ab68b73af3f9a55db52d5542a06/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f3a2dd0b1990bbb2e225f3b341a225e171f6c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f3a2dd0b1990bbb2e225f3b341a225e171f6c91", "html_url": "https://github.com/rust-lang/rust/commit/1f3a2dd0b1990bbb2e225f3b341a225e171f6c91"}, {"sha": "b2dd1377c7b2624391d82b0eee2c988e090dd311", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2dd1377c7b2624391d82b0eee2c988e090dd311", "html_url": "https://github.com/rust-lang/rust/commit/b2dd1377c7b2624391d82b0eee2c988e090dd311"}], "stats": {"total": 268, "additions": 131, "deletions": 137}, "files": [{"sha": "c90e43a4060f7e48895be1e8cfc39c213022746b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -1493,7 +1493,7 @@ fn generator_layout_and_saved_local_names<'tcx>(\n \n     let state_arg = mir::Local::new(1);\n     for var in &body.var_debug_info {\n-        let place = if let mir::VarDebugInfoContents::Place(p) = var.value { p } else { continue };\n+        let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n         if place.local != state_arg {\n             continue;\n         }"}, {"sha": "f0612eaba8089f314aa631ec3555b7468c286424", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -7,6 +7,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_else)]\n #![feature(extern_types)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]"}, {"sha": "b911b108a735d3c4974b11659e1a7e09e26bc096", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -1,5 +1,6 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n+#![feature(let_else)]\n #![feature(internal_output_capture)]\n #![feature(thread_spawn_unchecked)]\n #![feature(nll)]"}, {"sha": "6d9183eda9d32e9a00c6fa0fbc6773b96640a7c0", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -717,57 +717,57 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n     }\n \n     fn should_ignore_fn(ret_ty: &ast::FnRetTy) -> bool {\n-        if let ast::FnRetTy::Ty(ref ty) = ret_ty {\n-            fn involves_impl_trait(ty: &ast::Ty) -> bool {\n-                match ty.kind {\n-                    ast::TyKind::ImplTrait(..) => true,\n-                    ast::TyKind::Slice(ref subty)\n-                    | ast::TyKind::Array(ref subty, _)\n-                    | ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. })\n-                    | ast::TyKind::Rptr(_, ast::MutTy { ty: ref subty, .. })\n-                    | ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n-                    ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n-                    ast::TyKind::Path(_, ref path) => {\n-                        path.segments.iter().any(|seg| match seg.args.as_deref() {\n-                            None => false,\n-                            Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n-                                data.args.iter().any(|arg| match arg {\n-                                    ast::AngleBracketedArg::Arg(arg) => match arg {\n-                                        ast::GenericArg::Type(ty) => involves_impl_trait(ty),\n-                                        ast::GenericArg::Lifetime(_)\n-                                        | ast::GenericArg::Const(_) => false,\n-                                    },\n-                                    ast::AngleBracketedArg::Constraint(c) => match c.kind {\n-                                        ast::AssocConstraintKind::Bound { .. } => true,\n-                                        ast::AssocConstraintKind::Equality { ref term } => {\n-                                            match term {\n-                                                Term::Ty(ty) => involves_impl_trait(ty),\n-                                                // FIXME(...): This should check if the constant\n-                                                // involves a trait impl, but for now ignore.\n-                                                Term::Const(_) => false,\n-                                            }\n+        let ast::FnRetTy::Ty(ref ty) = ret_ty else {\n+            return false;\n+        };\n+        fn involves_impl_trait(ty: &ast::Ty) -> bool {\n+            match ty.kind {\n+                ast::TyKind::ImplTrait(..) => true,\n+                ast::TyKind::Slice(ref subty)\n+                | ast::TyKind::Array(ref subty, _)\n+                | ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. })\n+                | ast::TyKind::Rptr(_, ast::MutTy { ty: ref subty, .. })\n+                | ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n+                ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n+                ast::TyKind::Path(_, ref path) => {\n+                    path.segments.iter().any(|seg| match seg.args.as_deref() {\n+                        None => false,\n+                        Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n+                            data.args.iter().any(|arg| match arg {\n+                                ast::AngleBracketedArg::Arg(arg) => match arg {\n+                                    ast::GenericArg::Type(ty) => involves_impl_trait(ty),\n+                                    ast::GenericArg::Lifetime(_) | ast::GenericArg::Const(_) => {\n+                                        false\n+                                    }\n+                                },\n+                                ast::AngleBracketedArg::Constraint(c) => match c.kind {\n+                                    ast::AssocConstraintKind::Bound { .. } => true,\n+                                    ast::AssocConstraintKind::Equality { ref term } => {\n+                                        match term {\n+                                            Term::Ty(ty) => involves_impl_trait(ty),\n+                                            // FIXME(...): This should check if the constant\n+                                            // involves a trait impl, but for now ignore.\n+                                            Term::Const(_) => false,\n                                         }\n-                                    },\n-                                })\n-                            }\n-                            Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n-                                any_involves_impl_trait(data.inputs.iter())\n-                                    || ReplaceBodyWithLoop::should_ignore_fn(&data.output)\n-                            }\n-                        })\n-                    }\n-                    _ => false,\n+                                    }\n+                                },\n+                            })\n+                        }\n+                        Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n+                            any_involves_impl_trait(data.inputs.iter())\n+                                || ReplaceBodyWithLoop::should_ignore_fn(&data.output)\n+                        }\n+                    })\n                 }\n+                _ => false,\n             }\n+        }\n \n-            fn any_involves_impl_trait<'a, I: Iterator<Item = &'a P<ast::Ty>>>(mut it: I) -> bool {\n-                it.any(|subty| involves_impl_trait(subty))\n-            }\n-\n-            involves_impl_trait(ty)\n-        } else {\n-            false\n+        fn any_involves_impl_trait<'a, I: Iterator<Item = &'a P<ast::Ty>>>(mut it: I) -> bool {\n+            it.any(|subty| involves_impl_trait(subty))\n         }\n+\n+        involves_impl_trait(ty)\n     }\n \n     fn is_sig_const(sig: &ast::FnSig) -> bool {"}, {"sha": "3294f2cf64172c65a0beb22e22b4c0eab8ea29e9", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -1347,23 +1347,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let mut otherwise = None;\n         for match_pair in match_pairs {\n-            if let PatKind::Or { ref pats } = *match_pair.pattern.kind {\n-                let or_span = match_pair.pattern.span;\n-                let place = match_pair.place;\n-\n-                first_candidate.visit_leaves(|leaf_candidate| {\n-                    self.test_or_pattern(\n-                        leaf_candidate,\n-                        &mut otherwise,\n-                        pats,\n-                        or_span,\n-                        place.clone(),\n-                        fake_borrows,\n-                    );\n-                });\n-            } else {\n+            let PatKind::Or { ref pats } = &*match_pair.pattern.kind else {\n                 bug!(\"Or-patterns should have been sorted to the end\");\n-            }\n+            };\n+            let or_span = match_pair.pattern.span;\n+            let place = match_pair.place;\n+\n+            first_candidate.visit_leaves(|leaf_candidate| {\n+                self.test_or_pattern(\n+                    leaf_candidate,\n+                    &mut otherwise,\n+                    pats,\n+                    or_span,\n+                    place.clone(),\n+                    fake_borrows,\n+                );\n+            });\n         }\n \n         let remainder_start = otherwise.unwrap_or_else(|| self.cfg.start_new_block());"}, {"sha": "f4bf28bfa5ce294b2202608148810f263776c0ba", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -88,11 +88,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         switch_ty: Ty<'tcx>,\n         options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> bool {\n-        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n-            Some(match_pair) => match_pair,\n-            _ => {\n-                return false;\n-            }\n+        let Some(match_pair) = candidate.match_pairs.iter().find(|mp| mp.place == *test_place) else {\n+            return false;\n         };\n \n         match *match_pair.pattern.kind {"}, {"sha": "7e1e5c788052bfb2f342f3abef5b7b745a25955e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -1171,9 +1171,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         ident: Symbol,\n         kind: &AssocItemKind,\n     ) -> Option<Symbol> {\n-        let module = if let Some((module, _)) = self.current_trait_ref {\n-            module\n-        } else {\n+        let Some((module, _)) = &self.current_trait_ref else {\n             return None;\n         };\n         if ident == kw::Underscore {"}, {"sha": "4c7bdb33fb87abbb9453f496758fef367fc3582c", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -1000,46 +1000,45 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n                 //          ^                 ^this gets resolved in the current scope\n                 for lifetime in lifetimes {\n-                    if let hir::GenericArg::Lifetime(lifetime) = lifetime {\n-                        self.visit_lifetime(lifetime);\n+                    let hir::GenericArg::Lifetime(lifetime) = lifetime else {\n+                        continue\n+                    };\n+                    self.visit_lifetime(lifetime);\n+\n+                    // Check for predicates like `impl for<'a> Trait<impl OtherTrait<'a>>`\n+                    // and ban them. Type variables instantiated inside binders aren't\n+                    // well-supported at the moment, so this doesn't work.\n+                    // In the future, this should be fixed and this error should be removed.\n+                    let def = self.map.defs.get(&lifetime.hir_id).cloned();\n+                    let Some(Region::LateBound(_, _, def_id, _)) = def else {\n+                        continue\n+                    };\n+                    let Some(def_id) = def_id.as_local() else {\n+                        continue\n+                    };\n+                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                    // Ensure that the parent of the def is an item, not HRTB\n+                    let parent_id = self.tcx.hir().get_parent_node(hir_id);\n+                    // FIXME(cjgillot) Can this check be replaced by\n+                    // `let parent_is_item = parent_id.is_owner();`?\n+                    let parent_is_item = if let Some(parent_def_id) = parent_id.as_owner() {\n+                        matches!(self.tcx.hir().krate().owners.get(parent_def_id), Some(Some(_)),)\n+                    } else {\n+                        false\n+                    };\n \n-                        // Check for predicates like `impl for<'a> Trait<impl OtherTrait<'a>>`\n-                        // and ban them. Type variables instantiated inside binders aren't\n-                        // well-supported at the moment, so this doesn't work.\n-                        // In the future, this should be fixed and this error should be removed.\n-                        let def = self.map.defs.get(&lifetime.hir_id).cloned();\n-                        if let Some(Region::LateBound(_, _, def_id, _)) = def {\n-                            if let Some(def_id) = def_id.as_local() {\n-                                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                                // Ensure that the parent of the def is an item, not HRTB\n-                                let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-                                // FIXME(cjgillot) Can this check be replaced by\n-                                // `let parent_is_item = parent_id.is_owner();`?\n-                                let parent_is_item =\n-                                    if let Some(parent_def_id) = parent_id.as_owner() {\n-                                        matches!(\n-                                            self.tcx.hir().krate().owners.get(parent_def_id),\n-                                            Some(Some(_)),\n-                                        )\n-                                    } else {\n-                                        false\n-                                    };\n-\n-                                if !parent_is_item {\n-                                    if !self.trait_definition_only {\n-                                        struct_span_err!(\n-                                            self.tcx.sess,\n-                                            lifetime.span,\n-                                            E0657,\n-                                            \"`impl Trait` can only capture lifetimes \\\n-                                                bound at the fn or impl level\"\n-                                        )\n-                                        .emit();\n-                                    }\n-                                    self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n-                                }\n-                            }\n+                    if !parent_is_item {\n+                        if !self.trait_definition_only {\n+                            struct_span_err!(\n+                                self.tcx.sess,\n+                                lifetime.span,\n+                                E0657,\n+                                \"`impl Trait` can only capture lifetimes \\\n+                                    bound at the fn or impl level\"\n+                            )\n+                            .emit();\n                         }\n+                        self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                 }\n "}, {"sha": "3fb42a2ec4a1d73045d89d9904db5959407abe40", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab19d4a515366ab68b73af3f9a55db52d5542a06/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ab19d4a515366ab68b73af3f9a55db52d5542a06", "patch": "@@ -840,39 +840,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::Ref(_, inner_ty, _) = suggested_ty.kind() {\n-                    suggested_ty = inner_ty;\n+                let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n+                    break;\n+                };\n+                suggested_ty = inner_ty;\n \n-                    let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n-                        obligation.param_env,\n-                        trait_ref,\n-                        suggested_ty,\n-                    );\n+                let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n+                    obligation.param_env,\n+                    trait_ref,\n+                    suggested_ty,\n+                );\n \n-                    if self.predicate_may_hold(&new_obligation) {\n-                        let sp = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                if self.predicate_may_hold(&new_obligation) {\n+                    let sp = self\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n \n-                        let remove_refs = refs_remaining + 1;\n+                    let remove_refs = refs_remaining + 1;\n \n-                        let msg = if remove_refs == 1 {\n-                            \"consider removing the leading `&`-reference\".to_string()\n-                        } else {\n-                            format!(\"consider removing {} leading `&`-references\", remove_refs)\n-                        };\n+                    let msg = if remove_refs == 1 {\n+                        \"consider removing the leading `&`-reference\".to_string()\n+                    } else {\n+                        format!(\"consider removing {} leading `&`-references\", remove_refs)\n+                    };\n \n-                        err.span_suggestion_short(\n-                            sp,\n-                            &msg,\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        break;\n-                    }\n-                } else {\n+                    err.span_suggestion_short(\n+                        sp,\n+                        &msg,\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n                     break;\n                 }\n             }"}]}