{"sha": "e64a8193b02ce72ef183274994a25eae281cb89c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NGE4MTkzYjAyY2U3MmVmMTgzMjc0OTk0YTI1ZWFlMjgxY2I4OWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-24T06:31:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-24T06:31:13Z"}, "message": "auto merge of #19858 : nick29581/rust/ranges, r=aturon\n\nCloses #19794\r\n\r\nr? @aturon for the first patch\r\nr? @nikomatsakis for the rest", "tree": {"sha": "567f36abeae55ab43a31ec2391de0beedef7ffc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/567f36abeae55ab43a31ec2391de0beedef7ffc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64a8193b02ce72ef183274994a25eae281cb89c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64a8193b02ce72ef183274994a25eae281cb89c", "html_url": "https://github.com/rust-lang/rust/commit/e64a8193b02ce72ef183274994a25eae281cb89c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64a8193b02ce72ef183274994a25eae281cb89c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "html_url": "https://github.com/rust-lang/rust/commit/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61"}, {"sha": "e82215d4e28cc8376a3623673c00f1f65f588927", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82215d4e28cc8376a3623673c00f1f65f588927", "html_url": "https://github.com/rust-lang/rust/commit/e82215d4e28cc8376a3623673c00f1f65f588927"}], "stats": {"total": 467, "additions": 452, "deletions": 15}, "files": [{"sha": "9c3e53a1aceebd7437ddff9b107fe2dbee7d247a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -2542,6 +2542,64 @@ impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n     }\n }\n \n+\n+/// The `Step` trait identifies objects which can be stepped over in both\n+/// directions. The `steps_between` function provides a way to\n+/// compare two Step objects (it could be provided using `step()` and `Ord`,\n+/// but the implementation would be so inefficient as to be useless).\n+#[unstable = \"Trait is unstable.\"]\n+pub trait Step: Ord {\n+    /// Change self to the next object.\n+    fn step(&mut self);\n+    /// Change self to the previous object.\n+    fn step_back(&mut self);\n+    /// The steps_between two step objects.\n+    /// a should always be less than b, so the result should never be negative.\n+    /// Return None if it is not possible to calculate steps_between without\n+    /// overflow.\n+    fn steps_between(a: &Self, b: &Self) -> Option<uint>;\n+}\n+\n+macro_rules! step_impl {\n+    ($($t:ty)*) => ($(\n+        #[unstable = \"Trait is unstable.\"]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&mut self) { *self += 1; }\n+            #[inline]\n+            fn step_back(&mut self) { *self -= 1; }\n+            #[inline]\n+            fn steps_between(a: &$t, b: &$t) -> Option<uint> {\n+                debug_assert!(a < b);\n+                Some((*a - *b) as uint)\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! step_impl_no_between {\n+    ($($t:ty)*) => ($(\n+        #[unstable = \"Trait is unstable.\"]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&mut self) { *self += 1; }\n+            #[inline]\n+            fn step_back(&mut self) { *self -= 1; }\n+            #[inline]\n+            fn steps_between(_a: &$t, _b: &$t) -> Option<uint> {\n+                None\n+            }\n+        }\n+    )*)\n+}\n+\n+step_impl!(uint u8 u16 u32 int i8 i16 i32);\n+#[cfg(target_word_size = \"64\")]\n+step_impl!(u64 i64);\n+#[cfg(target_word_size = \"32\")]\n+step_impl_no_between!(u64 i64);\n+\n+\n /// An iterator that repeats an element endlessly\n #[deriving(Clone)]\n #[stable]"}, {"sha": "9de723f38ee97fbd45ff614c9a60cc35c41085b8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -59,7 +59,7 @@\n #![allow(unknown_features, raw_pointer_deriving)]\n #![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n-#![feature(default_type_params, unboxed_closures)]\n+#![feature(default_type_params, unboxed_closures, associated_types)]\n #![deny(missing_docs)]\n \n mod macros;"}, {"sha": "0cd8c1d69d1a1e06677f75856dcbe7df4702e570", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -51,7 +51,10 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n+use clone::Clone;\n+use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use kinds::Sized;\n+use option::Option::{mod, Some, None};\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n@@ -833,6 +836,79 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n     fn slice_or_fail_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n \n+\n+/// An unbounded range.\n+#[deriving(Copy)]\n+#[lang=\"full_range\"]\n+pub struct FullRange;\n+\n+/// A (half-open) range which is bounded at both ends.\n+#[deriving(Copy)]\n+#[lang=\"range\"]\n+pub struct Range<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    pub start: Idx,\n+    /// The upper bound of the range (exclusive).\n+    pub end: Idx,\n+}\n+\n+// FIXME(#19391) needs a snapshot\n+//impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> Iterator<Idx> for Range<Idx> {\n+    #[inline]\n+    fn next(&mut self) -> Option<Idx> {\n+        if self.start < self.end {\n+            let result = self.start.clone();\n+            self.start.step();\n+            return Some(result);\n+        }\n+\n+        return None;\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if let Some(hint) = Step::steps_between(&self.end, &self.start) {\n+            (hint, Some(hint))\n+        } else {\n+            (0, None)\n+        }\n+    }\n+}\n+\n+impl<Idx: Clone + Step> DoubleEndedIterator<Idx> for Range<Idx> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Idx> {\n+        if self.start < self.end {\n+            self.end.step_back();\n+            return Some(self.end.clone());\n+        }\n+\n+        return None;\n+    }\n+}\n+\n+impl<Idx: Clone + Step> ExactSizeIterator<Idx> for Range<Idx> {}\n+\n+/// A range which is only bounded below.\n+#[deriving(Copy)]\n+#[lang=\"range_from\"]\n+pub struct RangeFrom<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    pub start: Idx,\n+}\n+\n+impl<Idx: Clone + Step> Iterator<Idx> for RangeFrom<Idx> {\n+    #[inline]\n+    fn next(&mut self) -> Option<Idx> {\n+        // Deliberately overflow so we loop forever.\n+        let result = self.start.clone();\n+        self.start.step();\n+        return Some(result);\n+    }\n+}\n+\n+\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`.\n ///"}, {"sha": "a8889ce9e348bd00c059582b506a45e479d68350", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use test::Bencher;\n+use core::ops::{Range, FullRange, RangeFrom};\n \n // Overhead of dtors\n \n@@ -27,3 +28,35 @@ fn alloc_obj_with_dtor(b: &mut Bencher) {\n         HasDtor { _x : 10 };\n     })\n }\n+\n+// Test the Range structs without the syntactic sugar.\n+\n+#[test]\n+fn test_range() {\n+    let r = Range { start: 2u, end: 10 };\n+    let mut count = 0u;\n+    for (i, ri) in r.enumerate() {\n+        assert!(ri == i + 2);\n+        assert!(ri >= 2u && ri < 10u);\n+        count += 1;\n+    }\n+    assert!(count == 8);\n+}\n+\n+#[test]\n+fn test_range_from() {\n+    let r = RangeFrom { start: 2u };\n+    let mut count = 0u;\n+    for (i, ri) in r.take(10).enumerate() {\n+        assert!(ri == i + 2);\n+        assert!(ri >= 2u && ri < 12u);\n+        count += 1;\n+    }\n+    assert!(count == 10);\n+}\n+\n+#[test]\n+fn test_full_range() {\n+    // Not much to test.\n+    let _ = FullRange;\n+}"}, {"sha": "f50790f7e9b15a56442a3032003376ce20b83ab4", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -439,6 +439,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                           start.iter().chain(end.iter()).map(|x| &**x))\n             }\n \n+            ast::ExprRange(ref start, ref end) => {\n+                let fields = Some(&**start).into_iter()\n+                    .chain(end.as_ref().map(|e| &**e).into_iter());\n+                self.straightline(expr, pred, fields)\n+            }\n+\n             ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n                 self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }"}, {"sha": "bf939e98338629daecd0c57f32b04e17702ac14d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -465,6 +465,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 assert!(overloaded);\n             }\n \n+            ast::ExprRange(ref start, ref end) => {\n+                self.consume_expr(&**start);\n+                end.as_ref().map(|e| self.consume_expr(&**e));\n+            }\n+\n             ast::ExprCall(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &**callee);\n                 self.consume_exprs(args);"}, {"sha": "b57b5554ed64ffc25de74b50b76c201e6d959915", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -366,6 +366,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n             infer::IfExpression(_) => \"if and else have incompatible types\",\n             infer::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n+            infer::RangeExpression(_) => \"start and end of range have incompatible types\",\n             infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n@@ -1490,6 +1491,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     infer::IfExpressionWithNoElse(_) => {\n                         format!(\"if may be missing an else clause\")\n                     }\n+                    infer::RangeExpression(_) => {\n+                        format!(\"start and end of range have compatible types\")\n+                    }\n                     infer::EquatePredicate(_) => {\n                         format!(\"equality where clause is satisfied\")\n                     }"}, {"sha": "07823779216d96cbe6015f4385348eac6f9e8f20", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -127,6 +127,9 @@ pub enum TypeOrigin {\n     // Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse(Span),\n \n+    // Computing common supertype in a range expression\n+    RangeExpression(Span),\n+\n     // `where a == b`\n     EquatePredicate(Span),\n }\n@@ -1084,6 +1087,7 @@ impl TypeOrigin {\n             MatchExpressionArm(match_span, _) => match_span,\n             IfExpression(span) => span,\n             IfExpressionWithNoElse(span) => span,\n+            RangeExpression(span) => span,\n             EquatePredicate(span) => span,\n         }\n     }\n@@ -1117,6 +1121,9 @@ impl<'tcx> Repr<'tcx> for TypeOrigin {\n             IfExpressionWithNoElse(a) => {\n                 format!(\"IfExpressionWithNoElse({})\", a.repr(tcx))\n             }\n+            RangeExpression(a) => {\n+                format!(\"RangeExpression({})\", a.repr(tcx))\n+            }\n             EquatePredicate(a) => {\n                 format!(\"EquatePredicate({})\", a.repr(tcx))\n             }"}, {"sha": "ca3087f08c4105606db9cc829bf51f79b12e30cb", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -267,6 +267,9 @@ lets_do_this! {\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n     SliceTraitLangItem,              \"slice\",                   slice_trait;\n     SliceMutTraitLangItem,           \"slice_mut\",               slice_mut_trait;\n+    RangeStructLangItem,             \"range\",                   range_struct;\n+    RangeFromStructLangItem,         \"range_from\",              range_from_struct;\n+    FullRangeStructLangItem,         \"full_range\",              full_range_struct;\n \n     UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;\n "}, {"sha": "f59a67e2e806dcf1556acd1179244303180b7fdb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -514,7 +514,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n       ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n       ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-      ast::ExprSlice(..) => {\n+      ast::ExprSlice(..) | ast::ExprRange(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -1197,6 +1197,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**e1, succ)\n           }\n \n+          ast::ExprRange(ref e1, ref e2) => {\n+            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n+            self.propagate_through_expr(&**e1, succ)\n+          }\n+\n           ast::ExprBox(None, ref e) |\n           ast::ExprAddrOf(_, ref e) |\n           ast::ExprCast(ref e, _) |\n@@ -1489,7 +1494,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n-      ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n+      ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n+      ast::ExprSlice(..) | ast::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {"}, {"sha": "932a124ed339b19ea9e03dc342a3a27645b4e86b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -541,7 +541,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprClosure(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) | ast::ExprSlice(..) |\n+          ast::ExprUnary(..) | ast::ExprSlice(..) | ast::ExprRange(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |"}, {"sha": "9c1259f41202e6fc9bc7b4886319bc8b0d192229", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -4261,6 +4261,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprCall(..) |\n         ast::ExprMethodCall(..) |\n         ast::ExprStruct(..) |\n+        ast::ExprRange(..) |\n         ast::ExprTup(..) |\n         ast::ExprIf(..) |\n         ast::ExprMatch(..) |"}, {"sha": "c68e9055269c0fca8e3278c39f5f94079c992eee", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -247,6 +247,7 @@ mod svh_visitor {\n         SawExprAssignOp(ast::BinOp),\n         SawExprIndex,\n         SawExprSlice,\n+        SawExprRange,\n         SawExprPath,\n         SawExprAddrOf(ast::Mutability),\n         SawExprRet,\n@@ -280,6 +281,7 @@ mod svh_visitor {\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprSlice(..)            => SawExprSlice,\n+            ExprRange(..)            => SawExprRange,\n             ExprPath(..)             => SawExprPath,\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n             ExprBreak(id)            => SawExprBreak(id.map(content)),"}, {"sha": "8fadaa05203e1829a3b76ef5b0429dc57e78ddb0", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -3494,6 +3494,11 @@ fn populate_scope_map(cx: &CrateContext,\n                 end.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n             }\n \n+            ast::ExprRange(ref start, ref end) => {\n+                walk_expr(cx, &**start, scope_stack, scope_map);\n+                end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            }\n+\n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n                 for ie in init_expressions.iter() {"}, {"sha": "6f9990a3e9ed90655ef8e601ddd12cbcc29a1250", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -39,7 +39,7 @@ use back::abi;\n use llvm::{mod, ValueRef};\n use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::subst::{mod, Subst};\n+use middle::subst::{mod, Subst, Substs};\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -66,6 +66,7 @@ use trans::type_::Type;\n use syntax::{ast, ast_util, codemap};\n use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n+use syntax::parse::token;\n use std::rc::Rc;\n \n // Destinations\n@@ -1048,8 +1049,49 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n+                         node_id_type(bcx, expr.id),\n                          dest)\n         }\n+        ast::ExprRange(ref start, ref end) => {\n+            // FIXME it is just not right that we are synthesising ast nodes in\n+            // trans. Shudder.\n+            fn make_field(field_name: &str, expr: P<ast::Expr>) -> ast::Field {\n+                ast::Field {\n+                    ident: codemap::dummy_spanned(token::str_to_ident(field_name)),\n+                    expr: expr,\n+                    span: codemap::DUMMY_SP,\n+                }\n+            }\n+\n+            // A range just desugars into a struct.\n+            let (did, fields) = match end {\n+                &Some(ref end) => {\n+                    // Desugar to Range\n+                    let fields = vec!(make_field(\"start\", start.clone()),\n+                                      make_field(\"end\", end.clone()));\n+                    (tcx.lang_items.range_struct(), fields)\n+                }\n+                &None => {\n+                    // Desugar to RangeFrom\n+                    let fields = vec!(make_field(\"start\", start.clone()));\n+                    (tcx.lang_items.range_from_struct(), fields)\n+                }\n+            };\n+\n+            if let Some(did) = did {\n+                let substs = Substs::new_type(vec![node_id_type(bcx, start.id)], vec![]);\n+                trans_struct(bcx,\n+                             fields.as_slice(),\n+                             None,\n+                             expr.span,\n+                             expr.id,\n+                             ty::mk_struct(tcx, did, substs),\n+                             dest)\n+            } else {\n+                tcx.sess.span_bug(expr.span,\n+                                  \"No lang item for ranges (how did we get this far?)\")\n+            }\n+        }\n         ast::ExprTup(ref args) => {\n             let numbered_fields: Vec<(uint, &ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n@@ -1347,10 +1389,10 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             base: Option<&ast::Expr>,\n                             expr_span: codemap::Span,\n                             expr_id: ast::NodeId,\n+                            ty: Ty<'tcx>,\n                             dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rec\");\n \n-    let ty = node_id_type(bcx, expr_id);\n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n         let mut need_base = Vec::from_elem(field_tys.len(), true);"}, {"sha": "abcd00ddcce08172afb914c40bfe8071dd05269f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -4251,7 +4251,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   check_expr(fcx, e);\n                   let e_t = fcx.expr_ty(e);\n                   if ty::type_is_error(e_t) {\n-                    fcx.write_ty(id, e_t);\n+                    fcx.write_ty(e.id, e_t);\n                     some_err = true;\n                   }\n               };\n@@ -4291,6 +4291,62 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               }\n           }\n        }\n+       ast::ExprRange(ref start, ref end) => {\n+          check_expr(fcx, &**start);\n+          let t_start = fcx.expr_ty(&**start);\n+\n+          let idx_type = if let &Some(ref e) = end {\n+            check_expr(fcx, &**e);\n+            let t_end = fcx.expr_ty(&**e);\n+            if ty::type_is_error(t_end) {\n+                ty::mk_err()\n+            } else if t_start == ty::mk_err() {\n+                ty::mk_err()\n+            } else {\n+                infer::common_supertype(fcx.infcx(),\n+                                        infer::RangeExpression(expr.span),\n+                                        true,\n+                                        t_start,\n+                                        t_end)\n+            }\n+          } else {\n+            t_start\n+          };\n+\n+          // Note that we don't check the type of start/end satisfy any\n+          // bounds because right the range structs do not have any. If we add\n+          // some bounds, then we'll need to check `t_start` against them here.\n+\n+          let range_type = if idx_type == ty::mk_err() {\n+            ty::mk_err()\n+          } else {\n+            // Find the did from the appropriate lang item.\n+            let did = if end.is_some() {\n+                // Range\n+                tcx.lang_items.range_struct()\n+            } else {\n+                // RangeFrom\n+                tcx.lang_items.range_from_struct()\n+            };\n+\n+            if let Some(did) = did {\n+                let polytype = ty::lookup_item_type(tcx, did);\n+                let substs = Substs::new_type(vec![idx_type], vec![]);\n+                let bounds = polytype.generics.to_bounds(tcx, &substs);\n+                fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::new(expr.span,\n+                                                 fcx.body_id,\n+                                                 traits::ItemObligation(did)),\n+                    &bounds);\n+\n+                ty::mk_struct(tcx, did, substs)\n+            } else {\n+                ty::mk_err()\n+            }\n+          };\n+          fcx.write_ty(id, range_type);\n+       }\n+\n     }\n \n     debug!(\"type of expr({}) {} is...\", expr.id,"}, {"sha": "0c8c17b080bf33f9a0914d40b2d8e3832506daaa", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -724,6 +724,7 @@ pub enum Expr_ {\n     ExprTupField(P<Expr>, Spanned<uint>),\n     ExprIndex(P<Expr>, P<Expr>),\n     ExprSlice(P<Expr>, Option<P<Expr>>, Option<P<Expr>>, Mutability),\n+    ExprRange(P<Expr>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or\n     /// type parameters, e.g. foo::bar::<baz>"}, {"sha": "0803de1bb53e215bc76ef6420f07e47a221f7130", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -1390,6 +1390,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                           e2.map(|x| folder.fold_expr(x)),\n                           m)\n             }\n+            ExprRange(e1, e2) => {\n+                ExprRange(folder.fold_expr(e1),\n+                          e2.map(|x| folder.fold_expr(x)))\n+            }\n             ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),"}, {"sha": "94b61ba56d2e5b938d3012f8f6991ae2a8c4dbf6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -26,7 +26,7 @@ use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n-use ast::{ExprLit, ExprLoop, ExprMac};\n+use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n@@ -95,7 +95,8 @@ bitflags! {\n         const UNRESTRICTED                  = 0b0000,\n         const RESTRICTION_STMT_EXPR         = 0b0001,\n         const RESTRICTION_NO_BAR_OP         = 0b0010,\n-        const RESTRICTION_NO_STRUCT_LITERAL = 0b0100\n+        const RESTRICTION_NO_STRUCT_LITERAL = 0b0100,\n+        const RESTRICTION_NO_DOTS           = 0b1000,\n     }\n }\n \n@@ -1547,7 +1548,7 @@ impl<'a> Parser<'a> {\n \n             // Parse the `; e` in `[ int; e ]`\n             // where `e` is a const expression\n-            let t = match self.maybe_parse_fixed_vstore() {\n+            let t = match self.maybe_parse_fixed_length_of_vec() {\n                 None => TyVec(t),\n                 Some(suffix) => TyFixedLengthVec(t, suffix)\n             };\n@@ -1707,12 +1708,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<P<ast::Expr>> {\n+    pub fn maybe_parse_fixed_length_of_vec(&mut self) -> Option<P<ast::Expr>> {\n         if self.check(&token::Comma) &&\n                 self.look_ahead(1, |t| *t == token::DotDot) {\n             self.bump();\n             self.bump();\n-            Some(self.parse_expr())\n+            Some(self.parse_expr_res(RESTRICTION_NO_DOTS))\n         } else if self.check(&token::Semi) {\n             self.bump();\n             Some(self.parse_expr())\n@@ -2130,14 +2131,22 @@ impl<'a> Parser<'a> {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_slice(&mut self, expr: P<Expr>,\n+    pub fn mk_slice(&mut self,\n+                    expr: P<Expr>,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>,\n                     mutbl: Mutability)\n                     -> ast::Expr_ {\n         ExprSlice(expr, start, end, mutbl)\n     }\n \n+    pub fn mk_range(&mut self,\n+                    start: P<Expr>,\n+                    end: Option<P<Expr>>)\n+                    -> ast::Expr_ {\n+        ExprRange(start, end)\n+    }\n+\n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::Expr_ {\n         ExprField(expr, ident)\n     }\n@@ -2615,7 +2624,7 @@ impl<'a> Parser<'a> {\n                     }\n                     // e[e] | e[e..] | e[e..e]\n                     _ => {\n-                        let ix = self.parse_expr();\n+                        let ix = self.parse_expr_res(RESTRICTION_NO_DOTS);\n                         match self.token {\n                             // e[e..] | e[e..e]\n                             token::DotDot => {\n@@ -2628,7 +2637,7 @@ impl<'a> Parser<'a> {\n                                     }\n                                     // e[e..e]\n                                     _ => {\n-                                        let e2 = self.parse_expr();\n+                                        let e2 = self.parse_expr_res(RESTRICTION_NO_DOTS);\n                                         self.commit_expr_expecting(&*e2,\n                                             token::CloseDelim(token::Bracket));\n                                         Some(e2)\n@@ -2654,6 +2663,21 @@ impl<'a> Parser<'a> {\n                 }\n               }\n \n+              // A range expression, either `expr..expr` or `expr..`.\n+              token::DotDot if !self.restrictions.contains(RESTRICTION_NO_DOTS) => {\n+                self.bump();\n+\n+                let opt_end = if self.token.can_begin_expr() {\n+                    let end = self.parse_expr_res(RESTRICTION_NO_DOTS);\n+                    Some(end)\n+                } else {\n+                    None\n+                };\n+\n+                let hi = self.span.hi;\n+                let range = self.mk_range(e, opt_end);\n+                return self.mk_expr(lo, hi, range);\n+              }\n               _ => return e\n             }\n         }"}, {"sha": "3d53bd8aadf70a0270cf4057b54e3cfaa492d69a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -1759,6 +1759,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(word(&mut self.s, \"]\"));\n             }\n+            ast::ExprRange(ref start, ref end) => {\n+                try!(self.print_expr(&**start));\n+                try!(word(&mut self.s, \"..\"));\n+                if let &Some(ref e) = end {\n+                    try!(self.print_expr(&**e));\n+                }\n+            }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));"}, {"sha": "4cc93467a7cc21f6044c7c83017874f7e05f570a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -871,6 +871,10 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_expr_opt(visitor, start);\n             walk_expr_opt(visitor, end)\n         }\n+        ExprRange(ref start, ref end) => {\n+            visitor.visit_expr(&**start);\n+            walk_expr_opt(visitor, end)\n+        }\n         ExprPath(ref path) => {\n             visitor.visit_path(path, expression.id)\n         }"}, {"sha": "ca7401dc26c8c8e44563cc98e737c1c3e654c8f6", "filename": "src/test/compile-fail/range-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test range syntax - type errors.\n+\n+pub fn main() {\n+    // Mixed types.\n+    let _ = 0u..10i;\n+    //~^ ERROR start and end of range have incompatible types\n+\n+    // Float => does not implement iterator.\n+    for i in 0f32..42f32 {}\n+    //~^ ERROR `for` loop expression has type `core::ops::Range<f32>` which does not implement\n+\n+    // Unsized type.\n+    let arr: &[_] = &[1u, 2, 3];\n+    let range = (*arr)..;\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n+}"}, {"sha": "40690bd844bce6f6980e95b770b41c18fa75bcd2", "filename": "src/test/compile-fail/range-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-2.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test range syntax - borrow errors.\n+\n+pub fn main() {\n+    let r = {\n+        (&42i)..&42\n+        //~^ ERROR borrowed value does not live long enough\n+        //~^^ ERROR borrowed value does not live long enough\n+    };\n+}"}, {"sha": "027121dd4229d4d0453cf99297dfb8d6c42abc29", "filename": "src/test/run-pass/range.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Ftest%2Frun-pass%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64a8193b02ce72ef183274994a25eae281cb89c/src%2Ftest%2Frun-pass%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange.rs?ref=e64a8193b02ce72ef183274994a25eae281cb89c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test range syntax.\n+\n+fn foo() -> int { 42 }\n+\n+pub fn main() {\n+    let mut count = 0;\n+    for i in 0u..10 {\n+        assert!(i >= 0 && i < 10);\n+        count += i;\n+    }\n+    assert!(count == 45);\n+\n+    let mut count = 0;\n+    let mut range = 0u..10;\n+    for i in range {\n+        assert!(i >= 0 && i < 10);\n+        count += i;\n+    }\n+    assert!(count == 45);\n+\n+    let mut count = 0;\n+    let mut rf = 3u..;\n+    for i in rf.take(10) {\n+        assert!(i >= 3 && i < 13);\n+        count += i;\n+    }\n+    assert!(count == 75);\n+\n+    let _ = 0u..4+4-3;\n+    let _ = 0..foo();\n+\n+    // Test we can use two different types with a common supertype.\n+    let x = &42i;\n+    {\n+        let y = 42i;\n+        let _ = x..&y;\n+    }\n+}"}]}