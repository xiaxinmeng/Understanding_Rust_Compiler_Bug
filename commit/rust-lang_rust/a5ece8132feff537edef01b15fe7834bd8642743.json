{"sha": "a5ece8132feff537edef01b15fe7834bd8642743", "node_id": "C_kwDOAAsO6NoAKGE1ZWNlODEzMmZlZmY1MzdlZGVmMDFiMTVmZTc4MzRiZDg2NDI3NDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-27T04:02:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-27T04:02:53Z"}, "message": "Auto merge of #8885 - Serial-ATA:rc-clone-in-vec-init-weak, r=llogiq\n\nSupport `Weak` in [`rc_clone_in_vec_init`]\n\nchangelog: Support `Weak` in [`rc_clone_in_vec_init`]", "tree": {"sha": "81f5cf41849f2193781aff834690c1a7dbe6a500", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81f5cf41849f2193781aff834690c1a7dbe6a500"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ece8132feff537edef01b15fe7834bd8642743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ece8132feff537edef01b15fe7834bd8642743", "html_url": "https://github.com/rust-lang/rust/commit/a5ece8132feff537edef01b15fe7834bd8642743", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ece8132feff537edef01b15fe7834bd8642743/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6553b985408dba318cd93b96eb9ce2b858100635", "url": "https://api.github.com/repos/rust-lang/rust/commits/6553b985408dba318cd93b96eb9ce2b858100635", "html_url": "https://github.com/rust-lang/rust/commit/6553b985408dba318cd93b96eb9ce2b858100635"}, {"sha": "fc28f6acc8ad5e1b6bd8c8963eef28ac02df59d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc28f6acc8ad5e1b6bd8c8963eef28ac02df59d2", "html_url": "https://github.com/rust-lang/rust/commit/fc28f6acc8ad5e1b6bd8c8963eef28ac02df59d2"}], "stats": {"total": 372, "additions": 327, "deletions": 45}, "files": [{"sha": "8db8c4e9b7870117d71022f7baa10809ab1c6bbf", "filename": "clippy_lints/src/rc_clone_in_vec_init.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a5ece8132feff537edef01b15fe7834bd8642743/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ece8132feff537edef01b15fe7834bd8642743/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs?ref=a5ece8132feff537edef01b15fe7834bd8642743", "patch": "@@ -2,7 +2,9 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::VecArgs;\n use clippy_utils::last_path_segment;\n use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::paths;\n use clippy_utils::source::{indent_of, snippet};\n+use clippy_utils::ty::match_type;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -11,10 +13,11 @@ use rustc_span::{sym, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `Arc::new` or `Rc::new` in `vec![elem; len]`\n+    /// Checks for reference-counted pointers (`Arc`, `Rc`, `rc::Weak`, and `sync::Weak`)\n+    /// in `vec![elem; len]`\n     ///\n     /// ### Why is this bad?\n-    /// This will create `elem` once and clone it `len` times - doing so with `Arc` or `Rc`\n+    /// This will create `elem` once and clone it `len` times - doing so with `Arc`/`Rc`/`Weak`\n     /// is a bit misleading, as it will create references to the same pointer, rather\n     /// than different instances.\n     ///\n@@ -26,7 +29,6 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    ///\n     /// // Initialize each value separately:\n     /// let mut data = Vec::with_capacity(100);\n     /// for _ in 0..100 {\n@@ -42,34 +44,20 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.62.0\"]\n     pub RC_CLONE_IN_VEC_INIT,\n     suspicious,\n-    \"initializing `Arc` or `Rc` in `vec![elem; len]`\"\n+    \"initializing reference-counted pointer in `vec![elem; len]`\"\n }\n declare_lint_pass!(RcCloneInVecInit => [RC_CLONE_IN_VEC_INIT]);\n \n impl LateLintPass<'_> for RcCloneInVecInit {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return; };\n         let Some(VecArgs::Repeat(elem, len)) = VecArgs::hir(cx, expr) else { return; };\n-        let Some(symbol) = new_reference_call(cx, elem) else { return; };\n+        let Some((symbol, func_span)) = ref_init(cx, elem) else { return; };\n \n-        emit_lint(cx, symbol, macro_call.span, elem, len);\n+        emit_lint(cx, symbol, macro_call.span, elem, len, func_span);\n     }\n }\n \n-fn elem_snippet(cx: &LateContext<'_>, elem: &Expr<'_>, symbol_name: &str) -> String {\n-    let elem_snippet = snippet(cx, elem.span, \"..\").to_string();\n-    if elem_snippet.contains('\\n') {\n-        // This string must be found in `elem_snippet`, otherwise we won't be constructing\n-        // the snippet in the first place.\n-        let reference_creation = format!(\"{symbol_name}::new\");\n-        let (code_until_reference_creation, _right) = elem_snippet.split_once(&reference_creation).unwrap();\n-\n-        return format!(\"{code_until_reference_creation}{reference_creation}(..)\");\n-    }\n-\n-    elem_snippet\n-}\n-\n fn loop_init_suggestion(elem: &str, len: &str, indent: &str) -> String {\n     format!(\n         r#\"{{\n@@ -89,17 +77,17 @@ fn extract_suggestion(elem: &str, len: &str, indent: &str) -> String {\n     )\n }\n \n-fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, elem: &Expr<'_>, len: &Expr<'_>) {\n+fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, elem: &Expr<'_>, len: &Expr<'_>, func_span: Span) {\n     let symbol_name = symbol.as_str();\n \n     span_lint_and_then(\n         cx,\n         RC_CLONE_IN_VEC_INIT,\n         lint_span,\n-        &format!(\"calling `{symbol_name}::new` in `vec![elem; len]`\"),\n+        \"initializing a reference-counted pointer in `vec![elem; len]`\",\n         |diag| {\n             let len_snippet = snippet(cx, len.span, \"..\");\n-            let elem_snippet = elem_snippet(cx, elem, symbol_name);\n+            let elem_snippet = format!(\"{}(..)\", snippet(cx, elem.span.with_hi(func_span.hi()), \"..\"));\n             let indentation = \" \".repeat(indent_of(cx, lint_span).unwrap_or(0));\n             let loop_init_suggestion = loop_init_suggestion(&elem_snippet, len_snippet.as_ref(), &indentation);\n             let extract_suggestion = extract_suggestion(&elem_snippet, len_snippet.as_ref(), &indentation);\n@@ -109,31 +97,41 @@ fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, elem: &Expr<\n                 lint_span,\n                 format!(\"consider initializing each `{symbol_name}` element individually\"),\n                 loop_init_suggestion,\n-                Applicability::Unspecified,\n+                Applicability::HasPlaceholders,\n             );\n             diag.span_suggestion(\n                 lint_span,\n                 format!(\n                     \"or if this is intentional, consider extracting the `{symbol_name}` initialization to a variable\"\n                 ),\n                 extract_suggestion,\n-                Applicability::Unspecified,\n+                Applicability::HasPlaceholders,\n             );\n         },\n     );\n }\n \n-/// Checks whether the given `expr` is a call to `Arc::new` or `Rc::new`\n-fn new_reference_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n+/// Checks whether the given `expr` is a call to `Arc::new`, `Rc::new`, or evaluates to a `Weak`\n+fn ref_init(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<(Symbol, Span)> {\n     if_chain! {\n         if let ExprKind::Call(func, _args) = expr.kind;\n         if let ExprKind::Path(ref func_path @ QPath::TypeRelative(ty, _)) = func.kind;\n         if let TyKind::Path(ref ty_path) = ty.kind;\n         if let Some(def_id) = cx.qpath_res(ty_path, ty.hir_id).opt_def_id();\n-        if last_path_segment(func_path).ident.name == sym::new;\n \n         then {\n-            return cx.tcx.get_diagnostic_name(def_id).filter(|symbol| symbol == &sym::Arc || symbol == &sym::Rc);\n+            if last_path_segment(func_path).ident.name == sym::new\n+                && let Some(symbol) = cx\n+                    .tcx\n+                    .get_diagnostic_name(def_id)\n+                    .filter(|symbol| symbol == &sym::Arc || symbol == &sym::Rc) {\n+                return Some((symbol, func.span));\n+            }\n+\n+            let ty_path = cx.typeck_results().expr_ty(expr);\n+            if match_type(cx, ty_path, &paths::WEAK_RC) || match_type(cx, ty_path, &paths::WEAK_ARC) {\n+                return Some((Symbol::intern(\"Weak\"), func.span));\n+            }\n         }\n     }\n "}, {"sha": "cd7d91e120650490baffe5d139617c71c851f723", "filename": "tests/ui/rc_clone_in_vec_init/arc.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr?ref=a5ece8132feff537edef01b15fe7834bd8642743", "patch": "@@ -1,4 +1,4 @@\n-error: calling `Arc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/arc.rs:7:13\n    |\n LL |     let v = vec![Arc::new(\"x\".to_string()); 2];\n@@ -10,19 +10,19 @@ help: consider initializing each `Arc` element individually\n    |\n LL ~     let v = {\n LL +         let mut v = Vec::with_capacity(2);\n-LL +         (0..2).for_each(|_| v.push(Arc::new(\"x\".to_string())));\n+LL +         (0..2).for_each(|_| v.push(Arc::new(..)));\n LL +         v\n LL ~     };\n    |\n help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n    |\n LL ~     let v = {\n-LL +         let data = Arc::new(\"x\".to_string());\n+LL +         let data = Arc::new(..);\n LL +         vec![data; 2]\n LL ~     };\n    |\n \n-error: calling `Arc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/arc.rs:15:21\n    |\n LL |             let v = vec![Arc::new(\"x\".to_string()); 2];\n@@ -33,19 +33,19 @@ help: consider initializing each `Arc` element individually\n    |\n LL ~             let v = {\n LL +                 let mut v = Vec::with_capacity(2);\n-LL +                 (0..2).for_each(|_| v.push(Arc::new(\"x\".to_string())));\n+LL +                 (0..2).for_each(|_| v.push(Arc::new(..)));\n LL +                 v\n LL ~             };\n    |\n help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n    |\n LL ~             let v = {\n-LL +                 let data = Arc::new(\"x\".to_string());\n+LL +                 let data = Arc::new(..);\n LL +                 vec![data; 2]\n LL ~             };\n    |\n \n-error: calling `Arc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/arc.rs:21:13\n    |\n LL |       let v = vec![\n@@ -75,7 +75,7 @@ LL +         vec![data; 2]\n LL ~     };\n    |\n \n-error: calling `Arc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/arc.rs:30:14\n    |\n LL |       let v1 = vec!["}, {"sha": "fe861afe05491fff24dce5fd21623278fe882e61", "filename": "tests/ui/rc_clone_in_vec_init/rc.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr?ref=a5ece8132feff537edef01b15fe7834bd8642743", "patch": "@@ -1,4 +1,4 @@\n-error: calling `Rc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/rc.rs:8:13\n    |\n LL |     let v = vec![Rc::new(\"x\".to_string()); 2];\n@@ -10,19 +10,19 @@ help: consider initializing each `Rc` element individually\n    |\n LL ~     let v = {\n LL +         let mut v = Vec::with_capacity(2);\n-LL +         (0..2).for_each(|_| v.push(Rc::new(\"x\".to_string())));\n+LL +         (0..2).for_each(|_| v.push(Rc::new(..)));\n LL +         v\n LL ~     };\n    |\n help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n    |\n LL ~     let v = {\n-LL +         let data = Rc::new(\"x\".to_string());\n+LL +         let data = Rc::new(..);\n LL +         vec![data; 2]\n LL ~     };\n    |\n \n-error: calling `Rc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/rc.rs:16:21\n    |\n LL |             let v = vec![Rc::new(\"x\".to_string()); 2];\n@@ -33,19 +33,19 @@ help: consider initializing each `Rc` element individually\n    |\n LL ~             let v = {\n LL +                 let mut v = Vec::with_capacity(2);\n-LL +                 (0..2).for_each(|_| v.push(Rc::new(\"x\".to_string())));\n+LL +                 (0..2).for_each(|_| v.push(Rc::new(..)));\n LL +                 v\n LL ~             };\n    |\n help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n    |\n LL ~             let v = {\n-LL +                 let data = Rc::new(\"x\".to_string());\n+LL +                 let data = Rc::new(..);\n LL +                 vec![data; 2]\n LL ~             };\n    |\n \n-error: calling `Rc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/rc.rs:22:13\n    |\n LL |       let v = vec![\n@@ -75,7 +75,7 @@ LL +         vec![data; 2]\n LL ~     };\n    |\n \n-error: calling `Rc::new` in `vec![elem; len]`\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n   --> $DIR/rc.rs:31:14\n    |\n LL |       let v1 = vec!["}, {"sha": "693c9b553c562fdeaf28629f2ae269b08f7e68bd", "filename": "tests/ui/rc_clone_in_vec_init/weak.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Fweak.rs?ref=a5ece8132feff537edef01b15fe7834bd8642743", "patch": "@@ -0,0 +1,83 @@\n+#![warn(clippy::rc_clone_in_vec_init)]\n+use std::rc::{Rc, Weak as UnSyncWeak};\n+use std::sync::{Arc, Mutex, Weak as SyncWeak};\n+\n+fn main() {}\n+\n+fn should_warn_simple_case() {\n+    let v = vec![SyncWeak::<u32>::new(); 2];\n+    let v2 = vec![UnSyncWeak::<u32>::new(); 2];\n+\n+    let v = vec![Rc::downgrade(&Rc::new(\"x\".to_string())); 2];\n+    let v = vec![Arc::downgrade(&Arc::new(\"x\".to_string())); 2];\n+}\n+\n+fn should_warn_simple_case_with_big_indentation() {\n+    if true {\n+        let k = 1;\n+        dbg!(k);\n+        if true {\n+            let v = vec![Arc::downgrade(&Arc::new(\"x\".to_string())); 2];\n+            let v2 = vec![Rc::downgrade(&Rc::new(\"x\".to_string())); 2];\n+        }\n+    }\n+}\n+\n+fn should_warn_complex_case() {\n+    let v = vec![\n+        Arc::downgrade(&Arc::new(Mutex::new({\n+            let x = 1;\n+            dbg!(x);\n+            x\n+        })));\n+        2\n+    ];\n+\n+    let v1 = vec![\n+        Rc::downgrade(&Rc::new(Mutex::new({\n+            let x = 1;\n+            dbg!(x);\n+            x\n+        })));\n+        2\n+    ];\n+}\n+\n+fn should_not_warn_custom_weak() {\n+    #[derive(Clone)]\n+    struct Weak;\n+\n+    impl Weak {\n+        fn new() -> Self {\n+            Weak\n+        }\n+    }\n+\n+    let v = vec![Weak::new(); 2];\n+}\n+\n+fn should_not_warn_vec_from_elem_but_not_weak() {\n+    let v = vec![String::new(); 2];\n+    let v1 = vec![1; 2];\n+    let v2 = vec![\n+        Box::new(Arc::downgrade(&Arc::new({\n+            let y = 3;\n+            dbg!(y);\n+            y\n+        })));\n+        2\n+    ];\n+    let v3 = vec![\n+        Box::new(Rc::downgrade(&Rc::new({\n+            let y = 3;\n+            dbg!(y);\n+            y\n+        })));\n+        2\n+    ];\n+}\n+\n+fn should_not_warn_vec_macro_but_not_from_elem() {\n+    let v = vec![Arc::downgrade(&Arc::new(\"x\".to_string()))];\n+    let v = vec![Rc::downgrade(&Rc::new(\"x\".to_string()))];\n+}"}, {"sha": "4a21946ccdfa8dd74f25b2889055ae66c4a7366a", "filename": "tests/ui/rc_clone_in_vec_init/weak.stderr", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Fweak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5ece8132feff537edef01b15fe7834bd8642743/tests%2Fui%2Frc_clone_in_vec_init%2Fweak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Fweak.stderr?ref=a5ece8132feff537edef01b15fe7834bd8642743", "patch": "@@ -0,0 +1,201 @@\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:8:13\n+   |\n+LL |     let v = vec![SyncWeak::<u32>::new(); 2];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::rc-clone-in-vec-init` implied by `-D warnings`\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(SyncWeak::<u32>::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = SyncWeak::<u32>::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:9:14\n+   |\n+LL |     let v2 = vec![UnSyncWeak::<u32>::new(); 2];\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~     let v2 = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(UnSyncWeak::<u32>::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~     let v2 = {\n+LL +         let data = UnSyncWeak::<u32>::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:11:13\n+   |\n+LL |     let v = vec![Rc::downgrade(&Rc::new(\"x\".to_string())); 2];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Rc::downgrade(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = Rc::downgrade(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:12:13\n+   |\n+LL |     let v = vec![Arc::downgrade(&Arc::new(\"x\".to_string())); 2];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Arc::downgrade(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = Arc::downgrade(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:20:21\n+   |\n+LL |             let v = vec![Arc::downgrade(&Arc::new(\"x\".to_string())); 2];\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~             let v = {\n+LL +                 let mut v = Vec::with_capacity(2);\n+LL +                 (0..2).for_each(|_| v.push(Arc::downgrade(..)));\n+LL +                 v\n+LL ~             };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~             let v = {\n+LL +                 let data = Arc::downgrade(..);\n+LL +                 vec![data; 2]\n+LL ~             };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:21:22\n+   |\n+LL |             let v2 = vec![Rc::downgrade(&Rc::new(\"x\".to_string())); 2];\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~             let v2 = {\n+LL +                 let mut v = Vec::with_capacity(2);\n+LL +                 (0..2).for_each(|_| v.push(Rc::downgrade(..)));\n+LL +                 v\n+LL ~             };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~             let v2 = {\n+LL +                 let data = Rc::downgrade(..);\n+LL +                 vec![data; 2]\n+LL ~             };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:27:13\n+   |\n+LL |       let v = vec![\n+   |  _____________^\n+LL | |         Arc::downgrade(&Arc::new(Mutex::new({\n+LL | |             let x = 1;\n+LL | |             dbg!(x);\n+...  |\n+LL | |         2\n+LL | |     ];\n+   | |_____^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Arc::downgrade(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = Arc::downgrade(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: initializing a reference-counted pointer in `vec![elem; len]`\n+  --> $DIR/weak.rs:36:14\n+   |\n+LL |       let v1 = vec![\n+   |  ______________^\n+LL | |         Rc::downgrade(&Rc::new(Mutex::new({\n+LL | |             let x = 1;\n+LL | |             dbg!(x);\n+...  |\n+LL | |         2\n+LL | |     ];\n+   | |_____^\n+   |\n+   = note: each element will point to the same `Weak` instance\n+help: consider initializing each `Weak` element individually\n+   |\n+LL ~     let v1 = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Rc::downgrade(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Weak` initialization to a variable\n+   |\n+LL ~     let v1 = {\n+LL +         let data = Rc::downgrade(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: aborting due to 8 previous errors\n+"}]}