{"sha": "6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYTFmYmI1MmJjMmY4MmE3OGQ3YjU5MmJkZmVkMmIwNWU2ZmI2NjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-12-09T15:40:15Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "recover from unresolved inference variable at end of autoderef\n\nWhen we are scanning for suggestions, an unresolved inference variable\nis not a hard error.", "tree": {"sha": "80497f405af1af13cc61d6c46f4a3362a1811db9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80497f405af1af13cc61d6c46f4a3362a1811db9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "html_url": "https://github.com/rust-lang/rust/commit/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "html_url": "https://github.com/rust-lang/rust/commit/5d41be3629067ddfd16fc672e75c2fcaf95c27ff"}], "stats": {"total": 70, "additions": 47, "deletions": 23}, "files": [{"sha": "b4647df3f4f0a6bed7b874084131c44b06379522", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "patch": "@@ -131,10 +131,18 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n     }\n \n+    /// Returns the final type, generating an error if it is an\n+    /// unresolved inference variable.\n     pub fn unambiguous_final_ty(&self) -> Ty<'tcx> {\n         self.fcx.structurally_resolved_type(self.span, self.cur_ty)\n     }\n \n+    /// Returns the final type we ended up with, which may well be an\n+    /// inference variable (we will resolve it first, if possible).\n+    pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n+        self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n+    }\n+\n     pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n         where I: IntoIterator<Item = &'b hir::Expr>\n     {"}, {"sha": "6353b45200bc977db61b89d3b985c86d27fb18eb", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "patch": "@@ -33,6 +33,8 @@ mod confirm;\n pub mod probe;\n mod suggest;\n \n+use self::probe::IsSuggestion;\n+\n pub enum MethodError<'tcx> {\n     // Did not find an applicable method, but we did find various near-misses that may work.\n     NoMatch(NoMatchData<'tcx>),\n@@ -91,7 +93,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n-        match self.probe_for_name(span, mode, method_name, self_ty, call_expr_id) {\n+        match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                  self_ty, call_expr_id) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n@@ -130,7 +133,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_for_name(span, mode, method_name, self_ty, call_expr.id)?;\n+        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                       self_ty, call_expr.id)?;\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n@@ -328,7 +332,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n-        let pick = self.probe_for_name(span, mode, method_name, self_ty, expr_id)?;\n+        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                       self_ty, expr_id)?;\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);"}, {"sha": "c29c46d146ed728dc4b20f80a90238d118365760", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6ea1fbb52bc2f82a78d7b592bdfed2b05e6fb666", "patch": "@@ -33,25 +33,17 @@ use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n pub enum LookingFor<'tcx> {\n+    /// looking for methods with the given name; this is the normal case\n     MethodName(ast::Name),\n+\n+    /// looking for methods that return a given type; this is used to\n+    /// assemble suggestions\n     ReturnType(Ty<'tcx>),\n }\n \n-impl<'tcx> LookingFor<'tcx> {\n-    pub fn is_method_name(&self) -> bool {\n-        match *self {\n-            LookingFor::MethodName(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_return_type(&self) -> bool {\n-        match *self {\n-            LookingFor::ReturnType(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n+/// Boolean flag used to indicate if this search is for a suggestion\n+/// or not.  If true, we can allow ambiguity and so forth.\n+pub struct IsSuggestion(pub bool);\n \n struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n@@ -183,13 +175,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                return_type,\n                scope_expr_id);\n         let method_names =\n-            self.probe_op(span, mode, LookingFor::ReturnType(return_type), self_ty, scope_expr_id,\n+            self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n+                          self_ty, scope_expr_id,\n                           |probe_cx| Ok(probe_cx.candidate_method_names()))\n                 .unwrap_or(vec![]);\n         method_names\n             .iter()\n             .flat_map(|&method_name| {\n-                match self.probe_for_name(span, mode, method_name, self_ty, scope_expr_id) {\n+                match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty, scope_expr_id) {\n                     Ok(pick) => Some(pick.item),\n                     Err(_) => None,\n                 }\n@@ -201,6 +194,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           span: Span,\n                           mode: Mode,\n                           item_name: ast::Name,\n+                          is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n                           scope_expr_id: ast::NodeId)\n                           -> PickResult<'tcx> {\n@@ -211,6 +205,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.probe_op(span,\n                       mode,\n                       LookingFor::MethodName(item_name),\n+                      is_suggestion,\n                       self_ty,\n                       scope_expr_id,\n                       |probe_cx| probe_cx.pick())\n@@ -220,6 +215,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       span: Span,\n                       mode: Mode,\n                       looking_for: LookingFor<'tcx>,\n+                      is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n                       scope_expr_id: ast::NodeId,\n                       op: OP)\n@@ -234,7 +230,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // think cause spurious errors. Really though this part should\n         // take place in the `self.probe` below.\n         let steps = if mode == Mode::MethodCall {\n-            match self.create_steps(span, self_ty) {\n+            match self.create_steps(span, self_ty, is_suggestion) {\n                 Some(steps) => steps,\n                 None => {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n@@ -287,7 +283,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn create_steps(&self,\n                     span: Span,\n-                    self_ty: Ty<'tcx>)\n+                    self_ty: Ty<'tcx>,\n+                    is_suggestion: IsSuggestion)\n                     -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n@@ -302,8 +299,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .collect();\n \n-        let final_ty = autoderef.unambiguous_final_ty();\n+        let final_ty = autoderef.maybe_ambiguous_final_ty();\n         match final_ty.sty {\n+            ty::TyInfer(ty::TyVar(_)) => {\n+                // Ended in an inference variable. If we are doing\n+                // a real method lookup, this is a hard error (it's an\n+                // ambiguity and we can't make progress).\n+                if !is_suggestion.0 {\n+                    let t = self.structurally_resolved_type(span, final_ty);\n+                    assert_eq!(t, self.tcx.types.err);\n+                    return None\n+                } else {\n+                    // If we're just looking for suggestions,\n+                    // though, ambiguity is no big thing, we can\n+                    // just ignore it.\n+                }\n+            }\n             ty::TyArray(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n "}]}