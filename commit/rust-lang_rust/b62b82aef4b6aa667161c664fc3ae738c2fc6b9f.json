{"sha": "b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "node_id": "C_kwDOAAsO6NoAKGI2MmI4MmFlZjRiNmFhNjY3MTYxYzY2NGZjM2FlNzM4YzJmYzZiOWY", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-02-01T12:30:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-10T05:34:13Z"}, "message": "Resolve documentation links in rustc and store the results in metadata\n\nThis commit implements MCP https://github.com/rust-lang/compiler-team/issues/584\n\nIt also removes code that is no longer used, and that includes code cloning resolver, so issue #83761 is fixed.", "tree": {"sha": "8810a1d178702e82c4e1a783d52e3515246ea78a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8810a1d178702e82c4e1a783d52e3515246ea78a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "html_url": "https://github.com/rust-lang/rust/commit/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a12d31d5a681d70f277b4fbf6cafe22bae876ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12d31d5a681d70f277b4fbf6cafe22bae876ea7", "html_url": "https://github.com/rust-lang/rust/commit/a12d31d5a681d70f277b4fbf6cafe22bae876ea7"}], "stats": {"total": 1506, "additions": 653, "deletions": 853}, "files": [{"sha": "ed5065d7611a57ee93d7f56a832bef6043640d09", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -4613,6 +4613,7 @@ name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n+ \"pulldown-cmark 0.9.2\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n@@ -4878,7 +4879,6 @@ dependencies = [\n  \"itertools\",\n  \"minifier\",\n  \"once_cell\",\n- \"pulldown-cmark 0.9.2\",\n  \"rayon\",\n  \"regex\",\n  \"rustdoc-json-types\","}, {"sha": "e0d77cdaebb3698cc64614b958370223495df800", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -486,6 +486,14 @@ impl<HCX> ToStableHashKey<HCX> for String {\n     }\n }\n \n+impl<HCX, T1: ToStableHashKey<HCX>, T2: ToStableHashKey<HCX>> ToStableHashKey<HCX> for (T1, T2) {\n+    type KeyType = (T1::KeyType, T2::KeyType);\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &HCX) -> Self::KeyType {\n+        (self.0.to_stable_hash_key(hcx), self.1.to_stable_hash_key(hcx))\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for bool {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {"}, {"sha": "f1801a0f844f7fbec25a7b8e0e191e83d51d257c", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -2,6 +2,8 @@ use crate::hir;\n \n use rustc_ast as ast;\n use rustc_ast::NodeId;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::ToStableHashKey;\n use rustc_macros::HashStable_Generic;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::hygiene::MacroKind;\n@@ -472,7 +474,8 @@ impl PartialRes {\n \n /// Different kinds of symbols can coexist even if they share the same textual name.\n /// Therefore, they each have a separate universe (known as a \"namespace\").\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n+#[derive(HashStable_Generic)]\n pub enum Namespace {\n     /// The type namespace includes `struct`s, `enum`s, `union`s, `trait`s, and `mod`s\n     /// (and, by extension, crates).\n@@ -499,6 +502,15 @@ impl Namespace {\n     }\n }\n \n+impl<CTX: crate::HashStableContext> ToStableHashKey<CTX> for Namespace {\n+    type KeyType = Namespace;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, _: &CTX) -> Namespace {\n+        *self\n+    }\n+}\n+\n /// Just a helper \u2012 separate structure for each namespace.\n #[derive(Copy, Clone, Default, Debug)]\n pub struct PerNS<T> {\n@@ -760,3 +772,5 @@ pub enum LifetimeRes {\n     /// HACK: This is used to recover the NodeId of an elided lifetime.\n     ElidedAnchor { start: NodeId, end: NodeId },\n }\n+\n+pub type DocLinkResMap = FxHashMap<(Symbol, Namespace), Option<Res<NodeId>>>;"}, {"sha": "800f85063c41a19fc0b510e87c978ab5fc02f6bf", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, DeriveProcMacro};\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, DocLinkResMap, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n@@ -1163,20 +1163,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    /// Decodes all inherent impls in the crate (for rustdoc).\n-    fn get_inherent_impls(self) -> impl Iterator<Item = (DefId, DefId)> + 'a {\n-        (0..self.root.tables.inherent_impls.size()).flat_map(move |i| {\n-            let ty_index = DefIndex::from_usize(i);\n-            let ty_def_id = self.local_def_id(ty_index);\n-            self.root\n-                .tables\n-                .inherent_impls\n-                .get(self, ty_index)\n-                .decode(self)\n-                .map(move |impl_index| (ty_def_id, self.local_def_id(impl_index)))\n-        })\n-    }\n-\n     /// Decodes all traits in the crate (for rustdoc and rustc diagnostics).\n     fn get_traits(self) -> impl Iterator<Item = DefId> + 'a {\n         self.root.traits.decode(self).map(move |index| self.local_def_id(index))\n@@ -1195,13 +1181,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_all_incoherent_impls(self) -> impl Iterator<Item = DefId> + 'a {\n-        self.cdata\n-            .incoherent_impls\n-            .values()\n-            .flat_map(move |impls| impls.decode(self).map(move |idx| self.local_def_id(idx)))\n-    }\n-\n     fn get_incoherent_impls(self, tcx: TyCtxt<'tcx>, simp: SimplifiedType) -> &'tcx [DefId] {\n         if let Some(impls) = self.cdata.incoherent_impls.get(&simp) {\n             tcx.arena.alloc_from_iter(impls.decode(self).map(|idx| self.local_def_id(idx)))\n@@ -1598,6 +1577,24 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_is_intrinsic(self, index: DefIndex) -> bool {\n         self.root.tables.is_intrinsic.get(self, index)\n     }\n+\n+    fn get_doc_link_resolutions(self, index: DefIndex) -> DocLinkResMap {\n+        self.root\n+            .tables\n+            .doc_link_resolutions\n+            .get(self, index)\n+            .expect(\"no resolutions for a doc link\")\n+            .decode(self)\n+    }\n+\n+    fn get_doc_link_traits_in_scope(self, index: DefIndex) -> impl Iterator<Item = DefId> + 'a {\n+        self.root\n+            .tables\n+            .doc_link_traits_in_scope\n+            .get(self, index)\n+            .expect(\"no traits in scope for a doc link\")\n+            .decode(self)\n+    }\n }\n \n impl CrateMetadata {"}, {"sha": "b12f9b5c917e80f8086416f3e4a7e046eac4450c", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -345,6 +345,10 @@ provide! { tcx, def_id, other, cdata,\n     expn_that_defined => { cdata.get_expn_that_defined(def_id.index, tcx.sess) }\n     generator_diagnostic_data => { cdata.get_generator_diagnostic_data(tcx, def_id.index) }\n     is_doc_hidden => { cdata.get_attr_flags(def_id.index).contains(AttrFlags::IS_DOC_HIDDEN) }\n+    doc_link_resolutions => { tcx.arena.alloc(cdata.get_doc_link_resolutions(def_id.index)) }\n+    doc_link_traits_in_scope => {\n+        tcx.arena.alloc_from_iter(cdata.get_doc_link_traits_in_scope(def_id.index))\n+    }\n }\n \n pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n@@ -613,36 +617,6 @@ impl CStore {\n         self.get_crate_data(cnum).get_trait_impls()\n     }\n \n-    /// Decodes all inherent impls in the crate (for rustdoc).\n-    pub fn inherent_impls_in_crate_untracked(\n-        &self,\n-        cnum: CrateNum,\n-    ) -> impl Iterator<Item = (DefId, DefId)> + '_ {\n-        self.get_crate_data(cnum).get_inherent_impls()\n-    }\n-\n-    /// Decodes all incoherent inherent impls in the crate (for rustdoc).\n-    pub fn incoherent_impls_in_crate_untracked(\n-        &self,\n-        cnum: CrateNum,\n-    ) -> impl Iterator<Item = DefId> + '_ {\n-        self.get_crate_data(cnum).get_all_incoherent_impls()\n-    }\n-\n-    pub fn associated_item_def_ids_untracked<'a>(\n-        &'a self,\n-        def_id: DefId,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = DefId> + 'a {\n-        self.get_crate_data(def_id.krate).get_associated_item_def_ids(def_id.index, sess)\n-    }\n-\n-    pub fn may_have_doc_links_untracked(&self, def_id: DefId) -> bool {\n-        self.get_crate_data(def_id.krate)\n-            .get_attr_flags(def_id.index)\n-            .contains(AttrFlags::MAY_HAVE_DOC_LINKS)\n-    }\n-\n     pub fn is_doc_hidden_untracked(&self, def_id: DefId) -> bool {\n         self.get_crate_data(def_id.krate)\n             .get_attr_flags(def_id.index)"}, {"sha": "263c71ae7028642c7cbcfc9ba01c581602d86008", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -3,7 +3,6 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n-use rustc_ast::util::comments;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n@@ -772,7 +771,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n struct AnalyzeAttrState {\n     is_exported: bool,\n-    may_have_doc_links: bool,\n     is_doc_hidden: bool,\n }\n \n@@ -790,15 +788,12 @@ fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n     let mut should_encode = false;\n     if rustc_feature::is_builtin_only_local(attr.name_or_empty()) {\n         // Attributes marked local-only don't need to be encoded for downstream crates.\n-    } else if let Some(s) = attr.doc_str() {\n+    } else if attr.doc_str().is_some() {\n         // We keep all doc comments reachable to rustdoc because they might be \"imported\" into\n         // downstream crates if they use `#[doc(inline)]` to copy an item's documentation into\n         // their own.\n         if state.is_exported {\n             should_encode = true;\n-            if comments::may_have_doc_links(s.as_str()) {\n-                state.may_have_doc_links = true;\n-            }\n         }\n     } else if attr.has_name(sym::doc) {\n         // If this is a `doc` attribute that doesn't have anything except maybe `inline` (as in\n@@ -1139,7 +1134,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n         let mut state = AnalyzeAttrState {\n             is_exported: tcx.effective_visibilities(()).is_exported(def_id),\n-            may_have_doc_links: false,\n             is_doc_hidden: false,\n         };\n         let attr_iter = tcx\n@@ -1151,9 +1145,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         record_array!(self.tables.attributes[def_id.to_def_id()] <- attr_iter);\n \n         let mut attr_flags = AttrFlags::empty();\n-        if state.may_have_doc_links {\n-            attr_flags |= AttrFlags::MAY_HAVE_DOC_LINKS;\n-        }\n         if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n@@ -1231,6 +1222,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_id.index\n             }));\n         }\n+\n+        for (def_id, res_map) in &tcx.resolutions(()).doc_link_resolutions {\n+            record!(self.tables.doc_link_resolutions[def_id.to_def_id()] <- res_map);\n+        }\n+\n+        for (def_id, traits) in &tcx.resolutions(()).doc_link_traits_in_scope {\n+            record_array!(self.tables.doc_link_traits_in_scope[def_id.to_def_id()] <- traits);\n+        }\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n@@ -1715,6 +1714,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n             }\n             self.encode_deprecation(LOCAL_CRATE.as_def_id());\n+            if let Some(res_map) = tcx.resolutions(()).doc_link_resolutions.get(&CRATE_DEF_ID) {\n+                record!(self.tables.doc_link_resolutions[LOCAL_CRATE.as_def_id()] <- res_map);\n+            }\n+            if let Some(traits) = tcx.resolutions(()).doc_link_traits_in_scope.get(&CRATE_DEF_ID) {\n+                record_array!(self.tables.doc_link_traits_in_scope[LOCAL_CRATE.as_def_id()] <- traits);\n+            }\n \n             // Normally, this information is encoded when we walk the items\n             // defined in this crate. However, we skip doing that for proc-macro crates,\n@@ -2225,6 +2230,18 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n+        doc_link_resolutions: |tcx, def_id| {\n+            tcx.resolutions(())\n+                .doc_link_resolutions\n+                .get(&def_id.expect_local())\n+                .expect(\"no resolutions for a doc link\")\n+        },\n+        doc_link_traits_in_scope: |tcx, def_id| {\n+            tcx.resolutions(())\n+                .doc_link_traits_in_scope\n+                .get(&def_id.expect_local())\n+                .expect(\"no traits in scope for a doc link\")\n+        },\n         traits_in_crate: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n "}, {"sha": "9227609cc8b668c126aa43cc73b8bf9b6f8d3167", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -9,7 +9,7 @@ use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind};\n+use rustc_hir::def::{CtorKind, DefKind, DocLinkResMap};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, DefPathHash, StableCrateId};\n use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items::LangItem;\n@@ -413,6 +413,8 @@ define_tables! {\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n+    doc_link_resolutions: Table<DefIndex, LazyValue<DocLinkResMap>>,\n+    doc_link_traits_in_scope: Table<DefIndex, LazyArray<DefId>>,\n }\n \n #[derive(TyEncodable, TyDecodable)]\n@@ -426,8 +428,7 @@ struct VariantData {\n bitflags::bitflags! {\n     #[derive(Default)]\n     pub struct AttrFlags: u8 {\n-        const MAY_HAVE_DOC_LINKS = 1 << 0;\n-        const IS_DOC_HIDDEN      = 1 << 1;\n+        const IS_DOC_HIDDEN = 1 << 0;\n     }\n }\n "}, {"sha": "9d2144c443b4a0baf406a6b44ba105ad2374d669", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -113,6 +113,7 @@ macro_rules! arena_types {\n             [decode] trait_impl_trait_tys: rustc_data_structures::fx::FxHashMap<rustc_hir::def_id::DefId, rustc_middle::ty::Ty<'tcx>>,\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n+            [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n         ]);\n     )\n }"}, {"sha": "d37d6b37a37c3ac2affe7f4a4c8b83af30b4a571", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -2156,4 +2156,16 @@ rustc_queries! {\n         desc { |tcx| \"deducing parameter attributes for {}\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }\n+\n+    query doc_link_resolutions(def_id: DefId) -> &'tcx DocLinkResMap {\n+        eval_always\n+        desc { \"resolutions for documentation links for a module\" }\n+        separate_provide_extern\n+    }\n+\n+    query doc_link_traits_in_scope(def_id: DefId) -> &'tcx [DefId] {\n+        eval_always\n+        desc { \"traits in scope for documentation links for a module\" }\n+        separate_provide_extern\n+    }\n }"}, {"sha": "cff3ba194bdb27a6b8fd7821e9f1824e412d2178", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -36,7 +36,7 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, DocLinkResMap, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n@@ -181,6 +181,8 @@ pub struct ResolverGlobalCtxt {\n     /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n     pub confused_type_with_std_module: FxHashMap<Span, Span>,\n     pub registered_tools: RegisteredTools,\n+    pub doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n+    pub doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n }\n \n /// Resolutions that should only be used for lowering."}, {"sha": "303675d3ca5c1854fda3d8f8247fd569d26236a7", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -81,6 +81,8 @@ trivially_parameterized_over_tcx! {\n     rustc_hir::IsAsync,\n     rustc_hir::LangItem,\n     rustc_hir::def::DefKind,\n+    rustc_hir::def::DocLinkResMap,\n+    rustc_hir::def_id::DefId,\n     rustc_hir::def_id::DefIndex,\n     rustc_hir::definitions::DefKey,\n     rustc_index::bit_set::BitSet<u32>,"}, {"sha": "bec70974dde048cb1627ef1ba1f30e0682d7a3f2", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -45,7 +45,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n+use rustc_hir::def::{DefKind, DocLinkResMap};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};"}, {"sha": "d4935b52b10442a45f00fc9452efbe57ccb0d112", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n+pulldown-cmark = { version = \"0.9.2\", default-features = false }\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }"}, {"sha": "e74bb0a9a4f32d77f21967d00281f661df9baf6d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -95,7 +95,7 @@ impl<'a> Resolver<'a> {\n     /// Reachable macros with block module parents exist due to `#[macro_export] macro_rules!`,\n     /// but they cannot use def-site hygiene, so the assumption holds\n     /// (<https://github.com/rust-lang/rust/pull/77984#issuecomment-712445508>).\n-    pub fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n+    pub(crate) fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n         loop {\n             match self.get_module(def_id) {\n                 Some(module) => return module,\n@@ -104,7 +104,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn expect_module(&mut self, def_id: DefId) -> Module<'a> {\n+    pub(crate) fn expect_module(&mut self, def_id: DefId) -> Module<'a> {\n         self.get_module(def_id).expect(\"argument `DefId` is not a module\")\n     }\n "}, {"sha": "ed1e787f3962c39400611d6f45a2f3a6696b1990", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -8,7 +8,7 @@\n \n use RibKind::*;\n \n-use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n+use crate::{path_names_to_string, rustdoc, BindingError, Finalize, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n@@ -24,9 +24,10 @@ use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n use rustc_middle::middle::resolve_lifetime::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n+use rustc_session::config::CrateType;\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, SyntaxContext};\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n@@ -620,7 +621,9 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.resolve_arm(arm);\n     }\n     fn visit_block(&mut self, block: &'ast Block) {\n+        let old_macro_rules = self.parent_scope.macro_rules;\n         self.resolve_block(block);\n+        self.parent_scope.macro_rules = old_macro_rules;\n     }\n     fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n         // We deal with repeat expressions explicitly in `resolve_expr`.\n@@ -771,6 +774,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         );\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        self.resolve_doc_links(&foreign_item.attrs);\n         match foreign_item.kind {\n             ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n                 self.with_generic_param_rib(\n@@ -1159,6 +1163,16 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             })\n         });\n     }\n+\n+    fn visit_variant(&mut self, v: &'ast Variant) {\n+        self.resolve_doc_links(&v.attrs);\n+        visit::walk_variant(self, v)\n+    }\n+\n+    fn visit_field_def(&mut self, f: &'ast FieldDef) {\n+        self.resolve_doc_links(&f.attrs);\n+        visit::walk_field_def(self, f)\n+    }\n }\n \n impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -2185,6 +2199,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn resolve_item(&mut self, item: &'ast Item) {\n+        self.resolve_doc_links(&item.attrs);\n+\n         let name = item.ident.name;\n         debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n@@ -2274,9 +2290,18 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 );\n             }\n \n-            ItemKind::Mod(..) | ItemKind::ForeignMod(_) => {\n+            ItemKind::Mod(..) => {\n                 self.with_scope(item.id, |this| {\n+                    this.resolve_doc_links(&item.attrs);\n+                    let old_macro_rules = this.parent_scope.macro_rules;\n                     visit::walk_item(this, item);\n+                    // Maintain macro_rules scopes in the same way as during early resolution\n+                    // for diagnostics and doc links.\n+                    if item.attrs.iter().all(|attr| {\n+                        !attr.has_name(sym::macro_use) && !attr.has_name(sym::macro_escape)\n+                    }) {\n+                        this.parent_scope.macro_rules = old_macro_rules;\n+                    }\n                 });\n             }\n \n@@ -2309,14 +2334,22 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.future_proof_import(use_tree);\n             }\n \n-            ItemKind::ExternCrate(..) | ItemKind::MacroDef(..) => {\n-                // do nothing, these are just around to be encoded\n+            ItemKind::MacroDef(ref macro_def) => {\n+                // Maintain macro_rules scopes in the same way as during early resolution\n+                // for diagnostics and doc links.\n+                if macro_def.macro_rules {\n+                    let (macro_rules_scope, _) =\n+                        self.r.macro_rules_scope(self.r.local_def_id(item.id));\n+                    self.parent_scope.macro_rules = macro_rules_scope;\n+                }\n             }\n \n-            ItemKind::GlobalAsm(_) => {\n+            ItemKind::ForeignMod(_) | ItemKind::GlobalAsm(_) => {\n                 visit::walk_item(self, item);\n             }\n \n+            ItemKind::ExternCrate(..) => {}\n+\n             ItemKind::MacCall(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }\n@@ -2544,6 +2577,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n         for item in trait_items {\n+            self.resolve_doc_links(&item.attrs);\n             match &item.kind {\n                 AssocItemKind::Const(_, ty, default) => {\n                     self.visit_ty(ty);\n@@ -2714,6 +2748,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         seen_trait_items: &mut FxHashMap<DefId, Span>,\n     ) {\n         use crate::ResolutionError::*;\n+        self.resolve_doc_links(&item.attrs);\n         match &item.kind {\n             AssocItemKind::Const(_, ty, default) => {\n                 debug!(\"resolve_implementation AssocItemKind::Const\");\n@@ -4116,6 +4151,86 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             self.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);\n         }\n     }\n+\n+    fn resolve_and_cache_rustdoc_path(&mut self, path_str: &str, ns: Namespace) -> bool {\n+        // FIXME: This caching may be incorrect in case of multiple `macro_rules`\n+        // items with the same name in the same module.\n+        // Also hygiene is not considered.\n+        let mut doc_link_resolutions = std::mem::take(&mut self.r.doc_link_resolutions);\n+        let res = doc_link_resolutions\n+            .entry(self.parent_scope.module.nearest_parent_mod().expect_local())\n+            .or_default()\n+            .entry((Symbol::intern(path_str), ns))\n+            .or_insert_with_key(|(path, ns)| {\n+                let res = self.r.resolve_rustdoc_path(path.as_str(), *ns, self.parent_scope);\n+                if let Some(res) = res\n+                    && let Some(def_id) = res.opt_def_id()\n+                    && !def_id.is_local()\n+                    && self.r.session.crate_types().contains(&CrateType::ProcMacro) {\n+                    // Encoding foreign def ids in proc macro crate metadata will ICE.\n+                    return None;\n+                }\n+                res\n+            })\n+            .is_some();\n+        self.r.doc_link_resolutions = doc_link_resolutions;\n+        res\n+    }\n+\n+    fn resolve_doc_links(&mut self, attrs: &[Attribute]) {\n+        if !attrs.iter().any(|attr| attr.may_have_doc_links()) {\n+            return;\n+        }\n+\n+        let mut need_traits_in_scope = false;\n+        for path_str in rustdoc::attrs_to_preprocessed_links(attrs) {\n+            // Resolve all namespaces due to no disambiguator or for diagnostics.\n+            let mut any_resolved = false;\n+            let mut need_assoc = false;\n+            for ns in [TypeNS, ValueNS, MacroNS] {\n+                if self.resolve_and_cache_rustdoc_path(&path_str, ns) {\n+                    any_resolved = true;\n+                } else if ns != MacroNS {\n+                    need_assoc = true;\n+                }\n+            }\n+\n+            // Resolve all prefixes for type-relative resolution or for diagnostics.\n+            if need_assoc || !any_resolved {\n+                let mut path = &path_str[..];\n+                while let Some(idx) = path.rfind(\"::\") {\n+                    path = &path[..idx];\n+                    need_traits_in_scope = true;\n+                    for ns in [TypeNS, ValueNS, MacroNS] {\n+                        self.resolve_and_cache_rustdoc_path(path, ns);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if need_traits_in_scope {\n+            // FIXME: hygiene is not considered.\n+            let mut doc_link_traits_in_scope = std::mem::take(&mut self.r.doc_link_traits_in_scope);\n+            doc_link_traits_in_scope\n+                .entry(self.parent_scope.module.nearest_parent_mod().expect_local())\n+                .or_insert_with(|| {\n+                    self.r\n+                        .traits_in_scope(None, &self.parent_scope, SyntaxContext::root(), None)\n+                        .into_iter()\n+                        .filter_map(|tr| {\n+                            if !tr.def_id.is_local()\n+                                && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n+                            {\n+                                // Encoding foreign def ids in proc macro crate metadata will ICE.\n+                                return None;\n+                            }\n+                            Some(tr.def_id)\n+                        })\n+                        .collect()\n+                });\n+            self.r.doc_link_traits_in_scope = doc_link_traits_in_scope;\n+        }\n+    }\n }\n \n struct LifetimeCountVisitor<'a, 'b> {\n@@ -4162,6 +4277,7 @@ impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n         visit::walk_crate(&mut LifetimeCountVisitor { r: self }, krate);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n+        late_resolution_visitor.resolve_doc_links(&krate.attrs);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {\n             self.lint_buffer.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");"}, {"sha": "e61e83189c384d01fc2fa05d760bb4be45369426", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -33,7 +33,7 @@ use rustc_data_structures::sync::{Lrc, RwLock};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, LifetimeRes, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathData, Definitions};\n@@ -78,6 +78,7 @@ mod ident;\n mod imports;\n mod late;\n mod macros;\n+pub mod rustdoc;\n \n enum Weak {\n     Yes,\n@@ -138,17 +139,17 @@ enum ScopeSet<'a> {\n /// This struct is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n #[derive(Clone, Copy, Debug)]\n-pub struct ParentScope<'a> {\n-    pub module: Module<'a>,\n+struct ParentScope<'a> {\n+    module: Module<'a>,\n     expansion: LocalExpnId,\n-    pub macro_rules: MacroRulesScopeRef<'a>,\n+    macro_rules: MacroRulesScopeRef<'a>,\n     derives: &'a [ast::Path],\n }\n \n impl<'a> ParentScope<'a> {\n     /// Creates a parent scope with the passed argument used as the module scope component,\n     /// and other scope components set to default empty values.\n-    pub fn module(module: Module<'a>, resolver: &Resolver<'a>) -> ParentScope<'a> {\n+    fn module(module: Module<'a>, resolver: &Resolver<'a>) -> ParentScope<'a> {\n         ParentScope {\n             module,\n             expansion: LocalExpnId::ROOT,\n@@ -1046,6 +1047,8 @@ pub struct Resolver<'a> {\n     lifetime_elision_allowed: FxHashSet<NodeId>,\n \n     effective_visibilities: EffectiveVisibilities,\n+    doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n+    doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1374,6 +1377,8 @@ impl<'a> Resolver<'a> {\n             confused_type_with_std_module: Default::default(),\n             lifetime_elision_allowed: Default::default(),\n             effective_visibilities: Default::default(),\n+            doc_link_resolutions: Default::default(),\n+            doc_link_traits_in_scope: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -1450,6 +1455,8 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module,\n             registered_tools: self.registered_tools,\n+            doc_link_resolutions: self.doc_link_resolutions,\n+            doc_link_traits_in_scope: self.doc_link_traits_in_scope,\n         };\n         let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args,\n@@ -1494,6 +1501,8 @@ impl<'a> Resolver<'a> {\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n             registered_tools: self.registered_tools.clone(),\n             effective_visibilities: self.effective_visibilities.clone(),\n+            doc_link_resolutions: self.doc_link_resolutions.clone(),\n+            doc_link_traits_in_scope: self.doc_link_traits_in_scope.clone(),\n         };\n         let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n@@ -1575,7 +1584,7 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    pub fn traits_in_scope(\n+    fn traits_in_scope(\n         &mut self,\n         current_trait: Option<Module<'a>>,\n         parent_scope: &ParentScope<'a>,\n@@ -1927,7 +1936,7 @@ impl<'a> Resolver<'a> {\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occurred.\n-    pub fn resolve_rustdoc_path(\n+    fn resolve_rustdoc_path(\n         &mut self,\n         path_str: &str,\n         ns: Namespace,\n@@ -1959,16 +1968,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// For rustdoc.\n-    /// For local modules returns only reexports, for external modules returns all children.\n-    pub fn module_children_or_reexports(&self, def_id: DefId) -> Vec<ModChild> {\n-        if let Some(def_id) = def_id.as_local() {\n-            self.reexport_map.get(&def_id).cloned().unwrap_or_default()\n-        } else {\n-            self.cstore().module_children_untracked(def_id, self.session).collect()\n-        }\n-    }\n-\n     /// For rustdoc.\n     pub fn macro_rules_scope(&self, def_id: LocalDefId) -> (MacroRulesScopeRef<'a>, Res) {\n         let scope = *self.macro_rules_scopes.get(&def_id).expect(\"not a `macro_rules` item\");\n@@ -1978,11 +1977,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// For rustdoc.\n-    pub fn get_partial_res(&self, node_id: NodeId) -> Option<PartialRes> {\n-        self.partial_res_map.get(&node_id).copied()\n-    }\n-\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {"}, {"sha": "0c2e8be049884e859074ed9abb4c41f76ea2b832", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -568,7 +568,7 @@ impl<'a> Resolver<'a> {\n         Ok((ext, res))\n     }\n \n-    pub fn resolve_macro_path(\n+    pub(crate) fn resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n         kind: Option<MacroKind>,"}, {"sha": "86172afb8769393a103ceaad9a438e16201178a5", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -0,0 +1,361 @@\n+use pulldown_cmark::{BrokenLink, Event, Options, Parser, Tag};\n+use rustc_ast as ast;\n+use rustc_ast::util::comments::beautify_doc_string;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::def_id::DefId;\n+use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::Span;\n+use std::cell::RefCell;\n+use std::{cmp, mem};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum DocFragmentKind {\n+    /// A doc fragment created from a `///` or `//!` doc comment.\n+    SugaredDoc,\n+    /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n+    RawDoc,\n+}\n+\n+/// A portion of documentation, extracted from a `#[doc]` attribute.\n+///\n+/// Each variant contains the line number within the complete doc-comment where the fragment\n+/// starts, as well as the Span where the corresponding doc comment or attribute is located.\n+///\n+/// Included files are kept separate from inline doc comments so that proper line-number\n+/// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n+/// kept separate because of issue #42760.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct DocFragment {\n+    pub span: Span,\n+    /// The module this doc-comment came from.\n+    ///\n+    /// This allows distinguishing between the original documentation and a pub re-export.\n+    /// If it is `None`, the item was not re-exported.\n+    pub parent_module: Option<DefId>,\n+    pub doc: Symbol,\n+    pub kind: DocFragmentKind,\n+    pub indent: usize,\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub enum MalformedGenerics {\n+    /// This link has unbalanced angle brackets.\n+    ///\n+    /// For example, `Vec<T` should trigger this, as should `Vec<T>>`.\n+    UnbalancedAngleBrackets,\n+    /// The generics are not attached to a type.\n+    ///\n+    /// For example, `<T>` should trigger this.\n+    ///\n+    /// This is detected by checking if the path is empty after the generics are stripped.\n+    MissingType,\n+    /// The link uses fully-qualified syntax, which is currently unsupported.\n+    ///\n+    /// For example, `<Vec as IntoIterator>::into_iter` should trigger this.\n+    ///\n+    /// This is detected by checking if ` as ` (the keyword `as` with spaces around it) is inside\n+    /// angle brackets.\n+    HasFullyQualifiedSyntax,\n+    /// The link has an invalid path separator.\n+    ///\n+    /// For example, `Vec:<T>:new()` should trigger this. Note that `Vec:new()` will **not**\n+    /// trigger this because it has no generics and thus [`strip_generics_from_path`] will not be\n+    /// called.\n+    ///\n+    /// Note that this will also **not** be triggered if the invalid path separator is inside angle\n+    /// brackets because rustdoc mostly ignores what's inside angle brackets (except for\n+    /// [`HasFullyQualifiedSyntax`](MalformedGenerics::HasFullyQualifiedSyntax)).\n+    ///\n+    /// This is detected by checking if there is a colon followed by a non-colon in the link.\n+    InvalidPathSeparator,\n+    /// The link has too many angle brackets.\n+    ///\n+    /// For example, `Vec<<T>>` should trigger this.\n+    TooManyAngleBrackets,\n+    /// The link has empty angle brackets.\n+    ///\n+    /// For example, `Vec<>` should trigger this.\n+    EmptyAngleBrackets,\n+}\n+\n+/// Removes excess indentation on comments in order for the Markdown\n+/// to be parsed correctly. This is necessary because the convention for\n+/// writing documentation is to provide a space between the /// or //! marker\n+/// and the doc text, but Markdown is whitespace-sensitive. For example,\n+/// a block of text with four-space indentation is parsed as a code block,\n+/// so if we didn't unindent comments, these list items\n+///\n+/// /// A list:\n+/// ///\n+/// ///    - Foo\n+/// ///    - Bar\n+///\n+/// would be parsed as if they were in a code block, which is likely not what the user intended.\n+pub fn unindent_doc_fragments(docs: &mut [DocFragment]) {\n+    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n+    // fragments kind's lines are never starting with a whitespace unless they are using some\n+    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n+    // we need to take into account the fact that the minimum indent minus one (to take this\n+    // whitespace into account).\n+    //\n+    // For example:\n+    //\n+    // /// hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In this case, you want \"hello! another\" and not \"hello!  another\".\n+    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n+        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n+    {\n+        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n+        // \"decide\" how much the minimum indent will be.\n+        1\n+    } else {\n+        0\n+    };\n+\n+    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n+    // removed. Example:\n+    //\n+    // ///     hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n+    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n+    // (5 - 1) whitespaces.\n+    let Some(min_indent) = docs\n+        .iter()\n+        .map(|fragment| {\n+            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    min_indent\n+                } else {\n+                    // Compare against either space or tab, ignoring whether they are\n+                    // mixed or not.\n+                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n+                    cmp::min(min_indent, whitespace)\n+                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n+                }\n+            })\n+        })\n+        .min()\n+    else {\n+        return;\n+    };\n+\n+    for fragment in docs {\n+        if fragment.doc == kw::Empty {\n+            continue;\n+        }\n+\n+        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n+            min_indent - add\n+        } else {\n+            min_indent\n+        };\n+\n+        fragment.indent = min_indent;\n+    }\n+}\n+\n+/// The goal of this function is to apply the `DocFragment` transformation that is required when\n+/// transforming into the final Markdown, which is applying the computed indent to each line in\n+/// each doc fragment (a `DocFragment` can contain multiple lines in case of `#[doc = \"\"]`).\n+///\n+/// Note: remove the trailing newline where appropriate\n+pub fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n+    let s = frag.doc.as_str();\n+    let mut iter = s.lines();\n+    if s.is_empty() {\n+        out.push('\\n');\n+        return;\n+    }\n+    while let Some(line) = iter.next() {\n+        if line.chars().any(|c| !c.is_whitespace()) {\n+            assert!(line.len() >= frag.indent);\n+            out.push_str(&line[frag.indent..]);\n+        } else {\n+            out.push_str(line);\n+        }\n+        out.push('\\n');\n+    }\n+}\n+\n+pub fn attrs_to_doc_fragments<'a>(\n+    attrs: impl Iterator<Item = (&'a ast::Attribute, Option<DefId>)>,\n+    doc_only: bool,\n+) -> (Vec<DocFragment>, ast::AttrVec) {\n+    let mut doc_fragments = Vec::new();\n+    let mut other_attrs = ast::AttrVec::new();\n+    for (attr, parent_module) in attrs {\n+        if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n+            let doc = beautify_doc_string(doc_str, comment_kind);\n+            let kind = if attr.is_doc_comment() {\n+                DocFragmentKind::SugaredDoc\n+            } else {\n+                DocFragmentKind::RawDoc\n+            };\n+            let fragment = DocFragment { span: attr.span, doc, kind, parent_module, indent: 0 };\n+            doc_fragments.push(fragment);\n+        } else if !doc_only {\n+            other_attrs.push(attr.clone());\n+        }\n+    }\n+\n+    unindent_doc_fragments(&mut doc_fragments);\n+\n+    (doc_fragments, other_attrs)\n+}\n+\n+/// Return the doc-comments on this item, grouped by the module they came from.\n+/// The module can be different if this is a re-export with added documentation.\n+///\n+/// The last newline is not trimmed so the produced strings are reusable between\n+/// early and late doc link resolution regardless of their position.\n+pub fn prepare_to_doc_link_resolution(\n+    doc_fragments: &[DocFragment],\n+) -> FxHashMap<Option<DefId>, String> {\n+    let mut res = FxHashMap::default();\n+    for fragment in doc_fragments {\n+        let out_str = res.entry(fragment.parent_module).or_default();\n+        add_doc_fragment(out_str, fragment);\n+    }\n+    res\n+}\n+\n+/// Options for rendering Markdown in the main body of documentation.\n+pub fn main_body_opts() -> Options {\n+    Options::ENABLE_TABLES\n+        | Options::ENABLE_FOOTNOTES\n+        | Options::ENABLE_STRIKETHROUGH\n+        | Options::ENABLE_TASKLISTS\n+        | Options::ENABLE_SMART_PUNCTUATION\n+}\n+\n+fn strip_generics_from_path_segment(segment: Vec<char>) -> Result<String, MalformedGenerics> {\n+    let mut stripped_segment = String::new();\n+    let mut param_depth = 0;\n+\n+    let mut latest_generics_chunk = String::new();\n+\n+    for c in segment {\n+        if c == '<' {\n+            param_depth += 1;\n+            latest_generics_chunk.clear();\n+        } else if c == '>' {\n+            param_depth -= 1;\n+            if latest_generics_chunk.contains(\" as \") {\n+                // The segment tries to use fully-qualified syntax, which is currently unsupported.\n+                // Give a helpful error message instead of completely ignoring the angle brackets.\n+                return Err(MalformedGenerics::HasFullyQualifiedSyntax);\n+            }\n+        } else {\n+            if param_depth == 0 {\n+                stripped_segment.push(c);\n+            } else {\n+                latest_generics_chunk.push(c);\n+            }\n+        }\n+    }\n+\n+    if param_depth == 0 {\n+        Ok(stripped_segment)\n+    } else {\n+        // The segment has unbalanced angle brackets, e.g. `Vec<T` or `Vec<T>>`\n+        Err(MalformedGenerics::UnbalancedAngleBrackets)\n+    }\n+}\n+\n+pub fn strip_generics_from_path(path_str: &str) -> Result<String, MalformedGenerics> {\n+    if !path_str.contains(['<', '>']) {\n+        return Ok(path_str.to_string());\n+    }\n+    let mut stripped_segments = vec![];\n+    let mut path = path_str.chars().peekable();\n+    let mut segment = Vec::new();\n+\n+    while let Some(chr) = path.next() {\n+        match chr {\n+            ':' => {\n+                if path.next_if_eq(&':').is_some() {\n+                    let stripped_segment =\n+                        strip_generics_from_path_segment(mem::take(&mut segment))?;\n+                    if !stripped_segment.is_empty() {\n+                        stripped_segments.push(stripped_segment);\n+                    }\n+                } else {\n+                    return Err(MalformedGenerics::InvalidPathSeparator);\n+                }\n+            }\n+            '<' => {\n+                segment.push(chr);\n+\n+                match path.next() {\n+                    Some('<') => {\n+                        return Err(MalformedGenerics::TooManyAngleBrackets);\n+                    }\n+                    Some('>') => {\n+                        return Err(MalformedGenerics::EmptyAngleBrackets);\n+                    }\n+                    Some(chr) => {\n+                        segment.push(chr);\n+\n+                        while let Some(chr) = path.next_if(|c| *c != '>') {\n+                            segment.push(chr);\n+                        }\n+                    }\n+                    None => break,\n+                }\n+            }\n+            _ => segment.push(chr),\n+        }\n+        trace!(\"raw segment: {:?}\", segment);\n+    }\n+\n+    if !segment.is_empty() {\n+        let stripped_segment = strip_generics_from_path_segment(segment)?;\n+        if !stripped_segment.is_empty() {\n+            stripped_segments.push(stripped_segment);\n+        }\n+    }\n+\n+    debug!(\"path_str: {:?}\\nstripped segments: {:?}\", path_str, &stripped_segments);\n+\n+    let stripped_path = stripped_segments.join(\"::\");\n+\n+    if !stripped_path.is_empty() { Ok(stripped_path) } else { Err(MalformedGenerics::MissingType) }\n+}\n+\n+/// Simplified version of the corresponding function in rustdoc.\n+/// If the rustdoc version returns a successful result, this function must return the same result.\n+/// Otherwise this function may return anything.\n+fn preprocess_link(link: &str) -> String {\n+    let link = link.replace('`', \"\");\n+    let link = link.split('#').next().unwrap();\n+    let link = link.rsplit('@').next().unwrap();\n+    let link = link.strip_suffix(\"()\").unwrap_or(link);\n+    let link = link.strip_suffix(\"{}\").unwrap_or(link);\n+    let link = link.strip_suffix(\"[]\").unwrap_or(link);\n+    let link = if link != \"!\" { link.strip_suffix(\"!\").unwrap_or(link) } else { link };\n+    strip_generics_from_path(link).unwrap_or_else(|_| link.to_string())\n+}\n+\n+/// Simplified version of `preprocessed_markdown_links` from rustdoc.\n+/// Must return at least the same links as it, but may add some more links on top of that.\n+pub(crate) fn attrs_to_preprocessed_links(attrs: &[ast::Attribute]) -> Vec<String> {\n+    let (doc_fragments, _) = attrs_to_doc_fragments(attrs.iter().map(|attr| (attr, None)), true);\n+    let doc = prepare_to_doc_link_resolution(&doc_fragments).into_values().next().unwrap();\n+\n+    let links = RefCell::new(Vec::new());\n+    let mut callback = |link: BrokenLink<'_>| {\n+        links.borrow_mut().push(preprocess_link(&link.reference));\n+        None\n+    };\n+    for event in Parser::new_with_broken_link_callback(&doc, main_body_opts(), Some(&mut callback))\n+    {\n+        if let Event::Start(Tag::Link(_, dest, _)) = event {\n+            links.borrow_mut().push(preprocess_link(&dest));\n+        }\n+    }\n+    links.into_inner()\n+}"}, {"sha": "5e592227d49c52bb5e6e2489112b75e55ce685bf", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -12,7 +12,6 @@ askama = { version = \"0.11\", default-features = false, features = [\"config\"] }\n itertools = \"0.10.1\"\n minifier = \"0.2.2\"\n once_cell = \"1.10.0\"\n-pulldown-cmark = { version = \"0.9.2\", default-features = false }\n regex = \"1\"\n rustdoc-json-types = { path = \"../rustdoc-json-types\" }\n serde_json = \"1.0\""}, {"sha": "de350af5159489b219915a9292c22c9dd42a8078", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 168, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -5,12 +5,11 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n use std::sync::OnceLock as OnceCell;\n-use std::{cmp, fmt, iter};\n+use std::{fmt, iter};\n \n use arrayvec::ArrayVec;\n use thin_vec::ThinVec;\n \n-use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n use rustc_const_eval::const_eval::is_unstable_const_fn;\n@@ -24,6 +23,7 @@ use rustc_hir_analysis::check::intrinsic::intrinsic_operation_unsafety;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt, Visibility};\n+use rustc_resolve::rustdoc::{add_doc_fragment, attrs_to_doc_fragments, DocFragment};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -1010,58 +1010,6 @@ impl<I: Iterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n     }\n }\n \n-/// A portion of documentation, extracted from a `#[doc]` attribute.\n-///\n-/// Each variant contains the line number within the complete doc-comment where the fragment\n-/// starts, as well as the Span where the corresponding doc comment or attribute is located.\n-///\n-/// Included files are kept separate from inline doc comments so that proper line-number\n-/// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n-/// kept separate because of issue #42760.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub(crate) struct DocFragment {\n-    pub(crate) span: rustc_span::Span,\n-    /// The module this doc-comment came from.\n-    ///\n-    /// This allows distinguishing between the original documentation and a pub re-export.\n-    /// If it is `None`, the item was not re-exported.\n-    pub(crate) parent_module: Option<DefId>,\n-    pub(crate) doc: Symbol,\n-    pub(crate) kind: DocFragmentKind,\n-    pub(crate) indent: usize,\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub(crate) enum DocFragmentKind {\n-    /// A doc fragment created from a `///` or `//!` doc comment.\n-    SugaredDoc,\n-    /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n-    RawDoc,\n-}\n-\n-/// The goal of this function is to apply the `DocFragment` transformation that is required when\n-/// transforming into the final Markdown, which is applying the computed indent to each line in\n-/// each doc fragment (a `DocFragment` can contain multiple lines in case of `#[doc = \"\"]`).\n-///\n-/// Note: remove the trailing newline where appropriate\n-fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n-    let s = frag.doc.as_str();\n-    let mut iter = s.lines();\n-    if s.is_empty() {\n-        out.push('\\n');\n-        return;\n-    }\n-    while let Some(line) = iter.next() {\n-        if line.chars().any(|c| !c.is_whitespace()) {\n-            assert!(line.len() >= frag.indent);\n-            out.push_str(&line[frag.indent..]);\n-        } else {\n-            out.push_str(line);\n-        }\n-        out.push('\\n');\n-    }\n-}\n-\n /// Collapse a collection of [`DocFragment`]s into one string,\n /// handling indentation and newlines as needed.\n pub(crate) fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n@@ -1073,86 +1021,6 @@ pub(crate) fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n     acc\n }\n \n-/// Removes excess indentation on comments in order for the Markdown\n-/// to be parsed correctly. This is necessary because the convention for\n-/// writing documentation is to provide a space between the /// or //! marker\n-/// and the doc text, but Markdown is whitespace-sensitive. For example,\n-/// a block of text with four-space indentation is parsed as a code block,\n-/// so if we didn't unindent comments, these list items\n-///\n-/// /// A list:\n-/// ///\n-/// ///    - Foo\n-/// ///    - Bar\n-///\n-/// would be parsed as if they were in a code block, which is likely not what the user intended.\n-fn unindent_doc_fragments(docs: &mut Vec<DocFragment>) {\n-    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n-    // fragments kind's lines are never starting with a whitespace unless they are using some\n-    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n-    // we need to take into account the fact that the minimum indent minus one (to take this\n-    // whitespace into account).\n-    //\n-    // For example:\n-    //\n-    // /// hello!\n-    // #[doc = \"another\"]\n-    //\n-    // In this case, you want \"hello! another\" and not \"hello!  another\".\n-    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n-        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n-    {\n-        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n-        // \"decide\" how much the minimum indent will be.\n-        1\n-    } else {\n-        0\n-    };\n-\n-    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n-    // removed. Example:\n-    //\n-    // ///     hello!\n-    // #[doc = \"another\"]\n-    //\n-    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n-    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n-    // (5 - 1) whitespaces.\n-    let Some(min_indent) = docs\n-        .iter()\n-        .map(|fragment| {\n-            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n-                if line.chars().all(|c| c.is_whitespace()) {\n-                    min_indent\n-                } else {\n-                    // Compare against either space or tab, ignoring whether they are\n-                    // mixed or not.\n-                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n-                    cmp::min(min_indent, whitespace)\n-                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n-                }\n-            })\n-        })\n-        .min()\n-    else {\n-        return;\n-    };\n-\n-    for fragment in docs {\n-        if fragment.doc == kw::Empty {\n-            continue;\n-        }\n-\n-        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n-            min_indent - add\n-        } else {\n-            min_indent\n-        };\n-\n-        fragment.indent = min_indent;\n-    }\n-}\n-\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n@@ -1231,26 +1099,7 @@ impl Attributes {\n         attrs: impl Iterator<Item = (&'a ast::Attribute, Option<DefId>)>,\n         doc_only: bool,\n     ) -> Attributes {\n-        let mut doc_strings = Vec::new();\n-        let mut other_attrs = ast::AttrVec::new();\n-        for (attr, parent_module) in attrs {\n-            if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n-                trace!(\"got doc_str={doc_str:?}\");\n-                let doc = beautify_doc_string(doc_str, comment_kind);\n-                let kind = if attr.is_doc_comment() {\n-                    DocFragmentKind::SugaredDoc\n-                } else {\n-                    DocFragmentKind::RawDoc\n-                };\n-                let fragment = DocFragment { span: attr.span, doc, kind, parent_module, indent: 0 };\n-                doc_strings.push(fragment);\n-            } else if !doc_only {\n-                other_attrs.push(attr.clone());\n-            }\n-        }\n-\n-        unindent_doc_fragments(&mut doc_strings);\n-\n+        let (doc_strings, other_attrs) = attrs_to_doc_fragments(attrs, doc_only);\n         Attributes { doc_strings, other_attrs }\n     }\n \n@@ -1269,20 +1118,6 @@ impl Attributes {\n         if out.is_empty() { None } else { Some(out) }\n     }\n \n-    /// Return the doc-comments on this item, grouped by the module they came from.\n-    /// The module can be different if this is a re-export with added documentation.\n-    ///\n-    /// The last newline is not trimmed so the produced strings are reusable between\n-    /// early and late doc link resolution regardless of their position.\n-    pub(crate) fn prepare_to_doc_link_resolution(&self) -> FxHashMap<Option<DefId>, String> {\n-        let mut res = FxHashMap::default();\n-        for fragment in &self.doc_strings {\n-            let out_str = res.entry(fragment.parent_module).or_default();\n-            add_doc_fragment(out_str, fragment);\n-        }\n-        res\n-    }\n-\n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n     pub(crate) fn collapsed_doc_value(&self) -> Option<String> {"}, {"sha": "20627c2cfc164135ceb469fe015207804b386303", "filename": "src/librustdoc/clean/types/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -2,6 +2,7 @@ use super::*;\n \n use crate::clean::collapse_doc_fragments;\n \n+use rustc_resolve::rustdoc::{unindent_doc_fragments, DocFragment, DocFragmentKind};\n use rustc_span::create_default_session_globals_then;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::Symbol;"}, {"sha": "e8316ac976b5f26d84dd75aae138cfffdbcc6aef", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -5,14 +5,13 @@ use rustc_data_structures::unord::UnordSet;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n-use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{HirId, Path, TraitCandidate};\n+use rustc_hir::{HirId, Path};\n use rustc_interface::interface;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n-use rustc_resolve as resolve;\n use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n use rustc_session::Session;\n@@ -35,23 +34,13 @@ pub(crate) use rustc_session::config::{Input, Options, UnstableOptions};\n \n pub(crate) struct ResolverCaches {\n     pub(crate) markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n-    pub(crate) doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n-    /// Traits in scope for a given module.\n-    /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n-    pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     pub(crate) all_trait_impls: Option<Vec<DefId>>,\n     pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n     pub(crate) extern_doc_reachable: DefIdSet,\n }\n \n pub(crate) struct DocContext<'tcx> {\n     pub(crate) tcx: TyCtxt<'tcx>,\n-    /// Name resolver. Used for intra-doc links.\n-    ///\n-    /// The `Rc<RefCell<...>>` wrapping is needed because that is what's returned by\n-    /// [`rustc_interface::Queries::expansion()`].\n-    // FIXME: see if we can get rid of this RefCell somehow\n-    pub(crate) resolver: Rc<RefCell<interface::BoxedResolver>>,\n     pub(crate) resolver_caches: ResolverCaches,\n     /// Used for normalization.\n     ///\n@@ -100,13 +89,6 @@ impl<'tcx> DocContext<'tcx> {\n         ret\n     }\n \n-    pub(crate) fn enter_resolver<F, R>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n-    {\n-        self.resolver.borrow_mut().access(f)\n-    }\n-\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     pub(crate) fn enter_alias<F, R>(&mut self, substs: DefIdMap<clean::SubstParam>, f: F) -> R\n@@ -313,7 +295,6 @@ pub(crate) fn create_config(\n \n pub(crate) fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n-    resolver: Rc<RefCell<interface::BoxedResolver>>,\n     resolver_caches: ResolverCaches,\n     show_coverage: bool,\n     render_options: RenderOptions,\n@@ -348,7 +329,6 @@ pub(crate) fn run_global_ctxt(\n \n     let mut ctxt = DocContext {\n         tcx,\n-        resolver,\n         resolver_caches,\n         param_env: ParamEnv::empty(),\n         external_traits: Default::default(),"}, {"sha": "dee0a01a654138d9fa10078e78309f7f3002517e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -28,6 +28,7 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n+pub(crate) use rustc_resolve::rustdoc::main_body_opts;\n use rustc_span::edition::Edition;\n use rustc_span::{Span, Symbol};\n \n@@ -58,15 +59,6 @@ mod tests;\n \n const MAX_HEADER_LEVEL: u32 = 6;\n \n-/// Options for rendering Markdown in the main body of documentation.\n-pub(crate) fn main_body_opts() -> Options {\n-    Options::ENABLE_TABLES\n-        | Options::ENABLE_FOOTNOTES\n-        | Options::ENABLE_STRIKETHROUGH\n-        | Options::ENABLE_TASKLISTS\n-        | Options::ENABLE_SMART_PUNCTUATION\n-}\n-\n /// Options for rendering Markdown in summaries (e.g., in search results).\n pub(crate) fn summary_opts() -> Options {\n     Options::ENABLE_TABLES"}, {"sha": "0d4a87eb4fe3a3503f35fe5282e2b89d5b758f25", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -31,6 +31,7 @@ extern crate tracing;\n //\n // Dependencies listed in Cargo.toml do not need `extern crate`.\n \n+extern crate pulldown_cmark;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n@@ -792,22 +793,13 @@ fn main_args(at_args: &[String]) -> MainResult {\n         }\n \n         compiler.enter(|queries| {\n-            // We need to hold on to the complete resolver, so we cause everything to be\n-            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n-            // current architecture.\n-            // FIXME(#83761): Resolver cloning can lead to inconsistencies between data in the\n-            // two copies because one of the copies can be modified after `TyCtxt` construction.\n-            let (resolver, resolver_caches) = {\n+            let resolver_caches = {\n                 let expansion = abort_on_err(queries.expansion(), sess);\n                 let (krate, resolver, _) = &*expansion.borrow();\n                 let resolver_caches = resolver.borrow_mut().access(|resolver| {\n-                    collect_intra_doc_links::early_resolve_intra_doc_links(\n-                        resolver,\n-                        krate,\n-                        render_options.document_private,\n-                    )\n+                    collect_intra_doc_links::early_resolve_intra_doc_links(resolver, krate)\n                 });\n-                (resolver.clone(), resolver_caches)\n+                resolver_caches\n             };\n \n             if sess.diagnostic().has_errors_or_lint_errors().is_some() {\n@@ -820,7 +812,6 @@ fn main_args(at_args: &[String]) -> MainResult {\n                 let (krate, render_opts, mut cache) = sess.time(\"run_global_ctxt\", || {\n                     core::run_global_ctxt(\n                         tcx,\n-                        resolver,\n                         resolver_caches,\n                         show_coverage,\n                         render_options,"}, {"sha": "692adcf0a80913291dbd4c8dc8927a9491308089", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 15, "deletions": 158, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -15,15 +15,15 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, ty};\n-use rustc_resolve::ParentScope;\n+use rustc_resolve::rustdoc::MalformedGenerics;\n+use rustc_resolve::rustdoc::{prepare_to_doc_link_resolution, strip_generics_from_path};\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::BytePos;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n-use std::mem;\n use std::ops::Range;\n \n use crate::clean::{self, utils::find_nearest_parent_module};\n@@ -179,47 +179,6 @@ enum ResolutionFailure<'a> {\n     NotResolved(UnresolvedPath<'a>),\n }\n \n-#[derive(Clone, Copy, Debug)]\n-enum MalformedGenerics {\n-    /// This link has unbalanced angle brackets.\n-    ///\n-    /// For example, `Vec<T` should trigger this, as should `Vec<T>>`.\n-    UnbalancedAngleBrackets,\n-    /// The generics are not attached to a type.\n-    ///\n-    /// For example, `<T>` should trigger this.\n-    ///\n-    /// This is detected by checking if the path is empty after the generics are stripped.\n-    MissingType,\n-    /// The link uses fully-qualified syntax, which is currently unsupported.\n-    ///\n-    /// For example, `<Vec as IntoIterator>::into_iter` should trigger this.\n-    ///\n-    /// This is detected by checking if ` as ` (the keyword `as` with spaces around it) is inside\n-    /// angle brackets.\n-    HasFullyQualifiedSyntax,\n-    /// The link has an invalid path separator.\n-    ///\n-    /// For example, `Vec:<T>:new()` should trigger this. Note that `Vec:new()` will **not**\n-    /// trigger this because it has no generics and thus [`strip_generics_from_path`] will not be\n-    /// called.\n-    ///\n-    /// Note that this will also **not** be triggered if the invalid path separator is inside angle\n-    /// brackets because rustdoc mostly ignores what's inside angle brackets (except for\n-    /// [`HasFullyQualifiedSyntax`](MalformedGenerics::HasFullyQualifiedSyntax)).\n-    ///\n-    /// This is detected by checking if there is a colon followed by a non-colon in the link.\n-    InvalidPathSeparator,\n-    /// The link has too many angle brackets.\n-    ///\n-    /// For example, `Vec<<T>>` should trigger this.\n-    TooManyAngleBrackets,\n-    /// The link has empty angle brackets.\n-    ///\n-    /// For example, `Vec<>` should trigger this.\n-    EmptyAngleBrackets,\n-}\n-\n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub(crate) enum UrlFragment {\n     Item(DefId),\n@@ -407,10 +366,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n     }\n \n-    /// Convenience wrapper around `resolve_rustdoc_path`.\n+    /// Convenience wrapper around `doc_link_resolutions`.\n     ///\n     /// This also handles resolving `true` and `false` as booleans.\n-    /// NOTE: `resolve_rustdoc_path` knows only about paths, not about types.\n+    /// NOTE: `doc_link_resolutions` knows only about paths, not about types.\n     /// Associated items will never be resolved by this function.\n     fn resolve_path(\n         &self,\n@@ -426,17 +385,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // Resolver doesn't know about true, false, and types that aren't paths (e.g. `()`).\n         let result = self\n             .cx\n-            .resolver_caches\n-            .doc_link_resolutions\n-            .get(&(Symbol::intern(path_str), ns, module_id))\n+            .tcx\n+            .doc_link_resolutions(module_id)\n+            .get(&(Symbol::intern(path_str), ns))\n             .copied()\n-            .unwrap_or_else(|| {\n-                self.cx.enter_resolver(|resolver| {\n-                    let parent_scope =\n-                        ParentScope::module(resolver.expect_module(module_id), resolver);\n-                    resolver.resolve_rustdoc_path(path_str, ns, parent_scope)\n-                })\n-            })\n+            .unwrap_or_else(|| panic!(\"no resolution for {:?} {:?} {:?}\", path_str, ns, module_id))\n             .and_then(|res| res.try_into().ok())\n             .or_else(|| resolve_primitive(path_str, ns));\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n@@ -779,8 +732,7 @@ fn trait_impls_for<'a>(\n     module: DefId,\n ) -> FxHashSet<(DefId, DefId)> {\n     let tcx = cx.tcx;\n-    let iter = cx.resolver_caches.traits_in_scope[&module].iter().flat_map(|trait_candidate| {\n-        let trait_ = trait_candidate.def_id;\n+    let iter = tcx.doc_link_traits_in_scope(module).iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`\n@@ -846,7 +798,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n         // In the presence of re-exports, this is not the same as the module of the item.\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n         // so we know which module it came from.\n-        for (parent_module, doc) in item.attrs.prepare_to_doc_link_resolution() {\n+        for (parent_module, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n             if !may_have_doc_links(&doc) {\n                 continue;\n             }\n@@ -975,16 +927,12 @@ fn preprocess_link(\n     }\n \n     // Strip generics from the path.\n-    let path_str = if path_str.contains(['<', '>'].as_slice()) {\n-        match strip_generics_from_path(path_str) {\n-            Ok(path) => path,\n-            Err(err) => {\n-                debug!(\"link has malformed generics: {}\", path_str);\n-                return Some(Err(PreprocessingError::MalformedGenerics(err, path_str.to_owned())));\n-            }\n+    let path_str = match strip_generics_from_path(path_str) {\n+        Ok(path) => path,\n+        Err(err) => {\n+            debug!(\"link has malformed generics: {}\", path_str);\n+            return Some(Err(PreprocessingError::MalformedGenerics(err, path_str.to_owned())));\n         }\n-    } else {\n-        path_str.to_owned()\n     };\n \n     // Sanity check to make sure we don't have any angle brackets after stripping generics.\n@@ -2064,94 +2012,3 @@ fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n     debug!(\"resolved primitives {:?}\", prim);\n     Some(Res::Primitive(prim))\n }\n-\n-fn strip_generics_from_path(path_str: &str) -> Result<String, MalformedGenerics> {\n-    let mut stripped_segments = vec![];\n-    let mut path = path_str.chars().peekable();\n-    let mut segment = Vec::new();\n-\n-    while let Some(chr) = path.next() {\n-        match chr {\n-            ':' => {\n-                if path.next_if_eq(&':').is_some() {\n-                    let stripped_segment =\n-                        strip_generics_from_path_segment(mem::take(&mut segment))?;\n-                    if !stripped_segment.is_empty() {\n-                        stripped_segments.push(stripped_segment);\n-                    }\n-                } else {\n-                    return Err(MalformedGenerics::InvalidPathSeparator);\n-                }\n-            }\n-            '<' => {\n-                segment.push(chr);\n-\n-                match path.next() {\n-                    Some('<') => {\n-                        return Err(MalformedGenerics::TooManyAngleBrackets);\n-                    }\n-                    Some('>') => {\n-                        return Err(MalformedGenerics::EmptyAngleBrackets);\n-                    }\n-                    Some(chr) => {\n-                        segment.push(chr);\n-\n-                        while let Some(chr) = path.next_if(|c| *c != '>') {\n-                            segment.push(chr);\n-                        }\n-                    }\n-                    None => break,\n-                }\n-            }\n-            _ => segment.push(chr),\n-        }\n-        trace!(\"raw segment: {:?}\", segment);\n-    }\n-\n-    if !segment.is_empty() {\n-        let stripped_segment = strip_generics_from_path_segment(segment)?;\n-        if !stripped_segment.is_empty() {\n-            stripped_segments.push(stripped_segment);\n-        }\n-    }\n-\n-    debug!(\"path_str: {:?}\\nstripped segments: {:?}\", path_str, &stripped_segments);\n-\n-    let stripped_path = stripped_segments.join(\"::\");\n-\n-    if !stripped_path.is_empty() { Ok(stripped_path) } else { Err(MalformedGenerics::MissingType) }\n-}\n-\n-fn strip_generics_from_path_segment(segment: Vec<char>) -> Result<String, MalformedGenerics> {\n-    let mut stripped_segment = String::new();\n-    let mut param_depth = 0;\n-\n-    let mut latest_generics_chunk = String::new();\n-\n-    for c in segment {\n-        if c == '<' {\n-            param_depth += 1;\n-            latest_generics_chunk.clear();\n-        } else if c == '>' {\n-            param_depth -= 1;\n-            if latest_generics_chunk.contains(\" as \") {\n-                // The segment tries to use fully-qualified syntax, which is currently unsupported.\n-                // Give a helpful error message instead of completely ignoring the angle brackets.\n-                return Err(MalformedGenerics::HasFullyQualifiedSyntax);\n-            }\n-        } else {\n-            if param_depth == 0 {\n-                stripped_segment.push(c);\n-            } else {\n-                latest_generics_chunk.push(c);\n-            }\n-        }\n-    }\n-\n-    if param_depth == 0 {\n-        Ok(stripped_segment)\n-    } else {\n-        // The segment has unbalanced angle brackets, e.g. `Vec<T` or `Vec<T>>`\n-        Err(MalformedGenerics::UnbalancedAngleBrackets)\n-    }\n-}"}, {"sha": "75c3380ee9bb91c49285ec35c14faeb965c3dbc0", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 23, "deletions": 381, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -1,431 +1,73 @@\n-use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n-use crate::passes::collect_intra_doc_links::preprocessed_markdown_links;\n-use crate::passes::collect_intra_doc_links::{Disambiguator, PreprocessedMarkdownLink};\n use crate::visit_lib::early_lib_embargo_visit_item;\n \n-use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, CRATE_DEF_ID};\n-use rustc_hir::TraitCandidate;\n-use rustc_middle::ty::{DefIdTree, Visibility};\n-use rustc_resolve::{ParentScope, Resolver};\n-use rustc_span::symbol::sym;\n-use rustc_span::{Symbol, SyntaxContext};\n-\n-use std::collections::hash_map::Entry;\n-use std::mem;\n+use rustc_hir::def::Res;\n+use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_resolve::Resolver;\n+use rustc_span::Symbol;\n \n pub(crate) fn early_resolve_intra_doc_links(\n     resolver: &mut Resolver<'_>,\n     krate: &ast::Crate,\n-    document_private_items: bool,\n ) -> ResolverCaches {\n-    let parent_scope =\n-        ParentScope::module(resolver.expect_module(CRATE_DEF_ID.to_def_id()), resolver);\n     let mut link_resolver = EarlyDocLinkResolver {\n         resolver,\n-        parent_scope,\n-        visited_mods: Default::default(),\n-        markdown_links: Default::default(),\n-        doc_link_resolutions: Default::default(),\n-        traits_in_scope: Default::default(),\n         all_trait_impls: Default::default(),\n         all_macro_rules: Default::default(),\n         extern_doc_reachable: Default::default(),\n-        local_doc_reachable: Default::default(),\n-        document_private_items,\n     };\n \n-    // Overridden `visit_item` below doesn't apply to the crate root,\n-    // so we have to visit its attributes and reexports separately.\n-    link_resolver.resolve_doc_links_local(&krate.attrs);\n-    link_resolver.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut link_resolver, krate);\n-\n-    // FIXME: somehow rustdoc is still missing crates even though we loaded all\n-    // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n-    // DO NOT REMOVE THIS without first testing on the reproducer in\n-    // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n-    for (extern_name, _) in\n-        link_resolver.resolver.sess().opts.externs.iter().filter(|(_, entry)| entry.add_prelude)\n-    {\n-        link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, parent_scope);\n-    }\n-\n     link_resolver.process_extern_impls();\n \n     ResolverCaches {\n-        markdown_links: Some(link_resolver.markdown_links),\n-        doc_link_resolutions: link_resolver.doc_link_resolutions,\n-        traits_in_scope: link_resolver.traits_in_scope,\n+        markdown_links: Some(Default::default()),\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.all_macro_rules,\n         extern_doc_reachable: link_resolver.extern_doc_reachable,\n     }\n }\n \n-fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes {\n-    Attributes::from_ast_iter(attrs.map(|attr| (attr, None)), true)\n-}\n-\n struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n-    parent_scope: ParentScope<'ra>,\n-    visited_mods: DefIdSet,\n-    markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n-    doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n-    traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_trait_impls: Vec<DefId>,\n     all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n     /// This set is used as a seed for `effective_visibilities`, which are then extended by some\n     /// more items using `lib_embargo_visit_item` during doc inlining.\n     extern_doc_reachable: DefIdSet,\n-    /// This is an easily identifiable superset of items added to `effective_visibilities`\n-    /// using `lib_embargo_visit_item` during doc inlining.\n-    /// The union of `(extern,local)_doc_reachable` is therefore a superset of\n-    /// `effective_visibilities` and can be used for pruning extern impls here\n-    /// in early doc link resolution.\n-    local_doc_reachable: DefIdSet,\n-    document_private_items: bool,\n }\n \n impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n-    fn add_traits_in_scope(&mut self, def_id: DefId) {\n-        // Calls to `traits_in_scope` are expensive, so try to avoid them if only possible.\n-        // Keys in the `traits_in_scope` cache are always module IDs.\n-        if let Entry::Vacant(entry) = self.traits_in_scope.entry(def_id) {\n-            let module = self.resolver.get_nearest_non_block_module(def_id);\n-            let module_id = module.def_id();\n-            let entry = if module_id == def_id {\n-                Some(entry)\n-            } else if let Entry::Vacant(entry) = self.traits_in_scope.entry(module_id) {\n-                Some(entry)\n-            } else {\n-                None\n-            };\n-            if let Some(entry) = entry {\n-                entry.insert(self.resolver.traits_in_scope(\n-                    None,\n-                    &ParentScope::module(module, self.resolver),\n-                    SyntaxContext::root(),\n-                    None,\n-                ));\n-            }\n-        }\n-    }\n-\n-    fn is_doc_reachable(&self, def_id: DefId) -> bool {\n-        self.extern_doc_reachable.contains(&def_id) || self.local_doc_reachable.contains(&def_id)\n-    }\n-\n-    /// Add traits in scope for links in impls collected by the `collect-intra-doc-links` pass.\n-    /// That pass filters impls using type-based information, but we don't yet have such\n-    /// information here, so we just conservatively calculate traits in scope for *all* modules\n-    /// having impls in them.\n     fn process_extern_impls(&mut self) {\n-        // Resolving links in already existing crates may trigger loading of new crates.\n-        let mut start_cnum = 0;\n-        loop {\n-            let crates = Vec::from_iter(self.resolver.cstore().crates_untracked());\n-            for cnum in &crates[start_cnum..] {\n-                early_lib_embargo_visit_item(\n-                    self.resolver,\n-                    &mut self.extern_doc_reachable,\n-                    cnum.as_def_id(),\n-                    true,\n-                );\n-            }\n-            for &cnum in &crates[start_cnum..] {\n-                let all_trait_impls =\n-                    Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n-                let all_inherent_impls =\n-                    Vec::from_iter(self.resolver.cstore().inherent_impls_in_crate_untracked(cnum));\n-                let all_incoherent_impls = Vec::from_iter(\n-                    self.resolver.cstore().incoherent_impls_in_crate_untracked(cnum),\n-                );\n-\n-                // Querying traits in scope is expensive so we try to prune the impl lists using\n-                // privacy, private traits and impls from other crates are never documented in\n-                // the current crate, and links in their doc comments are not resolved.\n-                for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n-                    if self.is_doc_reachable(trait_def_id)\n-                        && simplified_self_ty\n-                            .and_then(|ty| ty.def())\n-                            .map_or(true, |ty_def_id| self.is_doc_reachable(ty_def_id))\n-                    {\n-                        if self.visited_mods.insert(trait_def_id) {\n-                            self.resolve_doc_links_extern_impl(trait_def_id, false);\n-                        }\n-                        self.resolve_doc_links_extern_impl(impl_def_id, false);\n-                    }\n-                    self.all_trait_impls.push(impl_def_id);\n-                }\n-                for (ty_def_id, impl_def_id) in all_inherent_impls {\n-                    if self.is_doc_reachable(ty_def_id) {\n-                        self.resolve_doc_links_extern_impl(impl_def_id, true);\n-                    }\n-                }\n-                for impl_def_id in all_incoherent_impls {\n-                    self.resolve_doc_links_extern_impl(impl_def_id, true);\n-                }\n-            }\n-\n-            if crates.len() > start_cnum {\n-                start_cnum = crates.len();\n-            } else {\n-                break;\n-            }\n-        }\n-    }\n-\n-    fn resolve_doc_links_extern_impl(&mut self, def_id: DefId, is_inherent: bool) {\n-        self.resolve_doc_links_extern_outer_fixme(def_id, def_id);\n-        let assoc_item_def_ids = Vec::from_iter(\n-            self.resolver.cstore().associated_item_def_ids_untracked(def_id, self.resolver.sess()),\n-        );\n-        for assoc_def_id in assoc_item_def_ids {\n-            if !is_inherent || self.resolver.cstore().visibility_untracked(assoc_def_id).is_public()\n-            {\n-                self.resolve_doc_links_extern_outer_fixme(assoc_def_id, def_id);\n-            }\n-        }\n-    }\n-\n-    // FIXME: replace all uses with `resolve_doc_links_extern_outer` to actually resolve links, not\n-    // just add traits in scope. This may be expensive and require benchmarking and optimization.\n-    fn resolve_doc_links_extern_outer_fixme(&mut self, def_id: DefId, scope_id: DefId) {\n-        if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n-            return;\n-        }\n-        if let Some(parent_id) = self.resolver.opt_parent(scope_id) {\n-            self.add_traits_in_scope(parent_id);\n-        }\n-    }\n-\n-    fn resolve_doc_links_extern_outer(&mut self, def_id: DefId, scope_id: DefId) {\n-        if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n-            return;\n-        }\n-        let attrs = Vec::from_iter(\n-            self.resolver.cstore().item_attrs_untracked(def_id, self.resolver.sess()),\n-        );\n-        let parent_scope = ParentScope::module(\n-            self.resolver.get_nearest_non_block_module(\n-                self.resolver.opt_parent(scope_id).unwrap_or(scope_id),\n-            ),\n-            self.resolver,\n-        );\n-        self.resolve_doc_links(doc_attrs(attrs.iter()), parent_scope);\n-    }\n-\n-    fn resolve_doc_links_extern_inner(&mut self, def_id: DefId) {\n-        if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n-            return;\n-        }\n-        let attrs = Vec::from_iter(\n-            self.resolver.cstore().item_attrs_untracked(def_id, self.resolver.sess()),\n-        );\n-        let parent_scope = ParentScope::module(self.resolver.expect_module(def_id), self.resolver);\n-        self.resolve_doc_links(doc_attrs(attrs.iter()), parent_scope);\n-    }\n-\n-    fn resolve_doc_links_local(&mut self, attrs: &[ast::Attribute]) {\n-        if !attrs.iter().any(|attr| attr.may_have_doc_links()) {\n-            return;\n-        }\n-        self.resolve_doc_links(doc_attrs(attrs.iter()), self.parent_scope);\n-    }\n-\n-    fn resolve_and_cache(\n-        &mut self,\n-        path_str: &str,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'ra>,\n-    ) -> bool {\n-        // FIXME: This caching may be incorrect in case of multiple `macro_rules`\n-        // items with the same name in the same module.\n-        self.doc_link_resolutions\n-            .entry((Symbol::intern(path_str), ns, parent_scope.module.def_id()))\n-            .or_insert_with_key(|(path, ns, _)| {\n-                self.resolver.resolve_rustdoc_path(path.as_str(), *ns, *parent_scope)\n-            })\n-            .is_some()\n-    }\n-\n-    fn resolve_doc_links(&mut self, attrs: Attributes, parent_scope: ParentScope<'ra>) {\n-        let mut need_traits_in_scope = false;\n-        for (doc_module, doc) in attrs.prepare_to_doc_link_resolution() {\n-            assert_eq!(doc_module, None);\n-            let mut tmp_links = mem::take(&mut self.markdown_links);\n-            let links =\n-                tmp_links.entry(doc).or_insert_with_key(|doc| preprocessed_markdown_links(doc));\n-            for PreprocessedMarkdownLink(pp_link, _) in links {\n-                if let Ok(pinfo) = pp_link {\n-                    // The logic here is a conservative approximation for path resolution in\n-                    // `resolve_with_disambiguator`.\n-                    if let Some(ns) = pinfo.disambiguator.map(Disambiguator::ns) {\n-                        if self.resolve_and_cache(&pinfo.path_str, ns, &parent_scope) {\n-                            continue;\n-                        }\n-                    }\n-\n-                    // Resolve all namespaces due to no disambiguator or for diagnostics.\n-                    let mut any_resolved = false;\n-                    let mut need_assoc = false;\n-                    for ns in [TypeNS, ValueNS, MacroNS] {\n-                        if self.resolve_and_cache(&pinfo.path_str, ns, &parent_scope) {\n-                            any_resolved = true;\n-                        } else if ns != MacroNS {\n-                            need_assoc = true;\n-                        }\n-                    }\n-\n-                    // Resolve all prefixes for type-relative resolution or for diagnostics.\n-                    if need_assoc || !any_resolved {\n-                        let mut path = &pinfo.path_str[..];\n-                        while let Some(idx) = path.rfind(\"::\") {\n-                            path = &path[..idx];\n-                            need_traits_in_scope = true;\n-                            for ns in [TypeNS, ValueNS, MacroNS] {\n-                                self.resolve_and_cache(path, ns, &parent_scope);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            self.markdown_links = tmp_links;\n-        }\n-\n-        if need_traits_in_scope {\n-            self.add_traits_in_scope(parent_scope.module.def_id());\n-        }\n-    }\n-\n-    /// When reexports are inlined, they are replaced with item which they refer to, those items\n-    /// may have links in their doc comments, those links are resolved at the item definition site,\n-    /// so we need to know traits in scope at that definition site.\n-    fn process_module_children_or_reexports(&mut self, module_id: DefId) {\n-        if !self.visited_mods.insert(module_id) {\n-            return; // avoid infinite recursion\n-        }\n-\n-        for child in self.resolver.module_children_or_reexports(module_id) {\n-            // This condition should give a superset of `denied` from `fn clean_use_statement`.\n-            if child.vis.is_public()\n-                || self.document_private_items\n-                    && child.vis != Visibility::Restricted(module_id)\n-                    && module_id.is_local()\n-            {\n-                if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n-                    self.local_doc_reachable.insert(def_id);\n-                    let scope_id = match child.res {\n-                        Res::Def(\n-                            DefKind::Variant\n-                            | DefKind::AssocTy\n-                            | DefKind::AssocFn\n-                            | DefKind::AssocConst,\n-                            ..,\n-                        ) => self.resolver.parent(def_id),\n-                        _ => def_id,\n-                    };\n-                    self.resolve_doc_links_extern_outer(def_id, scope_id); // Outer attribute scope\n-                    if let Res::Def(DefKind::Mod, ..) = child.res {\n-                        self.resolve_doc_links_extern_inner(def_id); // Inner attribute scope\n-                    }\n-                    if let Res::Def(DefKind::Mod | DefKind::Enum | DefKind::Trait, ..) = child.res {\n-                        self.process_module_children_or_reexports(def_id);\n-                    }\n-                    if let Res::Def(DefKind::Struct | DefKind::Union | DefKind::Variant, _) =\n-                        child.res\n-                    {\n-                        let field_def_ids = Vec::from_iter(\n-                            self.resolver\n-                                .cstore()\n-                                .associated_item_def_ids_untracked(def_id, self.resolver.sess()),\n-                        );\n-                        for field_def_id in field_def_ids {\n-                            self.resolve_doc_links_extern_outer(field_def_id, scope_id);\n-                        }\n-                    }\n-                }\n+        for cnum in self.resolver.cstore().crates_untracked() {\n+            early_lib_embargo_visit_item(\n+                self.resolver,\n+                &mut self.extern_doc_reachable,\n+                cnum.as_def_id(),\n+                true,\n+            );\n+            for (_, impl_def_id, _) in self.resolver.cstore().trait_impls_in_crate_untracked(cnum) {\n+                self.all_trait_impls.push(impl_def_id);\n             }\n         }\n     }\n }\n \n impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        self.resolve_doc_links_local(&item.attrs); // Outer attribute scope\n-        if let ItemKind::Mod(..) = item.kind {\n-            let module_def_id = self.resolver.local_def_id(item.id).to_def_id();\n-            let module = self.resolver.expect_module(module_def_id);\n-            let old_module = mem::replace(&mut self.parent_scope.module, module);\n-            let old_macro_rules = self.parent_scope.macro_rules;\n-            self.resolve_doc_links_local(&item.attrs); // Inner attribute scope\n-            self.process_module_children_or_reexports(module_def_id);\n-            visit::walk_item(self, item);\n-            if item\n-                .attrs\n-                .iter()\n-                .all(|attr| !attr.has_name(sym::macro_use) && !attr.has_name(sym::macro_escape))\n-            {\n-                self.parent_scope.macro_rules = old_macro_rules;\n+        match &item.kind {\n+            ItemKind::Impl(impl_) if impl_.of_trait.is_some() => {\n+                self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n             }\n-            self.parent_scope.module = old_module;\n-        } else {\n-            match &item.kind {\n-                ItemKind::Impl(box ast::Impl { of_trait: Some(trait_ref), .. }) => {\n-                    if let Some(partial_res) = self.resolver.get_partial_res(trait_ref.ref_id)\n-                        && let Some(res) = partial_res.full_res()\n-                        && let Some(trait_def_id) = res.opt_def_id()\n-                        && !trait_def_id.is_local()\n-                        && self.visited_mods.insert(trait_def_id) {\n-                        self.resolve_doc_links_extern_impl(trait_def_id, false);\n-                    }\n-                    self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n-                }\n-                ItemKind::MacroDef(macro_def) if macro_def.macro_rules => {\n-                    let (macro_rules_scope, res) =\n-                        self.resolver.macro_rules_scope(self.resolver.local_def_id(item.id));\n-                    self.parent_scope.macro_rules = macro_rules_scope;\n-                    self.all_macro_rules.insert(item.ident.name, res);\n-                }\n-                _ => {}\n+            ItemKind::MacroDef(macro_def) if macro_def.macro_rules => {\n+                let (_, res) = self.resolver.macro_rules_scope(self.resolver.local_def_id(item.id));\n+                self.all_macro_rules.insert(item.ident.name, res);\n             }\n-            visit::walk_item(self, item);\n+            _ => {}\n         }\n+        visit::walk_item(self, item);\n     }\n-\n-    fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n-        self.resolve_doc_links_local(&item.attrs);\n-        visit::walk_assoc_item(self, item, ctxt)\n-    }\n-\n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.resolve_doc_links_local(&item.attrs);\n-        visit::walk_foreign_item(self, item)\n-    }\n-\n-    fn visit_variant(&mut self, v: &ast::Variant) {\n-        self.resolve_doc_links_local(&v.attrs);\n-        visit::walk_variant(self, v)\n-    }\n-\n-    fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.resolve_doc_links_local(&field.attrs);\n-        visit::walk_field_def(self, field)\n-    }\n-\n-    fn visit_block(&mut self, block: &ast::Block) {\n-        let old_macro_rules = self.parent_scope.macro_rules;\n-        visit::walk_block(self, block);\n-        self.parent_scope.macro_rules = old_macro_rules;\n-    }\n-\n-    // NOTE: if doc-comments are ever allowed on other nodes (e.g. function parameters),\n-    // then this will have to implement other visitor methods too.\n }"}, {"sha": "4b1ff68df502fad3c2ffa0c9f9f0d454052ea12f", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -2,11 +2,12 @@\n //! process.\n \n use rustc_middle::ty::TyCtxt;\n+use rustc_resolve::rustdoc::DocFragmentKind;\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use std::ops::Range;\n \n use self::Condition::*;\n-use crate::clean::{self, DocFragmentKind};\n+use crate::clean;\n use crate::core::DocContext;\n \n mod stripper;"}, {"sha": "c4b994af13bfe208506a3daa2a587834e552e223", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62b82aef4b6aa667161c664fc3ae738c2fc6b9f/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=b62b82aef4b6aa667161c664fc3ae738c2fc6b9f", "patch": "@@ -178,6 +178,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"ppv-lite86\",\n     \"proc-macro-hack\",\n     \"proc-macro2\",\n+    \"pulldown-cmark\",\n     \"psm\",\n     \"punycode\",\n     \"quote\",\n@@ -246,6 +247,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"unic-langid-macros\",\n     \"unic-langid-macros-impl\",\n     \"unic-ucd-version\",\n+    \"unicase\",\n     \"unicode-ident\",\n     \"unicode-normalization\",\n     \"unicode-script\","}]}