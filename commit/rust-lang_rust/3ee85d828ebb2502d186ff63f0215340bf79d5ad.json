{"sha": "3ee85d828ebb2502d186ff63f0215340bf79d5ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZTg1ZDgyOGViYjI1MDJkMTg2ZmY2M2YwMjE1MzQwYmY3OWQ1YWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-02T18:28:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-08T20:51:38Z"}, "message": "Kill dead code", "tree": {"sha": "900724dbacbe63c48c75c02269990cac2d988016", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900724dbacbe63c48c75c02269990cac2d988016"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ee85d828ebb2502d186ff63f0215340bf79d5ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee85d828ebb2502d186ff63f0215340bf79d5ad", "html_url": "https://github.com/rust-lang/rust/commit/3ee85d828ebb2502d186ff63f0215340bf79d5ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ee85d828ebb2502d186ff63f0215340bf79d5ad/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87edbea9da1d7dfd7e8c68e15f846f08d5f3a8c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/87edbea9da1d7dfd7e8c68e15f846f08d5f3a8c0", "html_url": "https://github.com/rust-lang/rust/commit/87edbea9da1d7dfd7e8c68e15f846f08d5f3a8c0"}], "stats": {"total": 279, "additions": 0, "deletions": 279}, "files": [{"sha": "16860e43f08fbf3f00cd51fe091310f5d907f728", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 279, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/3ee85d828ebb2502d186ff63f0215340bf79d5ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee85d828ebb2502d186ff63f0215340bf79d5ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3ee85d828ebb2502d186ff63f0215340bf79d5ad", "patch": "@@ -412,285 +412,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // METHOD MATCHING\n-    //\n-    // Method matching is a variation on the normal select/evaluation\n-    // situation.  In this scenario, rather than having a full trait\n-    // reference to select from, we start with an expression like\n-    // `receiver.method(...)`. This means that we have `rcvr_ty`, the\n-    // type of the receiver, and we have a possible trait that\n-    // supplies `method`. We must determine whether the receiver is\n-    // applicable, taking into account the transformed self type\n-    // declared on `method`. We also must consider the possibility\n-    // that `receiver` can be *coerced* into a suitable type (for\n-    // example, a receiver type like `&(Any+Send)` might be coerced\n-    // into a receiver like `&Any` to allow for method dispatch).  See\n-    // the body of `evaluate_method_obligation()` for more details on\n-    // the algorithm.\n-\n-    /// Determine whether a trait-method is applicable to a receiver of\n-    /// type `rcvr_ty`. *Does not affect the inference state.*\n-    ///\n-    /// - `rcvr_ty` -- type of the receiver\n-    /// - `xform_self_ty` -- transformed self type declared on the method, with `Self`\n-    ///   to a fresh type variable\n-    /// - `obligation` -- a reference to the trait where the method is declared, with\n-    ///   the input types on the trait replaced with fresh type variables\n-    pub fn evaluate_method_obligation(&mut self,\n-                                      rcvr_ty: Ty<'tcx>,\n-                                      xform_self_ty: Ty<'tcx>,\n-                                      obligation: &Obligation<'tcx>)\n-                                      -> MethodMatchResult\n-    {\n-        // Here is the situation. We have a trait method declared (say) like so:\n-        //\n-        //     trait TheTrait {\n-        //         fn the_method(self: Rc<Self>, ...) { ... }\n-        //     }\n-        //\n-        // And then we have a call looking (say) like this:\n-        //\n-        //     let x: Rc<Foo> = ...;\n-        //     x.the_method()\n-        //\n-        // Now we want to decide if `TheTrait` is applicable. As a\n-        // human, we can see that `TheTrait` is applicable if there is\n-        // an impl for the type `Foo`. But how does the compiler know\n-        // what impl to look for, given that our receiver has type\n-        // `Rc<Foo>`? We need to take the method's self type into\n-        // account.\n-        //\n-        // On entry to this function, we have the following inputs:\n-        //\n-        // - `rcvr_ty = Rc<Foo>`\n-        // - `xform_self_ty = Rc<$0>`\n-        // - `obligation = $0 as TheTrait`\n-        //\n-        // We do the match in two phases. The first is a *precise\n-        // match*, which means that no coercion is required. This is\n-        // the preferred way to match. It works by first making\n-        // `rcvr_ty` a subtype of `xform_self_ty`. This unifies `$0`\n-        // and `Foo`. We can then evaluate (roughly as normal) the\n-        // trait reference `Foo as TheTrait`.\n-        //\n-        // If this fails, we fallback to a coercive match, described below.\n-\n-        match self.infcx.probe(|| self.match_method_precise(rcvr_ty, xform_self_ty, obligation)) {\n-            Ok(()) => { return MethodMatched(PreciseMethodMatch); }\n-            Err(_) => { }\n-        }\n-\n-        // Coercive matches work slightly differently and cannot\n-        // completely reuse the normal trait matching machinery\n-        // (though they employ many of the same bits and pieces). To\n-        // see how it works, let's continue with our previous example,\n-        // but with the following declarations:\n-        //\n-        // ```\n-        // trait Foo : Bar { .. }\n-        // trait Bar : Baz { ... }\n-        // trait Baz { ... }\n-        // impl TheTrait for Bar {\n-        //     fn the_method(self: Rc<Bar>, ...) { ... }\n-        // }\n-        // ```\n-        //\n-        // Now we see that the receiver type `Rc<Foo>` is actually an\n-        // object type. And in fact the impl we want is an impl on the\n-        // supertrait `Rc<Bar>`.  The precise matching procedure won't\n-        // find it, however, because `Rc<Foo>` is not a subtype of\n-        // `Rc<Bar>` -- it is *coercible* to `Rc<Bar>` (actually, such\n-        // coercions are not yet implemented, but let's leave that\n-        // aside for now).\n-        //\n-        // To handle this case, we employ a different procedure. Recall\n-        // that our initial state is as follows:\n-        //\n-        // - `rcvr_ty = Rc<Foo>`\n-        // - `xform_self_ty = Rc<$0>`\n-        // - `obligation = $0 as TheTrait`\n-        //\n-        // We now go through each impl and instantiate all of its type\n-        // variables, yielding the trait reference that the impl\n-        // provides. In our example, the impl would provide `Bar as\n-        // TheTrait`.  Next we (try to) unify the trait reference that\n-        // the impl provides with the input obligation. This would\n-        // unify `$0` and `Bar`. Now we can see whether the receiver\n-        // type (`Rc<Foo>`) is *coercible to* the transformed self\n-        // type (`Rc<$0> == Rc<Bar>`). In this case, the answer is\n-        // yes, so the impl is considered a candidate.\n-        //\n-        // Note that there is the possibility of ambiguity here, even\n-        // when all types are known. In our example, this might occur\n-        // if there was *also* an impl of `TheTrait` for `Baz`. In\n-        // this case, `Rc<Foo>` would be coercible to both `Rc<Bar>`\n-        // and `Rc<Baz>`. (Note that it is not a *coherence violation*\n-        // to have impls for both `Bar` and `Baz`, despite this\n-        // ambiguity).  In this case, we report an error, listing all\n-        // the applicable impls.  The user can explicitly \"up-coerce\"\n-        // to the type they want.\n-        //\n-        // Note that this coercion step only considers actual impls\n-        // found in the source. This is because all the\n-        // compiler-provided impls (such as those for unboxed\n-        // closures) do not have relevant coercions. This simplifies\n-        // life immensely.\n-\n-        let mut impls =\n-            self.assemble_method_candidates_from_impls(rcvr_ty, xform_self_ty, obligation);\n-\n-        if impls.len() > 1 {\n-            impls.retain(|&c| self.winnow_method_impl(c, rcvr_ty, xform_self_ty, obligation));\n-        }\n-\n-        if impls.len() > 1 {\n-            return MethodAmbiguous(impls);\n-        }\n-\n-        match impls.pop() {\n-            Some(def_id) => MethodMatched(CoerciveMethodMatch(def_id)),\n-            None => MethodDidNotMatch\n-        }\n-    }\n-\n-    /// Given the successful result of a method match, this function \"confirms\" the result, which\n-    /// basically repeats the various matching operations, but outside of any snapshot so that\n-    /// their effects are committed into the inference state.\n-    pub fn confirm_method_match(&mut self,\n-                                rcvr_ty: Ty<'tcx>,\n-                                xform_self_ty: Ty<'tcx>,\n-                                obligation: &Obligation<'tcx>,\n-                                data: MethodMatchedData)\n-    {\n-        let is_ok = match data {\n-            PreciseMethodMatch => {\n-                self.match_method_precise(rcvr_ty, xform_self_ty, obligation).is_ok()\n-            }\n-\n-            CoerciveMethodMatch(impl_def_id) => {\n-                self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation).is_ok()\n-            }\n-        };\n-\n-        if !is_ok {\n-            self.tcx().sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"match not repeatable: {}, {}, {}, {}\",\n-                        rcvr_ty.repr(self.tcx()),\n-                        xform_self_ty.repr(self.tcx()),\n-                        obligation.repr(self.tcx()),\n-                        data)[]);\n-        }\n-    }\n-\n-    /// Implements the *precise method match* procedure described in\n-    /// `evaluate_method_obligation()`.\n-    fn match_method_precise(&mut self,\n-                            rcvr_ty: Ty<'tcx>,\n-                            xform_self_ty: Ty<'tcx>,\n-                            obligation: &Obligation<'tcx>)\n-                            -> Result<(),()>\n-    {\n-        self.infcx.commit_if_ok(|| {\n-            match self.infcx.sub_types(false, infer::RelateSelfType(obligation.cause.span),\n-                                       rcvr_ty, xform_self_ty) {\n-                Ok(()) => { }\n-                Err(_) => { return Err(()); }\n-            }\n-\n-            if self.evaluate_obligation(obligation) {\n-                Ok(())\n-            } else {\n-                Err(())\n-            }\n-        })\n-    }\n-\n-    /// Assembles a list of potentially applicable impls using the *coercive match* procedure\n-    /// described in `evaluate_method_obligation()`.\n-    fn assemble_method_candidates_from_impls(&mut self,\n-                                             rcvr_ty: Ty<'tcx>,\n-                                             xform_self_ty: Ty<'tcx>,\n-                                             obligation: &Obligation<'tcx>)\n-                                             -> Vec<ast::DefId>\n-    {\n-        let mut candidates = Vec::new();\n-\n-        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n-        for &impl_def_id in all_impls.iter() {\n-            self.infcx.probe(|| {\n-                match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n-                    Ok(_) => { candidates.push(impl_def_id); }\n-                    Err(_) => { }\n-                }\n-            });\n-        }\n-\n-        candidates\n-    }\n-\n-    /// Applies the *coercive match* procedure described in `evaluate_method_obligation()` to a\n-    /// particular impl.\n-    fn match_method_coerce(&mut self,\n-                           impl_def_id: ast::DefId,\n-                           rcvr_ty: Ty<'tcx>,\n-                           xform_self_ty: Ty<'tcx>,\n-                           obligation: &Obligation<'tcx>)\n-                           -> Result<Substs<'tcx>, ()>\n-    {\n-        // This is almost always expected to succeed. It\n-        // causes the impl's self-type etc to be unified with\n-        // the type variable that is shared between\n-        // obligation/xform_self_ty. In our example, after\n-        // this is done, the type of `xform_self_ty` would\n-        // change from `Rc<$0>` to `Rc<Foo>` (because $0 is\n-        // unified with `Foo`).\n-        let substs = try!(self.match_impl(impl_def_id, obligation));\n-\n-        // Next, check whether we can coerce. For now we require\n-        // that the coercion be a no-op.\n-        let origin = infer::Misc(obligation.cause.span);\n-        match infer::mk_coercety(self.infcx, true, origin,\n-                                 rcvr_ty, xform_self_ty) {\n-            Ok(None) => { /* Fallthrough */ }\n-            Ok(Some(_)) | Err(_) => { return Err(()); }\n-        }\n-\n-        Ok(substs)\n-    }\n-\n-    /// A version of `winnow_impl` applicable to coerice method matching.  This is basically the\n-    /// same as `winnow_impl` but it uses the method matching procedure and is specific to impls.\n-    fn winnow_method_impl(&mut self,\n-                          impl_def_id: ast::DefId,\n-                          rcvr_ty: Ty<'tcx>,\n-                          xform_self_ty: Ty<'tcx>,\n-                          obligation: &Obligation<'tcx>)\n-                          -> bool\n-    {\n-        debug!(\"winnow_method_impl: impl_def_id={} rcvr_ty={} xform_self_ty={} obligation={}\",\n-               impl_def_id.repr(self.tcx()),\n-               rcvr_ty.repr(self.tcx()),\n-               xform_self_ty.repr(self.tcx()),\n-               obligation.repr(self.tcx()));\n-\n-        self.infcx.probe(|| {\n-            match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n-                Ok(substs) => {\n-                    let vtable_impl = self.vtable_impl(impl_def_id,\n-                                                       substs,\n-                                                       obligation.cause,\n-                                                       obligation.recursion_depth + 1);\n-                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n-                }\n-                Err(()) => {\n-                    false\n-                }\n-            }\n-        })\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n     //"}]}