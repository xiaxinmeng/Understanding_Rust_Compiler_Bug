{"sha": "3f1961d62e166cfe71273175296d9d59222ca81c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMTk2MWQ2MmUxNjZjZmU3MTI3MzE3NTI5NmQ5ZDU5MjIyY2E4MWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-09T01:04:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:49:24Z"}, "message": "extract type-ops into their own submodules", "tree": {"sha": "3673c9fda79c90c2718dbd04c1321445fefd1658", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3673c9fda79c90c2718dbd04c1321445fefd1658"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f1961d62e166cfe71273175296d9d59222ca81c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1961d62e166cfe71273175296d9d59222ca81c", "html_url": "https://github.com/rust-lang/rust/commit/3f1961d62e166cfe71273175296d9d59222ca81c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f1961d62e166cfe71273175296d9d59222ca81c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cb86ed1e360be8a978e6e4c891c01bc1d8deaaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cb86ed1e360be8a978e6e4c891c01bc1d8deaaa", "html_url": "https://github.com/rust-lang/rust/commit/7cb86ed1e360be8a978e6e4c891c01bc1d8deaaa"}], "stats": {"total": 556, "additions": 323, "deletions": 233}, "files": [{"sha": "a127128818e1501a2d713ef75f47fcd268d48d1c", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -18,7 +18,7 @@\n //! contain revealed `impl Trait` values).\n \n use borrow_check::nll::renumber;\n-use borrow_check::nll::type_check::type_op::CustomTypeOp;\n+use borrow_check::nll::type_check::type_op::custom::CustomTypeOp;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;"}, {"sha": "780269930913dc99421cd097f73213d394dd8195", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use borrow_check::nll::region_infer::Cause;\n-use borrow_check::nll::type_check::type_op::{DropckOutlives, TypeOp};\n+use borrow_check::nll::type_check::type_op::TypeOp;\n+use borrow_check::nll::type_check::type_op::outlives::DropckOutlives;\n use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;"}, {"sha": "d7812d86574fd3913af2e2ca8d9f1fae19b70136", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -776,12 +776,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n     ) -> UnitResult<'tcx> {\n         let param_env = self.param_env;\n-        self.fully_perform_op(locations, type_op::Subtype::new(param_env, sub, sup))\n+        self.fully_perform_op(locations, type_op::subtype::Subtype::new(param_env, sub, sup))\n     }\n \n     fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> UnitResult<'tcx> {\n         let param_env = self.param_env;\n-        self.fully_perform_op(locations, type_op::Eq::new(param_env, b, a))\n+        self.fully_perform_op(locations, type_op::eq::Eq::new(param_env, b, a))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -1560,7 +1560,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.at_self(),\n-            type_op::ProvePredicates::new(param_env, predicates),\n+            type_op::predicates::ProvePredicates::new(param_env, predicates),\n         ).unwrap()\n     }\n \n@@ -1598,7 +1598,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n-            type_op::Normalize::new(param_env, value),\n+            type_op::normalize::Normalize::new(param_env, value),\n         ).unwrap()\n     }\n }"}, {"sha": "ce17cab8dcb0967cdee7635b65683bfaf18bec64", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/custom.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fcustom.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::{InferCtxt, InferResult};\n+use rustc::ty::TyCtxt;\n+use std::fmt;\n+\n+crate struct CustomTypeOp<F, G> {\n+    closure: F,\n+    description: G,\n+}\n+\n+impl<F, G> CustomTypeOp<F, G> {\n+    crate fn new<'gcx, 'tcx, R>(closure: F, description: G) -> Self\n+    where\n+        F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n+        G: Fn() -> String,\n+    {\n+        CustomTypeOp {\n+            closure,\n+            description,\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx, F, R, G> super::TypeOp<'gcx, 'tcx> for CustomTypeOp<F, G>\n+where\n+    F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n+    G: Fn() -> String,\n+{\n+    type Output = R;\n+\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        Err(self)\n+    }\n+\n+    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R> {\n+        (self.closure)(infcx)\n+    }\n+}\n+\n+impl<F, G> fmt::Debug for CustomTypeOp<F, G>\n+where\n+    G: Fn() -> String,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", (self.description)())\n+    }\n+}"}, {"sha": "b062eff0733c2e3e94316fb1f958e5007c24c12c", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/eq.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Feq.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::{InferCtxt, InferResult};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::{ParamEnv, Ty, TyCtxt};\n+\n+#[derive(Debug)]\n+crate struct Eq<'tcx> {\n+    param_env: ParamEnv<'tcx>,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Eq<'tcx> {\n+    crate fn new(param_env: ParamEnv<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n+        Self { param_env, a, b }\n+    }\n+}\n+\n+impl<'gcx, 'tcx> super::TypeOp<'gcx, 'tcx> for Eq<'tcx> {\n+    type Output = ();\n+\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        if self.a == self.b {\n+            Ok(())\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n+    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n+        infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .eq(self.a, self.b)\n+    }\n+}"}, {"sha": "448dfd853c1b322733373cfd3b9ad9c9a9778b60", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/mod.rs", "status": "modified", "additions": 13, "deletions": 227, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -11,17 +11,20 @@\n use rustc::infer::canonical::query_result;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::{InferCtxt, InferOk, InferResult};\n-use rustc::traits::query::dropck_outlives::trivial_dropck_outlives;\n-use rustc::traits::query::NoSolution;\n-use rustc::traits::{Normalized, Obligation, ObligationCause, PredicateObligation, TraitEngine};\n+use rustc::traits::{ObligationCause, TraitEngine};\n use rustc::ty::error::TypeError;\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::Kind;\n-use rustc::ty::{ParamEnv, Predicate, Ty, TyCtxt};\n+use rustc::ty::TyCtxt;\n use std::fmt;\n use std::rc::Rc;\n use syntax::codemap::DUMMY_SP;\n \n+crate mod custom;\n+crate mod eq;\n+crate mod normalize;\n+crate mod predicates;\n+crate mod outlives;\n+crate mod subtype;\n+\n crate trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     type Output;\n \n@@ -58,7 +61,10 @@ crate trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     ) -> Result<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>), TypeError<'tcx>> {\n         if cfg!(debug_assertions) {\n-            info!(\"fully_perform_op_and_get_region_constraint_data({:?})\", self);\n+            info!(\n+                \"fully_perform_op_and_get_region_constraint_data({:?})\",\n+                self\n+            );\n         }\n \n         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n@@ -90,223 +96,3 @@ crate trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n         }\n     }\n }\n-\n-crate struct CustomTypeOp<F, G> {\n-    closure: F,\n-    description: G,\n-}\n-\n-impl<F, G> CustomTypeOp<F, G> {\n-    pub(super) fn new<'gcx, 'tcx, R>(closure: F, description: G) -> Self\n-    where\n-        F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n-        G: Fn() -> String,\n-    {\n-        CustomTypeOp {\n-            closure,\n-            description,\n-        }\n-    }\n-}\n-\n-impl<'gcx, 'tcx, F, R, G> TypeOp<'gcx, 'tcx> for CustomTypeOp<F, G>\n-where\n-    F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R>,\n-    G: Fn() -> String,\n-{\n-    type Output = R;\n-\n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        Err(self)\n-    }\n-\n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, R> {\n-        (self.closure)(infcx)\n-    }\n-}\n-\n-impl<F, G> fmt::Debug for CustomTypeOp<F, G>\n-where\n-    G: Fn() -> String,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", (self.description)())\n-    }\n-}\n-\n-#[derive(Debug)]\n-crate struct Subtype<'tcx> {\n-    param_env: ParamEnv<'tcx>,\n-    sub: Ty<'tcx>,\n-    sup: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Subtype<'tcx> {\n-    crate fn new(param_env: ParamEnv<'tcx>, sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n-        Self {\n-            param_env,\n-            sub,\n-            sup,\n-        }\n-    }\n-}\n-\n-impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n-    type Output = ();\n-\n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        if self.sub == self.sup {\n-            Ok(())\n-        } else {\n-            Err(self)\n-        }\n-    }\n-\n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n-        infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .sup(self.sup, self.sub)\n-    }\n-}\n-\n-#[derive(Debug)]\n-crate struct Eq<'tcx> {\n-    param_env: ParamEnv<'tcx>,\n-    a: Ty<'tcx>,\n-    b: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Eq<'tcx> {\n-    crate fn new(param_env: ParamEnv<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n-        Self { param_env, a, b }\n-    }\n-}\n-\n-impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for Eq<'tcx> {\n-    type Output = ();\n-\n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        if self.a == self.b {\n-            Ok(())\n-        } else {\n-            Err(self)\n-        }\n-    }\n-\n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n-        infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .eq(self.a, self.b)\n-    }\n-}\n-\n-#[derive(Debug)]\n-crate struct ProvePredicates<'tcx> {\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-}\n-\n-impl<'tcx> ProvePredicates<'tcx> {\n-    crate fn new(\n-        param_env: ParamEnv<'tcx>,\n-        predicates: impl IntoIterator<Item = Predicate<'tcx>>,\n-    ) -> Self {\n-        ProvePredicates {\n-            obligations: predicates\n-                .into_iter()\n-                .map(|p| Obligation::new(ObligationCause::dummy(), param_env, p))\n-                .collect(),\n-        }\n-    }\n-}\n-\n-impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for ProvePredicates<'tcx> {\n-    type Output = ();\n-\n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        if self.obligations.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(self)\n-        }\n-    }\n-\n-    fn perform(self, _infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n-        Ok(InferOk {\n-            value: (),\n-            obligations: self.obligations,\n-        })\n-    }\n-}\n-\n-#[derive(Debug)]\n-crate struct Normalize<'tcx, T> {\n-    param_env: ParamEnv<'tcx>,\n-    value: T,\n-}\n-\n-impl<'tcx, T> Normalize<'tcx, T>\n-where\n-    T: fmt::Debug + TypeFoldable<'tcx>,\n-{\n-    crate fn new(param_env: ParamEnv<'tcx>, value: T) -> Self {\n-        Self { param_env, value }\n-    }\n-}\n-\n-impl<'gcx, 'tcx, T> TypeOp<'gcx, 'tcx> for Normalize<'tcx, T>\n-where\n-    T: fmt::Debug + TypeFoldable<'tcx>,\n-{\n-    type Output = T;\n-\n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        if !self.value.has_projections() {\n-            Ok(self.value)\n-        } else {\n-            Err(self)\n-        }\n-    }\n-\n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n-        let Normalized { value, obligations } = infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .normalize(&self.value)\n-            .unwrap_or_else(|NoSolution| {\n-                bug!(\"normalization of `{:?}` failed\", self.value,);\n-            });\n-        Ok(InferOk { value, obligations })\n-    }\n-}\n-\n-#[derive(Debug)]\n-crate struct DropckOutlives<'tcx> {\n-    param_env: ParamEnv<'tcx>,\n-    dropped_ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> DropckOutlives<'tcx> {\n-    crate fn new(param_env: ParamEnv<'tcx>, dropped_ty: Ty<'tcx>) -> Self {\n-        DropckOutlives {\n-            param_env,\n-            dropped_ty,\n-        }\n-    }\n-}\n-\n-impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for DropckOutlives<'tcx> {\n-    type Output = Vec<Kind<'tcx>>;\n-\n-    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        if trivial_dropck_outlives(tcx, self.dropped_ty) {\n-            Ok(vec![])\n-        } else {\n-            Err(self)\n-        }\n-    }\n-\n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n-        Ok(infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .dropck_outlives(self.dropped_ty))\n-    }\n-}"}, {"sha": "35242a5bc292aec0a97b8fe6aa1df1359985a86a", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/normalize.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fnormalize.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::{InferCtxt, InferOk, InferResult};\n+use rustc::traits::query::NoSolution;\n+use rustc::traits::{Normalized, ObligationCause};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{ParamEnv, TyCtxt};\n+use std::fmt;\n+\n+#[derive(Debug)]\n+crate struct Normalize<'tcx, T> {\n+    param_env: ParamEnv<'tcx>,\n+    value: T,\n+}\n+\n+impl<'tcx, T> Normalize<'tcx, T>\n+where\n+    T: fmt::Debug + TypeFoldable<'tcx>,\n+{\n+    crate fn new(param_env: ParamEnv<'tcx>, value: T) -> Self {\n+        Self { param_env, value }\n+    }\n+}\n+\n+impl<'gcx, 'tcx, T> super::TypeOp<'gcx, 'tcx> for Normalize<'tcx, T>\n+where\n+    T: fmt::Debug + TypeFoldable<'tcx>,\n+{\n+    type Output = T;\n+\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        if !self.value.has_projections() {\n+            Ok(self.value)\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n+    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n+        let Normalized { value, obligations } = infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .normalize(&self.value)\n+            .unwrap_or_else(|NoSolution| {\n+                bug!(\"normalization of `{:?}` failed\", self.value,);\n+            });\n+        Ok(InferOk { value, obligations })\n+    }\n+}"}, {"sha": "655ede4793abea6a3aa259072bb1658603d9a082", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/outlives.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Foutlives.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::{InferCtxt, InferResult};\n+use rustc::traits::query::dropck_outlives::trivial_dropck_outlives;\n+use rustc::traits::ObligationCause;\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{ParamEnv, Ty, TyCtxt};\n+\n+#[derive(Debug)]\n+crate struct DropckOutlives<'tcx> {\n+    param_env: ParamEnv<'tcx>,\n+    dropped_ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> DropckOutlives<'tcx> {\n+    crate fn new(param_env: ParamEnv<'tcx>, dropped_ty: Ty<'tcx>) -> Self {\n+        DropckOutlives {\n+            param_env,\n+            dropped_ty,\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx> super::TypeOp<'gcx, 'tcx> for DropckOutlives<'tcx> {\n+    type Output = Vec<Kind<'tcx>>;\n+\n+    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        if trivial_dropck_outlives(tcx, self.dropped_ty) {\n+            Ok(vec![])\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n+    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n+        Ok(infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .dropck_outlives(self.dropped_ty))\n+    }\n+}"}, {"sha": "18128d2234e1ccbadf79c10fab4fdecfc545fbca", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/predicates.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fpredicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fpredicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fpredicates.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::{InferCtxt, InferOk, InferResult};\n+use rustc::traits::{Obligation, ObligationCause, PredicateObligation};\n+use rustc::ty::{ParamEnv, Predicate, TyCtxt};\n+\n+#[derive(Debug)]\n+crate struct ProvePredicates<'tcx> {\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'tcx> ProvePredicates<'tcx> {\n+    crate fn new(\n+        param_env: ParamEnv<'tcx>,\n+        predicates: impl IntoIterator<Item = Predicate<'tcx>>,\n+    ) -> Self {\n+        ProvePredicates {\n+            obligations: predicates\n+                .into_iter()\n+                .map(|p| Obligation::new(ObligationCause::dummy(), param_env, p))\n+                .collect(),\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx> super::TypeOp<'gcx, 'tcx> for ProvePredicates<'tcx> {\n+    type Output = ();\n+\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        if self.obligations.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n+    fn perform(self, _infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n+        Ok(InferOk {\n+            value: (),\n+            obligations: self.obligations,\n+        })\n+    }\n+}"}, {"sha": "83cc3c7d09b3a5f98b86862578f009f62be10412", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/subtype.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f1961d62e166cfe71273175296d9d59222ca81c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fsubtype.rs?ref=3f1961d62e166cfe71273175296d9d59222ca81c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::{InferCtxt, InferResult};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::{ParamEnv, Ty, TyCtxt};\n+\n+#[derive(Debug)]\n+crate struct Subtype<'tcx> {\n+    param_env: ParamEnv<'tcx>,\n+    sub: Ty<'tcx>,\n+    sup: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Subtype<'tcx> {\n+    crate fn new(param_env: ParamEnv<'tcx>, sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n+        Self {\n+            param_env,\n+            sub,\n+            sup,\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx> super::TypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n+    type Output = ();\n+\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        if self.sub == self.sup {\n+            Ok(())\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n+    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n+        infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sup(self.sup, self.sub)\n+    }\n+}"}]}