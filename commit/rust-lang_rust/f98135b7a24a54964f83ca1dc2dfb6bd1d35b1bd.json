{"sha": "f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ODEzNWI3YTI0YTU0OTY0ZjgzY2ExZGMyZGZiNmJkMWQzNWIxYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-04T08:34:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-04T08:34:12Z"}, "message": "Auto merge of #82347 - the8472:parallelize-tidy, r=Mark-Simulacrum\n\nParallelize tidy\n\nSplit off from #81833\n\nWhile that PR brings wall time of `x.py test tidy` down to 0m2.847s adding this one on top should bring it down to 0m1.673s.\n\nr? `@Mark-Simulacrum`\n\nPrevious concerns can be found at https://github.com/rust-lang/rust/pull/81833#issuecomment-782754685 and https://github.com/rust-lang/rust/pull/81833#discussion_r575194633", "tree": {"sha": "f7cb2891d878d28e11dc815eff0f1f033d3ff268", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7cb2891d878d28e11dc815eff0f1f033d3ff268"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "html_url": "https://github.com/rust-lang/rust/commit/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88e7862dd05ff939cd498eb0ad2f3383bad33171", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e7862dd05ff939cd498eb0ad2f3383bad33171", "html_url": "https://github.com/rust-lang/rust/commit/88e7862dd05ff939cd498eb0ad2f3383bad33171"}, {"sha": "0513ba4d65b953ab637fbafd979a9bd002b93e5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0513ba4d65b953ab637fbafd979a9bd002b93e5c", "html_url": "https://github.com/rust-lang/rust/commit/0513ba4d65b953ab637fbafd979a9bd002b93e5c"}], "stats": {"total": 293, "additions": 189, "deletions": 104}, "files": [{"sha": "2d00f31e3159a9fde4aea8fa0e0dfbe77d315672", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "patch": "@@ -5308,6 +5308,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.11.1\",\n+ \"crossbeam-utils 0.8.0\",\n  \"lazy_static\",\n  \"regex\",\n  \"walkdir\","}, {"sha": "117201ab3cd860bd40364611824ab944f5a2a8ba", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "patch": "@@ -854,6 +854,7 @@ impl Step for Tidy {\n         cmd.arg(&builder.src);\n         cmd.arg(&builder.initial_cargo);\n         cmd.arg(&builder.out);\n+        cmd.arg(builder.jobs().to_string());\n         if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }"}, {"sha": "58c32993cb6ef24b1a08ac25c9a28acb32d925ba", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "patch": "@@ -10,6 +10,7 @@ cargo_metadata = \"0.11\"\n regex = \"1\"\n lazy_static = \"1\"\n walkdir = \"2\"\n+crossbeam-utils = \"0.8.0\"\n \n [[bin]]\n name = \"rust-tidy\""}, {"sha": "1d5ec5c31c67ff326e35a48c86be0a5e335b5930", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 102, "deletions": 67, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "patch": "@@ -5,91 +5,126 @@\n //! huge amount of bloat to the Git history, so it's good to just ensure we\n //! don't do that again.\n \n-use std::path::Path;\n+pub use os_impl::*;\n \n // All files are executable on Windows, so just check on Unix.\n #[cfg(windows)]\n-pub fn check(_path: &Path, _output: &Path, _bad: &mut bool) {}\n+mod os_impl {\n+    use std::path::Path;\n+\n+    pub fn check_filesystem_support(_sources: &[&Path], _output: &Path) -> bool {\n+        return false;\n+    }\n+\n+    pub fn check(_path: &Path, _bad: &mut bool) {}\n+}\n \n #[cfg(unix)]\n-pub fn check(path: &Path, output: &Path, bad: &mut bool) {\n+mod os_impl {\n     use std::fs;\n     use std::os::unix::prelude::*;\n+    use std::path::Path;\n     use std::process::{Command, Stdio};\n \n+    enum FilesystemSupport {\n+        Supported,\n+        Unsupported,\n+        ReadOnlyFs,\n+    }\n+\n+    use FilesystemSupport::*;\n+\n     fn is_executable(path: &Path) -> std::io::Result<bool> {\n         Ok(path.metadata()?.mode() & 0o111 != 0)\n     }\n \n-    // We want to avoid false positives on filesystems that do not support the\n-    // executable bit. This occurs on some versions of Window's linux subsystem,\n-    // for example.\n-    //\n-    // We try to create the temporary file first in the src directory, which is\n-    // the preferred location as it's most likely to be on the same filesystem,\n-    // and then in the output (`build`) directory if that fails. Sometimes we\n-    // see the source directory mounted as read-only which means we can't\n-    // readily create a file there to test.\n-    //\n-    // See #36706 and #74753 for context.\n-    let mut temp_path = path.join(\"tidy-test-file\");\n-    match fs::File::create(&temp_path).or_else(|_| {\n-        temp_path = output.join(\"tidy-test-file\");\n-        fs::File::create(&temp_path)\n-    }) {\n-        Ok(file) => {\n-            let exec = is_executable(&temp_path).unwrap_or(false);\n-            std::mem::drop(file);\n-            std::fs::remove_file(&temp_path).expect(\"Deleted temp file\");\n-            if exec {\n-                // If the file is executable, then we assume that this\n-                // filesystem does not track executability, so skip this check.\n-                return;\n-            }\n+    pub fn check_filesystem_support(sources: &[&Path], output: &Path) -> bool {\n+        // We want to avoid false positives on filesystems that do not support the\n+        // executable bit. This occurs on some versions of Window's linux subsystem,\n+        // for example.\n+        //\n+        // We try to create the temporary file first in the src directory, which is\n+        // the preferred location as it's most likely to be on the same filesystem,\n+        // and then in the output (`build`) directory if that fails. Sometimes we\n+        // see the source directory mounted as read-only which means we can't\n+        // readily create a file there to test.\n+        //\n+        // See #36706 and #74753 for context.\n+\n+        fn check_dir(dir: &Path) -> FilesystemSupport {\n+            let path = dir.join(\"tidy-test-file\");\n+            match fs::File::create(&path) {\n+                Ok(file) => {\n+                    let exec = is_executable(&path).unwrap_or(false);\n+                    std::mem::drop(file);\n+                    std::fs::remove_file(&path).expect(\"Deleted temp file\");\n+                    // If the file is executable, then we assume that this\n+                    // filesystem does not track executability, so skip this check.\n+                    return if exec { Unsupported } else { Supported };\n+                }\n+                Err(e) => {\n+                    // If the directory is read-only or we otherwise don't have rights,\n+                    // just don't run this check.\n+                    //\n+                    // 30 is the \"Read-only filesystem\" code at least in one CI\n+                    //    environment.\n+                    if e.raw_os_error() == Some(30) {\n+                        eprintln!(\"tidy: Skipping binary file check, read-only filesystem\");\n+                        return ReadOnlyFs;\n+                    }\n+\n+                    panic!(\"unable to create temporary file `{:?}`: {:?}\", path, e);\n+                }\n+            };\n         }\n-        Err(e) => {\n-            // If the directory is read-only or we otherwise don't have rights,\n-            // just don't run this check.\n-            //\n-            // 30 is the \"Read-only filesystem\" code at least in one CI\n-            //    environment.\n-            if e.raw_os_error() == Some(30) {\n-                eprintln!(\"tidy: Skipping binary file check, read-only filesystem\");\n-                return;\n-            }\n \n-            panic!(\"unable to create temporary file `{:?}`: {:?}\", temp_path, e);\n+        for &source_dir in sources {\n+            match check_dir(source_dir) {\n+                Unsupported => return false,\n+                ReadOnlyFs => {\n+                    return match check_dir(output) {\n+                        Supported => true,\n+                        _ => false,\n+                    };\n+                }\n+                _ => {}\n+            }\n         }\n+\n+        return true;\n     }\n \n-    super::walk_no_read(\n-        path,\n-        &mut |path| super::filter_dirs(path) || path.ends_with(\"src/etc\"),\n-        &mut |entry| {\n-            let file = entry.path();\n-            let filename = file.file_name().unwrap().to_string_lossy();\n-            let extensions = [\".py\", \".sh\"];\n-            if extensions.iter().any(|e| filename.ends_with(e)) {\n-                return;\n-            }\n+    #[cfg(unix)]\n+    pub fn check(path: &Path, bad: &mut bool) {\n+        crate::walk_no_read(\n+            path,\n+            &mut |path| crate::filter_dirs(path) || path.ends_with(\"src/etc\"),\n+            &mut |entry| {\n+                let file = entry.path();\n+                let filename = file.file_name().unwrap().to_string_lossy();\n+                let extensions = [\".py\", \".sh\"];\n+                if extensions.iter().any(|e| filename.ends_with(e)) {\n+                    return;\n+                }\n \n-            if t!(is_executable(&file), file) {\n-                let rel_path = file.strip_prefix(path).unwrap();\n-                let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n-                let output = Command::new(\"git\")\n-                    .arg(\"ls-files\")\n-                    .arg(&git_friendly_path)\n-                    .current_dir(path)\n-                    .stderr(Stdio::null())\n-                    .output()\n-                    .unwrap_or_else(|e| {\n-                        panic!(\"could not run git ls-files: {}\", e);\n-                    });\n-                let path_bytes = rel_path.as_os_str().as_bytes();\n-                if output.status.success() && output.stdout.starts_with(path_bytes) {\n-                    tidy_error!(bad, \"binary checked into source: {}\", file.display());\n+                if t!(is_executable(&file), file) {\n+                    let rel_path = file.strip_prefix(path).unwrap();\n+                    let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n+                    let output = Command::new(\"git\")\n+                        .arg(\"ls-files\")\n+                        .arg(&git_friendly_path)\n+                        .current_dir(path)\n+                        .stderr(Stdio::null())\n+                        .output()\n+                        .unwrap_or_else(|e| {\n+                            panic!(\"could not run git ls-files: {}\", e);\n+                        });\n+                    let path_bytes = rel_path.as_os_str().as_bytes();\n+                    if output.status.success() && output.stdout.starts_with(path_bytes) {\n+                        tidy_error!(bad, \"binary checked into source: {}\", file.display());\n+                    }\n                 }\n-            }\n-        },\n-    )\n+            },\n+        )\n+    }\n }"}, {"sha": "f190a9e57cecb39084dd0990d16bf1b470394b1c", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 84, "deletions": 37, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=f98135b7a24a54964f83ca1dc2dfb6bd1d35b1bd", "patch": "@@ -6,61 +6,108 @@\n \n use tidy::*;\n \n+use crossbeam_utils::thread::{scope, ScopedJoinHandle};\n+use std::collections::VecDeque;\n use std::env;\n+use std::num::NonZeroUsize;\n use std::path::PathBuf;\n use std::process;\n+use std::str::FromStr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n \n fn main() {\n     let root_path: PathBuf = env::args_os().nth(1).expect(\"need path to root of repo\").into();\n     let cargo: PathBuf = env::args_os().nth(2).expect(\"need path to cargo\").into();\n     let output_directory: PathBuf =\n         env::args_os().nth(3).expect(\"need path to output directory\").into();\n+    let concurrency: NonZeroUsize =\n+        FromStr::from_str(&env::args().nth(4).expect(\"need concurrency\"))\n+            .expect(\"concurrency must be a number\");\n \n     let src_path = root_path.join(\"src\");\n     let library_path = root_path.join(\"library\");\n     let compiler_path = root_path.join(\"compiler\");\n \n     let args: Vec<String> = env::args().skip(1).collect();\n \n-    let mut bad = false;\n     let verbose = args.iter().any(|s| *s == \"--verbose\");\n \n-    // Checks over tests.\n-    debug_artifacts::check(&src_path, &mut bad);\n-    ui_tests::check(&src_path, &mut bad);\n-\n-    // Checks that only make sense for the compiler.\n-    errors::check(&compiler_path, &mut bad);\n-    error_codes_check::check(&src_path, &mut bad);\n-\n-    // Checks that only make sense for the std libs.\n-    pal::check(&library_path, &mut bad);\n-\n-    // Checks that need to be done for both the compiler and std libraries.\n-    unit_tests::check(&src_path, &mut bad);\n-    unit_tests::check(&compiler_path, &mut bad);\n-    unit_tests::check(&library_path, &mut bad);\n-\n-    bins::check(&src_path, &output_directory, &mut bad);\n-    bins::check(&compiler_path, &output_directory, &mut bad);\n-    bins::check(&library_path, &output_directory, &mut bad);\n-\n-    style::check(&src_path, &mut bad);\n-    style::check(&compiler_path, &mut bad);\n-    style::check(&library_path, &mut bad);\n-\n-    edition::check(&src_path, &mut bad);\n-    edition::check(&compiler_path, &mut bad);\n-    edition::check(&library_path, &mut bad);\n-\n-    let collected = features::check(&src_path, &compiler_path, &library_path, &mut bad, verbose);\n-    unstable_book::check(&src_path, collected, &mut bad);\n-\n-    // Checks that are done on the cargo workspace.\n-    deps::check(&root_path, &cargo, &mut bad);\n-    extdeps::check(&root_path, &mut bad);\n-\n-    if bad {\n+    let bad = std::sync::Arc::new(AtomicBool::new(false));\n+\n+    scope(|s| {\n+        let mut handles: VecDeque<ScopedJoinHandle<'_, ()>> =\n+            VecDeque::with_capacity(concurrency.get());\n+\n+        macro_rules! check {\n+            ($p:ident $(, $args:expr)* ) => {\n+                while handles.len() >= concurrency.get() {\n+                    handles.pop_front().unwrap().join().unwrap();\n+                }\n+\n+                let handle = s.spawn(|_| {\n+                    let mut flag = false;\n+                    $p::check($($args),* , &mut flag);\n+                    if (flag) {\n+                        bad.store(true, Ordering::Relaxed);\n+                    }\n+                });\n+                handles.push_back(handle);\n+            }\n+        }\n+\n+        // Checks that are done on the cargo workspace.\n+        check!(deps, &root_path, &cargo);\n+        check!(extdeps, &root_path);\n+\n+        // Checks over tests.\n+        check!(debug_artifacts, &src_path);\n+        check!(ui_tests, &src_path);\n+\n+        // Checks that only make sense for the compiler.\n+        check!(errors, &compiler_path);\n+        check!(error_codes_check, &src_path);\n+\n+        // Checks that only make sense for the std libs.\n+        check!(pal, &library_path);\n+\n+        // Checks that need to be done for both the compiler and std libraries.\n+        check!(unit_tests, &src_path);\n+        check!(unit_tests, &compiler_path);\n+        check!(unit_tests, &library_path);\n+\n+        if bins::check_filesystem_support(\n+            &[&src_path, &compiler_path, &library_path],\n+            &output_directory,\n+        ) {\n+            check!(bins, &src_path);\n+            check!(bins, &compiler_path);\n+            check!(bins, &library_path);\n+        }\n+\n+        check!(style, &src_path);\n+        check!(style, &compiler_path);\n+        check!(style, &library_path);\n+\n+        check!(edition, &src_path);\n+        check!(edition, &compiler_path);\n+        check!(edition, &library_path);\n+\n+        let collected = {\n+            while handles.len() >= concurrency.get() {\n+                handles.pop_front().unwrap().join().unwrap();\n+            }\n+            let mut flag = false;\n+            let r = features::check(&src_path, &compiler_path, &library_path, &mut flag, verbose);\n+            if flag {\n+                bad.store(true, Ordering::Relaxed);\n+            }\n+            r\n+        };\n+        check!(unstable_book, &src_path, collected);\n+    })\n+    .unwrap();\n+\n+    if bad.load(Ordering::Relaxed) {\n         eprintln!(\"some tidy checks failed\");\n         process::exit(1);\n     }"}]}