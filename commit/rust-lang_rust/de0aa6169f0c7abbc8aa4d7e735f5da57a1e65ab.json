{"sha": "de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMGFhNjE2OWYwYzdhYmJjOGFhNGQ3ZTczNWY1ZGE1N2ExZTY1YWI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-16T16:26:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-16T16:26:13Z"}, "message": "Rollup merge of #76339 - CDirkx:structural-match-range, r=Mark-Simulacrum\n\nTest structural matching for all range types\n\nAs of #70166 all range types (`core::ops::Range` etc.) can be structurally matched upon, and by extension used in const generics. In reference to the fact that this is a publicly observable property of these types, and thus falls under the Rust stability guarantees of the standard library, a regression test was added in #70283.\n\nThis regression test was implemented by me by testing for the ability to use the range types within const generics, but that is not the actual property the std guarantees now (const generics is still unstable). This PR addresses that situation by adding extra tests for the range types that directly test whether they can be structurally matched upon.\n\nNote: also adds the otherwise unrelated test `test_range_to_inclusive` for completeness with the other range unit tests", "tree": {"sha": "f6bef1fbd59655adb14a0e5986d1906c38569afc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6bef1fbd59655adb14a0e5986d1906c38569afc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfsqgmCRBK7hj4Ov3rIwAAdHIIAEIY+lpXVxQP9IImb/2x85Kg\nV7699yyPP5LFnZ556Brdim3EHHl15U4k7iFaU6IfxLngDHbH6iFYkkeRhgb9NjWh\nXDYEUsTUXxh/nFprPH7zKMDS/GfaoDnXr6i+4yxJANDykUIJXsu/ZI/5G2eSqTBG\nilPpwKL9YGfEhT/dRLXaKQdbUqLzkuF0zZY8e/x4r9DhCV1WPUjsHxt22edd7F1w\n3yZNwTD5JqMipNYym3ZsyacFoSqvKDbe6QL1jkFi6sbzpuScogi/47RT3hTV/AaB\naIb5QT5UnFVWn/pLbhI3sKo6wiYP1JB2xNseAaFjh9D2WdDA1cgHbURciVEo3J0=\n=8+9H\n-----END PGP SIGNATURE-----\n", "payload": "tree f6bef1fbd59655adb14a0e5986d1906c38569afc\nparent 4cdd22062580b46cbb6cf97ca56d59ebeb1e91b7\nparent 6728240f36c7dd1ecb16d396c9c61933d2f01da9\nauthor Mara Bos <m-ou.se@m-ou.se> 1605543973 +0100\ncommitter GitHub <noreply@github.com> 1605543973 +0100\n\nRollup merge of #76339 - CDirkx:structural-match-range, r=Mark-Simulacrum\n\nTest structural matching for all range types\n\nAs of #70166 all range types (`core::ops::Range` etc.) can be structurally matched upon, and by extension used in const generics. In reference to the fact that this is a publicly observable property of these types, and thus falls under the Rust stability guarantees of the standard library, a regression test was added in #70283.\n\nThis regression test was implemented by me by testing for the ability to use the range types within const generics, but that is not the actual property the std guarantees now (const generics is still unstable). This PR addresses that situation by adding extra tests for the range types that directly test whether they can be structurally matched upon.\n\nNote: also adds the otherwise unrelated test `test_range_to_inclusive` for completeness with the other range unit tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab", "html_url": "https://github.com/rust-lang/rust/commit/de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cdd22062580b46cbb6cf97ca56d59ebeb1e91b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cdd22062580b46cbb6cf97ca56d59ebeb1e91b7", "html_url": "https://github.com/rust-lang/rust/commit/4cdd22062580b46cbb6cf97ca56d59ebeb1e91b7"}, {"sha": "6728240f36c7dd1ecb16d396c9c61933d2f01da9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6728240f36c7dd1ecb16d396c9c61933d2f01da9", "html_url": "https://github.com/rust-lang/rust/commit/6728240f36c7dd1ecb16d396c9c61933d2f01da9"}], "stats": {"total": 48, "additions": 47, "deletions": 1}, "files": [{"sha": "e9d595e65e2b2f49af8652b2cad7c762ee96ef26", "filename": "library/core/tests/ops.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab/library%2Fcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab/library%2Fcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fops.rs?ref=de0aa6169f0c7abbc8aa4d7e735f5da57a1e65ab", "patch": "@@ -1,4 +1,4 @@\n-use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo};\n+use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo, RangeToInclusive};\n \n // Test the Range structs and syntax.\n \n@@ -59,6 +59,12 @@ fn test_range_inclusive() {\n     assert_eq!(r.next(), None);\n }\n \n+#[test]\n+fn test_range_to_inclusive() {\n+    // Not much to test.\n+    let _ = RangeToInclusive { end: 42 };\n+}\n+\n #[test]\n fn test_range_is_empty() {\n     assert!(!(0.0..10.0).is_empty());\n@@ -151,3 +157,43 @@ fn test_range_syntax_in_return_statement() {\n     }\n     // Not much to test.\n }\n+\n+#[test]\n+fn range_structural_match() {\n+    // test that all range types can be structurally matched upon\n+\n+    const RANGE: Range<usize> = 0..1000;\n+    match RANGE {\n+        RANGE => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_FROM: RangeFrom<usize> = 0..;\n+    match RANGE_FROM {\n+        RANGE_FROM => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_FULL: RangeFull = ..;\n+    match RANGE_FULL {\n+        RANGE_FULL => {}\n+    }\n+\n+    const RANGE_INCLUSIVE: RangeInclusive<usize> = 0..=999;\n+    match RANGE_INCLUSIVE {\n+        RANGE_INCLUSIVE => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_TO: RangeTo<usize> = ..1000;\n+    match RANGE_TO {\n+        RANGE_TO => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_TO_INCLUSIVE: RangeToInclusive<usize> = ..=999;\n+    match RANGE_TO_INCLUSIVE {\n+        RANGE_TO_INCLUSIVE => {}\n+        _ => unreachable!(),\n+    }\n+}"}]}