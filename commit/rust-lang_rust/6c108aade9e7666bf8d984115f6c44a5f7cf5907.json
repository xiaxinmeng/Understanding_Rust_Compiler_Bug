{"sha": "6c108aade9e7666bf8d984115f6c44a5f7cf5907", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMTA4YWFkZTllNzY2NmJmOGQ5ODQxMTVmNmM0NGE1ZjdjZjU5MDc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-11T01:59:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-11T01:59:26Z"}, "message": "stdlib: Remove sio and aio. Bitrotted.", "tree": {"sha": "360cdc58963d280bae203662deed2a525badd82c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/360cdc58963d280bae203662deed2a525badd82c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c108aade9e7666bf8d984115f6c44a5f7cf5907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c108aade9e7666bf8d984115f6c44a5f7cf5907", "html_url": "https://github.com/rust-lang/rust/commit/6c108aade9e7666bf8d984115f6c44a5f7cf5907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c108aade9e7666bf8d984115f6c44a5f7cf5907/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "793da65a8eb060268056861d1a82761747aa52a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/793da65a8eb060268056861d1a82761747aa52a2", "html_url": "https://github.com/rust-lang/rust/commit/793da65a8eb060268056861d1a82761747aa52a2"}], "stats": {"total": 376, "additions": 1, "deletions": 375}, "files": [{"sha": "81abac86e396de1335b6852d0c1861572e8b286b", "filename": "src/lib/aio.rs", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,183 +0,0 @@\n-import task;\n-import vec;\n-\n-import comm;\n-import comm::{chan, port, send, recv};\n-import net;\n-\n-native \"cdecl\" mod rustrt {\n-    type socket;\n-    type server;\n-    fn aio_init();\n-    fn aio_run();\n-    fn aio_stop();\n-    fn aio_connect(host: *u8, port: int, connected: chan<socket>);\n-    fn aio_serve(host: *u8, port: int, acceptChan: chan<socket>) -> server;\n-    fn aio_writedata(s: socket, buf: *u8, size: uint, status: chan<bool>);\n-    fn aio_read(s: socket, reader: chan<[u8]>);\n-    fn aio_close_server(s: server, status: chan<bool>);\n-    fn aio_close_socket(s: socket);\n-    fn aio_is_null_client(s: socket) -> bool;\n-}\n-\n-// FIXME: these should be unsafe pointers or something, but those aren't\n-// currently in the sendable kind, so we'll unsafely cast between ints.\n-type server = rustrt::server;\n-type client = rustrt::socket;\n-tag pending_connection { remote(net::ip_addr, int); incoming(server); }\n-\n-tag socket_event { connected(client); closed; received([u8]); }\n-\n-tag server_event { pending(chan<chan<socket_event>>); }\n-\n-tag request {\n-    quit;\n-    connect(pending_connection, chan<socket_event>);\n-    serve(net::ip_addr, int, chan<server_event>, chan<server>);\n-    write(client, [u8], chan<bool>);\n-    close_server(server, chan<bool>);\n-    close_client(client);\n-}\n-\n-type ctx = chan<request>;\n-\n-fn ip_to_sbuf(ip: net::ip_addr) -> *u8 unsafe {\n-\n-    // FIXME: This is broken. We're creating a vector, getting a pointer\n-    // to its buffer, then dropping the vector. On top of that, the vector\n-    // created by str::bytes is not null-terminated.\n-    vec::to_ptr(str::bytes(net::format_addr(ip)))\n-}\n-\n-fn connect_task(args: (net::ip_addr, int, chan<socket_event>)) {\n-    let (ip, portnum, evt) = args;\n-    let connecter = port();\n-    rustrt::aio_connect(ip_to_sbuf(ip), portnum, chan(connecter));\n-    let client = recv(connecter);\n-    new_client(client, evt);\n-}\n-\n-fn new_client(client: client, evt: chan<socket_event>) {\n-    // Start the read before notifying about the connect.  This avoids a race\n-    // condition where the receiver can close the socket before we start\n-    // reading.\n-    let reader: port<[u8]> = port();\n-    rustrt::aio_read(client, chan(reader));\n-\n-    send(evt, connected(client));\n-\n-    while true {\n-        log \"waiting for bytes\";\n-        let data: [u8] = recv(reader);\n-        log \"got some bytes\";\n-        log vec::len::<u8>(data);\n-        if vec::len::<u8>(data) == 0u {\n-            log \"got empty buffer, bailing\";\n-            break;\n-        }\n-        log \"got non-empty buffer, sending\";\n-        send(evt, received(data));\n-        log \"sent non-empty buffer\";\n-    }\n-    log \"done reading\";\n-    send(evt, closed);\n-    log \"close message sent\";\n-}\n-\n-fn accept_task(args: (client, chan<server_event>)) {\n-    let (client, events) = args;\n-    log \"accept task was spawned\";\n-    let p = port();\n-    send(events, pending(chan(p)));\n-    let evt = recv(p);\n-    new_client(client, evt);\n-    log \"done accepting\";\n-}\n-\n-fn server_task(args: (net::ip_addr, int, chan<server_event>,\n-                       chan<server>)) {\n-    let (ip, portnum, events, server) = args;\n-    let accepter = port();\n-    send(server, rustrt::aio_serve(ip_to_sbuf(ip), portnum, chan(accepter)));\n-\n-    let client: client;\n-    while true {\n-        log \"preparing to accept a client\";\n-        client = recv(accepter);\n-        if rustrt::aio_is_null_client(client) {\n-            log \"client was actually null, returning\";\n-            ret;\n-        } else { task::spawn((client, events), accept_task); }\n-    }\n-}\n-\n-fn request_task(c: chan<ctx>) {\n-    // Create a port to accept IO requests on\n-    let p = port();\n-    // Hand of its channel to our spawner\n-    send(c, chan(p));\n-    log \"uv run task spawned\";\n-    // Spin for requests\n-    let req: request;\n-    while true {\n-        req = recv(p);\n-        alt req {\n-          quit. {\n-            log \"got quit message\";\n-            log \"stopping libuv\";\n-            rustrt::aio_stop();\n-            ret;\n-          }\n-          connect(remote(ip, portnum), client) {\n-            task::spawn((ip, portnum, client), connect_task);\n-          }\n-          serve(ip, portnum, events, server) {\n-            task::spawn((ip, portnum, events, server), server_task);\n-          }\n-          write(socket, v, status) unsafe {\n-            rustrt::aio_writedata(socket, vec::unsafe::to_ptr::<u8>(v),\n-                                  vec::len::<u8>(v), status);\n-          }\n-          close_server(server, status) {\n-            log \"closing server\";\n-            rustrt::aio_close_server(server, status);\n-          }\n-          close_client(client) {\n-            log \"closing client\";\n-            rustrt::aio_close_socket(client);\n-          }\n-        }\n-    }\n-}\n-\n-fn iotask(c: chan<ctx>) {\n-    log \"io task spawned\";\n-    // Initialize before accepting requests\n-    rustrt::aio_init();\n-\n-    log \"io task init\";\n-    // Spawn our request task\n-    let reqtask = task::spawn_joinable(copy c, request_task);\n-\n-    log \"uv run task init\";\n-    // Enter IO loop. This never returns until aio_stop is called.\n-    rustrt::aio_run();\n-    log \"waiting for request task to finish\";\n-\n-    task::join(reqtask);\n-}\n-\n-fn new() -> ctx {\n-    let p: port<ctx> = port();\n-    task::spawn(chan(p), iotask);\n-    ret recv(p);\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "fccf8b5c8fd06059e9686c6ee26efd743c737053", "filename": "src/lib/sio.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,82 +0,0 @@\n-import comm::{port, chan, send, recv};\n-\n-import net;\n-\n-type ctx = aio::ctx;\n-type client = {ctx: ctx, client: aio::client, evt: port<aio::socket_event>};\n-type server = {ctx: ctx, server: aio::server, evt: port<aio::server_event>};\n-\n-fn new() -> ctx { ret aio::new(); }\n-\n-fn destroy(ctx: ctx) { send(ctx, aio::quit); }\n-\n-fn make_socket(ctx: ctx, p: port<aio::socket_event>) -> client {\n-    let evt: aio::socket_event = recv(p);\n-    alt evt {\n-      aio::connected(client) { ret {ctx: ctx, client: client, evt: p}; }\n-      _ { fail \"Could not connect to client\"; }\n-    }\n-}\n-\n-fn connect_to(ctx: ctx, ip: net::ip_addr, portnum: int) -> client {\n-    let p: port<aio::socket_event> = port();\n-    send(ctx, aio::connect(aio::remote(ip, portnum), chan(p)));\n-    ret make_socket(ctx, p);\n-}\n-\n-fn read(c: client) -> [u8] {\n-    alt recv(c.evt) {\n-      aio::closed. { ret []; }\n-      aio::received(buf) { ret buf; }\n-    }\n-}\n-\n-fn create_server(ctx: ctx, ip: net::ip_addr, portnum: int) -> server {\n-    let evt: port<aio::server_event> = port();\n-    let p: port<aio::server> = port();\n-    send(ctx, aio::serve(ip, portnum, chan(evt), chan(p)));\n-    let srv: aio::server = recv(p);\n-    ret {ctx: ctx, server: srv, evt: evt};\n-}\n-\n-fn accept_from(server: server) -> client {\n-    let evt: aio::server_event = recv(server.evt);\n-    alt evt {\n-      aio::pending(callback) {\n-        let p = port();\n-        send(callback, chan(p));\n-        ret make_socket(server.ctx, p);\n-      }\n-    }\n-}\n-\n-fn write_data(c: client, data: [u8]) -> bool {\n-    let p = port();\n-    send(c.ctx, aio::write(c.client, data, chan(p)));\n-    ret recv(p);\n-}\n-\n-fn close_server(server: server) {\n-    // TODO: make this unit once we learn to send those from native code\n-    let p = port();\n-    send(server.ctx, aio::close_server(server.server, chan(p)));\n-    log \"Waiting for close\";\n-    recv(p);\n-    log \"Got close\";\n-}\n-\n-fn close_client(client: client) {\n-    send(client.ctx, aio::close_client(client.client));\n-    let evt: aio::socket_event;\n-    do  { evt = recv(client.evt); alt evt { aio::closed. { ret; } _ { } } }\n-        while true\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "9207f1cfdc9aeed3ed6633492e7b646968434435", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c108aade9e7666bf8d984115f6c44a5f7cf5907/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6c108aade9e7666bf8d984115f6c44a5f7cf5907/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=6c108aade9e7666bf8d984115f6c44a5f7cf5907", "patch": "@@ -8,7 +8,7 @@\n \n \n export box, char, float, int, str, ptr, uint, u8, u32, u64, vec;\n-export aio, comm, fs, io, net, run, sio, sys, task;\n+export comm, fs, io, net, run, sys, task;\n export ctypes, either, option, result, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n@@ -35,13 +35,11 @@ mod vec;\n \n // General io and system-services modules\n \n-mod aio;\n mod comm;\n mod fs;\n mod io;\n mod net;\n mod run = \"run_program.rs\";\n-mod sio;\n mod sys;\n mod task;\n "}, {"sha": "14e5e2e44cf6591d4ee7eb07ff856a7adb89ab34", "filename": "src/test/run-pass/sio-client.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-client.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-client.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-client.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,26 +0,0 @@\n-// xfail-test\n-use std;\n-import std::sio;\n-import std::task;\n-import std::net;\n-\n-fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n-  let client: sio::client;\n-  client = sio::connect_to(cx, ip, portnum);\n-  sio::close_client(client);\n-}\n-\n-fn main() {\n-  let cx: sio::ctx = sio::new();\n-  let srv: sio::server = sio::create_server(\n-       cx, net::parse_addr(\"0.0.0.0\"), 9090);\n-  let child = task::_spawn(bind connectTask(cx,\n-                                            net::parse_addr(\"127.0.0.1\"),\n-                                            9090));\n-  let client: sio::client = sio::accept_from(srv);\n-  task::join_id(child);\n-  sio::close_client(client);\n-  sio::close_server(srv);\n-  sio::destroy(cx);\n-}\n-"}, {"sha": "ea3374e493f612edd93b1415f68bd430908c3264", "filename": "src/test/run-pass/sio-ctx.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-ctx.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,10 +0,0 @@\n-// Seems to hang for long periods, probably with RUST_THREADS > 1. Issue #810\n-// xfail-test\n-\n-use std;\n-import std::sio;\n-\n-fn main() {\n-  let cx: sio::ctx = sio::new();\n-  sio::destroy(cx);\n-}"}, {"sha": "0085f4983f2cbf93efef992a7dee28690b431a7a", "filename": "src/test/run-pass/sio-read.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-read.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,30 +0,0 @@\n-// xfail-test\n-use std;\n-import std::sio;\n-import std::task;\n-import std::str;\n-import std::net;\n-\n-fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n-  let client: sio::client;\n-  client = sio::connect_to(cx, ip, portnum);\n-  let data = sio::read(client);\n-  sio::close_client(client);\n-}\n-\n-fn main() {\n-  let cx: sio::ctx = sio::new();\n-  let srv: sio::server = sio::create_server(\n-          cx, net::parse_addr(\"0.0.0.0\"), 9090);\n-  let child = task::_spawn(bind connectTask(cx,\n-                                            net::parse_addr(\"127.0.0.1\"),\n-                                            9090));\n-  let client: sio::client = sio::accept_from(srv);\n-  sio::write_data(client, str::bytes(\"hello, world\\n\"));\n-  task::join_id(child);\n-  sio::close_client(client);\n-  sio::close_server(srv);\n-  sio::destroy(cx);\n-}\n-\n-"}, {"sha": "1171971427ec8079a4142abdeb3b05dc84c79629", "filename": "src/test/run-pass/sio-srv.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-srv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-srv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-srv.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,13 +0,0 @@\n-// xfail-test\n-use std;\n-import std::sio;\n-import std::net;\n-\n-fn main() {\n-  let cx: sio::ctx = sio::new();\n-  let srv: sio::server = sio::create_server(cx,\n-                                            net::parse_addr(\"127.0.0.1\"),\n-                                            9090);\n-  sio::close_server(srv);\n-  sio::destroy(cx);\n-}"}, {"sha": "cc372bc916d1af808d766938ea864e1bfb155655", "filename": "src/test/run-pass/sio-write.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793da65a8eb060268056861d1a82761747aa52a2/src%2Ftest%2Frun-pass%2Fsio-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-write.rs?ref=793da65a8eb060268056861d1a82761747aa52a2", "patch": "@@ -1,28 +0,0 @@\n-// xfail-test\n-use std;\n-import std::sio;\n-import std::task;\n-import std::str;\n-import std::net;\n-\n-fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n-  let client: sio::client;\n-  client = sio::connect_to(cx, ip, portnum);\n-  sio::close_client(client);\n-}\n-\n-fn main() {\n-  let cx: sio::ctx = sio::new();\n-  let srv: sio::server = sio::create_server(cx, net::parse_addr(\"0.0.0.0\"),\n-                                            9090);\n-  let child = task::_spawn(bind connectTask(cx, net::parse_addr(\"127.0.0.1\"),\n-                                            9090));\n-  let client: sio::client = sio::accept_from(srv);\n-  sio::write_data(client, str::bytes(\"hello, world\\n\"));\n-  task::join_id(child);\n-  sio::close_client(client);\n-  sio::close_server(srv);\n-  sio::destroy(cx);\n-}\n-\n-"}]}