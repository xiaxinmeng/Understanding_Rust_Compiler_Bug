{"sha": "cd274632f8c78dbd534c016d5298655a5c116221", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMjc0NjMyZjhjNzhkYmQ1MzRjMDE2ZDUyOTg2NTVhNWMxMTYyMjE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-12T10:45:21Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-14T12:05:56Z"}, "message": "Put each error code long explanation into their own markdown file", "tree": {"sha": "2c18a3db20703238f5ce59f02b4f8d9a5ff1624d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c18a3db20703238f5ce59f02b4f8d9a5ff1624d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd274632f8c78dbd534c016d5298655a5c116221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd274632f8c78dbd534c016d5298655a5c116221", "html_url": "https://github.com/rust-lang/rust/commit/cd274632f8c78dbd534c016d5298655a5c116221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd274632f8c78dbd534c016d5298655a5c116221/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3302190b673660222ad52f3f2958fac9e804d365", "url": "https://api.github.com/repos/rust-lang/rust/commits/3302190b673660222ad52f3f2958fac9e804d365", "html_url": "https://github.com/rust-lang/rust/commit/3302190b673660222ad52f3f2958fac9e804d365"}], "stats": {"total": 26012, "additions": 12609, "deletions": 13403}, "files": [{"sha": "23ea48d4b72ba57ec4259315814f84da5782e156", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 396, "deletions": 13403, "changes": 13799, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=cd274632f8c78dbd534c016d5298655a5c116221"}, {"sha": "90756780d15024d6d2d6415929f84153f12c7fda", "filename": "src/librustc_error_codes/error_codes/E0001.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0001.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0001.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0001.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```\n+match Some(0) {\n+    Some(bar) => {/* ... */}\n+    x => {/* ... */} // This handles the `None` case\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms."}, {"sha": "5cb59da10e00bc0074f0d134c8fabb625c3b0c95", "filename": "src/librustc_error_codes/error_codes/E0002.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0002.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0002.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0002.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that an empty match expression is invalid because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired. This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+enum Empty {}\n+\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```compile_fail\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```"}, {"sha": "b79ef5fd8cb73685c80a74661f6c818114b50fe0", "filename": "src/librustc_error_codes/error_codes/E0004.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0004.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0004.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0004.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,46 @@\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0004\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n+\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```"}, {"sha": "e2e7db5082d168e2e6821dcb845fe57cd658f88d", "filename": "src/librustc_error_codes/error_codes/E0005.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0005.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0005.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0005.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,30 @@\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0005\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```"}, {"sha": "2be7870d5aeee8eff87cb77aff14dc42179779c1", "filename": "src/librustc_error_codes/error_codes/E0007.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0007.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0007.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0007.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0007\n+let x = Some(\"s\".to_string());\n+\n+match x {\n+    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n+    None => {},\n+}\n+```\n+\n+See also the error E0303."}, {"sha": "abb7fe41ab7a29e1889ceb6f1d9ebf1935fcff5a", "filename": "src/librustc_error_codes/error_codes/E0009.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,48 @@\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0009\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n+                            //        same pattern\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+\n+Solution #1: Bind the pattern's values the same way.\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```"}, {"sha": "71c790e102f93df46a69bcd5fe8c295f9051a945", "filename": "src/librustc_error_codes/error_codes/E0010.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0010.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0010.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0010.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,11 @@\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0010\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```"}, {"sha": "8de177590ece8c7a0fdb6fef686654d09e949fa4", "filename": "src/librustc_error_codes/error_codes/E0013.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0013.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0013.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0013.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0013\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n+extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```"}, {"sha": "2c69957e9f6425be986c319523a4d5572f7075d3", "filename": "src/librustc_error_codes/error_codes/E0014.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0014.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0014.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0014.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Constants can only be initialized by a constant value or, in a future\n+version of Rust, a call to a const function. This error indicates the use\n+of a path (like a::b, or x) denoting something other than one of these\n+allowed items.\n+\n+Erroneous code example:\n+\n+```\n+const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n+```\n+\n+To avoid it, you have to replace the non-constant value:\n+\n+```\n+const FOO: i32 = { const X : i32 = 0; X };\n+// or even:\n+const FOO2: i32 = { 0 }; // but brackets are useless here\n+```"}, {"sha": "2bf59983fa93af05b6664b5f008515ce274c8b69", "filename": "src/librustc_error_codes/error_codes/E0015.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md"}, {"sha": "d5e6857b4d6f893c2418f0962d15dcabef21fa83", "filename": "src/librustc_error_codes/error_codes/E0017.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+References in statics and constants may only refer to immutable values.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0017\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`."}, {"sha": "7832468a539d315c71cab09ebc1e936258fe616b", "filename": "src/librustc_error_codes/error_codes/E0019.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0019.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0019.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0019.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,36 @@\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0019\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    struct MyOwned;\n+\n+    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn func(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```"}, {"sha": "92cae460c81db15a697b9c466509f1c3e53b5e6d", "filename": "src/librustc_error_codes/error_codes/E0023.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,47 @@\n+A pattern used to match against an enum variant must provide a sub-pattern for\n+each field of the enum variant. This error indicates that a pattern attempted to\n+extract an incorrect number of fields from a variant.\n+\n+```\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+```\n+\n+Here the `Apple` variant has two fields, and should be matched against like so:\n+\n+```\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n+// Correct.\n+match x {\n+    Fruit::Apple(a, b) => {},\n+    _ => {}\n+}\n+```\n+\n+Matching with the wrong number of fields has no sensible interpretation:\n+\n+```compile_fail,E0023\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n+// Incorrect.\n+match x {\n+    Fruit::Apple(a) => {},\n+    Fruit::Apple(a, b, c) => {},\n+}\n+```\n+\n+Check how many fields the enum was declared with and ensure that your pattern\n+uses the same number."}, {"sha": "51073babd01de112ecf4cee325dda7e8905b52e9", "filename": "src/librustc_error_codes/error_codes/E0025.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0025.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0025.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0025.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,33 @@\n+Each field of a struct can only be bound once in a pattern. Erroneous code\n+example:\n+\n+```compile_fail,E0025\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main(){\n+    let x = Foo { a:1, b:2 };\n+\n+    let Foo { a: x, a: y } = x;\n+    // error: field `a` bound multiple times in the pattern\n+}\n+```\n+\n+Each occurrence of a field name binds the value of that field, so to fix this\n+error you will have to remove or alter the duplicate uses of the field name.\n+Perhaps you misspelled another field name? Example:\n+\n+```\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main(){\n+    let x = Foo { a:1, b:2 };\n+\n+    let Foo { a: x, b: y } = x; // ok!\n+}\n+```"}, {"sha": "9327b31ac4b9b11c8f0bd0ae950128b347c45401", "filename": "src/librustc_error_codes/error_codes/E0026.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0026.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0026.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0026.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,51 @@\n+This error indicates that a struct pattern attempted to extract a non-existent\n+field from a struct. Struct fields are identified by the name used before the\n+colon `:` so struct patterns should resemble the declaration of the struct type\n+being matched.\n+\n+```\n+// Correct matching.\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 1, y: 2 };\n+\n+match thing {\n+    Thing { x: xfield, y: yfield } => {}\n+}\n+```\n+\n+If you are using shorthand field patterns but want to refer to the struct field\n+by a different name, you should rename it explicitly.\n+\n+Change this:\n+\n+```compile_fail,E0026\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 0, y: 0 };\n+\n+match thing {\n+    Thing { x, z } => {}\n+}\n+```\n+\n+To this:\n+\n+```\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 0, y: 0 };\n+\n+match thing {\n+    Thing { x, y: z } => {}\n+}\n+```"}, {"sha": "ab2a20fe9e56d00fb9472b30cbc542a604aeaa71", "filename": "src/librustc_error_codes/error_codes/E0027.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0027.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0027.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0027.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,39 @@\n+This error indicates that a pattern for a struct fails to specify a sub-pattern\n+for every one of the struct's fields. Ensure that each field from the struct's\n+definition is mentioned in the pattern, or use `..` to ignore unwanted fields.\n+\n+For example:\n+\n+```compile_fail,E0027\n+struct Dog {\n+    name: String,\n+    age: u32,\n+}\n+\n+let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n+\n+// This is incorrect.\n+match d {\n+    Dog { age: x } => {}\n+}\n+```\n+\n+This is correct (explicit):\n+\n+```\n+struct Dog {\n+    name: String,\n+    age: u32,\n+}\n+\n+let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n+\n+match d {\n+    Dog { name: ref n, age: x } => {}\n+}\n+\n+// This is also correct (ignore unused fields).\n+match d {\n+    Dog { age: x, .. } => {}\n+}\n+```"}, {"sha": "fadfda0a80c18052bac2ee2baf685ebad44ce662", "filename": "src/librustc_error_codes/error_codes/E0029.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0029.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0029.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0029.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+In a match expression, only numbers and characters can be matched against a\n+range. This is because the compiler checks that the range is non-empty at\n+compile-time, and is unable to evaluate arbitrary comparison functions. If you\n+want to capture values of an orderable type between two end-points, you can use\n+a guard.\n+\n+```compile_fail,E0029\n+let string = \"salutations !\";\n+\n+// The ordering relation for strings cannot be evaluated at compile time,\n+// so this doesn't work:\n+match string {\n+    \"hello\" ..= \"world\" => {}\n+    _ => {}\n+}\n+\n+// This is a more general version, using a guard:\n+match string {\n+    s if s >= \"hello\" && s <= \"world\" => {}\n+    _ => {}\n+}\n+```"}, {"sha": "67d496da5e4eb771f8a2d17eba905ca20492a5db", "filename": "src/librustc_error_codes/error_codes/E0030.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0030.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0030.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0030.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,15 @@\n+When matching against a range, the compiler verifies that the range is\n+non-empty. Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0030\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ..= 1 => {}\n+    // This range is empty, and the compiler can tell.\n+    1000 ..= 5 => {}\n+}\n+```"}, {"sha": "0bb70e89f3dc81a5418f4c2a7cb79763ccaec5a1", "filename": "src/librustc_error_codes/error_codes/E0033.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+This error indicates that a pointer to a trait type cannot be implicitly\n+dereferenced by a pattern. Every trait defines a type, but because the\n+size of trait implementers isn't fixed, this type has no compile-time size.\n+Therefore, all accesses to trait types must be through pointers. If you\n+encounter this error you should try to avoid dereferencing the pointer.\n+\n+```compile_fail,E0033\n+# trait SomeTrait { fn method_one(&self){} fn method_two(&self){} }\n+# impl<T> SomeTrait for T {}\n+let trait_obj: &SomeTrait = &\"some_value\";\n+\n+// This tries to implicitly dereference to create an unsized local variable.\n+let &invalid = trait_obj;\n+\n+// You can call methods without binding to the value being pointed at.\n+trait_obj.method_one();\n+trait_obj.method_two();\n+```\n+\n+You can read more about trait objects in the [Trait Objects] section of the\n+Reference.\n+\n+[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects"}, {"sha": "bc804b7faefca52912316adf650169f012d08d2f", "filename": "src/librustc_error_codes/error_codes/E0034.md", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0034.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0034.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0034.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,84 @@\n+The compiler doesn't know what method to call because more than one method\n+has the same prototype. Erroneous code example:\n+\n+```compile_fail,E0034\n+struct Test;\n+\n+trait Trait1 {\n+    fn foo();\n+}\n+\n+trait Trait2 {\n+    fn foo();\n+}\n+\n+impl Trait1 for Test { fn foo() {} }\n+impl Trait2 for Test { fn foo() {} }\n+\n+fn main() {\n+    Test::foo() // error, which foo() to call?\n+}\n+```\n+\n+To avoid this error, you have to keep only one of them and remove the others.\n+So let's take our example and fix it:\n+\n+```\n+struct Test;\n+\n+trait Trait1 {\n+    fn foo();\n+}\n+\n+impl Trait1 for Test { fn foo() {} }\n+\n+fn main() {\n+    Test::foo() // and now that's good!\n+}\n+```\n+\n+However, a better solution would be using fully explicit naming of type and\n+trait:\n+\n+```\n+struct Test;\n+\n+trait Trait1 {\n+    fn foo();\n+}\n+\n+trait Trait2 {\n+    fn foo();\n+}\n+\n+impl Trait1 for Test { fn foo() {} }\n+impl Trait2 for Test { fn foo() {} }\n+\n+fn main() {\n+    <Test as Trait1>::foo()\n+}\n+```\n+\n+One last example:\n+\n+```\n+trait F {\n+    fn m(&self);\n+}\n+\n+trait G {\n+    fn m(&self);\n+}\n+\n+struct X;\n+\n+impl F for X { fn m(&self) { println!(\"I am F\"); } }\n+impl G for X { fn m(&self) { println!(\"I am G\"); } }\n+\n+fn main() {\n+    let f = X;\n+\n+    F::m(&f); // it displays \"I am F\"\n+    G::m(&f); // it displays \"I am G\"\n+}\n+```"}, {"sha": "21b5eb47480e62d85feec6a252ee5995a72038a3", "filename": "src/librustc_error_codes/error_codes/E0038.md", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,291 @@\n+Trait objects like `Box<Trait>` can only be constructed when certain\n+requirements are satisfied by the trait in question.\n+\n+Trait objects are a form of dynamic dispatch and use a dynamically sized type\n+for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n+type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n+pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n+(among other things) for dynamic dispatch. This design mandates some\n+restrictions on the types of traits that are allowed to be used in trait\n+objects, which are collectively termed as 'object safety' rules.\n+\n+Attempting to create a trait object for a non object-safe trait will trigger\n+this error.\n+\n+There are various rules:\n+\n+### The trait cannot require `Self: Sized`\n+\n+When `Trait` is treated as a type, the type does not implement the special\n+`Sized` trait, because the type does not have a known size at compile time and\n+can only be accessed behind a pointer. Thus, if we have a trait like the\n+following:\n+\n+```\n+trait Foo where Self: Sized {\n+\n+}\n+```\n+\n+We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+`Self` would not be `Sized`.\n+\n+Generally, `Self: Sized` is used to indicate that the trait should not be used\n+as a trait object. If the trait comes from your own crate, consider removing\n+this restriction.\n+\n+### Method references the `Self` type in its parameters or return type\n+\n+This happens when a trait has a method like the following:\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n+impl Trait for String {\n+    fn foo(&self) -> Self {\n+        \"hi\".to_owned()\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) -> Self {\n+        1\n+    }\n+}\n+```\n+\n+(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n+cause this problem.)\n+\n+In such a case, the compiler cannot predict the return type of `foo()` in a\n+situation like the following:\n+\n+```compile_fail\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n+fn call_foo(x: Box<Trait>) {\n+    let y = x.foo(); // What type is y?\n+    // ...\n+}\n+```\n+\n+If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n+on them to mark them as explicitly unavailable to trait objects. The\n+functionality will still be available to all other implementers, including\n+`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self where Self: Sized;\n+    // more functions\n+}\n+```\n+\n+Now, `foo()` can no longer be called on a trait object, but you will now be\n+allowed to make a trait object, and that will be able to call any object-safe\n+methods. With such a bound, one can still call `foo()` on types implementing\n+that trait that aren't behind trait objects.\n+\n+### Method has generic type parameters\n+\n+As mentioned before, trait objects contain pointers to method tables. So, if we\n+have:\n+\n+```\n+trait Trait {\n+    fn foo(&self);\n+}\n+\n+impl Trait for String {\n+    fn foo(&self) {\n+        // implementation 1\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) {\n+        // implementation 2\n+    }\n+}\n+// ...\n+```\n+\n+At compile time each implementation of `Trait` will produce a table containing\n+the various methods (and other items) related to the implementation.\n+\n+This works fine, but when the method gains generic parameters, we can have a\n+problem.\n+\n+Usually, generic parameters get _monomorphized_. For example, if I have\n+\n+```\n+fn foo<T>(x: T) {\n+    // ...\n+}\n+```\n+\n+The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n+other type substitution is different. Hence the compiler generates the\n+implementation on-demand. If you call `foo()` with a `bool` parameter, the\n+compiler will only generate code for `foo::<bool>()`. When we have additional\n+type parameters, the number of monomorphized implementations the compiler\n+generates does not grow drastically, since the compiler will only generate an\n+implementation if the function is called with unparametrized substitutions\n+(i.e., substitutions where none of the substituted types are themselves\n+parametrized).\n+\n+However, with trait objects we have to make a table containing _every_ object\n+that implements the trait. Now, if it has type parameters, we need to add\n+implementations for every type that implements the trait, and there could\n+theoretically be an infinite number of types.\n+\n+For example, with:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T);\n+    // more methods\n+}\n+\n+impl Trait for String {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 1\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 2\n+    }\n+}\n+\n+// 8 more implementations\n+```\n+\n+Now, if we have the following code:\n+\n+```compile_fail,E0038\n+# trait Trait { fn foo<T>(&self, on: T); }\n+# impl Trait for String { fn foo<T>(&self, on: T) {} }\n+# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n+# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n+# // etc.\n+fn call_foo(thing: Box<Trait>) {\n+    thing.foo(true); // this could be any one of the 8 types above\n+    thing.foo(1);\n+    thing.foo(\"hello\");\n+}\n+```\n+\n+We don't just need to create a table of all implementations of all methods of\n+`Trait`, we need to create such a table, for each different type fed to\n+`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n+types being fed to `foo()`) = 30 implementations!\n+\n+With real world traits these numbers can grow drastically.\n+\n+To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n+fix for the sub-error above if you do not intend to call the method with type\n+parameters:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T) where Self: Sized;\n+    // more methods\n+}\n+```\n+\n+If this is not an option, consider replacing the type parameter with another\n+trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n+number of types you intend to feed to this method is limited, consider manually\n+listing out the methods of different types.\n+\n+### Method has no receiver\n+\n+Methods that do not take a `self` parameter can't be called since there won't be\n+a way to get a pointer to the method table for them.\n+\n+```\n+trait Foo {\n+    fn foo() -> u8;\n+}\n+```\n+\n+This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n+an implementation.\n+\n+Adding a `Self: Sized` bound to these methods will generally make this compile.\n+\n+```\n+trait Foo {\n+    fn foo() -> u8 where Self: Sized;\n+}\n+```\n+\n+### The trait cannot contain associated constants\n+\n+Just like static functions, associated constants aren't stored on the method\n+table. If the trait or any subtrait contain an associated constant, they cannot\n+be made into an object.\n+\n+```compile_fail,E0038\n+trait Foo {\n+    const X: i32;\n+}\n+\n+impl Foo {}\n+```\n+\n+A simple workaround is to use a helper method instead:\n+\n+```\n+trait Foo {\n+    fn x(&self) -> i32;\n+}\n+```\n+\n+### The trait cannot use `Self` as a type parameter in the supertrait listing\n+\n+This is similar to the second sub-error, but subtler. It happens in situations\n+like the following:\n+\n+```compile_fail,E0038\n+trait Super<A: ?Sized> {}\n+\n+trait Trait: Super<Self> {\n+}\n+\n+struct Foo;\n+\n+impl Super<Foo> for Foo{}\n+\n+impl Trait for Foo {}\n+\n+fn main() {\n+    let x: Box<dyn Trait>;\n+}\n+```\n+\n+Here, the supertrait might have methods as follows:\n+\n+```\n+trait Super<A: ?Sized> {\n+    fn get_a(&self) -> &A; // note that this is object safe!\n+}\n+```\n+\n+If the trait `Trait` was deriving from something like `Super<String>` or\n+`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n+`get_a()` will definitely return an object of that type.\n+\n+However, if it derives from `Super<Self>`, even though `Super` is object safe,\n+the method `get_a()` would return an object of unknown type when called on the\n+function. `Self` type parameters let us make object safe traits no longer safe,\n+so they are forbidden when specifying supertraits.\n+\n+There's no easy fix for this, generally code will need to be refactored so that\n+you no longer need to derive from `Super<Self>`."}, {"sha": "fb262018c35b1e03b1614542cd587747456db7e3", "filename": "src/librustc_error_codes/error_codes/E0040.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0040.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0040.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0040.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+It is not allowed to manually call destructors in Rust. It is also not\n+necessary to do this since `drop` is called automatically whenever a value goes\n+out of scope.\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0040\n+struct Foo {\n+    x: i32,\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"kaboom\");\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Foo { x: -7 };\n+    x.drop(); // error: explicit use of destructor method\n+}\n+```"}, {"sha": "8e877e718599757990c1ee22da3f2c892cdadbca", "filename": "src/librustc_error_codes/error_codes/E0044.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0044.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0044.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0044.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+You cannot use type or const parameters on foreign items.\n+Example of erroneous code:\n+\n+```compile_fail,E0044\n+extern { fn some_func<T>(x: T); }\n+```\n+\n+To fix this, replace the generic parameter with the specializations that you\n+need:\n+\n+```\n+extern { fn some_func_i32(x: i32); }\n+extern { fn some_func_i64(x: i64); }\n+```"}, {"sha": "537490eb4cf5b155e72076a47b6e5c2bb9ca1969", "filename": "src/librustc_error_codes/error_codes/E0045.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0045.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0045.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0045.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+Rust only supports variadic parameters for interoperability with C code in its\n+FFI. As such, variadic parameters can only be used with functions which are\n+using the C ABI. Examples of erroneous code:\n+\n+```compile_fail\n+#![feature(unboxed_closures)]\n+\n+extern \"rust-call\" { fn foo(x: u8, ...); }\n+\n+// or\n+\n+fn foo(x: u8, ...) {}\n+```\n+\n+To fix such code, put them in an extern \"C\" block:\n+\n+```\n+extern \"C\" {\n+    fn foo (x: u8, ...);\n+}\n+```"}, {"sha": "2d0bb0863e8831d6a642cb7b15861df34bea702f", "filename": "src/librustc_error_codes/error_codes/E0046.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0046.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0046.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0046.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+Items are missing in a trait implementation. Erroneous code example:\n+\n+```compile_fail,E0046\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {}\n+// error: not all trait items implemented, missing: `foo`\n+```\n+\n+When trying to make some type implement a trait `Foo`, you must, at minimum,\n+provide implementations for all of `Foo`'s required methods (meaning the\n+methods that do not have default implementations), as well as any required\n+trait items like associated types or constants. Example:\n+\n+```\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo() {} // ok!\n+}\n+```"}, {"sha": "721a7fd57a51f9d959e4e63711fe87329162267d", "filename": "src/librustc_error_codes/error_codes/E0049.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0049.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0049.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0049.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of type or const parameters.\n+\n+For example, the trait below has a method `foo` with a type parameter `T`,\n+but the implementation of `foo` for the type `Bar` is missing this parameter:\n+\n+```compile_fail,E0049\n+trait Foo {\n+    fn foo<T: Default>(x: T) -> Self;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 0 type parameters but its trait declaration has 1\n+// type parameter\n+impl Foo for Bar {\n+    fn foo(x: bool) -> Self { Bar }\n+}\n+```"}, {"sha": "79d070802d3040f0e1fe6a838c04f8647e901553", "filename": "src/librustc_error_codes/error_codes/E0050.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0050.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0050.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0050.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of function parameters.\n+\n+For example, the trait below has a method `foo` with two function parameters\n+(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\n+the `u8` parameter:\n+\n+```compile_fail,E0050\n+trait Foo {\n+    fn foo(&self, x: u8) -> bool;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n+// has 2\n+impl Foo for Bar {\n+    fn foo(&self) -> bool { true }\n+}\n+```"}, {"sha": "822d1f0094d3603b26fb63d33b3a39af25709a25", "filename": "src/librustc_error_codes/error_codes/E0053.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0053.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0053.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0053.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+The parameters of any trait method must match between a trait implementation\n+and the trait definition.\n+\n+Here are a couple examples of this error:\n+\n+```compile_fail,E0053\n+trait Foo {\n+    fn foo(x: u16);\n+    fn bar(&self);\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, expected u16, found i16\n+    fn foo(x: i16) { }\n+\n+    // error, types differ in mutability\n+    fn bar(&mut self) { }\n+}\n+```"}, {"sha": "af71cb44462a69dc7ae7b2b40afce598922a02ba", "filename": "src/librustc_error_codes/error_codes/E0054.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0054.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0054.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0054.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+It is not allowed to cast to a bool. If you are trying to cast a numeric type\n+to a bool, you can compare it with zero instead:\n+\n+```compile_fail,E0054\n+let x = 5;\n+\n+// Not allowed, won't compile\n+let x_is_nonzero = x as bool;\n+```\n+\n+```\n+let x = 5;\n+\n+// Ok\n+let x_is_nonzero = x != 0;\n+```"}, {"sha": "d5b863081a61688d3b11a2ea7c68bb4b26dfa5da", "filename": "src/librustc_error_codes/error_codes/E0055.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+During a method call, a value is automatically dereferenced as many times as\n+needed to make the value's type match the method's receiver. The catch is that\n+the compiler will only attempt to dereference a number of times up to the\n+recursion limit (which can be set via the `recursion_limit` attribute).\n+\n+For a somewhat artificial example:\n+\n+```compile_fail,E0055\n+#![recursion_limit=\"5\"]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    let ref_foo = &&&&&Foo;\n+\n+    // error, reached the recursion limit while auto-dereferencing `&&&&&Foo`\n+    ref_foo.foo();\n+}\n+```\n+\n+One fix may be to increase the recursion limit. Note that it is possible to\n+create an infinite recursion of dereferencing, in which case the only fix is to\n+somehow break the recursion."}, {"sha": "e11c07f835ad765fcefbea278127afcd1fa4c892", "filename": "src/librustc_error_codes/error_codes/E0057.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+When invoking closures or other implementations of the function traits `Fn`,\n+`FnMut` or `FnOnce` using call notation, the number of parameters passed to the\n+function must match its definition.\n+\n+An example using a closure:\n+\n+```compile_fail,E0057\n+let f = |x| x * 3;\n+let a = f();        // invalid, too few parameters\n+let b = f(4);       // this works!\n+let c = f(2, 3);    // invalid, too many parameters\n+```\n+\n+A generic function must be treated similarly:\n+\n+```\n+fn foo<F: Fn()>(f: F) {\n+    f(); // this is valid, but f(3) would not work\n+}\n+```"}, {"sha": "b22edead25e7b26bc6dfe466001d0150c3081f2f", "filename": "src/librustc_error_codes/error_codes/E0059.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0059.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0059.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0059.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+The built-in function traits are generic over a tuple of the function arguments.\n+If one uses angle-bracket notation (`Fn<(T,), Output=U>`) instead of parentheses\n+(`Fn(T) -> U`) to denote the function trait, the type parameter should be a\n+tuple. Otherwise function call notation cannot be used and the trait will not be\n+implemented by closures.\n+\n+The most likely source of this error is using angle-bracket notation without\n+wrapping the function argument type into a tuple, for example:\n+\n+```compile_fail,E0059\n+#![feature(unboxed_closures)]\n+\n+fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }\n+```\n+\n+It can be fixed by adjusting the trait bound like this:\n+\n+```\n+#![feature(unboxed_closures)]\n+\n+fn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }\n+```\n+\n+Note that `(T,)` always denotes the type of a 1-tuple containing an element of\n+type `T`. The comma is necessary for syntactic disambiguation."}, {"sha": "7a07b8e7ed6697ce9dc94f953e7faabc33950177", "filename": "src/librustc_error_codes/error_codes/E0060.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,36 @@\n+External C functions are allowed to be variadic. However, a variadic function\n+takes a minimum number of arguments. For example, consider C's variadic `printf`\n+function:\n+\n+```\n+use std::os::raw::{c_char, c_int};\n+\n+extern \"C\" {\n+    fn printf(_: *const c_char, ...) -> c_int;\n+}\n+```\n+\n+Using this declaration, it must be called with at least one argument, so\n+simply calling `printf()` is invalid. But the following uses are allowed:\n+\n+```\n+# #![feature(static_nobundle)]\n+# use std::os::raw::{c_char, c_int};\n+# #[cfg_attr(all(windows, target_env = \"msvc\"),\n+#            link(name = \"legacy_stdio_definitions\", kind = \"static-nobundle\"))]\n+# extern \"C\" { fn printf(_: *const c_char, ...) -> c_int; }\n+# fn main() {\n+unsafe {\n+    use std::ffi::CString;\n+\n+    let fmt = CString::new(\"test\\n\").unwrap();\n+    printf(fmt.as_ptr());\n+\n+    let fmt = CString::new(\"number = %d\\n\").unwrap();\n+    printf(fmt.as_ptr(), 3);\n+\n+    let fmt = CString::new(\"%d, %d\\n\").unwrap();\n+    printf(fmt.as_ptr(), 10, 5);\n+}\n+# }\n+```"}, {"sha": "3386dff2c8513c2bde8e9bfb99f6d6119fbb41fe", "filename": "src/librustc_error_codes/error_codes/E0061.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+The number of arguments passed to a function must match the number of arguments\n+specified in the function signature.\n+\n+For example, a function like:\n+\n+```\n+fn f(a: u16, b: &str) {}\n+```\n+\n+Must always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n+\n+Note that Rust does not have a notion of optional function arguments or\n+variadic functions (except for its C-FFI)."}, {"sha": "0ebeb1bd78ed0af2a683f564b643511db32cb2bc", "filename": "src/librustc_error_codes/error_codes/E0062.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+This error indicates that during an attempt to build a struct or struct-like\n+enum variant, one of the fields was specified more than once. Erroneous code\n+example:\n+\n+```compile_fail,E0062\n+struct Foo {\n+    x: i32,\n+}\n+\n+fn main() {\n+    let x = Foo {\n+                x: 0,\n+                x: 0, // error: field `x` specified more than once\n+            };\n+}\n+```\n+\n+Each field should be specified exactly one time. Example:\n+\n+```\n+struct Foo {\n+    x: i32,\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0 }; // ok!\n+}\n+```"}, {"sha": "0d1f60437acf015228ead632d8a9f09504f05401", "filename": "src/librustc_error_codes/error_codes/E0063.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,26 @@\n+This error indicates that during an attempt to build a struct or struct-like\n+enum variant, one of the fields was not provided. Erroneous code example:\n+\n+```compile_fail,E0063\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0 }; // error: missing field: `y`\n+}\n+```\n+\n+Each field should be specified exactly once. Example:\n+\n+```\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0, y: 0 }; // ok!\n+}\n+```"}, {"sha": "101b96f7983f624854157cc842dfc4b8538c6cde", "filename": "src/librustc_error_codes/error_codes/E0067.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,33 @@\n+The left-hand side of a compound assignment expression must be a place\n+expression. A place expression represents a memory location and includes\n+item paths (ie, namespaced variables), dereferences, indexing expressions,\n+and field references.\n+\n+Let's start with some erroneous code examples:\n+\n+```compile_fail,E0067\n+use std::collections::LinkedList;\n+\n+// Bad: assignment to non-place expression\n+LinkedList::new() += 1;\n+\n+// ...\n+\n+fn some_func(i: &mut i32) {\n+    i += 12; // Error : '+=' operation cannot be applied on a reference !\n+}\n+```\n+\n+And now some working examples:\n+\n+```\n+let mut i : i32 = 0;\n+\n+i += 12; // Good !\n+\n+// ...\n+\n+fn some_func(i: &mut i32) {\n+    *i += 12; // Good !\n+}\n+```"}, {"sha": "ad3b1803b54dbb4b12dc6d31014c2078ca50e114", "filename": "src/librustc_error_codes/error_codes/E0069.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,12 @@\n+The compiler found a function whose body contains a `return;` statement but\n+whose return type is not `()`. An example of this is:\n+\n+```compile_fail,E0069\n+// error\n+fn foo() -> u8 {\n+    return;\n+}\n+```\n+\n+Since `return;` is just like `return ();`, there is a mismatch between the\n+function's return type and the value being returned."}, {"sha": "1a56080a09734338de12867d30c25d09e34948a0", "filename": "src/librustc_error_codes/error_codes/E0070.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,47 @@\n+The left-hand side of an assignment operator must be a place expression. A\n+place expression represents a memory location and can be a variable (with\n+optional namespacing), a dereference, an indexing expression or a field\n+reference.\n+\n+More details can be found in the [Expressions] section of the Reference.\n+\n+[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\n+\n+Now, we can go further. Here are some erroneous code examples:\n+\n+```compile_fail,E0070\n+struct SomeStruct {\n+    x: i32,\n+    y: i32\n+}\n+\n+const SOME_CONST : i32 = 12;\n+\n+fn some_other_func() {}\n+\n+fn some_function() {\n+    SOME_CONST = 14; // error : a constant value cannot be changed!\n+    1 = 3; // error : 1 isn't a valid place!\n+    some_other_func() = 4; // error : we cannot assign value to a function!\n+    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used\n+                       // like a variable!\n+}\n+```\n+\n+And now let's give working examples:\n+\n+```\n+struct SomeStruct {\n+    x: i32,\n+    y: i32\n+}\n+let mut s = SomeStruct {x: 0, y: 0};\n+\n+s.x = 3; // that's good !\n+\n+// ...\n+\n+fn some_func(x: &mut i32) {\n+    *x = 12; // that's good !\n+}\n+```"}, {"sha": "768dd0c7a48c29624779a101ad6c99e136c98603", "filename": "src/librustc_error_codes/error_codes/E0071.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+You tried to use structure-literal syntax to create an item that is\n+not a structure or enum variant.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0071\n+type U32 = u32;\n+let t = U32 { value: 4 }; // error: expected struct, variant or union type,\n+                          // found builtin type `u32`\n+```\n+\n+To fix this, ensure that the name was correctly spelled, and that\n+the correct form of initializer was used.\n+\n+For example, the code above can be fixed to:\n+\n+```\n+enum Foo {\n+    FirstValue(i32)\n+}\n+\n+fn main() {\n+    let u = Foo::FirstValue(0i32);\n+\n+    let t = 4;\n+}\n+```"}, {"sha": "e461d45f30c858902dd327acaab0328777fae3ce", "filename": "src/librustc_error_codes/error_codes/E0072.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+When defining a recursive struct or enum, any use of the type being defined\n+from inside the definition must occur behind a pointer (like `Box` or `&`).\n+This is because structs and enums must have a well-defined size, and without\n+the pointer, the size of the type would need to be unbounded.\n+\n+Consider the following erroneous definition of a type for a list of bytes:\n+\n+```compile_fail,E0072\n+// error, invalid recursive struct type\n+struct ListNode {\n+    head: u8,\n+    tail: Option<ListNode>,\n+}\n+```\n+\n+This type cannot have a well-defined size, because it needs to be arbitrarily\n+large (since we would be able to nest `ListNode`s to any depth). Specifically,\n+\n+```plain\n+size of `ListNode` = 1 byte for `head`\n+                   + 1 byte for the discriminant of the `Option`\n+                   + size of `ListNode`\n+```\n+\n+One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n+\n+```\n+struct ListNode {\n+    head: u8,\n+    tail: Option<Box<ListNode>>,\n+}\n+```\n+\n+This works because `Box` is a pointer, so its size is well-known."}, {"sha": "a5aea86ff2d9df6f371070756478b8045c25b18f", "filename": "src/librustc_error_codes/error_codes/E0073.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0073.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0073.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0073.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\n+in order to make a new `Foo` value. This is because there would be no way a\n+first instance of `Foo` could be made to initialize another instance!\n+\n+Here's an example of a struct that has this problem:\n+\n+```\n+struct Foo { x: Box<Foo> } // error\n+```\n+\n+One fix is to use `Option`, like so:\n+\n+```\n+struct Foo { x: Option<Box<Foo>> }\n+```\n+\n+Now it's possible to create at least one instance of `Foo`: `Foo { x: None }`."}, {"sha": "e25dec7681be5e4715f33d92edc7db7bd8404978", "filename": "src/librustc_error_codes/error_codes/E0074.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0074.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0074.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0074.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+When using the `#[simd]` attribute on a tuple struct, the components of the\n+tuple struct must all be of a concrete, nongeneric type so the compiler can\n+reason about how to use SIMD with them. This error will occur if the types\n+are generic.\n+\n+This will cause an error:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad<T>(T, T, T);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32, u32, u32);\n+```"}, {"sha": "f15af8150baaacd25875a4eb5fddfc4cdfcef606", "filename": "src/librustc_error_codes/error_codes/E0075.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+The `#[simd]` attribute can only be applied to non empty tuple structs, because\n+it doesn't make sense to try to use SIMD operations when there are no values to\n+operate on.\n+\n+This will cause an error:\n+\n+```compile_fail,E0075\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad;\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32);\n+```"}, {"sha": "466e0a96e6b018a91b5b5cd8d7d52f883f27cc7b", "filename": "src/librustc_error_codes/error_codes/E0076.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+When using the `#[simd]` attribute to automatically use SIMD operations in tuple\n+struct, the types in the struct must all be of the same type, or the compiler\n+will trigger this error.\n+\n+This will cause an error:\n+\n+```compile_fail,E0076\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad(u16, u32, u32);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32, u32, u32);\n+```"}, {"sha": "6ae35a6aa17fe504744433e3c09cca54e20efeca", "filename": "src/librustc_error_codes/error_codes/E0077.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+When using the `#[simd]` attribute on a tuple struct, the elements in the tuple\n+must be machine types so SIMD operations can be applied to them.\n+\n+This will cause an error:\n+\n+```compile_fail,E0077\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad(String);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32, u32, u32);\n+```"}, {"sha": "262bf00d385406e18278a828bfd4fd7e22683402", "filename": "src/librustc_error_codes/error_codes/E0080.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+This error indicates that the compiler was unable to sensibly evaluate a\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n+\n+```compile_fail,E0080\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n+```\n+\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n+\n+https://doc.rust-lang.org/reference.html#ffi-attributes"}, {"sha": "ec88ca9765e292ad1ab8898f6988f72528237950", "filename": "src/librustc_error_codes/error_codes/E0081.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,35 @@\n+Enum discriminants are used to differentiate enum variants stored in memory.\n+This error indicates that the same value was used for two or more variants,\n+making them impossible to tell apart.\n+\n+```compile_fail,E0081\n+// Bad.\n+enum Enum {\n+    P = 3,\n+    X = 3,\n+    Y = 5,\n+}\n+```\n+\n+```\n+// Good.\n+enum Enum {\n+    P,\n+    X = 3,\n+    Y = 5,\n+}\n+```\n+\n+Note that variants without a manually specified discriminant are numbered from\n+top to bottom starting from 0, so clashes can occur with seemingly unrelated\n+variants.\n+\n+```compile_fail,E0081\n+enum Bad {\n+    X,\n+    Y = 0\n+}\n+```\n+\n+Here `X` will have already been specified the discriminant 0 by the time `Y` is\n+encountered, so a conflict occurs."}, {"sha": "2388bc635d9f5a433756d6150eb20581e80d7b52", "filename": "src/librustc_error_codes/error_codes/E0084.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0084.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0084.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0084.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+An unsupported representation was attempted on a zero-variant enum.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0084\n+#[repr(i32)]\n+enum NightsWatch {} // error: unsupported representation for zero-variant enum\n+```\n+\n+It is impossible to define an integer type to be used to represent zero-variant\n+enum values because there are no zero-variant enum values. There is no way to\n+construct an instance of the following type using only safe code. So you have\n+two solutions. Either you add variants in your enum:\n+\n+```\n+#[repr(i32)]\n+enum NightsWatch {\n+    JonSnow,\n+    Commander,\n+}\n+```\n+\n+or you remove the integer represention of your enum:\n+\n+```\n+enum NightsWatch {}\n+```"}, {"sha": "9d292186f0fa587f2dddb6651e256f9b5189be85", "filename": "src/librustc_error_codes/error_codes/E0087.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0087.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0087.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0087.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,15 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Too many type arguments were supplied for a function. For example:\n+\n+```compile_fail,E0107\n+fn foo<T>() {}\n+\n+fn main() {\n+    foo::<f64, bool>(); // error: wrong number of type arguments:\n+                        //        expected 1, found 2\n+}\n+```\n+\n+The number of supplied arguments must exactly match the number of defined type\n+parameters."}, {"sha": "7780ad5b56e03dc6e0c58e67e1aadcf4b832965c", "filename": "src/librustc_error_codes/error_codes/E0088.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0088.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0088.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0088.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,45 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You gave too many lifetime arguments. Erroneous code example:\n+\n+```compile_fail,E0107\n+fn f() {}\n+\n+fn main() {\n+    f::<'static>() // error: wrong number of lifetime arguments:\n+                   //        expected 0, found 1\n+}\n+```\n+\n+Please check you give the right number of lifetime arguments. Example:\n+\n+```\n+fn f() {}\n+\n+fn main() {\n+    f() // ok!\n+}\n+```\n+\n+It's also important to note that the Rust compiler can generally\n+determine the lifetime by itself. Example:\n+\n+```\n+struct Foo {\n+    value: String\n+}\n+\n+impl Foo {\n+    // it can be written like this\n+    fn get_value<'a>(&'a self) -> &'a str { &self.value }\n+    // but the compiler works fine with this too:\n+    fn without_lifetime(&self) -> &str { &self.value }\n+}\n+\n+fn main() {\n+    let f = Foo { value: \"hello\".to_owned() };\n+\n+    println!(\"{}\", f.get_value());\n+    println!(\"{}\", f.without_lifetime());\n+}\n+```"}, {"sha": "504fbc7b96a98552777383d621f2107031aaf6a0", "filename": "src/librustc_error_codes/error_codes/E0089.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0089.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0089.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0089.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Too few type arguments were supplied for a function. For example:\n+\n+```compile_fail,E0107\n+fn foo<T, U>() {}\n+\n+fn main() {\n+    foo::<f64>(); // error: wrong number of type arguments: expected 2, found 1\n+}\n+```\n+\n+Note that if a function takes multiple type arguments but you want the compiler\n+to infer some of them, you can use type placeholders:\n+\n+```compile_fail,E0107\n+fn foo<T, U>(x: T) {}\n+\n+fn main() {\n+    let x: bool = true;\n+    foo::<f64>(x);    // error: wrong number of type arguments:\n+                      //        expected 2, found 1\n+    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n+}\n+```"}, {"sha": "e091bb6c9f2f74786df375ea08dc081b65ac4645", "filename": "src/librustc_error_codes/error_codes/E0090.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0090.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0090.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0090.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You gave too few lifetime arguments. Example:\n+\n+```compile_fail,E0107\n+fn foo<'a: 'b, 'b: 'a>() {}\n+\n+fn main() {\n+    foo::<'static>(); // error: wrong number of lifetime arguments:\n+                      //        expected 2, found 1\n+}\n+```\n+\n+Please check you give the right number of lifetime arguments. Example:\n+\n+```\n+fn foo<'a: 'b, 'b: 'a>() {}\n+\n+fn main() {\n+    foo::<'static, 'static>();\n+}\n+```"}, {"sha": "2a092402429f13fcedbfcb8adb2fe69f1c4b0491", "filename": "src/librustc_error_codes/error_codes/E0091.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,15 @@\n+You gave an unnecessary type or const parameter in a type alias. Erroneous\n+code example:\n+\n+```compile_fail,E0091\n+type Foo<T> = u32; // error: type parameter `T` is unused\n+// or:\n+type Foo<A,B> = Box<A>; // error: type parameter `B` is unused\n+```\n+\n+Please check you didn't write too many parameters. Example:\n+\n+```\n+type Foo = u32; // ok!\n+type Foo2<A> = Box<A>; // ok!\n+```"}, {"sha": "2750a7d45b48e56a45646764288b295c1b1fbadb", "filename": "src/librustc_error_codes/error_codes/E0092.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+You tried to declare an undefined atomic operation function.\n+Erroneous code example:\n+\n+```compile_fail,E0092\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_foo(); // error: unrecognized atomic operation\n+                     //        function\n+}\n+```\n+\n+Please check you didn't make a mistake in the function's name. All intrinsic\n+functions are defined in librustc_codegen_llvm/intrinsic.rs and in\n+libcore/intrinsics.rs in the Rust source code. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_fence(); // ok!\n+}\n+```"}, {"sha": "9633f794d8bb7457348b4d4794bed7eb14b28825", "filename": "src/librustc_error_codes/error_codes/E0093.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,33 @@\n+You declared an unknown intrinsic function. Erroneous code example:\n+\n+```compile_fail,E0093\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn foo(); // error: unrecognized intrinsic function: `foo`\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo();\n+    }\n+}\n+```\n+\n+Please check you didn't make a mistake in the function's name. All intrinsic\n+functions are defined in librustc_codegen_llvm/intrinsic.rs and in\n+libcore/intrinsics.rs in the Rust source code. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_fence(); // ok!\n+}\n+\n+fn main() {\n+    unsafe {\n+        atomic_fence();\n+    }\n+}\n+```"}, {"sha": "4d27f616d2d84250bc24f0d26355866ba36336a5", "filename": "src/librustc_error_codes/error_codes/E0094.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+You gave an invalid number of type parameters to an intrinsic function.\n+Erroneous code example:\n+\n+```compile_fail,E0094\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T, U>() -> usize; // error: intrinsic has wrong number\n+                                 //        of type parameters\n+}\n+```\n+\n+Please check that you provided the right number of type parameters\n+and verify with the function declaration in the Rust source code.\n+Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T>() -> usize; // ok!\n+}\n+```"}, {"sha": "8a49c1f79e475e95b79ebe5c56f1234821555a6d", "filename": "src/librustc_error_codes/error_codes/E0106.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,53 @@\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```compile_fail,E0106\n+struct Foo1 { x: &bool }\n+              // ^ expected lifetime parameter\n+struct Foo2<'a> { x: &'a bool } // correct\n+\n+struct Bar1 { x: Foo2 }\n+              // ^^^^ expected lifetime parameter\n+struct Bar2<'a> { x: Foo2<'a> } // correct\n+\n+enum Baz1 { A(u8), B(&bool), }\n+                  // ^ expected lifetime parameter\n+enum Baz2<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr1 = &str;\n+           // ^ expected lifetime parameter\n+type MyStr2<'a> = &'a str; // correct\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```compile_fail,E0106\n+// error, no input lifetimes\n+fn foo() -> &str { }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { }\n+```\n+\n+[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision"}, {"sha": "3a8acba061c81d5d2241373f07abeb04b863f1b6", "filename": "src/librustc_error_codes/error_codes/E0107.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+This error means that an incorrect number of generic arguments were provided:\n+\n+```compile_fail,E0107\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }             // error: wrong number of type arguments:\n+                                  //        expected 1, found 0\n+struct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n+                                  //        expected 1, found 2\n+\n+fn foo<T, U>(x: T, y: U) {}\n+\n+fn main() {\n+    let x: bool = true;\n+    foo::<bool>(x);                 // error: wrong number of type arguments:\n+                                    //        expected 2, found 1\n+    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n+                                    //        expected 2, found 3\n+}\n+\n+fn f() {}\n+\n+fn main() {\n+    f::<'static>(); // error: wrong number of lifetime arguments:\n+                    //        expected 0, found 1\n+}\n+```\n+"}, {"sha": "5bc229ade52f471abe53cb60effb5c511edf6203", "filename": "src/librustc_error_codes/error_codes/E0109.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+You tried to provide a generic argument to a type which doesn't need it.\n+Erroneous code example:\n+\n+```compile_fail,E0109\n+type X = u32<i32>; // error: type arguments are not allowed for this type\n+type Y = bool<'static>; // error: lifetime parameters are not allowed on\n+                        //        this type\n+```\n+\n+Check that you used the correct argument and that the definition is correct.\n+\n+Example:\n+\n+```\n+type X = u32; // ok!\n+type Y = bool; // ok!\n+```\n+\n+Note that generic arguments for enum variant constructors go after the variant,\n+not after the enum. For example, you would write `Option::None::<u32>`,\n+rather than `Option::<u32>::None`."}, {"sha": "b9fe406ffb9bdb0a0c8c222d15a4f5dfde8c44cb", "filename": "src/librustc_error_codes/error_codes/E0110.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0110.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0110.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0110.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,4 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You tried to provide a lifetime to a type which doesn't need it.\n+See `E0109` for more details."}, {"sha": "27759a423433fa0eb50a47bc7c9497c28575a9a4", "filename": "src/librustc_error_codes/error_codes/E0116.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+You can only define an inherent implementation for a type in the same crate\n+where the type was defined. For example, an `impl` block as below is not allowed\n+since `Vec` is defined in the standard library:\n+\n+```compile_fail,E0116\n+impl Vec<u8> { } // error\n+```\n+\n+To fix this problem, you can do either of these things:\n+\n+ - define a trait that has the desired associated functions/types/constants and\n+   implement the trait for the type in question\n+ - define a new type wrapping the type and define an implementation on the new\n+   type\n+\n+Note that using the `type` keyword does not work here because `type` only\n+introduces a type alias:\n+\n+```compile_fail,E0116\n+type Bytes = Vec<u8>;\n+\n+impl Bytes { } // error, same as above\n+```"}, {"sha": "bd36230566262bc6527ef23ac42a41ddefe83a70", "filename": "src/librustc_error_codes/error_codes/E0117.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,48 @@\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule prohibits any implementation of a foreign trait (a\n+trait defined in another crate) where\n+\n+ - the type that is implementing the trait is foreign\n+ - all of the parameters being passed to the trait (if there are any) are also\n+   foreign.\n+\n+Here's one example of this error:\n+\n+```compile_fail,E0117\n+impl Drop for u32 {}\n+```\n+\n+To avoid this kind of error, ensure that at least one local type is referenced\n+by the `impl`:\n+\n+```\n+pub struct Foo; // you define your type in your crate\n+\n+impl Drop for Foo { // and you can implement the trait on it!\n+    // code of trait implementation here\n+#   fn drop(&mut self) { }\n+}\n+\n+impl From<Foo> for i32 { // or you use a type from your crate as\n+                         // a type parameter\n+    fn from(i: Foo) -> i32 {\n+        0\n+    }\n+}\n+```\n+\n+Alternatively, define a trait locally and implement that instead:\n+\n+```\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for u32 {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md"}, {"sha": "baf35ffbb0b530facae434b1c59b45a71b30c314", "filename": "src/librustc_error_codes/error_codes/E0118.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,41 @@\n+You're trying to write an inherent implementation for something which isn't a\n+struct nor an enum. Erroneous code example:\n+\n+```compile_fail,E0118\n+impl (u8, u8) { // error: no base type found for inherent implementation\n+    fn get_state(&self) -> String {\n+        // ...\n+    }\n+}\n+```\n+\n+To fix this error, please implement a trait on the type or wrap it in a struct.\n+Example:\n+\n+```\n+// we create a trait here\n+trait LiveLongAndProsper {\n+    fn get_state(&self) -> String;\n+}\n+\n+// and now you can implement it on (u8, u8)\n+impl LiveLongAndProsper for (u8, u8) {\n+    fn get_state(&self) -> String {\n+        \"He's dead, Jim!\".to_owned()\n+    }\n+}\n+```\n+\n+Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.\n+For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\n+Example:\n+\n+```\n+struct TypeWrapper((u8, u8));\n+\n+impl TypeWrapper {\n+    fn get_state(&self) -> String {\n+        \"Fascinating!\".to_owned()\n+    }\n+}\n+```"}, {"sha": "0af3bd4a0de796706224cd7a2c5b5189d66c7865", "filename": "src/librustc_error_codes/error_codes/E0119.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,58 @@\n+There are conflicting trait implementations for the same type.\n+Example of erroneous code:\n+\n+```compile_fail,E0119\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo {\n+    value: usize\n+}\n+\n+impl MyTrait for Foo { // error: conflicting implementations of trait\n+                       //        `MyTrait` for type `Foo`\n+    fn get(&self) -> usize { self.value }\n+}\n+```\n+\n+When looking for the implementation for the trait, the compiler finds\n+both the `impl<T> MyTrait for T` where T is all types and the `impl\n+MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n+this is an error. So, when you write:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+This makes the trait implemented on all types in the scope. So if you\n+try to implement it on another one after that, the implementations will\n+conflict. Example:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo;\n+\n+fn main() {\n+    let f = Foo;\n+\n+    f.get(); // the trait is implemented so we can use it\n+}\n+```"}, {"sha": "99c2a493a46b9ec7784b87191bedb2dfce6745ff", "filename": "src/librustc_error_codes/error_codes/E0120.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,36 @@\n+An attempt was made to implement Drop on a trait, which is not allowed: only\n+structs and enums can implement Drop. An example causing this error:\n+\n+```compile_fail,E0120\n+trait MyTrait {}\n+\n+impl Drop for MyTrait {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+A workaround for this problem is to wrap the trait up in a struct, and implement\n+Drop on that. An example is shown below:\n+\n+```\n+trait MyTrait {}\n+struct MyWrapper<T: MyTrait> { foo: T }\n+\n+impl <T: MyTrait> Drop for MyWrapper<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+```\n+\n+Alternatively, wrapping trait objects requires something like the following:\n+\n+```\n+trait MyTrait {}\n+\n+//or Box<MyTrait>, if you wanted an owned trait object\n+struct MyWrapper<'a> { foo: &'a MyTrait }\n+\n+impl <'a> Drop for MyWrapper<'a> {\n+    fn drop(&mut self) {}\n+}\n+```"}, {"sha": "069d0fc48fb0f7c4cf1b78a3f824ad7c7640438c", "filename": "src/librustc_error_codes/error_codes/E0121.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,10 @@\n+In order to be consistent with Rust's lack of global type inference,\n+type and const placeholders are disallowed by design in item signatures.\n+\n+Examples of this error include:\n+\n+```compile_fail,E0121\n+fn foo() -> _ { 5 } // error, explicitly write out the return type instead\n+\n+static BAR: _ = \"test\"; // error, explicitly write out the type instead\n+```"}, {"sha": "a7836526a7dd4f9eb5f0312528a7dd4381a3bb6a", "filename": "src/librustc_error_codes/error_codes/E0124.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0124.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0124.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0124.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+You declared two fields of a struct with the same name. Erroneous code\n+example:\n+\n+```compile_fail,E0124\n+struct Foo {\n+    field1: i32,\n+    field1: i32, // error: field is already declared\n+}\n+```\n+\n+Please verify that the field names have been correctly spelled. Example:\n+\n+```\n+struct Foo {\n+    field1: i32,\n+    field2: i32, // ok!\n+}\n+```"}, {"sha": "d0a4b32f9688e84ab983bed4ad65857d6494e9e2", "filename": "src/librustc_error_codes/error_codes/E0128.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0128.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0128.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+Type parameter defaults can only use parameters that occur before them.\n+Erroneous code example:\n+\n+```compile_fail,E0128\n+struct Foo<T = U, U = ()> {\n+    field1: T,\n+    field2: U,\n+}\n+// error: type parameters with a default cannot use forward declared\n+// identifiers\n+```\n+\n+Since type parameters are evaluated in-order, you may be able to fix this issue\n+by doing:\n+\n+```\n+struct Foo<U = (), T = U> {\n+    field1: T,\n+    field2: U,\n+}\n+```\n+\n+Please also verify that this wasn't because of a name-clash and rename the type\n+parameter if so."}, {"sha": "5273f3ad14f46a8f8388731329223d2ef398d6cd", "filename": "src/librustc_error_codes/error_codes/E0130.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,31 @@\n+You declared a pattern as an argument in a foreign function declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+extern {\n+    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n+                                //        function declarations\n+}\n+```\n+\n+Please replace the pattern argument with a regular one. Example:\n+\n+```\n+struct SomeStruct {\n+    a: u32,\n+    b: u32,\n+}\n+\n+extern {\n+    fn foo(s: SomeStruct); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+extern {\n+    fn foo(a: (u32, u32)); // ok!\n+}\n+```"}, {"sha": "a70a02925b0fb73bc3bcfab54d74f16af61970b4", "filename": "src/librustc_error_codes/error_codes/E0131.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0131.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0131.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0131.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,8 @@\n+It is not possible to define `main` with generic parameters.\n+When `main` is present, it must take no arguments and return `()`.\n+Erroneous code example:\n+\n+```compile_fail,E0131\n+fn main<T>() { // error: main function is not allowed to have generic parameters\n+}\n+```"}, {"sha": "a23cc988bdb66606e1f295ac63d55ba4dff75b7f", "filename": "src/librustc_error_codes/error_codes/E0132.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0132.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0132.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0132.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+A function with the `start` attribute was declared with type parameters.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0132\n+#![feature(start)]\n+\n+#[start]\n+fn f<T>() {}\n+```\n+\n+It is not possible to declare type parameters on a function that has the `start`\n+attribute. Such a function must have the following type signature (for more\n+information, view [the unstable book][1]):\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n+\n+```\n+# let _:\n+fn(isize, *const *const u8) -> isize;\n+```\n+\n+Example:\n+\n+```\n+#![feature(start)]\n+\n+#[start]\n+fn my_start(argc: isize, argv: *const *const u8) -> isize {\n+    0\n+}\n+```"}, {"sha": "0488cdd808d6c60f54167021c4b40cd9ba1b4f75", "filename": "src/librustc_error_codes/error_codes/E0133.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,31 @@\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}, {"sha": "c0e8c7e061cf594e2b31387507311d5dc584b78e", "filename": "src/librustc_error_codes/error_codes/E0136.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0136.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0136.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0136.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+A binary can only have one entry point, and by default that entry point is the\n+function `main()`. If there are multiple such functions, please rename one.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0136\n+fn main() {\n+    // ...\n+}\n+\n+// ...\n+\n+fn main() { // error!\n+    // ...\n+}\n+```"}, {"sha": "0a02913d2364d6716caba2ab49e45410edc00be2", "filename": "src/librustc_error_codes/error_codes/E0137.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0137.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0137.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0137.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+More than one function was declared with the `#[main]` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0137\n+#![feature(main)]\n+\n+#[main]\n+fn foo() {}\n+\n+#[main]\n+fn f() {} // error: multiple functions with a `#[main]` attribute\n+```\n+\n+This error indicates that the compiler found multiple functions with the\n+`#[main]` attribute. This is an error because there must be a unique entry\n+point into a Rust program. Example:\n+\n+```\n+#![feature(main)]\n+\n+#[main]\n+fn f() {} // ok!\n+```"}, {"sha": "3f5eaea9f989e6ab8afc72aae6ce6145186ebf80", "filename": "src/librustc_error_codes/error_codes/E0138.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0138.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0138.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0138.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+More than one function was declared with the `#[start]` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0138\n+#![feature(start)]\n+\n+#[start]\n+fn foo(argc: isize, argv: *const *const u8) -> isize {}\n+\n+#[start]\n+fn f(argc: isize, argv: *const *const u8) -> isize {}\n+// error: multiple 'start' functions\n+```\n+\n+This error indicates that the compiler found multiple functions with the\n+`#[start]` attribute. This is an error because there must be a unique entry\n+point into a Rust program. Example:\n+\n+```\n+#![feature(start)]\n+\n+#[start]\n+fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n+```"}, {"sha": "a116cf29395faa7168910465eee27e14f1c4b38e", "filename": "src/librustc_error_codes/error_codes/E0139.md", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0139.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0139.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0139.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,84 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+There are various restrictions on transmuting between types in Rust; for example\n+types being transmuted must have the same size. To apply all these restrictions,\n+the compiler must know the exact types that may be transmuted. When type\n+parameters are involved, this cannot always be done.\n+\n+So, for example, the following is not allowed:\n+\n+```\n+use std::mem::transmute;\n+\n+struct Foo<T>(Vec<T>);\n+\n+fn foo<T>(x: Vec<T>) {\n+    // we are transmuting between Vec<T> and Foo<F> here\n+    let y: Foo<T> = unsafe { transmute(x) };\n+    // do something with y\n+}\n+```\n+\n+In this specific case there's a good chance that the transmute is harmless (but\n+this is not guaranteed by Rust). However, when alignment and enum optimizations\n+come into the picture, it's quite likely that the sizes may or may not match\n+with different type parameter substitutions. It's not possible to check this for\n+_all_ possible types, so `transmute()` simply only accepts types without any\n+unsubstituted type parameters.\n+\n+If you need this, there's a good chance you're doing something wrong. Keep in\n+mind that Rust doesn't guarantee much about the layout of different structs\n+(even two structs with identical declarations may have different layouts). If\n+there is a solution that avoids the transmute entirely, try it instead.\n+\n+If it's possible, hand-monomorphize the code by writing the function for each\n+possible type substitution. It's possible to use traits to do this cleanly,\n+for example:\n+\n+```\n+use std::mem::transmute;\n+\n+struct Foo<T>(Vec<T>);\n+\n+trait MyTransmutableType: Sized {\n+    fn transmute(_: Vec<Self>) -> Foo<Self>;\n+}\n+\n+impl MyTransmutableType for u8 {\n+    fn transmute(x: Vec<u8>) -> Foo<u8> {\n+        unsafe { transmute(x) }\n+    }\n+}\n+\n+impl MyTransmutableType for String {\n+    fn transmute(x: Vec<String>) -> Foo<String> {\n+        unsafe { transmute(x) }\n+    }\n+}\n+\n+// ... more impls for the types you intend to transmute\n+\n+fn foo<T: MyTransmutableType>(x: Vec<T>) {\n+    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n+    // do something with y\n+}\n+```\n+\n+Each impl will be checked for a size match in the transmute as usual, and since\n+there are no unbound type parameters involved, this should compile unless there\n+is a size mismatch in one of the impls.\n+\n+It is also possible to manually transmute:\n+\n+```\n+# use std::ptr;\n+# let v = Some(\"value\");\n+# type SomeType = &'static [u8];\n+unsafe {\n+    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n+}\n+# ;\n+```\n+\n+Note that this does not move `v` (unlike `transmute`), and may need a\n+call to `mem::forget(v)` in case you want to avoid destructors being called."}, {"sha": "602dcb6e2c5b754fe6023a07c2f570145d5df02f", "filename": "src/librustc_error_codes/error_codes/E0152.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+A lang item was redefined.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0152\n+#![feature(lang_items)]\n+\n+#[lang = \"arc\"]\n+struct Foo; // error: duplicate lang item found: `arc`\n+```\n+\n+Lang items are already implemented in the standard library. Unless you are\n+writing a free-standing application (e.g., a kernel), you do not need to provide\n+them yourself.\n+\n+You can build a free-standing crate by adding `#![no_std]` to the crate\n+attributes:\n+\n+```ignore (only-for-syntax-highlight)\n+#![no_std]\n+```\n+\n+See also the [unstable book][1].\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib"}, {"sha": "725a775e72cca31ed2e21f7f8cfbdd49b36c384b", "filename": "src/librustc_error_codes/error_codes/E0154.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,33 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Imports (`use` statements) are not allowed after non-item statements, such as\n+variable declarations and expression statements.\n+\n+Here is an example that demonstrates the error:\n+\n+```\n+fn f() {\n+    // Variable declaration before import\n+    let x = 0;\n+    use std::io::Read;\n+    // ...\n+}\n+```\n+\n+The solution is to declare the imports at the top of the block, function, or\n+file.\n+\n+Here is the previous example again, with the correct order:\n+\n+```\n+fn f() {\n+    use std::io::Read;\n+    let x = 0;\n+    // ...\n+}\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+https://doc.rust-lang.org/reference.html#statements"}, {"sha": "0a9ef9c39385cc6aa18af1c4e22df9a05ba70179", "filename": "src/librustc_error_codes/error_codes/E0158.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0158.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0158.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0158.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,38 @@\n+An associated const has been referenced in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0158\n+enum EFoo { A, B, C, D }\n+\n+trait Foo {\n+    const X: EFoo;\n+}\n+\n+fn test<A: Foo>(arg: EFoo) {\n+    match arg {\n+        A::X => { // error!\n+            println!(\"A::X\");\n+        }\n+    }\n+}\n+```\n+\n+`const` and `static` mean different things. A `const` is a compile-time\n+constant, an alias for a literal value. This property means you can match it\n+directly within a pattern.\n+\n+The `static` keyword, on the other hand, guarantees a fixed location in memory.\n+This does not always mean that the value is constant. For example, a global\n+mutex can be declared `static` as well.\n+\n+If you want to match against a `static`, consider using a guard instead:\n+\n+```\n+static FORTY_TWO: i32 = 42;\n+\n+match Some(42) {\n+    Some(x) if x == FORTY_TWO => {}\n+    _ => {}\n+}\n+```"}, {"sha": "26269db2327ce73122d6713bef481f3d138d85b2", "filename": "src/librustc_error_codes/error_codes/E0161.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0161.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0161.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0161.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,30 @@\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0161\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```"}, {"sha": "98146147f3950da35f564707003d7e5701d64745", "filename": "src/librustc_error_codes/error_codes/E0162.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0162.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0162.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0162.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,26 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An if-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+if let Irrefutable(x) = irr {\n+    // This body will always be executed.\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+let Irrefutable(x) = irr;\n+println!(\"{}\", x);\n+```"}, {"sha": "b41ce6fad8e572fe2f0e0b045dd3f648989dcf00", "filename": "src/librustc_error_codes/error_codes/E0164.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0164.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0164.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0164.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+This error means that an attempt was made to match a struct type enum\n+variant as a non-struct type:\n+\n+```compile_fail,E0164\n+enum Foo { B { i: u32 } }\n+\n+fn bar(foo: Foo) -> u32 {\n+    match foo {\n+        Foo::B(i) => i, // error E0164\n+    }\n+}\n+```\n+\n+Try using `{}` instead:\n+\n+```\n+enum Foo { B { i: u32 } }\n+\n+fn bar(foo: Foo) -> u32 {\n+    match foo {\n+        Foo::B{i} => i,\n+    }\n+}\n+```"}, {"sha": "92243db455015404b2aa836aba97009f5b4e6072", "filename": "src/librustc_error_codes/error_codes/E0165.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0165.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0165.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0165.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A while-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n+\n+```no_run\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+while let Irrefutable(x) = irr {\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```no_run\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+loop {\n+    let Irrefutable(x) = irr;\n+    // ...\n+}\n+```"}, {"sha": "4b870dbf22155cc38fc676c8bbd4a7c6d2a63d1a", "filename": "src/librustc_error_codes/error_codes/E0170.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,46 @@\n+Enum variants are qualified by default. For example, given this type:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+```\n+\n+You would match it using:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+let m = Method::GET;\n+\n+match m {\n+    Method::GET => {},\n+    Method::POST => {},\n+}\n+```\n+\n+If you don't qualify the names, the code will bind new variables named \"GET\" and\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n+that happens.\n+\n+Qualified names are good practice, and most code works well with them. But if\n+you prefer them unqualified, you can import the variants into scope:\n+\n+```\n+use Method::*;\n+enum Method { GET, POST }\n+# fn main() {}\n+```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```\n+pub use Method::*;\n+pub enum Method { GET, POST }\n+# fn main() {}\n+```"}, {"sha": "07980ad83f1b5dc3c50080b28d65d940c18ed102", "filename": "src/librustc_error_codes/error_codes/E0178.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0178.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0178.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0178.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+In types, the `+` type operator has low precedence, so it is often necessary\n+to use parentheses.\n+\n+For example:\n+\n+```compile_fail,E0178\n+trait Foo {}\n+\n+struct Bar<'a> {\n+    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n+    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n+    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n+    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n+}\n+```\n+\n+More details can be found in [RFC 438].\n+\n+[RFC 438]: https://github.com/rust-lang/rfcs/pull/438"}, {"sha": "e7fa8dfd8313e7be690d7e42b3c246da49700a0a", "filename": "src/librustc_error_codes/error_codes/E0184.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0184.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0184.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0184.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,6 @@\n+Explicitly implementing both Drop and Copy for a type is currently disallowed.\n+This feature can make some sense in theory, but the current implementation is\n+incorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so\n+it has been disabled for now.\n+\n+[iss20126]: https://github.com/rust-lang/rust/issues/20126"}, {"sha": "f0ad2af144aa00fe42d92d47df79d0aa7b3f20f4", "filename": "src/librustc_error_codes/error_codes/E0185.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+An associated function for a trait was defined to be static, but an\n+implementation of the trait declared the same function to be a method (i.e., to\n+take a `self` parameter).\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0185\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, method `foo` has a `&self` declaration in the impl, but not in\n+    // the trait\n+    fn foo(&self) {}\n+}\n+```"}, {"sha": "9135d5c1d5e9ad13f16b78109f9abf0bf61a489f", "filename": "src/librustc_error_codes/error_codes/E0186.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0186.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0186.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0186.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+An associated function for a trait was defined to be a method (i.e., to take a\n+`self` parameter), but an implementation of the trait declared the same function\n+to be static.\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0186\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, method `foo` has a `&self` declaration in the trait, but not in\n+    // the impl\n+    fn foo() {}\n+}\n+```"}, {"sha": "b79196f6cec7a15c48e41987e5c3c79b8a01af95", "filename": "src/librustc_error_codes/error_codes/E0191.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0191.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0191.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0191.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+Trait objects need to have all associated types specified. Erroneous code\n+example:\n+\n+```compile_fail,E0191\n+trait Trait {\n+    type Bar;\n+}\n+\n+type Foo = Trait; // error: the value of the associated type `Bar` (from\n+                  //        the trait `Trait`) must be specified\n+```\n+\n+Please verify you specified all associated types of the trait and that you\n+used the right trait. Example:\n+\n+```\n+trait Trait {\n+    type Bar;\n+}\n+\n+type Foo = Trait<Bar=i32>; // ok!\n+```"}, {"sha": "33308868cb235caaeebb54f8ea5687b754763b32", "filename": "src/librustc_error_codes/error_codes/E0192.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0192.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0192.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0192.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,4 @@\n+Negative impls are only allowed for auto traits. For more\n+information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md"}, {"sha": "e29a949ffba919329b2bac68d8628716f432cb35", "filename": "src/librustc_error_codes/error_codes/E0193.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0193.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0193.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0193.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,44 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+`where` clauses must use generic type parameters: it does not make sense to use\n+them otherwise. An example causing this error:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+#[derive(Copy,Clone)]\n+struct Wrapper<T> {\n+    Wrapped: T\n+}\n+\n+impl Foo for Wrapper<u32> where Wrapper<u32>: Clone {\n+    fn bar(&self) { }\n+}\n+```\n+\n+This use of a `where` clause is strange - a more common usage would look\n+something like the following:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+#[derive(Copy,Clone)]\n+struct Wrapper<T> {\n+    Wrapped: T\n+}\n+impl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {\n+    fn bar(&self) { }\n+}\n+```\n+\n+Here, we're saying that the implementation exists on Wrapper only when the\n+wrapped type `T` implements `Clone`. The `where` clause is important because\n+some types will not implement `Clone`, and thus will not get this method.\n+\n+In our erroneous example, however, we're referencing a single concrete type.\n+Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no\n+reason to also specify it in a `where` clause."}, {"sha": "3606521020a11f1f3e4c8b96aa30c2b2ca9adc55", "filename": "src/librustc_error_codes/error_codes/E0195.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+Your method's lifetime parameters do not match the trait declaration.\n+Erroneous code example:\n+\n+```compile_fail,E0195\n+trait Trait {\n+    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n+}\n+\n+struct Foo;\n+\n+impl Trait for Foo {\n+    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n+    // error: lifetime parameters or bounds on method `bar`\n+    // do not match the trait declaration\n+    }\n+}\n+```\n+\n+The lifetime constraint `'b` for bar() implementation does not match the\n+trait declaration. Ensure lifetime declarations match exactly in both trait\n+declaration and implementation. Example:\n+\n+```\n+trait Trait {\n+    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n+}\n+\n+struct Foo;\n+\n+impl Trait for Foo {\n+    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n+    }\n+}\n+```"}, {"sha": "0d91157e572ccf3d51499c63b2f73f45162982e7", "filename": "src/librustc_error_codes/error_codes/E0197.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+Inherent implementations (one that do not implement a trait but provide\n+methods associated with a type) are always safe because they are not\n+implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n+implementation will resolve this error.\n+\n+```compile_fail,E0197\n+struct Foo;\n+\n+// this will cause this error\n+unsafe impl Foo { }\n+// converting it to this will fix it\n+impl Foo { }\n+```"}, {"sha": "6504d60dbd1d53d1abcb95433e9913f0941410a1", "filename": "src/librustc_error_codes/error_codes/E0198.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+A negative implementation is one that excludes a type from implementing a\n+particular trait. Not being able to use a trait is always a safe operation,\n+so negative implementations are always safe and never need to be marked as\n+unsafe.\n+\n+```compile_fail\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+// unsafe is unnecessary\n+unsafe impl !Clone for Foo { }\n+```\n+\n+This will compile:\n+\n+```ignore (ignore auto_trait future compatibility warning)\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+auto trait Enterprise {}\n+\n+impl !Enterprise for Foo { }\n+```\n+\n+Please note that negative impls are only allowed for auto traits."}, {"sha": "d0c12dc6f17550e4cbbecf4302c27af57e2e2382", "filename": "src/librustc_error_codes/error_codes/E0199.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+Safe traits should not have unsafe implementations, therefore marking an\n+implementation for a safe trait unsafe will cause a compiler error. Removing\n+the unsafe marker on the trait noted in the error will resolve this problem.\n+\n+```compile_fail,E0199\n+struct Foo;\n+\n+trait Bar { }\n+\n+// this won't compile because Bar is safe\n+unsafe impl Bar for Foo { }\n+// this will compile\n+impl Bar for Foo { }\n+```"}, {"sha": "865e91430ac44e7462ce9430df04c3c043ca9217", "filename": "src/librustc_error_codes/error_codes/E0200.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+Unsafe traits must have unsafe implementations. This error occurs when an\n+implementation for an unsafe trait isn't marked as unsafe. This may be resolved\n+by marking the unsafe implementation as unsafe.\n+\n+```compile_fail,E0200\n+struct Foo;\n+\n+unsafe trait Bar { }\n+\n+// this won't compile because Bar is unsafe and impl isn't unsafe\n+impl Bar for Foo { }\n+// this will compile\n+unsafe impl Bar for Foo { }\n+```"}, {"sha": "bdbf02f0033ab9dc111aaaf0d441a52265999908", "filename": "src/librustc_error_codes/error_codes/E0201.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0201.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0201.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0201.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,45 @@\n+It is an error to define two associated items (like methods, associated types,\n+associated functions, etc.) with the same identifier.\n+\n+For example:\n+\n+```compile_fail,E0201\n+struct Foo(u8);\n+\n+impl Foo {\n+    fn bar(&self) -> bool { self.0 > 5 }\n+    fn bar() {} // error: duplicate associated function\n+}\n+\n+trait Baz {\n+    type Quux;\n+    fn baz(&self) -> bool;\n+}\n+\n+impl Baz for Foo {\n+    type Quux = u32;\n+\n+    fn baz(&self) -> bool { true }\n+\n+    // error: duplicate method\n+    fn baz(&self) -> bool { self.0 > 5 }\n+\n+    // error: duplicate associated type\n+    type Quux = u32;\n+}\n+```\n+\n+Note, however, that items with the same name are allowed for inherent `impl`\n+blocks that don't overlap:\n+\n+```\n+struct Foo<T>(T);\n+\n+impl Foo<u8> {\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+\n+impl Foo<bool> {\n+    fn bar(&self) -> bool { self.0 }\n+}\n+```"}, {"sha": "b20d338c5fd99a2a64ae5c7d33c60a8a0d514439", "filename": "src/librustc_error_codes/error_codes/E0202.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,5 @@\n+Inherent associated types were part of [RFC 195] but are not yet implemented.\n+See [the tracking issue][iss8995] for the status of this implementation.\n+\n+[RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n+[iss8995]: https://github.com/rust-lang/rust/issues/8995"}, {"sha": "315690111359fde1b9a6859cc3f88a55f6fefb3e", "filename": "src/librustc_error_codes/error_codes/E0204.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0204.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0204.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0204.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+An attempt to implement the `Copy` trait for a struct failed because one of the\n+fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n+mentioned field. Note that this may not be possible, as in the example of\n+\n+```compile_fail,E0204\n+struct Foo {\n+    foo : Vec<u32>,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```compile_fail,E0204\n+#[derive(Copy)]\n+struct Foo<'a> {\n+    ty: &'a mut bool,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is always `Copy`)."}, {"sha": "7916f53ad3b411b5ba4695b5c3a9cefe22015af2", "filename": "src/librustc_error_codes/error_codes/E0205.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0205.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0205.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0205.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An attempt to implement the `Copy` trait for an enum failed because one of the\n+variants does not implement `Copy`. To fix this, you must implement `Copy` for\n+the mentioned variant. Note that this may not be possible, as in the example of\n+\n+```compile_fail,E0204\n+enum Foo {\n+    Bar(Vec<u32>),\n+    Baz,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```compile_fail,E0204\n+#[derive(Copy)]\n+enum Foo<'a> {\n+    Bar(&'a mut bool),\n+    Baz,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is always `Copy`)."}, {"sha": "fc4c0e07a16bf5ce9a26647d29ff4959f4cc10b7", "filename": "src/librustc_error_codes/error_codes/E0206.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0206.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0206.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0206.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,12 @@\n+You can only implement `Copy` for a struct or enum. Both of the following\n+examples will fail, because neither `[u8; 256]` nor `&'static mut Bar`\n+(mutable reference to `Bar`) is a struct or enum:\n+\n+```compile_fail,E0206\n+type Foo = [u8; 256];\n+impl Copy for Foo { } // error\n+\n+#[derive(Copy, Clone)]\n+struct Bar;\n+impl Copy for &'static mut Bar { } // error\n+```"}, {"sha": "67b2063504c07f550772dd8c815aacdbd4c058b7", "filename": "src/librustc_error_codes/error_codes/E0207.md", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,131 @@\n+Any type parameter or lifetime parameter of an `impl` must meet at least one of\n+the following criteria:\n+\n+ - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`\n+ - for a trait impl, it appears in the _implemented trait_, e.g.\n+   `impl<T> SomeTrait<T> for Foo`\n+ - it is bound as an associated type, e.g. `impl<T, U> SomeTrait for T\n+   where T: AnotherTrait<AssocType=U>`\n+\n+### Error example 1\n+\n+Suppose we have a struct `Foo` and we would like to define some methods for it.\n+The following definition leads to a compiler error:\n+\n+```compile_fail,E0207\n+struct Foo;\n+\n+impl<T: Default> Foo {\n+// error: the type parameter `T` is not constrained by the impl trait, self\n+// type, or predicates [E0207]\n+    fn get(&self) -> T {\n+        <T as Default>::default()\n+    }\n+}\n+```\n+\n+The problem is that the parameter `T` does not appear in the implementing type\n+(`Foo`) of the impl. In this case, we can fix the error by moving the type\n+parameter from the `impl` to the method `get`:\n+\n+\n+```\n+struct Foo;\n+\n+// Move the type parameter from the impl to the method\n+impl Foo {\n+    fn get<T: Default>(&self) -> T {\n+        <T as Default>::default()\n+    }\n+}\n+```\n+\n+### Error example 2\n+\n+As another example, suppose we have a `Maker` trait and want to establish a\n+type `FooMaker` that makes `Foo`s:\n+\n+```compile_fail,E0207\n+trait Maker {\n+    type Item;\n+    fn make(&mut self) -> Self::Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+struct FooMaker;\n+\n+impl<T: Default> Maker for FooMaker {\n+// error: the type parameter `T` is not constrained by the impl trait, self\n+// type, or predicates [E0207]\n+    type Item = Foo<T>;\n+\n+    fn make(&mut self) -> Foo<T> {\n+        Foo { foo: <T as Default>::default() }\n+    }\n+}\n+```\n+\n+This fails to compile because `T` does not appear in the trait or in the\n+implementing type.\n+\n+One way to work around this is to introduce a phantom type parameter into\n+`FooMaker`, like so:\n+\n+```\n+use std::marker::PhantomData;\n+\n+trait Maker {\n+    type Item;\n+    fn make(&mut self) -> Self::Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+// Add a type parameter to `FooMaker`\n+struct FooMaker<T> {\n+    phantom: PhantomData<T>,\n+}\n+\n+impl<T: Default> Maker for FooMaker<T> {\n+    type Item = Foo<T>;\n+\n+    fn make(&mut self) -> Foo<T> {\n+        Foo {\n+            foo: <T as Default>::default(),\n+        }\n+    }\n+}\n+```\n+\n+Another way is to do away with the associated type in `Maker` and use an input\n+type parameter instead:\n+\n+```\n+// Use a type parameter instead of an associated type here\n+trait Maker<Item> {\n+    fn make(&mut self) -> Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+struct FooMaker;\n+\n+impl<T: Default> Maker<Foo<T>> for FooMaker {\n+    fn make(&mut self) -> Foo<T> {\n+        Foo { foo: <T as Default>::default() }\n+    }\n+}\n+```\n+\n+### Additional information\n+\n+For more information, please see [RFC 447].\n+\n+[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md"}, {"sha": "f8ddaecc831416f15fc925df22a7a6c4d8b070e6", "filename": "src/librustc_error_codes/error_codes/E0210.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0210.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0210.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0210.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,69 @@\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule concerns the use of type parameters in an\n+implementation of a foreign trait (a trait defined in another crate), and\n+states that type parameters must be \"covered\" by a local type. To understand\n+what this means, it is perhaps easiest to consider a few examples.\n+\n+If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n+following trait `impl` is an error:\n+\n+```compile_fail,E0210\n+# #[cfg(for_demonstration_only)]\n+extern crate foo;\n+# #[cfg(for_demonstration_only)]\n+use foo::ForeignTrait;\n+# use std::panic::UnwindSafe as ForeignTrait;\n+\n+impl<T> ForeignTrait for T { } // error\n+# fn main() {}\n+```\n+\n+To work around this, it can be covered with a local type, `MyType`:\n+\n+```\n+# use std::panic::UnwindSafe as ForeignTrait;\n+struct MyType<T>(T);\n+impl<T> ForeignTrait for MyType<T> { } // Ok\n+```\n+\n+Please note that a type alias is not sufficient.\n+\n+For another example of an error, suppose there's another trait defined in `foo`\n+named `ForeignTrait2` that takes two type parameters. Then this `impl` results\n+in the same rule violation:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+struct MyType2;\n+impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n+```\n+\n+The reason for this is that there are two appearances of type parameter `T` in\n+the `impl` header, both as parameters for `ForeignTrait2`. The first appearance\n+is uncovered, and so runs afoul of the orphan rule.\n+\n+Consider one more example:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\n+```\n+\n+This only differs from the previous `impl` in that the parameters `T` and\n+`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*\n+violate the orphan rule; it is permitted.\n+\n+To see why that last example was allowed, you need to understand the general\n+rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n+\n+```ignore (only-for-syntax-highlight)\n+impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n+```\n+\n+where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\n+are types. One of the types `T0, ..., Tn` must be a local type (this is another\n+orphan rule, see the explanation for E0117). Let `i` be the smallest integer\n+such that `Ti` is a local type. Then no type parameter can appear in any of the\n+`Tj` for `j < i`.\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md"}, {"sha": "77289f019005ec0b7f4ea6e40116fc1b52ac4327", "filename": "src/librustc_error_codes/error_codes/E0211.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0211.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0211.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0211.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,79 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You used a function or type which doesn't fit the requirements for where it was\n+used. Erroneous code examples:\n+\n+```compile_fail\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T>(); // error: intrinsic has wrong type\n+}\n+\n+// or:\n+\n+fn main() -> i32 { 0 }\n+// error: main function expects type: `fn() {main}`: expected (), found i32\n+\n+// or:\n+\n+let x = 1u8;\n+match x {\n+    0u8..=3i8 => (),\n+    // error: mismatched types in range: expected u8, found i8\n+    _ => ()\n+}\n+\n+// or:\n+\n+use std::rc::Rc;\n+struct Foo;\n+\n+impl Foo {\n+    fn x(self: Rc<Foo>) {}\n+    // error: mismatched self type: expected `Foo`: expected struct\n+    //        `Foo`, found struct `alloc::rc::Rc`\n+}\n+```\n+\n+For the first code example, please check the function definition. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T>() -> usize; // ok!\n+}\n+```\n+\n+The second case example is a bit particular: the main function must always\n+have this definition:\n+\n+```compile_fail\n+fn main();\n+```\n+\n+They never take parameters and never return types.\n+\n+For the third example, when you match, all patterns must have the same type\n+as the type you're matching on. Example:\n+\n+```\n+let x = 1u8;\n+\n+match x {\n+    0u8..=3u8 => (), // ok!\n+    _ => ()\n+}\n+```\n+\n+And finally, for the last example, only `Box<Self>`, `&Self`, `Self`,\n+or `&mut Self` work as explicit self parameters. Example:\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn x(self: Box<Foo>) {} // ok!\n+}\n+```"}, {"sha": "f78c1c0cd01379d55323b00c5793544751e8e67c", "filename": "src/librustc_error_codes/error_codes/E0214.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0214.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0214.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0214.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,12 @@\n+A generic type was described using parentheses rather than angle brackets.\n+For example:\n+\n+```compile_fail,E0214\n+fn main() {\n+    let v: Vec(&str) = vec![\"foo\"];\n+}\n+```\n+\n+This is not currently supported: `v` should be defined as `Vec<&str>`.\n+Parentheses are currently only used with generic types when defining parameters\n+for `Fn`-family traits."}, {"sha": "43e075b522b4e8bca46bea34b162b0ef83178a65", "filename": "src/librustc_error_codes/error_codes/E0220.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0220.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0220.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0220.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,41 @@\n+You used an associated type which isn't defined in the trait.\n+Erroneous code example:\n+\n+```compile_fail,E0220\n+trait T1 {\n+    type Bar;\n+}\n+\n+type Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n+\n+// or:\n+\n+trait T2 {\n+    type Bar;\n+\n+    // error: Baz is used but not declared\n+    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n+}\n+```\n+\n+Make sure that you have defined the associated type in the trait body.\n+Also, verify that you used the right trait or you didn't misspell the\n+associated type name. Example:\n+\n+```\n+trait T1 {\n+    type Bar;\n+}\n+\n+type Foo = T1<Bar=i32>; // ok!\n+\n+// or:\n+\n+trait T2 {\n+    type Bar;\n+    type Baz; // we declare `Baz` in our trait.\n+\n+    // and now we can use it here:\n+    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n+}\n+```"}, {"sha": "53fabf490e2c30b8ae35fd612927d1e84606c967", "filename": "src/librustc_error_codes/error_codes/E0221.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0221.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0221.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0221.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,43 @@\n+An attempt was made to retrieve an associated type, but the type was ambiguous.\n+For example:\n+\n+```compile_fail,E0221\n+trait T1 {}\n+trait T2 {}\n+\n+trait Foo {\n+    type A: T1;\n+}\n+\n+trait Bar : Foo {\n+    type A: T2;\n+    fn do_something() {\n+        let _: Self::A;\n+    }\n+}\n+```\n+\n+In this example, `Foo` defines an associated type `A`. `Bar` inherits that type\n+from `Foo`, and defines another associated type of the same name. As a result,\n+when we attempt to use `Self::A`, it's ambiguous whether we mean the `A` defined\n+by `Foo` or the one defined by `Bar`.\n+\n+There are two options to work around this issue. The first is simply to rename\n+one of the types. Alternatively, one can specify the intended type using the\n+following syntax:\n+\n+```\n+trait T1 {}\n+trait T2 {}\n+\n+trait Foo {\n+    type A: T1;\n+}\n+\n+trait Bar : Foo {\n+    type A: T2;\n+    fn do_something() {\n+        let _: <Self as Bar>::A;\n+    }\n+}\n+```"}, {"sha": "9fe036042558760f36b40270340533f42528b775", "filename": "src/librustc_error_codes/error_codes/E0223.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0223.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0223.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0223.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+An attempt was made to retrieve an associated type, but the type was ambiguous.\n+For example:\n+\n+```compile_fail,E0223\n+trait MyTrait {type X; }\n+\n+fn main() {\n+    let foo: MyTrait::X;\n+}\n+```\n+\n+The problem here is that we're attempting to take the type of X from MyTrait.\n+Unfortunately, the type of X is not defined, because it's only made concrete in\n+implementations of the trait. A working version of this code might look like:\n+\n+```\n+trait MyTrait {type X; }\n+struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+    type X = u32;\n+}\n+\n+fn main() {\n+    let foo: <MyStruct as MyTrait>::X;\n+}\n+```\n+\n+This syntax specifies that we want the X type from MyTrait, as made concrete in\n+MyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\n+might implement two different traits with identically-named associated types.\n+This syntax allows disambiguation between the two."}, {"sha": "b9820dc68eeeb585382064d9d417ddfdc688984c", "filename": "src/librustc_error_codes/error_codes/E0225.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0225.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0225.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0225.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+You attempted to use multiple types as bounds for a closure or trait object.\n+Rust does not currently support this. A simple example that causes this error:\n+\n+```compile_fail,E0225\n+fn main() {\n+    let _: Box<dyn std::io::Read + std::io::Write>;\n+}\n+```\n+\n+Auto traits such as Send and Sync are an exception to this rule:\n+It's possible to have bounds of one non-builtin trait, plus any number of\n+auto traits. For example, the following compiles correctly:\n+\n+```\n+fn main() {\n+    let _: Box<dyn std::io::Read + Send + Sync>;\n+}\n+```"}, {"sha": "a8bd341a62ba0df9787126301203178cf3091a19", "filename": "src/librustc_error_codes/error_codes/E0229.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0229.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0229.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0229.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,36 @@\n+An associated type binding was done outside of the type parameter declaration\n+and `where` clause. Erroneous code example:\n+\n+```compile_fail,E0229\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for isize {\n+    type A = usize;\n+    fn boo(&self) -> usize { 42 }\n+}\n+\n+fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n+// error: associated type bindings are not allowed here\n+```\n+\n+To solve this error, please move the type bindings in the type parameter\n+declaration:\n+\n+```\n+# struct Bar;\n+# trait Foo { type A; }\n+fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n+```\n+\n+Or in the `where` clause:\n+\n+```\n+# struct Bar;\n+# trait Foo { type A; }\n+fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n+```"}, {"sha": "9dbcb8e010b1cd387afe78923c199bcf4d361e47", "filename": "src/librustc_error_codes/error_codes/E0230.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(rustc_attrs)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+There will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces contain an identifier which doesn't\n+match with any of the type parameters or the string `Self`. This might happen\n+if you misspelled a type parameter, or if you intended to use literal curly\n+braces. If it is the latter, escape the curly braces with a second curly brace\n+of the same type; e.g., a literal `{` is `{{`."}, {"sha": "4f80da54540b156515edb47fbcc6a9677250ff32", "filename": "src/librustc_error_codes/error_codes/E0231.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(rustc_attrs)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces do not contain an identifier. Please\n+add one of the same name as a type parameter. If you intended to use literal\n+braces, use `{{` and `}}` to escape them."}, {"sha": "07a031488d0917dd8e7b4c87b892bf1df3c40e59", "filename": "src/librustc_error_codes/error_codes/E0232.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(rustc_attrs)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+For this to work, some note must be specified. An empty attribute will not do\n+anything, please remove the attribute or add some helpful note for users of the\n+trait."}, {"sha": "5d3d1828bf59bc4e77e2afb160766e5f556910eb", "filename": "src/librustc_error_codes/error_codes/E0243.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0243.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0243.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0243.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that not enough type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below is defined to be generic in `T`, but the\n+type parameter is missing in the definition of `Bar`:\n+\n+```compile_fail,E0107\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }\n+```"}, {"sha": "5187b7b05d2c17e7b746a3729450325539d53bd6", "filename": "src/librustc_error_codes/error_codes/E0244.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0244.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0244.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0244.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that too many type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below has no type parameters, but is supplied\n+with two in the definition of `Bar`:\n+\n+```compile_fail,E0107\n+struct Foo { x: bool }\n+\n+struct Bar<S, T> { x: Foo<S, T> }\n+```"}, {"sha": "4121dd27877a024aaab180aca047e78be8e4e8cc", "filename": "src/librustc_error_codes/error_codes/E0251.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0251.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0251.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0251.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```"}, {"sha": "e678944650f6039bf8d4337c0dab505f3c721d03", "filename": "src/librustc_error_codes/error_codes/E0252.md", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0252.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0252.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0252.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,54 @@\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0252\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use foo::baz as foo_baz;\n+use bar::baz; // ok!\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+use bar::baz;\n+\n+fn main() {\n+    let x = foo::baz; // ok!\n+}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```"}, {"sha": "aea51d4023821b1442bb14314bcde82dd29388ed", "filename": "src/librustc_error_codes/error_codes/E0253.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0253.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0253.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0253.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+Attempt was made to import an unimportable value. This can happen when trying\n+to import a method from a trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0253\n+mod foo {\n+    pub trait MyTrait {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::MyTrait::do_something;\n+// error: `do_something` is not directly importable\n+\n+fn main() {}\n+```\n+\n+It's invalid to directly import methods belonging to a trait or concrete type."}, {"sha": "44383ed6eab28e245c5adac1ef2aa972a5cf1416", "filename": "src/librustc_error_codes/error_codes/E0254.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0254.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0254.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0254.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,36 @@\n+Attempt was made to import an item whereas an extern crate with this name has\n+already been imported.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0254\n+extern crate core;\n+\n+mod foo {\n+    pub trait core {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::core;  // error: an extern crate named `core` has already\n+                //        been imported in this module\n+\n+fn main() {}\n+```\n+\n+To fix this issue, you have to rename at least one of the two imports.\n+Example:\n+\n+```\n+extern crate core as libcore; // ok!\n+\n+mod foo {\n+    pub trait core {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::core;\n+\n+fn main() {}\n+```"}, {"sha": "83f5ec3dda4c39207b4debb3120e1c3ac6606dd2", "filename": "src/librustc_error_codes/error_codes/E0255.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0255.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0255.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0255.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,44 @@\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0255\n+use bar::foo; // error: an item named `foo` is already in scope\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use bar::foo as bar_foo; // ok!\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {\n+    bar::foo(); // we get the item by referring to its parent\n+}\n+```"}, {"sha": "385376cdade91ce0575dfd8259185ce9dd2f0fa8", "filename": "src/librustc_error_codes/error_codes/E0256.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0256.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0256.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0256.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```compile_fail\n+use foo::Bar; // error\n+\n+type Bar = u32;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```"}, {"sha": "8d8f93db30ff87a1efd54d2d0d47c40ab0f366fd", "filename": "src/librustc_error_codes/error_codes/E0259.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0259.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0259.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0259.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+The name chosen for an external crate conflicts with another external crate\n+that has been imported into the current module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0259\n+extern crate core;\n+extern crate std as core;\n+\n+fn main() {}\n+```\n+\n+The solution is to choose a different name that doesn't conflict with any\n+external crate imported into the current module.\n+\n+Correct example:\n+\n+```\n+extern crate core;\n+extern crate std as other_name;\n+\n+fn main() {}\n+```"}, {"sha": "4a36735ae764c20b236b40832205f194dd6aca43", "filename": "src/librustc_error_codes/error_codes/E0260.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+The name for an item declaration conflicts with an external crate's name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0260\n+extern crate core;\n+\n+struct core;\n+\n+fn main() {}\n+```\n+\n+There are two possible solutions:\n+\n+Solution #1: Rename the item.\n+\n+```\n+extern crate core;\n+\n+struct xyz;\n+```\n+\n+Solution #2: Import the crate with a different name.\n+\n+```\n+extern crate core as xyz;\n+\n+struct abc;\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+https://doc.rust-lang.org/reference.html#statements"}, {"sha": "21cf8e70452e0aae29f90a73553b870c4e7ff70c", "filename": "src/librustc_error_codes/error_codes/E0261.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0261.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0261.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0261.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,53 @@\n+When using a lifetime like `'a` in a type, it must be declared before being\n+used.\n+\n+These two examples illustrate the problem:\n+\n+```compile_fail,E0261\n+// error, use of undeclared lifetime name `'a`\n+fn foo(x: &'a str) { }\n+\n+struct Foo {\n+    // error, use of undeclared lifetime name `'a`\n+    x: &'a str,\n+}\n+```\n+\n+These can be fixed by declaring lifetime parameters:\n+\n+```\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+fn foo<'a>(x: &'a str) {}\n+```\n+\n+Impl blocks declare lifetime parameters separately. You need to add lifetime\n+parameters to an impl block if you're implementing a type that has a lifetime\n+parameter of its own.\n+For example:\n+\n+```compile_fail,E0261\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+// error,  use of undeclared lifetime name `'a`\n+impl Foo<'a> {\n+    fn foo<'a>(x: &'a str) {}\n+}\n+```\n+\n+This is fixed by declaring the impl block like this:\n+\n+```\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+// correct\n+impl<'a> Foo<'a> {\n+    fn foo(x: &'a str) {}\n+}\n+```"}, {"sha": "2dca6b1bb07814e53a3744f5dce5f5fb3d04796f", "filename": "src/librustc_error_codes/error_codes/E0262.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0262.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0262.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0262.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,8 @@\n+Declaring certain lifetime names in parameters is disallowed. For example,\n+because the `'static` lifetime is a special built-in lifetime name denoting\n+the lifetime of the entire program, this is an error:\n+\n+```compile_fail,E0262\n+// error, invalid lifetime parameter name `'static`\n+fn foo<'static>(x: &'static str) { }\n+```"}, {"sha": "bb4da43b3f58bd5e212dfbbe0b58aeb2c6230d0a", "filename": "src/librustc_error_codes/error_codes/E0263.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0263.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0263.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0263.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,7 @@\n+A lifetime name cannot be declared more than once in the same scope. For\n+example:\n+\n+```compile_fail,E0263\n+// error, lifetime name `'a` declared twice in the same scope\n+fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n+```"}, {"sha": "e1e7516cec2c79ef9d5d51bbfeaba61de9179861", "filename": "src/librustc_error_codes/error_codes/E0264.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+An unknown external lang item was used. Erroneous code example:\n+\n+```compile_fail,E0264\n+#![feature(lang_items)]\n+\n+extern \"C\" {\n+    #[lang = \"cake\"] // error: unknown external lang item: `cake`\n+    fn cake();\n+}\n+```\n+\n+A list of available external lang items is available in\n+`src/librustc/middle/weak_lang_items.rs`. Example:\n+\n+```\n+#![feature(lang_items)]\n+\n+extern \"C\" {\n+    #[lang = \"panic_impl\"] // ok!\n+    fn cake();\n+}\n+```"}, {"sha": "066ebee0ffb74162b82fd6e1c7e95e8d31aba0cc", "filename": "src/librustc_error_codes/error_codes/E0267.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0267.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0267.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0267.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+This error indicates the use of a loop keyword (`break` or `continue`) inside a\n+closure but outside of any loop. Erroneous code example:\n+\n+```compile_fail,E0267\n+let w = || { break; }; // error: `break` inside of a closure\n+```\n+\n+`break` and `continue` keywords can be used as normal inside closures as long as\n+they are also contained within a loop. To halt the execution of a closure you\n+should instead use a return statement. Example:\n+\n+```\n+let w = || {\n+    for _ in 0..10 {\n+        break;\n+    }\n+};\n+\n+w();\n+```"}, {"sha": "7f3ac1186018ad61453e84541c4a8e891b53053d", "filename": "src/librustc_error_codes/error_codes/E0268.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0268.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0268.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0268.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+This error indicates the use of a loop keyword (`break` or `continue`) outside\n+of a loop. Without a loop to break out of or continue in, no sensible action can\n+be taken. Erroneous code example:\n+\n+```compile_fail,E0268\n+fn some_func() {\n+    break; // error: `break` outside of a loop\n+}\n+```\n+\n+Please verify that you are using `break` and `continue` only in loops. Example:\n+\n+```\n+fn some_func() {\n+    for _ in 0..10 {\n+        break; // ok!\n+    }\n+}\n+```"}, {"sha": "4078598b394151194a668d306bdf7b9c4eecf3ec", "filename": "src/librustc_error_codes/error_codes/E0271.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,80 @@\n+This is because of a type mismatch between the associated type of some\n+trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n+and another type `U` that is required to be equal to `T::Bar`, but is not.\n+Examples follow.\n+\n+Here is a basic example:\n+\n+```compile_fail,E0271\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+\n+foo(3_i8);\n+```\n+\n+Here is that same example again, with some explanatory comments:\n+\n+```compile_fail,E0271\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n+//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n+//                        |            |\n+//         This says `foo` can         |\n+//           only be used with         |\n+//              some type that         |\n+//         implements `Trait`.         |\n+//                                     |\n+//                             This says not only must\n+//                             `T` be an impl of `Trait`\n+//                             but also that the impl\n+//                             must assign the type `u32`\n+//                             to the associated type.\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+//      |                             |\n+// `i8` does have                     |\n+// implementation                     |\n+// of `Trait`...                      |\n+//                     ... but it is an implementation\n+//                     that assigns `&'static str` to\n+//                     the associated type.\n+\n+foo(3_i8);\n+// Here, we invoke `foo` with an `i8`, which does not satisfy\n+// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n+// therefore the type-checker complains with this error code.\n+```\n+\n+To avoid those issues, you have to make the types match correctly.\n+So we can fix the previous examples like this:\n+\n+```\n+// Basic Example:\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+\n+foo(3_i8);\n+\n+// For-Loop Example:\n+let vs = vec![1, 2, 3, 4];\n+for v in &vs {\n+    match v {\n+        &1 => {}\n+        _ => {}\n+    }\n+}\n+```"}, {"sha": "836a9a95fa17b4470217659f0d6b962c5d4b3c63", "filename": "src/librustc_error_codes/error_codes/E0275.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+This error occurs when there was a recursive trait requirement that overflowed\n+before it could be evaluated. Often this means that there is unbounded\n+recursion in resolving some type bounds.\n+\n+For example, in the following code:\n+\n+```compile_fail,E0275\n+trait Foo {}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for T where Bar<T>: Foo {}\n+```\n+\n+To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n+to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n+determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\n+clearly a recursive requirement that can't be resolved directly.\n+\n+Consider changing your trait bounds so that they're less self-referential."}, {"sha": "0e3a613bf9c024e6ba725a5c02de7981fd0a577a", "filename": "src/librustc_error_codes/error_codes/E0276.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+This error occurs when a bound in an implementation of a trait does not match\n+the bounds specified in the original trait. For example:\n+\n+```compile_fail,E0276\n+trait Foo {\n+    fn foo<T>(x: T);\n+}\n+\n+impl Foo for bool {\n+    fn foo<T>(x: T) where T: Copy {}\n+}\n+```\n+\n+Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\n+take any type `T`. However, in the `impl` for `bool`, we have added an extra\n+bound that `T` is `Copy`, which isn't compatible with the original trait.\n+\n+Consider removing the bound from the method or adding the bound to the original\n+method definition in the trait."}, {"sha": "2034a5b988cbf711f25a2422a03eab0fbe89f6ab", "filename": "src/librustc_error_codes/error_codes/E0277.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,85 @@\n+You tried to use a type which doesn't implement some trait in a place which\n+expected that trait. Erroneous code example:\n+\n+```compile_fail,E0277\n+// here we declare the Foo trait with a bar method\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+// we now declare a function which takes an object implementing the Foo trait\n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar();\n+}\n+\n+fn main() {\n+    // we now call the method with the i32 type, which doesn't implement\n+    // the Foo trait\n+    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n+}\n+```\n+\n+In order to fix this error, verify that the type you're using does implement\n+the trait. Example:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar(); // we can now use this method since i32 implements the\n+               // Foo trait\n+}\n+\n+// we implement the trait on the i32 type\n+impl Foo for i32 {\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    some_func(5i32); // ok!\n+}\n+```\n+\n+Or in a generic context, an erroneous code example would look like:\n+\n+```compile_fail,E0277\n+fn some_func<T>(foo: T) {\n+    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n+                           //        implemented for the type `T`\n+}\n+\n+fn main() {\n+    // We now call the method with the i32 type,\n+    // which *does* implement the Debug trait.\n+    some_func(5i32);\n+}\n+```\n+\n+Note that the error here is in the definition of the generic function: Although\n+we only call it with a parameter that does implement `Debug`, the compiler\n+still rejects the function: It must work with all possible input types. In\n+order to make this example compile, we need to restrict the generic type we're\n+accepting:\n+\n+```\n+use std::fmt;\n+\n+// Restrict the input type to types that implement Debug.\n+fn some_func<T: fmt::Debug>(foo: T) {\n+    println!(\"{:?}\", foo);\n+}\n+\n+fn main() {\n+    // Calling the method is still fine, as i32 implements Debug.\n+    some_func(5i32);\n+\n+    // This would fail to compile now:\n+    // struct WithoutDebug;\n+    // some_func(WithoutDebug);\n+}\n+```\n+\n+Rust only looks at the signature of the called function, as such it must\n+already specify all requirements that will be used for every type parameter."}, {"sha": "1a9796d2790ea262f013f46fdbe9ad86051d32c9", "filename": "src/librustc_error_codes/error_codes/E0281.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You tried to supply a type which doesn't implement some trait in a location\n+which expected that trait. This error typically occurs when working with\n+`Fn`-based types. Erroneous code example:\n+\n+```compile-fail\n+fn foo<F: Fn(usize)>(x: F) { }\n+\n+fn main() {\n+    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,\n+    // but the trait `core::ops::Fn<(usize,)>` is required\n+    // [E0281]\n+    foo(|y: String| { });\n+}\n+```\n+\n+The issue in this case is that `foo` is defined as accepting a `Fn` with one\n+argument of type `String`, but the closure we attempted to pass to it requires\n+one arguments of type `usize`."}, {"sha": "54a9de0025a3d6f51a02e68b6a6dfdfb47594f46", "filename": "src/librustc_error_codes/error_codes/E0282.md", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,65 @@\n+This error indicates that type inference did not result in one unique possible\n+type, and extra information is required. In most cases this can be provided\n+by adding a type annotation. Sometimes you need to specify a generic type\n+parameter manually.\n+\n+A common example is the `collect` method on `Iterator`. It has a generic type\n+parameter with a `FromIterator` bound, which for a `char` iterator is\n+implemented by `Vec` and `String` among others. Consider the following snippet\n+that reverses the characters of a string:\n+\n+```compile_fail,E0282\n+let x = \"hello\".chars().rev().collect();\n+```\n+\n+In this case, the compiler cannot infer what the type of `x` should be:\n+`Vec<char>` and `String` are both suitable candidates. To specify which type to\n+use, you can use a type annotation on `x`:\n+\n+```\n+let x: Vec<char> = \"hello\".chars().rev().collect();\n+```\n+\n+It is not necessary to annotate the full type. Once the ambiguity is resolved,\n+the compiler can infer the rest:\n+\n+```\n+let x: Vec<_> = \"hello\".chars().rev().collect();\n+```\n+\n+Another way to provide the compiler with enough information, is to specify the\n+generic type parameter:\n+\n+```\n+let x = \"hello\".chars().rev().collect::<Vec<char>>();\n+```\n+\n+Again, you need not specify the full type if the compiler can infer it:\n+\n+```\n+let x = \"hello\".chars().rev().collect::<Vec<_>>();\n+```\n+\n+Apart from a method or function with a generic type parameter, this error can\n+occur when a type parameter of a struct or trait cannot be inferred. In that\n+case it is not always possible to use a type annotation, because all candidates\n+have the same return type. For instance:\n+\n+```compile_fail,E0282\n+struct Foo<T> {\n+    num: T,\n+}\n+\n+impl<T> Foo<T> {\n+    fn bar() -> i32 {\n+        0\n+    }\n+\n+    fn baz() {\n+        let number = Foo::bar();\n+    }\n+}\n+```\n+\n+This will fail because the compiler does not know which instance of `Foo` to\n+call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error."}, {"sha": "075f8b2e3bb80975e5e1ca862b932aa661a86708", "filename": "src/librustc_error_codes/error_codes/E0283.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,49 @@\n+This error occurs when the compiler doesn't have enough information\n+to unambiguously choose an implementation.\n+\n+For example:\n+\n+```compile_fail,E0283\n+trait Generator {\n+    fn create() -> u32;\n+}\n+\n+struct Impl;\n+\n+impl Generator for Impl {\n+    fn create() -> u32 { 1 }\n+}\n+\n+struct AnotherImpl;\n+\n+impl Generator for AnotherImpl {\n+    fn create() -> u32 { 2 }\n+}\n+\n+fn main() {\n+    let cont: u32 = Generator::create();\n+    // error, impossible to choose one of Generator trait implementation\n+    // Should it be Impl or AnotherImpl, maybe something else?\n+}\n+```\n+\n+To resolve this error use the concrete type:\n+\n+```\n+trait Generator {\n+    fn create() -> u32;\n+}\n+\n+struct AnotherImpl;\n+\n+impl Generator for AnotherImpl {\n+    fn create() -> u32 { 2 }\n+}\n+\n+fn main() {\n+    let gen1 = AnotherImpl::create();\n+\n+    // if there are multiple methods with same name (different traits)\n+    let gen2 = <AnotherImpl as Generator>::create();\n+}\n+```"}, {"sha": "a1ffa2bda0050c267a917ef365e9dcaa8fc048e1", "filename": "src/librustc_error_codes/error_codes/E0284.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0284.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0284.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0284.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,42 @@\n+This error occurs when the compiler is unable to unambiguously infer the\n+return type of a function or method which is generic on return type, such\n+as the `collect` method for `Iterator`s.\n+\n+For example:\n+\n+```compile_fail,E0284\n+fn foo() -> Result<bool, ()> {\n+    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n+    let v: Vec<bool> = results.collect()?;\n+    // Do things with v...\n+    Ok(true)\n+}\n+```\n+\n+Here we have an iterator `results` over `Result<bool, ()>`.\n+Hence, `results.collect()` can return any type implementing\n+`FromIterator<Result<bool, ()>>`. On the other hand, the\n+`?` operator can accept any type implementing `Try`.\n+\n+The author of this code probably wants `collect()` to return a\n+`Result<Vec<bool>, ()>`, but the compiler can't be sure\n+that there isn't another type `T` implementing both `Try` and\n+`FromIterator<Result<bool, ()>>` in scope such that\n+`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\n+is returned.\n+\n+To resolve this error, use a concrete type for the intermediate expression:\n+\n+```\n+fn foo() -> Result<bool, ()> {\n+    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n+    let v = {\n+        let temp: Result<Vec<bool>, ()> = results.collect();\n+        temp?\n+    };\n+    // Do things with v...\n+    Ok(true)\n+}\n+```\n+\n+Note that the type of `v` can now be inferred from the type of `temp`."}, {"sha": "66c31376d8b2851d234446221daeb2504ec183d1", "filename": "src/librustc_error_codes/error_codes/E0297.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0297.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0297.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0297.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,40 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Patterns used to bind names must be irrefutable. That is, they must guarantee\n+that a name will be extracted in all cases. Instead of pattern matching the\n+loop variable, consider using a `match` or `if let` inside the loop body. For\n+instance:\n+\n+```compile_fail,E0005\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+// This fails because `None` is not covered.\n+for Some(x) in xs {\n+    // ...\n+}\n+```\n+\n+Match inside the loop instead:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    match item {\n+        Some(x) => {},\n+        None => {},\n+    }\n+}\n+```\n+\n+Or use `if let`:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    if let Some(x) = item {\n+        // ...\n+    }\n+}\n+```"}, {"sha": "485e19fbb8d9c2a394a0d4176f8b9c94f55fb939", "filename": "src/librustc_error_codes/error_codes/E0301.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0301.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0301.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0301.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,17 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Mutable borrows are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if mutable\n+borrows were allowed:\n+\n+```compile_fail,E0596\n+match Some(()) {\n+    None => { },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```"}, {"sha": "e6ac9d590c88f920eb0d64ddf886229b5270215f", "filename": "src/librustc_error_codes/error_codes/E0302.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0302.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0302.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0302.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,15 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Assignments are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if assignments\n+were allowed:\n+\n+```compile_fail,E0594\n+match Some(()) {\n+    None => { },\n+    option if { option = None; false } => { },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```"}, {"sha": "20a6c078f4fa279bee7779da3e323f1068a0d32c", "filename": "src/librustc_error_codes/error_codes/E0303.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+Before:\n+\n+```compile_fail,E0303\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(s) => {},\n+    None => {},\n+}\n+```\n+\n+After:\n+\n+```\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(s);\n+        // ...\n+    },\n+    None => {},\n+}\n+```\n+\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n+\n+See also https://github.com/rust-lang/rust/issues/14587"}, {"sha": "c382f406e4b5b247f101461960f733300eb31223", "filename": "src/librustc_error_codes/error_codes/E0307.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,78 @@\n+This error indicates that the `self` parameter in a method has an invalid\n+\"reciever type\".\n+\n+Methods take a special first parameter, of which there are three variants:\n+`self`, `&self`, and `&mut self`. These are syntactic sugar for\n+`self: Self`, `self: &Self`, and `self: &mut Self` respectively.\n+\n+```\n+# struct Foo;\n+trait Trait {\n+    fn foo(&self);\n+//         ^^^^^ `self` here is a reference to the receiver object\n+}\n+\n+impl Trait for Foo {\n+    fn foo(&self) {}\n+//         ^^^^^ the receiver type is `&Foo`\n+}\n+```\n+\n+The type `Self` acts as an alias to the type of the current trait\n+implementer, or \"receiver type\". Besides the already mentioned `Self`,\n+`&Self` and `&mut Self` valid receiver types, the following are also valid:\n+`self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, and `self: Pin<P>`\n+(where P is one of the previous types except `Self`). Note that `Self` can\n+also be the underlying implementing type, like `Foo` in the following\n+example:\n+\n+```\n+# struct Foo;\n+# trait Trait {\n+#     fn foo(&self);\n+# }\n+impl Trait for Foo {\n+    fn foo(self: &Foo) {}\n+}\n+```\n+\n+E0307 will be emitted by the compiler when using an invalid reciver type,\n+like in the following example:\n+\n+```compile_fail,E0307\n+# struct Foo;\n+# struct Bar;\n+# trait Trait {\n+#     fn foo(&self);\n+# }\n+impl Trait for Foo {\n+    fn foo(self: &Bar) {}\n+}\n+```\n+\n+The nightly feature [Arbintrary self types][AST] extends the accepted\n+set of receiver types to also include any type that can dereference to\n+`Self`:\n+\n+```\n+#![feature(arbitrary_self_types)]\n+\n+struct Foo;\n+struct Bar;\n+\n+// Because you can dereference `Bar` into `Foo`...\n+impl std::ops::Deref for Bar {\n+    type Target = Foo;\n+\n+    fn deref(&self) -> &Foo {\n+        &Foo\n+    }\n+}\n+\n+impl Foo {\n+    fn foo(self: Bar) {}\n+//         ^^^^^^^^^ ...it can be used as the receiver type\n+}\n+```\n+\n+[AST]: https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html"}, {"sha": "a907ca272970e0a3f72ee29cd3f8810f7e36e3ee", "filename": "src/librustc_error_codes/error_codes/E0308.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,17 @@\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \"I am not a number!\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```"}, {"sha": "73ce7407476f9d41edfcabb100689387510fbda3", "filename": "src/librustc_error_codes/error_codes/E0309.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,50 @@\n+The type definition contains some field whose type\n+requires an outlives annotation. Outlives annotations\n+(e.g., `T: 'a`) are used to guarantee that all the data in T is valid\n+for at least the lifetime `'a`. This scenario most commonly\n+arises when the type contains an associated type reference\n+like `<T as SomeTrait<'a>>::Output`, as shown in this example:\n+\n+```compile_fail,E0309\n+// This won't compile because the applicable impl of\n+// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n+// not have a matching where-clause.\n+struct Foo<'a, T> {\n+    foo: <T as SomeTrait<'a>>::Output,\n+}\n+\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T\n+where\n+    T: 'a,\n+{\n+    type Output = u32;\n+}\n+```\n+\n+Here, the where clause `T: 'a` that appears on the impl is not known to be\n+satisfied on the struct. To make this example compile, you have to add\n+a where-clause like `T: 'a` to the struct definition:\n+\n+```\n+struct Foo<'a, T>\n+where\n+    T: 'a,\n+{\n+    foo: <T as SomeTrait<'a>>::Output\n+}\n+\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T\n+where\n+    T: 'a,\n+{\n+    type Output = u32;\n+}\n+```"}, {"sha": "be87ccb114ad0ed78f7926b524194830a8df4104", "filename": "src/librustc_error_codes/error_codes/E0310.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+Types in type definitions have lifetimes associated with them that represent\n+how long the data stored within them is guaranteed to be live. This lifetime\n+must be as long as the data needs to be alive, and missing the constraint that\n+denotes this will cause this error.\n+\n+```compile_fail,E0310\n+// This won't compile because T is not constrained to the static lifetime\n+// the reference needs\n+struct Foo<T> {\n+    foo: &'static T\n+}\n+```\n+\n+This will compile, because it has the constraint on the type parameter:\n+\n+```\n+struct Foo<T: 'static> {\n+    foo: &'static T\n+}\n+```"}, {"sha": "cb090d0138221e85b1b253d3faf06e6873f62f6c", "filename": "src/librustc_error_codes/error_codes/E0312.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0312.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0312.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0312.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,30 @@\n+Reference's lifetime of borrowed content doesn't match the expected lifetime.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0312\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'static str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = maybestr.as_ref().unwrap();\n+        s  // Invalid lifetime!\n+    }\n+}\n+```\n+\n+To fix this error, either lessen the expected lifetime or find a way to not have\n+to use this reference outside of its current scope (by running the code directly\n+in the same block for example?):\n+\n+```\n+// In this case, we can fix the issue by switching from \"static\" lifetime to 'a\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = maybestr.as_ref().unwrap();\n+        s  // Ok!\n+    }\n+}\n+```"}, {"sha": "e31a2b56be37193a1832252a3bd82d59bb6cebd1", "filename": "src/librustc_error_codes/error_codes/E0317.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+This error occurs when an `if` expression without an `else` block is used in a\n+context where a type other than `()` is expected, for example a `let`\n+expression:\n+\n+```compile_fail,E0317\n+fn main() {\n+    let x = 5;\n+    let a = if x == 5 { 1 };\n+}\n+```\n+\n+An `if` expression without an `else` block has the type `()`, so this is a type\n+error. To resolve it, add an `else` block having the same type as the `if`\n+block."}, {"sha": "49cec94430bca8c229bd4c234f7e8c50a4bdfbed", "filename": "src/librustc_error_codes/error_codes/E0321.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+A cross-crate opt-out trait was implemented on something which wasn't a struct\n+or enum type. Erroneous code example:\n+\n+```compile_fail,E0321\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+impl !Sync for Foo {}\n+\n+unsafe impl Send for &'static Foo {}\n+// error: cross-crate traits with a default impl, like `core::marker::Send`,\n+//        can only be implemented for a struct/enum type, not\n+//        `&'static Foo`\n+```\n+\n+Only structs and enums are permitted to impl Send, Sync, and other opt-out\n+trait, and the struct or enum must be local to the current crate. So, for\n+example, `unsafe impl Send for Rc<Foo>` is not allowed."}, {"sha": "d2ee426763e7b1b60f7cb6a23b0d1b02aecf94a3", "filename": "src/librustc_error_codes/error_codes/E0322.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,4 @@\n+The `Sized` trait is a special trait built-in to the compiler for types with a\n+constant size known at compile-time. This trait is automatically implemented\n+for types as needed by the compiler, and it is currently disallowed to\n+explicitly implement it for a type."}, {"sha": "6d34c35f9cbb652caf4e9579c713d22ad8293148", "filename": "src/librustc_error_codes/error_codes/E0323.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,45 @@\n+An associated const was implemented when another trait item was expected.\n+Erroneous code example:\n+\n+```compile_fail,E0323\n+trait Foo {\n+    type N;\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    const N : u32 = 0;\n+    // error: item `N` is an associated const, which doesn't match its\n+    //        trait `<Bar as Foo>`\n+}\n+```\n+\n+Please verify that the associated const wasn't misspelled and the correct trait\n+was implemented. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    type N;\n+}\n+\n+impl Foo for Bar {\n+    type N = u32; // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+}\n+\n+impl Foo for Bar {\n+    const N : u32 = 0; // ok!\n+}\n+```"}, {"sha": "b8c9e596990c1e0907b7a09b7a15ce80841bce1d", "filename": "src/librustc_error_codes/error_codes/E0324.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,37 @@\n+A method was implemented when another trait item was expected. Erroneous\n+code example:\n+\n+```compile_fail,E0324\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+\n+    fn M();\n+}\n+\n+impl Foo for Bar {\n+    fn N() {}\n+    // error: item `N` is an associated method, which doesn't match its\n+    //        trait `<Bar as Foo>`\n+}\n+```\n+\n+To fix this error, please verify that the method name wasn't misspelled and\n+verify that you are indeed implementing the correct trait items. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+\n+    fn M();\n+}\n+\n+impl Foo for Bar {\n+    const N : u32 = 0;\n+\n+    fn M() {} // ok!\n+}\n+```"}, {"sha": "f685b92cbf0644ce833bb2e80b8130da1c86e4bb", "filename": "src/librustc_error_codes/error_codes/E0325.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,45 @@\n+An associated type was implemented when another trait item was expected.\n+Erroneous code example:\n+\n+```compile_fail,E0325\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+}\n+\n+impl Foo for Bar {\n+    type N = u32;\n+    // error: item `N` is an associated type, which doesn't match its\n+    //        trait `<Bar as Foo>`\n+}\n+```\n+\n+Please verify that the associated type name wasn't misspelled and your\n+implementation corresponds to the trait definition. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    type N;\n+}\n+\n+impl Foo for Bar {\n+    type N = u32; // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+}\n+\n+impl Foo for Bar {\n+    const N : u32 = 0; // ok!\n+}\n+```"}, {"sha": "0702d00c2de55119cb272b822f3f8d9116f206f2", "filename": "src/librustc_error_codes/error_codes/E0326.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+The types of any associated constants in a trait implementation must match the\n+types in the trait definition. This error indicates that there was a mismatch.\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0326\n+trait Foo {\n+    const BAR: bool;\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    const BAR: u32 = 5; // error, expected bool, found u32\n+}\n+```"}, {"sha": "83909235455655ff2ff1e6499043ebaee8212a65", "filename": "src/librustc_error_codes/error_codes/E0328.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0328.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0328.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0328.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+The Unsize trait should not be implemented directly. All implementations of\n+Unsize are provided automatically by the compiler.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0328\n+#![feature(unsize)]\n+\n+use std::marker::Unsize;\n+\n+pub struct MyType;\n+\n+impl<T> Unsize<T> for MyType {}\n+```\n+\n+If you are defining your own smart pointer type and would like to enable\n+conversion from a sized to an unsized type with the\n+[DST coercion system][RFC 982], use [`CoerceUnsized`] instead.\n+\n+```\n+#![feature(coerce_unsized)]\n+\n+use std::ops::CoerceUnsized;\n+\n+pub struct MyType<T: ?Sized> {\n+    field_with_unsized_type: T,\n+}\n+\n+impl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+[RFC 982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+[`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"}, {"sha": "37d84a1a89bfe1881919a03f804980903477e1dc", "filename": "src/librustc_error_codes/error_codes/E0329.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0329.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0329.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0329.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,40 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An attempt was made to access an associated constant through either a generic\n+type parameter or `Self`. This is not supported yet. An example causing this\n+error is shown below:\n+\n+```\n+trait Foo {\n+    const BAR: f64;\n+}\n+\n+struct MyStruct;\n+\n+impl Foo for MyStruct {\n+    const BAR: f64 = 0f64;\n+}\n+\n+fn get_bar_bad<F: Foo>(t: F) -> f64 {\n+    F::BAR\n+}\n+```\n+\n+Currently, the value of `BAR` for a particular type can only be accessed\n+through a concrete type, as shown below:\n+\n+```\n+trait Foo {\n+    const BAR: f64;\n+}\n+\n+struct MyStruct;\n+\n+impl Foo for MyStruct {\n+    const BAR: f64 = 0f64;\n+}\n+\n+fn get_bar_good() -> f64 {\n+    <MyStruct as Foo>::BAR\n+}\n+```"}, {"sha": "0cca8f58b17cfa2cfd799de245356cc47974807c", "filename": "src/librustc_error_codes/error_codes/E0364.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+Private items cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a type or value that was not itself public.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+mod foo {\n+    const X: u32 = 1;\n+}\n+\n+pub use foo::X;\n+\n+fn main() {}\n+```\n+\n+The solution to this problem is to ensure that the items that you are\n+re-exporting are themselves marked with `pub`:\n+\n+```\n+mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo::X;\n+\n+fn main() {}\n+```\n+\n+See the 'Use Declarations' section of the reference for more information on\n+this topic:\n+\n+https://doc.rust-lang.org/reference.html#use-declarations"}, {"sha": "8f90d949e303799d81e5d9180836487d4f4c9c6a", "filename": "src/librustc_error_codes/error_codes/E0365.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+Private modules cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a module that was not itself public.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0365\n+mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo as foo2;\n+\n+fn main() {}\n+```\n+\n+The solution to this problem is to ensure that the module that you are\n+re-exporting is itself marked with `pub`:\n+\n+```\n+pub mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo as foo2;\n+\n+fn main() {}\n+```\n+\n+See the 'Use Declarations' section of the reference for more information\n+on this topic:\n+\n+https://doc.rust-lang.org/reference.html#use-declarations"}, {"sha": "e6f8e61893b7b1425e7efa34b3ad9fd61f27de9e", "filename": "src/librustc_error_codes/error_codes/E0366.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0366.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0366.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0366.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,30 @@\n+An attempt was made to implement `Drop` on a concrete specialization of a\n+generic type. An example is shown below:\n+\n+```compile_fail,E0366\n+struct Foo<T> {\n+    t: T\n+}\n+\n+impl Drop for Foo<u32> {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+This code is not legal: it is not possible to specialize `Drop` to a subset of\n+implementations of a generic type. One workaround for this is to wrap the\n+generic type, as shown below:\n+\n+```\n+struct Foo<T> {\n+    t: T\n+}\n+\n+struct Bar {\n+    t: Foo<u32>\n+}\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {}\n+}\n+```"}, {"sha": "7d661b2f0338863a32f3fbdb91ea39fa10ec4632", "filename": "src/librustc_error_codes/error_codes/E0367.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,35 @@\n+An attempt was made to implement `Drop` on a specialization of a generic type.\n+An example is shown below:\n+\n+```compile_fail,E0367\n+trait Foo{}\n+\n+struct MyStruct<T> {\n+    t: T\n+}\n+\n+impl<T: Foo> Drop for MyStruct<T> {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+This code is not legal: it is not possible to specialize `Drop` to a subset of\n+implementations of a generic type. In order for this code to work, `MyStruct`\n+must also require that `T` implements `Foo`. Alternatively, another option is\n+to wrap the generic type in another that specializes appropriately:\n+\n+```\n+trait Foo{}\n+\n+struct MyStruct<T> {\n+    t: T\n+}\n+\n+struct MyStructWrapper<T: Foo> {\n+    t: MyStruct<T>\n+}\n+\n+impl <T: Foo> Drop for MyStructWrapper<T> {\n+    fn drop(&mut self) {}\n+}\n+```"}, {"sha": "0bb283258c463b769b01b36bf7a1a69e8f3ab985", "filename": "src/librustc_error_codes/error_codes/E0368.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,47 @@\n+This error indicates that a binary assignment operator like `+=` or `^=` was\n+applied to a type that doesn't support it. For example:\n+\n+```compile_fail,E0368\n+let mut x = 12f32; // error: binary operation `<<` cannot be applied to\n+                   //        type `f32`\n+\n+x <<= 2;\n+```\n+\n+To fix this error, please check that this type implements this binary\n+operation. Example:\n+\n+```\n+let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n+\n+x <<= 2; // ok!\n+```\n+\n+It is also possible to overload most operators for your own type by\n+implementing the `[OP]Assign` traits from `std::ops`.\n+\n+Another problem you might be facing is this: suppose you've overloaded the `+`\n+operator for some type `Foo` by implementing the `std::ops::Add` trait for\n+`Foo`, but you find that using `+=` does not work, as in this example:\n+\n+```compile_fail,E0368\n+use std::ops::Add;\n+\n+struct Foo(u32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, rhs: Foo) -> Foo {\n+        Foo(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Foo = Foo(5);\n+    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\n+}\n+```\n+\n+This is because `AddAssign` is not automatically implemented, so you need to\n+manually implement it for your type."}, {"sha": "08db342428c23e3b0dbd3c7d3995dd83202a1f2d", "filename": "src/librustc_error_codes/error_codes/E0369.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+A binary operation was attempted on a type which doesn't support it.\n+Erroneous code example:\n+\n+```compile_fail,E0369\n+let x = 12f32; // error: binary operation `<<` cannot be applied to\n+               //        type `f32`\n+\n+x << 2;\n+```\n+\n+To fix this error, please check that this type implements this binary\n+operation. Example:\n+\n+```\n+let x = 12u32; // the `u32` type does implement it:\n+               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n+\n+x << 2; // ok!\n+```\n+\n+It is also possible to overload most operators for your own type by\n+implementing traits from `std::ops`.\n+\n+String concatenation appends the string on the right to the string on the\n+left and may require reallocation. This requires ownership of the string\n+on the left. If something should be added to a string literal, move the\n+literal to the heap by allocating it with `to_owned()` like in\n+`\"Your text\".to_owned()`.\n+"}, {"sha": "a3d280fc6dccc3b2f207cee58b7eecebaace8f6e", "filename": "src/librustc_error_codes/error_codes/E0370.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,33 @@\n+The maximum value of an enum was reached, so it cannot be automatically\n+set in the next enum value. Erroneous code example:\n+\n+```compile_fail,E0370\n+#[repr(i64)]\n+enum Foo {\n+    X = 0x7fffffffffffffff,\n+    Y, // error: enum discriminant overflowed on value after\n+       //        9223372036854775807: i64; set explicitly via\n+       //        Y = -9223372036854775808 if that is desired outcome\n+}\n+```\n+\n+To fix this, please set manually the next enum value or put the enum variant\n+with the maximum value at the end of the enum. Examples:\n+\n+```\n+#[repr(i64)]\n+enum Foo {\n+    X = 0x7fffffffffffffff,\n+    Y = 0, // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+#[repr(i64)]\n+enum Foo {\n+    Y = 0, // ok!\n+    X = 0x7fffffffffffffff,\n+}\n+```"}, {"sha": "9363cddb1dd476b02a87e81a937c976b13d3def9", "filename": "src/librustc_error_codes/error_codes/E0371.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,17 @@\n+When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\n+definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n+`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\n+definition, so it is not useful to do this.\n+\n+Example:\n+\n+```compile_fail,E0371\n+trait Foo { fn foo(&self) { } }\n+trait Bar: Foo { }\n+trait Baz: Bar { }\n+\n+impl Bar for Baz { } // error, `Baz` implements `Bar` by definition\n+impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\n+impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\n+impl Baz for Bar { } // Note: This is OK\n+```"}, {"sha": "47e3a48f0317247a653dd707c1b4bc49b8134ff8", "filename": "src/librustc_error_codes/error_codes/E0373.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0373.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0373.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0373.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,48 @@\n+This error occurs when an attempt is made to use data captured by a closure,\n+when that data may no longer exist. It's most commonly seen when attempting to\n+return a closure:\n+\n+```compile_fail,E0373\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(|y| x + y)\n+}\n+```\n+\n+Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n+closed-over data by reference. This means that once `foo()` returns, `x` no\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n+\n+Another situation where this might be encountered is when spawning threads:\n+\n+```compile_fail,E0373\n+fn foo() {\n+    let x = 0u32;\n+    let y = 1u32;\n+\n+    let thr = std::thread::spawn(|| {\n+        x + y\n+    });\n+}\n+```\n+\n+Since our new thread runs in parallel, the stack frame containing `x` and `y`\n+may well have disappeared by the time we try to use them. Even if we call\n+`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n+stack frame won't disappear), we will not succeed: the compiler cannot prove\n+that this behaviour is safe, and so won't let us do it.\n+\n+The solution to this problem is usually to switch to using a `move` closure.\n+This approach moves (or copies, where possible) data into the closure, rather\n+than taking references to it. For example:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(move |y| x + y)\n+}\n+```\n+\n+Now that the closure has its own copy of the data, there's no need to worry\n+about safety."}, {"sha": "0e1a4bf8099a047b9c91dd933919c1a8a1955be0", "filename": "src/librustc_error_codes/error_codes/E0374.md", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0374.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0374.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0374.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,55 @@\n+A struct without a field containing an unsized type cannot implement\n+`CoerceUnsized`. An [unsized type][1] is any type that the compiler\n+doesn't know the length or alignment of at compile time. Any struct\n+containing an unsized type is also unsized.\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0374\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+}\n+\n+// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.\n+impl<T, U> CoerceUnsized<Foo<U>> for Foo<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+`CoerceUnsized` is used to coerce one struct containing an unsized type\n+into another struct containing a different unsized type. If the struct\n+doesn't have any fields of unsized types then you don't need explicit\n+coercion to get the types you want. To fix this you can either\n+not try to implement `CoerceUnsized` or you can add a field that is\n+unsized to the struct.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+// We don't need to impl `CoerceUnsized` here.\n+struct Foo {\n+    a: i32,\n+}\n+\n+// We add the unsized type field to the struct.\n+struct Bar<T: ?Sized> {\n+    a: i32,\n+    b: T,\n+}\n+\n+// The struct has an unsized field so we can implement\n+// `CoerceUnsized` for it.\n+impl<T, U> CoerceUnsized<Bar<U>> for Bar<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+Note that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`\n+and `Arc` to be able to mark that they can coerce unsized types that they\n+are pointing at."}, {"sha": "31fcd85cb079f6d60e23a523f933e52b83130557", "filename": "src/librustc_error_codes/error_codes/E0375.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0375.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0375.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0375.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,52 @@\n+A struct with more than one field containing an unsized type cannot implement\n+`CoerceUnsized`. This only occurs when you are trying to coerce one of the\n+types in your struct to another type in the struct. In this case we try to\n+impl `CoerceUnsized` from `T` to `U` which are both types that the struct\n+takes. An [unsized type][1] is any type that the compiler doesn't know the\n+length or alignment of at compile time. Any struct containing an unsized type\n+is also unsized.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0375\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized, U: ?Sized> {\n+    a: i32,\n+    b: T,\n+    c: U,\n+}\n+\n+// error: Struct `Foo` has more than one unsized field.\n+impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\n+```\n+\n+`CoerceUnsized` only allows for coercion from a structure with a single\n+unsized type field to another struct with a single unsized type field.\n+In fact Rust only allows for a struct to have one unsized type in a struct\n+and that unsized type must be the last field in the struct. So having two\n+unsized types in a single struct is not allowed by the compiler. To fix this\n+use only one field containing an unsized type in the struct and then use\n+multiple structs to manage each unsized type field you need.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+    b: T,\n+}\n+\n+impl <T, U> CoerceUnsized<Foo<U>> for Foo<T>\n+    where T: CoerceUnsized<U> {}\n+\n+fn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {\n+    Foo { a: 12i32, b: t } // we use coercion to get the `Foo<U>` type we need\n+}\n+```\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait"}, {"sha": "b028aab45831f7612b12923ab28e0ffc9f834b8c", "filename": "src/librustc_error_codes/error_codes/E0376.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0376.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0376.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0376.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,45 @@\n+The type you are trying to impl `CoerceUnsized` for is not a struct.\n+`CoerceUnsized` can only be implemented for a struct. Unsized types are\n+already able to be coerced without an implementation of `CoerceUnsized`\n+whereas a struct containing an unsized type needs to know the unsized type\n+field it's containing is able to be coerced. An [unsized type][1]\n+is any type that the compiler doesn't know the length or alignment of at\n+compile time. Any struct containing an unsized type is also unsized.\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0376\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: T,\n+}\n+\n+// error: The type `U` is not a struct\n+impl<T, U> CoerceUnsized<U> for Foo<T> {}\n+```\n+\n+The `CoerceUnsized` trait takes a struct type. Make sure the type you are\n+providing to `CoerceUnsized` is a struct with only the last field containing an\n+unsized type.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T> {\n+    a: T,\n+}\n+\n+// The `Foo<U>` is a struct so `CoerceUnsized` can be implemented\n+impl<T, U> CoerceUnsized<Foo<U>> for Foo<T> where T: CoerceUnsized<U> {}\n+```\n+\n+Note that in Rust, structs can only contain an unsized type if the field\n+containing the unsized type is the last and only unsized type field in the\n+struct."}, {"sha": "311483c8900beaf3fb8652aa759af94e1db74d35", "filename": "src/librustc_error_codes/error_codes/E0378.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,57 @@\n+The `DispatchFromDyn` trait currently can only be implemented for\n+builtin pointer types and structs that are newtype wrappers around them\n+\u2014 that is, the struct must have only one field (except for`PhantomData`),\n+and that field must itself implement `DispatchFromDyn`.\n+\n+Examples:\n+\n+```\n+#![feature(dispatch_from_dyn, unsize)]\n+use std::{\n+    marker::Unsize,\n+    ops::DispatchFromDyn,\n+};\n+\n+struct Ptr<T: ?Sized>(*const T);\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T>\n+where\n+    T: Unsize<U>,\n+{}\n+```\n+\n+```\n+#![feature(dispatch_from_dyn)]\n+use std::{\n+    ops::DispatchFromDyn,\n+    marker::PhantomData,\n+};\n+\n+struct Wrapper<T> {\n+    ptr: T,\n+    _phantom: PhantomData<()>,\n+}\n+\n+impl<T, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```\n+\n+Example of illegal `DispatchFromDyn` implementation\n+(illegal because of extra field)\n+\n+```compile-fail,E0378\n+#![feature(dispatch_from_dyn)]\n+use std::ops::DispatchFromDyn;\n+\n+struct WrapperExtraField<T> {\n+    ptr: T,\n+    extra_stuff: i32,\n+}\n+\n+impl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```"}, {"sha": "3503da6ac2f7893958f957878da3d43f1d8e3f83", "filename": "src/librustc_error_codes/error_codes/E0379.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0379.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0379.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0379.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,4 @@\n+Trait methods cannot be declared `const` by design. For more information, see\n+[RFC 911].\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/pull/911"}, {"sha": "fe5de56933963183276a7b03aa5a2fdc95744e28", "filename": "src/librustc_error_codes/error_codes/E0380.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0380.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0380.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0380.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,4 @@\n+Auto traits cannot have methods or associated items.\n+For more information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md"}, {"sha": "976780099255f2de359812ac04eae381db2a7c7c", "filename": "src/librustc_error_codes/error_codes/E0381.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0381.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0381.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0381.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+It is not allowed to use or capture an uninitialized variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0381\n+fn main() {\n+    let x: i32;\n+    let y = x; // error, use of possibly-uninitialized variable\n+}\n+```\n+\n+To fix this, ensure that any declared variables are initialized before being\n+used. Example:\n+\n+```\n+fn main() {\n+    let x: i32 = 0;\n+    let y = x; // ok!\n+}\n+```"}, {"sha": "1592eac2ec5fb73f790e0caba00d3f7366414f20", "filename": "src/librustc_error_codes/error_codes/E0382.md", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,110 @@\n+This error occurs when an attempt is made to use a variable after its contents\n+have been moved elsewhere.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0382\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n+of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n+of workarounds like `Rc`, a value cannot be owned by more than one variable.\n+\n+Sometimes we don't need to move the value. Using a reference, we can let another\n+function borrow the value without changing its ownership. In the example below,\n+we don't actually have to move our string to `calculate_length`, we can give it\n+a reference to it with `&` instead.\n+\n+```\n+fn main() {\n+    let s1 = String::from(\"hello\");\n+\n+    let len = calculate_length(&s1);\n+\n+    println!(\"The length of '{}' is {}.\", s1, len);\n+}\n+\n+fn calculate_length(s: &String) -> usize {\n+    s.len()\n+}\n+```\n+\n+A mutable reference can be created with `&mut`.\n+\n+Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n+can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n+affect the original variable.\n+\n+Most types in the standard library are marked `Clone`. The example below\n+demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n+copied to `s2`. Then the first character of `s1` is removed, without affecting\n+`s2`. \"any many\" is printed to the console.\n+\n+```\n+fn main() {\n+    let mut s1 = String::from(\"many\");\n+    let s2 = s1.clone();\n+    s1.remove(0);\n+    println!(\"{} {}\", s1, s2);\n+}\n+```\n+\n+If we control the definition of a type, we can implement `Clone` on it ourselves\n+with `#[derive(Clone)]`.\n+\n+Some types have no ownership semantics at all and are trivial to duplicate. An\n+example is `i32` and the other number types. We don't have to call `.clone()` to\n+clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+cloning is more convenient in this case. We can mark our own types `Copy` if\n+all their members also are marked `Copy`.\n+\n+In the example below, we implement a `Point` type. Because it only stores two\n+integers, we opt-out of ownership semantics with `Copy`. Then we can\n+`let p2 = p1` without `p1` being moved.\n+\n+```\n+#[derive(Copy, Clone)]\n+struct Point { x: i32, y: i32 }\n+\n+fn main() {\n+    let mut p1 = Point{ x: -1, y: 2 };\n+    let p2 = p1;\n+    p1.x = 1;\n+    println!(\"p1: {}, {}\", p1.x, p1.y);\n+    println!(\"p2: {}, {}\", p2.x, p2.y);\n+}\n+```\n+\n+Alternatively, if we don't control the struct's definition, or mutable shared\n+ownership is truly required, we can use `Rc` and `RefCell`:\n+\n+```\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n+    let y = x.clone();\n+    x.borrow_mut().s = 6;\n+    println!(\"{}\", x.borrow().s);\n+}\n+```\n+\n+With this approach, x and y share ownership of the data via the `Rc` (reference\n+count type). `RefCell` essentially performs runtime borrow checking: ensuring\n+that at most one writer or multiple readers can access the data at any one time.\n+\n+If you wish to learn more about ownership in Rust, start with the chapter in the\n+Book:\n+\n+https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html"}, {"sha": "fd2b0b08fb007239d8e805caacc28c593b561958", "filename": "src/librustc_error_codes/error_codes/E0383.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0383.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0383.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0383.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to partially reinitialize a\n+structure that is currently uninitialized.\n+\n+For example, this can happen when a drop has taken place:\n+\n+```compile_fail\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x); // `x` is now uninitialized\n+x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n+```\n+\n+This error can be fixed by fully reinitializing the structure in question:\n+\n+```\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x);\n+x = Foo { a: 2 };\n+```"}, {"sha": "7c7ee744a8c89c692e4ac148af44a356566e1b23", "filename": "src/librustc_error_codes/error_codes/E0384.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0384.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0384.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0384.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,20 @@\n+This error occurs when an attempt is made to reassign an immutable variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0384\n+fn main() {\n+    let x = 3;\n+    x = 5; // error, reassignment of immutable variable\n+}\n+```\n+\n+By default, variables in Rust are immutable. To fix this error, add the keyword\n+`mut` after the keyword `let` when declaring the variable. For example:\n+\n+```\n+fn main() {\n+    let mut x = 3;\n+    x = 5;\n+}\n+```"}, {"sha": "de3b468b6e4acc3d74f40c08d67c4154af70a311", "filename": "src/librustc_error_codes/error_codes/E0386.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0386.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0386.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0386.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,31 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to mutate the target of a mutable\n+reference stored inside an immutable container.\n+\n+For example, this can happen when storing a `&mut` inside an immutable `Box`:\n+\n+```\n+let mut x: i64 = 1;\n+let y: Box<_> = Box::new(&mut x);\n+**y = 2; // error, cannot assign to data in an immutable container\n+```\n+\n+This error can be fixed by making the container mutable:\n+\n+```\n+let mut x: i64 = 1;\n+let mut y: Box<_> = Box::new(&mut x);\n+**y = 2;\n+```\n+\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n+\n+```\n+use std::cell::Cell;\n+\n+let x: i64 = 1;\n+let y: Box<Cell<_>> = Box::new(Cell::new(x));\n+y.set(2);\n+```"}, {"sha": "3a5facfdd25109c8b16e6a844cf8a2ce2ec8c3d4", "filename": "src/librustc_error_codes/error_codes/E0387.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,57 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to mutate or mutably reference data\n+that a closure has captured immutably.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+// Accepts a function or a closure that captures its environment immutably.\n+// Closures passed to foo will not be able to mutate their closed-over state.\n+fn foo<F: Fn()>(f: F) { }\n+\n+// Attempts to mutate closed-over data. Error message reads:\n+// `cannot assign to data in a captured outer variable...`\n+fn mutable() {\n+    let mut x = 0u32;\n+    foo(|| x = 2);\n+}\n+\n+// Attempts to take a mutable reference to closed-over data.  Error message\n+// reads: `cannot borrow data mutably in a captured outer variable...`\n+fn mut_addr() {\n+    let mut x = 0u32;\n+    foo(|| { let y = &mut x; });\n+}\n+```\n+\n+The problem here is that foo is defined as accepting a parameter of type `Fn`.\n+Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n+they capture their context immutably.\n+\n+If the definition of `foo` is under your control, the simplest solution is to\n+capture the data mutably. This can be done by defining `foo` to take FnMut\n+rather than Fn:\n+\n+```\n+fn foo<F: FnMut()>(f: F) { }\n+```\n+\n+Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n+\n+```\n+use std::cell::Cell;\n+\n+fn foo<F: Fn()>(f: F) { }\n+\n+fn mutable() {\n+    let x = Cell::new(0u32);\n+    foo(|| x.set(2));\n+}\n+```\n+\n+You can read more about cell types in the API documentation:\n+\n+https://doc.rust-lang.org/std/cell/"}, {"sha": "512fb42e6ecb5f8684d2a5a4d26382b4b5143b1d", "filename": "src/librustc_error_codes/error_codes/E0388.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0388.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0388.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0388.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1 @@\n+#### Note: this error code is no longer emitted by the compiler."}, {"sha": "9f064e44c820902ade4810905f20b1cfaa3c02f6", "filename": "src/librustc_error_codes/error_codes/E0389.md", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0389.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0389.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0389.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,63 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An attempt was made to mutate data using a non-mutable reference. This\n+commonly occurs when attempting to assign to a non-mutable reference of a\n+mutable reference (`&(&mut T)`).\n+\n+Erroneous code example:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+    let fancy_ref = &(&mut fancy);\n+    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n+immutable reference to a value borrows it immutably. There can be multiple\n+references of type `&(&mut T)` that point to the same value, so they must be\n+immutable to prevent multiple mutable references to the same value.\n+\n+To fix this, either remove the outer reference:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut fancy;\n+    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Or make the outer reference mutable:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut (&mut fancy);\n+    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```"}, {"sha": "9d05740d6f5ab1be7a8720580c32c9f296c4f157", "filename": "src/librustc_error_codes/error_codes/E0390.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0390.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0390.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0390.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+You tried to implement methods for a primitive type. Erroneous code example:\n+\n+```compile_fail,E0390\n+struct Foo {\n+    x: i32\n+}\n+\n+impl *mut Foo {}\n+// error: only a single inherent implementation marked with\n+//        `#[lang = \"mut_ptr\"]` is allowed for the `*mut T` primitive\n+```\n+\n+This isn't allowed, but using a trait to implement a method is a good solution.\n+Example:\n+\n+```\n+struct Foo {\n+    x: i32\n+}\n+\n+trait Bar {\n+    fn bar();\n+}\n+\n+impl Bar for *mut Foo {\n+    fn bar() {} // ok!\n+}\n+```"}, {"sha": "5db9ad16d08f700f5e590c2d6938fd1dcbbc820b", "filename": "src/librustc_error_codes/error_codes/E0391.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0391.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0391.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0391.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+This error indicates that some types or traits depend on each other\n+and therefore cannot be constructed.\n+\n+The following example contains a circular dependency between two traits:\n+\n+```compile_fail,E0391\n+trait FirstTrait : SecondTrait {\n+\n+}\n+\n+trait SecondTrait : FirstTrait {\n+\n+}\n+```"}, {"sha": "1d93e904e37fc8b694d08f3e64d5085bc9d2c460", "filename": "src/librustc_error_codes/error_codes/E0392.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0392.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0392.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0392.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,57 @@\n+This error indicates that a type or lifetime parameter has been declared\n+but not actually used. Here is an example that demonstrates the error:\n+\n+```compile_fail,E0392\n+enum Foo<T> {\n+    Bar,\n+}\n+```\n+\n+If the type parameter was included by mistake, this error can be fixed\n+by simply removing the type parameter, as shown below:\n+\n+```\n+enum Foo {\n+    Bar,\n+}\n+```\n+\n+Alternatively, if the type parameter was intentionally inserted, it must be\n+used. A simple fix is shown below:\n+\n+```\n+enum Foo<T> {\n+    Bar(T),\n+}\n+```\n+\n+This error may also commonly be found when working with unsafe code. For\n+example, when using raw pointers one may wish to specify the lifetime for\n+which the pointed-at data is valid. An initial attempt (below) causes this\n+error:\n+\n+```compile_fail,E0392\n+struct Foo<'a, T> {\n+    x: *const T,\n+}\n+```\n+\n+We want to express the constraint that Foo should not outlive `'a`, because\n+the data pointed to by `T` is only valid for that lifetime. The problem is\n+that there are no actual uses of `'a`. It's possible to work around this\n+by adding a PhantomData type to the struct, using it to tell the compiler\n+to act as if the struct contained a borrowed reference `&'a T`:\n+\n+```\n+use std::marker::PhantomData;\n+\n+struct Foo<'a, T: 'a> {\n+    x: *const T,\n+    phantom: PhantomData<&'a T>\n+}\n+```\n+\n+[PhantomData] can also be used to express information about unused type\n+parameters.\n+\n+[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html"}, {"sha": "7cce99401cf0c13144681e0b2a40bb3cf9ecb409", "filename": "src/librustc_error_codes/error_codes/E0393.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+A type parameter which references `Self` in its default value was not specified.\n+Example of erroneous code:\n+\n+```compile_fail,E0393\n+trait A<T=Self> {}\n+\n+fn together_we_will_rule_the_galaxy(son: &A) {}\n+// error: the type parameter `T` must be explicitly specified in an\n+//        object type because its default value `Self` references the\n+//        type `Self`\n+```\n+\n+A trait object is defined over a single, fully-defined trait. With a regular\n+default parameter, this parameter can just be substituted in. However, if the\n+default parameter is `Self`, the trait changes for each concrete type; i.e.\n+`i32` will be expected to implement `A<i32>`, `bool` will be expected to\n+implement `A<bool>`, etc... These types will not share an implementation of a\n+fully-defined trait; instead they share implementations of a trait with\n+different parameters substituted in for each implementation. This is\n+irreconcilable with what we need to make a trait object work, and is thus\n+disallowed. Making the trait concrete by explicitly specifying the value of the\n+defaulted parameter will fix this issue. Fixed example:\n+\n+```\n+trait A<T=Self> {}\n+\n+fn together_we_will_rule_the_galaxy(son: &A<i32>) {} // Ok!\n+```"}, {"sha": "75d86979e3c877332c798b61c7acdeda8b38da08", "filename": "src/librustc_error_codes/error_codes/E0398.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0398.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0398.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0398.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,35 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+In Rust 1.3, the default object lifetime bounds are expected to change, as\n+described in [RFC 1156]. You are getting a warning because the compiler\n+thinks it is possible that this change will cause a compilation error in your\n+code. It is possible, though unlikely, that this is a false alarm.\n+\n+The heart of the change is that where `&'a Box<SomeTrait>` used to default to\n+`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,\n+`SomeTrait` is the name of some trait type). Note that the only types which are\n+affected are references to boxes, like `&Box<SomeTrait>` or\n+`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\n+are unaffected.\n+\n+To silence this warning, edit your code to use an explicit bound. Most of the\n+time, this means that you will want to change the signature of a function that\n+you are calling. For example, if the error is reported on a call like `foo(x)`,\n+and `foo` is defined as follows:\n+\n+```\n+# trait SomeTrait {}\n+fn foo(arg: &Box<SomeTrait>) { /* ... */ }\n+```\n+\n+You might change it to:\n+\n+```\n+# trait SomeTrait {}\n+fn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }\n+```\n+\n+This explicitly states that you expect the trait object `SomeTrait` to contain\n+references (with a maximum lifetime of `'a`).\n+\n+[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md"}, {"sha": "71482c3ca64c8cdf3410dcc562407d00851d1078", "filename": "src/librustc_error_codes/error_codes/E0399.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,35 @@\n+You implemented a trait, overriding one or more of its associated types but did\n+not reimplement its default methods.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0399\n+#![feature(associated_type_defaults)]\n+\n+pub trait Foo {\n+    type Assoc = u8;\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for i32 {\n+    // error - the following trait items need to be reimplemented as\n+    //         `Assoc` was overridden: `bar`\n+    type Assoc = i32;\n+}\n+```\n+\n+To fix this, add an implementation for each default method from the trait:\n+\n+```\n+#![feature(associated_type_defaults)]\n+\n+pub trait Foo {\n+    type Assoc = u8;\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for i32 {\n+    type Assoc = i32;\n+    fn bar(&self) {} // ok!\n+}\n+```"}, {"sha": "4c93053d5f8b6210f0c40f6cf38a67a212f08b24", "filename": "src/librustc_error_codes/error_codes/E0401.md", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0401.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0401.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0401.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,106 @@\n+Inner items do not inherit type or const parameters from the functions\n+they are embedded in.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    fn bar(y: T) { // T is defined in the \"outer\" function\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+Nor will this:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    type MaybeT = Option<T>;\n+    // ...\n+}\n+```\n+\n+Or this:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    struct Foo {\n+        x: T,\n+    }\n+    // ...\n+}\n+```\n+\n+Items inside functions are basically just like top-level items, except\n+that they can only be used from the function they are in.\n+\n+There are a couple of solutions for this.\n+\n+If the item is a function, you may use a closure:\n+\n+```\n+fn foo<T>(x: T) {\n+    let bar = |y: T| { // explicit type annotation may not be necessary\n+        // ..\n+    };\n+    bar(x);\n+}\n+```\n+\n+For a generic item, you can copy over the parameters:\n+\n+```\n+fn foo<T>(x: T) {\n+    fn bar<T>(y: T) {\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+```\n+fn foo<T>(x: T) {\n+    type MaybeT<T> = Option<T>;\n+}\n+```\n+\n+Be sure to copy over any bounds as well:\n+\n+```\n+fn foo<T: Copy>(x: T) {\n+    fn bar<T: Copy>(y: T) {\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+```\n+fn foo<T: Copy>(x: T) {\n+    struct Foo<T: Copy> {\n+        x: T,\n+    }\n+}\n+```\n+\n+This may require additional type hints in the function body.\n+\n+In case the item is a function inside an `impl`, defining a private helper\n+function might be easier:\n+\n+```\n+# struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    pub fn foo(&self, x: T) {\n+        self.bar(x);\n+    }\n+\n+    fn bar(&self, y: T) {\n+        // ..\n+    }\n+}\n+```\n+\n+For default impls in traits, the private helper solution won't work, however\n+closures or copying the parameters should still work."}, {"sha": "5f4a40ce92e675ab7b6b66a53f8b0150aacb7f20", "filename": "src/librustc_error_codes/error_codes/E0403.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0403.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0403.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0403.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+Some type parameters have the same name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0403\n+fn f<T, T>(s: T, u: T) {} // error: the name `T` is already used for a generic\n+                          //        parameter in this item's generic parameters\n+```\n+\n+Please verify that none of the type parameters are misspelled, and rename any\n+clashing parameters. Example:\n+\n+```\n+fn f<T, Y>(s: T, u: Y) {} // ok!\n+```\n+\n+Type parameters in an associated item also cannot shadow parameters from the\n+containing item:\n+\n+```compile_fail,E0403\n+trait Foo<T> {\n+    fn do_something(&self) -> T;\n+    fn do_something_else<T: Clone>(&self, bar: T);\n+}\n+```"}, {"sha": "861a50bfd8c574c0dd29531640ec3e395a69d4b6", "filename": "src/librustc_error_codes/error_codes/E0404.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,44 @@\n+You tried to use something which is not a trait in a trait position, such as\n+a bound or `impl`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+struct Bar;\n+\n+impl Foo for Bar {} // error: `Foo` is not a trait\n+```\n+\n+Another erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+\n+fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n+```\n+\n+Please verify that you didn't misspell the trait's name or otherwise use the\n+wrong identifier. Example:\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+struct Bar;\n+\n+impl Foo for Bar { // ok!\n+    // functions implementation\n+}\n+```\n+\n+or\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+\n+fn bar<T: Foo>(t: T) {} // ok!\n+```\n+"}, {"sha": "ff1e8c0be8803cadfe63ba525d7ffe0332a5c802", "filename": "src/librustc_error_codes/error_codes/E0405.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0405.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0405.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0405.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+The code refers to a trait that is not in scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0405\n+struct Foo;\n+\n+impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n+```\n+\n+Please verify that the name of the trait wasn't misspelled and ensure that it\n+was imported. Example:\n+\n+```\n+# #[cfg(for_demonstration_only)]\n+// solution 1:\n+use some_file::SomeTrait;\n+\n+// solution 2:\n+trait SomeTrait {\n+    // some functions\n+}\n+\n+struct Foo;\n+\n+impl SomeTrait for Foo { // ok!\n+    // implements functions\n+}\n+```"}, {"sha": "fa26c77a1b0c4269852e26e7db544697cecf9bce", "filename": "src/librustc_error_codes/error_codes/E0407.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0407.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0407.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0407.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,52 @@\n+A definition of a method not in the implemented trait was given in a trait\n+implementation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0407\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // error: method `b` is not a member of trait `Foo`\n+}\n+```\n+\n+Please verify you didn't misspell the method name and you used the correct\n+trait. First example:\n+\n+```\n+trait Foo {\n+    fn a();\n+    fn b();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // ok!\n+}\n+```\n+\n+Second example:\n+\n+```\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+}\n+\n+impl Bar {\n+    fn b() {}\n+}\n+```"}, {"sha": "3acdbb740a37980ebe53633bc7a5c329b02690ab", "filename": "src/librustc_error_codes/error_codes/E0408.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0408.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0408.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0408.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,41 @@\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0408\n+match x {\n+    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n+                                      //        not bound in pattern #2\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound to the contents of the `Some` and can be used within the\n+block corresponding to the match arm. However, in case `x` is `None`, we have\n+not specified what `y` is, and the block will use a nonexistent variable.\n+\n+To fix this error, either split into multiple match arms:\n+\n+```\n+let x = Some(1);\n+match x {\n+    Some(y) => { /* use y */ }\n+    None => { /* ... */ }\n+}\n+```\n+\n+or, bind the variable to a field of the same type in all sub-patterns of the\n+or pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, y) | (y, 0) => { /* use y */}\n+    _ => {}\n+}\n+```\n+\n+In this example, if `x` matches the pattern `(0, _)`, the second field is set\n+to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\n+cases `y` is set to some value."}, {"sha": "53eb0fd0573ffcec8b25bfed23fb6b4b502eabfe", "filename": "src/librustc_error_codes/error_codes/E0409.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0409.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0409.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0409.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,38 @@\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0409\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n+                                          //        different mode in pattern #2\n+                                          //        than in pattern #1\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound by-value in one case and by-reference in the other.\n+\n+To fix this error, just use the same mode in both cases.\n+Generally using `ref` or `ref mut` where not already used will fix this:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (ref y, 0) => { /* use y */}\n+    _ => ()\n+}\n+```\n+\n+Alternatively, split the pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (y, 0) => { /* use y */ }\n+    (0, ref y) => { /* use y */}\n+    _ => ()\n+}\n+```"}, {"sha": "d82171533ae51c6bf1e3b88b9d7f423196fd81af", "filename": "src/librustc_error_codes/error_codes/E0411.md", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0411.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0411.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0411.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,56 @@\n+The `Self` keyword was used outside an impl, trait, or type definition.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0411\n+<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\n+             // definition\n+```\n+\n+The `Self` keyword represents the current type, which explains why it can only\n+be used inside an impl, trait, or type definition. It gives access to the\n+associated items of a type:\n+\n+```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Baz : Foo {\n+    fn bar() -> Self::Bar; // like this\n+}\n+```\n+\n+However, be careful when two types have a common associated type:\n+\n+```compile_fail\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n+trait Baz : Foo + Foo2 {\n+    fn bar() -> Self::Bar;\n+    // error: ambiguous associated type `Bar` in bounds of `Self`\n+}\n+```\n+\n+This problem can be solved by specifying from which trait we want to use the\n+`Bar` type:\n+\n+```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n+trait Baz : Foo + Foo2 {\n+    fn bar() -> <Self as Foo>::Bar; // ok!\n+}\n+```"}, {"sha": "60a09610d86f6bb639d705032f2df9b72f888d99", "filename": "src/librustc_error_codes/error_codes/E0412.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0412.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0412.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0412.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,64 @@\n+The type name used is not in scope.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0412\n+impl Something {} // error: type name `Something` is not in scope\n+\n+// or:\n+\n+trait Foo {\n+    fn bar(N); // error: type name `N` is not in scope\n+}\n+\n+// or:\n+\n+fn foo(x: T) {} // type name `T` is not in scope\n+```\n+\n+To fix this error, please verify you didn't misspell the type name, you did\n+declare it or imported it into the scope. Examples:\n+\n+```\n+struct Something;\n+\n+impl Something {} // ok!\n+\n+// or:\n+\n+trait Foo {\n+    type N;\n+\n+    fn bar(_: Self::N); // ok!\n+}\n+\n+// or:\n+\n+fn foo<T>(x: T) {} // ok!\n+```\n+\n+Another case that causes this error is when a type is imported into a parent\n+module. To fix this, you can follow the suggestion and use File directly or\n+`use super::File;` which will import the types from the parent namespace. An\n+example that causes this error is below:\n+\n+```compile_fail,E0412\n+use std::fs::File;\n+\n+mod foo {\n+    fn some_function(f: File) {}\n+}\n+```\n+\n+```\n+use std::fs::File;\n+\n+mod foo {\n+    // either\n+    use super::File;\n+    // or\n+    // use std::fs::File;\n+    fn foo(f: File) {}\n+}\n+# fn main() {} // don't insert it for us; that'll break imports\n+```"}, {"sha": "97d733a7b2dd76869ca65b5a2aab9f67bf3acb33", "filename": "src/librustc_error_codes/error_codes/E0415.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0415.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0415.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0415.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+More than one function parameter have the same name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0415\n+fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n+                          //        once in this parameter list\n+```\n+\n+Please verify you didn't misspell parameters' name. Example:\n+\n+```\n+fn foo(f: i32, g: i32) {} // ok!\n+```"}, {"sha": "7bc316dafc5fb3061a37f2524da890e3c6b6a0ec", "filename": "src/librustc_error_codes/error_codes/E0416.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0416.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0416.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0416.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+An identifier is bound more than once in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0416\n+match (1, 2) {\n+    (x, x) => {} // error: identifier `x` is bound more than once in the\n+                 //        same pattern\n+}\n+```\n+\n+Please verify you didn't misspell identifiers' name. Example:\n+\n+```\n+match (1, 2) {\n+    (x, y) => {} // ok!\n+}\n+```\n+\n+Or maybe did you mean to unify? Consider using a guard:\n+\n+```\n+# let (A, B, C) = (1, 2, 3);\n+match (A, B, C) {\n+    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n+    (y, z, see) => { /* A and B unequal; do another thing */ }\n+}\n+```"}, {"sha": "a91ea6a9e22f607ca58e6314ab5a6ad54743260f", "filename": "src/librustc_error_codes/error_codes/E0422.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0422.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0422.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0422.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+You are trying to use an identifier that is either undefined or not a struct.\n+Erroneous code example:\n+\n+```compile_fail,E0422\n+fn main () {\n+    let x = Foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `Foo` is undefined, so it inherently isn't anything, and\n+definitely not a struct.\n+\n+```compile_fail\n+fn main () {\n+    let foo = 1;\n+    let x = foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one."}, {"sha": "6a7c31f5e0d43095622831a26c18e24dcec4827d", "filename": "src/librustc_error_codes/error_codes/E0423.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0423.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0423.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0423.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,47 @@\n+An identifier was used like a function name or a value was expected and the\n+identifier exists but it belongs to a different namespace.\n+\n+For (an erroneous) example, here a `struct` variant name were used as a\n+function:\n+\n+```compile_fail,E0423\n+struct Foo { a: bool };\n+\n+let f = Foo();\n+// error: expected function, tuple struct or tuple variant, found `Foo`\n+// `Foo` is a struct name, but this expression uses it like a function name\n+```\n+\n+Please verify you didn't misspell the name of what you actually wanted to use\n+here. Example:\n+\n+```\n+fn Foo() -> u32 { 0 }\n+\n+let f = Foo(); // ok!\n+```\n+\n+It is common to forget the trailing `!` on macro invocations, which would also\n+yield this error:\n+\n+```compile_fail,E0423\n+println(\"\");\n+// error: expected function, tuple struct or tuple variant,\n+// found macro `println`\n+// did you mean `println!(...)`? (notice the trailing `!`)\n+```\n+\n+Another case where this error is emitted is when a value is expected, but\n+something else is found:\n+\n+```compile_fail,E0423\n+pub mod a {\n+    pub const I: i32 = 1;\n+}\n+\n+fn h1() -> i32 {\n+    a.I\n+    //~^ ERROR expected value, found module `a`\n+    // did you mean `a::I`?\n+}\n+```"}, {"sha": "a9f6f579b4275856925cc28c4af28fcca3d2d0d0", "filename": "src/librustc_error_codes/error_codes/E0424.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0424.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0424.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0424.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,40 @@\n+The `self` keyword was used inside of an associated function without a \"`self`\n+receiver\" parameter.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0424\n+struct Foo;\n+\n+impl Foo {\n+    // `bar` is a method, because it has a receiver parameter.\n+    fn bar(&self) {}\n+\n+    // `foo` is not a method, because it has no receiver parameter.\n+    fn foo() {\n+        self.bar(); // error: `self` value is a keyword only available in\n+                    //        methods with a `self` parameter\n+    }\n+}\n+```\n+\n+The `self` keyword can only be used inside methods, which are associated\n+functions (functions defined inside of a `trait` or `impl` block) that have a\n+`self` receiver as its first parameter, like `self`, `&self`, `&mut self` or\n+`self: &mut Pin<Self>` (this last one is an example of an [\"abitrary `self`\n+type\"](https://github.com/rust-lang/rust/issues/44874)).\n+\n+Check if the associated function's parameter list should have contained a `self`\n+receiver for it to be a method, and add it if so. Example:\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&self) {}\n+\n+    fn foo(self) { // `foo` is now a method.\n+        self.bar(); // ok!\n+    }\n+}\n+```"}, {"sha": "13e71b850657992df0d9b420f9cc31d946731d15", "filename": "src/librustc_error_codes/error_codes/E0425.md", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0425.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0425.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0425.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,60 @@\n+An unresolved name was used.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0425\n+something_that_doesnt_exist::foo;\n+// error: unresolved name `something_that_doesnt_exist::foo`\n+\n+// or:\n+\n+trait Foo {\n+    fn bar() {\n+        Self; // error: unresolved name `Self`\n+    }\n+}\n+\n+// or:\n+\n+let x = unknown_variable;  // error: unresolved name `unknown_variable`\n+```\n+\n+Please verify that the name wasn't misspelled and ensure that the\n+identifier being referred to is valid for the given situation. Example:\n+\n+```\n+enum something_that_does_exist {\n+    Foo,\n+}\n+```\n+\n+Or:\n+\n+```\n+mod something_that_does_exist {\n+    pub static foo : i32 = 0i32;\n+}\n+\n+something_that_does_exist::foo; // ok!\n+```\n+\n+Or:\n+\n+```\n+let unknown_variable = 12u32;\n+let x = unknown_variable; // ok!\n+```\n+\n+If the item is not defined in the current module, it must be imported using a\n+`use` statement, like so:\n+\n+```\n+# mod foo { pub fn bar() {} }\n+# fn main() {\n+use foo::bar;\n+bar();\n+# }\n+```\n+\n+If the item you are importing is not defined in some super-module of the\n+current module, then it must also be declared as public (e.g., `pub fn`)."}, {"sha": "15e7fb04738353ca95225555566ea5e1d9c5adc0", "filename": "src/librustc_error_codes/error_codes/E0426.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0426.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0426.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0426.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,17 @@\n+An undeclared label was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0426\n+loop {\n+    break 'a; // error: use of undeclared label `'a`\n+}\n+```\n+\n+Please verify you spelt or declare the label correctly. Example:\n+\n+```\n+'a: loop {\n+    break 'a; // ok!\n+}\n+```"}, {"sha": "38db0b4bcf96d28ae517dd01c80a0c3e8b9d94f0", "filename": "src/librustc_error_codes/error_codes/E0428.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0428.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0428.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0428.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+A type or module has been defined more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0428\n+struct Bar;\n+struct Bar; // error: duplicate definition of value `Bar`\n+```\n+\n+Please verify you didn't misspell the type/module's name or remove/rename the\n+duplicated one. Example:\n+\n+```\n+struct Bar;\n+struct Bar2; // ok!\n+```"}, {"sha": "8c5fd8624fdeaccc746814df6e6f201d74455a4e", "filename": "src/librustc_error_codes/error_codes/E0429.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0429.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0429.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0429.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+The `self` keyword cannot appear alone as the last segment in a `use`\n+declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0429\n+use std::fmt::self; // error: `self` imports are only allowed within a { } list\n+```\n+\n+To use a namespace itself in addition to some of its members, `self` may appear\n+as part of a brace-enclosed list of imports:\n+\n+```\n+use std::fmt::{self, Debug};\n+```\n+\n+If you only want to import the namespace, do so directly:\n+\n+```\n+use std::fmt;\n+```"}, {"sha": "8cca0f21e5943c97a6115ab661e3fde69cdad78a", "filename": "src/librustc_error_codes/error_codes/E0430.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0430.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0430.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0430.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+The `self` import appears more than once in the list.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0430\n+use something::{self, self}; // error: `self` import can only appear once in\n+                             //        the list\n+```\n+\n+Please verify you didn't misspell the import name or remove the duplicated\n+`self` import. Example:\n+\n+```\n+# mod something {}\n+# fn main() {\n+use something::{self}; // ok!\n+# }\n+```"}, {"sha": "1b70f5f1d7b7609ca09b91270c0accacf8ac24b6", "filename": "src/librustc_error_codes/error_codes/E0431.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0431.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0431.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0431.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,11 @@\n+An invalid `self` import was made.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0431\n+use {self}; // error: `self` import can only appear in an import list with a\n+            //        non-empty prefix\n+```\n+\n+You cannot import the current module into itself, please remove this import\n+or verify you didn't misspell it."}, {"sha": "b562a85b785ff37ec3bb5e3756cd191e83a7d4ca", "filename": "src/librustc_error_codes/error_codes/E0432.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0432.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0432.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0432.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+An import was unresolved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0432\n+use something::Foo; // error: unresolved import `something::Foo`.\n+```\n+\n+Paths in `use` statements are relative to the crate root. To import items\n+relative to the current and parent modules, use the `self::` and `super::`\n+prefixes, respectively. Also verify that you didn't misspell the import\n+name and that the import exists in the module from where you tried to\n+import it. Example:\n+\n+```\n+use self::something::Foo; // ok!\n+\n+mod something {\n+    pub struct Foo;\n+}\n+# fn main() {}\n+```\n+\n+Or, if you tried to use a module from an external crate, you may have missed\n+the `extern crate` declaration (which is usually placed in the crate root):\n+\n+```\n+extern crate core; // Required to use the `core` crate\n+\n+use core::any;\n+# fn main() {}\n+```"}, {"sha": "f9e333e8ccd00f001637fc0319978b917f82b194", "filename": "src/librustc_error_codes/error_codes/E0433.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0433.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0433.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0433.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,17 @@\n+An undeclared type or module was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0433\n+let map = HashMap::new();\n+// error: failed to resolve: use of undeclared type or module `HashMap`\n+```\n+\n+Please verify you didn't misspell the type/module's name or that you didn't\n+forget to import it:\n+\n+\n+```\n+use std::collections::HashMap; // HashMap has been imported.\n+let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n+```"}, {"sha": "e093f0796da5e6aae062b1fe926e4a1ed6099365", "filename": "src/librustc_error_codes/error_codes/E0434.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0434.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0434.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0434.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,42 @@\n+This error indicates that a variable usage inside an inner function is invalid\n+because the variable comes from a dynamic environment. Inner functions do not\n+have access to their containing environment.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0434\n+fn foo() {\n+    let y = 5;\n+    fn bar() -> u32 {\n+        y // error: can't capture dynamic environment in a fn item; use the\n+          //        || { ... } closure form instead.\n+    }\n+}\n+```\n+\n+Functions do not capture local variables. To fix this error, you can replace the\n+function with a closure:\n+\n+```\n+fn foo() {\n+    let y = 5;\n+    let bar = || {\n+        y\n+    };\n+}\n+```\n+\n+or replace the captured variable with a constant or a static item:\n+\n+```\n+fn foo() {\n+    static mut X: u32 = 4;\n+    const Y: u32 = 5;\n+    fn bar() -> u32 {\n+        unsafe {\n+            X = 3;\n+        }\n+        Y\n+    }\n+}\n+```"}, {"sha": "424e5ce1e2e5b99917ea4648b14a8e1dbe5eae56", "filename": "src/librustc_error_codes/error_codes/E0435.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0435.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0435.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0435.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+A non-constant value was used in a constant expression.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0435\n+let foo = 42;\n+let a: [u8; foo]; // error: attempt to use a non-constant value in a constant\n+```\n+\n+To fix this error, please replace the value with a constant. Example:\n+\n+```\n+let a: [u8; 42]; // ok!\n+```\n+\n+Or:\n+\n+```\n+const FOO: usize = 42;\n+let a: [u8; FOO]; // ok!\n+```"}, {"sha": "b1afd9e96033712013af5842784d682e15b1029f", "filename": "src/librustc_error_codes/error_codes/E0436.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,47 @@\n+The functional record update syntax is only allowed for structs. (Struct-like\n+enum variants don't qualify, for example.)\n+\n+Erroneous code example:\n+\n+```compile_fail,E0436\n+enum PublicationFrequency {\n+    Weekly,\n+    SemiMonthly { days: (u8, u8), annual_special: bool },\n+}\n+\n+fn one_up_competitor(competitor_frequency: PublicationFrequency)\n+                     -> PublicationFrequency {\n+    match competitor_frequency {\n+        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n+            days: (1, 15), annual_special: false\n+        },\n+        c @ PublicationFrequency::SemiMonthly{ .. } =>\n+            PublicationFrequency::SemiMonthly {\n+                annual_special: true, ..c // error: functional record update\n+                                          //        syntax requires a struct\n+        }\n+    }\n+}\n+```\n+\n+Rewrite the expression without functional record update syntax:\n+\n+```\n+enum PublicationFrequency {\n+    Weekly,\n+    SemiMonthly { days: (u8, u8), annual_special: bool },\n+}\n+\n+fn one_up_competitor(competitor_frequency: PublicationFrequency)\n+                     -> PublicationFrequency {\n+    match competitor_frequency {\n+        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n+            days: (1, 15), annual_special: false\n+        },\n+        PublicationFrequency::SemiMonthly{ days, .. } =>\n+            PublicationFrequency::SemiMonthly {\n+                days, annual_special: true // ok!\n+        }\n+    }\n+}\n+```"}, {"sha": "834cf33dbc7f0790b53bac15456d8a898ae4664e", "filename": "src/librustc_error_codes/error_codes/E0437.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+Trait implementations can only implement associated types that are members of\n+the trait in question. This error indicates that you attempted to implement\n+an associated type whose name does not match the name of any associated type\n+in the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0437\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    type Bar = bool;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated type:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```"}, {"sha": "cb141a5d24aeddda718ea69528e7c4dd4393008e", "filename": "src/librustc_error_codes/error_codes/E0438.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+Trait implementations can only implement associated constants that are\n+members of the trait in question. This error indicates that you\n+attempted to implement an associated constant whose name does not\n+match the name of any associated constant in the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0438\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    const BAR: bool = true;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated constant:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```"}, {"sha": "e6da2117ac5f2b64a468fabab81c81bb5534ad23", "filename": "src/librustc_error_codes/error_codes/E0439.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+The length of the platform-intrinsic function `simd_shuffle`\n+wasn't specified. Erroneous code example:\n+\n+```compile_fail,E0439\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n+    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`\n+}\n+```\n+\n+The `simd_shuffle` function needs the length of the array passed as\n+last parameter in its name. Example:\n+\n+```\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n+}\n+```"}, {"sha": "9cc62b2ba6d0afb88ebf021181d93ca672267c6d", "filename": "src/librustc_error_codes/error_codes/E0445.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0445.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0445.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0445.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+A private trait was used on a public type parameter bound.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0445\n+#![deny(private_in_public)]\n+\n+trait Foo {\n+    fn dummy(&self) { }\n+}\n+\n+pub trait Bar : Foo {} // error: private trait in public interface\n+pub struct Bar2<T: Foo>(pub T); // same error\n+pub fn foo<T: Foo> (t: T) {} // same error\n+```\n+\n+To solve this error, please ensure that the trait is also public. The trait\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`. Example:\n+\n+```\n+pub trait Foo { // we set the Foo trait public\n+    fn dummy(&self) { }\n+}\n+\n+pub trait Bar : Foo {} // ok!\n+pub struct Bar2<T: Foo>(pub T); // ok!\n+pub fn foo<T: Foo> (t: T) {} // ok!\n+```"}, {"sha": "d0144478dbfe0c617c7d00a7e54500adb0c90a3c", "filename": "src/librustc_error_codes/error_codes/E0446.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,30 @@\n+A private type was used in a public type signature.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0446\n+#![deny(private_in_public)]\n+\n+mod Foo {\n+    struct Bar(u32);\n+\n+    pub fn bar() -> Bar { // error: private type in public interface\n+        Bar(0)\n+    }\n+}\n+```\n+\n+To solve this error, please ensure that the type is also public. The type\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`.\n+Example:\n+\n+```\n+mod Foo {\n+    pub struct Bar(u32); // we set the Bar type public\n+\n+    pub fn bar() -> Bar { // ok!\n+        Bar(0)\n+    }\n+}\n+```"}, {"sha": "af8cd8d6d5202ebd748c03660fe02cfbc24703e2", "filename": "src/librustc_error_codes/error_codes/E0447.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0447.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0447.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0447.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,15 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+The `pub` keyword was used inside a function.\n+\n+Erroneous code example:\n+\n+```\n+fn foo() {\n+    pub struct Bar; // error: visibility has no effect inside functions\n+}\n+```\n+\n+Since we cannot access items defined inside a function, the visibility of its\n+items does not impact outer code. So using the `pub` keyword in this context\n+is invalid."}, {"sha": "ba096f9e984ae73ef9bdf19737d7dfab469926a8", "filename": "src/librustc_error_codes/error_codes/E0448.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0448.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0448.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0448.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+The `pub` keyword was used inside a public enum.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+pub enum Foo {\n+    pub Bar, // error: unnecessary `pub` visibility\n+}\n+```\n+\n+Since the enum is already public, adding `pub` on one its elements is\n+unnecessary. Example:\n+\n+```compile_fail\n+enum Foo {\n+    pub Bar, // not ok!\n+}\n+```\n+\n+This is the correct syntax:\n+\n+```\n+pub enum Foo {\n+    Bar, // ok!\n+}\n+```"}, {"sha": "a3eb51961d32e3a649b3ad11a5b14427cfed7b4c", "filename": "src/librustc_error_codes/error_codes/E0449.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0449.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0449.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0449.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,37 @@\n+A visibility qualifier was used when it was unnecessary. Erroneous code\n+examples:\n+\n+```compile_fail,E0449\n+struct Bar;\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+pub impl Bar {} // error: unnecessary visibility qualifier\n+\n+pub impl Foo for Bar { // error: unnecessary visibility qualifier\n+    pub fn foo() {} // error: unnecessary visibility qualifier\n+}\n+```\n+\n+To fix this error, please remove the visibility qualifier when it is not\n+required. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+// Directly implemented methods share the visibility of the type itself,\n+// so `pub` is unnecessary here\n+impl Bar {}\n+\n+// Trait methods share the visibility of the trait, so `pub` is\n+// unnecessary in either case\n+impl Foo for Bar {\n+    fn foo() {}\n+}\n+```"}, {"sha": "821073fe16eaeef0821a4a0a0c4948f0ddde3bd5", "filename": "src/librustc_error_codes/error_codes/E0451.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0451.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0451.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0451.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,48 @@\n+A struct constructor with private fields was invoked.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0451\n+mod Bar {\n+    pub struct Foo {\n+        pub a: isize,\n+        b: isize,\n+    }\n+}\n+\n+let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`\n+                                //        is private\n+```\n+\n+To fix this error, please ensure that all the fields of the struct are public,\n+or implement a function for easy instantiation. Examples:\n+\n+```\n+mod Bar {\n+    pub struct Foo {\n+        pub a: isize,\n+        pub b: isize, // we set `b` field public\n+    }\n+}\n+\n+let f = Bar::Foo{ a: 0, b: 0 }; // ok!\n+```\n+\n+Or:\n+\n+```\n+mod Bar {\n+    pub struct Foo {\n+        pub a: isize,\n+        b: isize, // still private\n+    }\n+\n+    impl Foo {\n+        pub fn new() -> Foo { // we create a method to instantiate `Foo`\n+            Foo { a: 0, b: 0 }\n+        }\n+    }\n+}\n+\n+let f = Bar::Foo::new(); // ok!\n+```"}, {"sha": "be3d573e10d2d9f4857f8860b622bb64d1ee87d9", "filename": "src/librustc_error_codes/error_codes/E0452.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+An invalid lint attribute has been given. Erroneous code example:\n+\n+```compile_fail,E0452\n+#![allow(foo = \"\")] // error: malformed lint attribute\n+```\n+\n+Lint attributes only accept a list of identifiers (where each identifier is a\n+lint name). Ensure the attribute is of this form:\n+\n+```\n+#![allow(foo)] // ok!\n+// or:\n+#![allow(foo, foo2)] // ok!\n+```"}, {"sha": "11789db8f365a0465ffd46cf4e393380ce223b04", "filename": "src/librustc_error_codes/error_codes/E0453.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0453.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0453.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0453.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,42 @@\n+A lint check attribute was overruled by a `forbid` directive set as an\n+attribute on an enclosing scope, or on the command line with the `-F` option.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0453\n+#![forbid(non_snake_case)]\n+\n+#[allow(non_snake_case)]\n+fn main() {\n+    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer\n+                      //        forbid(non_snake_case)\n+}\n+```\n+\n+The `forbid` lint setting, like `deny`, turns the corresponding compiler\n+warning into a hard error. Unlike `deny`, `forbid` prevents itself from being\n+overridden by inner attributes.\n+\n+If you're sure you want to override the lint check, you can change `forbid` to\n+`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a\n+command-line option) to allow the inner lint check attribute:\n+\n+```\n+#![deny(non_snake_case)]\n+\n+#[allow(non_snake_case)]\n+fn main() {\n+    let MyNumber = 2; // ok!\n+}\n+```\n+\n+Otherwise, edit the code to pass the lint check, and remove the overruled\n+attribute:\n+\n+```\n+#![forbid(non_snake_case)]\n+\n+fn main() {\n+    let my_number = 2;\n+}\n+```"}, {"sha": "d33148850816f60694bf5f459c743d79e6702959", "filename": "src/librustc_error_codes/error_codes/E0454.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+A link name was given with an empty name. Erroneous code example:\n+\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n+#[link(name = \"\")] extern {}\n+// error: `#[link(name = \"\")]` given with empty name\n+```\n+\n+The rust compiler cannot link to an external library if you don't give it its\n+name. Example:\n+\n+```no_run\n+#[link(name = \"some_lib\")] extern {} // ok!\n+```"}, {"sha": "a642528dee2258ca9a61537e3c2558384ddbd673", "filename": "src/librustc_error_codes/error_codes/E0455.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+Linking with `kind=framework` is only supported when targeting macOS,\n+as frameworks are specific to that operating system.\n+\n+Erroneous code example:\n+\n+```ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)\n+#[link(name = \"FooCoreServices\", kind = \"framework\")] extern {}\n+// OS used to compile is Linux for example\n+```\n+\n+To solve this error you can use conditional compilation:\n+\n+```\n+#[cfg_attr(target=\"macos\", link(name = \"FooCoreServices\", kind = \"framework\"))]\n+extern {}\n+```\n+\n+See more:\n+https://doc.rust-lang.org/reference/attributes.html#conditional-compilation"}, {"sha": "e6baeb8f69229221f8a497026c9fc5ef2e16570c", "filename": "src/librustc_error_codes/error_codes/E0458.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n+\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n+#[link(kind = \"wonderful_unicorn\")] extern {}\n+// error: unknown kind: `wonderful_unicorn`\n+```\n+\n+Please specify a valid \"kind\" value, from one of the following:\n+\n+* static\n+* dylib\n+* framework\n+"}, {"sha": "663bc322ee65d6000acffc31e59f4f3bf4afb369", "filename": "src/librustc_error_codes/error_codes/E0459.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,13 @@\n+A link was used without a name parameter. Erroneous code example:\n+\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n+#[link(kind = \"dylib\")] extern {}\n+// error: `#[link(...)]` specified without `name = \"foo\"`\n+```\n+\n+Please add the name parameter to allow the rust compiler to find the library\n+you want. Example:\n+\n+```no_run\n+#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n+```"}, {"sha": "41add698cdc9041d6474250f7c25ca46d1259259", "filename": "src/librustc_error_codes/error_codes/E0463.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0463.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0463.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0463.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,11 @@\n+A plugin/crate was declared but cannot be found. Erroneous code example:\n+\n+```compile_fail,E0463\n+#![feature(plugin)]\n+#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\n+extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n+```\n+\n+You need to link your code to the relevant crate in order to be able to use it\n+(through Cargo or the `-L` option of rustc example). Plugins are crates as\n+well, and you link to them the same way."}, {"sha": "443b7bae1345e5fdae42cf0787b63137bf73a2e6", "filename": "src/librustc_error_codes/error_codes/E0466.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+Macro import declarations were malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0466\n+#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n+extern crate core as some_crate;\n+\n+#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n+extern crate core as another_crate;\n+```\n+\n+This is a syntax error at the level of attribute declarations. The proper\n+syntax for macro imports is the following:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+// In some_crate:\n+#[macro_export]\n+macro_rules! get_tacos {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! get_pimientos {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n+extern crate some_crate;               // `get_pimientos` macros from some_crate\n+```\n+\n+If you would like to import all exported macros, write `macro_use` with no\n+arguments."}, {"sha": "73e3ebb949ac0da13e0386e9a48e70867ef0f826", "filename": "src/librustc_error_codes/error_codes/E0468.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+A non-root module attempts to import macros from another crate.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0468\n+mod foo {\n+    #[macro_use(debug_assert)]  // error: must be at crate root to import\n+    extern crate core;          //        macros from another crate\n+    fn run_macro() { debug_assert!(true); }\n+}\n+```\n+\n+Only `extern crate` imports at the crate root level are allowed to import\n+macros.\n+\n+Either move the macro import to crate root or do without the foreign macros.\n+This will work:\n+\n+```\n+#[macro_use(debug_assert)]\n+extern crate core;\n+\n+mod foo {\n+    fn run_macro() { debug_assert!(true); }\n+}\n+# fn main() {}\n+```"}, {"sha": "22db976aac2decad576ed3d1766640955823fe7f", "filename": "src/librustc_error_codes/error_codes/E0469.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0469.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0469.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0469.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,39 @@\n+A macro listed for import was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0469\n+#[macro_use(drink, be_merry)] // error: imported macro not found\n+extern crate alloc;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for import, and that the crate\n+in question exports them.\n+\n+A working version would be:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(eat, drink)]\n+extern crate some_crate; //ok!\n+```"}, {"sha": "6634d9b6e63b418f572621b03ad39cae3d6f5eab", "filename": "src/librustc_error_codes/error_codes/E0478.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+A lifetime bound was not satisfied.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0478\n+// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must\n+// outlive all the superbounds from the trait (`'kiss`, in this example).\n+\n+trait Wedding<'t>: 't { }\n+\n+struct Prince<'kiss, 'SnowWhite> {\n+    child: Box<Wedding<'kiss> + 'SnowWhite>,\n+    // error: lifetime bound not satisfied\n+}\n+```\n+\n+In this example, the `'SnowWhite` lifetime is supposed to outlive the `'kiss`\n+lifetime but the declaration of the `Prince` struct doesn't enforce it. To fix\n+this issue, you need to specify it:\n+\n+```\n+trait Wedding<'t>: 't { }\n+\n+struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'kiss must live\n+                                          // longer than 'SnowWhite.\n+    child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!\n+}\n+```"}, {"sha": "1ccaf71257b8b47e21c81082b08abea73abac758", "filename": "src/librustc_error_codes/error_codes/E0491.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0491.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0491.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0491.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+A reference has a longer lifetime than the data it references.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0491\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T {\n+    type Output = &'a T; // compile error E0491\n+}\n+```\n+\n+Here, the problem is that a reference type like `&'a T` is only valid\n+if all the data in T outlives the lifetime `'a`. But this impl as written\n+is applicable to any lifetime `'a` and any type `T` -- we have no guarantee\n+that `T` outlives `'a`. To fix this, you can add a where clause like\n+`where T: 'a`.\n+\n+```\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T\n+where\n+    T: 'a,\n+{\n+    type Output = &'a T; // compile error E0491\n+}\n+```"}, {"sha": "1caa59999ae1e384cb7ed77fb629c9272c9ba672", "filename": "src/librustc_error_codes/error_codes/E0492.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0492.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0492.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0492.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,71 @@\n+A borrow of a constant containing interior mutability was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0492\n+use std::sync::atomic::AtomicUsize;\n+\n+const A: AtomicUsize = AtomicUsize::new(0);\n+static B: &'static AtomicUsize = &A;\n+// error: cannot borrow a constant which may contain interior mutability,\n+//        create a static instead\n+```\n+\n+A `const` represents a constant value that should never change. If one takes\n+a `&` reference to the constant, then one is taking a pointer to some memory\n+location containing the value. Normally this is perfectly fine: most values\n+can't be changed via a shared `&` pointer, but interior mutability would allow\n+it. That is, a constant value could be mutated. On the other hand, a `static` is\n+explicitly a single memory location, which can be mutated at will.\n+\n+So, in order to solve this error, either use statics which are `Sync`:\n+\n+```\n+use std::sync::atomic::AtomicUsize;\n+\n+static A: AtomicUsize = AtomicUsize::new(0);\n+static B: &'static AtomicUsize = &A; // ok!\n+```\n+\n+You can also have this error while using a cell type:\n+\n+```compile_fail,E0492\n+use std::cell::Cell;\n+\n+const A: Cell<usize> = Cell::new(1);\n+const B: &Cell<usize> = &A;\n+// error: cannot borrow a constant which may contain interior mutability,\n+//        create a static instead\n+\n+// or:\n+struct C { a: Cell<usize> }\n+\n+const D: C = C { a: Cell::new(1) };\n+const E: &Cell<usize> = &D.a; // error\n+\n+// or:\n+const F: &C = &D; // error\n+```\n+\n+This is because cell types do operations that are not thread-safe. Due to this,\n+they don't implement Sync and thus can't be placed in statics.\n+\n+However, if you still wish to use these types, you can achieve this by an unsafe\n+wrapper:\n+\n+```\n+use std::cell::Cell;\n+use std::marker::Sync;\n+\n+struct NotThreadSafe<T> {\n+    value: Cell<T>,\n+}\n+\n+unsafe impl<T> Sync for NotThreadSafe<T> {}\n+\n+static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n+static B: &'static NotThreadSafe<usize> = &A; // ok!\n+```\n+\n+Remember this solution is unsafe! You will have to ensure that accesses to the\n+cell are synchronized."}, {"sha": "90a0cbce623d0473230e147388f95127260ccb81", "filename": "src/librustc_error_codes/error_codes/E0493.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,42 @@\n+A type with a `Drop` implementation was destructured when trying to initialize\n+a static item.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0493\n+enum DropType {\n+    A,\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Foo {\n+    field1: DropType,\n+}\n+\n+static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n+```\n+\n+The problem here is that if the given type or one of its fields implements the\n+`Drop` trait, this `Drop` implementation cannot be called during the static\n+type initialization which might cause a memory leak. To prevent this issue,\n+you need to instantiate all the static type's fields by hand.\n+\n+```\n+enum DropType {\n+    A,\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Foo {\n+    field1: DropType,\n+}\n+\n+static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n+                                               // by hand.\n+```"}, {"sha": "f956237b80bc343bb94ff27f20e266dff879e3de", "filename": "src/librustc_error_codes/error_codes/E0495.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0495.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0495.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0495.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,38 @@\n+A lifetime cannot be determined in the given situation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0495\n+fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // error!\n+        ((u,),) => u,\n+    }\n+}\n+\n+let y = Box::new((42,));\n+let x = transmute_lifetime(&y);\n+```\n+\n+In this code, you have two ways to solve this issue:\n+ 1. Enforce that `'a` lives at least as long as `'b`.\n+ 2. Use the same lifetime requirement for both input and output values.\n+\n+So for the first solution, you can do it by replacing `'a` with `'a: 'b`:\n+\n+```\n+fn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```\n+\n+In the second you can do it by simply removing `'b` so they both use `'a`:\n+\n+```\n+fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```"}, {"sha": "83d65cd3e09ae561a3b36de2afcdbcf889d60045", "filename": "src/librustc_error_codes/error_codes/E0496.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0496.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0496.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0496.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,31 @@\n+A lifetime name is shadowing another lifetime name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0496\n+struct Foo<'a> {\n+    a: &'a i32,\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime\n+                           //        name that is already in scope\n+    }\n+}\n+```\n+\n+Please change the name of one of the lifetimes to remove this error. Example:\n+\n+```\n+struct Foo<'a> {\n+    a: &'a i32,\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn f<'b>(x: &'b i32) { // ok!\n+    }\n+}\n+\n+fn main() {\n+}\n+```"}, {"sha": "ef2882415d24a9c2894be2abfe6b698742bae20a", "filename": "src/librustc_error_codes/error_codes/E0497.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0497.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0497.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0497.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A stability attribute was used outside of the standard library.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+#[stable] // error: stability attributes may not be used outside of the\n+          //        standard library\n+fn foo() {}\n+```\n+\n+It is not possible to use stability attributes outside of the standard library.\n+Also, for now, it is not possible to write deprecation messages either."}, {"sha": "370ceef530bd270efa05da8a3c14fa22502d31a1", "filename": "src/librustc_error_codes/error_codes/E0499.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,30 @@\n+A variable was borrowed as mutable more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0499\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &mut i;\n+x;\n+// error: cannot borrow `i` as mutable more than once at a time\n+```\n+\n+Please note that in rust, you can either have many immutable references, or one\n+mutable reference. Take a look at\n+https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more\n+information. Example:\n+\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i; // ok!\n+\n+// or:\n+let mut i = 0;\n+let a = &i; // ok!\n+let b = &i; // still ok!\n+let c = &i; // still ok!\n+b;\n+a;\n+```"}, {"sha": "fde31d2c745b4c8aa3a28ec1bfbfddcda42587f0", "filename": "src/librustc_error_codes/error_codes/E0500.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0500.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0500.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0500.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,41 @@\n+A borrowed variable was used by a closure.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0500\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let nights_watch = &jon_snow;\n+    let starks = || {\n+        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n+                       //        but it is already borrowed\n+    };\n+    println!(\"{}\", nights_watch);\n+}\n+```\n+\n+In here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\n+cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n+you can create the closure after the borrow has ended:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let nights_watch = &jon_snow;\n+    println!(\"{}\", nights_watch);\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+}\n+```\n+\n+Or, if the type implements the `Clone` trait, you can clone it between\n+closures:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let mut jon_copy = jon_snow.clone();\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+    println!(\"{}\", jon_copy);\n+}\n+```"}, {"sha": "95e0dfd40015f90a7798420a40105f076f9540d0", "filename": "src/librustc_error_codes/error_codes/E0501.md", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,76 @@\n+This error indicates that a mutable variable is being used while it is still\n+captured by a closure. Because the closure has borrowed the variable, it is not\n+available for use until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at\n+http://rustbyexample.com/fn/closures/capture.html for more information about\n+capturing.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0501\n+fn inside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn outside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn foo(a: &mut i32) {\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n+                        //        closure requires unique access.\n+    bar();\n+}\n+```\n+\n+To fix this error, you can finish using the closure before using the captured\n+variable:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    bar();\n+    // borrow on `a` ends.\n+    outside_closure(a); // ok!\n+}\n+```\n+\n+Or you can pass the variable as a parameter to the closure:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let mut bar = |s: &mut i32| {\n+        inside_closure(s)\n+    };\n+    outside_closure(a);\n+    bar(a);\n+}\n+```\n+\n+It may be possible to define the closure later:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    outside_closure(a);\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    bar();\n+}\n+```"}, {"sha": "69220259e3d7d5896e7d9105b6c0d63b86625bf4", "filename": "src/librustc_error_codes/error_codes/E0502.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+This error indicates that you are trying to borrow a variable as mutable when it\n+has already been borrowed as immutable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0502\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    let ref y = a; // a is borrowed as immutable.\n+    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n+            //        as immutable\n+    println!(\"{}\", y);\n+}\n+```\n+\n+To fix this error, ensure that you don't have any other references to the\n+variable before trying to access it mutably:\n+\n+```\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    bar(a);\n+    let ref y = a; // ok!\n+    println!(\"{}\", y);\n+}\n+```\n+\n+For more information on the rust ownership system, take a look at\n+https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html."}, {"sha": "c683619e3d03f45532101dd6d1eb8c233db798e0", "filename": "src/librustc_error_codes/error_codes/E0503.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,52 @@\n+A value was used after it was mutably borrowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0503\n+fn main() {\n+    let mut value = 3;\n+    // Create a mutable borrow of `value`.\n+    let borrow = &mut value;\n+    let _sum = value + 1; // error: cannot use `value` because\n+                          //        it was mutably borrowed\n+    println!(\"{}\", borrow);\n+}\n+```\n+\n+In this example, `value` is mutably borrowed by `borrow` and cannot be\n+used to calculate `sum`. This is not possible because this would violate\n+Rust's mutability rules.\n+\n+You can fix this error by finishing using the borrow before the next use of\n+the value:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    let borrow = &mut value;\n+    println!(\"{}\", borrow);\n+    // The block has ended and with it the borrow.\n+    // You can now use `value` again.\n+    let _sum = value + 1;\n+}\n+```\n+\n+Or by cloning `value` before borrowing it:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    // We clone `value`, creating a copy.\n+    let value_cloned = value.clone();\n+    // The mutable borrow is a reference to `value` and\n+    // not to `value_cloned`...\n+    let borrow = &mut value;\n+    // ... which means we can still use `value_cloned`,\n+    let _sum = value_cloned + 1;\n+    // even though the borrow only ends here.\n+    println!(\"{}\", borrow);\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}, {"sha": "bcbd00a8690a454c486e7afe549e2749823626a2", "filename": "src/librustc_error_codes/error_codes/E0504.md", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0504.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0504.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0504.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,103 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to move a borrowed variable into a\n+closure.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        println!(\"child function: {}\", fancy_num.num);\n+        // error: cannot move `fancy_num` into closure because it is borrowed\n+    };\n+\n+    x();\n+    println!(\"main function: {}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n+the closure `x`. There is no way to move a value into a closure while it is\n+borrowed, as that would invalidate the borrow.\n+\n+If the closure can't outlive the value being moved, try using a reference\n+rather than moving:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        // fancy_ref is usable here because it doesn't move `fancy_num`\n+        println!(\"child function: {}\", fancy_ref.num);\n+    };\n+\n+    x();\n+\n+    println!(\"main function: {}\", fancy_num.num);\n+}\n+```\n+\n+If the value has to be borrowed and then moved, try limiting the lifetime of\n+the borrow using a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"main function: {}\", fancy_ref.num);\n+        // `fancy_ref` goes out of scope here\n+    }\n+\n+    let x = move || {\n+        // `fancy_num` can be moved now (no more references exist)\n+        println!(\"child function: {}\", fancy_num.num);\n+    };\n+\n+    x();\n+}\n+```\n+\n+If the lifetime of a reference isn't enough, such as in the case of threading,\n+consider using an `Arc` to create a reference-counted value:\n+\n+```\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n+    let fancy_ref2 = fancy_ref1.clone();\n+\n+    let x = thread::spawn(move || {\n+        // `fancy_ref1` can be moved and has a `'static` lifetime\n+        println!(\"child thread: {}\", fancy_ref1.num);\n+    });\n+\n+    x.join().expect(\"child thread should finish\");\n+    println!(\"main thread: {}\", fancy_ref2.num);\n+}\n+```"}, {"sha": "14baa01cb50a04fcbbc17e4345284a42db07593c", "filename": "src/librustc_error_codes/error_codes/E0505.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,85 @@\n+A value was moved out while it was still borrowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0505\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    let _ref_to_val: &Value = &x;\n+    eat(x);\n+    borrow(_ref_to_val);\n+}\n+```\n+\n+Here, the function `eat` takes ownership of `x`. However,\n+`x` cannot be moved because the borrow to `_ref_to_val`\n+needs to last till the function `borrow`.\n+To fix that you can do a few different things:\n+\n+* Try to avoid moving the variable.\n+* Release borrow before move.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: &Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+\n+    let ref_to_val: &Value = &x;\n+    eat(&x); // pass by reference, if it's possible\n+    borrow(ref_to_val);\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+\n+    let ref_to_val: &Value = &x;\n+    borrow(ref_to_val);\n+    // ref_to_val is no longer used.\n+    eat(x);\n+}\n+```\n+\n+Or:\n+\n+```\n+#[derive(Clone, Copy)] // implement Copy trait\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    let ref_to_val: &Value = &x;\n+    eat(x); // it will be copied here.\n+    borrow(ref_to_val);\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}, {"sha": "9b8e316487203331d18e4d3a4e7db5ca4c72e901", "filename": "src/librustc_error_codes/error_codes/E0506.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,81 @@\n+This error occurs when an attempt is made to assign to a borrowed value.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0506\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+    // error: cannot assign to `fancy_num` because it is borrowed\n+\n+    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n+}\n+```\n+\n+Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n+be assigned to a new value as it would invalidate the reference.\n+\n+Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let moved_num = fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+\n+    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n+}\n+```\n+\n+If the value has to be borrowed, try limiting the lifetime of the borrow using\n+a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"Ref: {}\", fancy_ref.num);\n+    }\n+\n+    // Works because `fancy_ref` is no longer in scope\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+```\n+\n+Or by moving the reference into a function:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    print_fancy_ref(&fancy_num);\n+\n+    // Works because function borrow has ended\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+\n+fn print_fancy_ref(fancy_ref: &FancyNum){\n+    println!(\"Ref: {}\", fancy_ref.num);\n+}\n+```"}, {"sha": "89a6fb47377c4bfb529f3c749d8340cfccaad411", "filename": "src/librustc_error_codes/error_codes/E0507.md", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,131 @@\n+You tried to move out of a value which was borrowed.\n+\n+This can also happen when using a type implementing `Fn` or `FnMut`, as neither\n+allows moving out of them (they usually represent closures which can be called\n+more than once). Much of the text following applies equally well to non-`FnOnce`\n+closure bodies.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0507\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n+}\n+```\n+\n+Here, the `nothing_is_true` method takes the ownership of `self`. However,\n+`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n+which is a borrow of the content owned by the `RefCell`. To fix this error,\n+you have three choices:\n+\n+* Try to avoid moving the variable.\n+* Somehow reclaim the ownership.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(&self) {} // First case, we don't take ownership\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+    let x = x.into_inner(); // we get back ownership\n+\n+    x.nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+#[derive(Clone, Copy)] // we implement the Copy trait\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Moving a member out of a mutably borrowed struct will also cause E0507 error:\n+\n+```compile_fail,E0507\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+struct Batcave {\n+    knight: TheDarkKnight\n+}\n+\n+fn main() {\n+    let mut cave = Batcave {\n+        knight: TheDarkKnight\n+    };\n+    let borrowed = &mut cave;\n+\n+    borrowed.knight.nothing_is_true(); // E0507\n+}\n+```\n+\n+It is fine only if you put something back. `mem::replace` can be used for that:\n+\n+```\n+# struct TheDarkKnight;\n+# impl TheDarkKnight { fn nothing_is_true(self) {} }\n+# struct Batcave { knight: TheDarkKnight }\n+use std::mem;\n+\n+let mut cave = Batcave {\n+    knight: TheDarkKnight\n+};\n+let borrowed = &mut cave;\n+\n+mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}, {"sha": "33572fca6a3e8a308243444de3e7c32007f5230f", "filename": "src/librustc_error_codes/error_codes/E0508.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0508.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0508.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0508.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,41 @@\n+A value was moved out of a non-copy fixed-size array.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0508\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n+                           //        a non-copy fixed-size array\n+}\n+```\n+\n+The first element was moved out of the array, but this is not\n+possible because `NonCopy` does not implement the `Copy` trait.\n+\n+Consider borrowing the element instead of moving it:\n+\n+```\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n+}\n+```\n+\n+Alternatively, if your type implements `Clone` and you need to own the value,\n+consider borrowing and then cloning:\n+\n+```\n+#[derive(Clone)]\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    // Now you can clone the array element.\n+    let _value = array[0].clone();\n+}\n+```"}, {"sha": "9cbd7d695aab9623f10822ddb389bd530503af0f", "filename": "src/librustc_error_codes/error_codes/E0509.md", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0509.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0509.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0509.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,92 @@\n+This error occurs when an attempt is made to move out of a value whose type\n+implements the `Drop` trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0509\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let fancy_field = drop_struct.fancy; // Error E0509\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Here, we tried to move a field out of a struct of type `DropStruct` which\n+implements the `Drop` trait. However, a struct cannot be dropped if one or\n+more of its fields have been moved.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that gets\n+called when they go out of scope. This destructor may use the fields of the\n+struct, so moving out of the struct could make it impossible to run the\n+destructor. Therefore, we must think of all values whose type implements the\n+`Drop` trait as single units whose fields cannot be moved.\n+\n+This error can be fixed by creating a reference to the fields of a struct,\n+enum, or tuple using the `ref` keyword:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let ref fancy_field = drop_struct.fancy; // No more errors!\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Note that this technique can also be used in the arms of a match expression:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+enum DropEnum {\n+    Fancy(FancyNum)\n+}\n+\n+impl Drop for DropEnum {\n+    fn drop(&mut self) {\n+        // Destruct DropEnum, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    // Creates and enum of type `DropEnum`, which implements `Drop`\n+    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n+    match drop_enum {\n+        // Creates a reference to the inside of `DropEnum::Fancy`\n+        DropEnum::Fancy(ref fancy_field) => // No error!\n+            println!(\"It was fancy-- {}!\", fancy_field.num),\n+    }\n+    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n+}\n+```"}, {"sha": "d5be417888b547ea63e236ddb209546dc1fc3aef", "filename": "src/librustc_error_codes/error_codes/E0510.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+Cannot mutate place in this match guard.\n+\n+When matching on a variable it cannot be mutated in the match guards, as this\n+could cause the match to be non-exhaustive:\n+\n+```compile_fail,E0510\n+let mut x = Some(0);\n+match x {\n+    None => (),\n+    Some(_) if { x = None; false } => (),\n+    Some(v) => (), // No longer matches\n+}\n+```\n+\n+Here executing `x = None` would modify the value being matched and require us\n+to go \"back in time\" to the `None` arm."}, {"sha": "2d6ff8241e69232754927cac33b4515d2b936170", "filename": "src/librustc_error_codes/error_codes/E0511.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+Invalid monomorphization of an intrinsic function was used. Erroneous code\n+example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+fn main() {\n+    unsafe { simd_add(0, 1); }\n+    // error: invalid monomorphization of `simd_add` intrinsic\n+}\n+```\n+\n+The generic type has to be a SIMD type. Example:\n+\n+```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x2(i32, i32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n+```"}, {"sha": "c13c0511c757590e6c86a6a60539b59736e51f83", "filename": "src/librustc_error_codes/error_codes/E0512.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0512.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0512.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0512.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+Transmute with two differently sized types was attempted. Erroneous code\n+example:\n+\n+```compile_fail,E0512\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n+    // error: cannot transmute between types of different sizes,\n+    //        or dependently-sized types\n+}\n+```\n+\n+Please use types with same size or use the expected type directly. Example:\n+\n+```\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n+    // or:\n+    unsafe { takes_u8(0u8); } // ok!\n+}\n+```"}, {"sha": "9580b6f92acd1bd77188397cbf62bc29576ff0d0", "filename": "src/librustc_error_codes/error_codes/E0515.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0515.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0515.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0515.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,37 @@\n+Cannot return value that references local variable\n+\n+Local variables, function parameters and temporaries are all dropped before the\n+end of the function body. So a reference to them cannot be returned.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0515\n+fn get_dangling_reference() -> &'static i32 {\n+    let x = 0;\n+    &x\n+}\n+```\n+\n+```compile_fail,E0515\n+use std::slice::Iter;\n+fn get_dangling_iterator<'a>() -> Iter<'a, i32> {\n+    let v = vec![1, 2, 3];\n+    v.iter()\n+}\n+```\n+\n+Consider returning an owned value instead:\n+\n+```\n+use std::vec::IntoIter;\n+\n+fn get_integer() -> i32 {\n+    let x = 0;\n+    x\n+}\n+\n+fn get_owned_iterator() -> IntoIter<i32> {\n+    let v = vec![1, 2, 3];\n+    v.into_iter()\n+}\n+```"}, {"sha": "815d7609013000871982c87017c99201feaee833", "filename": "src/librustc_error_codes/error_codes/E0516.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0516.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0516.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0516.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+The `typeof` keyword is currently reserved but unimplemented.\n+Erroneous code example:\n+\n+```compile_fail,E0516\n+fn main() {\n+    let x: typeof(92) = 92;\n+}\n+```\n+\n+Try using type inference instead. Example:\n+\n+```\n+fn main() {\n+    let x = 92;\n+}\n+```"}, {"sha": "f738d33560a02bd47d1f79348118e5ef54468ba8", "filename": "src/librustc_error_codes/error_codes/E0517.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0517.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0517.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0517.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,45 @@\n+This error indicates that a `#[repr(..)]` attribute was placed on an\n+unsupported item.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0517\n+#[repr(C)]\n+type Foo = u8;\n+\n+#[repr(packed)]\n+enum Foo {Bar, Baz}\n+\n+#[repr(u8)]\n+struct Foo {bar: bool, baz: bool}\n+\n+#[repr(C)]\n+impl Foo {\n+    // ...\n+}\n+```\n+\n+* The `#[repr(C)]` attribute can only be placed on structs and enums.\n+* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n+* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n+\n+These attributes do not work on typedefs, since typedefs are just aliases.\n+\n+Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n+discriminant size for enums with no data fields on any of the variants, e.g.\n+`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to\n+the size of the provided type. Such an enum can be cast to a value of the same\n+type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n+with a constrained set of allowed values.\n+\n+Only field-less enums can be cast to numerical primitives, so this attribute\n+will not apply to structs.\n+\n+`#[repr(packed)]` reduces padding to make the struct size smaller. The\n+representation of enums isn't strictly defined in Rust, and this attribute\n+won't work on enums.\n+\n+`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n+types (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\n+SIMD. This doesn't make much sense for enums since they don't consist of a\n+single list of data."}, {"sha": "1af9a3735fe1a67c2f04e96e8174938101ec043f", "filename": "src/librustc_error_codes/error_codes/E0518.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0518.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0518.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0518.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+This error indicates that an `#[inline(..)]` attribute was incorrectly placed\n+on something other than a function or method.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0518\n+#[inline(always)]\n+struct Foo;\n+\n+#[inline(never)]\n+impl Foo {\n+    // ...\n+}\n+```\n+\n+`#[inline]` hints the compiler whether or not to attempt to inline a method or\n+function. By default, the compiler does a pretty good job of figuring this out\n+itself, but if you feel the need for annotations, `#[inline(always)]` and\n+`#[inline(never)]` can override or force the compiler's decision.\n+\n+If you wish to apply this attribute to all methods in an impl, manually annotate\n+each method; it is not possible to annotate the entire impl with an `#[inline]`\n+attribute."}, {"sha": "e8a2b4da080546abcf9ee5255ce06bb5d535d118", "filename": "src/librustc_error_codes/error_codes/E0520.md", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0520.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0520.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0520.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,59 @@\n+A non-default implementation was already made on this type so it cannot be\n+specialized further. Erroneous code example:\n+\n+```compile_fail,E0520\n+#![feature(specialization)]\n+\n+trait SpaceLlama {\n+    fn fly(&self);\n+}\n+\n+// applies to all T\n+impl<T> SpaceLlama for T {\n+    default fn fly(&self) {}\n+}\n+\n+// non-default impl\n+// applies to all `Clone` T and overrides the previous impl\n+impl<T: Clone> SpaceLlama for T {\n+    fn fly(&self) {}\n+}\n+\n+// since `i32` is clone, this conflicts with the previous implementation\n+impl SpaceLlama for i32 {\n+    default fn fly(&self) {}\n+    // error: item `fly` is provided by an `impl` that specializes\n+    //        another, but the item in the parent `impl` is not marked\n+    //        `default` and so it cannot be specialized.\n+}\n+```\n+\n+Specialization only allows you to override `default` functions in\n+implementations.\n+\n+To fix this error, you need to mark all the parent implementations as default.\n+Example:\n+\n+```\n+#![feature(specialization)]\n+\n+trait SpaceLlama {\n+    fn fly(&self);\n+}\n+\n+// applies to all T\n+impl<T> SpaceLlama for T {\n+    default fn fly(&self) {} // This is a parent implementation.\n+}\n+\n+// applies to all `Clone` T; overrides the previous impl\n+impl<T: Clone> SpaceLlama for T {\n+    default fn fly(&self) {} // This is a parent implementation but was\n+                             // previously not a default one, causing the error\n+}\n+\n+// applies to i32, overrides the previous two impls\n+impl SpaceLlama for i32 {\n+    fn fly(&self) {} // And now that's ok!\n+}\n+```"}, {"sha": "e4756c384c495ffc02fc3e0972e7dbed1f47ab69", "filename": "src/librustc_error_codes/error_codes/E0522.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,14 @@\n+The lang attribute is intended for marking special items that are built-in to\n+Rust itself. This includes special traits (like `Copy` and `Sized`) that affect\n+how the compiler behaves, as well as special functions that may be automatically\n+invoked (such as the handler for out-of-bounds accesses when indexing a slice).\n+Erroneous code example:\n+\n+```compile_fail,E0522\n+#![feature(lang_items)]\n+\n+#[lang = \"cookie\"]\n+fn cookie() -> ! { // error: definition of an unknown language item: `cookie`\n+    loop {}\n+}\n+```"}, {"sha": "bab241b5a9510db11148d74bcbe599503524c914", "filename": "src/librustc_error_codes/error_codes/E0524.md", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0524.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0524.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0524.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,60 @@\n+A variable which requires unique access is being used in more than one closure\n+at the same time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0524\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    let mut c1 = || set(x);\n+    let mut c2 = || set(x); // error!\n+\n+    c2();\n+    c1();\n+}\n+```\n+\n+To solve this issue, multiple solutions are available. First, is it required\n+for this variable to be used in more than one closure at a time? If it is the\n+case, use reference counted types such as `Rc` (or `Arc` if it runs\n+concurrently):\n+\n+```\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    let x = Rc::new(RefCell::new(x));\n+    let y = Rc::clone(&x);\n+    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\n+    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\n+\n+    c2();\n+    c1();\n+}\n+```\n+\n+If not, just run closures one at a time:\n+\n+```\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    { // This block isn't necessary since non-lexical lifetimes, it's just to\n+      // make it more clear.\n+        let mut c1 = || set(&mut *x);\n+        c1();\n+    } // `c1` has been dropped here so we're free to use `x` again!\n+    let mut c2 = || set(&mut *x);\n+    c2();\n+}\n+```"}, {"sha": "95e5f362bdea69136ab928da36ff26b39e17d8b3", "filename": "src/librustc_error_codes/error_codes/E0525.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,40 @@\n+A closure was used but didn't implement the expected trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0525\n+struct X;\n+\n+fn foo<T>(_: T) {}\n+fn bar<T: Fn(u32)>(_: T) {}\n+\n+fn main() {\n+    let x = X;\n+    let closure = |_| foo(x); // error: expected a closure that implements\n+                              //        the `Fn` trait, but this closure only\n+                              //        implements `FnOnce`\n+    bar(closure);\n+}\n+```\n+\n+In the example above, `closure` is an `FnOnce` closure whereas the `bar`\n+function expected an `Fn` closure. In this case, it's simple to fix the issue,\n+you just have to implement `Copy` and `Clone` traits on `struct X` and it'll\n+be ok:\n+\n+```\n+#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\n+struct X;\n+\n+fn foo<T>(_: T) {}\n+fn bar<T: Fn(u32)>(_: T) {}\n+\n+fn main() {\n+    let x = X;\n+    let closure = |_| foo(x);\n+    bar(closure); // ok!\n+}\n+```\n+\n+To understand better how closures work in Rust, read:\n+https://doc.rust-lang.org/book/ch13-01-closures.html"}, {"sha": "4bff39dc770e0ec4c30ec45b7ff4d1703e2c3f18", "filename": "src/librustc_error_codes/error_codes/E0527.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+The number of elements in an array or slice pattern differed from the number of\n+elements in the array being matched.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0527\n+let r = &[1, 2, 3, 4];\n+match r {\n+    &[a, b] => { // error: pattern requires 2 elements but array\n+                 //        has 4\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\n+Ensure that the pattern is consistent with the size of the matched\n+array. Additional elements can be matched with `..`:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4];\n+match r {\n+    &[a, b, ..] => { // ok!\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```"}, {"sha": "4b6ea2469919cd61b28b650e5e1e6c2782e66cb3", "filename": "src/librustc_error_codes/error_codes/E0528.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,31 @@\n+An array or slice pattern required more elements than were present in the\n+matched array.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0528\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2];\n+match r {\n+    &[a, b, c, rest @ ..] => { // error: pattern requires at least 3\n+                               //        elements but array has 2\n+        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n+    }\n+}\n+```\n+\n+Ensure that the matched array has at least as many elements as the pattern\n+requires. You can match an arbitrary number of remaining elements with `..`:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4, 5];\n+match r {\n+    &[a, b, c, rest @ ..] => { // ok!\n+        // prints `a=1, b=2, c=3 rest=[4, 5]`\n+        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n+    }\n+}\n+```"}, {"sha": "013f438ba93cde59eb74ca04a560f69f50d691bf", "filename": "src/librustc_error_codes/error_codes/E0529.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0529.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0529.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0529.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+An array or slice pattern was matched against some other type.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0529\n+let r: f32 = 1.0;\n+match r {\n+    [a, b] => { // error: expected an array or slice, found `f32`\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\n+Ensure that the pattern and the expression being matched on are of consistent\n+types:\n+\n+```\n+let r = [1.0, 2.0];\n+match r {\n+    [a, b] => { // ok!\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```"}, {"sha": "502f674fc1d21829aafc608c85d85635262fccb0", "filename": "src/librustc_error_codes/error_codes/E0530.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0530.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0530.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0530.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,32 @@\n+A binding shadowed something it shouldn't.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0530\n+static TEST: i32 = 0;\n+\n+let r: (i32, i32) = (0, 0);\n+match r {\n+    TEST => {} // error: match bindings cannot shadow statics\n+}\n+```\n+\n+To fix this error, just change the binding's name in order to avoid shadowing\n+one of the following:\n+\n+* struct name\n+* struct/enum variant\n+* static\n+* const\n+* associated const\n+\n+Fixed example:\n+\n+```\n+static TEST: i32 = 0;\n+\n+let r: (i32, i32) = (0, 0);\n+match r {\n+    something => {} // ok!\n+}\n+```"}, {"sha": "2814046fbddd765982b340555a29c952946086b1", "filename": "src/librustc_error_codes/error_codes/E0531.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0531.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0531.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0531.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,42 @@\n+An unknown tuple struct/variant has been used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0531\n+let Type(x) = Type(12); // error!\n+match Bar(12) {\n+    Bar(x) => {} // error!\n+    _ => {}\n+}\n+```\n+\n+In most cases, it's either a forgotten import or a typo. However, let's look at\n+how you can have such a type:\n+\n+```edition2018\n+struct Type(u32); // this is a tuple struct\n+\n+enum Foo {\n+    Bar(u32), // this is a tuple variant\n+}\n+\n+use Foo::*; // To use Foo's variant directly, we need to import them in\n+            // the scope.\n+```\n+\n+Either way, it should work fine with our previous code:\n+\n+```edition2018\n+struct Type(u32);\n+\n+enum Foo {\n+    Bar(u32),\n+}\n+use Foo::*;\n+\n+let Type(x) = Type(12); // ok!\n+match Type(12) {\n+    Type(x) => {} // ok!\n+    _ => {}\n+}\n+```"}, {"sha": "6fb315a371655984d7d5bfb00a8bf856b0520079", "filename": "src/librustc_error_codes/error_codes/E0532.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0532.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0532.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0532.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,38 @@\n+Pattern arm did not match expected kind.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0532\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        // error: expected unit struct, unit variant or constant, found tuple\n+        //        variant `State::Failed`\n+        State::Failed => println!(\"Failed\"),\n+        _ => ()\n+    }\n+}\n+```\n+\n+To fix this error, ensure the match arm kind is the same as the expression\n+matched.\n+\n+Fixed example:\n+\n+```\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n+        _ => ()\n+    }\n+}\n+```"}, {"sha": "279d728caae93ff6a5eb0ba8ec6b8f80bf478c07", "filename": "src/librustc_error_codes/error_codes/E0533.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0533.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0533.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0533.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+An item which isn't a unit struct, a variant, nor a constant has been used as a\n+match pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0533\n+struct Tortoise;\n+\n+impl Tortoise {\n+    fn turtle(&self) -> u32 { 0 }\n+}\n+\n+match 0u32 {\n+    Tortoise::turtle => {} // Error!\n+    _ => {}\n+}\n+if let Tortoise::turtle = 0u32 {} // Same error!\n+```\n+\n+If you want to match against a value returned by a method, you need to bind the\n+value first:\n+\n+```\n+struct Tortoise;\n+\n+impl Tortoise {\n+    fn turtle(&self) -> u32 { 0 }\n+}\n+\n+match 0u32 {\n+    x if x == Tortoise.turtle() => {} // Bound into `x` then we compare it!\n+    _ => {}\n+}\n+```"}, {"sha": "e50b84764b4dbc28dacbe68ee851a1746c6a6ae5", "filename": "src/librustc_error_codes/error_codes/E0534.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,35 @@\n+The `inline` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline()] // error: expected one argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The parenthesized `inline` attribute requires the parameter to be specified:\n+\n+```\n+#[inline(always)]\n+fn something() {}\n+```\n+\n+or:\n+\n+```\n+#[inline(never)]\n+fn something() {}\n+```\n+\n+Alternatively, a paren-less version of the attribute may be used to hint the\n+compiler about inlining opportunity:\n+\n+```\n+#[inline]\n+fn something() {}\n+```\n+\n+For more information about the inline attribute, read:\n+https://doc.rust-lang.org/reference.html#inline-attributes"}, {"sha": "e9abfe5dda1ba913f57d338256d7ce1287c5b12a", "filename": "src/librustc_error_codes/error_codes/E0535.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+An unknown argument was given to the `inline` attribute.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline(unknown)] // error: invalid argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `inline` attribute only supports two arguments:\n+\n+ * always\n+ * never\n+\n+All other arguments given to the `inline` attribute will return this error.\n+Example:\n+\n+```\n+#[inline(never)] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+For more information about the inline attribute, https:\n+read://doc.rust-lang.org/reference.html#inline-attributes"}, {"sha": "9006906a70381aa09ac7320df4d82c70586c0f51", "filename": "src/librustc_error_codes/error_codes/E0536.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0536.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0536.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0536.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+The `not` cfg-predicate was malformed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0536\n+#[cfg(not())] // error: expected 1 cfg-pattern\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+The `not` predicate expects one cfg-pattern. Example:\n+\n+```\n+#[cfg(not(target_os = \"linux\"))] // ok!\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+For more information about the cfg attribute, read:\n+https://doc.rust-lang.org/reference.html#conditional-compilation"}, {"sha": "82d8c6188afd69192f097002dd4578d1644281b8", "filename": "src/librustc_error_codes/error_codes/E0537.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0537.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0537.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0537.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+An unknown predicate was used inside the `cfg` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0537\n+#[cfg(unknown())] // error: invalid predicate `unknown`\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+The `cfg` attribute supports only three kinds of predicates:\n+\n+ * any\n+ * all\n+ * not\n+\n+Example:\n+\n+```\n+#[cfg(not(target_os = \"linux\"))] // ok!\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+For more information about the cfg attribute, read:\n+https://doc.rust-lang.org/reference.html#conditional-compilation"}, {"sha": "5858771ce8883fa2f17b17534a8e11b73101b952", "filename": "src/librustc_error_codes/error_codes/E0538.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0538.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0538.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0538.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+Attribute contains same meta item more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0538\n+#[deprecated(\n+    since=\"1.0.0\",\n+    note=\"First deprecation note.\",\n+    note=\"Second deprecation note.\" // error: multiple same meta item\n+)]\n+fn deprecated_function() {}\n+```\n+\n+Meta items are the key-value pairs inside of an attribute. Each key may only be\n+used once in each attribute.\n+\n+To fix the problem, remove all but one of the meta items with the same key.\n+\n+Example:\n+\n+```\n+#[deprecated(\n+    since=\"1.0.0\",\n+    note=\"First deprecation note.\"\n+)]\n+fn deprecated_function() {}\n+```"}, {"sha": "96334088feeef7b3f8a4af04e60a985d68178d61", "filename": "src/librustc_error_codes/error_codes/E0541.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0541.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0541.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0541.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,29 @@\n+An unknown meta item was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0541\n+#[deprecated(\n+    since=\"1.0.0\",\n+    // error: unknown meta item\n+    reason=\"Example invalid meta item. Should be 'note'\")\n+]\n+fn deprecated_function() {}\n+```\n+\n+Meta items are the key-value pairs inside of an attribute. The keys provided\n+must be one of the valid keys for the specified attribute.\n+\n+To fix the problem, either remove the unknown meta item, or rename it if you\n+provided the wrong name.\n+\n+In the erroneous code example above, the wrong name was provided, so changing\n+to a correct one it will fix the error. Example:\n+\n+```\n+#[deprecated(\n+    since=\"1.0.0\",\n+    note=\"This is a valid meta item for the deprecated attribute.\"\n+)]\n+fn deprecated_function() {}\n+```"}, {"sha": "1487d701847fcb653b6a2dbbcd22932fb5c59979", "filename": "src/librustc_error_codes/error_codes/E0550.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0550.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0550.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0550.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+More than one `deprecated` attribute has been put on an item.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0550\n+#[deprecated(note = \"because why not?\")]\n+#[deprecated(note = \"right?\")] // error!\n+fn the_banished() {}\n+```\n+\n+The `deprecated` attribute can only be present **once** on an item.\n+\n+```\n+#[deprecated(note = \"because why not, right?\")]\n+fn the_banished() {} // ok!\n+```"}, {"sha": "53db559a4fcbf3401c71f8757352226b8f491635", "filename": "src/librustc_error_codes/error_codes/E0551.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0551.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0551.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0551.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+An invalid meta-item was used inside an attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0551\n+#[deprecated(note)] // error!\n+fn i_am_deprecated() {}\n+```\n+\n+Meta items are the key-value pairs inside of an attribute. To fix this issue,\n+you need to give a value to the `note` key. Example:\n+\n+```\n+#[deprecated(note = \"because\")] // ok!\n+fn i_am_deprecated() {}\n+```"}, {"sha": "0fbc861fb7ca71cb44320a7432a45f1cd752a18e", "filename": "src/librustc_error_codes/error_codes/E0552.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0552.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0552.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0552.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,27 @@\n+A unrecognized representation attribute was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0552\n+#[repr(D)] // error: unrecognized representation hint\n+struct MyStruct {\n+    my_field: usize\n+}\n+```\n+\n+You can use a `repr` attribute to tell the compiler how you want a struct or\n+enum to be laid out in memory.\n+\n+Make sure you're using one of the supported options:\n+\n+```\n+#[repr(C)] // ok!\n+struct MyStruct {\n+    my_field: usize\n+}\n+```\n+\n+For more information about specifying representations, see the [\"Alternative\n+Representations\" section] of the Rustonomicon.\n+\n+[\"Alternative Representations\" section]: https://doc.rust-lang.org/nomicon/other-reprs.html"}, {"sha": "e25212983ebcc784d56490ce8877861e9dbac2bc", "filename": "src/librustc_error_codes/error_codes/E0554.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0554.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0554.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0554.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,12 @@\n+Feature attributes are only allowed on the nightly release channel. Stable or\n+beta compilers will not comply.\n+\n+Example of erroneous code (on a stable compiler):\n+\n+```ignore (depends on release channel)\n+#![feature(non_ascii_idents)] // error: `#![feature]` may not be used on the\n+                              //        stable release channel\n+```\n+\n+If you need the feature, make sure to use a nightly release of the compiler\n+(but be warned that the feature may be removed or altered in the future)."}, {"sha": "2aac8240d293ac1d1b213177820575adaf485d89", "filename": "src/librustc_error_codes/error_codes/E0556.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0556.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0556.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0556.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,16 @@\n+The `feature` attribute was badly formed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0556\n+#![feature(foo_bar_baz, foo(bar), foo = \"baz\", foo)] // error!\n+#![feature] // error!\n+#![feature = \"foo\"] // error!\n+```\n+\n+The `feature` attribute only accept a \"feature flag\" and can only be used on\n+nightly. Example:\n+\n+```ignore (only works in nightly)\n+#![feature(flag)]\n+```"}, {"sha": "f330efe59336a3acac07ceb1a6b7d63417983313", "filename": "src/librustc_error_codes/error_codes/E0557.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0557.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0557.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0557.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,9 @@\n+A feature attribute named a feature that has been removed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0557\n+#![feature(managed_boxes)] // error: feature has been removed\n+```\n+\n+Delete the offending feature attribute."}, {"sha": "b9f7b650892f1ec6857bbd90517d5a7c52169175", "filename": "src/librustc_error_codes/error_codes/E0559.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0559.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0559.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0559.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+An unknown field was specified into an enum's structure variant.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0559\n+enum Field {\n+    Fool { x: u32 },\n+}\n+\n+let s = Field::Fool { joke: 0 };\n+// error: struct variant `Field::Fool` has no field named `joke`\n+```\n+\n+Verify you didn't misspell the field's name or that the field exists. Example:\n+\n+```\n+enum Field {\n+    Fool { joke: u32 },\n+}\n+\n+let s = Field::Fool { joke: 0 }; // ok!\n+```"}, {"sha": "7185bf38c233dae3a7e699bd2a764100aae2c720", "filename": "src/librustc_error_codes/error_codes/E0560.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0560.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0560.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0560.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,23 @@\n+An unknown field was specified into a structure.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0560\n+struct Simba {\n+    mother: u32,\n+}\n+\n+let s = Simba { mother: 1, father: 0 };\n+// error: structure `Simba` has no field named `father`\n+```\n+\n+Verify you didn't misspell the field's name or that the field exists. Example:\n+\n+```\n+struct Simba {\n+    mother: u32,\n+    father: u32,\n+}\n+\n+let s = Simba { mother: 1, father: 0 }; // ok!\n+```"}, {"sha": "5290018901498178e71200fd75cc226f12051f1f", "filename": "src/librustc_error_codes/error_codes/E0561.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0561.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0561.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0561.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+A non-ident or non-wildcard pattern has been used as a parameter of a function\n+pointer type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0561\n+type A1 = fn(mut param: u8); // error!\n+type A2 = fn(&param: u32); // error!\n+```\n+\n+When using an alias over a function type, you cannot e.g. denote a parameter as\n+being mutable.\n+\n+To fix the issue, remove patterns (`_` is allowed though). Example:\n+\n+```\n+type A1 = fn(param: u8); // ok!\n+type A2 = fn(_: u32); // ok!\n+```\n+\n+You can also omit the parameter name:\n+\n+```\n+type A3 = fn(i16); // ok!\n+```"}, {"sha": "95f038df56d63eab02406aaa983d439edeeaf903", "filename": "src/librustc_error_codes/error_codes/E0562.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0562.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0562.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0562.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,33 @@\n+Abstract return types (written `impl Trait` for some trait `Trait`) are only\n+allowed as function and inherent impl return types.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0562\n+fn main() {\n+    let count_to_ten: impl Iterator<Item=usize> = 0..10;\n+    // error: `impl Trait` not allowed outside of function and inherent method\n+    //        return types\n+    for i in count_to_ten {\n+        println!(\"{}\", i);\n+    }\n+}\n+```\n+\n+Make sure `impl Trait` only appears in return-type position.\n+\n+```\n+fn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n+    0..n\n+}\n+\n+fn main() {\n+    for i in count_to_n(10) {  // ok!\n+        println!(\"{}\", i);\n+    }\n+}\n+```\n+\n+See [RFC 1522] for more details.\n+\n+[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md"}, {"sha": "1faedf45932710f6ef259da5f8c6f3d2d994b790", "filename": "src/librustc_error_codes/error_codes/E0565.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0565.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0565.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0565.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,17 @@\n+A literal was used in a built-in attribute that doesn't support literals.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline(\"always\")] // error: unsupported literal\n+pub fn something() {}\n+```\n+\n+Literals in attributes are new and largely unsupported in built-in attributes.\n+Work to support literals where appropriate is ongoing. Try using an unquoted\n+name instead:\n+\n+```\n+#[inline(always)]\n+pub fn something() {}\n+```"}, {"sha": "62fb66f61497683d32beda4a5c8d81b0815111f1", "filename": "src/librustc_error_codes/error_codes/E0566.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0566.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0566.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0566.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+Conflicting representation hints have been used on a same item.\n+\n+Erroneous code example:\n+\n+```\n+#[repr(u32, u64)] // warning!\n+enum Repr { A }\n+```\n+\n+In most cases (if not all), using just one representation hint is more than\n+enough. If you want to have a representation hint depending on the current\n+architecture, use `cfg_attr`. Example:\n+\n+```\n+#[cfg_attr(linux, repr(u32))]\n+#[cfg_attr(not(linux), repr(u64))]\n+enum Repr { A }\n+```"}, {"sha": "ec1ed03c126e13d8fe5272f8c28137293e3b6d3e", "filename": "src/librustc_error_codes/error_codes/E0567.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0567.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0567.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0567.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+Generics have been used on an auto trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0567\n+#![feature(optin_builtin_traits)]\n+\n+auto trait Generic<T> {} // error!\n+\n+fn main() {}\n+```\n+\n+Since an auto trait is implemented on all existing types, the\n+compiler would not be able to infer the types of the trait's generic\n+parameters.\n+\n+To fix this issue, just remove the generics:\n+\n+```\n+#![feature(optin_builtin_traits)]\n+\n+auto trait Generic {} // ok!\n+\n+fn main() {}\n+```"}, {"sha": "a37381f1cbd1633aceb0a7612f4d4feefb0258ad", "filename": "src/librustc_error_codes/error_codes/E0568.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0568.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0568.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0568.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,26 @@\n+A super trait has been added to an auto trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0568\n+#![feature(optin_builtin_traits)]\n+\n+auto trait Bound : Copy {} // error!\n+\n+fn main() {}\n+```\n+\n+Since an auto trait is implemented on all existing types, adding a super trait\n+would filter out a lot of those types. In the current example, almost none of\n+all the existing types could implement `Bound` because very few of them have the\n+`Copy` trait.\n+\n+To fix this issue, just remove the super trait:\n+\n+```\n+#![feature(optin_builtin_traits)]\n+\n+auto trait Bound {} // ok!\n+\n+fn main() {}\n+```"}, {"sha": "4cba0cf9c96baab174750a9090ad118deb4fabd8", "filename": "src/librustc_error_codes/error_codes/E0569.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0569.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0569.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0569.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,18 @@\n+If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n+that impl must be declared as an `unsafe impl.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0569\n+#![feature(dropck_eyepatch)]\n+\n+struct Foo<X>(X);\n+impl<#[may_dangle] X> Drop for Foo<X> {\n+    fn drop(&mut self) { }\n+}\n+```\n+\n+In this example, we are asserting that the destructor for `Foo` will not\n+access any data of type `X`, and require this assertion to be true for\n+overall safety in our program. The compiler does not currently attempt to\n+verify this assertion; therefore we must tag this `impl` as unsafe."}, {"sha": "bf9615f87387d85041d8e2b71d973c0645a1aba7", "filename": "src/librustc_error_codes/error_codes/E0570.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0570.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0570.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0570.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,7 @@\n+The requested ABI is unsupported by the current target.\n+\n+The rust compiler maintains for each target a blacklist of ABIs unsupported on\n+that target. If an ABI is present in such a list this usually means that the\n+target / ABI combination is currently unsupported by llvm.\n+\n+If necessary, you can circumvent this check using custom target specifications."}, {"sha": "c2a3a8d75888196be0567f616a5d1aa7747d5360", "filename": "src/librustc_error_codes/error_codes/E0571.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0571.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0571.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0571.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,31 @@\n+A `break` statement with an argument appeared in a non-`loop` loop.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0571\n+# let mut i = 1;\n+# fn satisfied(n: usize) -> bool { n % 23 == 0 }\n+let result = while true {\n+    if satisfied(i) {\n+        break 2*i; // error: `break` with value from a `while` loop\n+    }\n+    i += 1;\n+};\n+```\n+\n+The `break` statement can take an argument (which will be the value of the loop\n+expression if the `break` statement is executed) in `loop` loops, but not\n+`for`, `while`, or `while let` loops.\n+\n+Make sure `break value;` statements only occur in `loop` loops:\n+\n+```\n+# let mut i = 1;\n+# fn satisfied(n: usize) -> bool { n % 23 == 0 }\n+let result = loop { // ok!\n+    if satisfied(i) {\n+        break 2*i;\n+    }\n+    i += 1;\n+};\n+```"}, {"sha": "b2660650f1bdbde5e0f8b546a85ab5fbfa135178", "filename": "src/librustc_error_codes/error_codes/E0572.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0572.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0572.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0572.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+A return statement was found outside of a function body.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0572\n+const FOO: u32 = return 0; // error: return statement outside of function body\n+\n+fn main() {}\n+```\n+\n+To fix this issue, just remove the return keyword or move the expression into a\n+function. Example:\n+\n+```\n+const FOO: u32 = 0;\n+\n+fn some_fn() -> u32 {\n+    return FOO;\n+}\n+\n+fn main() {\n+    some_fn();\n+}\n+```"}, {"sha": "6021ed0ef211bdfe4fdb05e0abe9843cff411b41", "filename": "src/librustc_error_codes/error_codes/E0573.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0573.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0573.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0573.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,71 @@\n+Something other than a type has been used when one was expected.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0573\n+enum Dragon {\n+    Born,\n+}\n+\n+fn oblivion() -> Dragon::Born { // error!\n+    Dragon::Born\n+}\n+\n+const HOBBIT: u32 = 2;\n+impl HOBBIT {} // error!\n+\n+enum Wizard {\n+    Gandalf,\n+    Saruman,\n+}\n+\n+trait Isengard {\n+    fn wizard(_: Wizard::Saruman); // error!\n+}\n+```\n+\n+In all these errors, a type was expected. For example, in the first error, if\n+we want to return the `Born` variant from the `Dragon` enum, we must set the\n+function to return the enum and not its variant:\n+\n+```\n+enum Dragon {\n+    Born,\n+}\n+\n+fn oblivion() -> Dragon { // ok!\n+    Dragon::Born\n+}\n+```\n+\n+In the second error, you can't implement something on an item, only on types.\n+We would need to create a new type if we wanted to do something similar:\n+\n+```\n+struct Hobbit(u32); // we create a new type\n+\n+const HOBBIT: Hobbit = Hobbit(2);\n+impl Hobbit {} // ok!\n+```\n+\n+In the third case, we tried to only expect one variant of the `Wizard` enum,\n+which is not possible. To make this work, we need to using pattern matching\n+over the `Wizard` enum:\n+\n+```\n+enum Wizard {\n+    Gandalf,\n+    Saruman,\n+}\n+\n+trait Isengard {\n+    fn wizard(w: Wizard) { // ok!\n+        match w {\n+            Wizard::Saruman => {\n+                // do something\n+            }\n+            _ => {} // ignore everything else\n+        }\n+    }\n+}\n+```"}, {"sha": "8154d5b782e36a18b0d234093260cdefeaa092db", "filename": "src/librustc_error_codes/error_codes/E0574.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0574.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0574.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0574.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,47 @@\n+Something other than a struct, variant or union has been used when one was\n+expected.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0574\n+mod Mordor {}\n+\n+let sauron = Mordor { x: () }; // error!\n+\n+enum Jak {\n+    Daxter { i: isize },\n+}\n+\n+let eco = Jak::Daxter { i: 1 };\n+match eco {\n+    Jak { i } => {} // error!\n+}\n+```\n+\n+In all these errors, a type was expected. For example, in the first error,\n+we tried to instantiate the `Mordor` module, which is impossible. If you want\n+to instantiate a type inside a module, you can do it as follow:\n+\n+```\n+mod Mordor {\n+    pub struct TheRing {\n+        pub x: usize,\n+    }\n+}\n+\n+let sauron = Mordor::TheRing { x: 1 }; // ok!\n+```\n+\n+In the second error, we tried to bind the `Jak` enum directly, which is not\n+possible: you can only bind one of its variants. To do so:\n+\n+```\n+enum Jak {\n+    Daxter { i: isize },\n+}\n+\n+let eco = Jak::Daxter { i: 1 };\n+match eco {\n+    Jak::Daxter { i } => {} // ok!\n+}\n+```"}, {"sha": "903939a9af983dae8c1e88364b4e682bce848069", "filename": "src/librustc_error_codes/error_codes/E0575.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0575.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0575.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0575.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,50 @@\n+Something other than a type or an associated type was given.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0575\n+enum Rick { Morty }\n+\n+let _: <u8 as Rick>::Morty; // error!\n+\n+trait Age {\n+    type Empire;\n+    fn Mythology() {}\n+}\n+\n+impl Age for u8 {\n+    type Empire = u16;\n+}\n+\n+let _: <u8 as Age>::Mythology; // error!\n+```\n+\n+In both cases, we're declaring a variable (called `_`) and we're giving it a\n+type. However, `<u8 as Rick>::Morty` and `<u8 as Age>::Mythology` aren't types,\n+therefore the compiler throws an error.\n+\n+`<u8 as Rick>::Morty` is an enum variant, you cannot use a variant as a type,\n+you have to use the enum directly:\n+\n+```\n+enum Rick { Morty }\n+\n+let _: Rick; // ok!\n+```\n+\n+`<u8 as Age>::Mythology` is a trait method, which is definitely not a type.\n+However, the `Age` trait provides an associated type `Empire` which can be\n+used as a type:\n+\n+```\n+trait Age {\n+    type Empire;\n+    fn Mythology() {}\n+}\n+\n+impl Age for u8 {\n+    type Empire = u16;\n+}\n+\n+let _: <u8 as Age>::Empire; // ok!\n+```"}, {"sha": "8eead4e7e3b51cd3acb3c8b54adc8eed69a9c1c1", "filename": "src/librustc_error_codes/error_codes/E0576.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0576.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0576.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0576.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,22 @@\n+An associated item wasn't found in the given type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0576\n+trait Hello {\n+    type Who;\n+\n+    fn hello() -> <Self as Hello>::You; // error!\n+}\n+```\n+\n+In this example, we tried to use the non-existent associated type `You` of the\n+`Hello` trait. To fix this error, use an existing associated type:\n+\n+```\n+trait Hello {\n+    type Who;\n+\n+    fn hello() -> <Self as Hello>::Who; // ok!\n+}\n+```"}, {"sha": "1feb9c0acf36497aba158da009e8e36665711cae", "filename": "src/librustc_error_codes/error_codes/E0577.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0577.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0577.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0577.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,24 @@\n+Something other than a module was found in visibility scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0577,edition2018\n+pub struct Sea;\n+\n+pub (in crate::Sea) struct Shark; // error!\n+\n+fn main() {}\n+```\n+\n+`Sea` is not a module, therefore it is invalid to use it in a visibility path.\n+To fix this error we need to ensure `Sea` is a module.\n+\n+Please note that the visibility scope can only be applied on ancestors!\n+\n+```edition2018\n+pub mod Sea {\n+    pub (in crate::Sea) struct Shark; // ok!\n+}\n+\n+fn main() {}\n+```"}, {"sha": "fca89757287f54a2f35a118c026257d8c11b1d2e", "filename": "src/librustc_error_codes/error_codes/E0578.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0578.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0578.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0578.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,25 @@\n+A module cannot be found and therefore, the visibility cannot be determined.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0578,edition2018\n+foo!();\n+\n+pub (in ::Sea) struct Shark; // error!\n+\n+fn main() {}\n+```\n+\n+Because of the call to the `foo` macro, the compiler guesses that the missing\n+module could be inside it and fails because the macro definition cannot be\n+found.\n+\n+To fix this error, please be sure that the module is in scope:\n+\n+```edition2018\n+pub mod Sea {\n+    pub (in crate::Sea) struct Shark;\n+}\n+\n+fn main() {}\n+```"}, {"sha": "225e27f0cab8329e33063b547a7c801e25acff27", "filename": "src/librustc_error_codes/error_codes/E0579.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0579.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0579.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0579.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,19 @@\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0579\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    match 5u32 {\n+        // This range is ok, albeit pointless.\n+        1 .. 2 => {}\n+        // This range is empty, and the compiler can tell.\n+        5 .. 5 => {} // error!\n+    }\n+}\n+```"}, {"sha": "260575d5de4a2c87be188253aa60742cfe5d3a7a", "filename": "src/librustc_error_codes/error_codes/E0580.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0580.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0580.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0580.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,21 @@\n+The `main` function was incorrectly declared.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0580\n+fn main(x: i32) { // error: main function has wrong type\n+    println!(\"{}\", x);\n+}\n+```\n+\n+The `main` function prototype should never take arguments.\n+Example:\n+\n+```\n+fn main() {\n+    // your code\n+}\n+```\n+\n+If you want to get command-line arguments, use `std::env::args`. To exit with a\n+specified exit code, use `std::process::exit`."}, {"sha": "947ec255a9db863c3a947e7888f4a4b58ab78a8c", "filename": "src/librustc_error_codes/error_codes/E0581.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0581.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0581.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0581.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,28 @@\n+In a `fn` type, a lifetime appears only in the return type,\n+and not in the arguments types.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0581\n+fn main() {\n+    // Here, `'a` appears only in the return type:\n+    let x: for<'a> fn() -> &'a i32;\n+}\n+```\n+\n+To fix this issue, either use the lifetime in the arguments, or use\n+`'static`. Example:\n+\n+```\n+fn main() {\n+    // Here, `'a` appears only in the return type:\n+    let x: for<'a> fn(&'a i32) -> &'a i32;\n+    let y: fn() -> &'static i32;\n+}\n+```\n+\n+Note: The examples above used to be (erroneously) accepted by the\n+compiler, but this was since corrected. See [issue #33685] for more\n+details.\n+\n+[issue #33685]: https://github.com/rust-lang/rust/issues/33685"}, {"sha": "c0cf44852c4ef41291428988020c89c38dc03fb3", "filename": "src/librustc_error_codes/error_codes/E0582.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0582.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd274632f8c78dbd534c016d5298655a5c116221/src%2Flibrustc_error_codes%2Ferror_codes%2FE0582.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0582.md?ref=cd274632f8c78dbd534c016d5298655a5c116221", "patch": "@@ -0,0 +1,34 @@\n+A lifetime appears only in an associated-type binding,\n+and not in the input types to the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0582\n+fn bar<F>(t: F)\n+    // No type can satisfy this requirement, since `'a` does not\n+    // appear in any of the input types (here, `i32`):\n+    where F: for<'a> Fn(i32) -> Option<&'a i32>\n+{\n+}\n+\n+fn main() { }\n+```\n+\n+To fix this issue, either use the lifetime in the inputs, or use\n+`'static`. Example:\n+\n+```\n+fn bar<F, G>(t: F, u: G)\n+    where F: for<'a> Fn(&'a i32) -> Option<&'a i32>,\n+          G: Fn(i32) -> Option<&'static i32>,\n+{\n+}\n+\n+fn main() { }\n+```\n+\n+Note: The examples above used to be (erroneously) accepted by the\n+compiler, but this was since corrected. See [issue #33685] for more\n+details.\n+\n+[issue #33685]: https://github.com/rust-lang/rust/issues/33685"}]}