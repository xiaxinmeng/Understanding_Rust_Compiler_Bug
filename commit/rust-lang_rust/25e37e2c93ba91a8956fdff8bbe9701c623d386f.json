{"sha": "25e37e2c93ba91a8956fdff8bbe9701c623d386f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZTM3ZTJjOTNiYTkxYTg5NTZmZGZmOGJiZTk3MDFjNjIzZDM4NmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-09T09:29:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-09T09:29:11Z"}, "message": "Merge #4175\n\n4175: Introduce HirDisplay method for rendering source code & use it in add_function assist r=flodiebold a=TimoFreiberg\n\nNext feature for #3639.\r\n\r\nSo far the only change in the new `HirDisplay` method is that paths are qualified, but more changes will be necessary (omitting the function name from function types, returning an error instead of printing `\"{unknown}\"`, probably more).\r\n\r\nIs that approach okay?\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>", "tree": {"sha": "c8c3d772e9ad5a71f7ea911b4c82a2f373211143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c3d772e9ad5a71f7ea911b4c82a2f373211143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25e37e2c93ba91a8956fdff8bbe9701c623d386f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetnfnCRBK7hj4Ov3rIwAAdHIIAE6L6Aq4zJEi7bTfNsW7l18Q\nIiCTwacQvSPKwqBoDACPg+nyMITbgqd6YI+u3REPi6DkOgmHJuLuHaqUUldVVD1c\n9gcNv0gTeaDWL0mnrOW9+fa22kBQxWL5pkRAztf6VZGwckbpc+C8oytyJg/MjDeh\nPnX8ykE97liPqr70j6rtrF/97H5ZeC0dxPbP5p4gDO/dsqKZyFht9Mwho/53Ie4u\nbHVVOfN1dwcfoZueqlNCjoh2jb65PaPM2DAlgm4L87wNbhPqv1uC5x5E6rfi7Owo\nAsObSnQz+l+kyuFmBQ2kNF9EZJSyMvpeVGwxnPhRTBG6Dbzn6Ifa9pkYdlNvm5g=\n=BfB+\n-----END PGP SIGNATURE-----\n", "payload": "tree c8c3d772e9ad5a71f7ea911b4c82a2f373211143\nparent d7a0b0ff913d717fa6e7c5a1db02a30316760a75\nparent 64e6b8200bfceea92b0dcaab3e533a9152994e78\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589016551 +0000\ncommitter GitHub <noreply@github.com> 1589016551 +0000\n\nMerge #4175\n\n4175: Introduce HirDisplay method for rendering source code & use it in add_function assist r=flodiebold a=TimoFreiberg\n\nNext feature for #3639.\r\n\r\nSo far the only change in the new `HirDisplay` method is that paths are qualified, but more changes will be necessary (omitting the function name from function types, returning an error instead of printing `\"{unknown}\"`, probably more).\r\n\r\nIs that approach okay?\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25e37e2c93ba91a8956fdff8bbe9701c623d386f", "html_url": "https://github.com/rust-lang/rust/commit/25e37e2c93ba91a8956fdff8bbe9701c623d386f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25e37e2c93ba91a8956fdff8bbe9701c623d386f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7a0b0ff913d717fa6e7c5a1db02a30316760a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a0b0ff913d717fa6e7c5a1db02a30316760a75", "html_url": "https://github.com/rust-lang/rust/commit/d7a0b0ff913d717fa6e7c5a1db02a30316760a75"}, {"sha": "64e6b8200bfceea92b0dcaab3e533a9152994e78", "url": "https://api.github.com/repos/rust-lang/rust/commits/64e6b8200bfceea92b0dcaab3e533a9152994e78", "html_url": "https://github.com/rust-lang/rust/commit/64e6b8200bfceea92b0dcaab3e533a9152994e78"}], "stats": {"total": 399, "additions": 300, "deletions": 99}, "files": [{"sha": "95faf0f4feea3c7446ba06663e43a5700b27522c", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 116, "deletions": 58, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=25e37e2c93ba91a8956fdff8bbe9701c623d386f", "patch": "@@ -43,16 +43,12 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         return None;\n     }\n \n-    let target_module = if let Some(qualifier) = path.qualifier() {\n-        if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) =\n-            ctx.sema.resolve_path(&qualifier)\n-        {\n-            Some(module.definition_source(ctx.sema.db))\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        None\n+    let target_module = match path.qualifier() {\n+        Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => Some(module),\n+            _ => return None,\n+        },\n+        None => None,\n     };\n \n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n@@ -83,25 +79,29 @@ struct FunctionBuilder {\n }\n \n impl FunctionBuilder {\n-    /// Prepares a generated function that matches `call` in `generate_in`\n-    /// (or as close to `call` as possible, if `generate_in` is `None`)\n+    /// Prepares a generated function that matches `call`.\n+    /// The function is generated in `target_module` or next to `call`\n     fn from_call(\n         ctx: &AssistContext,\n         call: &ast::CallExpr,\n         path: &ast::Path,\n-        target_module: Option<hir::InFile<hir::ModuleSource>>,\n+        target_module: Option<hir::Module>,\n     ) -> Option<Self> {\n-        let needs_pub = target_module.is_some();\n         let mut file = ctx.frange.file_id;\n-        let target = if let Some(target_module) = target_module {\n-            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, target_module)?;\n-            file = in_file;\n-            target\n-        } else {\n-            next_space_for_fn_after_call_site(&call)?\n+        let target = match &target_module {\n+            Some(target_module) => {\n+                let module_source = target_module.definition_source(ctx.db);\n+                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+                file = in_file;\n+                target\n+            }\n+            None => next_space_for_fn_after_call_site(&call)?,\n         };\n+        let needs_pub = target_module.is_some();\n+        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = fn_name(&path)?;\n-        let (type_params, params) = fn_args(ctx, &call)?;\n+        let (type_params, params) = fn_args(ctx, target_module, &call)?;\n+\n         Some(Self { target, fn_name, type_params, params, file, needs_pub })\n     }\n \n@@ -144,6 +144,15 @@ enum GeneratedFunctionTarget {\n     InEmptyItemList(ast::ItemList),\n }\n \n+impl GeneratedFunctionTarget {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            GeneratedFunctionTarget::BehindItem(it) => it,\n+            GeneratedFunctionTarget::InEmptyItemList(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n     Some(ast::make::name(&name))\n@@ -152,17 +161,17 @@ fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n     ctx: &AssistContext,\n+    target_module: hir::Module,\n     call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n-        let arg_name = match fn_arg_name(&arg) {\n+        arg_names.push(match fn_arg_name(&arg) {\n             Some(name) => name,\n             None => String::from(\"arg\"),\n-        };\n-        arg_names.push(arg_name);\n-        arg_types.push(match fn_arg_type(ctx, &arg) {\n+        });\n+        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n             Some(ty) => ty,\n             None => String::from(\"()\"),\n         });\n@@ -218,12 +227,21 @@ fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistContext, fn_arg: &ast::Expr) -> Option<String> {\n+fn fn_arg_type(\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n+    fn_arg: &ast::Expr,\n+) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n     }\n-    Some(ty.display(ctx.sema.db).to_string())\n+\n+    if let Ok(rendered) = ty.display_source_code(ctx.db, target_module.into()) {\n+        Some(rendered)\n+    } else {\n+        None\n+    }\n }\n \n /// Returns the position inside the current mod or file\n@@ -252,10 +270,10 @@ fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFu\n \n fn next_space_for_fn_in_module(\n     db: &dyn hir::db::AstDatabase,\n-    module: hir::InFile<hir::ModuleSource>,\n+    module_source: &hir::InFile<hir::ModuleSource>,\n ) -> Option<(FileId, GeneratedFunctionTarget)> {\n-    let file = module.file_id.original_file(db);\n-    let assist_item = match module.value {\n+    let file = module_source.file_id.original_file(db);\n+    let assist_item = match &module_source.value {\n         hir::ModuleSource::SourceFile(it) => {\n             if let Some(last_item) = it.items().last() {\n                 GeneratedFunctionTarget::BehindItem(last_item.syntax().clone())\n@@ -599,8 +617,33 @@ fn bar(foo: impl Foo) {\n     }\n \n     #[test]\n-    #[ignore]\n-    // FIXME print paths properly to make this test pass\n+    fn borrowed_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar<|>(&baz())\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar(&baz())\n+}\n+\n+fn bar(baz: &Baz) {\n+    <|>todo!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n     fn add_function_with_qualified_path_arg() {\n         check_assist(\n             add_function,\n@@ -609,25 +652,21 @@ mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        <|>bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    <|>bar(Baz::baz())\n }\n \",\n             r\"\n mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    bar(Baz::baz())\n+}\n \n-    fn bar(baz: super::Baz::Bof) {\n-        <|>todo!()\n-    }\n+fn bar(baz: Baz::Bof) {\n+    <|>todo!()\n }\n \",\n         )\n@@ -808,6 +847,40 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    #[ignore]\n+    // Ignored until local imports are supported.\n+    // See https://github.com/rust-analyzer/rust-analyzer/issues/1165\n+    fn qualified_path_uses_correct_scope() {\n+        check_assist(\n+            add_function,\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz<|>(foo)\n+}\n+\",\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz(foo)\n+}\n+\n+fn baz(foo: foo::Foo) {\n+    <|>todo!()\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n@@ -919,21 +992,6 @@ fn bar(baz: ()) {}\n         )\n     }\n \n-    #[test]\n-    fn add_function_not_applicable_if_function_path_not_singleton() {\n-        // In the future this assist could be extended to generate functions\n-        // if the path is in the same crate (or even the same workspace).\n-        // For the beginning, I think this is fine.\n-        check_assist_not_applicable(\n-            add_function,\n-            r\"\n-fn foo() {\n-    other_crate::bar<|>();\n-}\n-        \",\n-        )\n-    }\n-\n     #[test]\n     #[ignore]\n     fn create_method_with_no_args() {"}, {"sha": "be18c845c643d7a8dcf2c0b346a1e84e913ef1d8", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=25e37e2c93ba91a8956fdff8bbe9701c623d386f", "patch": "@@ -22,8 +22,11 @@ use hir_expand::{\n     MacroDefId, MacroDefKind,\n };\n use hir_ty::{\n-    autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    autoderef,\n+    display::{HirDisplayError, HirFormatter},\n+    expr::ExprValidator,\n+    method_resolution, ApplicationTy, Canonical, InEnvironment, Substs, TraitEnvironment, Ty,\n+    TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n@@ -1319,7 +1322,7 @@ impl Type {\n }\n \n impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> std::fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.ty.value.hir_fmt(f)\n     }\n }"}, {"sha": "f5edaea8c80683f49b29a33ff4ea069fbf0f2008", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 140, "deletions": 36, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=25e37e2c93ba91a8956fdff8bbe9701c623d386f", "patch": "@@ -6,28 +6,42 @@ use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n     Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n-use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n+use hir_def::{\n+    find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n+    Lookup, ModuleId,\n+};\n use hir_expand::name::Name;\n \n-pub struct HirFormatter<'a, 'b> {\n+pub struct HirFormatter<'a> {\n     pub db: &'a dyn HirDatabase,\n-    fmt: &'a mut fmt::Formatter<'b>,\n+    fmt: &'a mut dyn fmt::Write,\n     buf: String,\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n }\n \n pub trait HirDisplay {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result;\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError>;\n \n+    /// Returns a `Display`able type that is human-readable.\n+    /// Use this for showing types to the user (e.g. diagnostics)\n     fn display<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, None, false)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n     }\n \n+    /// Returns a `Display`able type that is human-readable and tries to be succinct.\n+    /// Use this for showing types to the user where space is constrained (e.g. doc popups)\n     fn display_truncated<'a>(\n         &'a self,\n         db: &'a dyn HirDatabase,\n@@ -36,16 +50,46 @@ pub trait HirDisplay {\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, max_size, true)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size,\n+            omit_verbose_types: true,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n+    }\n+\n+    /// Returns a String representation of `self` that can be inserted into the given module.\n+    /// Use this when generating code (e.g. assists)\n+    fn display_source_code<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+        module_id: ModuleId,\n+    ) -> Result<String, DisplaySourceCodeError> {\n+        let mut result = String::new();\n+        match self.hir_fmt(&mut HirFormatter {\n+            db,\n+            fmt: &mut result,\n+            buf: String::with_capacity(20),\n+            curr_size: 0,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::SourceCode { module_id },\n+        }) {\n+            Ok(()) => {}\n+            Err(HirDisplayError::FmtError) => panic!(\"Writing to String can't fail!\"),\n+            Err(HirDisplayError::DisplaySourceCodeError(e)) => return Err(e),\n+        };\n+        Ok(result)\n     }\n }\n \n-impl<'a, 'b> HirFormatter<'a, 'b> {\n+impl<'a> HirFormatter<'a> {\n     pub fn write_joined<T: HirDisplay>(\n         &mut self,\n         iter: impl IntoIterator<Item = T>,\n         sep: &str,\n-    ) -> fmt::Result {\n+    ) -> Result<(), HirDisplayError> {\n         let mut first = true;\n         for e in iter {\n             if !first {\n@@ -58,14 +102,14 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n \n     /// This allows using the `write!` macro directly with a `HirFormatter`.\n-    pub fn write_fmt(&mut self, args: fmt::Arguments) -> fmt::Result {\n+    pub fn write_fmt(&mut self, args: fmt::Arguments) -> Result<(), HirDisplayError> {\n         // We write to a buffer first to track output size\n         self.buf.clear();\n         fmt::write(&mut self.buf, args)?;\n         self.curr_size += self.buf.len();\n \n         // Then we write to the internal formatter from the buffer\n-        self.fmt.write_str(&self.buf)\n+        self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)\n     }\n \n     pub fn should_truncate(&self) -> bool {\n@@ -81,34 +125,76 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n }\n \n-pub struct HirDisplayWrapper<'a, T>(&'a dyn HirDatabase, &'a T, Option<usize>, bool);\n+#[derive(Clone, Copy)]\n+enum DisplayTarget {\n+    /// Display types for inlays, doc popups, autocompletion, etc...\n+    /// Showing `{unknown}` or not qualifying paths is fine here.\n+    /// There's no reason for this to fail.\n+    Diagnostics,\n+    /// Display types for inserting them in source files.\n+    /// The generated code should compile, so paths need to be qualified.\n+    SourceCode { module_id: ModuleId },\n+}\n+\n+#[derive(Debug)]\n+pub enum DisplaySourceCodeError {\n+    PathNotFound,\n+}\n+\n+pub enum HirDisplayError {\n+    /// Errors that can occur when generating source code\n+    DisplaySourceCodeError(DisplaySourceCodeError),\n+    /// `FmtError` is required to be compatible with std::fmt::Display\n+    FmtError,\n+}\n+impl From<fmt::Error> for HirDisplayError {\n+    fn from(_: fmt::Error) -> Self {\n+        Self::FmtError\n+    }\n+}\n+\n+pub struct HirDisplayWrapper<'a, T> {\n+    db: &'a dyn HirDatabase,\n+    t: &'a T,\n+    max_size: Option<usize>,\n+    omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n+}\n \n impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n where\n     T: HirDisplay,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.1.hir_fmt(&mut HirFormatter {\n-            db: self.0,\n+        match self.t.hir_fmt(&mut HirFormatter {\n+            db: self.db,\n             fmt: f,\n             buf: String::with_capacity(20),\n             curr_size: 0,\n-            max_size: self.2,\n-            omit_verbose_types: self.3,\n-        })\n+            max_size: self.max_size,\n+            omit_verbose_types: self.omit_verbose_types,\n+            display_target: self.display_target,\n+        }) {\n+            Ok(()) => Ok(()),\n+            Err(HirDisplayError::FmtError) => Err(fmt::Error),\n+            Err(HirDisplayError::DisplaySourceCodeError(_)) => {\n+                // This should never happen\n+                panic!(\"HirDisplay failed when calling Display::fmt!\")\n+            }\n+        }\n     }\n }\n \n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -191,12 +277,30 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n+                match f.display_target {\n+                    DisplayTarget::Diagnostics => {\n+                        let name = match def_id {\n+                            AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                            AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                            AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                        };\n+                        write!(f, \"{}\", name)?;\n+                    }\n+                    DisplayTarget::SourceCode { module_id } => {\n+                        if let Some(path) = find_path::find_path(\n+                            f.db.upcast(),\n+                            ItemInNs::Types(def_id.into()),\n+                            module_id,\n+                        ) {\n+                            write!(f, \"{}\", path)?;\n+                        } else {\n+                            return Err(HirDisplayError::DisplaySourceCodeError(\n+                                DisplaySourceCodeError::PathNotFound,\n+                            ));\n+                        }\n+                    }\n+                }\n+\n                 if self.parameters.len() > 0 {\n                     let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n                     let parameters_to_write = if f.omit_verbose_types() {\n@@ -269,7 +373,7 @@ impl HirDisplay for ApplicationTy {\n }\n \n impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -287,7 +391,7 @@ impl HirDisplay for ProjectionTy {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -332,7 +436,7 @@ impl HirDisplay for Ty {\n fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n     f: &mut HirFormatter,\n-) -> fmt::Result {\n+) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n     // actual Rust. It will have weird results if the predicates\n@@ -394,7 +498,7 @@ fn write_bounds_like_dyn_trait(\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> fmt::Result {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -416,19 +520,19 @@ impl TraitRef {\n }\n \n impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.hir_fmt_ext(f, false)\n     }\n }\n \n impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -452,15 +556,15 @@ impl HirDisplay for GenericPredicate {\n }\n \n impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        Ok(match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db))?,\n             Obligation::Projection(proj) => write!(\n                 f,\n                 \"Normalize({} => {})\",\n                 proj.projection_ty.display(f.db),\n                 proj.ty.display(f.db)\n-            ),\n-        }\n+            )?,\n+        })\n     }\n }"}, {"sha": "1fe05c70c961c02409f2ae349b07db66e2eade25", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=25e37e2c93ba91a8956fdff8bbe9701c623d386f", "patch": "@@ -6,6 +6,7 @@ mod patterns;\n mod traits;\n mod method_resolution;\n mod macros;\n+mod display_source_code;\n \n use std::sync::Arc;\n \n@@ -16,7 +17,7 @@ use hir_def::{\n     item_scope::ItemScope,\n     keys,\n     nameres::CrateDefMap,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use insta::assert_snapshot;\n@@ -37,6 +38,18 @@ use crate::{\n // update the snapshots.\n \n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, _| ty.display(db).to_string())\n+}\n+\n+fn displayed_source_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, module_id| ty.display_source_code(db, module_id).unwrap())\n+}\n+\n+fn type_at_pos_displayed(\n+    db: &TestDB,\n+    pos: FilePosition,\n+    display_fn: impl FnOnce(&Ty, ModuleId) -> String,\n+) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let fn_def = expr.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n@@ -49,7 +62,7 @@ fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n         let infer = db.infer(func.into());\n         let ty = &infer[expr_id];\n-        return ty.display(db).to_string();\n+        return display_fn(ty, module);\n     }\n     panic!(\"Can't find expression\")\n }"}, {"sha": "ca17486152e2be017b9baa498cdc5c6dc8c3965a", "filename": "crates/ra_hir_ty/src/tests/display_source_code.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e37e2c93ba91a8956fdff8bbe9701c623d386f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=25e37e2c93ba91a8956fdff8bbe9701c623d386f", "patch": "@@ -0,0 +1,23 @@\n+use super::displayed_source_at_pos;\n+use crate::test_db::TestDB;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn qualify_path_to_submodule() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+\n+mod foo {\n+    pub struct Foo;\n+}\n+\n+fn bar() {\n+    let foo: foo::Foo = foo::Foo;\n+    foo<|>\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"foo::Foo\", displayed_source_at_pos(&db, pos));\n+}"}]}