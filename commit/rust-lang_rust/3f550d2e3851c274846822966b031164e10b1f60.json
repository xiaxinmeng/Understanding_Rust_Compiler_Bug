{"sha": "3f550d2e3851c274846822966b031164e10b1f60", "node_id": "C_kwDOAAsO6NoAKDNmNTUwZDJlMzg1MWMyNzQ4NDY4MjI5NjZiMDMxMTY0ZTEwYjFmNjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-13T15:43:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-13T15:43:12Z"}, "message": "Merge #11000\n\n11000: fix: insert whitespaces into assoc items for assist when macro generated r=Veykril a=Veykril\n\nThis is obviously only a temporary hack which still produces ugly looking items, but as long as the syntax is valid one can at least have rustfmt fix the formatting again. \r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6588\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "502010a0671e1464f4589c74d967b25c0a841dfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/502010a0671e1464f4589c74d967b25c0a841dfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f550d2e3851c274846822966b031164e10b1f60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJht2oQCRBK7hj4Ov3rIwAAaLcIAK6gwAXjKtiN5K5jNhedX2+M\neVOgwYaWNByON/0UCIAmfm55WguAG95/SdWf5qy8XlSfTqLWyNSxf4bp3hhgfty/\nHTz4vZwZ/+jcaHwE+ogbbZ/vzO/NsHAqFsTvK/KHBTSKz1zyvBKrTdQjlhmnCTxn\ntYrBnOz1+E51iJkldIna3FtdEGVyG+MEkySW3bF9tmKMNkusGEBOYSYKFZ9CAn3N\n7EqHmaEL9UKsPkw4zmX7s2ZosyTX7NlUCDL5ge0OeiuloUzskUTFLAmcwV4o7nSb\nuxsurgtrQoAjABBlX2/q6rg2FwFtt71469tPMnC7fvnrNC7ZBI+zXnlfoPc9E38=\n=lbU2\n-----END PGP SIGNATURE-----\n", "payload": "tree 502010a0671e1464f4589c74d967b25c0a841dfa\nparent db2a7087b994e20f264f26ad6db75184282ad120\nparent 749eeef3e75a3acc993fdd454ebadaa7e319509a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639410192 +0000\ncommitter GitHub <noreply@github.com> 1639410192 +0000\n\nMerge #11000\n\n11000: fix: insert whitespaces into assoc items for assist when macro generated r=Veykril a=Veykril\n\nThis is obviously only a temporary hack which still produces ugly looking items, but as long as the syntax is valid one can at least have rustfmt fix the formatting again. \r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6588\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f550d2e3851c274846822966b031164e10b1f60", "html_url": "https://github.com/rust-lang/rust/commit/3f550d2e3851c274846822966b031164e10b1f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f550d2e3851c274846822966b031164e10b1f60/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db2a7087b994e20f264f26ad6db75184282ad120", "url": "https://api.github.com/repos/rust-lang/rust/commits/db2a7087b994e20f264f26ad6db75184282ad120", "html_url": "https://github.com/rust-lang/rust/commit/db2a7087b994e20f264f26ad6db75184282ad120"}, {"sha": "749eeef3e75a3acc993fdd454ebadaa7e319509a", "url": "https://api.github.com/repos/rust-lang/rust/commits/749eeef3e75a3acc993fdd454ebadaa7e319509a", "html_url": "https://github.com/rust-lang/rust/commit/749eeef3e75a3acc993fdd454ebadaa7e319509a"}], "stats": {"total": 308, "additions": 205, "deletions": 103}, "files": [{"sha": "75f6b025779587ec935b97b721005d16a043ba8f", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -1164,8 +1164,7 @@ impl<'a> SemanticsScope<'a> {\n     }\n \n     /// Note: `FxHashSet<TraitId>` should be treated as an opaque type, passed into `Type\n-    // FIXME: rename to visible_traits to not repeat scope?\n-    pub fn traits_in_scope(&self) -> FxHashSet<TraitId> {\n+    pub fn visible_traits(&self) -> FxHashSet<TraitId> {\n         let resolver = &self.resolver;\n         resolver.traits_in_scope(self.db.upcast())\n     }"}, {"sha": "949744c01b2ae73a79c342bea85f5cb9834776b5", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 7, "deletions": 84, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -1,9 +1,10 @@\n-use std::iter;\n-\n use hir::Semantics;\n-use ide_db::{helpers::pick_best_token, RootDatabase};\n+use ide_db::{\n+    helpers::{insert_whitespace_into_node::insert_ws_into, pick_best_token},\n+    RootDatabase,\n+};\n use itertools::Itertools;\n-use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T};\n+use syntax::{ast, ted, AstNode, SyntaxKind, SyntaxNode};\n \n use crate::FilePosition;\n \n@@ -49,7 +50,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n             let expansions = sema.expand_derive_macro(&attr)?;\n             Some(ExpandedMacro {\n                 name: tt,\n-                expansion: expansions.into_iter().map(insert_whitespaces).join(\"\"),\n+                expansion: expansions.into_iter().map(insert_ws_into).join(\"\"),\n             })\n         } else {\n             None\n@@ -82,7 +83,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n     // FIXME:\n     // macro expansion may lose all white space information\n     // But we hope someday we can use ra_fmt for that\n-    let expansion = insert_whitespaces(expanded?);\n+    let expansion = insert_ws_into(expanded?).to_string();\n     Some(ExpandedMacro { name: name.unwrap_or_else(|| \"???\".to_owned()), expansion })\n }\n \n@@ -122,84 +123,6 @@ fn expand<T: AstNode>(\n     Some(expanded)\n }\n \n-// FIXME: It would also be cool to share logic here and in the mbe tests,\n-// which are pretty unreadable at the moment.\n-fn insert_whitespaces(syn: SyntaxNode) -> String {\n-    use SyntaxKind::*;\n-    let mut res = String::new();\n-\n-    let mut indent = 0;\n-    let mut last: Option<SyntaxKind> = None;\n-\n-    for event in syn.preorder_with_tokens() {\n-        let token = match event {\n-            WalkEvent::Enter(NodeOrToken::Token(token)) => token,\n-            WalkEvent::Leave(NodeOrToken::Node(node))\n-                if matches!(node.kind(), ATTR | MATCH_ARM | STRUCT | ENUM | UNION | FN | IMPL) =>\n-            {\n-                res.push('\\n');\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-                continue;\n-            }\n-            _ => continue,\n-        };\n-        let is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n-            token.next_token().map(|it| f(it.kind())).unwrap_or(default)\n-        };\n-        let is_last =\n-            |f: fn(SyntaxKind) -> bool, default| -> bool { last.map(f).unwrap_or(default) };\n-\n-        match token.kind() {\n-            k if is_text(k) && is_next(|it| !it.is_punct(), true) => {\n-                res.push_str(token.text());\n-                res.push(' ');\n-            }\n-            L_CURLY if is_next(|it| it != R_CURLY, true) => {\n-                indent += 1;\n-                if is_last(is_text, false) {\n-                    res.push(' ');\n-                }\n-                res.push_str(\"{\\n\");\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-            }\n-            R_CURLY if is_last(|it| it != L_CURLY, true) => {\n-                indent = indent.saturating_sub(1);\n-                res.push('\\n');\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-                res.push_str(\"}\");\n-            }\n-            R_CURLY => {\n-                res.push_str(\"}\\n\");\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-            }\n-            LIFETIME_IDENT if is_next(|it| it == IDENT || it == MUT_KW, true) => {\n-                res.push_str(token.text());\n-                res.push(' ');\n-            }\n-            AS_KW => {\n-                res.push_str(token.text());\n-                res.push(' ');\n-            }\n-            T![;] => {\n-                res.push_str(\";\\n\");\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-            }\n-            T![->] => res.push_str(\" -> \"),\n-            T![=] => res.push_str(\" = \"),\n-            T![=>] => res.push_str(\" => \"),\n-            _ => res.push_str(token.text()),\n-        }\n-\n-        last = Some(token.kind());\n-    }\n-\n-    return res;\n-\n-    fn is_text(k: SyntaxKind) -> bool {\n-        k.is_keyword() || k.is_literal() || k == IDENT\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "a10eca10d11946c1b350b0e1189b56c2d91d2de1", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -1,5 +1,5 @@\n use hir::HasSource;\n-use ide_db::traits::resolve_target_trait;\n+use ide_db::{helpers::insert_whitespace_into_node::insert_ws_into, traits::resolve_target_trait};\n use syntax::ast::{self, make, AstNode};\n \n use crate::{\n@@ -105,7 +105,7 @@ fn add_missing_impl_members_inner(\n     let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n \n     let missing_items = filter_assoc_items(\n-        ctx.db(),\n+        &ctx.sema,\n         &ide_db::traits::get_missing_assoc_items(&ctx.sema, &impl_def),\n         mode,\n     );\n@@ -117,6 +117,17 @@ fn add_missing_impl_members_inner(\n     let target = impl_def.syntax().text_range();\n     acc.add(AssistId(assist_id, AssistKind::QuickFix), label, target, |builder| {\n         let target_scope = ctx.sema.scope(impl_def.syntax());\n+        let missing_items = missing_items\n+            .into_iter()\n+            .map(|it| {\n+                if ctx.sema.hir_file_for(it.syntax()).is_macro() {\n+                    if let Some(it) = ast::AssocItem::cast(insert_ws_into(it.syntax().clone())) {\n+                        return it;\n+                    }\n+                }\n+                it.clone_for_update()\n+            })\n+            .collect();\n         let (new_impl_def, first_new_item) = add_trait_assoc_items_to_impl(\n             &ctx.sema,\n             missing_items,\n@@ -890,6 +901,44 @@ impl Default for Foo {\n         Self(Default::default())\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_from_macro() {\n+        check_assist(\n+            add_missing_default_members,\n+            r#\"\n+macro_rules! foo {\n+    () => {\n+        trait FooB {\n+            fn foo<'lt>(&'lt self) {}\n+        }\n+    }\n+}\n+foo!();\n+struct Foo(usize);\n+\n+impl FooB for Foo {\n+    $0\n+}\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+    () => {\n+        trait FooB {\n+            fn foo<'lt>(&'lt self) {}\n+        }\n+    }\n+}\n+foo!();\n+struct Foo(usize);\n+\n+impl FooB for Foo {\n+    $0fn foo< 'lt>(& 'lt self){}\n+\n+}\n \"#,\n         )\n     }"}, {"sha": "7fbbdb4f5eb1f15d591af6c5e5a70d6fd9380f4d", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -148,7 +148,7 @@ fn is_ref_and_impls_iter_method(\n     let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n     let scope = sema.scope(iterable.syntax());\n     let krate = scope.module()?.krate();\n-    let traits_in_scope = scope.traits_in_scope();\n+    let traits_in_scope = scope.visible_traits();\n     let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n \n     let has_wanted_method = ty"}, {"sha": "15025cf0d0e4600320fcd16ecaab097437317a6d", "filename": "crates/ide_assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -92,7 +92,7 @@ fn get_impl_method(\n     let scope = ctx.sema.scope(impl_.syntax());\n     let krate = impl_def.module(db).krate();\n     let ty = impl_def.self_ty(db);\n-    let traits_in_scope = scope.traits_in_scope();\n+    let traits_in_scope = scope.visible_traits();\n     ty.iterate_method_candidates(db, krate, &traits_in_scope, Some(fn_name), |_, func| Some(func))\n }\n "}, {"sha": "b3723710a8631cd40a499349eff837d026188f0d", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -1,4 +1,5 @@\n use hir::ModuleDef;\n+use ide_db::helpers::insert_whitespace_into_node::insert_ws_into;\n use ide_db::helpers::{\n     get_path_at_cursor_in_tt, import_assets::NameToImport, mod_path_to_ast,\n     parse_tt_as_comma_sep_paths,\n@@ -170,7 +171,7 @@ fn impl_def_from_trait(\n ) -> Option<(ast::Impl, ast::AssocItem)> {\n     let trait_ = trait_?;\n     let target_scope = sema.scope(annotated_name.syntax());\n-    let trait_items = filter_assoc_items(sema.db, &trait_.items(sema.db), DefaultMethods::No);\n+    let trait_items = filter_assoc_items(sema, &trait_.items(sema.db), DefaultMethods::No);\n     if trait_items.is_empty() {\n         return None;\n     }\n@@ -193,6 +194,17 @@ fn impl_def_from_trait(\n         node\n     };\n \n+    let trait_items = trait_items\n+        .into_iter()\n+        .map(|it| {\n+            if sema.hir_file_for(it.syntax()).is_macro() {\n+                if let Some(it) = ast::AssocItem::cast(insert_ws_into(it.syntax().clone())) {\n+                    return it;\n+                }\n+            }\n+            it.clone_for_update()\n+        })\n+        .collect();\n     let (impl_def, first_assoc_item) =\n         add_trait_assoc_items_to_impl(sema, trait_items, trait_, impl_def, target_scope);\n "}, {"sha": "90ec710c8e939f7c0ae4a15f194a719b8e275bf5", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -5,7 +5,7 @@ use std::ops;\n use itertools::Itertools;\n \n pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n-use hir::{db::HirDatabase, HasSource, HirDisplay};\n+use hir::{db::HirDatabase, HirDisplay, Semantics};\n use ide_db::{\n     helpers::FamousDefs, helpers::SnippetCap, path_transform::PathTransform, RootDatabase,\n };\n@@ -92,7 +92,7 @@ pub enum DefaultMethods {\n }\n \n pub fn filter_assoc_items(\n-    db: &RootDatabase,\n+    sema: &Semantics<RootDatabase>,\n     items: &[hir::AssocItem],\n     default_methods: DefaultMethods,\n ) -> Vec<ast::AssocItem> {\n@@ -109,11 +109,11 @@ pub fn filter_assoc_items(\n     items\n         .iter()\n         // Note: This throws away items with no source.\n-        .filter_map(|i| {\n+        .filter_map(|&i| {\n             let item = match i {\n-                hir::AssocItem::Function(i) => ast::AssocItem::Fn(i.source(db)?.value),\n-                hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(i.source(db)?.value),\n-                hir::AssocItem::Const(i) => ast::AssocItem::Const(i.source(db)?.value),\n+                hir::AssocItem::Function(i) => ast::AssocItem::Fn(sema.source(i)?.value),\n+                hir::AssocItem::TypeAlias(i) => ast::AssocItem::TypeAlias(sema.source(i)?.value),\n+                hir::AssocItem::Const(i) => ast::AssocItem::Const(sema.source(i)?.value),\n             };\n             Some(item)\n         })\n@@ -129,7 +129,7 @@ pub fn filter_assoc_items(\n }\n \n pub fn add_trait_assoc_items_to_impl(\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    sema: &Semantics<RootDatabase>,\n     items: Vec<ast::AssocItem>,\n     trait_: hir::Trait,\n     impl_: ast::Impl,\n@@ -140,7 +140,6 @@ pub fn add_trait_assoc_items_to_impl(\n     let transform = PathTransform::trait_impl(&target_scope, &source_scope, trait_, impl_.clone());\n \n     let items = items.into_iter().map(|assoc_item| {\n-        let assoc_item = assoc_item.clone_for_update();\n         transform.apply(assoc_item.syntax());\n         assoc_item.remove_attrs_and_docs();\n         assoc_item"}, {"sha": "e7371270fbf6d5ad9be3a51e72f67282cc9a8603", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -79,7 +79,7 @@ fn complete_methods(\n ) {\n     if let Some(krate) = ctx.krate {\n         let mut seen_methods = FxHashSet::default();\n-        let traits_in_scope = ctx.scope.traits_in_scope();\n+        let traits_in_scope = ctx.scope.visible_traits();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n             if func.self_param(ctx.db).is_some() && seen_methods.insert(func.name(ctx.db)) {\n                 f(func);"}, {"sha": "a0d6d5cdc6b91657c7e2c39621f7cfb1328c4ae3", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -187,7 +187,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n             let krate = ctx.krate;\n             if let Some(krate) = krate {\n-                let traits_in_scope = ctx.scope.traits_in_scope();\n+                let traits_in_scope = ctx.scope.visible_traits();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n                     add_assoc_item(acc, ctx, item);\n                     None::<()>\n@@ -220,7 +220,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     add_enum_variants(acc, ctx, e);\n                 }\n \n-                let traits_in_scope = ctx.scope.traits_in_scope();\n+                let traits_in_scope = ctx.scope.visible_traits();\n                 let mut seen = FxHashSet::default();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n                     // We might iterate candidates of a trait multiple times here, so deduplicate"}, {"sha": "18a5f64891e5a9d5c9dade3b4fc1e7c3ce794dd6", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -4,6 +4,7 @@ pub mod generated_lints;\n pub mod import_assets;\n pub mod insert_use;\n pub mod merge_imports;\n+pub mod insert_whitespace_into_node;\n pub mod node_ext;\n pub mod rust_doc;\n "}, {"sha": "251a4caa13278636788c7447599d68f4521ce4a3", "filename": "crates/ide_db/src/helpers/insert_whitespace_into_node.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_whitespace_into_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_whitespace_into_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_whitespace_into_node.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -0,0 +1,119 @@\n+//! Utilities for formatting macro expanded nodes until we get a proper formatter.\n+use syntax::{\n+    ast::make,\n+    ted::{self, Position},\n+    NodeOrToken,\n+    SyntaxKind::{self, *},\n+    SyntaxNode, SyntaxToken, WalkEvent, T,\n+};\n+\n+// FIXME: It would also be cool to share logic here and in the mbe tests,\n+// which are pretty unreadable at the moment.\n+/// Renders a [`SyntaxNode`] with whitespace inserted between tokens that require them.\n+pub fn insert_ws_into(syn: SyntaxNode) -> SyntaxNode {\n+    let mut indent = 0;\n+    let mut last: Option<SyntaxKind> = None;\n+    let mut mods = Vec::new();\n+    let syn = syn.clone_subtree().clone_for_update();\n+\n+    let before = Position::before;\n+    let after = Position::after;\n+\n+    let do_indent = |pos: fn(_) -> Position, token: &SyntaxToken, indent| {\n+        (pos(token.clone()), make::tokens::whitespace(&\" \".repeat(2 * indent)))\n+    };\n+    let do_ws = |pos: fn(_) -> Position, token: &SyntaxToken| {\n+        (pos(token.clone()), make::tokens::single_space())\n+    };\n+    let do_nl = |pos: fn(_) -> Position, token: &SyntaxToken| {\n+        (pos(token.clone()), make::tokens::single_newline())\n+    };\n+\n+    for event in syn.preorder_with_tokens() {\n+        let token = match event {\n+            WalkEvent::Enter(NodeOrToken::Token(token)) => token,\n+            WalkEvent::Leave(NodeOrToken::Node(node))\n+                if matches!(node.kind(), ATTR | MATCH_ARM | STRUCT | ENUM | UNION | FN | IMPL) =>\n+            {\n+                if indent > 0 {\n+                    mods.push((\n+                        Position::after(node.clone()),\n+                        make::tokens::whitespace(&\" \".repeat(2 * indent)),\n+                    ));\n+                }\n+                if node.parent().is_some() {\n+                    mods.push((Position::after(node), make::tokens::single_newline()));\n+                }\n+                continue;\n+            }\n+            _ => continue,\n+        };\n+        let tok = &token;\n+\n+        let is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n+            tok.next_token().map(|it| f(it.kind())).unwrap_or(default)\n+        };\n+        let is_last =\n+            |f: fn(SyntaxKind) -> bool, default| -> bool { last.map(f).unwrap_or(default) };\n+\n+        match tok.kind() {\n+            k if is_text(k) && is_next(|it| !it.is_punct(), true) => {\n+                mods.push(do_ws(after, tok));\n+            }\n+            L_CURLY if is_next(|it| it != R_CURLY, true) => {\n+                indent += 1;\n+                if is_last(is_text, false) {\n+                    mods.push(do_ws(before, tok));\n+                }\n+\n+                if indent > 0 {\n+                    mods.push(do_indent(after, tok, indent));\n+                }\n+                mods.push(do_nl(after, &tok));\n+            }\n+            R_CURLY if is_last(|it| it != L_CURLY, true) => {\n+                indent = indent.saturating_sub(1);\n+\n+                if indent > 0 {\n+                    mods.push(do_indent(before, tok, indent));\n+                }\n+                mods.push(do_nl(before, tok));\n+            }\n+            R_CURLY => {\n+                if indent > 0 {\n+                    mods.push(do_indent(after, tok, indent));\n+                }\n+                mods.push(do_nl(after, tok));\n+            }\n+            LIFETIME_IDENT if is_next(|it| is_text(it), true) => {\n+                mods.push(do_ws(after, tok));\n+            }\n+            AS_KW => {\n+                mods.push(do_ws(after, tok));\n+            }\n+            T![;] => {\n+                if indent > 0 {\n+                    mods.push(do_indent(after, tok, indent));\n+                }\n+                mods.push(do_nl(after, tok));\n+            }\n+            T![->] | T![=] | T![=>] => {\n+                mods.push(do_ws(before, tok));\n+                mods.push(do_ws(after, tok));\n+            }\n+            _ => (),\n+        }\n+\n+        last = Some(tok.kind());\n+    }\n+\n+    for (pos, insert) in mods {\n+        ted::insert(pos, insert);\n+    }\n+\n+    syn\n+}\n+\n+fn is_text(k: SyntaxKind) -> bool {\n+    k.is_keyword() || k.is_literal() || k == IDENT\n+}"}, {"sha": "7902295d2907a6256088c7f907365f64395a4a70", "filename": "crates/ide_ssr/src/resolving.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f550d2e3851c274846822966b031164e10b1f60/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fresolving.rs?ref=3f550d2e3851c274846822966b031164e10b1f60", "patch": "@@ -222,7 +222,7 @@ impl<'db> ResolutionScope<'db> {\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 self.scope.module()?.krate(),\n-                &self.scope.traits_in_scope(),\n+                &self.scope.visible_traits(),\n                 None,\n                 |_ty, assoc_item| {\n                     let item_name = assoc_item.name(self.scope.db)?;"}]}