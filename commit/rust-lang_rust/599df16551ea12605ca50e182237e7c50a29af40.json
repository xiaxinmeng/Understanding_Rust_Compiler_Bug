{"sha": "599df16551ea12605ca50e182237e7c50a29af40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OWRmMTY1NTFlYTEyNjA1Y2E1MGUxODIyMzdlN2M1MGEyOWFmNDA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-10-25T01:42:31Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-10-25T01:42:31Z"}, "message": "rustc_privacy: Expand public node set, build exported node set more correctly", "tree": {"sha": "b1b6c1d913ebc5e18398ac4321b782b7bcd95006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b6c1d913ebc5e18398ac4321b782b7bcd95006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/599df16551ea12605ca50e182237e7c50a29af40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/599df16551ea12605ca50e182237e7c50a29af40", "html_url": "https://github.com/rust-lang/rust/commit/599df16551ea12605ca50e182237e7c50a29af40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/599df16551ea12605ca50e182237e7c50a29af40/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2f41bd5be70544411e5ed42bcdb201e6ab25eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f41bd5be70544411e5ed42bcdb201e6ab25eb2", "html_url": "https://github.com/rust-lang/rust/commit/d2f41bd5be70544411e5ed42bcdb201e6ab25eb2"}], "stats": {"total": 241, "additions": 149, "deletions": 92}, "files": [{"sha": "88b64f6359ed5552ae0bfe7e84af6e0f228e2936", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599df16551ea12605ca50e182237e7c50a29af40/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599df16551ea12605ca50e182237e7c50a29af40/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=599df16551ea12605ca50e182237e7c50a29af40", "patch": "@@ -1159,6 +1159,12 @@ impl StructFieldKind {\n             NamedField(..) => false,\n         }\n     }\n+\n+    pub fn visibility(&self) -> Visibility {\n+        match *self {\n+            NamedField(_, vis) | UnnamedField(vis) => vis\n+        }\n+    }\n }\n \n /// Fields and Ids of enum variants and structs"}, {"sha": "76ff96d62982154e15af032097d70776ebcc5999", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 137, "deletions": 92, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/599df16551ea12605ca50e182237e7c50a29af40/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599df16551ea12605ca50e182237e7c50a29af40/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=599df16551ea12605ca50e182237e7c50a29af40", "patch": "@@ -162,7 +162,7 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     // This is a list of all exported items in the AST. An exported item is any\n     // function/method/item which is usable by external crates. This essentially\n     // means that the result is \"public all the way down\", but the \"path down\"\n-    // may jump across private boundaries through reexport statements.\n+    // may jump across private boundaries through reexport statements or type aliases.\n     exported_items: ExportedItems,\n \n     // This sets contains all the destination nodes which are publicly\n@@ -172,9 +172,12 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     // destination must also be exported.\n     reexports: NodeSet,\n \n+    // Items that are directly public without help of reexports or type aliases.\n     // These two fields are closely related to one another in that they are only\n-    // used for generation of the 'PublicItems' set, not for privacy checking at\n-    // all\n+    // used for generation of the `public_items` set, not for privacy checking at\n+    // all. Public items are mostly a subset of exported items with exception of\n+    // fields and exported macros - they are public, but not exported.\n+    // FIXME: Make fields and exported macros exported as well (requires fixing resulting ICEs)\n     public_items: PublicItems,\n     prev_public: bool,\n }\n@@ -194,58 +197,103 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn exported_trait(&self, _id: ast::NodeId) -> bool {\n         true\n     }\n+\n+    fn is_public_exported_ty(&self, ty: &hir::Ty) -> (bool, bool) {\n+        if let hir::TyPath(..) = ty.node {\n+            match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n+                def::DefPrimTy(..) | def::DefSelfTy(..) => (true, true),\n+                def => {\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n+                        (self.public_items.contains(&node_id),\n+                         self.exported_items.contains(&node_id))\n+                    } else {\n+                        (true, true)\n+                    }\n+                }\n+            }\n+        } else {\n+            (true, true)\n+        }\n+    }\n+\n+    fn is_public_exported_trait(&self, trait_ref: &hir::TraitRef) -> (bool, bool) {\n+        let did = self.tcx.trait_ref_to_def_id(trait_ref);\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            (self.public_items.contains(&node_id), self.exported_items.contains(&node_id))\n+        } else {\n+            (true, true)\n+        }\n+    }\n+\n+    fn maybe_insert_id(&mut self, id: ast::NodeId) {\n+        if self.prev_public { self.public_items.insert(id); }\n+        if self.prev_exported { self.exported_items.insert(id); }\n+    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let orig_all_pub = self.prev_public;\n-        self.prev_public = orig_all_pub && item.vis == hir::Public;\n-        if self.prev_public {\n-            self.public_items.insert(item.id);\n-        }\n-\n+        let orig_all_public = self.prev_public;\n         let orig_all_exported = self.prev_exported;\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway\n+            // cannot have visibility qualifiers on them anyway. They are also not\n+            // added to public/exported sets based on inherited publicity.\n             hir::ItemImpl(..) | hir::ItemDefaultImpl(..) | hir::ItemForeignMod(..) => {}\n \n             // Traits are a little special in that even if they themselves are\n             // not public they may still be exported.\n             hir::ItemTrait(..) => {\n+                self.prev_public = self.prev_public && item.vis == hir::Public;\n                 self.prev_exported = self.exported_trait(item.id);\n+\n+                self.maybe_insert_id(item.id);\n             }\n \n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n             _ => {\n-                self.prev_exported =\n-                    (orig_all_exported && item.vis == hir::Public) ||\n-                     self.reexports.contains(&item.id);\n+                self.prev_public = self.prev_public && item.vis == hir::Public;\n+                self.prev_exported = self.prev_exported && item.vis == hir::Public ||\n+                                     self.reexports.contains(&item.id);\n+\n+                self.maybe_insert_id(item.id);\n             }\n         }\n \n-        let public_first = self.prev_exported &&\n-                           self.exported_items.insert(item.id);\n-\n         match item.node {\n             // Enum variants inherit from their parent, so if the enum is\n-            // public all variants are public unless they're explicitly priv\n-            hir::ItemEnum(ref def, _) if public_first => {\n+            // public all variants are public\n+            hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n-                    self.exported_items.insert(variant.node.data.id());\n-                    self.public_items.insert(variant.node.data.id());\n+                    self.maybe_insert_id(variant.node.data.id());\n+                    for field in variant.node.data.fields() {\n+                        // Variant fields are always public\n+                        if self.prev_public { self.public_items.insert(field.node.id); }\n+                        // FIXME: Make fields exported (requires fixing resulting ICEs)\n+                        // if self.prev_exported { self.exported_items.insert(field.node.id); }\n+                    }\n+                }\n+            }\n+\n+            // * Inherent impls for public types only have public methods exported\n+            // * Inherent impls for private types do not need to export their methods\n+            // * Inherent impls themselves are not exported, they are nothing more than\n+            // containers for other items\n+            hir::ItemImpl(_, _, _, None, ref ty, ref impl_items) => {\n+                let (public_ty, exported_ty) = self.is_public_exported_ty(&ty);\n+\n+                for impl_item in impl_items {\n+                    if impl_item.vis == hir::Public {\n+                        if public_ty { self.public_items.insert(impl_item.id); }\n+                        if exported_ty { self.exported_items.insert(impl_item.id); }\n+                    }\n                 }\n             }\n \n             // Implementations are a little tricky to determine what's exported\n             // out of them. Here's a few cases which are currently defined:\n             //\n-            // * Impls for private types do not need to export their methods\n-            //   (either public or private methods)\n-            //\n-            // * Impls for public types only have public methods exported\n-            //\n             // * Public trait impls for public types must have all methods\n             //   exported.\n             //\n@@ -257,83 +305,51 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             //   undefined symbols at linkage time if this case is not handled.\n             //\n             // * Private trait impls for private types can be completely ignored\n-            hir::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n-                let public_ty = match ty.node {\n-                    hir::TyPath(..) => {\n-                        match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                            def::DefPrimTy(..) => true,\n-                            def::DefSelfTy(..) => true,\n-                            def => {\n-                                let did = def.def_id();\n-                                if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-                                    self.exported_items.contains(&node_id)\n-                                } else {\n-                                    true\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => true,\n-                };\n-                let tr = self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id));\n-                let public_trait = tr.clone().map_or(false, |tr| {\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(tr.def_id) {\n-                        self.exported_items.contains(&node_id)\n-                    } else {\n-                        true\n-                    }\n-                });\n+            hir::ItemImpl(_, _, _, Some(ref trait_ref), ref ty, ref impl_items) => {\n+                let (public_ty, _exported_ty) = self.is_public_exported_ty(&ty);\n+                let (public_trait, exported_trait) = self.is_public_exported_trait(trait_ref);\n \n-                if public_ty || public_trait {\n-                    for impl_item in impl_items {\n-                        match impl_item.node {\n-                            hir::ConstImplItem(..) => {\n-                                if (public_ty && impl_item.vis == hir::Public)\n-                                    || tr.is_some() {\n-                                    self.exported_items.insert(impl_item.id);\n-                                }\n-                            }\n-                            hir::MethodImplItem(ref sig, _) => {\n-                                let meth_public = match sig.explicit_self.node {\n-                                    hir::SelfStatic => public_ty,\n-                                    _ => true,\n-                                } && impl_item.vis == hir::Public;\n-                                if meth_public || tr.is_some() {\n-                                    self.exported_items.insert(impl_item.id);\n-                                }\n-                            }\n-                            hir::TypeImplItem(_) => {}\n-                        }\n-                    }\n+                if public_ty && public_trait { self.public_items.insert(item.id); }\n+                if exported_trait { self.exported_items.insert(item.id); }\n+\n+                for impl_item in impl_items {\n+                    if public_ty && public_trait { self.public_items.insert(impl_item.id); }\n+                    if exported_trait { self.exported_items.insert(impl_item.id); }\n                 }\n             }\n \n+            // Default trait impls are exported for public traits\n+            hir::ItemDefaultImpl(_, ref trait_ref) => {\n+                let (public_trait, exported_trait) = self.is_public_exported_trait(trait_ref);\n+\n+                if public_trait { self.public_items.insert(item.id); }\n+                if exported_trait { self.exported_items.insert(item.id); }\n+            }\n+\n             // Default methods on traits are all public so long as the trait\n             // is public\n-            hir::ItemTrait(_, _, _, ref trait_items) if public_first => {\n+            hir::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n-                    debug!(\"trait item {}\", trait_item.id);\n-                    self.exported_items.insert(trait_item.id);\n+                    self.maybe_insert_id(trait_item.id);\n                 }\n             }\n \n             // Struct constructors are public if the struct is all public.\n-            hir::ItemStruct(ref def, _) if public_first => {\n+            hir::ItemStruct(ref def, _) => {\n                 if !def.is_struct() {\n-                    self.exported_items.insert(def.id());\n+                    self.maybe_insert_id(def.id());\n                 }\n-                // fields can be public or private, so lets check\n                 for field in def.fields() {\n-                    let vis = match field.node.kind {\n-                        hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n-                    };\n-                    if vis == hir::Public {\n-                        self.public_items.insert(field.node.id);\n+                    // Struct fields can be public or private, so lets check\n+                    if field.node.kind.visibility() == hir::Public {\n+                        if self.prev_public { self.public_items.insert(field.node.id); }\n+                        // FIXME: Make fields exported (requires fixing resulting ICEs)\n+                        // if self.prev_exported { self.exported_items.insert(field.node.id); }\n                     }\n                 }\n             }\n \n-            hir::ItemTy(ref ty, _) if public_first => {\n+            hir::ItemTy(ref ty, _) if self.prev_exported => {\n                 if let hir::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {},\n@@ -347,19 +363,37 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    let public = self.prev_public && foreign_item.vis == hir::Public;\n+                    let exported = self.prev_exported && foreign_item.vis == hir::Public ||\n+                                   self.reexports.contains(&foreign_item.id);\n+\n+                    if public { self.public_items.insert(foreign_item.id); }\n+                    if exported { self.exported_items.insert(foreign_item.id); }\n+                }\n+            }\n+\n             _ => {}\n         }\n \n         visit::walk_item(self, item);\n \n+        self.prev_public = orig_all_public;\n         self.prev_exported = orig_all_exported;\n-        self.prev_public = orig_all_pub;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n-        if (self.prev_exported && a.vis == hir::Public) || self.reexports.contains(&a.id) {\n-            self.exported_items.insert(a.id);\n-        }\n+    fn visit_block(&mut self, b: &'v hir::Block) {\n+        let orig_all_public = replace(&mut self.prev_public, false);\n+        let orig_all_exported = replace(&mut self.prev_exported, false);\n+\n+        // Blocks can have exported and public items, for example impls, but they always\n+        // start as non-public and non-exported regardless of publicity of a function,\n+        // constant, type, field, etc. in which this block resides\n+        visit::walk_block(self, b);\n+\n+        self.prev_public = orig_all_public;\n+        self.prev_exported = orig_all_exported;\n     }\n \n     fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n@@ -375,6 +409,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         }\n         visit::walk_mod(self, m)\n     }\n+\n+    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+        self.public_items.insert(md.id);\n+        // FIXME: Make exported macros exported (requires fixing resulting ICEs)\n+        // self.exported_items.insert(md.id);\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -1447,11 +1487,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-\n     // we don't need to introspect into these at all: an\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n+    // FIXME: Unfortunately this ^^^ is not true, blocks can contain\n+    // exported items (e.g. impls) and actual code in rustc itself breaks\n+    // if we don't traverse blocks in `EmbargoVisitor`\n     fn visit_block(&mut self, _: &hir::Block) {}\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n@@ -1501,9 +1543,12 @@ pub fn check_crate(tcx: &ty::ctxt,\n         prev_public: true,\n     };\n     loop {\n-        let before = visitor.exported_items.len();\n+        let before = (visitor.exported_items.len(), visitor.public_items.len(),\n+                      visitor.reexports.len());\n         visit::walk_crate(&mut visitor, krate);\n-        if before == visitor.exported_items.len() {\n+        let after = (visitor.exported_items.len(), visitor.public_items.len(),\n+                     visitor.reexports.len());\n+        if after == before {\n             break\n         }\n     }"}, {"sha": "76c4088609bc2afe5c394bfb11f360ca2962409d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/599df16551ea12605ca50e182237e7c50a29af40/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599df16551ea12605ca50e182237e7c50a29af40/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=599df16551ea12605ca50e182237e7c50a29af40", "patch": "@@ -1737,6 +1737,12 @@ impl StructFieldKind {\n             NamedField(..) => false,\n         }\n     }\n+\n+    pub fn visibility(&self) -> Visibility {\n+        match *self {\n+            NamedField(_, vis) | UnnamedField(vis) => vis\n+        }\n+    }\n }\n \n /// Fields and Ids of enum variants and structs"}]}