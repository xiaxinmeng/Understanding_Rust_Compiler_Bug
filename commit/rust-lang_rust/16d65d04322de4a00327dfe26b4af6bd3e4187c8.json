{"sha": "16d65d04322de4a00327dfe26b4af6bd3e4187c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZDY1ZDA0MzIyZGU0YTAwMzI3ZGZlMjZiNGFmNmJkM2U0MTg3Yzg=", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2020-10-06T09:39:59Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2020-10-11T09:53:30Z"}, "message": "revise Hermit's mutex interface to support the behaviour of StaticMutex\n\nrust-lang/rust#77147 simplifies things by splitting this Mutex type\ninto two types matching the two use cases: StaticMutex and MovableMutex.\nTo support the behavior of StaticMutex, we move part of the mutex\nimplementation into libstd.", "tree": {"sha": "6fee95eb6bef2e40dfb00e9633eaae50c69da384", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fee95eb6bef2e40dfb00e9633eaae50c69da384"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d65d04322de4a00327dfe26b4af6bd3e4187c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJSBAABCAA8FiEEGkIfPZjnqQD6B3IuKFeOu3ie9isFAl+C1hoeHHNsYW5rZXNA\nZW9uZXJjLnJ3dGgtYWFjaGVuLmRlAAoJEChXjrt4nvYr/7UP/1pBed+4mKI/dbov\nsIusb215Jrz05JXJneqnas0X/k/D6qAvGGue8lJADfyR3agBIgUEaAWkzHdeLvBP\nxxe8zD4TEAOprgQWP1WUdqUNxcsUnERweJPkVVvKui9HP3kGEGj5YZwQo3j5lZPn\naARwoGqME6cLuGfHDPmLoEPE/0SZL7UW6HE0FIUldu7Kz8q6o2gXCjtjKPtk1/Za\nwHhDxw/VfzLoyjWzcOh5aKWXdmBzXhnT3Av6ezQQxyNtUoineS3n14JGg5KS3Gwd\nQNkz1g5tNQ2JukUNqJuZmQK0ojBAQqhF4mDvqFO9M5YdtqdAeM8UM+tRoLZZ/uei\nN3yeWQ1dqvd7B+bZEohzlwxUaX0vdfKbYWCmiF7fiMK+GCvH0xXHvY2HJJSl9EgQ\nUy6c8Ot/nGUE7mp5BPgQI0oT9ilh2UZ4OsL37NiatHNxfbEWW2amXouJOXasgF6F\n+PzV/ET7KZzDmC3kPSP0Ix+oI9aYlBNR0NJxbRqH9AuIqA371dvHDL2FW6+DmtTq\nXc+wawBgQ1BUU2wUVrroGbEszXK+tz2y6VtXXP1YZTCyDm2rLPuUFg89H/gPnPvl\nZ6vwRT1Xqp49VtsHQRXJjIOglw0/HZkl4LoPob961Z9wODGMJ496TvzpFbSGfgVo\nex9PI6qWbTE1L0RQeIR1lX59FPbv\n=K91k\n-----END PGP SIGNATURE-----", "payload": "tree 6fee95eb6bef2e40dfb00e9633eaae50c69da384\nparent c6bebc14a14de81848f24353227244860f2ecdaf\nauthor Stefan Lankes <slankes@eonerc.rwth-aachen.de> 1601977199 +0200\ncommitter Stefan Lankes <slankes@eonerc.rwth-aachen.de> 1602410010 +0200\n\nrevise Hermit's mutex interface to support the behaviour of StaticMutex\n\nrust-lang/rust#77147 simplifies things by splitting this Mutex type\ninto two types matching the two use cases: StaticMutex and MovableMutex.\nTo support the behavior of StaticMutex, we move part of the mutex\nimplementation into libstd.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d65d04322de4a00327dfe26b4af6bd3e4187c8", "html_url": "https://github.com/rust-lang/rust/commit/16d65d04322de4a00327dfe26b4af6bd3e4187c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d65d04322de4a00327dfe26b4af6bd3e4187c8/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6bebc14a14de81848f24353227244860f2ecdaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bebc14a14de81848f24353227244860f2ecdaf", "html_url": "https://github.com/rust-lang/rust/commit/c6bebc14a14de81848f24353227244860f2ecdaf"}], "stats": {"total": 190, "additions": 182, "deletions": 8}, "files": [{"sha": "511a5100ac62575fa1fc17a009404fe7a1325231", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 182, "deletions": 8, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/16d65d04322de4a00327dfe26b4af6bd3e4187c8/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d65d04322de4a00327dfe26b4af6bd3e4187c8/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=16d65d04322de4a00327dfe26b4af6bd3e4187c8", "patch": "@@ -1,43 +1,217 @@\n+use crate::cell::UnsafeCell;\n+use crate::collections::VecDeque;\n use crate::ffi::c_void;\n+use crate::ops::{Deref, DerefMut, Drop};\n use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint};\n use crate::sys::hermit::abi;\n \n+/// This type provides a lock based on busy waiting to realize mutual exclusion\n+///\n+/// # Description\n+///\n+/// This structure behaves a lot like a common mutex. There are some differences:\n+///\n+/// - By using busy waiting, it can be used outside the runtime.\n+/// - It is a so called ticket lock (https://en.wikipedia.org/wiki/Ticket_lock)\n+///   and completly fair.\n+#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n+#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\n+struct Spinlock<T: ?Sized> {\n+    queue: AtomicUsize,\n+    dequeue: AtomicUsize,\n+    data: UnsafeCell<T>,\n+}\n+\n+unsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\n+unsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n+\n+/// A guard to which the protected data can be accessed\n+///\n+/// When the guard falls out of scope it will release the lock.\n+struct SpinlockGuard<'a, T: ?Sized + 'a> {\n+    dequeue: &'a AtomicUsize,\n+    data: &'a mut T,\n+}\n+\n+impl<T> Spinlock<T> {\n+    pub const fn new(user_data: T) -> Spinlock<T> {\n+        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n+    }\n+\n+    #[inline]\n+    fn obtain_lock(&self) {\n+        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n+        while self.dequeue.load(Ordering::SeqCst) != ticket {\n+            spin_loop_hint();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n+        self.obtain_lock();\n+        SpinlockGuard {\n+            dequeue: &self.dequeue,\n+            data: &mut *self.data.get(),\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for Spinlock<T> {\n+    fn default() -> Spinlock<T> {\n+        Spinlock::new(Default::default())\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        &*self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut *self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n+    /// The dropping of the SpinlockGuard will release the lock it was created from.\n+    fn drop(&mut self) {\n+        self.dequeue.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+/// Realize a priority queue for tasks\n+struct PriorityQueue {\n+    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n+    prio_bitmap: u64,\n+}\n+\n+impl PriorityQueue {\n+    pub const fn new() -> PriorityQueue {\n+        PriorityQueue {\n+            queues: [\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None,\n+            ],\n+            prio_bitmap: 0,\n+        }\n+    }\n+\n+    /// Add a task handle by its priority to the queue\n+    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n+        let i: usize = prio.into().into();\n+        self.prio_bitmap |= (1 << i) as u64;\n+        if let Some(queue) = &mut self.queues[i] {\n+            queue.push_back(id);\n+        } else {\n+            let mut queue = VecDeque::new();\n+            queue.push_back(id);\n+            self.queues[i] = Some(queue);\n+        }\n+    }\n+\n+    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n+        if let Some(queue) = &mut self.queues[queue_index] {\n+            let id = queue.pop_front();\n+\n+            if queue.is_empty() {\n+                self.prio_bitmap &= !(1 << queue_index as u64);\n+            }\n+\n+            id\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Pop the task handle with the highest priority from the queue\n+    pub fn pop(&mut self) -> Option<abi::Tid> {\n+        for i in 0..abi::NO_PRIORITIES {\n+            if self.prio_bitmap & (1 << i) != 0 {\n+                return self.pop_from_queue(i);\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+struct MutexInner {\n+    locked: bool,\n+    blocked_task: PriorityQueue,\n+}\n+\n+impl MutexInner {\n+    pub const fn new() -> MutexInner {\n+        MutexInner {\n+            locked: false,\n+            blocked_task: PriorityQueue::new(),\n+        }\n+    }\n+}\n+\n pub struct Mutex {\n-    inner: *const c_void,\n+    inner: Spinlock<MutexInner>,\n }\n \n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: ptr::null() }\n+        Mutex {\n+            inner: Spinlock::new(MutexInner::new()),\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn init(&mut self) {\n-        let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+        self.inner = Spinlock::new(MutexInner::new());\n     }\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let _ = abi::sem_timedwait(self.inner, 0);\n+        loop {\n+            let mut guard = self.inner.lock();\n+            if guard.locked == false {\n+                guard.locked = true;\n+                return;\n+            } else {\n+                let prio = abi::get_priority();\n+                let id = abi::getpid();\n+\n+                guard.blocked_task.push(prio, id);\n+                abi::block_current_task();\n+                drop(guard);\n+                abi::yield_now();\n+            }\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let _ = abi::sem_post(self.inner);\n+        let mut guard = self.inner.lock();\n+        guard.locked = false;\n+        if let Some(tid) = guard.blocked_task.pop() {\n+            abi::wakeup_task(tid);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        let result = abi::sem_trywait(self.inner);\n-        result == 0\n+        let mut guard = self.inner.lock();\n+        if guard.locked == false {\n+            guard.locked = true;\n+        }\n+        guard.locked\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        let _ = abi::sem_destroy(self.inner);\n     }\n }\n "}]}