{"sha": "74190853373c7963d933e2fb5c2ac2f761fdbc02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MTkwODUzMzczYzc5NjNkOTMzZTJmYjVjMmFjMmY3NjFmZGJjMDI=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-09-02T01:45:37Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-09-03T12:45:06Z"}, "message": "Modernized a few more types in syntax::ast", "tree": {"sha": "12ffa50679235aab28c7bf26799504d7ac8b8ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12ffa50679235aab28c7bf26799504d7ac8b8ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74190853373c7963d933e2fb5c2ac2f761fdbc02", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74190853373c7963d933e2fb5c2ac2f761fdbc02", "html_url": "https://github.com/rust-lang/rust/commit/74190853373c7963d933e2fb5c2ac2f761fdbc02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74190853373c7963d933e2fb5c2ac2f761fdbc02/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58decdd7a115f2892d63fa3760fa2125eb784ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/58decdd7a115f2892d63fa3760fa2125eb784ac8", "html_url": "https://github.com/rust-lang/rust/commit/58decdd7a115f2892d63fa3760fa2125eb784ac8"}], "stats": {"total": 7611, "additions": 3808, "deletions": 3803}, "files": [{"sha": "2a5c3ae0f4f0519f99c462dfe82f6865f9a5086d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -116,12 +116,12 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n     fold::noop_fold_item_underscore(&item, fld)\n }\n \n-fn filter_stmt(cx: @Context, stmt: @ast::stmt) ->\n-   Option<@ast::stmt> {\n+fn filter_stmt(cx: @Context, stmt: @ast::Stmt) ->\n+   Option<@ast::Stmt> {\n     match stmt.node {\n-      ast::stmt_decl(decl, _) => {\n+      ast::StmtDecl(decl, _) => {\n         match decl.node {\n-          ast::decl_item(item) => {\n+          ast::DeclItem(item) => {\n             if item_in_cfg(cx, item) {\n                 option::Some(stmt)\n             } else { option::None }"}, {"sha": "63491c3d413951ca982f361f43563054a4c9860a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -441,29 +441,29 @@ fn is_extra(cx: &TestCtxt) -> bool {\n     }\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n+fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for test in cx.testfns.iter() {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n \n     let sess = cx.sess;\n-    let inner_expr = @ast::expr {\n+    let inner_expr = @ast::Expr {\n         id: sess.next_node_id(),\n-        node: ast::expr_vec(descs, ast::m_imm),\n+        node: ast::ExprVec(descs, ast::MutImmutable),\n         span: dummy_sp(),\n     };\n \n-    @ast::expr {\n+    @ast::Expr {\n         id: sess.next_node_id(),\n-        node: ast::expr_vstore(inner_expr, ast::expr_vstore_slice),\n+        node: ast::ExprVstore(inner_expr, ast::ExprVstoreSlice),\n         span: dummy_sp(),\n     }\n }\n \n #[cfg(stage0)]\n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n@@ -474,17 +474,17 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n \n-    let name_expr = @ast::expr {\n+    let name_expr = @ast::Expr {\n           id: cx.sess.next_node_id(),\n-          node: ast::expr_lit(@name_lit),\n+          node: ast::ExprLit(@name_lit),\n           span: span\n     };\n \n     let fn_path = path_node_global(path);\n \n-    let fn_expr = @ast::expr {\n+    let fn_expr = @ast::Expr {\n         id: cx.sess.next_node_id(),\n-        node: ast::expr_path(fn_path),\n+        node: ast::ExprPath(fn_path),\n         span: span,\n     };\n \n@@ -519,7 +519,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     e\n }\n #[cfg(not(stage0))]\n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n@@ -528,17 +528,17 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n \n-    let name_expr = @ast::expr {\n+    let name_expr = @ast::Expr {\n           id: cx.sess.next_node_id(),\n-          node: ast::expr_lit(@name_lit),\n+          node: ast::ExprLit(@name_lit),\n           span: span\n     };\n \n     let fn_path = path_node_global(path);\n \n-    let fn_expr = @ast::expr {\n+    let fn_expr = @ast::Expr {\n         id: cx.sess.next_node_id(),\n-        node: ast::expr_path(fn_path),\n+        node: ast::ExprPath(fn_path),\n         span: span,\n     };\n "}, {"sha": "bc7cba46c6b1dfeba3a17eed838437f80ac56b2b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -26,16 +26,16 @@ use syntax::diagnostic::expect;\n \n pub struct StaticMethodInfo {\n     ident: ast::Ident,\n-    def_id: ast::def_id,\n+    def_id: ast::DefId,\n     purity: ast::purity\n }\n \n-pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::def_id) -> ~str {\n+pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::DefId) -> ~str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::def_id)\n+pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::DefId)\n                          -> uint {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_type_param_count(cdata, def.node);\n@@ -51,7 +51,7 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n \n /// Iterates over each child of the given item.\n pub fn each_child_of_item(cstore: @mut cstore::CStore,\n-                          def_id: ast::def_id,\n+                          def_id: ast::DefId,\n                           callback: &fn(decoder::DefLike, ast::Ident)) {\n     let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n@@ -79,7 +79,7 @@ pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n+pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ast_map::path {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     let path = decoder::get_item_path(cdata, def.node);\n@@ -92,14 +92,14 @@ pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n \n pub enum found_ast {\n     found(ast::inlined_item),\n-    found_parent(ast::def_id, ast::inlined_item),\n+    found_parent(ast::DefId, ast::inlined_item),\n     not_found,\n }\n \n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n+pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n                           decode_inlined_item: decoder::decode_inlined_item)\n                        -> found_ast {\n     let cstore = tcx.cstore;\n@@ -108,102 +108,102 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n                                 decode_inlined_item)\n }\n \n-pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n+pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n                       -> ~[@ty::VariantInfo] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::def_id)\n+pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n     let cdata = cstore::get_crate_data(tcx.cstore, impl_def_id.crate);\n     decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n-pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {\n+pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n     let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n \n pub fn get_method_name_and_explicit_self(cstore: @mut cstore::CStore,\n-                                         def: ast::def_id)\n+                                         def: ast::DefId)\n                                      -> (ast::Ident, ast::explicit_self_)\n {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n-                                def: ast::def_id) -> ~[ast::def_id] {\n+                                def: ast::DefId) -> ~[ast::DefId] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n-                                  def: ast::def_id)\n+                                  def: ast::DefId)\n                                -> ~[@ty::Method] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[@ty::TraitRef] {\n+pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::def_id)\n+pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n-                                  def: ast::def_id)\n+                                  def: ast::DefId)\n                                -> Option<~[StaticMethodInfo]> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n-                      def_id: ast::def_id,\n+                      def_id: ast::DefId,\n                       f: &fn(~[@ast::MetaItem])) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: @mut cstore::CStore,\n-                         def: ast::def_id)\n+                         def: ast::DefId)\n                       -> ~[ty::field_ty] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n pub fn get_type(tcx: ty::ctxt,\n-                def: ast::def_id)\n+                def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-pub fn get_trait_def(tcx: ty::ctxt, def: ast::def_id) -> ty::TraitDef {\n+pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n pub fn get_region_param(cstore: @mut metadata::cstore::CStore,\n-                        def: ast::def_id) -> Option<ty::region_variance> {\n+                        def: ast::DefId) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_region_param(cdata, def.node);\n }\n \n-pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n-                      def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n+                      def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n@@ -229,30 +229,30 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait(tcx: ty::ctxt,\n-                      def: ast::def_id) -> Option<@ty::TraitRef> {\n+                      def: ast::DefId) -> Option<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: ty::ctxt,\n-                        def: ast::def_id) -> typeck::impl_res {\n+                        def: ast::DefId) -> typeck::impl_res {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n pub fn get_impl_method(cstore: @mut cstore::CStore,\n-                       def: ast::def_id,\n+                       def: ast::DefId,\n                        mname: ast::Ident)\n-                    -> Option<ast::def_id> {\n+                    -> Option<ast::DefId> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n pub fn get_item_visibility(cstore: @mut cstore::CStore,\n-                           def_id: ast::def_id)\n+                           def_id: ast::DefId)\n                         -> ast::visibility {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_visibility(cdata, def_id.node)\n@@ -267,21 +267,21 @@ pub fn get_link_args_for_crate(cstore: @mut cstore::CStore,\n \n pub fn each_impl(cstore: @mut cstore::CStore,\n                  crate_num: ast::CrateNum,\n-                 callback: &fn(ast::def_id)) {\n+                 callback: &fn(ast::DefId)) {\n     let cdata = cstore::get_crate_data(cstore, crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n-                                    def_id: ast::def_id,\n-                                    callback: &fn(ast::def_id)) {\n+                                    def_id: ast::DefId,\n+                                    callback: &fn(ast::DefId)) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n-                                     def_id: ast::def_id,\n-                                     callback: &fn(ast::def_id)) {\n+                                     def_id: ast::DefId,\n+                                     callback: &fn(ast::DefId)) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n }\n@@ -290,9 +290,9 @@ pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n /// default method or an implementation of a trait method), returns the ID of\n /// the trait that the method belongs to. Otherwise, returns `None`.\n pub fn get_trait_of_method(cstore: @mut cstore::CStore,\n-                           def_id: ast::def_id,\n+                           def_id: ast::DefId,\n                            tcx: ty::ctxt)\n-                           -> Option<ast::def_id> {\n+                           -> Option<ast::DefId> {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)\n }"}, {"sha": "c15327f4e2115d101870f7e02c3dab46d8e8e197", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -177,7 +177,7 @@ fn item_symbol(item: ebml::Doc) -> ~str {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str()\n }\n \n-fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n+fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n     do reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n         ret = Some(reader::with_doc_data(did, parse_def_id));\n@@ -187,17 +187,17 @@ fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n }\n \n fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n-                                        d: ebml::Doc) -> ast::def_id {\n+                                        d: ebml::Doc) -> ast::DefId {\n     let trait_did = item_parent_item(d).expect(\"item without parent\");\n-    ast::def_id { crate: cnum, node: trait_did.node }\n+    ast::DefId { crate: cnum, node: trait_did.node }\n }\n \n-fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::def_id {\n+fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n     let tagdoc = reader::get_doc(d, tag_def_id);\n     return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n }\n \n-fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::def_id> {\n+fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     do reader::maybe_get_doc(d, tag_item_method_provided_source).map_move |doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n     }\n@@ -235,7 +235,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n     }\n }\n \n-pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n+pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n@@ -278,12 +278,12 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n     n\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::def_id] {\n-    let mut ids: ~[ast::def_id] = ~[];\n+fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n+    let mut ids: ~[ast::DefId] = ~[];\n     let v = tag_items_data_item_variant;\n     do reader::tagged_docs(item, v) |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n-        ids.push(ast::def_id { crate: cdata.cnum, node: ext.node });\n+        ids.push(ast::DefId { crate: cdata.cnum, node: ext.node });\n         true\n     };\n     return ids;\n@@ -321,16 +321,16 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::Ident {\n     }\n }\n \n-fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n+fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        ImmStatic => DlDef(ast::def_static(did, false)),\n-        MutStatic => DlDef(ast::def_static(did, true)),\n-        Struct    => DlDef(ast::def_struct(did)),\n-        UnsafeFn  => DlDef(ast::def_fn(did, ast::unsafe_fn)),\n-        Fn        => DlDef(ast::def_fn(did, ast::impure_fn)),\n-        ForeignFn => DlDef(ast::def_fn(did, ast::extern_fn)),\n+        ImmStatic => DlDef(ast::DefStatic(did, false)),\n+        MutStatic => DlDef(ast::DefStatic(did, true)),\n+        Struct    => DlDef(ast::DefStruct(did)),\n+        UnsafeFn  => DlDef(ast::DefFn(did, ast::unsafe_fn)),\n+        Fn        => DlDef(ast::DefFn(did, ast::impure_fn)),\n+        ForeignFn => DlDef(ast::DefFn(did, ast::extern_fn)),\n         StaticMethod | UnsafeStaticMethod => {\n             let purity = if fam == UnsafeStaticMethod { ast::unsafe_fn } else\n                 { ast::impure_fn };\n@@ -347,26 +347,26 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n                 ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            DlDef(ast::def_static_method(did, provenance, purity))\n+            DlDef(ast::DefStaticMethod(did, provenance, purity))\n         }\n-        Type | ForeignType => DlDef(ast::def_ty(did)),\n-        Mod => DlDef(ast::def_mod(did)),\n-        ForeignMod => DlDef(ast::def_foreign_mod(did)),\n+        Type | ForeignType => DlDef(ast::DefTy(did)),\n+        Mod => DlDef(ast::DefMod(did)),\n+        ForeignMod => DlDef(ast::DefForeignMod(did)),\n         Variant => {\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n-            DlDef(ast::def_variant(enum_did, did))\n+            DlDef(ast::DefVariant(enum_did, did))\n         }\n-        Trait => DlDef(ast::def_trait(did)),\n-        Enum => DlDef(ast::def_ty(did)),\n+        Trait => DlDef(ast::DefTrait(did)),\n+        Enum => DlDef(ast::DefTy(did)),\n         Impl => DlImpl(did),\n         PublicField | PrivateField | InheritedField => DlField,\n     }\n }\n \n-pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::def_id) ->\n-   ast::def {\n+pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::DefId) ->\n+   ast::Def {\n     let item = lookup_item(did_.node, data);\n-    let did = ast::def_id { crate: cnum, node: did_.node };\n+    let did = ast::DefId { crate: cnum, node: did_.node };\n     // We treat references to enums as references to types.\n     return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n@@ -402,7 +402,7 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n-    let t = item_type(ast::def_id { crate: cdata.cnum, node: id }, item, tcx,\n+    let t = item_type(ast::DefId { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n     let tp_defs = if family_has_type_params(item_family(item)) {\n         item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n@@ -452,7 +452,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n \n \n pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n-                       name: ast::Ident) -> Option<ast::def_id> {\n+                       name: ast::Ident) -> Option<ast::DefId> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n@@ -471,12 +471,12 @@ pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n \n // Something that a name can resolve to.\n pub enum DefLike {\n-    DlDef(ast::def),\n-    DlImpl(ast::def_id),\n+    DlDef(ast::Def),\n+    DlImpl(ast::DefId),\n     DlField\n }\n \n-fn def_like_to_def(def_like: DefLike) -> ast::def {\n+fn def_like_to_def(def_like: DefLike) -> ast::Def {\n     match def_like {\n         DlDef(def) => return def,\n         DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n@@ -528,7 +528,7 @@ impl<'self> EachItemContext<'self> {\n \n     fn process_item_and_pop_name(&mut self,\n                                  doc: ebml::Doc,\n-                                 def_id: ast::def_id,\n+                                 def_id: ast::DefId,\n                                  old_len: uint)\n                                  -> bool {\n         let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n@@ -578,7 +578,7 @@ impl<'self> EachItemContext<'self> {\n         continue\n     }\n \n-    fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n+    fn each_item_of_module(&mut self, def_id: ast::DefId) -> bool {\n         // This item might not be in this crate. If it's not, look it up.\n         let items = if def_id.crate == self.cdata.cnum {\n             reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n@@ -910,7 +910,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n     let mut disr_val = 0;\n     for did in variant_ids.iter() {\n         let item = find_item(did.node, items);\n-        let ctor_ty = item_type(ast::def_id { crate: cdata.cnum, node: id},\n+        let ctor_ty = item_type(ast::DefId { crate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n@@ -937,10 +937,10 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n }\n \n fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n-    fn get_mutability(ch: u8) -> ast::mutability {\n+    fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n-            'i' => ast::m_imm,\n-            'm' => ast::m_mutbl,\n+            'i' => ast::MutImmutable,\n+            'm' => ast::MutMutable,\n             _ => fail!(\"unknown mutability character: `%c`\", ch as char),\n         }\n     }\n@@ -983,7 +983,7 @@ pub fn get_impl(intr: @ident_interner, cdata: Cmd, impl_id: ast::NodeId,\n     let data = cdata.data;\n     let impl_item = lookup_item(impl_id, data);\n     ty::Impl {\n-        did: ast::def_id {\n+        did: ast::DefId {\n             crate: cdata.cnum,\n             node: impl_id,\n         },\n@@ -1043,7 +1043,7 @@ pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n }\n \n pub fn get_trait_method_def_ids(cdata: Cmd,\n-                                id: ast::NodeId) -> ~[ast::def_id] {\n+                                id: ast::NodeId) -> ~[ast::DefId] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n@@ -1236,7 +1236,7 @@ fn read_path(d: ebml::Doc) -> (~str, uint) {\n     }\n }\n \n-fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n+fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n     if id.crate != ast::LOCAL_CRATE { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n@@ -1419,13 +1419,13 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-pub fn translate_def_id(cdata: Cmd, did: ast::def_id) -> ast::def_id {\n+pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     if did.crate == ast::LOCAL_CRATE {\n-        return ast::def_id { crate: cdata.cnum, node: did.node };\n+        return ast::DefId { crate: cdata.cnum, node: did.node };\n     }\n \n     match cdata.cnum_map.find(&did.crate) {\n-      option::Some(&n) => ast::def_id { crate: n, node: did.node },\n+      option::Some(&n) => ast::DefId { crate: n, node: did.node },\n       option::None => fail!(\"didn't find a crate in the cnum_map\")\n     }\n }\n@@ -1440,7 +1440,7 @@ pub fn get_link_args_for_crate(cdata: Cmd) -> ~[~str] {\n     result\n }\n \n-pub fn each_impl(cdata: Cmd, callback: &fn(ast::def_id)) {\n+pub fn each_impl(cdata: Cmd, callback: &fn(ast::DefId)) {\n     let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n     let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n@@ -1450,7 +1450,7 @@ pub fn each_impl(cdata: Cmd, callback: &fn(ast::def_id)) {\n \n pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n-                                    callback: &fn(ast::def_id)) {\n+                                    callback: &fn(ast::DefId)) {\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n             |impl_doc| {\n@@ -1462,7 +1462,7 @@ pub fn each_implementation_for_type(cdata: Cmd,\n \n pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n-                                     callback: &fn(ast::def_id)) {\n+                                     callback: &fn(ast::DefId)) {\n     let item_doc = lookup_item(id, cdata.data);\n \n     let _ = do reader::tagged_docs(item_doc,\n@@ -1475,7 +1475,7 @@ pub fn each_implementation_for_trait(cdata: Cmd,\n }\n \n pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n-                           -> Option<ast::def_id> {\n+                           -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data);\n     let parent_item_id = match item_parent_item(item_doc) {\n         None => return None,"}, {"sha": "1b469676773c0b09cd9d0f3aef7cfbef38a247dc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -113,7 +113,7 @@ fn encode_impl_type_basename(ecx: &EncodeContext,\n                          ecx.tcx.sess.str_of(name));\n }\n \n-pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n+pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: DefId) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n@@ -180,7 +180,7 @@ fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n     ebml_w.end_tag();\n }\n \n-pub fn def_to_str(did: def_id) -> ~str {\n+pub fn def_to_str(did: DefId) -> ~str {\n     fmt!(\"%d:%d\", did.crate, did.node)\n }\n \n@@ -209,7 +209,7 @@ fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n-fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n+fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: DefId) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_str(vid);\n     ebml_w.writer.write(s.as_bytes());\n@@ -300,7 +300,7 @@ fn encode_disr_val(_: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n+fn encode_parent_item(ebml_w: &mut writer::Encoder, id: DefId) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     let s = def_to_str(id);\n     ebml_w.writer.write(s.as_bytes());\n@@ -319,7 +319,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n-                               ast::def_id { crate: LOCAL_CRATE, node: id });\n+                               ast::DefId { crate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {val: variant.node.id as i64,\n@@ -378,7 +378,7 @@ fn encode_path(ecx: &EncodeContext,\n fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n-                                   method_def_id: def_id,\n+                                   method_def_id: DefId,\n                                    method_ident: Ident) {\n     debug!(\"(encode reexported static method) %s::%s\",\n             exp.name, ecx.tcx.sess.str_of(method_ident));\n@@ -638,10 +638,10 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n     ebml_w.end_tag();\n \n     fn encode_mutability(ebml_w: &writer::Encoder,\n-                         m: ast::mutability) {\n+                         m: ast::Mutability) {\n         match m {\n-            m_imm => ebml_w.writer.write(&[ 'i' as u8 ]),\n-            m_mutbl => ebml_w.writer.write(&[ 'm' as u8 ]),\n+            MutImmutable => ebml_w.writer.write(&[ 'i' as u8 ]),\n+            MutMutable => ebml_w.writer.write(&[ 'm' as u8 ]),\n         }\n     }\n }\n@@ -653,7 +653,7 @@ fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n }\n \n fn encode_provided_source(ebml_w: &mut writer::Encoder,\n-                          source_opt: Option<def_id>) {\n+                          source_opt: Option<DefId>) {\n     for source in source_opt.iter() {\n         ebml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_str(*source);\n@@ -805,7 +805,7 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n-                                   def_id: def_id) {\n+                                   def_id: DefId) {\n     match ecx.tcx.inherent_impls.find(&def_id) {\n         None => {}\n         Some(&implementations) => {\n@@ -821,7 +821,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n // Encodes the implementations of a trait defined in this crate.\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n-                                    trait_def_id: def_id) {\n+                                    trait_def_id: DefId) {\n     match ecx.tcx.trait_impls.find(&trait_def_id) {\n         None => {}\n         Some(&implementations) => {\n@@ -856,7 +856,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n-        if m == ast::m_mutbl {\n+        if m == ast::MutMutable {\n             encode_family(ebml_w, 'b');\n         } else {\n             encode_family(ebml_w, 'c');\n@@ -1223,7 +1223,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn my_visit_expr(_e:@expr) { }\n+fn my_visit_expr(_e:@Expr) { }\n \n fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n                  ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n@@ -1272,7 +1272,7 @@ struct EncodeVisitor {\n }\n \n impl visit::Visitor<()> for EncodeVisitor {\n-    fn visit_expr(&mut self, ex:@expr, _:()) {\n+    fn visit_expr(&mut self, ex:@Expr, _:()) {\n         visit::walk_expr(self, ex, ());\n         my_visit_expr(ex);\n     }"}, {"sha": "036c66cca84630a0027480728236520332b1e177", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -51,7 +51,7 @@ pub enum DefIdSource {\n     TypeParameter\n }\n type conv_did<'self> =\n-    &'self fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n+    &'self fn(source: DefIdSource, ast::DefId) -> ast::DefId;\n \n pub struct PState<'self> {\n     data: &'self [u8],\n@@ -422,10 +422,10 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n     }\n }\n \n-fn parse_mutability(st: &mut PState) -> ast::mutability {\n+fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     match peek(st) {\n-      'm' => { next(st); ast::m_mutbl }\n-      _ => { ast::m_imm }\n+      'm' => { next(st); ast::MutMutable }\n+      _ => { ast::MutImmutable }\n     }\n }\n \n@@ -435,7 +435,7 @@ fn parse_mt(st: &mut PState, conv: conv_did) -> ty::mt {\n }\n \n fn parse_def(st: &mut PState, source: DefIdSource,\n-             conv: conv_did) -> ast::def_id {\n+             conv: conv_did) -> ast::DefId {\n     return conv(source, scan(st, |c| { c == '|' }, parse_def_id));\n }\n \n@@ -535,7 +535,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n }\n \n // Rust metadata parsing\n-pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n+pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let mut colon_idx = 0u;\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n@@ -557,7 +557,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n        None => fail!(\"internal error: parse_def_id: id expected, but found %?\",\n                      def_part)\n     };\n-    ast::def_id { crate: crate_num, node: def_num }\n+    ast::DefId { crate: crate_num, node: def_num }\n }\n \n pub fn parse_type_param_def_data(data: &[u8], start: uint,"}, {"sha": "86821200796b91ad982755963fdcb0f228fc5310", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -26,7 +26,7 @@ use syntax::print::pprust::*;\n pub struct ctxt {\n     diag: @mut span_handler,\n     // Def -> str Callback:\n-    ds: @fn(def_id) -> ~str,\n+    ds: @fn(DefId) -> ~str,\n     // The type context.\n     tcx: ty::ctxt,\n     abbrevs: abbrev_ctxt\n@@ -95,10 +95,10 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n     }\n }\n \n-fn enc_mutability(w: @io::Writer, mt: ast::mutability) {\n+fn enc_mutability(w: @io::Writer, mt: ast::Mutability) {\n     match mt {\n-      m_imm => (),\n-      m_mutbl => w.write_char('m'),\n+      MutImmutable => (),\n+      MutMutable => w.write_char('m'),\n     }\n }\n "}, {"sha": "f6645b1c1d1e6ed0580a049eb9beaef6304986dc", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -72,7 +72,7 @@ trait tr {\n }\n \n trait tr_intern {\n-    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n+    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::DefId;\n }\n \n // ______________________________________________________________________\n@@ -179,7 +179,7 @@ impl ExtendedDecodeContext {\n         assert!(!self.from_id_range.empty());\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n-    pub fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n+    pub fn tr_def_id(&self, did: ast::DefId) -> ast::DefId {\n         /*!\n          * Translates an EXTERNAL def-id, converting the crate number\n          * from the one used in the encoded data to the current crate\n@@ -203,7 +203,7 @@ impl ExtendedDecodeContext {\n \n         decoder::translate_def_id(self.dcx.cdata, did)\n     }\n-    pub fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n+    pub fn tr_intern_def_id(&self, did: ast::DefId) -> ast::DefId {\n         /*!\n          * Translates an INTERNAL def-id, meaning a def-id that is\n          * known to refer to some part of the item currently being\n@@ -212,21 +212,21 @@ impl ExtendedDecodeContext {\n          */\n \n         assert_eq!(did.crate, ast::LOCAL_CRATE);\n-        ast::def_id { crate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n+        ast::DefId { crate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n     pub fn tr_span(&self, _span: Span) -> Span {\n         codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }\n \n-impl tr_intern for ast::def_id {\n-    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+impl tr_intern for ast::DefId {\n+    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::DefId {\n         xcx.tr_intern_def_id(*self)\n     }\n }\n \n-impl tr for ast::def_id {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+impl tr for ast::DefId {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::DefId {\n         xcx.tr_def_id(*self)\n     }\n }\n@@ -238,30 +238,30 @@ impl tr for Span {\n }\n \n trait def_id_encoder_helpers {\n-    fn emit_def_id(&mut self, did: ast::def_id);\n+    fn emit_def_id(&mut self, did: ast::DefId);\n }\n \n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n-    fn emit_def_id(&mut self, did: ast::def_id) {\n+    fn emit_def_id(&mut self, did: ast::DefId) {\n         did.encode(self)\n     }\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n+    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::DefId;\n     fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::def_id;\n+                         cdata: @cstore::crate_metadata) -> ast::DefId;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n-        let did: ast::def_id = Decodable::decode(self);\n+    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::DefId {\n+        let did: ast::DefId = Decodable::decode(self);\n         did.tr(xcx)\n     }\n \n     fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::def_id {\n-        let did: ast::def_id = Decodable::decode(self);\n+                         cdata: @cstore::crate_metadata) -> ast::DefId {\n+        let did: ast::DefId = Decodable::decode(self);\n         decoder::translate_def_id(cdata, did)\n     }\n }\n@@ -301,12 +301,12 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: &ast::Block, fld: @fold::ast_fold) -> ast::Block {\n         let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n-              ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@codemap::Spanned { node: ast::decl_local(_), span: _}, _)\n+              ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n+              ast::StmtDecl(@codemap::Spanned { node: ast::DeclLocal(_), span: _}, _)\n                 => Some(*stmt),\n-              ast::stmt_decl(@codemap::Spanned { node: ast::decl_item(_), span: _}, _)\n+              ast::StmtDecl(@codemap::Spanned { node: ast::DeclItem(_), span: _}, _)\n                 => None,\n-              ast::stmt_mac(*) => fail!(\"unexpanded macro in astencode\")\n+              ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n         }.collect();\n         let blk_sans_items = ast::Block {\n@@ -360,22 +360,22 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: &mut writer::Encoder, def: ast::def) {\n+fn encode_def(ebml_w: &mut writer::Encoder, def: ast::Def) {\n     def.encode(ebml_w)\n }\n \n-fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n+fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n     let mut dsr = reader::Decoder(doc);\n-    let def: ast::def = Decodable::decode(&mut dsr);\n+    let def: ast::Def = Decodable::decode(&mut dsr);\n     def.tr(xcx)\n }\n \n-impl tr for ast::def {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n+impl tr for ast::Def {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::Def {\n         match *self {\n-          ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n-          ast::def_static_method(did, wrapped_did2, p) => {\n-            ast::def_static_method(did.tr(xcx),\n+          ast::DefFn(did, p) => ast::DefFn(did.tr(xcx), p),\n+          ast::DefStaticMethod(did, wrapped_did2, p) => {\n+            ast::DefStaticMethod(did.tr(xcx),\n                                    match wrapped_did2 {\n                                     ast::FromTrait(did2) => {\n                                         ast::FromTrait(did2.tr(xcx))\n@@ -386,37 +386,37 @@ impl tr for ast::def {\n                                    },\n                                    p)\n           }\n-          ast::def_method(did0, did1) => {\n-            ast::def_method(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+          ast::DefMethod(did0, did1) => {\n+            ast::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n           }\n-          ast::def_self_ty(nid) => { ast::def_self_ty(xcx.tr_id(nid)) }\n-          ast::def_self(nid) => { ast::def_self(xcx.tr_id(nid)) }\n-          ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n-          ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n-          ast::def_static(did, m) => { ast::def_static(did.tr(xcx), m) }\n-          ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n-          ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n-          ast::def_variant(e_did, v_did) => {\n-            ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n+          ast::DefSelfTy(nid) => { ast::DefSelfTy(xcx.tr_id(nid)) }\n+          ast::DefSelf(nid) => { ast::DefSelf(xcx.tr_id(nid)) }\n+          ast::DefMod(did) => { ast::DefMod(did.tr(xcx)) }\n+          ast::DefForeignMod(did) => { ast::DefForeignMod(did.tr(xcx)) }\n+          ast::DefStatic(did, m) => { ast::DefStatic(did.tr(xcx), m) }\n+          ast::DefArg(nid, b) => { ast::DefArg(xcx.tr_id(nid), b) }\n+          ast::DefLocal(nid, b) => { ast::DefLocal(xcx.tr_id(nid), b) }\n+          ast::DefVariant(e_did, v_did) => {\n+            ast::DefVariant(e_did.tr(xcx), v_did.tr(xcx))\n           },\n-          ast::def_trait(did) => ast::def_trait(did.tr(xcx)),\n-          ast::def_ty(did) => ast::def_ty(did.tr(xcx)),\n-          ast::def_prim_ty(p) => ast::def_prim_ty(p),\n-          ast::def_ty_param(did, v) => ast::def_ty_param(did.tr(xcx), v),\n-          ast::def_binding(nid, bm) => ast::def_binding(xcx.tr_id(nid), bm),\n-          ast::def_use(did) => ast::def_use(did.tr(xcx)),\n-          ast::def_upvar(nid1, def, nid2, nid3) => {\n-            ast::def_upvar(xcx.tr_id(nid1),\n+          ast::DefTrait(did) => ast::DefTrait(did.tr(xcx)),\n+          ast::DefTy(did) => ast::DefTy(did.tr(xcx)),\n+          ast::DefPrimTy(p) => ast::DefPrimTy(p),\n+          ast::DefTyParam(did, v) => ast::DefTyParam(did.tr(xcx), v),\n+          ast::DefBinding(nid, bm) => ast::DefBinding(xcx.tr_id(nid), bm),\n+          ast::DefUse(did) => ast::DefUse(did.tr(xcx)),\n+          ast::DefUpvar(nid1, def, nid2, nid3) => {\n+            ast::DefUpvar(xcx.tr_id(nid1),\n                            @(*def).tr(xcx),\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::def_struct(did) => ast::def_struct(did.tr(xcx)),\n-          ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n-          ast::def_typaram_binder(nid) => {\n-            ast::def_typaram_binder(xcx.tr_id(nid))\n+          ast::DefStruct(did) => ast::DefStruct(did.tr(xcx)),\n+          ast::DefRegion(nid) => ast::DefRegion(xcx.tr_id(nid)),\n+          ast::DefTyParamBinder(nid) => {\n+            ast::DefTyParamBinder(xcx.tr_id(nid))\n           }\n-          ast::def_label(nid) => ast::def_label(xcx.tr_id(nid))\n+          ast::DefLabel(nid) => ast::DefLabel(xcx.tr_id(nid))\n         }\n     }\n }\n@@ -914,7 +914,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = ast::def_id { crate: ast::LOCAL_CRATE, node: id };\n+    let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n     {\n         let r = tcx.tcache.find(&lid);\n         for &tpbt in r.iter() {\n@@ -1012,8 +1012,8 @@ trait ebml_decoder_decoder_helpers {\n     fn convert_def_id(&mut self,\n                       xcx: @ExtendedDecodeContext,\n                       source: DefIdSource,\n-                      did: ast::def_id)\n-                      -> ast::def_id;\n+                      did: ast::DefId)\n+                      -> ast::DefId;\n \n     // Versions of the type reading functions that don't need the full\n     // ExtendedDecodeContext.\n@@ -1122,8 +1122,8 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     fn convert_def_id(&mut self,\n                       xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n-                      did: ast::def_id)\n-                      -> ast::def_id {\n+                      did: ast::DefId)\n+                      -> ast::DefId {\n         /*!\n          *\n          * Converts a def-id that appears in a type.  The correct\n@@ -1192,7 +1192,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_tcache => {\n                         let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                        let lid = ast::def_id { crate: ast::LOCAL_CRATE, node: id };\n+                        let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n                         dcx.tcx.tcache.insert(lid, tpbt);\n                     }\n                     c::tag_table_param_defs => {"}, {"sha": "8cfb2bad57f3bc203c3c734fa06f101f614edac7", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -23,7 +23,7 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n-use syntax::ast::{m_imm, m_mutbl};\n+use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -43,7 +43,7 @@ struct CheckLoanCtxt<'self> {\n struct CheckLoanVisitor;\n \n impl<'self> Visitor<CheckLoanCtxt<'self>> for CheckLoanVisitor {\n-    fn visit_expr<'a>(&mut self, ex:@ast::expr, e:CheckLoanCtxt<'a>) {\n+    fn visit_expr<'a>(&mut self, ex:@ast::Expr, e:CheckLoanCtxt<'a>) {\n         check_loans_in_expr(self, ex, e);\n     }\n     fn visit_local(&mut self, l:@ast::Local, e:CheckLoanCtxt) {\n@@ -52,7 +52,7 @@ impl<'self> Visitor<CheckLoanCtxt<'self>> for CheckLoanVisitor {\n     fn visit_block(&mut self, b:&ast::Block, e:CheckLoanCtxt) {\n         check_loans_in_block(self, b, e);\n     }\n-    fn visit_pat(&mut self, p:@ast::pat, e:CheckLoanCtxt) {\n+    fn visit_pat(&mut self, p:@ast::Pat, e:CheckLoanCtxt) {\n         check_loans_in_pat(self, p, e);\n     }\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n@@ -332,7 +332,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         };\n     }\n \n-    pub fn check_assignment(&self, expr: @ast::expr) {\n+    pub fn check_assignment(&self, expr: @ast::Expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n         let cmt = match self.bccx.tcx.adjustments.find(&expr.id) {\n@@ -432,21 +432,21 @@ impl<'self> CheckLoanCtxt<'self> {\n         }\n \n         fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n-                                              expr: @ast::expr,\n+                                              expr: @ast::Expr,\n                                               cmt: mc::cmt) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n             debug!(\"check_for_aliasable_mutable_writes(cmt=%s, guarantor=%s)\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) => {\n+                mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n                     check_for_aliasability_violation(this, expr, b);\n                 }\n \n-                mc::cat_deref(_, deref_count, mc::gc_ptr(ast::m_mutbl)) => {\n+                mc::cat_deref(_, deref_count, mc::gc_ptr(ast::MutMutable)) => {\n                     // Dynamically check writes to `@mut`\n \n                     let key = root_map_key {\n@@ -464,13 +464,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         }\n \n         fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n-                                            expr: @ast::expr,\n+                                            expr: @ast::Expr,\n                                             cmt: mc::cmt) -> bool {\n             let mut cmt = cmt;\n \n             loop {\n                 match cmt.cat {\n-                    mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) |\n+                    mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) |\n                     mc::cat_downcast(b) |\n                     mc::cat_stack_upvar(b) |\n                     mc::cat_deref(b, _, mc::uniq_ptr) |\n@@ -488,7 +488,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                     mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n                     mc::cat_static_item(*) |\n                     mc::cat_deref(_, _, mc::gc_ptr(_)) |\n-                    mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) => {\n+                    mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) => {\n                         // Aliasability is independent of base cmt\n                         match cmt.freely_aliasable() {\n                             None => {\n@@ -509,7 +509,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         fn check_for_assignment_to_restricted_or_frozen_location(\n             this: &CheckLoanCtxt,\n-            expr: @ast::expr,\n+            expr: @ast::Expr,\n             cmt: mc::cmt) -> bool\n         {\n             //! Check for assignments that violate the terms of an\n@@ -612,7 +612,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                     // with inherited mutability and with `&mut`\n                     // pointers.\n                     LpExtend(lp_base, mc::McInherited, _) |\n-                    LpExtend(lp_base, _, LpDeref(mc::region_ptr(ast::m_mutbl, _))) => {\n+                    LpExtend(lp_base, _, LpDeref(mc::region_ptr(ast::MutMutable, _))) => {\n                         loan_path = lp_base;\n                     }\n \n@@ -643,7 +643,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     pub fn report_illegal_mutation(&self,\n-                                   expr: @ast::expr,\n+                                   expr: @ast::Expr,\n                                    loan_path: &LoanPath,\n                                    loan: &Loan) {\n         self.bccx.span_err(\n@@ -656,9 +656,9 @@ impl<'self> CheckLoanCtxt<'self> {\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n-    fn check_move_out_from_expr(&self, expr: @ast::expr) {\n+    fn check_move_out_from_expr(&self, expr: @ast::Expr) {\n         match expr.node {\n-            ast::expr_fn_block(*) => {\n+            ast::ExprFnBlock(*) => {\n                 // moves due to capture clauses are checked\n                 // in `check_loans_in_fn`, so that we can\n                 // give a better error message\n@@ -710,11 +710,11 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     pub fn check_call(&self,\n-                      _expr: @ast::expr,\n-                      _callee: Option<@ast::expr>,\n+                      _expr: @ast::Expr,\n+                      _callee: Option<@ast::Expr>,\n                       _callee_id: ast::NodeId,\n                       _callee_span: Span,\n-                      _args: &[@ast::expr]) {\n+                      _args: &[@ast::Expr]) {\n         // NB: This call to check for conflicting loans is not truly\n         // necessary, because the callee_id never issues new loans.\n         // However, I added it for consistency and lest the system\n@@ -795,7 +795,7 @@ fn check_loans_in_local<'a>(vt: &mut CheckLoanVisitor,\n }\n \n fn check_loans_in_expr<'a>(vt: &mut CheckLoanVisitor,\n-                           expr: @ast::expr,\n+                           expr: @ast::Expr,\n                            this: CheckLoanCtxt<'a>) {\n     visit::walk_expr(vt, expr, this);\n \n@@ -806,8 +806,8 @@ fn check_loans_in_expr<'a>(vt: &mut CheckLoanVisitor,\n     this.check_move_out_from_expr(expr);\n \n     match expr.node {\n-      ast::expr_self |\n-      ast::expr_path(*) => {\n+      ast::ExprSelf |\n+      ast::ExprPath(*) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n@@ -817,26 +817,26 @@ fn check_loans_in_expr<'a>(vt: &mut CheckLoanVisitor,\n               }\n           }\n       }\n-      ast::expr_assign(dest, _) |\n-      ast::expr_assign_op(_, _, dest, _) => {\n+      ast::ExprAssign(dest, _) |\n+      ast::ExprAssignOp(_, _, dest, _) => {\n         this.check_assignment(dest);\n       }\n-      ast::expr_call(f, ref args, _) => {\n+      ast::ExprCall(f, ref args, _) => {\n         this.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n-      ast::expr_method_call(callee_id, _, _, _, ref args, _) => {\n+      ast::ExprMethodCall(callee_id, _, _, _, ref args, _) => {\n         this.check_call(expr, None, callee_id, expr.span, *args);\n       }\n-      ast::expr_index(callee_id, _, rval) |\n-      ast::expr_binary(callee_id, _, _, rval)\n+      ast::ExprIndex(callee_id, _, rval) |\n+      ast::ExprBinary(callee_id, _, _, rval)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n                         callee_id,\n                         expr.span,\n                         [rval]);\n       }\n-      ast::expr_unary(callee_id, _, _) | ast::expr_index(callee_id, _, _)\n+      ast::ExprUnary(callee_id, _, _) | ast::ExprIndex(callee_id, _, _)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n@@ -849,7 +849,7 @@ fn check_loans_in_expr<'a>(vt: &mut CheckLoanVisitor,\n }\n \n fn check_loans_in_pat<'a>(vt: &mut CheckLoanVisitor,\n-                          pat: @ast::pat,\n+                          pat: @ast::Pat,\n                           this: CheckLoanCtxt<'a>)\n {\n     this.check_for_conflicting_loans(pat.id);"}, {"sha": "4b12fa202d4ad1a09fe6456fdad2657515630732", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -33,15 +33,15 @@ pub fn gather_decl(bccx: @BorrowckCtxt,\n \n pub fn gather_move_from_expr(bccx: @BorrowckCtxt,\n                              move_data: &mut MoveData,\n-                             move_expr: @ast::expr,\n+                             move_expr: @ast::Expr,\n                              cmt: mc::cmt) {\n     gather_move_from_expr_or_pat(bccx, move_data, move_expr.id,\n                                  MoveExpr(move_expr), cmt);\n }\n \n pub fn gather_move_from_pat(bccx: @BorrowckCtxt,\n                             move_data: &mut MoveData,\n-                            move_pat: @ast::pat,\n+                            move_pat: @ast::Pat,\n                             cmt: mc::cmt) {\n     gather_move_from_expr_or_pat(bccx, move_data, move_pat.id,\n                                  MovePat(move_pat), cmt);\n@@ -68,7 +68,7 @@ fn gather_move_from_expr_or_pat(bccx: @BorrowckCtxt,\n \n pub fn gather_captures(bccx: @BorrowckCtxt,\n                        move_data: &mut MoveData,\n-                       closure_expr: @ast::expr) {\n+                       closure_expr: @ast::Expr) {\n     let captured_vars = bccx.capture_map.get(&closure_expr.id);\n     for captured_var in captured_vars.iter() {\n         match captured_var.mode {"}, {"sha": "1b94ac06c8eb1e2b0ee8706f98a4ff6ec5300e5e", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -15,7 +15,7 @@\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{m_imm, m_mutbl};\n+use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{note_and_explain_region};\n@@ -90,7 +90,7 @@ impl GuaranteeLifetimeContext {\n \n                 // L-Deref-Managed-Imm-User-Root\n                 let omit_root = (\n-                    ptr_mutbl == m_imm &&\n+                    ptr_mutbl == MutImmutable &&\n                     self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n                     self.is_rvalue_or_immutable(base) &&\n                     !self.is_moved(base)\n@@ -187,7 +187,7 @@ impl GuaranteeLifetimeContext {\n                   cmt_deref: mc::cmt,\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n-                  ptr_mutbl: ast::mutability,\n+                  ptr_mutbl: ast::Mutability,\n                   discr_scope: Option<ast::NodeId>) {\n         debug!(\"check_root(cmt_deref=%s, cmt_base=%s, derefs=%?, ptr_mutbl=%?, \\\n                 discr_scope=%?)\",\n@@ -235,8 +235,8 @@ impl GuaranteeLifetimeContext {\n         // we need to dynamically mark it to prevent incompatible\n         // borrows from happening later.\n         let opt_dyna = match ptr_mutbl {\n-            m_imm => None,\n-            m_mutbl => {\n+            MutImmutable => None,\n+            MutMutable => {\n                 match self.loan_mutbl {\n                     MutableMutability => Some(DynaMut),\n                     ImmutableMutability | ConstMutability => Some(DynaImm)"}, {"sha": "be033de4e41b572bf385d20523e83c3554ef37b5", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -32,7 +32,7 @@ use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ast::{expr, fn_kind, fn_decl, Block, NodeId, stmt, pat, Local};\n+use syntax::ast::{Expr, fn_kind, fn_decl, Block, NodeId, Stmt, Pat, Local};\n \n mod lifetime;\n mod restrictions;\n@@ -76,7 +76,7 @@ struct GatherLoanCtxt {\n struct GatherLoanVisitor;\n \n impl visit::Visitor<@mut GatherLoanCtxt> for GatherLoanVisitor {\n-    fn visit_expr(&mut self, ex:@expr, e:@mut GatherLoanCtxt) {\n+    fn visit_expr(&mut self, ex:@Expr, e:@mut GatherLoanCtxt) {\n         gather_loans_in_expr(self, ex, e);\n     }\n     fn visit_block(&mut self, b:&Block, e:@mut GatherLoanCtxt) {\n@@ -86,10 +86,10 @@ impl visit::Visitor<@mut GatherLoanCtxt> for GatherLoanVisitor {\n                 s:Span, n:NodeId, e:@mut GatherLoanCtxt) {\n         gather_loans_in_fn(self, fk, fd, b, s, n, e);\n     }\n-    fn visit_stmt(&mut self, s:@stmt, e:@mut GatherLoanCtxt) {\n+    fn visit_stmt(&mut self, s:@Stmt, e:@mut GatherLoanCtxt) {\n         add_stmt_to_map(self, s, e);\n     }\n-    fn visit_pat(&mut self, p:@pat, e:@mut GatherLoanCtxt) {\n+    fn visit_pat(&mut self, p:@Pat, e:@mut GatherLoanCtxt) {\n         add_pat_to_id_range(self, p, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:@mut GatherLoanCtxt) {\n@@ -117,7 +117,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n }\n \n fn add_pat_to_id_range(v: &mut GatherLoanVisitor,\n-                       p: @ast::pat,\n+                       p: @ast::Pat,\n                        this: @mut GatherLoanCtxt) {\n     // NB: This visitor function just adds the pat ids into the id\n     // range. We gather loans that occur in patterns using the\n@@ -196,7 +196,7 @@ fn gather_loans_in_local(v: &mut GatherLoanVisitor,\n \n \n fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n-                        ex: @ast::expr,\n+                        ex: @ast::Expr,\n                         this: @mut GatherLoanCtxt) {\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n@@ -230,7 +230,7 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n \n     // Special checks for various kinds of expressions:\n     match ex.node {\n-      ast::expr_addr_of(mutbl, base) => {\n+      ast::ExprAddrOf(mutbl, base) => {\n         let base_cmt = this.bccx.cat_expr(base);\n \n         // make sure that the thing we are pointing out stays valid\n@@ -244,7 +244,7 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n         visit::walk_expr(v, ex, this);\n       }\n \n-      ast::expr_assign(l, _) | ast::expr_assign_op(_, _, l, _) => {\n+      ast::ExprAssign(l, _) | ast::ExprAssignOp(_, _, l, _) => {\n           let l_cmt = this.bccx.cat_expr(l);\n           match opt_loan_path(l_cmt) {\n               Some(l_lp) => {\n@@ -261,7 +261,7 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n           visit::walk_expr(v, ex, this);\n       }\n \n-      ast::expr_match(ex_v, ref arms) => {\n+      ast::ExprMatch(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arm in arms.iter() {\n             for pat in arm.pats.iter() {\n@@ -271,8 +271,8 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n         visit::walk_expr(v, ex, this);\n       }\n \n-      ast::expr_index(_, _, arg) |\n-      ast::expr_binary(_, _, _, arg)\n+      ast::ExprIndex(_, _, arg) |\n+      ast::ExprBinary(_, _, _, arg)\n       if this.bccx.method_map.contains_key(&ex.id) => {\n           // Arguments in method calls are always passed by ref.\n           //\n@@ -290,7 +290,7 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::expr_while(cond, ref body) => {\n+      ast::ExprWhile(cond, ref body) => {\n           // during the condition, can only root for the condition\n           this.push_repeating_id(cond.id);\n           v.visit_expr(cond, this);\n@@ -303,13 +303,13 @@ fn gather_loans_in_expr(v: &mut GatherLoanVisitor,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::expr_loop(ref body, _) => {\n+      ast::ExprLoop(ref body, _) => {\n           this.push_repeating_id(body.id);\n           visit::walk_expr(v, ex, this);\n           this.pop_repeating_id(body.id);\n       }\n \n-      ast::expr_fn_block(*) => {\n+      ast::ExprFnBlock(*) => {\n           gather_moves::gather_captures(this.bccx, this.move_data, ex);\n           visit::walk_expr(v, ex, this);\n       }\n@@ -333,7 +333,7 @@ impl GatherLoanCtxt {\n     }\n \n     pub fn guarantee_adjustments(&mut self,\n-                                 expr: @ast::expr,\n+                                 expr: @ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n                expr.repr(self.tcx()), adjustment);\n@@ -668,7 +668,7 @@ impl GatherLoanCtxt {\n \n     fn gather_pat(&mut self,\n                   discr_cmt: mc::cmt,\n-                  root_pat: @ast::pat,\n+                  root_pat: @ast::Pat,\n                   arm_match_ids: Option<(ast::NodeId, ast::NodeId)>) {\n         /*!\n          * Walks patterns, examining the bindings to determine if they\n@@ -678,9 +678,9 @@ impl GatherLoanCtxt {\n \n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n-              ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n+              ast::PatIdent(bm, _, _) if self.pat_is_binding(pat) => {\n                 match bm {\n-                  ast::bind_by_ref(mutbl) => {\n+                  ast::BindByRef(mutbl) => {\n                     // ref x or ref x @ p --- creates a ptr which must\n                     // remain valid for the scope of the match\n \n@@ -715,7 +715,7 @@ impl GatherLoanCtxt {\n                                          loan_mutability,\n                                          scope_r);\n                   }\n-                  ast::bind_infer => {\n+                  ast::BindInfer => {\n                       // No borrows here, but there may be moves\n                       if self.bccx.is_move(pat.id) {\n                           gather_moves::gather_move_from_pat(\n@@ -725,7 +725,7 @@ impl GatherLoanCtxt {\n                 }\n               }\n \n-              ast::pat_vec(_, Some(slice_pat), _) => {\n+              ast::PatVec(_, Some(slice_pat), _) => {\n                   // The `slice_pat` here creates a slice into the\n                   // original vector.  This is effectively a borrow of\n                   // the elements of the vector being matched.\n@@ -768,8 +768,8 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn vec_slice_info(&self, pat: @ast::pat, slice_ty: ty::t)\n-                          -> (ast::mutability, ty::Region) {\n+    pub fn vec_slice_info(&self, pat: @ast::Pat, slice_ty: ty::t)\n+                          -> (ast::Mutability, ty::Region) {\n         /*!\n          *\n          * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -795,22 +795,22 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+    pub fn pat_is_variant_or_struct(&self, pat: @ast::Pat) -> bool {\n         pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n     }\n \n-    pub fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n+    pub fn pat_is_binding(&self, pat: @ast::Pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }\n }\n \n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(v: &mut GatherLoanVisitor,\n-                   stmt: @ast::stmt,\n+                   stmt: @ast::Stmt,\n                    this: @mut GatherLoanCtxt) {\n     match stmt.node {\n-        ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n+        ast::StmtExpr(_, id) | ast::StmtSemi(_, id) => {\n             this.bccx.stmt_map.insert(id);\n         }\n         _ => ()"}, {"sha": "16ee45b2c68e84ec49fdf2da6571815294d2cc25", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -15,7 +15,7 @@ use std::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{m_imm, m_mutbl};\n+use syntax::ast::{MutImmutable, MutMutable};\n use syntax::codemap::Span;\n \n pub enum RestrictionResult {\n@@ -115,13 +115,13 @@ impl RestrictionsContext {\n \n             mc::cat_copied_upvar(*) | // FIXME(#2152) allow mutation of upvars\n             mc::cat_static_item(*) |\n-            mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) |\n-            mc::cat_deref(_, _, mc::gc_ptr(m_imm)) => {\n+            mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) |\n+            mc::cat_deref(_, _, mc::gc_ptr(MutImmutable)) => {\n                 // R-Deref-Imm-Borrowed\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(m_mutbl)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(MutMutable)) => {\n                 // R-Deref-Managed-Borrowed\n                 //\n                 // Technically, no restrictions are *necessary* here.\n@@ -169,7 +169,7 @@ impl RestrictionsContext {\n                 }\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(m_mutbl, _)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, _)) => {\n                 // Because an `&mut` pointer does not inherit its\n                 // mutability, we can only prevent mutation or prevent\n                 // freezing if it is not aliased. Therefore, in such"}, {"sha": "986b3956410bccfa65bf6733712d1c14691e136f", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -249,11 +249,11 @@ pub enum LoanMutability {\n }\n \n impl LoanMutability {\n-    pub fn from_ast_mutability(ast_mutability: ast::mutability)\n+    pub fn from_ast_mutability(ast_mutability: ast::Mutability)\n                                -> LoanMutability {\n         match ast_mutability {\n-            ast::m_imm => ImmutableMutability,\n-            ast::m_mutbl => MutableMutability,\n+            ast::MutImmutable => ImmutableMutability,\n+            ast::MutMutable => MutableMutability,\n         }\n     }\n }\n@@ -487,16 +487,16 @@ impl BorrowckCtxt {\n         self.moves_map.contains(&id)\n     }\n \n-    pub fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n+    pub fn cat_expr(&self, expr: @ast::Expr) -> mc::cmt {\n         mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> mc::cmt {\n         mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n     pub fn cat_expr_autoderefd(&self,\n-                               expr: @ast::expr,\n+                               expr: @ast::Expr,\n                                adj: @ty::AutoAdjustment)\n                                -> mc::cmt {\n         match *adj {\n@@ -518,7 +518,7 @@ impl BorrowckCtxt {\n                    id: ast::NodeId,\n                    span: Span,\n                    ty: ty::t,\n-                   def: ast::def)\n+                   def: ast::Def)\n                    -> mc::cmt {\n         mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n@@ -536,8 +536,8 @@ impl BorrowckCtxt {\n \n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n-                       pat: @ast::pat,\n-                       op: &fn(mc::cmt, @ast::pat)) {\n+                       pat: @ast::Pat,\n+                       op: &fn(mc::cmt, @ast::Pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n@@ -691,7 +691,7 @@ impl BorrowckCtxt {\n                     span,\n                     fmt!(\"%s in an aliasable location\", prefix));\n             }\n-            mc::AliasableManaged(ast::m_mutbl) => {\n+            mc::AliasableManaged(ast::MutMutable) => {\n                 // FIXME(#6269) reborrow @mut to &mut\n                 self.tcx.sess.span_err(\n                     span,\n@@ -825,10 +825,10 @@ impl BorrowckCtxt {\n         mutbl.to_str()\n     }\n \n-    pub fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n+    pub fn mut_to_keyword(&self, mutbl: ast::Mutability) -> &'static str {\n         match mutbl {\n-            ast::m_imm => \"\",\n-            ast::m_mutbl => \"mut\",\n+            ast::MutImmutable => \"\",\n+            ast::MutMutable => \"mut\",\n         }\n     }\n }"}, {"sha": "d7423fddd76a0c4ad65e00150ae1d71e85eada3c", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -108,9 +108,9 @@ pub struct MovePath {\n \n pub enum MoveKind {\n     Declared,               // When declared, variables start out \"moved\".\n-    MoveExpr(@ast::expr),   // Expression or binding that moves a variable\n-    MovePat(@ast::pat),     // By-move binding\n-    Captured(@ast::expr),   // Closure creation that moves a value\n+    MoveExpr(@ast::Expr),   // Expression or binding that moves a variable\n+    MovePat(@ast::Pat),     // By-move binding\n+    Captured(@ast::Expr),   // Closure creation that moves a value\n }\n \n pub struct Move {"}, {"sha": "c6341abe3a6bdb2b320479901c2d8675d7c7a1df", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -62,67 +62,67 @@ impl CFGBuilder {\n         self.add_node(blk.id, [expr_exit])\n     }\n \n-    fn stmt(&mut self, stmt: @ast::stmt, pred: CFGIndex) -> CFGIndex {\n+    fn stmt(&mut self, stmt: @ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n-            ast::stmt_decl(decl, _) => {\n+            ast::StmtDecl(decl, _) => {\n                 self.decl(decl, pred)\n             }\n \n-            ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+            ast::StmtExpr(expr, _) | ast::StmtSemi(expr, _) => {\n                 self.expr(expr, pred)\n             }\n \n-            ast::stmt_mac(*) => {\n+            ast::StmtMac(*) => {\n                 self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n     }\n \n-    fn decl(&mut self, decl: @ast::decl, pred: CFGIndex) -> CFGIndex {\n+    fn decl(&mut self, decl: @ast::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n-            ast::decl_local(local) => {\n+            ast::DeclLocal(local) => {\n                 let init_exit = self.opt_expr(local.init, pred);\n                 self.pat(local.pat, init_exit)\n             }\n \n-            ast::decl_item(_) => {\n+            ast::DeclItem(_) => {\n                 pred\n             }\n         }\n     }\n \n-    fn pat(&mut self, pat: @ast::pat, pred: CFGIndex) -> CFGIndex {\n+    fn pat(&mut self, pat: @ast::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            ast::pat_ident(_, _, None) |\n-            ast::pat_enum(_, None) |\n-            ast::pat_lit(*) |\n-            ast::pat_range(*) |\n-            ast::pat_wild => {\n+            ast::PatIdent(_, _, None) |\n+            ast::PatEnum(_, None) |\n+            ast::PatLit(*) |\n+            ast::PatRange(*) |\n+            ast::PatWild => {\n                 self.add_node(pat.id, [pred])\n             }\n \n-            ast::pat_box(subpat) |\n-            ast::pat_uniq(subpat) |\n-            ast::pat_region(subpat) |\n-            ast::pat_ident(_, _, Some(subpat)) => {\n+            ast::PatBox(subpat) |\n+            ast::PatUniq(subpat) |\n+            ast::PatRegion(subpat) |\n+            ast::PatIdent(_, _, Some(subpat)) => {\n                 let subpat_exit = self.pat(subpat, pred);\n                 self.add_node(pat.id, [subpat_exit])\n             }\n \n-            ast::pat_enum(_, Some(ref subpats)) |\n-            ast::pat_tup(ref subpats) => {\n+            ast::PatEnum(_, Some(ref subpats)) |\n+            ast::PatTup(ref subpats) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|p| *p), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n-            ast::pat_struct(_, ref subpats, _) => {\n+            ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| f.pat), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n-            ast::pat_vec(ref pre, ref vec, ref post) => {\n+            ast::PatVec(ref pre, ref vec, ref post) => {\n                 let pre_exit =\n                     self.pats_all(pre.iter().map(|p| *p), pred);\n                 let vec_exit =\n@@ -134,7 +134,7 @@ impl CFGBuilder {\n         }\n     }\n \n-    fn pats_all<I: Iterator<@ast::pat>>(&mut self,\n+    fn pats_all<I: Iterator<@ast::Pat>>(&mut self,\n                                         pats: I,\n                                         pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n@@ -143,7 +143,7 @@ impl CFGBuilder {\n     }\n \n     fn pats_any(&mut self,\n-                pats: &[@ast::pat],\n+                pats: &[@ast::Pat],\n                 pred: CFGIndex) -> CFGIndex {\n         //! Handles case where just one of the patterns must match.\n \n@@ -159,14 +159,14 @@ impl CFGBuilder {\n         }\n     }\n \n-    fn expr(&mut self, expr: @ast::expr, pred: CFGIndex) -> CFGIndex {\n+    fn expr(&mut self, expr: @ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            ast::expr_block(ref blk) => {\n+            ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(blk, pred);\n                 self.add_node(expr.id, [blk_exit])\n             }\n \n-            ast::expr_if(cond, ref then, None) => {\n+            ast::ExprIf(cond, ref then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -186,7 +186,7 @@ impl CFGBuilder {\n                 self.add_node(expr.id, [cond_exit, then_exit])        // 3,4\n             }\n \n-            ast::expr_if(cond, ref then, Some(otherwise)) => {\n+            ast::ExprIf(cond, ref then, Some(otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -207,7 +207,7 @@ impl CFGBuilder {\n                 self.add_node(expr.id, [then_exit, else_exit])        // 4, 5\n             }\n \n-            ast::expr_while(cond, ref body) => {\n+            ast::ExprWhile(cond, ref body) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -239,9 +239,9 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::expr_loop(ref body, _) => {\n+            ast::ExprLoop(ref body, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -269,7 +269,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::expr_match(discr, ref arms) => {\n+            ast::ExprMatch(discr, ref arms) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -306,7 +306,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -326,125 +326,125 @@ impl CFGBuilder {\n                 self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n             }\n \n-            ast::expr_ret(v) => {\n+            ast::ExprRet(v) => {\n                 let v_exit = self.opt_expr(v, pred);\n                 let loop_scope = self.loop_scopes[0];\n                 self.add_exiting_edge(expr, v_exit,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_node(expr.id, [])\n             }\n \n-            ast::expr_break(label) => {\n+            ast::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n                 self.add_exiting_edge(expr, pred,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_node(expr.id, [])\n             }\n \n-            ast::expr_again(label) => {\n+            ast::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n                 self.add_exiting_edge(expr, pred,\n                                       loop_scope, loop_scope.continue_index);\n                 self.add_node(expr.id, [])\n             }\n \n-            ast::expr_vec(ref elems, _) => {\n+            ast::ExprVec(ref elems, _) => {\n                 self.straightline(expr, pred, *elems)\n             }\n \n-            ast::expr_call(func, ref args, _) => {\n+            ast::ExprCall(func, ref args, _) => {\n                 self.call(expr, pred, func, *args)\n             }\n \n-            ast::expr_method_call(_, rcvr, _, _, ref args, _) => {\n+            ast::ExprMethodCall(_, rcvr, _, _, ref args, _) => {\n                 self.call(expr, pred, rcvr, *args)\n             }\n \n-            ast::expr_index(_, l, r) |\n-            ast::expr_binary(_, _, l, r) if self.is_method_call(expr) => {\n+            ast::ExprIndex(_, l, r) |\n+            ast::ExprBinary(_, _, l, r) if self.is_method_call(expr) => {\n                 self.call(expr, pred, l, [r])\n             }\n \n-            ast::expr_unary(_, _, e) if self.is_method_call(expr) => {\n+            ast::ExprUnary(_, _, e) if self.is_method_call(expr) => {\n                 self.call(expr, pred, e, [])\n             }\n \n-            ast::expr_tup(ref exprs) => {\n+            ast::ExprTup(ref exprs) => {\n                 self.straightline(expr, pred, *exprs)\n             }\n \n-            ast::expr_struct(_, ref fields, base) => {\n+            ast::ExprStruct(_, ref fields, base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: ~[@ast::expr] =\n+                let field_exprs: ~[@ast::Expr] =\n                     fields.iter().map(|f| f.expr).collect();\n                 self.straightline(expr, base_exit, field_exprs)\n             }\n \n-            ast::expr_repeat(elem, count, _) => {\n+            ast::ExprRepeat(elem, count, _) => {\n                 self.straightline(expr, pred, [elem, count])\n             }\n \n-            ast::expr_assign(l, r) |\n-            ast::expr_assign_op(_, _, l, r) => {\n+            ast::ExprAssign(l, r) |\n+            ast::ExprAssignOp(_, _, l, r) => {\n                 self.straightline(expr, pred, [r, l])\n             }\n \n-            ast::expr_log(l, r) |\n-            ast::expr_index(_, l, r) |\n-            ast::expr_binary(_, _, l, r) => { // NB: && and || handled earlier\n+            ast::ExprLog(l, r) |\n+            ast::ExprIndex(_, l, r) |\n+            ast::ExprBinary(_, _, l, r) => { // NB: && and || handled earlier\n                 self.straightline(expr, pred, [l, r])\n             }\n \n-            ast::expr_addr_of(_, e) |\n-            ast::expr_do_body(e) |\n-            ast::expr_cast(e, _) |\n-            ast::expr_unary(_, _, e) |\n-            ast::expr_paren(e) |\n-            ast::expr_vstore(e, _) |\n-            ast::expr_field(e, _, _) => {\n+            ast::ExprAddrOf(_, e) |\n+            ast::ExprDoBody(e) |\n+            ast::ExprCast(e, _) |\n+            ast::ExprUnary(_, _, e) |\n+            ast::ExprParen(e) |\n+            ast::ExprVstore(e, _) |\n+            ast::ExprField(e, _, _) => {\n                 self.straightline(expr, pred, [e])\n             }\n \n-            ast::expr_mac(*) |\n-            ast::expr_inline_asm(*) |\n-            ast::expr_self |\n-            ast::expr_fn_block(*) |\n-            ast::expr_lit(*) |\n-            ast::expr_path(*) => {\n+            ast::ExprMac(*) |\n+            ast::ExprInlineAsm(*) |\n+            ast::ExprSelf |\n+            ast::ExprFnBlock(*) |\n+            ast::ExprLit(*) |\n+            ast::ExprPath(*) => {\n                 self.straightline(expr, pred, [])\n             }\n         }\n     }\n \n     fn call(&mut self,\n-            call_expr: @ast::expr,\n+            call_expr: @ast::Expr,\n             pred: CFGIndex,\n-            func_or_rcvr: @ast::expr,\n-            args: &[@ast::expr]) -> CFGIndex {\n+            func_or_rcvr: @ast::Expr,\n+            args: &[@ast::Expr]) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         self.straightline(call_expr, func_or_rcvr_exit, args)\n     }\n \n     fn exprs(&mut self,\n-             exprs: &[@ast::expr],\n+             exprs: &[@ast::Expr],\n              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n \n         exprs.iter().fold(pred, |p, &e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n-                opt_expr: Option<@ast::expr>,\n+                opt_expr: Option<@ast::Expr>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n \n         opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n     }\n \n     fn straightline(&mut self,\n-                    expr: @ast::expr,\n+                    expr: @ast::Expr,\n                     pred: CFGIndex,\n-                    subexprs: &[@ast::expr]) -> CFGIndex {\n+                    subexprs: &[@ast::Expr]) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n@@ -473,7 +473,7 @@ impl CFGBuilder {\n     }\n \n     fn add_exiting_edge(&mut self,\n-                        from_expr: @ast::expr,\n+                        from_expr: @ast::Expr,\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n@@ -487,7 +487,7 @@ impl CFGBuilder {\n     }\n \n     fn find_scope(&self,\n-                  expr: @ast::expr,\n+                  expr: @ast::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {\n         match label {\n             None => {\n@@ -496,7 +496,7 @@ impl CFGBuilder {\n \n             Some(_) => {\n                 match self.tcx.def_map.find(&expr.id) {\n-                    Some(&ast::def_label(loop_id)) => {\n+                    Some(&ast::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n                                 return *l;\n@@ -517,7 +517,7 @@ impl CFGBuilder {\n         }\n     }\n \n-    fn is_method_call(&self, expr: &ast::expr) -> bool {\n+    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         self.method_map.contains_key(&expr.id)\n     }\n }"}, {"sha": "1ef3b6b7869a5a265a49a00fc8e969e7aa050edb", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -33,10 +33,10 @@ impl Visitor<bool> for CheckCrateVisitor {\n     fn visit_item(&mut self, i:@item, env:bool) {\n         check_item(self, self.sess, self.ast_map, self.def_map, i, env);\n     }\n-    fn visit_pat(&mut self, p:@pat, env:bool) {\n+    fn visit_pat(&mut self, p:@Pat, env:bool) {\n         check_pat(self, p, env);\n     }\n-    fn visit_expr(&mut self, ex:@expr, env:bool) {\n+    fn visit_expr(&mut self, ex:@Expr, env:bool) {\n         check_expr(self, self.sess, self.def_map, self.method_map,\n                    self.tcx, ex, env);\n     }\n@@ -81,23 +81,23 @@ pub fn check_item(v: &mut CheckCrateVisitor,\n     }\n }\n \n-pub fn check_pat(v: &mut CheckCrateVisitor, p: @pat, _is_const: bool) {\n-    fn is_str(e: @expr) -> bool {\n+pub fn check_pat(v: &mut CheckCrateVisitor, p: @Pat, _is_const: bool) {\n+    fn is_str(e: @Expr) -> bool {\n         match e.node {\n-            expr_vstore(\n-                @expr { node: expr_lit(@codemap::Spanned {\n+            ExprVstore(\n+                @Expr { node: ExprLit(@codemap::Spanned {\n                     node: lit_str(_),\n                     _}),\n                        _ },\n-                expr_vstore_uniq\n+                ExprVstoreUniq\n             ) => true,\n             _ => false\n         }\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      pat_lit(a) => if !is_str(a) { v.visit_expr(a, true); },\n-      pat_range(a, b) => {\n+      PatLit(a) => if !is_str(a) { v.visit_expr(a, true); },\n+      PatRange(a, b) => {\n         if !is_str(a) { v.visit_expr(a, true); }\n         if !is_str(b) { v.visit_expr(b, true); }\n       }\n@@ -110,33 +110,33 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                   def_map: resolve::DefMap,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n-                  e: @expr,\n+                  e: @Expr,\n                   is_const: bool) {\n     if is_const {\n         match e.node {\n-          expr_unary(_, deref, _) => { }\n-          expr_unary(_, box(_), _) | expr_unary(_, uniq, _) => {\n+          ExprUnary(_, UnDeref, _) => { }\n+          ExprUnary(_, UnBox(_), _) | ExprUnary(_, UnUniq, _) => {\n             sess.span_err(e.span,\n                           \"disallowed operator in constant expression\");\n             return;\n           }\n-          expr_lit(@codemap::Spanned {node: lit_str(_), _}) => { }\n-          expr_binary(*) | expr_unary(*) => {\n+          ExprLit(@codemap::Spanned {node: lit_str(_), _}) => { }\n+          ExprBinary(*) | ExprUnary(*) => {\n             if method_map.contains_key(&e.id) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }\n           }\n-          expr_lit(_) => (),\n-          expr_cast(_, _) => {\n+          ExprLit(_) => (),\n+          ExprCast(_, _) => {\n             let ety = ty::expr_ty(tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n                 sess.span_err(e.span, ~\"can not cast to `\" +\n                               ppaux::ty_to_str(tcx, ety) +\n                               \"` in a constant expression\");\n             }\n           }\n-          expr_path(ref pth) => {\n+          ExprPath(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n@@ -147,10 +147,10 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                              items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n-              Some(&def_static(*)) |\n-              Some(&def_fn(_, _)) |\n-              Some(&def_variant(_, _)) |\n-              Some(&def_struct(_)) => { }\n+              Some(&DefStatic(*)) |\n+              Some(&DefFn(_, _)) |\n+              Some(&DefVariant(_, _)) |\n+              Some(&DefStruct(_)) => { }\n \n               Some(&def) => {\n                 debug!(\"(checking const) found bad def: %?\", def);\n@@ -164,10 +164,10 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n               }\n             }\n           }\n-          expr_call(callee, _, NoSugar) => {\n+          ExprCall(callee, _, NoSugar) => {\n             match def_map.find(&callee.id) {\n-                Some(&def_struct(*)) => {}    // OK.\n-                Some(&def_variant(*)) => {}    // OK.\n+                Some(&DefStruct(*)) => {}    // OK.\n+                Some(&DefVariant(*)) => {}    // OK.\n                 _ => {\n                     sess.span_err(\n                         e.span,\n@@ -176,17 +176,17 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                 }\n             }\n           }\n-          expr_paren(e) => { check_expr(v, sess, def_map, method_map,\n+          ExprParen(e) => { check_expr(v, sess, def_map, method_map,\n                                         tcx, e, is_const); }\n-          expr_vstore(_, expr_vstore_slice) |\n-          expr_vec(_, m_imm) |\n-          expr_addr_of(m_imm, _) |\n-          expr_field(*) |\n-          expr_index(*) |\n-          expr_tup(*) |\n-          expr_repeat(*) |\n-          expr_struct(*) => { }\n-          expr_addr_of(*) => {\n+          ExprVstore(_, ExprVstoreSlice) |\n+          ExprVec(_, MutImmutable) |\n+          ExprAddrOf(MutImmutable, _) |\n+          ExprField(*) |\n+          ExprIndex(*) |\n+          ExprTup(*) |\n+          ExprRepeat(*) |\n+          ExprStruct(*) => { }\n+          ExprAddrOf(*) => {\n                 sess.span_err(\n                     e.span,\n                     \"borrowed pointers in constants may only refer to \\\n@@ -200,15 +200,15 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n         }\n     }\n     match e.node {\n-      expr_lit(@codemap::Spanned {node: lit_int(v, t), _}) => {\n+      ExprLit(@codemap::Spanned {node: lit_int(v, t), _}) => {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, \"literal out of range for its type\");\n             }\n         }\n       }\n-      expr_lit(@codemap::Spanned {node: lit_uint(v, t), _}) => {\n+      ExprLit(@codemap::Spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n             sess.span_err(e.span, \"literal out of range for its type\");\n@@ -258,10 +258,10 @@ impl Visitor<env> for CheckItemRecursionVisitor {\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(&mut self, e: @expr, env: env) {\n+    fn visit_expr(&mut self, e: @Expr, env: env) {\n         match e.node {\n-            expr_path(*) => match env.def_map.find(&e.id) {\n-                Some(&def_static(def_id, _)) if ast_util::is_local(def_id) =>\n+            ExprPath(*) => match env.def_map.find(&e.id) {\n+                Some(&DefStatic(def_id, _)) if ast_util::is_local(def_id) =>\n                     match env.ast_map.get_copy(&def_id.node) {\n                         ast_map::node_item(it, _) => {\n                             self.visit_item(it, env);"}, {"sha": "cc3511aa51f2852513fcca4a450cf6a35268008b", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -39,30 +39,30 @@ impl Visitor<Context> for CheckLoopVisitor {\n                                   });\n     }\n \n-    fn visit_expr(&mut self, e:@expr, cx:Context) {\n+    fn visit_expr(&mut self, e:@Expr, cx:Context) {\n \n             match e.node {\n-              expr_while(e, ref b) => {\n+              ExprWhile(e, ref b) => {\n                 self.visit_expr(e, cx);\n                 self.visit_block(b, Context { in_loop: true,.. cx });\n               }\n-              expr_loop(ref b, _) => {\n+              ExprLoop(ref b, _) => {\n                 self.visit_block(b, Context { in_loop: true,.. cx });\n               }\n-              expr_fn_block(_, ref b) => {\n+              ExprFnBlock(_, ref b) => {\n                 self.visit_block(b, Context { in_loop: false, can_ret: false });\n               }\n-              expr_break(_) => {\n+              ExprBreak(_) => {\n                 if !cx.in_loop {\n                     self.tcx.sess.span_err(e.span, \"`break` outside of loop\");\n                 }\n               }\n-              expr_again(_) => {\n+              ExprAgain(_) => {\n                 if !cx.in_loop {\n                     self.tcx.sess.span_err(e.span, \"`loop` outside of loop\");\n                 }\n               }\n-              expr_ret(oe) => {\n+              ExprRet(oe) => {\n                 if !cx.can_ret {\n                     self.tcx.sess.span_err(e.span, \"`return` in block function\");\n                 }"}, {"sha": "14a4601e4155ced906f5a521f40f47c5fbb876f3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -39,7 +39,7 @@ struct CheckMatchVisitor {\n }\n \n impl Visitor<()> for CheckMatchVisitor {\n-    fn visit_expr(&mut self, ex:@expr, e:()) {\n+    fn visit_expr(&mut self, ex:@Expr, e:()) {\n         check_expr(self, self.cx, ex, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:()) {\n@@ -66,11 +66,11 @@ pub fn check_crate(tcx: ty::ctxt,\n \n pub fn check_expr(v: &mut CheckMatchVisitor,\n                   cx: @MatchCheckCtxt,\n-                  ex: @expr,\n+                  ex: @Expr,\n                   s: ()) {\n     visit::walk_expr(v, ex, s);\n     match ex.node {\n-      expr_match(scrut, ref arms) => {\n+      ExprMatch(scrut, ref arms) => {\n         // First, check legality of move bindings.\n         for arm in arms.iter() {\n             check_legality_of_move_bindings(cx,\n@@ -103,7 +103,7 @@ pub fn check_expr(v: &mut CheckMatchVisitor,\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@pat]]>().concat_vec();\n+       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@Pat]]>().concat_vec();\n        if arms.is_empty() {\n            cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n@@ -115,15 +115,15 @@ pub fn check_expr(v: &mut CheckMatchVisitor,\n }\n \n // Check for unreachable patterns\n-pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n+pub fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     let mut seen = ~[];\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n \n             // Check that we do not match against a static NaN (#6804)\n-            let pat_matches_nan: &fn(@pat) -> bool = |p| {\n+            let pat_matches_nan: &fn(@Pat) -> bool = |p| {\n                 match cx.tcx.def_map.find(&p.id) {\n-                    Some(&def_static(did, false)) => {\n+                    Some(&DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         match eval_const_expr(cx.tcx, const_expr) {\n                             const_float(f) if f.is_NaN() => true,\n@@ -153,14 +153,14 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n     }\n }\n \n-pub fn raw_pat(p: @pat) -> @pat {\n+pub fn raw_pat(p: @Pat) -> @Pat {\n     match p.node {\n-      pat_ident(_, _, Some(s)) => { raw_pat(s) }\n+      PatIdent(_, _, Some(s)) => { raw_pat(s) }\n       _ => { p }\n     }\n }\n \n-pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@pat]) {\n+pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n     assert!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n         not_useful => {\n@@ -208,14 +208,14 @@ pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@pat]) {\n     cx.tcx.sess.span_err(sp, msg);\n }\n \n-pub type matrix = ~[~[@pat]];\n+pub type matrix = ~[~[@Pat]];\n \n pub enum useful { useful(ty::t, ctor), useful_, not_useful }\n \n #[deriving(Eq)]\n pub enum ctor {\n     single,\n-    variant(def_id),\n+    variant(DefId),\n     val(const_val),\n     range(const_val, const_val),\n     vec(uint)\n@@ -234,7 +234,7 @@ pub enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n+pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match m.iter().find(|r| r[0].id != 0) {\n@@ -276,7 +276,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                 let max_len = do m.rev_iter().fold(0) |max_len, r| {\n                   match r[0].node {\n-                    pat_vec(ref before, _, ref after) => {\n+                    PatVec(ref before, _, ref after) => {\n                       num::max(before.len() + after.len(), max_len)\n                     }\n                     _ => max_len\n@@ -315,7 +315,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n \n pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              m: &matrix,\n-                             v: &[@pat],\n+                             v: &[@Pat],\n                              ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n@@ -329,34 +329,34 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n     }\n }\n \n-pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @pat) -> Option<ctor> {\n+pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-      pat_wild => { None }\n-      pat_ident(_, _, _) | pat_enum(_, _) => {\n+      PatWild => { None }\n+      PatIdent(_, _, _) | PatEnum(_, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(&def_variant(_, id)) => Some(variant(id)),\n-          Some(&def_static(did, false)) => {\n+          Some(&DefVariant(_, id)) => Some(variant(id)),\n+          Some(&DefStatic(did, false)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n           _ => None\n         }\n       }\n-      pat_lit(expr) => { Some(val(eval_const_expr(cx.tcx, expr))) }\n-      pat_range(lo, hi) => {\n+      PatLit(expr) => { Some(val(eval_const_expr(cx.tcx, expr))) }\n+      PatRange(lo, hi) => {\n         Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n-      pat_struct(*) => {\n+      PatStruct(*) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(&def_variant(_, id)) => Some(variant(id)),\n+          Some(&DefVariant(_, id)) => Some(variant(id)),\n           _ => Some(single)\n         }\n       }\n-      pat_box(_) | pat_uniq(_) | pat_tup(_) | pat_region(*) => {\n+      PatBox(_) | PatUniq(_) | PatTup(_) | PatRegion(*) => {\n         Some(single)\n       }\n-      pat_vec(ref before, slice, ref after) => {\n+      PatVec(ref before, slice, ref after) => {\n         match slice {\n           Some(_) => None,\n           None => Some(vec(before.len() + after.len()))\n@@ -365,13 +365,13 @@ pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     }\n }\n \n-pub fn is_wild(cx: &MatchCheckCtxt, p: @pat) -> bool {\n+pub fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n-      pat_wild => { true }\n-      pat_ident(_, _, _) => {\n+      PatWild => { true }\n+      PatIdent(_, _, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(&def_variant(_, _)) | Some(&def_static(*)) => { false }\n+          Some(&DefVariant(_, _)) | Some(&DefStatic(*)) => { false }\n           _ => { true }\n         }\n       }\n@@ -432,7 +432,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut wrong = false;\n         for r in m.iter() {\n           match r[0].node {\n-            pat_vec(ref before, ref slice, ref after) => {\n+            PatVec(ref before, ref slice, ref after) => {\n               let count = before.len() + after.len();\n               if (count < n && slice.is_none()) || count > n {\n                 wrong = true;\n@@ -455,7 +455,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         // Find the lengths and slices of all vector patterns.\n         let vec_pat_lens = do m.iter().filter_map |r| {\n             match r[0].node {\n-                pat_vec(ref before, ref slice, ref after) => {\n+                PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n@@ -527,34 +527,34 @@ pub fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     }\n }\n \n-pub fn wild() -> @pat {\n-    @pat {id: 0, node: pat_wild, span: dummy_sp()}\n+pub fn wild() -> @Pat {\n+    @Pat {id: 0, node: PatWild, span: dummy_sp()}\n }\n \n pub fn specialize(cx: &MatchCheckCtxt,\n-                  r: &[@pat],\n+                  r: &[@Pat],\n                   ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n-               -> Option<~[@pat]> {\n+               -> Option<~[@Pat]> {\n     // Sad, but I can't get rid of this easily\n     let r0 = (*raw_pat(r[0])).clone();\n     match r0 {\n-        pat{id: pat_id, node: n, span: pat_span} =>\n+        Pat{id: pat_id, node: n, span: pat_span} =>\n             match n {\n-            pat_wild => {\n+            PatWild => {\n                 Some(vec::append(vec::from_elem(arity, wild()), r.tail()))\n             }\n-            pat_ident(_, _, _) => {\n+            PatIdent(_, _, _) => {\n                 match cx.tcx.def_map.find(&pat_id) {\n-                    Some(&def_variant(_, id)) => {\n+                    Some(&DefVariant(_, id)) => {\n                         if variant(id) == *ctor_id {\n                             Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n                     }\n-                    Some(&def_static(did, _)) => {\n+                    Some(&DefStatic(did, _)) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -602,9 +602,9 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-            pat_enum(_, args) => {\n+            PatEnum(_, args) => {\n                 match cx.tcx.def_map.get_copy(&pat_id) {\n-                    def_static(did, _) => {\n+                    DefStatic(did, _) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -639,17 +639,17 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             None\n                         }\n                     }\n-                    def_variant(_, id) if variant(id) == *ctor_id => {\n+                    DefVariant(_, id) if variant(id) == *ctor_id => {\n                         let args = match args {\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n                         };\n                         Some(vec::append(args, r.tail()))\n                     }\n-                    def_variant(_, _) => None,\n+                    DefVariant(_, _) => None,\n \n-                    def_fn(*) |\n-                    def_struct(*) => {\n+                    DefFn(*) |\n+                    DefStruct(*) => {\n                         // FIXME #4731: Is this right? --pcw\n                         let new_args;\n                         match args {\n@@ -661,10 +661,10 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     _ => None\n                 }\n             }\n-            pat_struct(_, ref flds, _) => {\n+            PatStruct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n                 match cx.tcx.def_map.get_copy(&pat_id) {\n-                    def_variant(_, variant_id) => {\n+                    DefVariant(_, variant_id) => {\n                         if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n@@ -709,11 +709,11 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-            pat_tup(args) => Some(vec::append(args, r.tail())),\n-            pat_box(a) | pat_uniq(a) | pat_region(a) => {\n+            PatTup(args) => Some(vec::append(args, r.tail())),\n+            PatBox(a) | PatUniq(a) | PatRegion(a) => {\n                 Some(vec::append(~[a], r.tail()))\n             }\n-            pat_lit(expr) => {\n+            PatLit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n                 let match_ = match *ctor_id {\n                     val(ref v) => {\n@@ -743,7 +743,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                 };\n                 if match_ { Some(r.tail().to_owned()) } else { None }\n             }\n-            pat_range(lo, hi) => {\n+            PatRange(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => (*v, *v),\n                     range(ref lo, ref hi) => (*lo, *hi),\n@@ -767,7 +767,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-            pat_vec(before, slice, after) => {\n+            PatVec(before, slice, after) => {\n                 match *ctor_id {\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n@@ -797,7 +797,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n     }\n }\n \n-pub fn default(cx: &MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n+pub fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<~[@Pat]> {\n     if is_wild(cx, r[0]) { Some(r.tail().to_owned()) }\n     else { None }\n }\n@@ -833,58 +833,58 @@ pub fn check_fn(v: &mut CheckMatchVisitor,\n     }\n }\n \n-pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n+pub fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n     match cx.tcx.def_map.find(&pat.id) {\n-      Some(&def_variant(enum_id, _)) => {\n+      Some(&DefVariant(enum_id, _)) => {\n         if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n             return true;\n         }\n       }\n-      Some(&def_static(*)) => return true,\n+      Some(&DefStatic(*)) => return true,\n       _ => ()\n     }\n \n     match pat.node {\n-      pat_box(sub) | pat_uniq(sub) | pat_region(sub) |\n-      pat_ident(_, _, Some(sub)) => {\n+      PatBox(sub) | PatUniq(sub) | PatRegion(sub) |\n+      PatIdent(_, _, Some(sub)) => {\n         is_refutable(cx, sub)\n       }\n-      pat_wild | pat_ident(_, _, None) => { false }\n-      pat_lit(@expr {node: expr_lit(@Spanned { node: lit_nil, _}), _}) => {\n+      PatWild | PatIdent(_, _, None) => { false }\n+      PatLit(@Expr {node: ExprLit(@Spanned { node: lit_nil, _}), _}) => {\n         // \"()\"\n         false\n       }\n-      pat_lit(_) | pat_range(_, _) => { true }\n-      pat_struct(_, ref fields, _) => {\n+      PatLit(_) | PatRange(_, _) => { true }\n+      PatStruct(_, ref fields, _) => {\n         fields.iter().any(|f| is_refutable(cx, f.pat))\n       }\n-      pat_tup(ref elts) => {\n+      PatTup(ref elts) => {\n         elts.iter().any(|elt| is_refutable(cx, *elt))\n       }\n-      pat_enum(_, Some(ref args)) => {\n+      PatEnum(_, Some(ref args)) => {\n         args.iter().any(|a| is_refutable(cx, *a))\n       }\n-      pat_enum(_,_) => { false }\n-      pat_vec(*) => { true }\n+      PatEnum(_,_) => { false }\n+      PatVec(*) => { true }\n     }\n }\n \n // Legality of move bindings checking\n \n pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                        has_guard: bool,\n-                                       pats: &[@pat]) {\n+                                       pats: &[@Pat]) {\n     let tcx = cx.tcx;\n     let def_map = tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n     for pat in pats.iter() {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n-                bind_by_ref(_) => {\n+                BindByRef(_) => {\n                     by_ref_span = Some(span);\n                 }\n-                bind_infer => {\n+                BindInfer => {\n                     if cx.moves_map.contains(&id) {\n                         any_by_move = true;\n                     }\n@@ -893,7 +893,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     }\n \n-    let check_move: &fn(@pat, Option<@pat>) = |p, sub| {\n+    let check_move: &fn(@Pat, Option<@Pat>) = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(*) is legal, but x @ Foo(y) isn't.\n@@ -921,7 +921,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         do walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n-                    pat_ident(_, _, sub) => {\n+                    PatIdent(_, _, sub) => {\n                         if cx.moves_map.contains(&p.id) {\n                             check_move(p, sub);\n                         }"}, {"sha": "be09dde322b33bfdade199e430db2b17b6b33c0f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -75,7 +75,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn classify(e: &expr,\n+pub fn classify(e: &Expr,\n                 tcx: ty::ctxt)\n              -> constness {\n     let did = ast_util::local_def(e.id);\n@@ -84,47 +84,47 @@ pub fn classify(e: &expr,\n       None => {\n         let cn =\n             match e.node {\n-              ast::expr_lit(lit) => {\n+              ast::ExprLit(lit) => {\n                 match lit.node {\n                   ast::lit_str(*) |\n                   ast::lit_float(*) => general_const,\n                   _ => integral_const\n                 }\n               }\n \n-              ast::expr_unary(_, _, inner) |\n-              ast::expr_paren(inner) => {\n+              ast::ExprUnary(_, _, inner) |\n+              ast::ExprParen(inner) => {\n                 classify(inner, tcx)\n               }\n \n-              ast::expr_binary(_, _, a, b) => {\n+              ast::ExprBinary(_, _, a, b) => {\n                 join(classify(a, tcx),\n                      classify(b, tcx))\n               }\n \n-              ast::expr_tup(ref es) |\n-              ast::expr_vec(ref es, ast::m_imm) => {\n+              ast::ExprTup(ref es) |\n+              ast::ExprVec(ref es, ast::MutImmutable) => {\n                 join_all(es.iter().map(|e| classify(*e, tcx)))\n               }\n \n-              ast::expr_vstore(e, vstore) => {\n+              ast::ExprVstore(e, vstore) => {\n                   match vstore {\n-                      ast::expr_vstore_slice => classify(e, tcx),\n-                      ast::expr_vstore_uniq |\n-                      ast::expr_vstore_box |\n-                      ast::expr_vstore_mut_box |\n-                      ast::expr_vstore_mut_slice => non_const\n+                      ast::ExprVstoreSlice => classify(e, tcx),\n+                      ast::ExprVstoreUniq |\n+                      ast::ExprVstoreBox |\n+                      ast::ExprVstoreMutBox |\n+                      ast::ExprVstoreMutSlice => non_const\n                   }\n               }\n \n-              ast::expr_struct(_, ref fs, None) => {\n+              ast::ExprStruct(_, ref fs, None) => {\n                 let cs = do fs.iter().map |f| {\n                     classify(f.expr, tcx)\n                 };\n                 join_all(cs)\n               }\n \n-              ast::expr_cast(base, _) => {\n+              ast::ExprCast(base, _) => {\n                 let ty = ty::expr_ty(tcx, e);\n                 let base = classify(base, tcx);\n                 if ty::type_is_integral(ty) {\n@@ -136,26 +136,26 @@ pub fn classify(e: &expr,\n                 }\n               }\n \n-              ast::expr_field(base, _, _) => {\n+              ast::ExprField(base, _, _) => {\n                 classify(base, tcx)\n               }\n \n-              ast::expr_index(_, base, idx) => {\n+              ast::ExprIndex(_, base, idx) => {\n                 join(classify(base, tcx),\n                      classify(idx, tcx))\n               }\n \n-              ast::expr_addr_of(ast::m_imm, base) => {\n+              ast::ExprAddrOf(ast::MutImmutable, base) => {\n                 classify(base, tcx)\n               }\n \n               // FIXME: (#3728) we can probably do something CCI-ish\n               // surrounding nonlocal constants. But we don't yet.\n-              ast::expr_path(_) => {\n+              ast::ExprPath(_) => {\n                 lookup_constness(tcx, e)\n               }\n \n-              ast::expr_repeat(*) => general_const,\n+              ast::ExprRepeat(*) => general_const,\n \n               _ => non_const\n             };\n@@ -165,21 +165,21 @@ pub fn classify(e: &expr,\n     }\n }\n \n-pub fn lookup_const(tcx: ty::ctxt, e: &expr) -> Option<@expr> {\n+pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n     match tcx.def_map.find(&e.id) {\n-        Some(&ast::def_static(def_id, false)) => lookup_const_by_id(tcx, def_id),\n-        Some(&ast::def_variant(enum_def, variant_def)) => lookup_variant_by_id(tcx,\n+        Some(&ast::DefStatic(def_id, false)) => lookup_const_by_id(tcx, def_id),\n+        Some(&ast::DefVariant(enum_def, variant_def)) => lookup_variant_by_id(tcx,\n                                                                                enum_def,\n                                                                                variant_def),\n         _ => None\n     }\n }\n \n pub fn lookup_variant_by_id(tcx: ty::ctxt,\n-                            enum_def: ast::def_id,\n-                            variant_def: ast::def_id)\n-                       -> Option<@expr> {\n-    fn variant_expr(variants: &[ast::variant], id: ast::NodeId) -> Option<@expr> {\n+                            enum_def: ast::DefId,\n+                            variant_def: ast::DefId)\n+                       -> Option<@Expr> {\n+    fn variant_expr(variants: &[ast::variant], id: ast::NodeId) -> Option<@Expr> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;\n@@ -225,13 +225,13 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n }\n \n pub fn lookup_const_by_id(tcx: ty::ctxt,\n-                          def_id: ast::def_id)\n-                       -> Option<@expr> {\n+                          def_id: ast::DefId)\n+                       -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n         match tcx.items.find(&def_id.node) {\n             None => None,\n             Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n+                item_static(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             Some(_) => None\n@@ -247,15 +247,15 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n             csearch::found(ast::ii_item(item)) => match item.node {\n-                item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n+                item_static(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             _ => None\n         }\n     }\n }\n \n-pub fn lookup_constness(tcx: ty::ctxt, e: &expr) -> constness {\n+pub fn lookup_constness(tcx: ty::ctxt, e: &Expr) -> constness {\n     match lookup_const(tcx, e) {\n         Some(rhs) => {\n             let ty = ty::expr_ty(tcx, rhs);\n@@ -272,7 +272,7 @@ pub fn lookup_constness(tcx: ty::ctxt, e: &expr) -> constness {\n struct ConstEvalVisitor { tcx: ty::ctxt }\n \n impl Visitor<()> for ConstEvalVisitor {\n-    fn visit_expr_post(&mut self, e:@expr, _:()) {\n+    fn visit_expr_post(&mut self, e:@Expr, _:()) {\n         classify(e, self.tcx);\n     }\n }\n@@ -296,19 +296,19 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn eval_const_expr(tcx: middle::ty::ctxt, e: &expr) -> const_val {\n+pub fn eval_const_expr(tcx: middle::ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(&tcx, e) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n }\n \n-pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &expr)\n+pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             -> Result<const_val, ~str> {\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n-      expr_unary(_, neg, inner) => {\n+      ExprUnary(_, UnNeg, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n@@ -318,108 +318,108 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &expr)\n           ref err => ((*err).clone())\n         }\n       }\n-      expr_unary(_, not, inner) => {\n+      ExprUnary(_, UnNot, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(~\"Not on float or string\")\n         }\n       }\n-      expr_binary(_, op, a, b) => {\n+      ExprBinary(_, op, a, b) => {\n         match (eval_const_expr_partial(tcx, a),\n                eval_const_expr_partial(tcx, b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op {\n-              add => Ok(const_float(a + b)),\n-              subtract => Ok(const_float(a - b)),\n-              mul => Ok(const_float(a * b)),\n-              div => Ok(const_float(a / b)),\n-              rem => Ok(const_float(a % b)),\n-              eq => fromb(a == b),\n-              lt => fromb(a < b),\n-              le => fromb(a <= b),\n-              ne => fromb(a != b),\n-              ge => fromb(a >= b),\n-              gt => fromb(a > b),\n+              BiAdd => Ok(const_float(a + b)),\n+              BiSub => Ok(const_float(a - b)),\n+              BiMul => Ok(const_float(a * b)),\n+              BiDiv => Ok(const_float(a / b)),\n+              BiRem => Ok(const_float(a % b)),\n+              BiEq => fromb(a == b),\n+              BiLt => fromb(a < b),\n+              BiLe => fromb(a <= b),\n+              BiNe => fromb(a != b),\n+              BiGe => fromb(a >= b),\n+              BiGt => fromb(a > b),\n               _ => Err(~\"Can't do this op on floats\")\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n             match op {\n-              add => Ok(const_int(a + b)),\n-              subtract => Ok(const_int(a - b)),\n-              mul => Ok(const_int(a * b)),\n-              div if b == 0 => Err(~\"attempted to divide by zero\"),\n-              div => Ok(const_int(a / b)),\n-              rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n-              rem => Ok(const_int(a % b)),\n-              and | bitand => Ok(const_int(a & b)),\n-              or | bitor => Ok(const_int(a | b)),\n-              bitxor => Ok(const_int(a ^ b)),\n-              shl => Ok(const_int(a << b)),\n-              shr => Ok(const_int(a >> b)),\n-              eq => fromb(a == b),\n-              lt => fromb(a < b),\n-              le => fromb(a <= b),\n-              ne => fromb(a != b),\n-              ge => fromb(a >= b),\n-              gt => fromb(a > b)\n+              BiAdd => Ok(const_int(a + b)),\n+              BiSub => Ok(const_int(a - b)),\n+              BiMul => Ok(const_int(a * b)),\n+              BiDiv if b == 0 => Err(~\"attempted to divide by zero\"),\n+              BiDiv => Ok(const_int(a / b)),\n+              BiRem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n+              BiRem => Ok(const_int(a % b)),\n+              BiAnd | BiBitAnd => Ok(const_int(a & b)),\n+              BiOr | BiBitOr => Ok(const_int(a | b)),\n+              BiBitXor => Ok(const_int(a ^ b)),\n+              BiShl => Ok(const_int(a << b)),\n+              BiShr => Ok(const_int(a >> b)),\n+              BiEq => fromb(a == b),\n+              BiLt => fromb(a < b),\n+              BiLe => fromb(a <= b),\n+              BiNe => fromb(a != b),\n+              BiGe => fromb(a >= b),\n+              BiGt => fromb(a > b)\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_uint(b))) => {\n             match op {\n-              add => Ok(const_uint(a + b)),\n-              subtract => Ok(const_uint(a - b)),\n-              mul => Ok(const_uint(a * b)),\n-              div if b == 0 => Err(~\"attempted to divide by zero\"),\n-              div => Ok(const_uint(a / b)),\n-              rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n-              rem => Ok(const_uint(a % b)),\n-              and | bitand => Ok(const_uint(a & b)),\n-              or | bitor => Ok(const_uint(a | b)),\n-              bitxor => Ok(const_uint(a ^ b)),\n-              shl => Ok(const_uint(a << b)),\n-              shr => Ok(const_uint(a >> b)),\n-              eq => fromb(a == b),\n-              lt => fromb(a < b),\n-              le => fromb(a <= b),\n-              ne => fromb(a != b),\n-              ge => fromb(a >= b),\n-              gt => fromb(a > b),\n+              BiAdd => Ok(const_uint(a + b)),\n+              BiSub => Ok(const_uint(a - b)),\n+              BiMul => Ok(const_uint(a * b)),\n+              BiDiv if b == 0 => Err(~\"attempted to divide by zero\"),\n+              BiDiv => Ok(const_uint(a / b)),\n+              BiRem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n+              BiRem => Ok(const_uint(a % b)),\n+              BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n+              BiOr | BiBitOr => Ok(const_uint(a | b)),\n+              BiBitXor => Ok(const_uint(a ^ b)),\n+              BiShl => Ok(const_uint(a << b)),\n+              BiShr => Ok(const_uint(a >> b)),\n+              BiEq => fromb(a == b),\n+              BiLt => fromb(a < b),\n+              BiLe => fromb(a <= b),\n+              BiNe => fromb(a != b),\n+              BiGe => fromb(a >= b),\n+              BiGt => fromb(a > b),\n             }\n           }\n           // shifts can have any integral type as their rhs\n           (Ok(const_int(a)), Ok(const_uint(b))) => {\n             match op {\n-              shl => Ok(const_int(a << b)),\n-              shr => Ok(const_int(a >> b)),\n+              BiShl => Ok(const_int(a << b)),\n+              BiShr => Ok(const_int(a >> b)),\n               _ => Err(~\"Can't do this op on an int and uint\")\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n-              shl => Ok(const_uint(a << b)),\n-              shr => Ok(const_uint(a >> b)),\n+              BiShl => Ok(const_uint(a << b)),\n+              BiShr => Ok(const_uint(a >> b)),\n               _ => Err(~\"Can't do this op on a uint and int\")\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n             Ok(const_bool(match op {\n-              and => a && b,\n-              or => a || b,\n-              bitxor => a ^ b,\n-              bitand => a & b,\n-              bitor => a | b,\n-              eq => a == b,\n-              ne => a != b,\n+              BiAnd => a && b,\n+              BiOr => a || b,\n+              BiBitXor => a ^ b,\n+              BiBitAnd => a & b,\n+              BiBitOr => a | b,\n+              BiEq => a == b,\n+              BiNe => a != b,\n               _ => return Err(~\"Can't do this op on bools\")\n              }))\n           }\n           _ => Err(~\"Bad operands for binary\")\n         }\n       }\n-      expr_cast(base, _) => {\n+      ExprCast(base, _) => {\n         let ety = tcx.expr_ty(e);\n         let base = eval_const_expr_partial(tcx, base);\n         match base {\n@@ -455,16 +455,16 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &expr)\n             }\n         }\n       }\n-      expr_path(_) => {\n+      ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n               Some(actual_e) => eval_const_expr_partial(&tcx.ty_ctxt(), actual_e),\n               None => Err(~\"Non-constant path in constant expr\")\n           }\n       }\n-      expr_lit(lit) => Ok(lit_to_const(lit)),\n+      ExprLit(lit) => Ok(lit_to_const(lit)),\n       // If we have a vstore, just keep going; it has to be a string\n-      expr_vstore(e, _) => eval_const_expr_partial(tcx, e),\n-      expr_paren(e)     => eval_const_expr_partial(tcx, e),\n+      ExprVstore(e, _) => eval_const_expr_partial(tcx, e),\n+      ExprParen(e)     => eval_const_expr_partial(tcx, e),\n       _ => Err(~\"Unsupported constant expr\")\n     }\n }\n@@ -497,11 +497,11 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n     }\n }\n \n-pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<int> {\n+pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n-pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<bool> {\n+pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n     compare_lit_exprs(tcx, a, b).map_move(|val| val == 0)\n }\n "}, {"sha": "b392351c2f2935408183e92caf2a2b5eee40d5d0", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -390,40 +390,40 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_stmt(&mut self,\n-                 stmt: @ast::stmt,\n+                 stmt: @ast::Stmt,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         match stmt.node {\n-            ast::stmt_decl(decl, _) => {\n+            ast::StmtDecl(decl, _) => {\n                 self.walk_decl(decl, in_out, loop_scopes);\n             }\n \n-            ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+            ast::StmtExpr(expr, _) | ast::StmtSemi(expr, _) => {\n                 self.walk_expr(expr, in_out, loop_scopes);\n             }\n \n-            ast::stmt_mac(*) => {\n+            ast::StmtMac(*) => {\n                 self.tcx().sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n     }\n \n     fn walk_decl(&mut self,\n-                 decl: @ast::decl,\n+                 decl: @ast::Decl,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         match decl.node {\n-            ast::decl_local(local) => {\n+            ast::DeclLocal(local) => {\n                 self.walk_opt_expr(local.init, in_out, loop_scopes);\n                 self.walk_pat(local.pat, in_out, loop_scopes);\n             }\n \n-            ast::decl_item(_) => {}\n+            ast::DeclItem(_) => {}\n         }\n     }\n \n     fn walk_expr(&mut self,\n-                 expr: @ast::expr,\n+                 expr: @ast::Expr,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_expr(expr=%s, in_out=%s)\",\n@@ -432,7 +432,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         self.merge_with_entry_set(expr.id, in_out);\n \n         match expr.node {\n-            ast::expr_fn_block(ref decl, ref body) => {\n+            ast::ExprFnBlock(ref decl, ref body) => {\n                 if self.dfcx.oper.walk_closures() {\n                     // In the absence of once fns, we must assume that\n                     // every function body will execute more than\n@@ -521,7 +521,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 }\n             }\n \n-            ast::expr_if(cond, ref then, els) => {\n+            ast::ExprIf(cond, ref then, els) => {\n                 //\n                 //     (cond)\n                 //       |\n@@ -544,7 +544,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 join_bits(&self.dfcx.oper, then_bits, in_out);\n             }\n \n-            ast::expr_while(cond, ref blk) => {\n+            ast::ExprWhile(cond, ref blk) => {\n                 //\n                 //     (expr) <--+\n                 //       |       |\n@@ -570,9 +570,9 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n-            ast::expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::expr_loop(ref blk, _) => {\n+            ast::ExprLoop(ref blk, _) => {\n                 //\n                 //     (expr) <--+\n                 //       |       |\n@@ -596,7 +596,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n-            ast::expr_match(discr, ref arms) => {\n+            ast::ExprMatch(discr, ref arms) => {\n                 //\n                 //    (discr)\n                 //     / | \\\n@@ -630,100 +630,100 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 }\n             }\n \n-            ast::expr_ret(o_e) => {\n+            ast::ExprRet(o_e) => {\n                 self.walk_opt_expr(o_e, in_out, loop_scopes);\n                 self.reset(in_out);\n             }\n \n-            ast::expr_break(label) => {\n+            ast::ExprBreak(label) => {\n                 let scope = self.find_scope(expr, label, loop_scopes);\n                 self.break_from_to(expr, scope, in_out);\n                 self.reset(in_out);\n             }\n \n-            ast::expr_again(label) => {\n+            ast::ExprAgain(label) => {\n                 let scope = self.find_scope(expr, label, loop_scopes);\n                 self.pop_scopes(expr, scope, in_out);\n                 self.add_to_entry_set(scope.loop_id, reslice(in_out));\n                 self.reset(in_out);\n             }\n \n-            ast::expr_assign(l, r) |\n-            ast::expr_assign_op(_, _, l, r) => {\n+            ast::ExprAssign(l, r) |\n+            ast::ExprAssignOp(_, _, l, r) => {\n                 self.walk_expr(r, in_out, loop_scopes);\n                 self.walk_expr(l, in_out, loop_scopes);\n             }\n \n-            ast::expr_vec(ref exprs, _) => {\n+            ast::ExprVec(ref exprs, _) => {\n                 self.walk_exprs(*exprs, in_out, loop_scopes)\n             }\n \n-            ast::expr_repeat(l, r, _) => {\n+            ast::ExprRepeat(l, r, _) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n                 self.walk_expr(r, in_out, loop_scopes);\n             }\n \n-            ast::expr_struct(_, ref fields, with_expr) => {\n+            ast::ExprStruct(_, ref fields, with_expr) => {\n                 for field in fields.iter() {\n                     self.walk_expr(field.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n             }\n \n-            ast::expr_call(f, ref args, _) => {\n+            ast::ExprCall(f, ref args, _) => {\n                 self.walk_call(f.id, expr.id,\n                                f, *args, in_out, loop_scopes);\n             }\n \n-            ast::expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n+            ast::ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => {\n                 self.walk_call(callee_id, expr.id,\n                                rcvr, *args, in_out, loop_scopes);\n             }\n \n-            ast::expr_index(callee_id, l, r) |\n-            ast::expr_binary(callee_id, _, l, r) if self.is_method_call(expr) => {\n+            ast::ExprIndex(callee_id, l, r) |\n+            ast::ExprBinary(callee_id, _, l, r) if self.is_method_call(expr) => {\n                 self.walk_call(callee_id, expr.id,\n                                l, [r], in_out, loop_scopes);\n             }\n \n-            ast::expr_unary(callee_id, _, e) if self.is_method_call(expr) => {\n+            ast::ExprUnary(callee_id, _, e) if self.is_method_call(expr) => {\n                 self.walk_call(callee_id, expr.id,\n                                e, [], in_out, loop_scopes);\n             }\n \n-            ast::expr_tup(ref exprs) => {\n+            ast::ExprTup(ref exprs) => {\n                 self.walk_exprs(*exprs, in_out, loop_scopes);\n             }\n \n-            ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n                 let temp = reslice(in_out).to_owned();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n \n-            ast::expr_log(l, r) |\n-            ast::expr_index(_, l, r) |\n-            ast::expr_binary(_, _, l, r) => {\n+            ast::ExprLog(l, r) |\n+            ast::ExprIndex(_, l, r) |\n+            ast::ExprBinary(_, _, l, r) => {\n                 self.walk_exprs([l, r], in_out, loop_scopes);\n             }\n \n-            ast::expr_lit(*) |\n-            ast::expr_path(*) |\n-            ast::expr_self => {\n+            ast::ExprLit(*) |\n+            ast::ExprPath(*) |\n+            ast::ExprSelf => {\n             }\n \n-            ast::expr_addr_of(_, e) |\n-            ast::expr_do_body(e) |\n-            ast::expr_cast(e, _) |\n-            ast::expr_unary(_, _, e) |\n-            ast::expr_paren(e) |\n-            ast::expr_vstore(e, _) |\n-            ast::expr_field(e, _, _) => {\n+            ast::ExprAddrOf(_, e) |\n+            ast::ExprDoBody(e) |\n+            ast::ExprCast(e, _) |\n+            ast::ExprUnary(_, _, e) |\n+            ast::ExprParen(e) |\n+            ast::ExprVstore(e, _) |\n+            ast::ExprField(e, _, _) => {\n                 self.walk_expr(e, in_out, loop_scopes);\n             }\n \n-            ast::expr_inline_asm(ref inline_asm) => {\n+            ast::ExprInlineAsm(ref inline_asm) => {\n                 for &(_, expr) in inline_asm.inputs.iter() {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n@@ -732,11 +732,11 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 }\n             }\n \n-            ast::expr_block(ref blk) => {\n+            ast::ExprBlock(ref blk) => {\n                 self.walk_block(blk, in_out, loop_scopes);\n             }\n \n-            ast::expr_mac(*) => {\n+            ast::ExprMac(*) => {\n                 self.tcx().sess.span_bug(expr.span, \"unexpanded macro\");\n             }\n         }\n@@ -745,7 +745,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn pop_scopes(&mut self,\n-                  from_expr: @ast::expr,\n+                  from_expr: @ast::Expr,\n                   to_scope: &mut LoopScope,\n                   in_out: &mut [uint]) {\n         //! Whenever you have a `break` or a `loop` statement, flow\n@@ -779,7 +779,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn break_from_to(&mut self,\n-                     from_expr: @ast::expr,\n+                     from_expr: @ast::Expr,\n                      to_scope: &mut LoopScope,\n                      in_out: &mut [uint]) {\n         self.pop_scopes(from_expr, to_scope, in_out);\n@@ -792,7 +792,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_exprs(&mut self,\n-                  exprs: &[@ast::expr],\n+                  exprs: &[@ast::Expr],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n         for &expr in exprs.iter() {\n@@ -801,7 +801,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_opt_expr(&mut self,\n-                     opt_expr: Option<@ast::expr>,\n+                     opt_expr: Option<@ast::Expr>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut ~[LoopScope]) {\n         for &expr in opt_expr.iter() {\n@@ -812,8 +812,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     fn walk_call(&mut self,\n                  _callee_id: ast::NodeId,\n                  call_id: ast::NodeId,\n-                 arg0: @ast::expr,\n-                 args: &[@ast::expr],\n+                 arg0: @ast::Expr,\n+                 args: &[@ast::Expr],\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         self.walk_expr(arg0, in_out, loop_scopes);\n@@ -831,7 +831,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_pat(&mut self,\n-                pat: @ast::pat,\n+                pat: @ast::Pat,\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n@@ -846,7 +846,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_pat_alternatives(&mut self,\n-                             pats: &[@ast::pat],\n+                             pats: &[@ast::Pat],\n                              in_out: &mut [uint],\n                              loop_scopes: &mut ~[LoopScope]) {\n         if pats.len() == 1 {\n@@ -866,7 +866,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn find_scope<'a>(&self,\n-                      expr: @ast::expr,\n+                      expr: @ast::Expr,\n                       label: Option<ast::Ident>,\n                       loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n         let index = match label {\n@@ -877,7 +877,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n             Some(_) => {\n                 match self.tcx().def_map.find(&expr.id) {\n-                    Some(&ast::def_label(loop_id)) => {\n+                    Some(&ast::DefLabel(loop_id)) => {\n                         match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {\n@@ -900,7 +900,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         &mut loop_scopes[index]\n     }\n \n-    fn is_method_call(&self, expr: @ast::expr) -> bool {\n+    fn is_method_call(&self, expr: @ast::Expr) -> bool {\n         self.dfcx.method_map.contains_key(&expr.id)\n     }\n "}, {"sha": "160b03132e06f96c55b6218f32ce04c1c1a8b982", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -16,14 +16,14 @@ use middle::ty;\n use middle::typeck::method_map;\n use util::ppaux;\n \n-use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n-use syntax::ast::{expr_unary, unsafe_fn, expr_path};\n+use syntax::ast::{UnDeref, ExprCall, ExprInlineAsm, ExprMethodCall};\n+use syntax::ast::{ExprUnary, unsafe_fn, ExprPath};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit::{fk_item_fn, fk_method};\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{fn_decl,Block,NodeId,expr};\n+use syntax::ast::{fn_decl,Block,NodeId,Expr};\n \n #[deriving(Eq)]\n enum UnsafeContext {\n@@ -112,10 +112,10 @@ impl Visitor<()> for EffectCheckVisitor {\n             self.context.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr:@expr, _:()) {\n+    fn visit_expr(&mut self, expr:@Expr, _:()) {\n \n             match expr.node {\n-                expr_method_call(callee_id, _, _, _, _, _) => {\n+                ExprMethodCall(callee_id, _, _, _, _, _) => {\n                     let base_type = ty::node_id_to_type(self.tcx, callee_id);\n                     debug!(\"effect: method call case, base type is %s\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n@@ -124,15 +124,15 @@ impl Visitor<()> for EffectCheckVisitor {\n                                        \"invocation of unsafe method\")\n                     }\n                 }\n-                expr_call(base, _, _) => {\n+                ExprCall(base, _, _) => {\n                     let base_type = ty::node_id_to_type(self.tcx, base.id);\n                     debug!(\"effect: call case, base type is %s\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n                         self.require_unsafe(expr.span, \"call to unsafe function\")\n                     }\n                 }\n-                expr_unary(_, deref, base) => {\n+                ExprUnary(_, UnDeref, base) => {\n                     let base_type = ty::node_id_to_type(self.tcx, base.id);\n                     debug!(\"effect: unary case, base type is %s\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n@@ -144,12 +144,12 @@ impl Visitor<()> for EffectCheckVisitor {\n                         _ => {}\n                     }\n                 }\n-                expr_inline_asm(*) => {\n+                ExprInlineAsm(*) => {\n                     self.require_unsafe(expr.span, \"use of inline assembly\")\n                 }\n-                expr_path(*) => {\n+                ExprPath(*) => {\n                     match ty::resolve_expr(self.tcx, expr) {\n-                        ast::def_static(_, true) => {\n+                        ast::DefStatic(_, true) => {\n                             self.require_unsafe(expr.span, \"use of mutable static\")\n                         }\n                         _ => {}"}, {"sha": "ea6ff90634a004416280a11b22e30c0bac8b9aca", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::{item};\n // (The def_upvar will already have been stripped).\n #[deriving(Encodable, Decodable)]\n pub struct freevar_entry {\n-    def: ast::def, //< The variable being accessed free.\n+    def: ast::Def, //< The variable being accessed free.\n     span: Span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n@@ -44,21 +44,21 @@ impl Visitor<int> for CollectFreevarsVisitor {\n         // ignore_item\n     }\n \n-    fn visit_expr(&mut self, expr:@ast::expr, depth:int) {\n+    fn visit_expr(&mut self, expr:@ast::Expr, depth:int) {\n \n             match expr.node {\n-              ast::expr_fn_block(*) => {\n+              ast::ExprFnBlock(*) => {\n                 visit::walk_expr(self, expr, depth + 1)\n               }\n-              ast::expr_path(*) | ast::expr_self => {\n+              ast::ExprPath(*) | ast::ExprSelf => {\n                   let mut i = 0;\n                   match self.def_map.find(&expr.id) {\n                     None => fail!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n                       while i < depth {\n                         match def {\n-                          ast::def_upvar(_, inner, _, _) => { def = *inner; }\n+                          ast::DefUpvar(_, inner, _, _) => { def = *inner; }\n                           _ => break\n                         }\n                         i += 1;"}, {"sha": "d3b94e9f7c6f9509faa455a06c9404b566dd0a58", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -61,7 +61,7 @@ struct KindAnalysisVisitor;\n \n impl Visitor<Context> for KindAnalysisVisitor {\n \n-    fn visit_expr(&mut self, ex:@expr, e:Context) {\n+    fn visit_expr(&mut self, ex:@Expr, e:Context) {\n         check_expr(self, ex, e);\n     }\n \n@@ -92,7 +92,7 @@ pub fn check_crate(tcx: ty::ctxt,\n \n fn check_struct_safe_for_destructor(cx: Context,\n                                     span: Span,\n-                                    struct_did: def_id) {\n+                                    struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n     if !struct_tpt.generics.has_type_params() {\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n@@ -260,7 +260,7 @@ fn check_fn(\n     visit::walk_fn(v, fk, decl, body, sp, fn_id, cx);\n }\n \n-pub fn check_expr(v: &mut KindAnalysisVisitor, e: @expr, cx: Context) {\n+pub fn check_expr(v: &mut KindAnalysisVisitor, e: @Expr, cx: Context) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n@@ -272,7 +272,7 @@ pub fn check_expr(v: &mut KindAnalysisVisitor, e: @expr, cx: Context) {\n         let r = cx.tcx.node_type_substs.find(&type_parameter_id);\n         for ts in r.iter() {\n             let type_param_defs = match e.node {\n-              expr_path(_) => {\n+              ExprPath(_) => {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n               }\n@@ -301,11 +301,11 @@ pub fn check_expr(v: &mut KindAnalysisVisitor, e: @expr, cx: Context) {\n     }\n \n     match e.node {\n-        expr_unary(_, box(_), interior) => {\n+        ExprUnary(_, UnBox(_), interior) => {\n             let interior_type = ty::expr_ty(cx.tcx, interior);\n             let _ = check_durable(cx.tcx, interior_type, interior.span);\n         }\n-        expr_cast(source, _) => {\n+        ExprCast(source, _) => {\n             check_cast_for_escaping_regions(cx, source, e);\n             match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n                 ty::ty_trait(_, _, _, _, bounds) => {\n@@ -315,7 +315,7 @@ pub fn check_expr(v: &mut KindAnalysisVisitor, e: @expr, cx: Context) {\n                 _ => { }\n             }\n         }\n-        expr_repeat(element, count_expr, _) => {\n+        ExprRepeat(element, count_expr, _) => {\n             let count = ty::eval_repeat_count(&cx.tcx, count_expr);\n             if count > 1 {\n                 let element_ty = ty::expr_ty(cx.tcx, element);\n@@ -412,11 +412,11 @@ pub fn check_trait_cast_bounds(cx: Context, sp: Span, ty: ty::t,\n     }\n }\n \n-fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n+fn is_nullary_variant(cx: Context, ex: @Expr) -> bool {\n     match ex.node {\n-      expr_path(_) => {\n+      ExprPath(_) => {\n         match cx.tcx.def_map.get_copy(&ex.id) {\n-          def_variant(edid, vdid) => {\n+          DefVariant(edid, vdid) => {\n               ty::enum_variant_with_id(cx.tcx, edid, vdid).args.is_empty()\n           }\n           _ => false\n@@ -426,18 +426,18 @@ fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     }\n }\n \n-fn check_imm_free_var(cx: Context, def: def, sp: Span) {\n+fn check_imm_free_var(cx: Context, def: Def, sp: Span) {\n     match def {\n-        def_local(_, is_mutbl) => {\n+        DefLocal(_, is_mutbl) => {\n             if is_mutbl {\n                 cx.tcx.sess.span_err(\n                     sp,\n                     \"mutable variables cannot be implicitly captured\");\n             }\n         }\n-        def_arg(*) => { /* ok */ }\n-        def_upvar(_, def1, _, _) => { check_imm_free_var(cx, *def1, sp); }\n-        def_binding(*) | def_self(*) => { /*ok*/ }\n+        DefArg(*) => { /* ok */ }\n+        DefUpvar(_, def1, _, _) => { check_imm_free_var(cx, *def1, sp); }\n+        DefBinding(*) | DefSelf(*) => { /*ok*/ }\n         _ => {\n             cx.tcx.sess.span_bug(\n                 sp,\n@@ -515,8 +515,8 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n     cx: Context,\n-    source: &expr,\n-    target: &expr)\n+    source: &Expr,\n+    target: &Expr)\n {\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries."}, {"sha": "c8e1a46fa78548796c8db5f356043d7bb6e7d3b6", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -24,7 +24,7 @@ use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use metadata::cstore::iter_crate_data;\n use middle::ty::{BuiltinBound, BoundFreeze, BoundSend, BoundSized};\n-use syntax::ast::{Crate, def_id, MetaItem};\n+use syntax::ast::{Crate, DefId, MetaItem};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::ast::{item};\n@@ -83,7 +83,7 @@ pub enum LangItem {\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..41]\n+    items: [Option<DefId>, ..41]\n }\n \n impl LanguageItems {\n@@ -93,7 +93,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn each_item(&self, f: &fn(Option<def_id>, uint) -> bool) -> bool {\n+    pub fn each_item(&self, f: &fn(Option<DefId>, uint) -> bool) -> bool {\n         self.items.iter().enumerate().advance(|(i, &item)| f(item, i))\n     }\n \n@@ -151,15 +151,15 @@ impl LanguageItems {\n \n     // FIXME #4621: Method macros sure would be nice here.\n \n-    pub fn require(&self, it: LangItem) -> Result<def_id, ~str> {\n+    pub fn require(&self, it: LangItem) -> Result<DefId, ~str> {\n         match self.items[it as uint] {\n             Some(id) => Ok(id),\n             None => Err(fmt!(\"requires `%s` lang_item\",\n                              LanguageItems::item_name(it as uint)))\n         }\n     }\n \n-    pub fn to_builtin_kind(&self, id: def_id) -> Option<BuiltinBound> {\n+    pub fn to_builtin_kind(&self, id: DefId) -> Option<BuiltinBound> {\n         if Some(id) == self.freeze_trait() {\n             Some(BoundFreeze)\n         } else if Some(id) == self.send_trait() {\n@@ -171,128 +171,128 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn freeze_trait(&self) -> Option<def_id> {\n+    pub fn freeze_trait(&self) -> Option<DefId> {\n         self.items[FreezeTraitLangItem as uint]\n     }\n-    pub fn send_trait(&self) -> Option<def_id> {\n+    pub fn send_trait(&self) -> Option<DefId> {\n         self.items[SendTraitLangItem as uint]\n     }\n-    pub fn sized_trait(&self) -> Option<def_id> {\n+    pub fn sized_trait(&self) -> Option<DefId> {\n         self.items[SizedTraitLangItem as uint]\n     }\n \n-    pub fn drop_trait(&self) -> Option<def_id> {\n+    pub fn drop_trait(&self) -> Option<DefId> {\n         self.items[DropTraitLangItem as uint]\n     }\n \n-    pub fn add_trait(&self) -> Option<def_id> {\n+    pub fn add_trait(&self) -> Option<DefId> {\n         self.items[AddTraitLangItem as uint]\n     }\n-    pub fn sub_trait(&self) -> Option<def_id> {\n+    pub fn sub_trait(&self) -> Option<DefId> {\n         self.items[SubTraitLangItem as uint]\n     }\n-    pub fn mul_trait(&self) -> Option<def_id> {\n+    pub fn mul_trait(&self) -> Option<DefId> {\n         self.items[MulTraitLangItem as uint]\n     }\n-    pub fn div_trait(&self) -> Option<def_id> {\n+    pub fn div_trait(&self) -> Option<DefId> {\n         self.items[DivTraitLangItem as uint]\n     }\n-    pub fn rem_trait(&self) -> Option<def_id> {\n+    pub fn rem_trait(&self) -> Option<DefId> {\n         self.items[RemTraitLangItem as uint]\n     }\n-    pub fn neg_trait(&self) -> Option<def_id> {\n+    pub fn neg_trait(&self) -> Option<DefId> {\n         self.items[NegTraitLangItem as uint]\n     }\n-    pub fn not_trait(&self) -> Option<def_id> {\n+    pub fn not_trait(&self) -> Option<DefId> {\n         self.items[NotTraitLangItem as uint]\n     }\n-    pub fn bitxor_trait(&self) -> Option<def_id> {\n+    pub fn bitxor_trait(&self) -> Option<DefId> {\n         self.items[BitXorTraitLangItem as uint]\n     }\n-    pub fn bitand_trait(&self) -> Option<def_id> {\n+    pub fn bitand_trait(&self) -> Option<DefId> {\n         self.items[BitAndTraitLangItem as uint]\n     }\n-    pub fn bitor_trait(&self) -> Option<def_id> {\n+    pub fn bitor_trait(&self) -> Option<DefId> {\n         self.items[BitOrTraitLangItem as uint]\n     }\n-    pub fn shl_trait(&self) -> Option<def_id> {\n+    pub fn shl_trait(&self) -> Option<DefId> {\n         self.items[ShlTraitLangItem as uint]\n     }\n-    pub fn shr_trait(&self) -> Option<def_id> {\n+    pub fn shr_trait(&self) -> Option<DefId> {\n         self.items[ShrTraitLangItem as uint]\n     }\n-    pub fn index_trait(&self) -> Option<def_id> {\n+    pub fn index_trait(&self) -> Option<DefId> {\n         self.items[IndexTraitLangItem as uint]\n     }\n \n-    pub fn eq_trait(&self) -> Option<def_id> {\n+    pub fn eq_trait(&self) -> Option<DefId> {\n         self.items[EqTraitLangItem as uint]\n     }\n-    pub fn ord_trait(&self) -> Option<def_id> {\n+    pub fn ord_trait(&self) -> Option<DefId> {\n         self.items[OrdTraitLangItem as uint]\n     }\n \n-    pub fn str_eq_fn(&self) -> Option<def_id> {\n+    pub fn str_eq_fn(&self) -> Option<DefId> {\n         self.items[StrEqFnLangItem as uint]\n     }\n-    pub fn uniq_str_eq_fn(&self) -> Option<def_id> {\n+    pub fn uniq_str_eq_fn(&self) -> Option<DefId> {\n         self.items[UniqStrEqFnLangItem as uint]\n     }\n-    pub fn log_type_fn(&self) -> Option<def_id> {\n+    pub fn log_type_fn(&self) -> Option<DefId> {\n         self.items[LogTypeFnLangItem as uint]\n     }\n-    pub fn fail_fn(&self) -> Option<def_id> {\n+    pub fn fail_fn(&self) -> Option<DefId> {\n         self.items[FailFnLangItem as uint]\n     }\n-    pub fn fail_bounds_check_fn(&self) -> Option<def_id> {\n+    pub fn fail_bounds_check_fn(&self) -> Option<DefId> {\n         self.items[FailBoundsCheckFnLangItem as uint]\n     }\n-    pub fn exchange_malloc_fn(&self) -> Option<def_id> {\n+    pub fn exchange_malloc_fn(&self) -> Option<DefId> {\n         self.items[ExchangeMallocFnLangItem as uint]\n     }\n-    pub fn closure_exchange_malloc_fn(&self) -> Option<def_id> {\n+    pub fn closure_exchange_malloc_fn(&self) -> Option<DefId> {\n         self.items[ClosureExchangeMallocFnLangItem as uint]\n     }\n-    pub fn exchange_free_fn(&self) -> Option<def_id> {\n+    pub fn exchange_free_fn(&self) -> Option<DefId> {\n         self.items[ExchangeFreeFnLangItem as uint]\n     }\n-    pub fn malloc_fn(&self) -> Option<def_id> {\n+    pub fn malloc_fn(&self) -> Option<DefId> {\n         self.items[MallocFnLangItem as uint]\n     }\n-    pub fn free_fn(&self) -> Option<def_id> {\n+    pub fn free_fn(&self) -> Option<DefId> {\n         self.items[FreeFnLangItem as uint]\n     }\n-    pub fn borrow_as_imm_fn(&self) -> Option<def_id> {\n+    pub fn borrow_as_imm_fn(&self) -> Option<DefId> {\n         self.items[BorrowAsImmFnLangItem as uint]\n     }\n-    pub fn borrow_as_mut_fn(&self) -> Option<def_id> {\n+    pub fn borrow_as_mut_fn(&self) -> Option<DefId> {\n         self.items[BorrowAsMutFnLangItem as uint]\n     }\n-    pub fn return_to_mut_fn(&self) -> Option<def_id> {\n+    pub fn return_to_mut_fn(&self) -> Option<DefId> {\n         self.items[ReturnToMutFnLangItem as uint]\n     }\n-    pub fn check_not_borrowed_fn(&self) -> Option<def_id> {\n+    pub fn check_not_borrowed_fn(&self) -> Option<DefId> {\n         self.items[CheckNotBorrowedFnLangItem as uint]\n     }\n-    pub fn strdup_uniq_fn(&self) -> Option<def_id> {\n+    pub fn strdup_uniq_fn(&self) -> Option<DefId> {\n         self.items[StrDupUniqFnLangItem as uint]\n     }\n-    pub fn record_borrow_fn(&self) -> Option<def_id> {\n+    pub fn record_borrow_fn(&self) -> Option<DefId> {\n         self.items[RecordBorrowFnLangItem as uint]\n     }\n-    pub fn unrecord_borrow_fn(&self) -> Option<def_id> {\n+    pub fn unrecord_borrow_fn(&self) -> Option<DefId> {\n         self.items[UnrecordBorrowFnLangItem as uint]\n     }\n-    pub fn start_fn(&self) -> Option<def_id> {\n+    pub fn start_fn(&self) -> Option<DefId> {\n         self.items[StartFnLangItem as uint]\n     }\n-    pub fn ty_desc(&self) -> Option<def_id> {\n+    pub fn ty_desc(&self) -> Option<DefId> {\n         self.items[TyDescStructLangItem as uint]\n     }\n-    pub fn ty_visitor(&self) -> Option<def_id> {\n+    pub fn ty_visitor(&self) -> Option<DefId> {\n         self.items[TyVisitorTraitLangItem as uint]\n     }\n-    pub fn opaque(&self) -> Option<def_id> {\n+    pub fn opaque(&self) -> Option<DefId> {\n         self.items[OpaqueStructLangItem as uint]\n     }\n }\n@@ -388,7 +388,7 @@ impl<'self> LanguageItemCollector<'self> {\n     }\n \n     pub fn match_and_collect_meta_item(&mut self,\n-                                       item_def_id: def_id,\n+                                       item_def_id: DefId,\n                                        meta_item: &MetaItem) {\n         match meta_item.name_str_pair() {\n             Some((key, value)) => {\n@@ -398,7 +398,7 @@ impl<'self> LanguageItemCollector<'self> {\n         }\n     }\n \n-    pub fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n+    pub fn collect_item(&mut self, item_index: uint, item_def_id: DefId) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -415,7 +415,7 @@ impl<'self> LanguageItemCollector<'self> {\n     }\n \n     pub fn match_and_collect_item(&mut self,\n-                                  item_def_id: def_id,\n+                                  item_def_id: DefId,\n                                   key: &str,\n                                   value: @str) {\n         if \"lang\" != key {\n@@ -448,7 +448,7 @@ impl<'self> LanguageItemCollector<'self> {\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             do each_lang_item(crate_store, crate_number)\n                     |node_id, item_index| {\n-                let def_id = def_id { crate: crate_number, node: node_id };\n+                let def_id = DefId { crate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);\n                 true\n             };"}, {"sha": "596fd05b2627687886b0a7cd579395decf48bc54", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -674,12 +674,12 @@ impl Visitor<@mut Context> for WhileTrueLintVisitor {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n-    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n \n             match e.node {\n-                ast::expr_while(cond, _) => {\n+                ast::ExprWhile(cond, _) => {\n                     match cond.node {\n-                        ast::expr_lit(@codemap::Spanned {\n+                        ast::ExprLit(@codemap::Spanned {\n                             node: ast::lit_bool(true), _}) =>\n                         {\n                             cx.span_lint(while_true, e.span,\n@@ -725,24 +725,24 @@ impl SubitemStoppableVisitor for TypeLimitsLintVisitor {\n }\n \n impl TypeLimitsLintVisitor {\n-    fn is_valid<T:cmp::Ord>(&mut self, binop: ast::binop, v: T,\n+    fn is_valid<T:cmp::Ord>(&mut self, binop: ast::BinOp, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n-            ast::lt => v <= max,\n-            ast::le => v < max,\n-            ast::gt => v >= min,\n-            ast::ge => v > min,\n-            ast::eq | ast::ne => v >= min && v <= max,\n+            ast::BiLt => v <= max,\n+            ast::BiLe => v < max,\n+            ast::BiGt => v >= min,\n+            ast::BiGe => v > min,\n+            ast::BiEq | ast::BiNe => v >= min && v <= max,\n             _ => fail!()\n         }\n     }\n \n-    fn rev_binop(&mut self, binop: ast::binop) -> ast::binop {\n+    fn rev_binop(&mut self, binop: ast::BinOp) -> ast::BinOp {\n         match binop {\n-            ast::lt => ast::gt,\n-            ast::le => ast::ge,\n-            ast::gt => ast::lt,\n-            ast::ge => ast::le,\n+            ast::BiLt => ast::BiGt,\n+            ast::BiLe => ast::BiGe,\n+            ast::BiGt => ast::BiLt,\n+            ast::BiGe => ast::BiLe,\n             _ => binop\n         }\n     }\n@@ -772,13 +772,13 @@ impl TypeLimitsLintVisitor {\n \n     fn check_limits(&mut self,\n                     cx: &Context,\n-                    binop: ast::binop,\n-                    l: @ast::expr,\n-                    r: @ast::expr)\n+                    binop: ast::BinOp,\n+                    l: @ast::Expr,\n+                    r: @ast::Expr)\n                     -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n-            (&ast::expr_lit(_), _) => (l, r, true),\n-            (_, &ast::expr_lit(_)) => (r, l, false),\n+            (&ast::ExprLit(_), _) => (l, r, true),\n+            (_, &ast::ExprLit(_)) => (r, l, false),\n             _ => return true\n         };\n         // Normalize the binop so that the literal is always on the RHS in\n@@ -792,7 +792,7 @@ impl TypeLimitsLintVisitor {\n             ty::ty_int(int_ty) => {\n                 let (min, max) = self.int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n-                    ast::expr_lit(@li) => match li.node {\n+                    ast::ExprLit(@li) => match li.node {\n                         ast::lit_int(v, _) => v,\n                         ast::lit_uint(v, _) => v as i64,\n                         ast::lit_int_unsuffixed(v) => v,\n@@ -805,7 +805,7 @@ impl TypeLimitsLintVisitor {\n             ty::ty_uint(uint_ty) => {\n                 let (min, max): (u64, u64) = self.uint_ty_range(uint_ty);\n                 let lit_val: u64 = match lit.node {\n-                    ast::expr_lit(@li) => match li.node {\n+                    ast::ExprLit(@li) => match li.node {\n                         ast::lit_int(v, _) => v as u64,\n                         ast::lit_uint(v, _) => v,\n                         ast::lit_int_unsuffixed(v) => v as u64,\n@@ -819,10 +819,10 @@ impl TypeLimitsLintVisitor {\n         }\n     }\n \n-    fn is_comparison(&mut self, binop: ast::binop) -> bool {\n+    fn is_comparison(&mut self, binop: ast::BinOp) -> bool {\n         match binop {\n-            ast::eq | ast::lt | ast::le |\n-            ast::ne | ast::ge | ast::gt => true,\n+            ast::BiEq | ast::BiLt | ast::BiLe |\n+            ast::BiNe | ast::BiGe | ast::BiGt => true,\n             _ => false\n         }\n     }\n@@ -838,10 +838,10 @@ impl Visitor<@mut Context> for TypeLimitsLintVisitor {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n-    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n \n             match e.node {\n-                ast::expr_binary(_, ref binop, l, r) => {\n+                ast::ExprBinary(_, ref binop, l, r) => {\n                     if self.is_comparison(*binop)\n                         && !self.check_limits(cx, *binop, l, r) {\n                         cx.span_lint(type_limits, e.span,\n@@ -865,12 +865,12 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n         match ty.node {\n             ast::ty_path(_, _, id) => {\n                 match cx.tcx.def_map.get_copy(&id) {\n-                    ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n+                    ast::DefPrimTy(ast::ty_int(ast::ty_i)) => {\n                         cx.span_lint(ctypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n                                 libc::c_int or libc::c_long should be used\");\n                     }\n-                    ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n+                    ast::DefPrimTy(ast::ty_uint(ast::ty_u)) => {\n                         cx.span_lint(ctypes, ty.span,\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n@@ -979,7 +979,7 @@ impl Visitor<@mut Context> for HeapLintVisitor {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n-    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n             let ty = ty::expr_ty(cx.tcx, e);\n             check_type(cx, e.span, ty);\n             visit::walk_expr(self, e, cx);\n@@ -1010,10 +1010,10 @@ impl Visitor<@mut Context> for PathStatementLintVisitor {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n-    fn visit_stmt(&mut self, s:@ast::stmt, cx:@mut Context) {\n+    fn visit_stmt(&mut self, s:@ast::Stmt, cx:@mut Context) {\n             match s.node {\n-                ast::stmt_semi(\n-                    @ast::expr { node: ast::expr_path(_), _ },\n+                ast::StmtSemi(\n+                    @ast::Expr { node: ast::ExprPath(_), _ },\n                     _\n                 ) => {\n                     cx.span_lint(path_statement, s.span,\n@@ -1073,7 +1073,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n     match it.node {\n         // only check static constants\n-        ast::item_static(_, ast::m_imm, _) => {\n+        ast::item_static(_, ast::MutImmutable, _) => {\n             let s = cx.tcx.sess.str_of(it.ident);\n             // check for lowercase letters rather than non-uppercase\n             // ones (some scripts don't have a concept of\n@@ -1103,10 +1103,10 @@ impl Visitor<@mut Context> for UnusedUnsafeLintVisitor {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n-    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n \n             match e.node {\n-                ast::expr_block(ref blk) if blk.rules == ast::UnsafeBlock => {\n+                ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock => {\n                     if !cx.tcx.used_unsafe.contains(&blk.id) {\n                         cx.span_lint(unused_unsafe, blk.span,\n                                      \"unnecessary `unsafe` block\");\n@@ -1127,7 +1127,7 @@ fn lint_unused_unsafe() -> @mut OuterLint {\n struct UnusedMutLintVisitor { stopping_on_items: bool }\n \n impl UnusedMutLintVisitor {\n-    fn check_pat(&mut self, cx: &Context, p: @ast::pat) {\n+    fn check_pat(&mut self, cx: &Context, p: @ast::Pat) {\n         let mut used = false;\n         let mut bindings = 0;\n         do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n@@ -1229,7 +1229,7 @@ impl Visitor<@mut Context> for UnnecessaryAllocationLintVisitor {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n-    fn visit_expr(&mut self, e:@ast::expr, cx:@mut Context) {\n+    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n             self.check(cx, e);\n             visit::walk_expr(self, e, cx);\n     }\n@@ -1238,14 +1238,14 @@ impl Visitor<@mut Context> for UnnecessaryAllocationLintVisitor {\n impl UnnecessaryAllocationLintVisitor {\n     // Warn if string and vector literals with sigils are immediately borrowed.\n     // Those can have the sigil removed.\n-    fn check(&mut self, cx: &Context, e: &ast::expr) {\n+    fn check(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n-            ast::expr_vstore(e2, ast::expr_vstore_box) => {\n+            ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n+            ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n                 match e2.node {\n-                    ast::expr_lit(@codemap::Spanned{\n+                    ast::ExprLit(@codemap::Spanned{\n                             node: ast::lit_str(*), _}) |\n-                    ast::expr_vec(*) => {}\n+                    ast::ExprVec(*) => {}\n                     _ => return\n                 }\n             }"}, {"sha": "27a155403ed0fdd101ab32a09d060acc0c18eee2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -158,8 +158,8 @@ impl Visitor<@mut IrMaps> for LivenessVisitor {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:@mut IrMaps) { visit_local(self, l, e); }\n-    fn visit_expr(&mut self, ex:@expr, e:@mut IrMaps) { visit_expr(self, ex, e); }\n-    fn visit_arm(&mut self, a:&arm, e:@mut IrMaps) { visit_arm(self, a, e); }\n+    fn visit_expr(&mut self, ex:@Expr, e:@mut IrMaps) { visit_expr(self, ex, e); }\n+    fn visit_arm(&mut self, a:&Arm, e:@mut IrMaps) { visit_arm(self, a, e); }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -220,7 +220,7 @@ struct CaptureInfo {\n }\n \n enum LocalKind {\n-    FromMatch(binding_mode),\n+    FromMatch(BindingMode),\n     FromLetWithInitializer,\n     FromLetNoInitializer\n }\n@@ -331,7 +331,7 @@ impl IrMaps {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n-    pub fn captures(&mut self, expr: &expr) -> @~[CaptureInfo] {\n+    pub fn captures(&mut self, expr: &Expr) -> @~[CaptureInfo] {\n         match self.capture_info_map.find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n@@ -354,10 +354,10 @@ impl Visitor<@Liveness> for ErrorCheckVisitor {\n     fn visit_local(&mut self, l:@Local, e:@Liveness) {\n         check_local(self, l, e);\n     }\n-    fn visit_expr(&mut self, ex:@expr, e:@Liveness) {\n+    fn visit_expr(&mut self, ex:@Expr, e:@Liveness) {\n         check_expr(self, ex, e);\n     }\n-    fn visit_arm(&mut self, a:&arm, e:@Liveness) {\n+    fn visit_arm(&mut self, a:&Arm, e:@Liveness) {\n         check_arm(self, a, e);\n     }\n }\n@@ -449,7 +449,7 @@ fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     visit::walk_local(v, local, this);\n }\n \n-fn visit_arm(v: &mut LivenessVisitor, arm: &arm, this: @mut IrMaps) {\n+fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -468,18 +468,18 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &arm, this: @mut IrMaps) {\n     visit::walk_arm(v, arm, this);\n }\n \n-fn visit_expr(v: &mut LivenessVisitor, expr: @expr, this: @mut IrMaps) {\n+fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      expr_path(_) | expr_self => {\n+      ExprPath(_) | ExprSelf => {\n         let def = this.tcx.def_map.get_copy(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::walk_expr(v, expr, this);\n       }\n-      expr_fn_block(*) => {\n+      ExprFnBlock(*) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -514,25 +514,25 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @expr, this: @mut IrMaps) {\n       }\n \n       // live nodes required for interesting control flow:\n-      expr_if(*) | expr_match(*) | expr_while(*) | expr_loop(*) => {\n+      ExprIf(*) | ExprMatch(*) | ExprWhile(*) | ExprLoop(*) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n-      expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n-      expr_binary(_, op, _, _) if ast_util::lazy_binop(op) => {\n+      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+      ExprBinary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n \n       // otherwise, live nodes are not required:\n-      expr_index(*) | expr_field(*) | expr_vstore(*) | expr_vec(*) |\n-      expr_call(*) | expr_method_call(*) | expr_tup(*) | expr_log(*) |\n-      expr_binary(*) | expr_addr_of(*) |\n-      expr_do_body(*) | expr_cast(*) | expr_unary(*) | expr_break(_) |\n-      expr_again(_) | expr_lit(_) | expr_ret(*) | expr_block(*) |\n-      expr_assign(*) | expr_assign_op(*) | expr_mac(*) |\n-      expr_struct(*) | expr_repeat(*) | expr_paren(*) |\n-      expr_inline_asm(*) => {\n+      ExprIndex(*) | ExprField(*) | ExprVstore(*) | ExprVec(*) |\n+      ExprCall(*) | ExprMethodCall(*) | ExprTup(*) | ExprLog(*) |\n+      ExprBinary(*) | ExprAddrOf(*) |\n+      ExprDoBody(*) | ExprCast(*) | ExprUnary(*) | ExprBreak(_) |\n+      ExprAgain(_) | ExprLit(_) | ExprRet(*) | ExprBlock(*) |\n+      ExprAssign(*) | ExprAssignOp(*) | ExprMac(*) |\n+      ExprStruct(*) | ExprRepeat(*) | ExprParen(*) |\n+      ExprInlineAsm(*) => {\n           visit::walk_expr(v, expr, this);\n       }\n     }\n@@ -618,9 +618,9 @@ impl Liveness {\n         }\n     }\n \n-    pub fn variable_from_path(&self, expr: &expr) -> Option<Variable> {\n+    pub fn variable_from_path(&self, expr: &Expr) -> Option<Variable> {\n         match expr.node {\n-          expr_path(_) => {\n+          ExprPath(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n             do moves::moved_variable_node_id_from_def(def).map_move |rdef| {\n                 self.variable(rdef, expr.span)\n@@ -650,7 +650,7 @@ impl Liveness {\n     }\n \n     pub fn pat_bindings(&self,\n-                        pat: @pat,\n+                        pat: @Pat,\n                         f: &fn(LiveNode, Variable, Span, NodeId)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n@@ -661,7 +661,7 @@ impl Liveness {\n     }\n \n     pub fn arm_pats_bindings(&self,\n-                             pats: &[@pat],\n+                             pats: &[@Pat],\n                              f: &fn(LiveNode, Variable, Span, NodeId)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n@@ -671,12 +671,12 @@ impl Liveness {\n         }\n     }\n \n-    pub fn define_bindings_in_pat(&self, pat: @pat, succ: LiveNode)\n+    pub fn define_bindings_in_pat(&self, pat: @Pat, succ: LiveNode)\n                                   -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    pub fn define_bindings_in_arm_pats(&self, pats: &[@pat], succ: LiveNode)\n+    pub fn define_bindings_in_arm_pats(&self, pats: &[@Pat], succ: LiveNode)\n                                        -> LiveNode {\n         let mut succ = succ;\n         do self.arm_pats_bindings(pats) |ln, var, _sp, _id| {\n@@ -764,7 +764,7 @@ impl Liveness {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n                       // to find with one\n                 match self.tcx.def_map.find(&id) {\n-                    Some(&def_label(loop_id)) => loop_id,\n+                    Some(&DefLabel(loop_id)) => loop_id,\n                     _ => self.tcx.sess.span_bug(sp, \"Label on break/loop \\\n                                                      doesn't refer to a loop\")\n                 },\n@@ -945,30 +945,30 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_stmt(&self, stmt: &stmt, succ: LiveNode)\n+    pub fn propagate_through_stmt(&self, stmt: &Stmt, succ: LiveNode)\n                                   -> LiveNode {\n         match stmt.node {\n-          stmt_decl(decl, _) => {\n+          StmtDecl(decl, _) => {\n             return self.propagate_through_decl(decl, succ);\n           }\n \n-          stmt_expr(expr, _) | stmt_semi(expr, _) => {\n+          StmtExpr(expr, _) | StmtSemi(expr, _) => {\n             return self.propagate_through_expr(expr, succ);\n           }\n \n-          stmt_mac(*) => {\n+          StmtMac(*) => {\n             self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n           }\n         }\n     }\n \n-    pub fn propagate_through_decl(&self, decl: &decl, succ: LiveNode)\n+    pub fn propagate_through_decl(&self, decl: &Decl, succ: LiveNode)\n                                   -> LiveNode {\n         match decl.node {\n-            decl_local(ref local) => {\n+            DeclLocal(ref local) => {\n                 self.propagate_through_local(*local, succ)\n             }\n-            decl_item(_) => succ,\n+            DeclItem(_) => succ,\n         }\n     }\n \n@@ -992,39 +992,39 @@ impl Liveness {\n         self.define_bindings_in_pat(local.pat, succ)\n     }\n \n-    pub fn propagate_through_exprs(&self, exprs: &[@expr], succ: LiveNode)\n+    pub fn propagate_through_exprs(&self, exprs: &[@Expr], succ: LiveNode)\n                                    -> LiveNode {\n         do exprs.rev_iter().fold(succ) |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         }\n     }\n \n     pub fn propagate_through_opt_expr(&self,\n-                                      opt_expr: Option<@expr>,\n+                                      opt_expr: Option<@Expr>,\n                                       succ: LiveNode)\n                                       -> LiveNode {\n         do opt_expr.iter().fold(succ) |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         }\n     }\n \n-    pub fn propagate_through_expr(&self, expr: @expr, succ: LiveNode)\n+    pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n                                   -> LiveNode {\n         debug!(\"propagate_through_expr: %s\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          expr_path(_) | expr_self => {\n+          ExprPath(_) | ExprSelf => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          expr_field(e, _, _) => {\n+          ExprField(e, _, _) => {\n               self.propagate_through_expr(e, succ)\n           }\n \n-          expr_fn_block(_, ref blk) => {\n+          ExprFnBlock(_, ref blk) => {\n               debug!(\"%s is an expr_fn_block\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -1047,7 +1047,7 @@ impl Liveness {\n               })\n           }\n \n-          expr_if(cond, ref then, els) => {\n+          ExprIf(cond, ref then, els) => {\n             //\n             //     (cond)\n             //       |\n@@ -1069,19 +1069,19 @@ impl Liveness {\n             self.propagate_through_expr(cond, ln)\n           }\n \n-          expr_while(cond, ref blk) => {\n+          ExprWhile(cond, ref blk) => {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n-          expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+          ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          expr_loop(ref blk, _) => {\n+          ExprLoop(ref blk, _) => {\n             self.propagate_through_loop(expr, None, blk, succ)\n           }\n \n-          expr_match(e, ref arms) => {\n+          ExprMatch(e, ref arms) => {\n             //\n             //      (e)\n             //       |\n@@ -1112,12 +1112,12 @@ impl Liveness {\n             self.propagate_through_expr(e, ln)\n           }\n \n-          expr_ret(o_e) => {\n+          ExprRet(o_e) => {\n             // ignore succ and subst exit_ln:\n             self.propagate_through_opt_expr(o_e, self.s.exit_ln)\n           }\n \n-          expr_break(opt_label) => {\n+          ExprBreak(opt_label) => {\n               // Find which label this break jumps to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1131,7 +1131,7 @@ impl Liveness {\n               }\n           }\n \n-          expr_again(opt_label) => {\n+          ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1145,15 +1145,15 @@ impl Liveness {\n               }\n           }\n \n-          expr_assign(l, r) => {\n+          ExprAssign(l, r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(l, succ, ACC_WRITE);\n             let succ = self.propagate_through_lvalue_components(l, succ);\n             self.propagate_through_expr(r, succ)\n           }\n \n-          expr_assign_op(_, _, l, r) => {\n+          ExprAssignOp(_, _, l, r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n@@ -1163,27 +1163,27 @@ impl Liveness {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          expr_vstore(expr, _) => {\n+          ExprVstore(expr, _) => {\n             self.propagate_through_expr(expr, succ)\n           }\n \n-          expr_vec(ref exprs, _) => {\n+          ExprVec(ref exprs, _) => {\n             self.propagate_through_exprs(*exprs, succ)\n           }\n \n-          expr_repeat(element, count, _) => {\n+          ExprRepeat(element, count, _) => {\n             let succ = self.propagate_through_expr(count, succ);\n             self.propagate_through_expr(element, succ)\n           }\n \n-          expr_struct(_, ref fields, with_expr) => {\n+          ExprStruct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n             do fields.rev_iter().fold(succ) |succ, field| {\n                 self.propagate_through_expr(field.expr, succ)\n             }\n           }\n \n-          expr_call(f, ref args, _) => {\n+          ExprCall(f, ref args, _) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n@@ -1193,7 +1193,7 @@ impl Liveness {\n             self.propagate_through_expr(f, succ)\n           }\n \n-          expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n+          ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, callee_id));\n@@ -1203,11 +1203,11 @@ impl Liveness {\n             self.propagate_through_expr(rcvr, succ)\n           }\n \n-          expr_tup(ref exprs) => {\n+          ExprTup(ref exprs) => {\n             self.propagate_through_exprs(*exprs, succ)\n           }\n \n-          expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+          ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n             let r_succ = self.propagate_through_expr(r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n@@ -1217,21 +1217,21 @@ impl Liveness {\n             self.propagate_through_expr(l, ln)\n           }\n \n-          expr_log(l, r) |\n-          expr_index(_, l, r) |\n-          expr_binary(_, _, l, r) => {\n+          ExprLog(l, r) |\n+          ExprIndex(_, l, r) |\n+          ExprBinary(_, _, l, r) => {\n             self.propagate_through_exprs([l, r], succ)\n           }\n \n-          expr_addr_of(_, e) |\n-          expr_do_body(e) |\n-          expr_cast(e, _) |\n-          expr_unary(_, _, e) |\n-          expr_paren(e) => {\n+          ExprAddrOf(_, e) |\n+          ExprDoBody(e) |\n+          ExprCast(e, _) |\n+          ExprUnary(_, _, e) |\n+          ExprParen(e) => {\n             self.propagate_through_expr(e, succ)\n           }\n \n-          expr_inline_asm(ref ia) =>{\n+          ExprInlineAsm(ref ia) =>{\n             let succ = do ia.inputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n             };\n@@ -1240,22 +1240,22 @@ impl Liveness {\n             }\n           }\n \n-          expr_lit(*) => {\n+          ExprLit(*) => {\n             succ\n           }\n \n-          expr_block(ref blk) => {\n+          ExprBlock(ref blk) => {\n             self.propagate_through_block(blk, succ)\n           }\n \n-          expr_mac(*) => {\n+          ExprMac(*) => {\n             self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n     }\n \n     pub fn propagate_through_lvalue_components(&self,\n-                                               expr: @expr,\n+                                               expr: @Expr,\n                                                succ: LiveNode)\n                                                -> LiveNode {\n         // # Lvalues\n@@ -1308,17 +1308,17 @@ impl Liveness {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            expr_path(_) => succ,\n-            expr_field(e, _, _) => self.propagate_through_expr(e, succ),\n+            ExprPath(_) => succ,\n+            ExprField(e, _, _) => self.propagate_through_expr(e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n \n     // see comment on propagate_through_lvalue()\n-    pub fn write_lvalue(&self, expr: &expr, succ: LiveNode, acc: uint)\n+    pub fn write_lvalue(&self, expr: &Expr, succ: LiveNode, acc: uint)\n                         -> LiveNode {\n         match expr.node {\n-          expr_path(_) => self.access_path(expr, succ, acc),\n+          ExprPath(_) => self.access_path(expr, succ, acc),\n \n           // We do not track other lvalues, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n@@ -1328,7 +1328,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn access_path(&self, expr: &expr, succ: LiveNode, acc: uint)\n+    pub fn access_path(&self, expr: &Expr, succ: LiveNode, acc: uint)\n                        -> LiveNode {\n         let def = self.tcx.def_map.get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n@@ -1346,8 +1346,8 @@ impl Liveness {\n     }\n \n     pub fn propagate_through_loop(&self,\n-                                  expr: &expr,\n-                                  cond: Option<@expr>,\n+                                  expr: &Expr,\n+                                  cond: Option<@Expr>,\n                                   body: &Block,\n                                   succ: LiveNode)\n                                   -> LiveNode {\n@@ -1452,37 +1452,37 @@ fn check_local(vt: &mut ErrorCheckVisitor, local: @Local, this: @Liveness) {\n     visit::walk_local(vt, local, this);\n }\n \n-fn check_arm(vt: &mut ErrorCheckVisitor, arm: &arm, this: @Liveness) {\n+fn check_arm(vt: &mut ErrorCheckVisitor, arm: &Arm, this: @Liveness) {\n     do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     }\n     visit::walk_arm(vt, arm, this);\n }\n \n-fn check_expr(vt: &mut ErrorCheckVisitor, expr: @expr, this: @Liveness) {\n+fn check_expr(vt: &mut ErrorCheckVisitor, expr: @Expr, this: @Liveness) {\n     match expr.node {\n-      expr_assign(l, r) => {\n+      ExprAssign(l, r) => {\n         this.check_lvalue(l, vt);\n         vt.visit_expr(r, this);\n \n         visit::walk_expr(vt, expr, this);\n       }\n \n-      expr_assign_op(_, _, l, _) => {\n+      ExprAssignOp(_, _, l, _) => {\n         this.check_lvalue(l, vt);\n \n         visit::walk_expr(vt, expr, this);\n       }\n \n-      expr_inline_asm(ref ia) => {\n+      ExprInlineAsm(ref ia) => {\n         for &(_, input) in ia.inputs.iter() {\n           vt.visit_expr(input, this);\n         }\n \n         // Output operands must be lvalues\n         for &(_, out) in ia.outputs.iter() {\n           match out.node {\n-            expr_addr_of(_, inner) => {\n+            ExprAddrOf(_, inner) => {\n               this.check_lvalue(inner, vt);\n             }\n             _ => {}\n@@ -1494,17 +1494,17 @@ fn check_expr(vt: &mut ErrorCheckVisitor, expr: @expr, this: @Liveness) {\n       }\n \n       // no correctness conditions related to liveness\n-      expr_call(*) | expr_method_call(*) | expr_if(*) | expr_match(*) |\n-      expr_while(*) | expr_loop(*) | expr_index(*) | expr_field(*) |\n-      expr_vstore(*) | expr_vec(*) | expr_tup(*) | expr_log(*) |\n-      expr_binary(*) | expr_do_body(*) |\n-      expr_cast(*) | expr_unary(*) | expr_ret(*) | expr_break(*) |\n-      expr_again(*) | expr_lit(_) | expr_block(*) |\n-      expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n-      expr_paren(*) | expr_fn_block(*) | expr_path(*) | expr_self(*) => {\n+      ExprCall(*) | ExprMethodCall(*) | ExprIf(*) | ExprMatch(*) |\n+      ExprWhile(*) | ExprLoop(*) | ExprIndex(*) | ExprField(*) |\n+      ExprVstore(*) | ExprVec(*) | ExprTup(*) | ExprLog(*) |\n+      ExprBinary(*) | ExprDoBody(*) |\n+      ExprCast(*) | ExprUnary(*) | ExprRet(*) | ExprBreak(*) |\n+      ExprAgain(*) | ExprLit(_) | ExprBlock(*) |\n+      ExprMac(*) | ExprAddrOf(*) | ExprStruct(*) | ExprRepeat(*) |\n+      ExprParen(*) | ExprFnBlock(*) | ExprPath(*) | ExprSelf(*) => {\n         visit::walk_expr(vt, expr, this);\n       }\n-      expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\")\n+      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n \n@@ -1549,11 +1549,11 @@ impl Liveness {\n         }\n     }\n \n-    pub fn check_lvalue(@self, expr: @expr, vt: &mut ErrorCheckVisitor) {\n+    pub fn check_lvalue(@self, expr: @Expr, vt: &mut ErrorCheckVisitor) {\n         match expr.node {\n-          expr_path(_) => {\n+          ExprPath(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n-              def_local(nid, _) => {\n+              DefLocal(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n                 // mutable, then check for a reassignment to flag the mutability\n@@ -1630,7 +1630,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n+    pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @Pat) {\n         do self.pat_bindings(pat) |ln, var, sp, id| {\n             if !self.warn_about_unused(sp, id, ln, var) {\n                 self.warn_about_dead_assign(sp, id, ln, var);"}, {"sha": "0171712c0823a042e39e0200595d84f87a6edecf", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -52,7 +52,7 @@ use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n use util::common::indenter;\n \n-use syntax::ast::{m_imm, m_mutbl};\n+use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n@@ -84,9 +84,9 @@ pub struct CopiedUpvar {\n #[deriving(Eq, IterBytes)]\n pub enum PointerKind {\n     uniq_ptr,\n-    gc_ptr(ast::mutability),\n-    region_ptr(ast::mutability, ty::Region),\n-    unsafe_ptr(ast::mutability)\n+    gc_ptr(ast::Mutability),\n+    region_ptr(ast::Mutability, ty::Region),\n+    unsafe_ptr(ast::Mutability)\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -174,7 +174,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         ty::ty_estr(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, _}) => {\n-            Some(deref_ptr(region_ptr(ast::m_imm, r)))\n+            Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n         ty::ty_box(ref mt) |\n@@ -188,7 +188,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n \n         ty::ty_estr(ty::vstore_box) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n-            Some(deref_ptr(gc_ptr(ast::m_imm)))\n+            Some(deref_ptr(gc_ptr(ast::MutImmutable)))\n         }\n \n         ty::ty_ptr(ref mt) => {\n@@ -222,7 +222,7 @@ pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n \n pub fn cat_expr(tcx: ty::ctxt,\n                 method_map: typeck::method_map,\n-                expr: @ast::expr)\n+                expr: @ast::Expr)\n              -> cmt {\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n@@ -232,7 +232,7 @@ pub fn cat_expr(tcx: ty::ctxt,\n \n pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n                            method_map: typeck::method_map,\n-                           expr: @ast::expr)\n+                           expr: @ast::Expr)\n                         -> cmt {\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n@@ -243,7 +243,7 @@ pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n pub fn cat_expr_autoderefd(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    expr: @ast::expr,\n+    expr: @ast::Expr,\n     autoderefs: uint) -> cmt\n {\n     let mcx = &mem_categorization_ctxt {\n@@ -258,7 +258,7 @@ pub fn cat_def(\n     expr_id: ast::NodeId,\n     expr_span: Span,\n     expr_ty: ty::t,\n-    def: ast::def) -> cmt {\n+    def: ast::Def) -> cmt {\n \n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n@@ -271,12 +271,12 @@ pub trait ast_node {\n     fn span(&self) -> Span;\n }\n \n-impl ast_node for @ast::expr {\n+impl ast_node for @ast::Expr {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> Span { self.span }\n }\n \n-impl ast_node for @ast::pat {\n+impl ast_node for @ast::Pat {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> Span { self.span }\n }\n@@ -293,10 +293,10 @@ impl ToStr for MutabilityCategory {\n }\n \n impl MutabilityCategory {\n-    pub fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n+    pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n         match m {\n-            m_imm => McImmutable,\n-            m_mutbl => McDeclared\n+            MutImmutable => McImmutable,\n+            MutMutable => McDeclared\n         }\n     }\n \n@@ -331,15 +331,15 @@ impl MutabilityCategory {\n }\n \n impl mem_categorization_ctxt {\n-    pub fn expr_ty(&self, expr: @ast::expr) -> ty::t {\n+    pub fn expr_ty(&self, expr: @ast::Expr) -> ty::t {\n         ty::expr_ty(self.tcx, expr)\n     }\n \n-    pub fn pat_ty(&self, pat: @ast::pat) -> ty::t {\n+    pub fn pat_ty(&self, pat: @ast::Pat) -> ty::t {\n         ty::node_id_to_type(self.tcx, pat.id)\n     }\n \n-    pub fn cat_expr(&self, expr: @ast::expr) -> cmt {\n+    pub fn cat_expr(&self, expr: @ast::Expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -373,7 +373,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&self, expr: @ast::expr, autoderefs: uint)\n+    pub fn cat_expr_autoderefd(&self, expr: @ast::Expr, autoderefs: uint)\n                                -> cmt {\n         let mut cmt = self.cat_expr_unadjusted(expr);\n         for deref in range(1u, autoderefs + 1) {\n@@ -382,13 +382,13 @@ impl mem_categorization_ctxt {\n         return cmt;\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> cmt {\n         debug!(\"cat_expr: id=%d expr=%s\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n         let expr_ty = self.expr_ty(expr);\n         match expr.node {\n-          ast::expr_unary(_, ast::deref, e_base) => {\n+          ast::ExprUnary(_, ast::UnDeref, e_base) => {\n             if self.method_map.contains_key(&expr.id) {\n                 return self.cat_rvalue_node(expr, expr_ty);\n             }\n@@ -397,7 +397,7 @@ impl mem_categorization_ctxt {\n             self.cat_deref(expr, base_cmt, 0)\n           }\n \n-          ast::expr_field(base, f_name, _) => {\n+          ast::ExprField(base, f_name, _) => {\n             // Method calls are now a special syntactic form,\n             // so `a.b` should always be a field.\n             assert!(!self.method_map.contains_key(&expr.id));\n@@ -406,7 +406,7 @@ impl mem_categorization_ctxt {\n             self.cat_field(expr, base_cmt, f_name, self.expr_ty(expr))\n           }\n \n-          ast::expr_index(_, base, _) => {\n+          ast::ExprIndex(_, base, _) => {\n             if self.method_map.contains_key(&expr.id) {\n                 return self.cat_rvalue_node(expr, expr_ty);\n             }\n@@ -415,45 +415,45 @@ impl mem_categorization_ctxt {\n             self.cat_index(expr, base_cmt, 0)\n           }\n \n-          ast::expr_path(_) | ast::expr_self => {\n+          ast::ExprPath(_) | ast::ExprSelf => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          ast::expr_paren(e) => self.cat_expr_unadjusted(e),\n-\n-          ast::expr_addr_of(*) | ast::expr_call(*) |\n-          ast::expr_assign(*) | ast::expr_assign_op(*) |\n-          ast::expr_fn_block(*) | ast::expr_ret(*) |\n-          ast::expr_do_body(*) | ast::expr_unary(*) |\n-          ast::expr_method_call(*) | ast::expr_cast(*) | ast::expr_vstore(*) |\n-          ast::expr_vec(*) | ast::expr_tup(*) | ast::expr_if(*) |\n-          ast::expr_log(*) | ast::expr_binary(*) | ast::expr_while(*) |\n-          ast::expr_block(*) | ast::expr_loop(*) | ast::expr_match(*) |\n-          ast::expr_lit(*) | ast::expr_break(*) | ast::expr_mac(*) |\n-          ast::expr_again(*) | ast::expr_struct(*) | ast::expr_repeat(*) |\n-          ast::expr_inline_asm(*) => {\n+          ast::ExprParen(e) => self.cat_expr_unadjusted(e),\n+\n+          ast::ExprAddrOf(*) | ast::ExprCall(*) |\n+          ast::ExprAssign(*) | ast::ExprAssignOp(*) |\n+          ast::ExprFnBlock(*) | ast::ExprRet(*) |\n+          ast::ExprDoBody(*) | ast::ExprUnary(*) |\n+          ast::ExprMethodCall(*) | ast::ExprCast(*) | ast::ExprVstore(*) |\n+          ast::ExprVec(*) | ast::ExprTup(*) | ast::ExprIf(*) |\n+          ast::ExprLog(*) | ast::ExprBinary(*) | ast::ExprWhile(*) |\n+          ast::ExprBlock(*) | ast::ExprLoop(*) | ast::ExprMatch(*) |\n+          ast::ExprLit(*) | ast::ExprBreak(*) | ast::ExprMac(*) |\n+          ast::ExprAgain(*) | ast::ExprStruct(*) | ast::ExprRepeat(*) |\n+          ast::ExprInlineAsm(*) => {\n             return self.cat_rvalue_node(expr, expr_ty);\n           }\n \n-          ast::expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\")\n+          ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n     pub fn cat_def(&self,\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n-                   def: ast::def)\n+                   def: ast::Def)\n                    -> cmt {\n         match def {\n-          ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n-          ast::def_foreign_mod(_) | ast::def_static(_, false) |\n-          ast::def_use(_) | ast::def_variant(*) |\n-          ast::def_trait(_) | ast::def_ty(_) | ast::def_prim_ty(_) |\n-          ast::def_ty_param(*) | ast::def_struct(*) |\n-          ast::def_typaram_binder(*) | ast::def_region(_) |\n-          ast::def_label(_) | ast::def_self_ty(*) | ast::def_method(*) => {\n+          ast::DefFn(*) | ast::DefStaticMethod(*) | ast::DefMod(_) |\n+          ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n+          ast::DefUse(_) | ast::DefVariant(*) |\n+          ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n+          ast::DefTyParam(*) | ast::DefStruct(*) |\n+          ast::DefTyParamBinder(*) | ast::DefRegion(_) |\n+          ast::DefLabel(_) | ast::DefSelfTy(*) | ast::DefMethod(*) => {\n               @cmt_ {\n                   id:id,\n                   span:span,\n@@ -463,7 +463,7 @@ impl mem_categorization_ctxt {\n               }\n           }\n \n-          ast::def_static(_, true) => {\n+          ast::DefStatic(_, true) => {\n               @cmt_ {\n                   id:id,\n                   span:span,\n@@ -473,7 +473,7 @@ impl mem_categorization_ctxt {\n               }\n           }\n \n-          ast::def_arg(vid, mutbl) => {\n+          ast::DefArg(vid, mutbl) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n@@ -488,7 +488,7 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::def_self(self_id) => {\n+          ast::DefSelf(self_id) => {\n             @cmt_ {\n                 id:id,\n                 span:span,\n@@ -498,7 +498,7 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::def_upvar(upvar_id, inner, fn_node_id, _) => {\n+          ast::DefUpvar(upvar_id, inner, fn_node_id, _) => {\n               let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n@@ -549,7 +549,7 @@ impl mem_categorization_ctxt {\n               }\n           }\n \n-          ast::def_local(vid, mutbl) => {\n+          ast::DefLocal(vid, mutbl) => {\n             let m = if mutbl {McDeclared} else {McImmutable};\n             @cmt_ {\n                 id:id,\n@@ -560,7 +560,7 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::def_binding(vid, _) => {\n+          ast::DefBinding(vid, _) => {\n             // by-value/by-ref bindings are local variables\n             @cmt_ {\n                 id:id,\n@@ -602,11 +602,11 @@ impl mem_categorization_ctxt {\n     /// or if the container is mutable.\n     pub fn inherited_mutability(&self,\n                                 base_m: MutabilityCategory,\n-                                interior_m: ast::mutability)\n+                                interior_m: ast::Mutability)\n                                 -> MutabilityCategory {\n         match interior_m {\n-            m_imm => base_m.inherit(),\n-            m_mutbl => McDeclared\n+            MutImmutable => base_m.inherit(),\n+            MutMutable => McDeclared\n         }\n     }\n \n@@ -824,8 +824,8 @@ impl mem_categorization_ctxt {\n \n     pub fn cat_pattern(&self,\n                        cmt: cmt,\n-                       pat: @ast::pat,\n-                       op: &fn(cmt, @ast::pat)) {\n+                       pat: @ast::Pat,\n+                       op: &fn(cmt, @ast::Pat)) {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -879,16 +879,16 @@ impl mem_categorization_ctxt {\n         op(cmt, pat);\n \n         match pat.node {\n-          ast::pat_wild => {\n+          ast::PatWild => {\n             // _\n           }\n \n-          ast::pat_enum(_, None) => {\n+          ast::PatEnum(_, None) => {\n             // variant(*)\n           }\n-          ast::pat_enum(_, Some(ref subpats)) => {\n+          ast::PatEnum(_, Some(ref subpats)) => {\n             match self.tcx.def_map.find(&pat.id) {\n-                Some(&ast::def_variant(enum_did, _)) => {\n+                Some(&ast::DefVariant(enum_did, _)) => {\n                     // variant(x, y, z)\n \n                     let downcast_cmt = {\n@@ -910,8 +910,8 @@ impl mem_categorization_ctxt {\n                         self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n-                Some(&ast::def_fn(*)) |\n-                Some(&ast::def_struct(*)) => {\n+                Some(&ast::DefFn(*)) |\n+                Some(&ast::DefStruct(*)) => {\n                     for (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n                         let cmt_field =\n@@ -921,7 +921,7 @@ impl mem_categorization_ctxt {\n                         self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n                     }\n                 }\n-                Some(&ast::def_static(*)) => {\n+                Some(&ast::DefStatic(*)) => {\n                     for &subpat in subpats.iter() {\n                         self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n@@ -934,15 +934,15 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::pat_ident(_, _, Some(subpat)) => {\n+          ast::PatIdent(_, _, Some(subpat)) => {\n               self.cat_pattern(cmt, subpat, op);\n           }\n \n-          ast::pat_ident(_, _, None) => {\n+          ast::PatIdent(_, _, None) => {\n               // nullary variant or identifier: ignore\n           }\n \n-          ast::pat_struct(_, ref field_pats, _) => {\n+          ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n@@ -951,7 +951,7 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::pat_tup(ref subpats) => {\n+          ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, &subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = self.pat_ty(subpat); // see (*)\n@@ -963,14 +963,14 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::pat_box(subpat) | ast::pat_uniq(subpat) |\n-          ast::pat_region(subpat) => {\n+          ast::PatBox(subpat) | ast::PatUniq(subpat) |\n+          ast::PatRegion(subpat) => {\n             // @p1, ~p1\n             let subcmt = self.cat_deref(pat, cmt, 0);\n             self.cat_pattern(subcmt, subpat, op);\n           }\n \n-          ast::pat_vec(ref before, slice, ref after) => {\n+          ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for &before_pat in before.iter() {\n                   self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n@@ -985,16 +985,16 @@ impl mem_categorization_ctxt {\n               }\n           }\n \n-          ast::pat_lit(_) | ast::pat_range(_, _) => {\n+          ast::PatLit(_) | ast::PatRange(_, _) => {\n               /*always ok*/\n           }\n         }\n     }\n \n-    pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n+    pub fn mut_to_str(&self, mutbl: ast::Mutability) -> ~str {\n         match mutbl {\n-          m_mutbl => ~\"mutable\",\n-          m_imm => ~\"immutable\"\n+          MutMutable => ~\"mutable\",\n+          MutImmutable => ~\"immutable\"\n         }\n     }\n \n@@ -1060,24 +1060,24 @@ pub fn field_mutbl(tcx: ty::ctxt,\n                    base_ty: ty::t,\n                    f_name: ast::Ident,\n                    node_id: ast::NodeId)\n-                -> Option<ast::mutability> {\n+                -> Option<ast::Mutability> {\n     // Need to refactor so that struct/enum fields can be treated uniformly.\n     match ty::get(base_ty).sty {\n       ty::ty_struct(did, _) => {\n         let r = ty::lookup_struct_fields(tcx, did);\n         for fld in r.iter() {\n             if fld.ident == f_name {\n-                return Some(ast::m_imm);\n+                return Some(ast::MutImmutable);\n             }\n         }\n       }\n       ty::ty_enum(*) => {\n         match tcx.def_map.get_copy(&node_id) {\n-          ast::def_variant(_, variant_id) => {\n+          ast::DefVariant(_, variant_id) => {\n             let r = ty::lookup_struct_fields(tcx, variant_id);\n             for fld in r.iter() {\n                 if fld.ident == f_name {\n-                    return Some(ast::m_imm);\n+                    return Some(ast::MutImmutable);\n                 }\n             }\n           }\n@@ -1091,8 +1091,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n }\n \n pub enum AliasableReason {\n-    AliasableManaged(ast::mutability),\n-    AliasableBorrowed(ast::mutability),\n+    AliasableManaged(ast::Mutability),\n+    AliasableBorrowed(ast::Mutability),\n     AliasableOther\n }\n \n@@ -1145,7 +1145,7 @@ impl cmt_ {\n             cat_arg(_) |\n             cat_self(*) |\n             cat_deref(_, _, unsafe_ptr(*)) | // of course it is aliasable, but...\n-            cat_deref(_, _, region_ptr(m_mutbl, _)) => {\n+            cat_deref(_, _, region_ptr(MutMutable, _)) => {\n                 None\n             }\n \n@@ -1158,7 +1158,7 @@ impl cmt_ {\n                 Some(AliasableManaged(m))\n             }\n \n-            cat_deref(_, _, region_ptr(m @ m_imm, _)) => {\n+            cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n                 Some(AliasableBorrowed(m))\n             }\n "}, {"sha": "ba05ab1f3c3cdca30c42bc7453683cbf6a56454a", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -152,7 +152,7 @@ pub enum CaptureMode {\n \n #[deriving(Encodable, Decodable)]\n pub struct CaptureVar {\n-    def: def,         // Variable being accessed free\n+    def: Def,         // Variable being accessed free\n     span: Span,       // Location of an access to this variable\n     mode: CaptureMode // How variable is being accessed\n }\n@@ -197,7 +197,7 @@ impl visit::Visitor<VisitContext> for ComputeModesVisitor {\n                 b:&Block, s:Span, n:NodeId, e:VisitContext) {\n         compute_modes_for_fn(*self, fk, fd, b, s, n, e);\n     }\n-    fn visit_expr(&mut self, ex:@expr, e:VisitContext) {\n+    fn visit_expr(&mut self, ex:@Expr, e:VisitContext) {\n         compute_modes_for_expr(*self, ex, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:VisitContext) {\n@@ -223,12 +223,12 @@ pub fn compute_moves(tcx: ty::ctxt,\n     return visit_cx.move_maps;\n }\n \n-pub fn moved_variable_node_id_from_def(def: def) -> Option<NodeId> {\n+pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n     match def {\n-      def_binding(nid, _) |\n-      def_arg(nid, _) |\n-      def_local(nid, _) |\n-      def_self(nid) => Some(nid),\n+      DefBinding(nid, _) |\n+      DefArg(nid, _) |\n+      DefLocal(nid, _) |\n+      DefSelf(nid) => Some(nid),\n \n       _ => None\n     }\n@@ -261,20 +261,20 @@ fn compute_modes_for_fn(v: ComputeModesVisitor,\n }\n \n fn compute_modes_for_expr(v: ComputeModesVisitor,\n-                          expr: @expr,\n+                          expr: @Expr,\n                           cx: VisitContext)\n {\n     cx.consume_expr(expr, v);\n }\n \n impl VisitContext {\n-    pub fn consume_exprs(&self, exprs: &[@expr], visitor: ComputeModesVisitor) {\n+    pub fn consume_exprs(&self, exprs: &[@Expr], visitor: ComputeModesVisitor) {\n         for expr in exprs.iter() {\n             self.consume_expr(*expr, visitor);\n         }\n     }\n \n-    pub fn consume_expr(&self, expr: @expr, visitor: ComputeModesVisitor) {\n+    pub fn consume_expr(&self, expr: @Expr, visitor: ComputeModesVisitor) {\n         /*!\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -311,7 +311,7 @@ impl VisitContext {\n     }\n \n     pub fn use_expr(&self,\n-                    expr: @expr,\n+                    expr: @Expr,\n                     expr_mode: UseMode,\n                     visitor: ComputeModesVisitor) {\n         /*!\n@@ -336,7 +336,7 @@ impl VisitContext {\n         debug!(\"comp_mode = %?\", comp_mode);\n \n         match expr.node {\n-            expr_path(*) | expr_self => {\n+            ExprPath(*) | ExprSelf => {\n                 match comp_mode {\n                     Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n@@ -349,7 +349,7 @@ impl VisitContext {\n                 }\n             }\n \n-            expr_unary(_, deref, base) => {       // *base\n+            ExprUnary(_, UnDeref, base) => {       // *base\n                 if !self.use_overloaded_operator(\n                     expr, base, [], visitor)\n                 {\n@@ -358,12 +358,12 @@ impl VisitContext {\n                 }\n             }\n \n-            expr_field(base, _, _) => {        // base.f\n+            ExprField(base, _, _) => {        // base.f\n                 // Moving out of base.f moves out of base.\n                 self.use_expr(base, comp_mode, visitor);\n             }\n \n-            expr_index(_, lhs, rhs) => {          // lhs[rhs]\n+            ExprIndex(_, lhs, rhs) => {          // lhs[rhs]\n                 if !self.use_overloaded_operator(\n                     expr, lhs, [rhs], visitor)\n                 {\n@@ -372,7 +372,7 @@ impl VisitContext {\n                 }\n             }\n \n-            expr_call(callee, ref args, _) => {    // callee(args)\n+            ExprCall(callee, ref args, _) => {    // callee(args)\n                 // Figure out whether the called function is consumed.\n                 let mode = match ty::get(ty::expr_ty(self.tcx, callee)).sty {\n                     ty::ty_closure(ref cty) => {\n@@ -397,14 +397,14 @@ impl VisitContext {\n                 self.use_fn_args(callee.id, *args, visitor);\n             }\n \n-            expr_method_call(callee_id, rcvr, _, _, ref args, _) => { // callee.m(args)\n+            ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => { // callee.m(args)\n                 // Implicit self is equivalent to & mode, but every\n                 // other kind should be + mode.\n                 self.use_receiver(rcvr, visitor);\n                 self.use_fn_args(callee_id, *args, visitor);\n             }\n \n-            expr_struct(_, ref fields, opt_with) => {\n+            ExprStruct(_, ref fields, opt_with) => {\n                 for field in fields.iter() {\n                     self.consume_expr(field.expr, visitor);\n                 }\n@@ -441,19 +441,19 @@ impl VisitContext {\n                 }\n             }\n \n-            expr_tup(ref exprs) => {\n+            ExprTup(ref exprs) => {\n                 self.consume_exprs(*exprs, visitor);\n             }\n \n-            expr_if(cond_expr, ref then_blk, opt_else_expr) => {\n+            ExprIf(cond_expr, ref then_blk, opt_else_expr) => {\n                 self.consume_expr(cond_expr, visitor);\n                 self.consume_block(then_blk, visitor);\n                 for else_expr in opt_else_expr.iter() {\n                     self.consume_expr(*else_expr, visitor);\n                 }\n             }\n \n-            expr_match(discr, ref arms) => {\n+            ExprMatch(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n                 for arm in arms.iter() {\n@@ -466,50 +466,50 @@ impl VisitContext {\n                 self.use_expr(discr, Read, visitor);\n             }\n \n-            expr_paren(base) => {\n+            ExprParen(base) => {\n                 // Note: base is not considered a *component* here, so\n                 // use `expr_mode` not `comp_mode`.\n                 self.use_expr(base, expr_mode, visitor);\n             }\n \n-            expr_vec(ref exprs, _) => {\n+            ExprVec(ref exprs, _) => {\n                 self.consume_exprs(*exprs, visitor);\n             }\n \n-            expr_addr_of(_, base) => {   // &base\n+            ExprAddrOf(_, base) => {   // &base\n                 self.use_expr(base, Read, visitor);\n             }\n \n-            expr_inline_asm(*) |\n-            expr_break(*) |\n-            expr_again(*) |\n-            expr_lit(*) => {}\n+            ExprInlineAsm(*) |\n+            ExprBreak(*) |\n+            ExprAgain(*) |\n+            ExprLit(*) => {}\n \n-            expr_loop(ref blk, _) => {\n+            ExprLoop(ref blk, _) => {\n                 self.consume_block(blk, visitor);\n             }\n \n-            expr_log(a_expr, b_expr) => {\n+            ExprLog(a_expr, b_expr) => {\n                 self.consume_expr(a_expr, visitor);\n                 self.use_expr(b_expr, Read, visitor);\n             }\n \n-            expr_while(cond_expr, ref blk) => {\n+            ExprWhile(cond_expr, ref blk) => {\n                 self.consume_expr(cond_expr, visitor);\n                 self.consume_block(blk, visitor);\n             }\n \n-            expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n-            expr_unary(_, _, lhs) => {\n+            ExprUnary(_, _, lhs) => {\n                 if !self.use_overloaded_operator(\n                     expr, lhs, [], visitor)\n                 {\n                     self.consume_expr(lhs, visitor);\n                 }\n             }\n \n-            expr_binary(_, _, lhs, rhs) => {\n+            ExprBinary(_, _, lhs, rhs) => {\n                 if !self.use_overloaded_operator(\n                     expr, lhs, [rhs], visitor)\n                 {\n@@ -518,26 +518,26 @@ impl VisitContext {\n                 }\n             }\n \n-            expr_block(ref blk) => {\n+            ExprBlock(ref blk) => {\n                 self.consume_block(blk, visitor);\n             }\n \n-            expr_ret(ref opt_expr) => {\n+            ExprRet(ref opt_expr) => {\n                 for expr in opt_expr.iter() {\n                     self.consume_expr(*expr, visitor);\n                 }\n             }\n \n-            expr_assign(lhs, rhs) => {\n+            ExprAssign(lhs, rhs) => {\n                 self.use_expr(lhs, Read, visitor);\n                 self.consume_expr(rhs, visitor);\n             }\n \n-            expr_cast(base, _) => {\n+            ExprCast(base, _) => {\n                 self.consume_expr(base, visitor);\n             }\n \n-            expr_assign_op(_, _, lhs, rhs) => {\n+            ExprAssignOp(_, _, lhs, rhs) => {\n                 // FIXME(#4712) --- Overloaded operators?\n                 //\n                 // if !self.use_overloaded_operator(\n@@ -548,16 +548,16 @@ impl VisitContext {\n                 // }\n             }\n \n-            expr_repeat(base, count, _) => {\n+            ExprRepeat(base, count, _) => {\n                 self.consume_expr(base, visitor);\n                 self.consume_expr(count, visitor);\n             }\n \n-            expr_do_body(base) => {\n+            ExprDoBody(base) => {\n                 self.use_expr(base, comp_mode, visitor);\n             }\n \n-            expr_fn_block(ref decl, ref body) => {\n+            ExprFnBlock(ref decl, ref body) => {\n                 for a in decl.inputs.iter() {\n                     self.use_pat(a.pat);\n                 }\n@@ -566,11 +566,11 @@ impl VisitContext {\n                 self.consume_block(body, visitor);\n             }\n \n-            expr_vstore(base, _) => {\n+            ExprVstore(base, _) => {\n                 self.use_expr(base, comp_mode, visitor);\n             }\n \n-            expr_mac(*) => {\n+            ExprMac(*) => {\n                 self.tcx.sess.span_bug(\n                     expr.span,\n                     \"macro expression remains after expansion\");\n@@ -579,9 +579,9 @@ impl VisitContext {\n     }\n \n     pub fn use_overloaded_operator(&self,\n-                                   expr: &expr,\n-                                   receiver_expr: @expr,\n-                                   arg_exprs: &[@expr],\n+                                   expr: &Expr,\n+                                   receiver_expr: @Expr,\n+                                   arg_exprs: &[@Expr],\n                                    visitor: ComputeModesVisitor)\n                                    -> bool {\n         if !self.method_map.contains_key(&expr.id) {\n@@ -599,7 +599,7 @@ impl VisitContext {\n         return true;\n     }\n \n-    pub fn consume_arm(&self, arm: &arm, visitor: ComputeModesVisitor) {\n+    pub fn consume_arm(&self, arm: &Arm, visitor: ComputeModesVisitor) {\n         for pat in arm.pats.iter() {\n             self.use_pat(*pat);\n         }\n@@ -611,7 +611,7 @@ impl VisitContext {\n         self.consume_block(&arm.body, visitor);\n     }\n \n-    pub fn use_pat(&self, pat: @pat) {\n+    pub fn use_pat(&self, pat: @Pat) {\n         /*!\n          *\n          * Decides whether each binding in a pattern moves the value\n@@ -620,8 +620,8 @@ impl VisitContext {\n \n         do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, path| {\n             let binding_moves = match bm {\n-                bind_by_ref(_) => false,\n-                bind_infer => {\n+                BindByRef(_) => false,\n+                BindInfer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n                     debug!(\"pattern %? %s type is %s\",\n                            id,\n@@ -641,30 +641,30 @@ impl VisitContext {\n     }\n \n     pub fn use_receiver(&self,\n-                        receiver_expr: @expr,\n+                        receiver_expr: @Expr,\n                         visitor: ComputeModesVisitor) {\n         self.use_fn_arg(receiver_expr, visitor);\n     }\n \n     pub fn use_fn_args(&self,\n                        _: NodeId,\n-                       arg_exprs: &[@expr],\n+                       arg_exprs: &[@Expr],\n                        visitor: ComputeModesVisitor) {\n         //! Uses the argument expressions.\n         for arg_expr in arg_exprs.iter() {\n             self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n \n-    pub fn use_fn_arg(&self, arg_expr: @expr, visitor: ComputeModesVisitor) {\n+    pub fn use_fn_arg(&self, arg_expr: @Expr, visitor: ComputeModesVisitor) {\n         //! Uses the argument.\n         self.consume_expr(arg_expr, visitor)\n     }\n \n     pub fn arms_have_by_move_bindings(&self,\n                                       moves_map: MovesMap,\n-                                      arms: &[arm])\n-                                      -> Option<@pat> {\n+                                      arms: &[Arm])\n+                                      -> Option<@Pat> {\n         let mut ret = None;\n         for arm in arms.iter() {\n             for &pat in arm.pats.iter() {"}, {"sha": "acdadacc083e23aaeb09ef725f841d493cfb97a8", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -20,61 +20,61 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n+pub fn pat_id_map(dm: resolve::DefMap, pat: @Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n     map\n }\n \n-pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n-        pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n+        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(*) => {\n             match dm.find(&pat.id) {\n-                Some(&def_variant(*)) | Some(&def_struct(*)) => true,\n+                Some(&DefVariant(*)) | Some(&DefStruct(*)) => true,\n                 _ => false\n             }\n         }\n         _ => false\n     }\n }\n \n-pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n+pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n-        pat_ident(_, _, None) | pat_enum(*) => {\n+        PatIdent(_, _, None) | PatEnum(*) => {\n             match dm.find(&pat.id) {\n-                Some(&def_static(_, false)) => true,\n+                Some(&DefStatic(_, false)) => true,\n                 _ => false\n             }\n         }\n         _ => false\n     }\n }\n \n-pub fn pat_is_binding(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_binding(dm: resolve::DefMap, pat: @Pat) -> bool {\n     match pat.node {\n-        pat_ident(*) => {\n+        PatIdent(*) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n         _ => false\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @Pat) -> bool {\n     match pat.node {\n-        pat_ident(*) => pat_is_binding(dm, pat),\n-        pat_wild => true,\n+        PatIdent(*) => pat_is_binding(dm, pat),\n+        PatWild => true,\n         _ => false\n     }\n }\n \n-pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                    it: &fn(binding_mode, NodeId, Span, &Path)) {\n+pub fn pat_bindings(dm: resolve::DefMap, pat: @Pat,\n+                    it: &fn(BindingMode, NodeId, Span, &Path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n-          pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+          PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n@@ -83,15 +83,15 @@ pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n     };\n }\n \n-pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[NodeId] {\n+pub fn pat_binding_ids(dm: resolve::DefMap, pat: @Pat) -> ~[NodeId] {\n     let mut found = ~[];\n     pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;\n }\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(*)`.\n-pub fn pat_contains_bindings(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_contains_bindings(dm: resolve::DefMap, pat: @Pat) -> bool {\n     let mut contains_bindings = false;\n     do walk_pat(pat) |p| {\n         if pat_is_binding(dm, p) {"}, {"sha": "04fceb3e8e3cd87eb622aa7a4a6cb9ae0e4554dc", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -18,12 +18,12 @@ use middle::typeck::{method_map, method_origin, method_param};\n use middle::typeck::{method_static, method_object};\n \n use std::util::ignore;\n-use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n-use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n-use syntax::ast::{expr_struct, expr_unary, Ident, inherited, item_enum};\n+use syntax::ast::{DeclItem, Def, DefFn, DefId, DefStaticMethod};\n+use syntax::ast::{DefVariant, ExprField, ExprMethodCall, ExprPath};\n+use syntax::ast::{ExprStruct, ExprUnary, Ident, inherited, item_enum};\n use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n-use syntax::ast::{item_trait, LOCAL_CRATE, NodeId, pat_struct, Path};\n-use syntax::ast::{private, provided, public, required, stmt_decl, visibility};\n+use syntax::ast::{item_trait, LOCAL_CRATE, NodeId, PatStruct, Path};\n+use syntax::ast::{private, provided, public, required, StmtDecl, visibility};\n use syntax::ast;\n use syntax::ast_map::{node_foreign_item, node_item, node_method};\n use syntax::ast_map::{node_trait_method};\n@@ -35,7 +35,7 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ast::{_mod,expr,item,Block,pat};\n+use syntax::ast::{_mod,Expr,item,Block,Pat};\n \n struct PrivacyVisitor {\n     tcx: ty::ctxt,\n@@ -79,7 +79,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that an enum variant is in scope\n-    fn check_variant(&mut self, span: Span, enum_id: ast::def_id) {\n+    fn check_variant(&mut self, span: Span, enum_id: ast::DefId) {\n         let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n         let parental_privacy = if is_local(enum_id) {\n             let parent_vis = ast_map::node_item_query(self.tcx.items,\n@@ -109,7 +109,7 @@ impl PrivacyVisitor {\n \n     // Returns true if a crate-local method is private and false otherwise.\n     fn method_is_private(&mut self, span: Span, method_id: NodeId) -> bool {\n-        let check = |vis: visibility, container_id: def_id| {\n+        let check = |vis: visibility, container_id: DefId| {\n             let mut is_private = false;\n             if vis == private {\n                 is_private = true;\n@@ -203,7 +203,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private field is in scope.\n-    fn check_field(&mut self, span: Span, id: ast::def_id, ident: ast::Ident) {\n+    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.ident != ident { loop; }\n@@ -216,7 +216,7 @@ impl PrivacyVisitor {\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_method_common(&mut self, span: Span, method_id: def_id, name: &Ident) {\n+    fn check_method_common(&mut self, span: Span, method_id: DefId, name: &Ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n@@ -245,16 +245,16 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private path is in scope.\n-    fn check_path(&mut self, span: Span, def: def, path: &Path) {\n+    fn check_path(&mut self, span: Span, def: Def, path: &Path) {\n         debug!(\"checking path\");\n         match def {\n-            def_static_method(method_id, _, _) => {\n+            DefStaticMethod(method_id, _, _) => {\n                 debug!(\"found static method def, checking it\");\n                 self.check_method_common(span,\n                                          method_id,\n                                          &path.segments.last().identifier)\n             }\n-            def_fn(def_id, _) => {\n+            DefFn(def_id, _) => {\n                 if def_id.crate == LOCAL_CRATE {\n                     if self.local_item_is_private(span, def_id.node) &&\n                             !self.privileged_items.iter().any(|x| x == &def_id.node) {\n@@ -371,9 +371,9 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n             let mut n_added = 0;\n             for stmt in block.stmts.iter() {\n                 match stmt.node {\n-                    stmt_decl(decl, _) => {\n+                    StmtDecl(decl, _) => {\n                         match decl.node {\n-                            decl_item(item) => {\n+                            DeclItem(item) => {\n                                 self.add_privileged_item(item, &mut n_added);\n                             }\n                             _ => {}\n@@ -391,10 +391,10 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n \n     }\n \n-    fn visit_expr<'mm>(&mut self, expr:@expr, method_map:&'mm method_map) {\n+    fn visit_expr<'mm>(&mut self, expr:@Expr, method_map:&'mm method_map) {\n \n             match expr.node {\n-                expr_field(base, ident, _) => {\n+                ExprField(base, ident, _) => {\n                     // Method calls are now a special syntactic form,\n                     // so `a.b` should always be a field.\n                     assert!(!method_map.contains_key(&expr.id));\n@@ -412,7 +412,7 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                         _ => {}\n                     }\n                 }\n-                expr_method_call(_, base, ident, _, _, _) => {\n+                ExprMethodCall(_, base, ident, _, _, _) => {\n                     // Ditto\n                     match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n                                                           base))).sty {\n@@ -436,10 +436,10 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                         _ => {}\n                     }\n                 }\n-                expr_path(ref path) => {\n+                ExprPath(ref path) => {\n                     self.check_path(expr.span, self.tcx.def_map.get_copy(&expr.id), path);\n                 }\n-                expr_struct(_, ref fields, _) => {\n+                ExprStruct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n@@ -455,7 +455,7 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                             if id.crate != LOCAL_CRATE ||\n                                     !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 match self.tcx.def_map.get_copy(&expr.id) {\n-                                    def_variant(_, variant_id) => {\n+                                    DefVariant(_, variant_id) => {\n                                         for field in (*fields).iter() {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n@@ -481,7 +481,7 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                         }\n                     }\n                 }\n-                expr_unary(_, ast::deref, operand) => {\n+                ExprUnary(_, ast::UnDeref, operand) => {\n                     // In *e, we need to check that if e's type is an\n                     // enum type t, then t's first variant is public or\n                     // privileged. (We can assume it has only one variant\n@@ -503,10 +503,10 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n \n     }\n \n-    fn visit_pat<'mm>(&mut self, pattern:@pat, method_map:&'mm method_map) {\n+    fn visit_pat<'mm>(&mut self, pattern:@Pat, method_map:&'mm method_map) {\n \n             match pattern.node {\n-                pat_struct(_, ref fields, _) => {\n+                PatStruct(_, ref fields, _) => {\n                     match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n@@ -522,7 +522,7 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                             if enum_id.crate != LOCAL_CRATE ||\n                                     !self.privileged_items.iter().any(|x| x == &enum_id.node) {\n                                 match self.tcx.def_map.find(&pattern.id) {\n-                                    Some(&def_variant(_, variant_id)) => {\n+                                    Some(&DefVariant(_, variant_id)) => {\n                                         for field in fields.iter() {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\"}, {"sha": "07ec4bc27fb41900173e36eb35592d1e4562b84d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -205,10 +205,10 @@ struct MarkSymbolVisitor {\n \n impl Visitor<()> for MarkSymbolVisitor {\n \n-    fn visit_expr(&mut self, expr:@expr, _:()) {\n+    fn visit_expr(&mut self, expr:@Expr, _:()) {\n \n                 match expr.node {\n-                    expr_path(_) => {\n+                    ExprPath(_) => {\n                         let def = match self.tcx.def_map.find(&expr.id) {\n                             Some(&def) => def,\n                             None => {\n@@ -225,7 +225,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n                         }\n                         self.reachable_symbols.insert(def_id.node);\n                     }\n-                    expr_method_call(*) => {\n+                    ExprMethodCall(*) => {\n                         match self.method_map.find(&expr.id) {\n                             Some(&typeck::method_map_entry {\n                                 origin: typeck::method_static(def_id),\n@@ -283,7 +283,7 @@ impl ReachableContext {\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: def_id)\n+    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: DefId)\n                                             -> bool {\n         if def_id.crate != LOCAL_CRATE {\n             return false"}, {"sha": "c4e20137271d383b567e62d8226f58d83a7aa02e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{Block,item,fn_decl,NodeId,arm,pat,stmt,expr,Local};\n+use syntax::ast::{Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n use syntax::ast::{Ty,TypeMethod,struct_field};\n \n /**\n@@ -340,46 +340,46 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_arm(visitor: &mut RegionResolutionVisitor,\n-               arm: &ast::arm,\n+               arm: &ast::Arm,\n                cx: Context) {\n     visit::walk_arm(visitor, arm, cx);\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n-               pat: @ast::pat,\n+               pat: @ast::Pat,\n                cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id, pat.span);\n     visit::walk_pat(visitor, pat, cx);\n }\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n-                stmt: @ast::stmt,\n+                stmt: @ast::Stmt,\n                 cx: Context) {\n     match stmt.node {\n-        ast::stmt_decl(*) => {\n+        ast::StmtDecl(*) => {\n             visit::walk_stmt(visitor, stmt, cx);\n         }\n-        ast::stmt_expr(_, stmt_id) |\n-        ast::stmt_semi(_, stmt_id) => {\n+        ast::StmtExpr(_, stmt_id) |\n+        ast::StmtSemi(_, stmt_id) => {\n             parent_to_expr(cx, stmt_id, stmt.span);\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n             visit::walk_stmt(visitor, stmt, expr_cx);\n         }\n-        ast::stmt_mac(*) => cx.sess.bug(\"unexpanded macro\")\n+        ast::StmtMac(*) => cx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n-                expr: @ast::expr,\n+                expr: @ast::Expr,\n                 cx: Context) {\n     parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n     new_cx.parent = Some(expr.id);\n     match expr.node {\n-        ast::expr_assign_op(*) | ast::expr_index(*) | ast::expr_binary(*) |\n-        ast::expr_unary(*) | ast::expr_call(*) | ast::expr_method_call(*) => {\n+        ast::ExprAssignOp(*) | ast::ExprIndex(*) | ast::ExprBinary(*) |\n+        ast::ExprUnary(*) | ast::ExprCall(*) | ast::ExprMethodCall(*) => {\n             // FIXME(#6268) Nested method calls\n             //\n             // The lifetimes for a call or method call look as follows:\n@@ -400,7 +400,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n             // parent_to_expr(new_cx, expr.callee_id);\n         }\n \n-        ast::expr_match(*) => {\n+        ast::ExprMatch(*) => {\n             new_cx.var_parent = Some(expr.id);\n         }\n \n@@ -485,16 +485,16 @@ impl Visitor<Context> for RegionResolutionVisitor {\n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, cx:Context) {\n         resolve_fn(self, fk, fd, b, s, n, cx);\n     }\n-    fn visit_arm(&mut self, a:&arm, cx:Context) {\n+    fn visit_arm(&mut self, a:&Arm, cx:Context) {\n         resolve_arm(self, a, cx);\n     }\n-    fn visit_pat(&mut self, p:@pat, cx:Context) {\n+    fn visit_pat(&mut self, p:@Pat, cx:Context) {\n         resolve_pat(self, p, cx);\n     }\n-    fn visit_stmt(&mut self, s:@stmt, cx:Context) {\n+    fn visit_stmt(&mut self, s:@Stmt, cx:Context) {\n         resolve_stmt(self, s, cx);\n     }\n-    fn visit_expr(&mut self, ex:@expr, cx:Context) {\n+    fn visit_expr(&mut self, ex:@Expr, cx:Context) {\n         resolve_expr(self, ex, cx);\n     }\n     fn visit_local(&mut self, l:@Local, cx:Context) {\n@@ -823,9 +823,9 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n     match ty.node {\n       ast::ty_path(ref path, _, id) => {\n         match cx.def_map.find(&id) {\n-          Some(&ast::def_ty(did)) |\n-          Some(&ast::def_trait(did)) |\n-          Some(&ast::def_struct(did)) => {\n+          Some(&ast::DefTy(did)) |\n+          Some(&ast::DefTrait(did)) |\n+          Some(&ast::DefStruct(did)) => {\n             if did.crate == ast::LOCAL_CRATE {\n                 if cx.region_is_relevant(&path.segments.last().lifetime) {\n                     cx.add_dep(did.node);\n@@ -890,7 +890,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n                 mt: &ast::mt,\n                 cx: @mut DetermineRpCtxt) {\n         // mutability is invariant\n-        if mt.mutbl == ast::m_mutbl {\n+        if mt.mutbl == ast::MutMutable {\n             do cx.with_ambient_variance(rv_invariant) {\n                 visitor.visit_ty(mt.ty, cx);\n             }"}, {"sha": "ddf358841f76c9b67aa27c50a306806990b2c957", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 161, "deletions": 157, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -43,18 +43,18 @@ use std::hashmap::{HashMap, HashSet};\n use std::util;\n \n // Definition mapping\n-pub type DefMap = @mut HashMap<NodeId,def>;\n+pub type DefMap = @mut HashMap<NodeId,Def>;\n \n pub struct binding_info {\n     span: Span,\n-    binding_mode: binding_mode,\n+    binding_mode: BindingMode,\n }\n \n // Map from the name in a pattern to its binding mode.\n pub type BindingMap = HashMap<Ident,binding_info>;\n \n // Trait method resolution\n-pub type TraitMap = HashMap<NodeId,@mut ~[def_id]>;\n+pub type TraitMap = HashMap<NodeId,@mut ~[DefId]>;\n \n // A summary of the generics on a trait.\n struct TraitGenerics {\n@@ -68,7 +68,7 @@ pub type ExportMap2 = @mut HashMap<NodeId, ~[Export2]>;\n \n pub struct Export2 {\n     name: @str,        // The name of the target.\n-    def_id: def_id,     // The definition of the target.\n+    def_id: DefId,     // The definition of the target.\n     reexport: bool,     // Whether this is a reexport.\n }\n \n@@ -120,8 +120,8 @@ impl NamespaceResult {\n \n pub enum NameDefinition {\n     NoNameDefinition,           //< The name was unbound.\n-    ChildNameDefinition(def),   //< The name identifies an immediate child.\n-    ImportNameDefinition(def)   //< The name identifies an import.\n+    ChildNameDefinition(Def),   //< The name identifies an immediate child.\n+    ImportNameDefinition(Def)   //< The name identifies an import.\n }\n \n #[deriving(Eq)]\n@@ -143,13 +143,13 @@ impl Visitor<()> for ResolveVisitor {\n     fn visit_item(&mut self, item:@item, _:()) {\n         self.resolver.resolve_item(item, self);\n     }\n-    fn visit_arm(&mut self, arm:&arm, _:()) {\n+    fn visit_arm(&mut self, arm:&Arm, _:()) {\n         self.resolver.resolve_arm(arm, self);\n     }\n     fn visit_block(&mut self, block:&Block, _:()) {\n         self.resolver.resolve_block(block, self);\n     }\n-    fn visit_expr(&mut self, expr:@expr, _:()) {\n+    fn visit_expr(&mut self, expr:@Expr, _:()) {\n         self.resolver.resolve_expr(expr, self);\n     }\n     fn visit_local(&mut self, local:@Local, _:()) {\n@@ -293,8 +293,8 @@ enum NameSearchType {\n }\n \n pub enum BareIdentifierPatternResolution {\n-    FoundStructOrEnumVariant(def),\n-    FoundConst(def),\n+    FoundStructOrEnumVariant(Def),\n+    FoundConst(Def),\n     BareIdentifierPatternUnresolved\n }\n \n@@ -442,7 +442,7 @@ pub enum ModuleKind {\n /// One node in the tree of modules.\n pub struct Module {\n     parent_link: ParentLink,\n-    def_id: Option<def_id>,\n+    def_id: Option<DefId>,\n     kind: ModuleKind,\n \n     children: @mut HashMap<Ident, @mut NameBindings>,\n@@ -485,7 +485,7 @@ pub struct Module {\n \n impl Module {\n     pub fn new(parent_link: ParentLink,\n-                def_id: Option<def_id>,\n+                def_id: Option<DefId>,\n                 kind: ModuleKind,\n                 external: bool)\n                 -> Module {\n@@ -514,14 +514,14 @@ impl Module {\n pub struct TypeNsDef {\n     privacy: Privacy,\n     module_def: Option<@mut Module>,\n-    type_def: Option<def>,\n+    type_def: Option<Def>,\n     type_span: Option<Span>\n }\n \n // Records a possibly-private value definition.\n pub struct ValueNsDef {\n     privacy: Privacy,\n-    def: def,\n+    def: Def,\n     value_span: Option<Span>,\n }\n \n@@ -544,7 +544,7 @@ impl NameBindings {\n     pub fn define_module(@mut self,\n                          privacy: Privacy,\n                          parent_link: ParentLink,\n-                         def_id: Option<def_id>,\n+                         def_id: Option<DefId>,\n                          kind: ModuleKind,\n                          external: bool,\n                          sp: Span) {\n@@ -574,7 +574,7 @@ impl NameBindings {\n     pub fn set_module_kind(@mut self,\n                            privacy: Privacy,\n                            parent_link: ParentLink,\n-                           def_id: Option<def_id>,\n+                           def_id: Option<DefId>,\n                            kind: ModuleKind,\n                            external: bool,\n                            _sp: Span) {\n@@ -609,7 +609,7 @@ impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    pub fn define_type(@mut self, privacy: Privacy, def: def, sp: Span) {\n+    pub fn define_type(@mut self, privacy: Privacy, def: Def, sp: Span) {\n         // Merges the type with the existing type def or creates a new one.\n         match self.type_def {\n             None => {\n@@ -632,7 +632,7 @@ impl NameBindings {\n     }\n \n     /// Records a value definition.\n-    pub fn define_value(@mut self, privacy: Privacy, def: def, sp: Span) {\n+    pub fn define_value(@mut self, privacy: Privacy, def: Def, sp: Span) {\n         self.value_def = Some(ValueNsDef { privacy: privacy, def: def, value_span: Some(sp) });\n     }\n \n@@ -678,7 +678,7 @@ impl NameBindings {\n         }\n     }\n \n-    pub fn def_for_namespace(&self, namespace: Namespace) -> Option<def> {\n+    pub fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n         match namespace {\n             TypeNS => {\n                 match self.type_def {\n@@ -690,7 +690,7 @@ impl NameBindings {\n                                 match type_def.module_def {\n                                     Some(module) => {\n                                         match module.def_id {\n-                                            Some(did) => Some(def_mod(did)),\n+                                            Some(did) => Some(DefMod(did)),\n                                             None => None,\n                                         }\n                                     }\n@@ -814,7 +814,7 @@ pub fn Resolver(session: Session,\n \n     graph_root.define_module(Public,\n                              NoParentLink,\n-                             Some(def_id { crate: 0, node: 0 }),\n+                             Some(DefId { crate: 0, node: 0 }),\n                              NormalModuleKind,\n                              false,\n                              crate.span);\n@@ -873,8 +873,8 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    method_map: @mut HashMap<Ident, HashSet<def_id>>,\n-    structs: HashSet<def_id>,\n+    method_map: @mut HashMap<Ident, HashSet<DefId>>,\n+    structs: HashSet<DefId>,\n \n     // The number of imports that are currently unresolved.\n     unresolved_imports: uint,\n@@ -897,7 +897,7 @@ pub struct Resolver {\n     xray_context: XrayFlag,\n \n     // The trait that the current context can refer to.\n-    current_trait_refs: Option<~[def_id]>,\n+    current_trait_refs: Option<~[DefId]>,\n \n     // The ident for the keyword \"self\".\n     self_ident: Ident,\n@@ -1071,7 +1071,7 @@ impl Resolver {\n                     }\n                     ForbidDuplicateTypes => {\n                         match child.def_for_namespace(TypeNS) {\n-                            Some(def_mod(_)) | None => {}\n+                            Some(DefMod(_)) | None => {}\n                             Some(_) => duplicate_type = TypeError\n                         }\n                         Some(TypeNS)\n@@ -1085,7 +1085,7 @@ impl Resolver {\n                     ForbidDuplicateTypesAndValues => {\n                         let mut n = None;\n                         match child.def_for_namespace(TypeNS) {\n-                            Some(def_mod(_)) | None => {}\n+                            Some(DefMod(_)) | None => {}\n                             Some(_) => {\n                                 n = Some(TypeNS);\n                                 duplicate_type = TypeError;\n@@ -1131,9 +1131,9 @@ impl Resolver {\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n-                stmt_decl(declaration, _) => {\n+                StmtDecl(declaration, _) => {\n                     match declaration.node {\n-                        decl_item(_) => {\n+                        DeclItem(_) => {\n                             return true;\n                         }\n                         _ => {\n@@ -1177,7 +1177,7 @@ impl Resolver {\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n                 let parent_link = self.get_parent_link(new_parent, ident);\n-                let def_id = def_id { crate: 0, node: item.id };\n+                let def_id = DefId { crate: 0, node: item.id };\n                 name_bindings.define_module(privacy,\n                                             parent_link,\n                                             Some(def_id),\n@@ -1200,7 +1200,7 @@ impl Resolver {\n \n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n-                        let def_id = def_id { crate: 0, node: item.id };\n+                        let def_id = DefId { crate: 0, node: item.id };\n                         name_bindings.define_module(privacy,\n                                                     parent_link,\n                                                     Some(def_id),\n@@ -1223,16 +1223,16 @@ impl Resolver {\n             item_static(_, m, _) => {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateValues, sp);\n-                let mutbl = m == ast::m_mutbl;\n+                let mutbl = m == ast::MutMutable;\n \n                 name_bindings.define_value\n-                    (privacy, def_static(local_def(item.id), mutbl), sp);\n+                    (privacy, DefStatic(local_def(item.id), mutbl), sp);\n             }\n             item_fn(_, purity, _, _, _) => {\n               let (name_bindings, new_parent) =\n                 self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n-                let def = def_fn(local_def(item.id), purity);\n+                let def = DefFn(local_def(item.id), purity);\n                 name_bindings.define_value(privacy, def, sp);\n                 visit::walk_item(visitor, item, new_parent);\n             }\n@@ -1243,15 +1243,15 @@ impl Resolver {\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 name_bindings.define_type\n-                    (privacy, def_ty(local_def(item.id)), sp);\n+                    (privacy, DefTy(local_def(item.id)), sp);\n             }\n \n             item_enum(ref enum_definition, _) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 name_bindings.define_type\n-                    (privacy, def_ty(local_def(item.id)), sp);\n+                    (privacy, DefTy(local_def(item.id)), sp);\n \n                 for variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n@@ -1275,12 +1275,12 @@ impl Resolver {\n                 let (name_bindings, new_parent) = self.add_child(ident, parent, forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(privacy, def_ty(local_def(item.id)), sp);\n+                name_bindings.define_type(privacy, DefTy(local_def(item.id)), sp);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 do ctor_id.while_some |cid| {\n-                    name_bindings.define_value(privacy, def_struct(local_def(cid)), sp);\n+                    name_bindings.define_value(privacy, DefStruct(local_def(cid)), sp);\n                     None\n                 }\n \n@@ -1351,15 +1351,15 @@ impl Resolver {\n                                 sty_static => {\n                                     // Static methods become\n                                     // `def_static_method`s.\n-                                    def_static_method(local_def(method.id),\n+                                    DefStaticMethod(local_def(method.id),\n                                                       FromImpl(local_def(\n                                                         item.id)),\n                                                       method.purity)\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n                                     // `def_method`s.\n-                                    def_method(local_def(method.id), None)\n+                                    DefMethod(local_def(method.id), None)\n                                 }\n                             };\n \n@@ -1404,13 +1404,13 @@ impl Resolver {\n                     let def = match ty_m.explicit_self.node {\n                         sty_static => {\n                             // Static methods become `def_static_method`s.\n-                            def_static_method(local_def(ty_m.id),\n+                            DefStaticMethod(local_def(ty_m.id),\n                                               FromTrait(local_def(item.id)),\n                                               ty_m.purity)\n                         }\n                         _ => {\n                             // Non-static methods become `def_method`s.\n-                            def_method(local_def(ty_m.id),\n+                            DefMethod(local_def(ty_m.id),\n                                        Some(local_def(item.id)))\n                         }\n                     };\n@@ -1442,7 +1442,7 @@ impl Resolver {\n                     }\n                 }\n \n-                name_bindings.define_type(privacy, def_trait(def_id), sp);\n+                name_bindings.define_type(privacy, DefTrait(def_id), sp);\n                 visit::walk_item(visitor, item, new_parent);\n             }\n \n@@ -1456,7 +1456,7 @@ impl Resolver {\n     // type and/or value namespaces.\n     pub fn build_reduced_graph_for_variant(@mut self,\n                                            variant: &variant,\n-                                           item_id: def_id,\n+                                           item_id: DefId,\n                                            parent_privacy: Privacy,\n                                            parent: ReducedGraphParent,\n                                            _: &mut BuildReducedGraphVisitor) {\n@@ -1474,15 +1474,15 @@ impl Resolver {\n                 let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                                 variant.span);\n                 child.define_value(privacy,\n-                                   def_variant(item_id,\n+                                   DefVariant(item_id,\n                                                local_def(variant.node.id)),\n                                    variant.span);\n             }\n             struct_variant_kind(_) => {\n                 let (child, _) = self.add_child(ident, parent, ForbidDuplicateTypesAndValues,\n                                                 variant.span);\n                 child.define_type(privacy,\n-                                  def_variant(item_id,\n+                                  DefVariant(item_id,\n                                               local_def(variant.node.id)),\n                                   variant.span);\n                 self.structs.insert(local_def(variant.node.id));\n@@ -1573,7 +1573,7 @@ impl Resolver {\n                 match find_extern_mod_stmt_cnum(self.session.cstore,\n                                                         node_id) {\n                     Some(crate_id) => {\n-                        let def_id = def_id { crate: crate_id, node: 0 };\n+                        let def_id = DefId { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink\n                             (self.get_module_from_parent(parent), name);\n                         let external_module = @mut Module::new(parent_link,\n@@ -1607,7 +1607,7 @@ impl Resolver {\n \n         match foreign_item.node {\n             foreign_item_fn(_, ref generics) => {\n-                let def = def_fn(local_def(foreign_item.id), unsafe_fn);\n+                let def = DefFn(local_def(foreign_item.id), unsafe_fn);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n                 do self.with_type_parameter_rib(\n@@ -1618,7 +1618,7 @@ impl Resolver {\n                 }\n             }\n             foreign_item_static(_, m) => {\n-                let def = def_static(local_def(foreign_item.id), m);\n+                let def = DefStatic(local_def(foreign_item.id), m);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n                 visit::walk_foreign_item(visitor, foreign_item, new_parent);\n@@ -1655,16 +1655,16 @@ impl Resolver {\n     }\n \n     fn handle_external_def(@mut self,\n-                           def: def,\n+                           def: Def,\n                            visibility: ast::visibility,\n                            child_name_bindings: @mut NameBindings,\n                            final_ident: &str,\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n         match def {\n-          def_mod(def_id) | def_foreign_mod(def_id) | def_struct(def_id) |\n-          def_ty(def_id) => {\n+          DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n+          DefTy(def_id) => {\n             match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n@@ -1690,8 +1690,8 @@ impl Resolver {\n         }\n \n         match def {\n-          def_mod(_) | def_foreign_mod(_) => {}\n-          def_variant(*) => {\n+          DefMod(_) | DefForeignMod(_) => {}\n+          DefVariant(*) => {\n             debug!(\"(building reduced graph for external crate) building \\\n                     variant %s\",\n                    final_ident);\n@@ -1700,12 +1700,12 @@ impl Resolver {\n             let privacy = variant_visibility_to_privacy(visibility, true);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n-          def_fn(*) | def_static_method(*) | def_static(*) => {\n+          DefFn(*) | DefStaticMethod(*) | DefStatic(*) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) %s\", final_ident);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n-          def_trait(def_id) => {\n+          DefTrait(def_id) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type %s\", final_ident);\n \n@@ -1751,13 +1751,13 @@ impl Resolver {\n                                                   true,\n                                                   dummy_sp())\n           }\n-          def_ty(_) => {\n+          DefTy(_) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type %s\", final_ident);\n \n               child_name_bindings.define_type(privacy, def, dummy_sp());\n           }\n-          def_struct(def_id) => {\n+          DefStruct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building type and value for %s\",\n                    final_ident);\n@@ -1767,13 +1767,13 @@ impl Resolver {\n             }\n             self.structs.insert(def_id);\n           }\n-          def_method(*) => {\n+          DefMethod(*) => {\n             // Ignored; handled elsewhere.\n           }\n-          def_self(*) | def_arg(*) | def_local(*) |\n-          def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n-          def_use(*) | def_upvar(*) | def_region(*) |\n-          def_typaram_binder(*) | def_label(*) | def_self_ty(*) => {\n+          DefSelf(*) | DefArg(*) | DefLocal(*) |\n+          DefPrimTy(*) | DefTyParam(*) | DefBinding(*) |\n+          DefUse(*) | DefUpvar(*) | DefRegion(*) |\n+          DefTyParamBinder(*) | DefLabel(*) | DefSelfTy(*) => {\n             fail!(\"didn't expect `%?`\", def);\n           }\n         }\n@@ -1788,7 +1788,7 @@ impl Resolver {\n             DlDef(def) => {\n                 // Add the new child item, if necessary.\n                 match def {\n-                    def_foreign_mod(def_id) => {\n+                    DefForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n                         do csearch::each_child_of_item(self.session.cstore,\n@@ -1889,7 +1889,7 @@ impl Resolver {\n                                                        new_parent,\n                                                        OverwriteDuplicates,\n                                                        dummy_sp());\n-                                    let def = def_fn(\n+                                    let def = DefFn(\n                                         static_method_info.def_id,\n                                         static_method_info.purity);\n                                     method_name_bindings.define_value(\n@@ -3395,16 +3395,16 @@ impl Resolver {\n         let is_ty_param;\n \n         match def_like {\n-            DlDef(d @ def_local(*)) | DlDef(d @ def_upvar(*)) |\n-            DlDef(d @ def_arg(*)) | DlDef(d @ def_binding(*)) => {\n+            DlDef(d @ DefLocal(*)) | DlDef(d @ DefUpvar(*)) |\n+            DlDef(d @ DefArg(*)) | DlDef(d @ DefBinding(*)) => {\n                 def = d;\n                 is_ty_param = false;\n             }\n-            DlDef(d @ def_ty_param(*)) => {\n+            DlDef(d @ DefTyParam(*)) => {\n                 def = d;\n                 is_ty_param = true;\n             }\n-            DlDef(d @ def_self(*))\n+            DlDef(d @ DefSelf(*))\n                     if allow_capturing_self == DontAllowCapturingSelf => {\n                 def = d;\n                 is_ty_param = false;\n@@ -3422,7 +3422,7 @@ impl Resolver {\n                 }\n                 FunctionRibKind(function_id, body_id) => {\n                     if !is_ty_param {\n-                        def = def_upvar(def_id_of_def(def).node,\n+                        def = DefUpvar(def_id_of_def(def).node,\n                                         @def,\n                                         function_id,\n                                         body_id);\n@@ -3432,9 +3432,9 @@ impl Resolver {\n                   // If the def is a ty param, and came from the parent\n                   // item, it's ok\n                   match def {\n-                    def_ty_param(did, _)\n+                    DefTyParam(did, _)\n                         if self.def_map.find(&did.node).map_move(|x| *x)\n-                            == Some(def_typaram_binder(item_id)) => {\n+                            == Some(DefTyParamBinder(item_id)) => {\n                       // ok\n                     }\n                     _ => {\n@@ -3592,7 +3592,7 @@ impl Resolver {\n                 let self_type_rib = @Rib::new(NormalRibKind);\n                 self.type_ribs.push(self_type_rib);\n                 self_type_rib.bindings.insert(self.type_self_ident,\n-                                              DlDef(def_self_ty(item.id)));\n+                                              DlDef(DefSelfTy(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n@@ -3726,13 +3726,13 @@ impl Resolver {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n-                    let def_like = DlDef(def_ty_param\n+                    let def_like = DlDef(DefTyParam\n                         (local_def(type_parameter.id),\n                          index + initial_index));\n                     // Associate this type parameter with\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n-                                    def_typaram_binder(node_id));\n+                                    DefTyParamBinder(node_id));\n                     function_type_rib.bindings.insert(name, def_like);\n                 }\n             }\n@@ -3801,7 +3801,7 @@ impl Resolver {\n                     // Nothing to do.\n                 }\n                 HasSelfBinding(self_node_id) => {\n-                    let def_like = DlDef(def_self(self_node_id));\n+                    let def_like = DlDef(DefSelf(self_node_id));\n                     *function_value_rib.self_binding = Some(def_like);\n                 }\n             }\n@@ -4064,7 +4064,7 @@ impl Resolver {\n                              None, visitor);\n     }\n \n-    pub fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n+    pub fn binding_mode_map(@mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n@@ -4075,7 +4075,7 @@ impl Resolver {\n         return result;\n     }\n \n-    pub fn check_consistent_bindings(@mut self, arm: &arm) {\n+    pub fn check_consistent_bindings(@mut self, arm: &Arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n@@ -4114,7 +4114,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_arm(@mut self, arm: &arm, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_arm(@mut self, arm: &Arm, visitor: &mut ResolveVisitor) {\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n@@ -4178,7 +4178,7 @@ impl Resolver {\n \n                         Some(&primitive_type) => {\n                             result_def =\n-                                Some(def_prim_ty(primitive_type));\n+                                Some(DefPrimTy(primitive_type));\n \n                             if path.segments\n                                    .iter()\n@@ -4267,7 +4267,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_pattern(@mut self,\n-                           pattern: @pat,\n+                           pattern: @Pat,\n                            mode: PatternBindingMode,\n                            mutability: Mutability,\n                            // Maps idents to the node ID for the (outermost)\n@@ -4277,7 +4277,7 @@ impl Resolver {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n-                pat_ident(binding_mode, ref path, _)\n+                PatIdent(binding_mode, ref path, _)\n                         if !path.global && path.segments.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n@@ -4340,15 +4340,15 @@ impl Resolver {\n                                     // For pattern arms, we must use\n                                     // `def_binding` definitions.\n \n-                                    def_binding(pattern.id, binding_mode)\n+                                    DefBinding(pattern.id, binding_mode)\n                                 }\n                                 LocalIrrefutableMode => {\n                                     // But for locals, we use `def_local`.\n-                                    def_local(pattern.id, is_mutable)\n+                                    DefLocal(pattern.id, is_mutable)\n                                 }\n                                 ArgumentIrrefutableMode => {\n                                     // And for function arguments, `def_arg`.\n-                                    def_arg(pattern.id, is_mutable)\n+                                    DefArg(pattern.id, is_mutable)\n                                 }\n                             };\n \n@@ -4406,14 +4406,14 @@ impl Resolver {\n                     }\n                 }\n \n-                pat_ident(binding_mode, ref path, _) => {\n+                PatIdent(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n                     match self.resolve_path(pat_id, path, ValueNS, false, visitor) {\n-                        Some(def @ def_variant(*)) |\n-                                Some(def @ def_struct(*)) => {\n+                        Some(def @ DefVariant(*)) |\n+                                Some(def @ DefStruct(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n-                        Some(def @ def_static(*)) => {\n+                        Some(def @ DefStatic(*)) => {\n                             self.enforce_default_binding_mode(\n                                 pattern,\n                                 binding_mode,\n@@ -4441,13 +4441,13 @@ impl Resolver {\n                     }\n                 }\n \n-                pat_enum(ref path, _) => {\n+                PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     match self.resolve_path(pat_id, path, ValueNS, false, visitor) {\n-                        Some(def @ def_fn(*))      |\n-                        Some(def @ def_variant(*)) |\n-                        Some(def @ def_struct(*))  |\n-                        Some(def @ def_static(*)) => {\n+                        Some(def @ DefFn(*))      |\n+                        Some(def @ DefVariant(*)) |\n+                        Some(def @ DefStruct(*))  |\n+                        Some(def @ DefStatic(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n@@ -4461,8 +4461,12 @@ impl Resolver {\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n-                                                  \"unresolved enum variant, \\\n-                                                   struct or const\");\n+                                               fmt!(\"unresolved enum variant, \\\n+                                                    struct or const `%s`\",\n+                                                    self.session\n+                                                        .str_of(path.segments\n+                                                                    .last()\n+                                                                    .identifier)));\n                         }\n                     }\n \n@@ -4474,27 +4478,27 @@ impl Resolver {\n                     }\n                 }\n \n-                pat_lit(expr) => {\n+                PatLit(expr) => {\n                     self.resolve_expr(expr, visitor);\n                 }\n \n-                pat_range(first_expr, last_expr) => {\n+                PatRange(first_expr, last_expr) => {\n                     self.resolve_expr(first_expr, visitor);\n                     self.resolve_expr(last_expr, visitor);\n                 }\n \n-                pat_struct(ref path, _, _) => {\n+                PatStruct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, TypeNS, false, visitor) {\n-                        Some(def_ty(class_id))\n+                        Some(DefTy(class_id))\n                                 if self.structs.contains(&class_id) => {\n-                            let class_def = def_struct(class_id);\n+                            let class_def = DefStruct(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n-                        Some(definition @ def_struct(class_id)) => {\n+                        Some(definition @ DefStruct(class_id)) => {\n                             assert!(self.structs.contains(&class_id));\n                             self.record_def(pattern.id, definition);\n                         }\n-                        Some(definition @ def_variant(_, variant_id))\n+                        Some(definition @ DefVariant(_, variant_id))\n                                 if self.structs.contains(&variant_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n@@ -4532,10 +4536,10 @@ impl Resolver {\n                     }\n                     Some(def) => {\n                         match def.def {\n-                            def @ def_variant(*) | def @ def_struct(*) => {\n+                            def @ DefVariant(*) | def @ DefStruct(*) => {\n                                 return FoundStructOrEnumVariant(def);\n                             }\n-                            def @ def_static(_, false) => {\n+                            def @ DefStatic(_, false) => {\n                                 return FoundConst(def);\n                             }\n                             _ => {\n@@ -4564,7 +4568,7 @@ impl Resolver {\n                         namespace: Namespace,\n                         check_ribs: bool,\n                         visitor: &mut ResolveVisitor)\n-                        -> Option<def> {\n+                        -> Option<Def> {\n         // First, resolve the types.\n         for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n             self.resolve_type(ty, visitor);\n@@ -4608,7 +4612,7 @@ impl Resolver {\n                               namespace: Namespace,\n                               check_ribs: bool,\n                               span: Span)\n-                              -> Option<def> {\n+                              -> Option<Def> {\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n                                                       namespace,\n@@ -4692,7 +4696,7 @@ impl Resolver {\n                     match module.def_id {\n                         None => {} // Continue.\n                         Some(def_id) => {\n-                            return ChildNameDefinition(def_mod(def_id));\n+                            return ChildNameDefinition(DefMod(def_id));\n                         }\n                     }\n                 }\n@@ -4719,7 +4723,7 @@ impl Resolver {\n                                         path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n-                                        -> Option<def> {\n+                                        -> Option<Def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let containing_module;\n@@ -4785,7 +4789,7 @@ impl Resolver {\n                                        path: &Path,\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n-                                       -> Option<def> {\n+                                       -> Option<Def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let root_module = self.graph_root.get_module();\n@@ -4832,7 +4836,7 @@ impl Resolver {\n                                             ident: Ident,\n                                             namespace: Namespace,\n                                             span: Span)\n-                                            -> Option<def> {\n+                                            -> Option<Def> {\n         // Check the local set of ribs.\n         let search_result;\n         match namespace {\n@@ -4862,7 +4866,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_self_value_in_local_ribs(@mut self, span: Span)\n-                                            -> Option<def> {\n+                                            -> Option<Def> {\n         // FIXME #4950: This should not use a while loop.\n         let ribs = &mut self.value_ribs;\n         let mut i = ribs.len();\n@@ -4897,7 +4901,7 @@ impl Resolver {\n     pub fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n                                                        ident: Ident,\n                                                        namespace: Namespace)\n-                                                       -> Option<def> {\n+                                                       -> Option<Def> {\n         // Check the items.\n         match self.resolve_item_in_lexical_scope(self.current_module,\n                                                  ident,\n@@ -5014,7 +5018,7 @@ impl Resolver {\n       return false;\n     }\n \n-    pub fn resolve_expr(@mut self, expr: @expr, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_expr(@mut self, expr: @Expr, visitor: &mut ResolveVisitor) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -5025,7 +5029,7 @@ impl Resolver {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n-            expr_path(ref path) => {\n+            ExprPath(ref path) => {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n@@ -5038,7 +5042,7 @@ impl Resolver {\n                         // First-class methods are not supported yet; error\n                         // out here.\n                         match def {\n-                            def_method(*) => {\n+                            DefMethod(*) => {\n                                 self.resolve_error(expr.span,\n                                                       \"first-class methods \\\n                                                        are not supported\");\n@@ -5068,7 +5072,7 @@ impl Resolver {\n                             // structs, which wouldn't result in this error.)\n                             match self.with_no_errors(||\n                                 self.resolve_path(expr.id, path, TypeNS, false, visitor)) {\n-                                Some(def_ty(struct_id))\n+                                Some(DefTy(struct_id))\n                                   if self.structs.contains(&struct_id) => {\n                                     self.resolve_error(expr.span,\n                                             fmt!(\"`%s` is a structure name, but this expression \\\n@@ -5102,7 +5106,7 @@ impl Resolver {\n                 visit::walk_expr(visitor, expr, ());\n             }\n \n-            expr_fn_block(ref fn_decl, ref block) => {\n+            ExprFnBlock(ref fn_decl, ref block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n                                       Some(fn_decl),\n                                       NoTypeParameters,\n@@ -5111,15 +5115,15 @@ impl Resolver {\n                                       visitor);\n             }\n \n-            expr_struct(ref path, _, _) => {\n+            ExprStruct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n                 match self.resolve_path(expr.id, path, TypeNS, false, visitor) {\n-                    Some(def_ty(class_id)) | Some(def_struct(class_id))\n+                    Some(DefTy(class_id)) | Some(DefStruct(class_id))\n                             if self.structs.contains(&class_id) => {\n-                        let class_def = def_struct(class_id);\n+                        let class_def = DefStruct(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n-                    Some(definition @ def_variant(_, class_id))\n+                    Some(definition @ DefVariant(_, class_id))\n                             if self.structs.contains(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n@@ -5136,11 +5140,11 @@ impl Resolver {\n                 visit::walk_expr(visitor, expr, ());\n             }\n \n-            expr_loop(_, Some(label)) => {\n+            ExprLoop(_, Some(label)) => {\n                 do self.with_label_rib {\n                     {\n                         let this = &mut *self;\n-                        let def_like = DlDef(def_label(expr.id));\n+                        let def_like = DlDef(DefLabel(expr.id));\n                         let rib = this.label_ribs[this.label_ribs.len() - 1];\n                         rib.bindings.insert(label, def_like);\n                     }\n@@ -5149,9 +5153,9 @@ impl Resolver {\n                 }\n             }\n \n-            expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n-            expr_break(Some(label)) | expr_again(Some(label)) => {\n+            ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n@@ -5160,7 +5164,7 @@ impl Resolver {\n                                                    `%s`\",\n                                                    self.session.str_of(\n                                                        label))),\n-                    Some(DlDef(def @ def_label(_))) => {\n+                    Some(DlDef(def @ DefLabel(_))) => {\n                         self.record_def(expr.id, def)\n                     }\n                     Some(_) => {\n@@ -5171,7 +5175,7 @@ impl Resolver {\n                 }\n             }\n \n-            expr_self => {\n+            ExprSelf => {\n                 match self.resolve_self_value_in_local_ribs(expr.span) {\n                     None => {\n                         self.resolve_error(expr.span,\n@@ -5189,81 +5193,81 @@ impl Resolver {\n     }\n \n     pub fn record_candidate_traits_for_expr_if_necessary(@mut self,\n-                                                         expr: @expr) {\n+                                                         expr: @Expr) {\n         match expr.node {\n-            expr_field(_, ident, _) => {\n+            ExprField(_, ident, _) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n-            expr_method_call(_, _, ident, _, _, _) => {\n+            ExprMethodCall(_, _, ident, _, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for %d\",\n                        expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n-            expr_binary(_, add, _, _) | expr_assign_op(_, add, _, _) => {\n+            ExprBinary(_, BiAdd, _, _) | ExprAssignOp(_, BiAdd, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.add_trait());\n             }\n-            expr_binary(_, subtract, _, _) | expr_assign_op(_, subtract, _, _) => {\n+            ExprBinary(_, BiSub, _, _) | ExprAssignOp(_, BiSub, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.sub_trait());\n             }\n-            expr_binary(_, mul, _, _) | expr_assign_op(_, mul, _, _) => {\n+            ExprBinary(_, BiMul, _, _) | ExprAssignOp(_, BiMul, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.mul_trait());\n             }\n-            expr_binary(_, div, _, _) | expr_assign_op(_, div, _, _) => {\n+            ExprBinary(_, BiDiv, _, _) | ExprAssignOp(_, BiDiv, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.div_trait());\n             }\n-            expr_binary(_, rem, _, _) | expr_assign_op(_, rem, _, _) => {\n+            ExprBinary(_, BiRem, _, _) | ExprAssignOp(_, BiRem, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.rem_trait());\n             }\n-            expr_binary(_, bitxor, _, _) | expr_assign_op(_, bitxor, _, _) => {\n+            ExprBinary(_, BiBitXor, _, _) | ExprAssignOp(_, BiBitXor, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.bitxor_trait());\n             }\n-            expr_binary(_, bitand, _, _) | expr_assign_op(_, bitand, _, _) => {\n+            ExprBinary(_, BiBitAnd, _, _) | ExprAssignOp(_, BiBitAnd, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.bitand_trait());\n             }\n-            expr_binary(_, bitor, _, _) | expr_assign_op(_, bitor, _, _) => {\n+            ExprBinary(_, BiBitOr, _, _) | ExprAssignOp(_, BiBitOr, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.bitor_trait());\n             }\n-            expr_binary(_, shl, _, _) | expr_assign_op(_, shl, _, _) => {\n+            ExprBinary(_, BiShl, _, _) | ExprAssignOp(_, BiShl, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.shl_trait());\n             }\n-            expr_binary(_, shr, _, _) | expr_assign_op(_, shr, _, _) => {\n+            ExprBinary(_, BiShr, _, _) | ExprAssignOp(_, BiShr, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.shr_trait());\n             }\n-            expr_binary(_, lt, _, _) | expr_binary(_, le, _, _) |\n-            expr_binary(_, ge, _, _) | expr_binary(_, gt, _, _) => {\n+            ExprBinary(_, BiLt, _, _) | ExprBinary(_, BiLe, _, _) |\n+            ExprBinary(_, BiGe, _, _) | ExprBinary(_, BiGt, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.ord_trait());\n             }\n-            expr_binary(_, eq, _, _) | expr_binary(_, ne, _, _) => {\n+            ExprBinary(_, BiEq, _, _) | ExprBinary(_, BiNe, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.eq_trait());\n             }\n-            expr_unary(_, neg, _) => {\n+            ExprUnary(_, UnNeg, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.neg_trait());\n             }\n-            expr_unary(_, not, _) => {\n+            ExprUnary(_, UnNot, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.not_trait());\n             }\n-            expr_index(*) => {\n+            ExprIndex(*) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.index_trait());\n             }\n@@ -5274,7 +5278,7 @@ impl Resolver {\n     }\n \n     pub fn search_for_traits_containing_method(@mut self, name: Ident)\n-                                               -> ~[def_id] {\n+                                               -> ~[DefId] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                self.session.str_of(name));\n \n@@ -5305,7 +5309,7 @@ impl Resolver {\n                     match child_name_bindings.def_for_namespace(TypeNS) {\n                         Some(def) => {\n                             match def {\n-                                def_trait(trait_def_id) => {\n+                                DefTrait(trait_def_id) => {\n                                     if candidate_traits.contains(&trait_def_id) {\n                                         self.add_trait_info(\n                                             &mut found_traits,\n@@ -5333,7 +5337,7 @@ impl Resolver {\n                             match target.bindings.def_for_namespace(TypeNS) {\n                                 Some(def) => {\n                                     match def {\n-                                        def_trait(trait_def_id) => {\n+                                        DefTrait(trait_def_id) => {\n                                             if candidate_traits.contains(&trait_def_id) {\n                                                 self.add_trait_info(\n                                                     &mut found_traits,\n@@ -5374,8 +5378,8 @@ impl Resolver {\n     }\n \n     pub fn add_trait_info(&self,\n-                          found_traits: &mut ~[def_id],\n-                          trait_def_id: def_id,\n+                          found_traits: &mut ~[DefId],\n+                          trait_def_id: DefId,\n                           name: Ident) {\n         debug!(\"(adding trait info) found trait %d:%d for method '%s'\",\n                trait_def_id.crate,\n@@ -5386,7 +5390,7 @@ impl Resolver {\n \n     pub fn add_fixed_trait_for_expr(@mut self,\n                                     expr_id: NodeId,\n-                                    trait_id: Option<def_id>) {\n+                                    trait_id: Option<DefId>) {\n         match trait_id {\n             Some(trait_id) => {\n                 self.trait_map.insert(expr_id, @mut ~[trait_id]);\n@@ -5395,18 +5399,18 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_def(@mut self, node_id: NodeId, def: def) {\n+    pub fn record_def(@mut self, node_id: NodeId, def: Def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n     }\n \n     pub fn enforce_default_binding_mode(@mut self,\n-                                        pat: @pat,\n-                                        pat_binding_mode: binding_mode,\n+                                        pat: @Pat,\n+                                        pat_binding_mode: BindingMode,\n                                         descr: &str) {\n         match pat_binding_mode {\n-            bind_infer => {}\n-            bind_by_ref(*) => {\n+            BindInfer => {}\n+            BindByRef(*) => {\n                 self.resolve_error(\n                     pat.span,\n                     fmt!(\"cannot use `ref` binding mode with %s\","}, {"sha": "569c6dfde0cab7c3c97374ea46fbedf85b1cdd24", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -42,7 +42,7 @@ impl Visitor<Context> for StackCheckVisitor {\n                 b:&ast::Block, s:Span, n:ast::NodeId, e:Context) {\n         stack_check_fn(*self, fk, fd, b, s, n, e);\n     }\n-    fn visit_expr(&mut self, ex:@ast::expr, e:Context) {\n+    fn visit_expr(&mut self, ex:@ast::Expr, e:Context) {\n         stack_check_expr(*self, ex, e);\n     }\n }\n@@ -121,13 +121,13 @@ fn stack_check_fn<'a>(v: StackCheckVisitor,\n }\n \n fn stack_check_expr<'a>(v: StackCheckVisitor,\n-                        expr: @ast::expr,\n+                        expr: @ast::Expr,\n                         cx: Context) {\n     debug!(\"stack_check_expr(safe_stack=%b, expr=%s)\",\n            cx.safe_stack, expr.repr(cx.tcx));\n     if !cx.safe_stack {\n         match expr.node {\n-            ast::expr_call(callee, _, _) => {\n+            ast::ExprCall(callee, _, _) => {\n                 let callee_ty = ty::expr_ty(cx.tcx, callee);\n                 debug!(\"callee_ty=%s\", callee_ty.repr(cx.tcx));\n                 match ty::get(callee_ty).sty {\n@@ -146,13 +146,13 @@ fn stack_check_expr<'a>(v: StackCheckVisitor,\n     visit::walk_expr(&mut v, expr, cx);\n }\n \n-fn call_to_extern_fn(cx: Context, callee: @ast::expr) {\n+fn call_to_extern_fn(cx: Context, callee: @ast::Expr) {\n     // Permit direct calls to extern fns that are annotated with\n     // #[rust_stack]. This is naturally a horrible pain to achieve.\n     match callee.node {\n-        ast::expr_path(*) => {\n+        ast::ExprPath(*) => {\n             match cx.tcx.def_map.find(&callee.id) {\n-                Some(&ast::def_fn(id, _)) if id.crate == ast::LOCAL_CRATE => {\n+                Some(&ast::DefFn(id, _)) if id.crate == ast::LOCAL_CRATE => {\n                     match cx.tcx.items.find(&id.node) {\n                         Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n                             if attr::contains_name(item.attrs, \"rust_stack\") {"}, {"sha": "ad0ab95ebf0f121bcb0e3943407441bd7fd90ae5", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -231,8 +231,8 @@ use syntax::codemap::{Span, dummy_sp};\n // expression.\n enum Lit {\n     UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n-    ExprLit(@ast::expr),\n-    ConstLit(ast::def_id),              // the def ID of the constant\n+    ExprLit(@ast::Expr),\n+    ConstLit(ast::DefId),              // the def ID of the constant\n }\n \n #[deriving(Eq)]\n@@ -246,7 +246,7 @@ pub enum VecLenOpt {\n enum Opt {\n     lit(Lit),\n     var(ty::Disr, @adt::Repr),\n-    range(@ast::expr, @ast::expr),\n+    range(@ast::Expr, @ast::Expr),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n@@ -347,7 +347,7 @@ fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n-        ast::def_variant(enum_id, var_id) => {\n+        ast::DefVariant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for v in (*variants).iter() {\n                 if var_id == v.id {\n@@ -357,8 +357,8 @@ fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n             }\n             ::std::util::unreachable();\n         }\n-        ast::def_fn(*) |\n-        ast::def_struct(_) => {\n+        ast::DefFn(*) |\n+        ast::DefStruct(_) => {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n@@ -395,7 +395,7 @@ type BindingsMap = HashMap<Ident, BindingInfo>;\n #[deriving(Clone)]\n struct ArmData<'self> {\n     bodycx: @mut Block,\n-    arm: &'self ast::arm,\n+    arm: &'self ast::Arm,\n     bindings_map: @BindingsMap\n }\n \n@@ -407,7 +407,7 @@ struct ArmData<'self> {\n  */\n #[deriving(Clone)]\n struct Match<'self> {\n-    pats: ~[@ast::pat],\n+    pats: ~[@ast::Pat],\n     data: ArmData<'self>,\n     bound_ptrs: ~[(Ident, ValueRef)]\n }\n@@ -426,7 +426,7 @@ impl<'self> Repr for Match<'self> {\n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n         match br.pats[col].node {\n-          ast::pat_ident(_, _, Some(_)) => return true,\n+          ast::PatIdent(_, _, Some(_)) => return true,\n           _ => ()\n         }\n     }\n@@ -447,7 +447,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n \n     do m.map |br| {\n         match br.pats[col].node {\n-            ast::pat_ident(_, ref path, Some(inner)) => {\n+            ast::PatIdent(_, ref path, Some(inner)) => {\n                 let pats = vec::append(\n                     br.pats.slice(0u, col).to_owned(),\n                     vec::append(~[inner],\n@@ -467,7 +467,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n     }\n }\n \n-fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n+fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -476,7 +476,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     }\n }\n \n-type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n+type enter_pat<'self> = &'self fn(@ast::Pat) -> Option<~[@ast::Pat]>;\n \n fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,\n@@ -504,7 +504,7 @@ fn enter_match<'r>(bcx: @mut Block,\n                 let this = br.pats[col];\n                 let mut bound_ptrs = br.bound_ptrs.clone();\n                 match this.node {\n-                    ast::pat_ident(_, ref path, None) => {\n+                    ast::PatIdent(_, ref path, None) => {\n                         if pat_is_binding(dm, this) {\n                             bound_ptrs.push((path_to_ident(path), val));\n                         }\n@@ -544,8 +544,8 @@ fn enter_default<'r>(bcx: @mut Block,\n     // Collect all of the matches that can match against anything.\n     let matches = do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_tup(_) => Some(~[]),\n-          ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n+          ast::PatWild | ast::PatTup(_) => Some(~[]),\n+          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n     };\n@@ -613,12 +613,12 @@ fn enter_opt<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n-    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     let mut i = 0;\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         let answer = match p.node {\n-            ast::pat_enum(*) |\n-            ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n+            ast::PatEnum(*) |\n+            ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n                 let const_def = tcx.def_map.get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n@@ -627,7 +627,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                     None\n                 }\n             }\n-            ast::pat_enum(_, ref subpats) => {\n+            ast::PatEnum(_, ref subpats) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // XXX: Must we clone?\n                     match *subpats {\n@@ -638,26 +638,26 @@ fn enter_opt<'r>(bcx: @mut Block,\n                     None\n                 }\n             }\n-            ast::pat_ident(_, _, None)\n+            ast::PatIdent(_, _, None)\n                     if pat_is_variant_or_struct(tcx.def_map, p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(~[])\n                 } else {\n                     None\n                 }\n             }\n-            ast::pat_lit(l) => {\n+            ast::PatLit(l) => {\n                 if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(~[])} else {None}\n             }\n-            ast::pat_range(l1, l2) => {\n+            ast::PatRange(l1, l2) => {\n                 if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n             }\n-            ast::pat_struct(_, ref field_pats, _) => {\n+            ast::PatStruct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n                     match tcx.def_map.get_copy(&p.id) {\n-                        ast::def_variant(_, found_struct_id) => {\n+                        ast::DefVariant(_, found_struct_id) => {\n                             struct_id = found_struct_id;\n                         }\n                         _ => {\n@@ -681,7 +681,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                     None\n                 }\n             }\n-            ast::pat_vec(ref before, slice, ref after) => {\n+            ast::PatVec(ref before, slice, ref after) => {\n                 let (lo, hi) = match *opt {\n                     vec_len(_, _, (lo, hi)) => (lo, hi),\n                     _ => tcx.sess.span_bug(p.span,\n@@ -746,10 +746,10 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_struct(_, ref fpats, _) => {\n+            ast::PatStruct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n                 for fname in fields.iter() {\n                     match fpats.iter().find(|p| p.ident == *fname) {\n@@ -781,10 +781,10 @@ fn enter_tup<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_tup(ref elts) => Some((*elts).clone()),\n+            ast::PatTup(ref elts) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -807,10 +807,10 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_enum(_, Some(ref elts)) => Some((*elts).clone()),\n+            ast::PatEnum(_, Some(ref elts)) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -832,10 +832,10 @@ fn enter_box<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_box(sub) => {\n+            ast::PatBox(sub) => {\n                 Some(~[sub])\n             }\n             _ => {\n@@ -859,10 +859,10 @@ fn enter_uniq<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_uniq(sub) => {\n+            ast::PatUniq(sub) => {\n                 Some(~[sub])\n             }\n             _ => {\n@@ -886,10 +886,10 @@ fn enter_region<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::pat { id: 0, node: ast::pat_wild, span: dummy_sp() };\n+    let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: dummy_sp() };\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-            ast::pat_region(sub) => {\n+            ast::PatRegion(sub) => {\n                 Some(~[sub])\n             }\n             _ => {\n@@ -930,48 +930,48 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     for (i, br) in m.iter().enumerate() {\n         let cur = br.pats[col];\n         match cur.node {\n-            ast::pat_lit(l) => {\n+            ast::PatLit(l) => {\n                 add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n             }\n-            ast::pat_ident(*) => {\n+            ast::PatIdent(*) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n                 match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(&ast::def_variant(*)) => {\n+                    Some(&ast::DefVariant(*)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(&ast::def_struct(*)) => {\n+                    Some(&ast::DefStruct(*)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n-                    Some(&ast::def_static(const_did, false)) => {\n+                    Some(&ast::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n                 }\n             }\n-            ast::pat_enum(*) | ast::pat_struct(*) => {\n+            ast::PatEnum(*) | ast::PatStruct(*) => {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n                 match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(&ast::def_fn(*)) |\n-                    Some(&ast::def_variant(*)) => {\n+                    Some(&ast::DefFn(*)) |\n+                    Some(&ast::DefVariant(*)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(&ast::def_static(const_did, false)) => {\n+                    Some(&ast::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n                 }\n             }\n-            ast::pat_range(l1, l2) => {\n+            ast::PatRange(l1, l2) => {\n                 add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n-            ast::pat_vec(ref before, slice, ref after) => {\n+            ast::PatVec(ref before, slice, ref after) => {\n                 let (len, vec_opt) = match slice {\n                     None => (before.len(), vec_len_eq),\n                     Some(_) => (before.len() + after.len(),\n@@ -1050,7 +1050,7 @@ fn extract_vec_elems(bcx: @mut Block,\n         );\n         let slice_len = Sub(bcx, len, slice_len_offset);\n         let slice_ty = ty::mk_evec(bcx.tcx(),\n-            ty::mt {ty: vt.unit_ty, mutbl: ast::m_imm},\n+            ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n             ty::vstore_slice(ty::re_static)\n         );\n         let scratch = scratch_datum(bcx, slice_ty, \"\", false);\n@@ -1081,7 +1081,7 @@ fn collect_record_or_struct_fields(bcx: @mut Block,\n     let mut found = false;\n     for br in m.iter() {\n         match br.pats[col].node {\n-          ast::pat_struct(_, ref fs, _) => {\n+          ast::PatStruct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n               ty::ty_struct(*) => {\n                    extend(&mut fields, *fs);\n@@ -1099,7 +1099,7 @@ fn collect_record_or_struct_fields(bcx: @mut Block,\n         return None;\n     }\n \n-    fn extend(idents: &mut ~[ast::Ident], field_pats: &[ast::field_pat]) {\n+    fn extend(idents: &mut ~[ast::Ident], field_pats: &[ast::FieldPat]) {\n         for field_pat in field_pats.iter() {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any(|x| *x == field_ident) {\n@@ -1152,29 +1152,29 @@ macro_rules! any_pat (\n )\n \n fn any_box_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::pat_box(_))\n+    any_pat!(m, ast::PatBox(_))\n }\n \n fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::pat_uniq(_))\n+    any_pat!(m, ast::PatUniq(_))\n }\n \n fn any_region_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::pat_region(_))\n+    any_pat!(m, ast::PatRegion(_))\n }\n \n fn any_tup_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::pat_tup(_))\n+    any_pat!(m, ast::PatTup(_))\n }\n \n fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n-            ast::pat_enum(_, Some(_)) => {\n+            ast::PatEnum(_, Some(_)) => {\n                 match bcx.tcx().def_map.find(&pat.id) {\n-                    Some(&ast::def_fn(*)) |\n-                    Some(&ast::def_struct(*)) => true,\n+                    Some(&ast::DefFn(*)) |\n+                    Some(&ast::DefStruct(*)) => true,\n                     _ => false\n                 }\n             }\n@@ -1186,10 +1186,10 @@ fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n type mk_fail = @fn() -> BasicBlockRef;\n \n fn pick_col(m: &[Match]) -> uint {\n-    fn score(p: &ast::pat) -> uint {\n+    fn score(p: &ast::Pat) -> uint {\n         match p.node {\n-          ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n-          ast::pat_ident(_, _, Some(p)) => score(p),\n+          ast::PatLit(_) | ast::PatEnum(_, _) | ast::PatRange(_, _) => 1u,\n+          ast::PatIdent(_, _, Some(p)) => score(p),\n           _ => 0u\n         }\n     }\n@@ -1227,7 +1227,7 @@ fn compare_values(cx: @mut Block,\n                    -> Result {\n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n-      let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::eq);\n+      let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq);\n       return rslt(rs.bcx, rs.val);\n     }\n \n@@ -1341,7 +1341,7 @@ fn insert_lllocals(bcx: @mut Block,\n }\n \n fn compile_guard(bcx: @mut Block,\n-                     guard_expr: @ast::expr,\n+                     guard_expr: @ast::Expr,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n@@ -1659,19 +1659,19 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   Result {bcx, val}) => {\n                                   compare_scalar_types(\n                                           bcx, test_val, val,\n-                                          t, ast::ge)\n+                                          t, ast::BiGe)\n                               }\n                               range_result(\n                                   Result {val: vbegin, _},\n                                   Result {bcx, val: vend}) => {\n                                   let Result {bcx, val: llge} =\n                                       compare_scalar_types(\n                                           bcx, test_val,\n-                                          vbegin, t, ast::ge);\n+                                          vbegin, t, ast::BiGe);\n                                   let Result {bcx, val: llle} =\n                                       compare_scalar_types(\n                                           bcx, test_val, vend,\n-                                          t, ast::le);\n+                                          t, ast::BiLe);\n                                   rslt(bcx, And(bcx, llge, llle))\n                               }\n                           }\n@@ -1689,14 +1689,14 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   Result {bcx, val}) => {\n                                   let value = compare_scalar_values(\n                                       bcx, test_val, val,\n-                                      signed_int, ast::eq);\n+                                      signed_int, ast::BiEq);\n                                   rslt(bcx, value)\n                               }\n                               lower_bound(\n                                   Result {bcx, val: val}) => {\n                                   let value = compare_scalar_values(\n                                       bcx, test_val, val,\n-                                      signed_int, ast::ge);\n+                                      signed_int, ast::BiGe);\n                                   rslt(bcx, value)\n                               }\n                               range_result(\n@@ -1705,11 +1705,11 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   let llge =\n                                       compare_scalar_values(\n                                           bcx, test_val,\n-                                          vbegin, signed_int, ast::ge);\n+                                          vbegin, signed_int, ast::BiGe);\n                                   let llle =\n                                       compare_scalar_values(\n                                           bcx, test_val, vend,\n-                                          signed_int, ast::le);\n+                                          signed_int, ast::BiLe);\n                                   rslt(bcx, And(bcx, llge, llle))\n                               }\n                           }\n@@ -1768,17 +1768,17 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n }\n \n pub fn trans_match(bcx: @mut Block,\n-                   match_expr: &ast::expr,\n-                   discr_expr: @ast::expr,\n-                   arms: &[ast::arm],\n+                   match_expr: &ast::Expr,\n+                   discr_expr: @ast::Expr,\n+                   arms: &[ast::Arm],\n                    dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n     do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n }\n \n-fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n+fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1794,15 +1794,15 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n         let llmatch;\n         let trmode;\n         match bm {\n-            ast::bind_infer => {\n+            ast::BindInfer => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n                 trmode = TrByValue(alloca(bcx, llvariable_ty,\n                                           bcx.ident(ident)));\n             }\n-            ast::bind_by_ref(_) => {\n+            ast::BindByRef(_) => {\n                 llmatch = alloca(bcx, llvariable_ty, bcx.ident(ident));\n                 trmode = TrByRef;\n             }\n@@ -1819,8 +1819,8 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n }\n \n fn trans_match_inner(scope_cx: @mut Block,\n-                         discr_expr: @ast::expr,\n-                         arms: &[ast::arm],\n+                         discr_expr: @ast::Expr,\n+                         arms: &[ast::Arm],\n                          dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n@@ -1909,8 +1909,8 @@ enum IrrefutablePatternBindingMode {\n }\n \n pub fn store_local(bcx: @mut Block,\n-                   pat: @ast::pat,\n-                   opt_init_expr: Option<@ast::expr>)\n+                   pat: @ast::Pat,\n+                   opt_init_expr: Option<@ast::Expr>)\n                                -> @mut Block {\n     /*!\n      * Generates code for a local variable declaration like\n@@ -1962,7 +1962,7 @@ pub fn store_local(bcx: @mut Block,\n         }\n     };\n \n-    fn create_dummy_locals(mut bcx: @mut Block, pat: @ast::pat) -> @mut Block {\n+    fn create_dummy_locals(mut bcx: @mut Block, pat: @ast::Pat) -> @mut Block {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -1976,7 +1976,7 @@ pub fn store_local(bcx: @mut Block,\n }\n \n pub fn store_arg(mut bcx: @mut Block,\n-                 pat: @ast::pat,\n+                 pat: @ast::Pat,\n                  llval: ValueRef)\n                  -> @mut Block {\n     /*!\n@@ -2037,7 +2037,7 @@ fn mk_binding_alloca(mut bcx: @mut Block,\n }\n \n fn bind_irrefutable_pat(bcx: @mut Block,\n-                        pat: @ast::pat,\n+                        pat: @ast::Pat,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode)\n                         -> @mut Block {\n@@ -2077,7 +2077,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        ast::pat_ident(pat_binding_mode, ref path, inner) => {\n+        ast::PatIdent(pat_binding_mode, ref path, inner) => {\n             if pat_is_binding(tcx.def_map, pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n@@ -2086,7 +2086,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                     bcx, pat.id, path, binding_mode,\n                     |bcx, variable_ty, llvariable_val| {\n                         match pat_binding_mode {\n-                            ast::bind_infer => {\n+                            ast::BindInfer => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n                                 let datum = Datum {val: val,\n@@ -2095,7 +2095,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                                 datum.store_to(bcx, INIT, llvariable_val)\n                             }\n \n-                            ast::bind_by_ref(_) => {\n+                            ast::BindByRef(_) => {\n                                 // By ref binding: the value of the variable\n                                 // is the pointer `val` itself.\n                                 Store(bcx, val, llvariable_val);\n@@ -2109,9 +2109,9 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                 bcx = bind_irrefutable_pat(bcx, inner_pat, val, binding_mode);\n             }\n         }\n-        ast::pat_enum(_, ref sub_pats) => {\n+        ast::PatEnum(_, ref sub_pats) => {\n             match bcx.tcx().def_map.find(&pat.id) {\n-                Some(&ast::def_variant(enum_id, var_id)) => {\n+                Some(&ast::DefVariant(enum_id, var_id)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ty::enum_variant_with_id(ccx.tcx,\n                                                          enum_id,\n@@ -2127,8 +2127,8 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                         }\n                     }\n                 }\n-                Some(&ast::def_fn(*)) |\n-                Some(&ast::def_struct(*)) => {\n+                Some(&ast::DefFn(*)) |\n+                Some(&ast::DefStruct(*)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n@@ -2145,14 +2145,14 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                         }\n                     }\n                 }\n-                Some(&ast::def_static(_, false)) => {\n+                Some(&ast::DefStatic(_, false)) => {\n                 }\n                 _ => {\n                     // Nothing to do here.\n                 }\n             }\n         }\n-        ast::pat_struct(_, ref fields, _) => {\n+        ast::PatStruct(_, ref fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n@@ -2165,14 +2165,14 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                 }\n             }\n         }\n-        ast::pat_tup(ref elems) => {\n+        ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n             }\n         }\n-        ast::pat_box(inner) | ast::pat_uniq(inner) => {\n+        ast::PatBox(inner) | ast::PatUniq(inner) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n             let unboxed = match ty::get(pat_ty).sty {\n@@ -2181,23 +2181,23 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             };\n             bcx = bind_irrefutable_pat(bcx, inner, unboxed, binding_mode);\n         }\n-        ast::pat_region(inner) => {\n+        ast::PatRegion(inner) => {\n             let loaded_val = Load(bcx, val);\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode);\n         }\n-        ast::pat_vec(*) => {\n+        ast::PatVec(*) => {\n             bcx.tcx().sess.span_bug(\n                 pat.span,\n                 fmt!(\"vector patterns are never irrefutable!\"));\n         }\n-        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n+        ast::PatWild | ast::PatLit(_) | ast::PatRange(_, _) => ()\n     }\n     return bcx;\n }\n \n-fn simple_identifier<'a>(pat: &'a ast::pat) -> Option<&'a ast::Path> {\n+fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Path> {\n     match pat.node {\n-        ast::pat_ident(ast::bind_infer, ref path, None) => {\n+        ast::PatIdent(ast::BindInfer, ref path, None) => {\n             Some(path)\n         }\n         _ => {"}, {"sha": "de4ea331041f2111f4fcb8a02c5114091f8dfb46", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -46,7 +46,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         }));\n \n         let e = match out.node {\n-            ast::expr_addr_of(_, e) => e,\n+            ast::ExprAddrOf(_, e) => e,\n             _ => fail!(\"Expression must be addr of\")\n         };\n "}, {"sha": "251ce697d535a177dd8795f3f47f5b2c44276aac", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -292,7 +292,7 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    fn require_alloc_fn(bcx: @mut Block, t: ty::t, it: LangItem) -> ast::def_id {\n+    fn require_alloc_fn(bcx: @mut Block, t: ty::t, it: LangItem) -> ast::DefId {\n         let li = &bcx.tcx().lang_items;\n         match li.require(it) {\n             Ok(id) => id,\n@@ -498,8 +498,8 @@ pub fn note_unique_llvm_symbol(ccx: &mut CrateContext, sym: @str) {\n \n \n pub fn get_res_dtor(ccx: @mut CrateContext,\n-                    did: ast::def_id,\n-                    parent_id: ast::def_id,\n+                    did: ast::DefId,\n+                    parent_id: ast::DefId,\n                     substs: &[ty::t])\n                  -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n@@ -559,7 +559,7 @@ pub fn compare_scalar_types(cx: @mut Block,\n                             lhs: ValueRef,\n                             rhs: ValueRef,\n                             t: ty::t,\n-                            op: ast::binop)\n+                            op: ast::BinOp)\n                          -> Result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n@@ -590,7 +590,7 @@ pub fn compare_scalar_values(cx: @mut Block,\n                              lhs: ValueRef,\n                              rhs: ValueRef,\n                              nt: scalar_type,\n-                             op: ast::binop)\n+                             op: ast::BinOp)\n                           -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: @mut Block) -> ! {\n@@ -602,44 +602,44 @@ pub fn compare_scalar_values(cx: @mut Block,\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::eq | ast::le | ast::ge => return C_i1(true),\n-          ast::ne | ast::lt | ast::gt => return C_i1(false),\n+          ast::BiEq | ast::BiLe | ast::BiGe => return C_i1(true),\n+          ast::BiNe | ast::BiLt | ast::BiGt => return C_i1(false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n       }\n       floating_point => {\n         let cmp = match op {\n-          ast::eq => lib::llvm::RealOEQ,\n-          ast::ne => lib::llvm::RealUNE,\n-          ast::lt => lib::llvm::RealOLT,\n-          ast::le => lib::llvm::RealOLE,\n-          ast::gt => lib::llvm::RealOGT,\n-          ast::ge => lib::llvm::RealOGE,\n+          ast::BiEq => lib::llvm::RealOEQ,\n+          ast::BiNe => lib::llvm::RealUNE,\n+          ast::BiLt => lib::llvm::RealOLT,\n+          ast::BiLe => lib::llvm::RealOLE,\n+          ast::BiGt => lib::llvm::RealOGT,\n+          ast::BiGe => lib::llvm::RealOGE,\n           _ => die(cx)\n         };\n         return FCmp(cx, cmp, lhs, rhs);\n       }\n       signed_int => {\n         let cmp = match op {\n-          ast::eq => lib::llvm::IntEQ,\n-          ast::ne => lib::llvm::IntNE,\n-          ast::lt => lib::llvm::IntSLT,\n-          ast::le => lib::llvm::IntSLE,\n-          ast::gt => lib::llvm::IntSGT,\n-          ast::ge => lib::llvm::IntSGE,\n+          ast::BiEq => lib::llvm::IntEQ,\n+          ast::BiNe => lib::llvm::IntNE,\n+          ast::BiLt => lib::llvm::IntSLT,\n+          ast::BiLe => lib::llvm::IntSLE,\n+          ast::BiGt => lib::llvm::IntSGT,\n+          ast::BiGe => lib::llvm::IntSGE,\n           _ => die(cx)\n         };\n         return ICmp(cx, cmp, lhs, rhs);\n       }\n       unsigned_int => {\n         let cmp = match op {\n-          ast::eq => lib::llvm::IntEQ,\n-          ast::ne => lib::llvm::IntNE,\n-          ast::lt => lib::llvm::IntULT,\n-          ast::le => lib::llvm::IntULE,\n-          ast::gt => lib::llvm::IntUGT,\n-          ast::ge => lib::llvm::IntUGE,\n+          ast::BiEq => lib::llvm::IntEQ,\n+          ast::BiNe => lib::llvm::IntNE,\n+          ast::BiLt => lib::llvm::IntULT,\n+          ast::BiLe => lib::llvm::IntULE,\n+          ast::BiGt => lib::llvm::IntUGT,\n+          ast::BiGe => lib::llvm::IntUGE,\n           _ => die(cx)\n         };\n         return ICmp(cx, cmp, lhs, rhs);\n@@ -750,21 +750,21 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs(cx: @mut Block, op: ast::binop,\n+pub fn cast_shift_expr_rhs(cx: @mut Block, op: ast::BinOp,\n                            lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a,b| Trunc(cx, a, b),\n                    |a,b| ZExt(cx, a, b))\n }\n \n-pub fn cast_shift_const_rhs(op: ast::binop,\n+pub fn cast_shift_const_rhs(op: ast::BinOp,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n                    |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n-pub fn cast_shift_rhs(op: ast::binop,\n+pub fn cast_shift_rhs(op: ast::BinOp,\n                       lhs: ValueRef, rhs: ValueRef,\n                       trunc: &fn(ValueRef, Type) -> ValueRef,\n                       zext: &fn(ValueRef, Type) -> ValueRef)\n@@ -791,9 +791,9 @@ pub fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::binop,\n+pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::BinOp,\n                     rhs: ValueRef, rhs_t: ty::t) -> @mut Block {\n-    let text = if divrem == ast::div {\n+    let text = if divrem == ast::BiDiv {\n         @\"attempted to divide by zero\"\n     } else {\n         @\"attempted remainder with a divisor of zero\"\n@@ -821,7 +821,7 @@ pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n     C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n-pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n+pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n@@ -1088,7 +1088,7 @@ pub fn trans_trace(bcx: @mut Block, sp_opt: Option<Span>, trace_str: @str) {\n \n pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n-        ast::pat_wild => true, _ => false\n+        ast::PatWild => true, _ => false\n     }\n }\n \n@@ -1113,7 +1113,7 @@ pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n     _match::store_local(bcx, local.pat, local.init)\n }\n \n-pub fn trans_stmt(cx: @mut Block, s: &ast::stmt) -> @mut Block {\n+pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1124,22 +1124,22 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::stmt) -> @mut Block {\n     let mut bcx = cx;\n \n     match s.node {\n-        ast::stmt_expr(e, _) | ast::stmt_semi(e, _) => {\n+        ast::StmtExpr(e, _) | ast::StmtSemi(e, _) => {\n             bcx = expr::trans_into(cx, e, expr::Ignore);\n         }\n-        ast::stmt_decl(d, _) => {\n+        ast::StmtDecl(d, _) => {\n             match d.node {\n-                ast::decl_local(ref local) => {\n+                ast::DeclLocal(ref local) => {\n                     bcx = init_local(bcx, *local);\n                     if cx.sess().opts.extra_debuginfo\n                         && fcx_has_nonzero_span(bcx.fcx) {\n                         debuginfo::create_local_var_metadata(bcx, *local);\n                     }\n                 }\n-                ast::decl_item(i) => trans_item(cx.fcx.ccx, i)\n+                ast::DeclItem(i) => trans_item(cx.fcx.ccx, i)\n             }\n         }\n-        ast::stmt_mac(*) => cx.tcx().sess.bug(\"unexpanded macro\")\n+        ast::StmtMac(*) => cx.tcx().sess.bug(\"unexpanded macro\")\n     }\n \n     return bcx;\n@@ -1444,9 +1444,9 @@ pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n     for s in b.stmts.iter() {\n         match s.node {\n-          ast::stmt_decl(d, _) => {\n+          ast::StmtDecl(d, _) => {\n             match d.node {\n-              ast::decl_local(ref local) => it(*local),\n+              ast::DeclLocal(ref local) => it(*local),\n               _ => {} /* fall through */\n             }\n           }\n@@ -2231,7 +2231,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n           if attr::contains_name(item.attrs, \"static_assert\") {\n-              if m == ast::m_mutbl {\n+              if m == ast::MutMutable {\n                   ccx.sess.span_fatal(expr.span,\n                                       \"cannot have static_assert on a mutable \\\n                                        static\");\n@@ -2488,7 +2488,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             // LLVM type is not fully determined by the Rust type.\n                             let v = consts::const_expr(ccx, expr);\n                             ccx.const_values.insert(id, v);\n-                            exprt = (m == ast::m_mutbl || i.vis == ast::public);\n+                            exprt = (m == ast::MutMutable || i.vis == ast::public);\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);"}, {"sha": "14be9bc2873c39f4772dd85640eb11322b0bca81", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -77,13 +77,13 @@ pub struct Callee {\n     data: CalleeData\n }\n \n-pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n+pub fn trans(bcx: @mut Block, expr: @ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n-        ast::expr_path(_) => {\n+        ast::ExprPath(_) => {\n             return trans_def(bcx, bcx.def(expr.id), expr);\n         }\n         _ => {}\n@@ -92,7 +92,7 @@ pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee(bcx: @mut Block, expr: @ast::expr) -> Callee {\n+    fn datum_callee(bcx: @mut Block, expr: @ast::Expr) -> Callee {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(*) => {\n@@ -115,42 +115,42 @@ pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n         return Callee {bcx: bcx, data: Fn(fd)};\n     }\n \n-    fn trans_def(bcx: @mut Block, def: ast::def, ref_expr: @ast::expr) -> Callee {\n+    fn trans_def(bcx: @mut Block, def: ast::Def, ref_expr: @ast::Expr) -> Callee {\n         match def {\n-            ast::def_fn(did, _) |\n-            ast::def_static_method(did, ast::FromImpl(_), _) => {\n+            ast::DefFn(did, _) |\n+            ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id))\n             }\n-            ast::def_static_method(impl_did,\n+            ast::DefStaticMethod(impl_did,\n                                    ast::FromTrait(trait_did),\n                                    _) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx, impl_did,\n                                                                 trait_did,\n                                                                 ref_expr.id))\n             }\n-            ast::def_variant(tid, vid) => {\n+            ast::DefVariant(tid, vid) => {\n                 // nullary variants are not callable\n                 assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n             }\n-            ast::def_struct(def_id) => {\n+            ast::DefStruct(def_id) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id))\n             }\n-            ast::def_static(*) |\n-            ast::def_arg(*) |\n-            ast::def_local(*) |\n-            ast::def_binding(*) |\n-            ast::def_upvar(*) |\n-            ast::def_self(*) => {\n+            ast::DefStatic(*) |\n+            ast::DefArg(*) |\n+            ast::DefLocal(*) |\n+            ast::DefBinding(*) |\n+            ast::DefUpvar(*) |\n+            ast::DefSelf(*) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            ast::def_mod(*) | ast::def_foreign_mod(*) | ast::def_trait(*) |\n-            ast::def_ty(*) | ast::def_prim_ty(*) |\n-            ast::def_use(*) | ast::def_typaram_binder(*) |\n-            ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) |\n-            ast::def_self_ty(*) | ast::def_method(*) => {\n+            ast::DefMod(*) | ast::DefForeignMod(*) | ast::DefTrait(*) |\n+            ast::DefTy(*) | ast::DefPrimTy(*) |\n+            ast::DefUse(*) | ast::DefTyParamBinder(*) |\n+            ast::DefRegion(*) | ast::DefLabel(*) | ast::DefTyParam(*) |\n+            ast::DefSelfTy(*) | ast::DefMethod(*) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     fmt!(\"Cannot translate def %? \\\n@@ -161,14 +161,14 @@ pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n }\n \n pub fn trans_fn_ref_to_callee(bcx: @mut Block,\n-                              def_id: ast::def_id,\n+                              def_id: ast::DefId,\n                               ref_id: ast::NodeId) -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n pub fn trans_fn_ref(bcx: @mut Block,\n-                    def_id: ast::def_id,\n+                    def_id: ast::DefId,\n                     ref_id: ast::NodeId) -> FnData {\n     /*!\n      *\n@@ -188,7 +188,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n \n pub fn trans_fn_ref_with_vtables_to_callee(\n         bcx: @mut Block,\n-        def_id: ast::def_id,\n+        def_id: ast::DefId,\n         ref_id: ast::NodeId,\n         type_params: &[ty::t],\n         vtables: Option<typeck::vtable_res>)\n@@ -199,7 +199,7 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n }\n \n fn resolve_default_method_vtables(bcx: @mut Block,\n-                                  impl_id: ast::def_id,\n+                                  impl_id: ast::DefId,\n                                   method: &ty::Method,\n                                   substs: &ty::substs,\n                                   impl_vtables: Option<typeck::vtable_res>)\n@@ -242,7 +242,7 @@ fn resolve_default_method_vtables(bcx: @mut Block,\n \n pub fn trans_fn_ref_with_vtables(\n         bcx: @mut Block,       //\n-        def_id: ast::def_id,   // def id of fn\n+        def_id: ast::DefId,   // def id of fn\n         ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n@@ -447,8 +447,8 @@ pub fn trans_fn_ref_with_vtables(\n // Translating calls\n \n pub fn trans_call(in_cx: @mut Block,\n-                  call_ex: @ast::expr,\n-                  f: @ast::expr,\n+                  call_ex: @ast::Expr,\n+                  f: @ast::Expr,\n                   args: CallArgs,\n                   id: ast::NodeId,\n                   dest: expr::Dest)\n@@ -465,9 +465,9 @@ pub fn trans_call(in_cx: @mut Block,\n }\n \n pub fn trans_method_call(in_cx: @mut Block,\n-                         call_ex: @ast::expr,\n+                         call_ex: @ast::Expr,\n                          callee_id: ast::NodeId,\n-                         rcvr: @ast::expr,\n+                         rcvr: @ast::Expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n                          -> @mut Block {\n@@ -503,7 +503,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n }\n \n pub fn trans_lang_call(bcx: @mut Block,\n-                       did: ast::def_id,\n+                       did: ast::DefId,\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n     -> Result {\n@@ -530,7 +530,7 @@ pub fn trans_lang_call(bcx: @mut Block,\n }\n \n pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n-                                        did: ast::def_id,\n+                                        did: ast::DefId,\n                                         args: &[ValueRef],\n                                         type_params: &[ty::t],\n                                         dest: expr::Dest)\n@@ -576,11 +576,11 @@ impl Visitor<@mut bool> for CalleeTranslationVisitor {\n \n     fn visit_item(&mut self, _:@ast::item, _:@mut bool) { }\n \n-    fn visit_expr(&mut self, e:@ast::expr, cx:@mut bool) {\n+    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut bool) {\n \n             if !*cx {\n                 match e.node {\n-                  ast::expr_ret(_) => *cx = true,\n+                  ast::ExprRet(_) => *cx = true,\n                   _ => visit::walk_expr(self, e, cx),\n                 }\n             }\n@@ -757,7 +757,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n }\n \n pub enum CallArgs<'self> {\n-    ArgExprs(&'self [@ast::expr]),\n+    ArgExprs(&'self [@ast::Expr]),\n     ArgVals(&'self [ValueRef])\n }\n \n@@ -815,7 +815,7 @@ pub enum AutorefArg {\n pub fn trans_arg_expr(bcx: @mut Block,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n-                      arg_expr: @ast::expr,\n+                      arg_expr: @ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       autoref_arg: AutorefArg) -> Result {\n     let _icx = push_ctxt(\"trans_arg_expr\");"}, {"sha": "645f81577668e90f9f2d8f3ebb82de9ab80bf95d", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -208,7 +208,7 @@ pub fn store_environment(bcx: @mut Block,\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n     // whatever.\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::m_imm});\n+    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::MutImmutable});\n     let llboxptr_ty = type_of(ccx, cboxptr_ty);\n \n     // If there are no bound values, no point in allocating anything."}, {"sha": "25d64e65b19bb3cb812a7484397ef7b4b60c8bba", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -484,7 +484,7 @@ pub trait get_node_info {\n     fn info(&self) -> Option<NodeInfo>;\n }\n \n-impl get_node_info for ast::expr {\n+impl get_node_info for ast::Expr {\n     fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo {id: self.id,\n                        callee_id: self.get_callee_id(),\n@@ -500,7 +500,7 @@ impl get_node_info for ast::Block {\n     }\n }\n \n-impl get_node_info for Option<@ast::expr> {\n+impl get_node_info for Option<@ast::Expr> {\n     fn info(&self) -> Option<NodeInfo> {\n         self.chain_ref(|s| s.info())\n     }\n@@ -570,19 +570,19 @@ impl Block {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n-    pub fn expr_to_str(&self, e: @ast::expr) -> ~str {\n+    pub fn expr_to_str(&self, e: @ast::Expr) -> ~str {\n         e.repr(self.tcx())\n     }\n \n-    pub fn expr_is_lval(&self, e: &ast::expr) -> bool {\n+    pub fn expr_is_lval(&self, e: &ast::Expr) -> bool {\n         ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    pub fn expr_kind(&self, e: &ast::expr) -> ty::ExprKind {\n+    pub fn expr_kind(&self, e: &ast::Expr) -> ty::ExprKind {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    pub fn def(&self, nid: ast::NodeId) -> ast::def {\n+    pub fn def(&self, nid: ast::NodeId) -> ast::Def {\n         match self.tcx().def_map.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -681,7 +681,7 @@ pub fn block_parent(cx: @mut Block) -> @mut Block {\n pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(\n         tcx,\n-        ty::mt {ty: ty::mk_i8(), mutbl: ast::m_imm}\n+        ty::mt {ty: ty::mk_i8(), mutbl: ast::MutImmutable}\n     );\n     return ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_type(tcx),\n                          ptr, ptr,\n@@ -920,7 +920,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n \n #[deriving(Eq,IterBytes)]\n pub struct mono_id_ {\n-    def: ast::def_id,\n+    def: ast::DefId,\n     params: ~[mono_param_id]\n }\n \n@@ -979,11 +979,11 @@ pub fn node_id_type(bcx: @mut Block, id: ast::NodeId) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: @mut Block, ex: &ast::expr) -> ty::t {\n+pub fn expr_ty(bcx: @mut Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: @mut Block, ex: &ast::expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: @mut Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)\n@@ -1124,7 +1124,7 @@ pub fn bool_to_i1(bcx: @mut Block, llval: ValueRef) -> ValueRef {\n }\n \n pub fn langcall(bcx: @mut Block, span: Option<Span>, msg: &str,\n-                li: LangItem) -> ast::def_id {\n+                li: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {"}, {"sha": "64cfe13553dc4b34f9610614d76a0673e691f0bb", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -35,7 +35,7 @@ use std::libc::c_uint;\n use std::vec;\n use syntax::{ast, ast_util, ast_map};\n \n-pub fn const_lit(cx: &mut CrateContext, e: &ast::expr, lit: ast::lit)\n+pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -82,7 +82,7 @@ pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-pub fn const_vec(cx: @mut CrateContext, e: &ast::expr, es: &[@ast::expr])\n+pub fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr])\n     -> (ValueRef, ValueRef, Type) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n@@ -134,7 +134,7 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(cx.tcx, t, explicit) {\n         Some(ref mt) => {\n-            assert!(mt.mutbl != ast::m_mutbl);\n+            assert!(mt.mutbl != ast::MutMutable);\n             let dv = match ty::get(t).sty {\n                 ty::ty_ptr(*) | ty::ty_rptr(*) => {\n                      const_deref_ptr(cx, v)\n@@ -156,25 +156,25 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     }\n }\n \n-pub fn get_const_val(cx: @mut CrateContext, mut def_id: ast::def_id) -> ValueRef {\n+pub fn get_const_val(cx: @mut CrateContext, mut def_id: ast::DefId) -> ValueRef {\n     let contains_key = cx.const_values.contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n         match cx.tcx.items.get_copy(&def_id.node) {\n             ast_map::node_item(@ast::item {\n-                node: ast::item_static(_, ast::m_imm, _), _\n+                node: ast::item_static(_, ast::MutImmutable, _), _\n             }, _) => {\n-                trans_const(cx, ast::m_imm, def_id.node);\n+                trans_const(cx, ast::MutImmutable, def_id.node);\n             }\n             _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n         }\n     }\n     cx.const_values.get_copy(&def_id.node)\n }\n \n-pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n+pub fn const_expr(cx: @mut CrateContext, e: @ast::Expr) -> ValueRef {\n     let mut llconst = const_expr_unadjusted(cx, e);\n     let ety = ty::expr_ty(cx.tcx, e);\n     let adjustment = cx.tcx.adjustments.find_copy(&e.id);\n@@ -208,11 +208,11 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                     match *autoref {\n                         ty::AutoUnsafe(m) |\n                         ty::AutoPtr(ty::re_static, m) => {\n-                            assert!(m != ast::m_mutbl);\n+                            assert!(m != ast::MutMutable);\n                             llconst = llptr;\n                         }\n                         ty::AutoBorrowVec(ty::re_static, m) => {\n-                            assert!(m != ast::m_mutbl);\n+                            assert!(m != ast::MutMutable);\n                             assert_eq!(abi::slice_elt_base, 0);\n                             assert_eq!(abi::slice_elt_len, 1);\n \n@@ -252,12 +252,12 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     llconst\n }\n \n-fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n+fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n-          ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n-          ast::expr_binary(_, b, e1, e2) => {\n+          ast::ExprLit(lit) => consts::const_lit(cx, e, *lit),\n+          ast::ExprBinary(_, b, e1, e2) => {\n             let te1 = const_expr(cx, e1);\n             let te2 = const_expr(cx, e2);\n \n@@ -269,68 +269,68 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n             return match b {\n-              ast::add   => {\n+              ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }\n               }\n-              ast::subtract => {\n+              ast::BiSub => {\n                 if is_float { llvm::LLVMConstFSub(te1, te2) }\n                 else        { llvm::LLVMConstSub(te1, te2) }\n               }\n-              ast::mul    => {\n+              ast::BiMul    => {\n                 if is_float { llvm::LLVMConstFMul(te1, te2) }\n                 else        { llvm::LLVMConstMul(te1, te2) }\n               }\n-              ast::div    => {\n+              ast::BiDiv    => {\n                 if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n                 else if signed { llvm::LLVMConstSDiv(te1, te2) }\n                 else           { llvm::LLVMConstUDiv(te1, te2) }\n               }\n-              ast::rem    => {\n+              ast::BiRem    => {\n                 if is_float    { llvm::LLVMConstFRem(te1, te2) }\n                 else if signed { llvm::LLVMConstSRem(te1, te2) }\n                 else           { llvm::LLVMConstURem(te1, te2) }\n               }\n-              ast::and    => llvm::LLVMConstAnd(te1, te2),\n-              ast::or     => llvm::LLVMConstOr(te1, te2),\n-              ast::bitxor => llvm::LLVMConstXor(te1, te2),\n-              ast::bitand => llvm::LLVMConstAnd(te1, te2),\n-              ast::bitor  => llvm::LLVMConstOr(te1, te2),\n-              ast::shl    => llvm::LLVMConstShl(te1, te2),\n-              ast::shr    => {\n+              ast::BiAnd    => llvm::LLVMConstAnd(te1, te2),\n+              ast::BiOr     => llvm::LLVMConstOr(te1, te2),\n+              ast::BiBitXor => llvm::LLVMConstXor(te1, te2),\n+              ast::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n+              ast::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n+              ast::BiShl    => llvm::LLVMConstShl(te1, te2),\n+              ast::BiShr    => {\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n-              ast::eq     => {\n+              ast::BiEq     => {\n                   if is_float { ConstFCmp(RealOEQ, te1, te2) }\n                   else        { ConstICmp(IntEQ, te1, te2)   }\n               },\n-              ast::lt     => {\n+              ast::BiLt     => {\n                   if is_float { ConstFCmp(RealOLT, te1, te2) }\n                   else        {\n                       if signed { ConstICmp(IntSLT, te1, te2) }\n                       else      { ConstICmp(IntULT, te1, te2) }\n                   }\n               },\n-              ast::le     => {\n+              ast::BiLe     => {\n                   if is_float { ConstFCmp(RealOLE, te1, te2) }\n                   else        {\n                       if signed { ConstICmp(IntSLE, te1, te2) }\n                       else      { ConstICmp(IntULE, te1, te2) }\n                   }\n               },\n-              ast::ne     => {\n+              ast::BiNe     => {\n                   if is_float { ConstFCmp(RealONE, te1, te2) }\n                   else        { ConstICmp(IntNE, te1, te2) }\n               },\n-              ast::ge     => {\n+              ast::BiGe     => {\n                   if is_float { ConstFCmp(RealOGE, te1, te2) }\n                   else        {\n                       if signed { ConstICmp(IntSGE, te1, te2) }\n                       else      { ConstICmp(IntUGE, te1, te2) }\n                   }\n               },\n-              ast::gt     => {\n+              ast::BiGt     => {\n                   if is_float { ConstFCmp(RealOGT, te1, te2) }\n                   else        {\n                       if signed { ConstICmp(IntSGT, te1, te2) }\n@@ -339,18 +339,18 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               },\n             };\n           },\n-          ast::expr_unary(_, u, e) => {\n+          ast::ExprUnary(_, u, e) => {\n             let te = const_expr(cx, e);\n             let ty = ty::expr_ty(cx.tcx, e);\n             let is_float = ty::type_is_fp(ty);\n             return match u {\n-              ast::box(_)  |\n-              ast::uniq |\n-              ast::deref  => {\n+              ast::UnBox(_)  |\n+              ast::UnUniq |\n+              ast::UnDeref  => {\n                 let (dv, _dt) = const_deref(cx, te, ty, true);\n                 dv\n               }\n-              ast::not    => {\n+              ast::UnNot    => {\n                 match ty::get(ty).sty {\n                     ty::ty_bool => {\n                         // Somewhat questionable, but I believe this is\n@@ -362,13 +362,13 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n                     _ => llvm::LLVMConstNot(te),\n                 }\n               }\n-              ast::neg    => {\n+              ast::UnNeg    => {\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }\n               }\n             }\n           }\n-          ast::expr_field(base, field, _) => {\n+          ast::ExprField(base, field, _) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n               let bv = const_expr(cx, base);\n@@ -378,7 +378,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               }\n           }\n \n-          ast::expr_index(_, base, index) => {\n+          ast::ExprIndex(_, base, index) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let bv = const_expr(cx, base);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n@@ -423,7 +423,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               }\n               const_get_elt(cx, arr, [iv as c_uint])\n           }\n-          ast::expr_cast(base, _) => {\n+          ast::ExprCast(base, _) => {\n             let ety = ty::expr_ty(cx.tcx, e);\n             let llty = type_of::type_of(cx, ety);\n             let basety = ty::expr_ty(cx.tcx, base);\n@@ -477,17 +477,17 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               }\n             }\n           }\n-          ast::expr_addr_of(ast::m_imm, sub) => {\n+          ast::ExprAddrOf(ast::MutImmutable, sub) => {\n               let e = const_expr(cx, sub);\n               const_addr_of(cx, e)\n           }\n-          ast::expr_tup(ref es) => {\n+          ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n               let vals = es.map(|&e| const_expr(cx, e));\n               adt::trans_const(cx, repr, 0, vals)\n           }\n-          ast::expr_struct(_, ref fs, ref base_opt) => {\n+          ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n               let tcx = cx.tcx;\n@@ -514,19 +514,19 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n                   adt::trans_const(cx, repr, discr, cs)\n               }\n           }\n-          ast::expr_vec(ref es, ast::m_imm) => {\n+          ast::ExprVec(ref es, ast::MutImmutable) => {\n             let (v, _, _) = const_vec(cx, e, *es);\n             v\n           }\n-          ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n+          ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n             match sub.node {\n-              ast::expr_lit(ref lit) => {\n+              ast::ExprLit(ref lit) => {\n                 match lit.node {\n                   ast::lit_str(*) => { const_expr(cx, sub) }\n                   _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n-              ast::expr_vec(ref es, ast::m_imm) => {\n+              ast::ExprVec(ref es, ast::MutImmutable) => {\n                 let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do \"const\".with_c_str |name| {\n@@ -541,7 +541,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n-          ast::expr_repeat(elem, count, _) => {\n+          ast::ExprRepeat(elem, count, _) => {\n             let vec_ty = ty::expr_ty(cx.tcx, e);\n             let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n             let llunitty = type_of::type_of(cx, unit_ty);\n@@ -558,13 +558,13 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n             };\n             v\n           }\n-          ast::expr_path(ref pth) => {\n+          ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n             assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n \n             let tcx = cx.tcx;\n             match tcx.def_map.find(&e.id) {\n-                Some(&ast::def_fn(def_id, _purity)) => {\n+                Some(&ast::DefFn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n@@ -573,18 +573,18 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n                         base::get_item_val(cx, def_id.node)\n                     }\n                 }\n-                Some(&ast::def_static(def_id, false)) => {\n+                Some(&ast::DefStatic(def_id, false)) => {\n                     get_const_val(cx, def_id)\n                 }\n-                Some(&ast::def_variant(enum_did, variant_did)) => {\n+                Some(&ast::DefVariant(enum_did, variant_did)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                          enum_did,\n                                                          variant_did);\n                     adt::trans_const(cx, repr, vinfo.disr_val, [])\n                 }\n-                Some(&ast::def_struct(_)) => {\n+                Some(&ast::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n                     C_null(llty)\n@@ -594,16 +594,16 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n                 }\n             }\n           }\n-          ast::expr_call(callee, ref args, _) => {\n+          ast::ExprCall(callee, ref args, _) => {\n               let tcx = cx.tcx;\n               match tcx.def_map.find(&callee.id) {\n-                  Some(&ast::def_struct(_)) => {\n+                  Some(&ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let arg_vals = args.map(|a| const_expr(cx, *a));\n                       adt::trans_const(cx, repr, 0, arg_vals)\n                   }\n-                  Some(&ast::def_variant(enum_did, variant_did)) => {\n+                  Some(&ast::DefVariant(enum_did, variant_did)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n@@ -615,22 +615,22 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n                   _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::expr_paren(e) => { return const_expr(cx, e); }\n+          ast::ExprParen(e) => { return const_expr(cx, e); }\n           _ => cx.sess.span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };\n     }\n }\n \n-pub fn trans_const(ccx: @mut CrateContext, m: ast::mutability, id: ast::NodeId) {\n+pub fn trans_const(ccx: @mut CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     unsafe {\n         let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n         let v = ccx.const_values.get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n-        if m != ast::m_mutbl {\n+        if m != ast::MutMutable {\n             llvm::LLVMSetGlobalConstant(g, True);\n         }\n     }"}, {"sha": "e7781e93d8ceca933e0c1a6a7fcb0fa24f44f3c1", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -53,19 +53,19 @@ pub struct CrateContext {\n      item_symbols: HashMap<ast::NodeId, ~str>,\n      link_meta: LinkMeta,\n      enum_sizes: HashMap<ty::t, uint>,\n-     discrims: HashMap<ast::def_id, ValueRef>,\n+     discrims: HashMap<ast::DefId, ValueRef>,\n      discrim_symbols: HashMap<ast::NodeId, @str>,\n      tydescs: HashMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n      finished_tydescs: bool,\n      // Track mapping of external ids to local items imported for inlining\n-     external: HashMap<ast::def_id, Option<ast::NodeId>>,\n+     external: HashMap<ast::DefId, Option<ast::NodeId>>,\n      // Cache instances of monomorphized functions\n      monomorphized: HashMap<mono_id, ValueRef>,\n-     monomorphizing: HashMap<ast::def_id, uint>,\n+     monomorphizing: HashMap<ast::DefId, uint>,\n      // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: HashMap<ast::def_id, @~[type_use::type_uses]>,\n+     type_use_cache: HashMap<ast::DefId, @~[type_use::type_uses]>,\n      // Cache generated vtables\n      vtables: HashMap<(ty::t, mono_id), ValueRef>,\n      // Cache of constant strings,\n@@ -85,9 +85,9 @@ pub struct CrateContext {\n      const_values: HashMap<ast::NodeId, ValueRef>,\n \n      // Cache of external const values\n-     extern_const_values: HashMap<ast::def_id, ValueRef>,\n+     extern_const_values: HashMap<ast::DefId, ValueRef>,\n \n-     impl_method_cache: HashMap<(ast::def_id, ast::Ident), ast::def_id>,\n+     impl_method_cache: HashMap<(ast::DefId, ast::Ident), ast::DefId>,\n \n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, Type>,"}, {"sha": "c3d5598d234cf17bbfcd75d89b43e5664212a964", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -50,9 +50,9 @@ pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Bl\n }\n \n pub fn trans_if(bcx: @mut Block,\n-            cond: @ast::expr,\n+            cond: @ast::Expr,\n             thn: &ast::Block,\n-            els: Option<@ast::expr>,\n+            els: Option<@ast::Expr>,\n             dest: expr::Dest)\n          -> @mut Block {\n     debug!(\"trans_if(bcx=%s, cond=%s, thn=%?, dest=%s)\",\n@@ -121,14 +121,14 @@ pub fn trans_if(bcx: @mut Block,\n     return next_bcx;\n \n     // trans `else [ if { .. } ... | { .. } ]`\n-    fn trans_if_else(else_bcx_in: @mut Block, elexpr: @ast::expr,\n+    fn trans_if_else(else_bcx_in: @mut Block, elexpr: @ast::Expr,\n                      dest: expr::Dest) -> @mut Block {\n         let else_bcx_out = match elexpr.node {\n-            ast::expr_if(_, _, _) => {\n+            ast::ExprIf(_, _, _) => {\n                 let elseif_blk = ast_util::block_from_expr(elexpr);\n                 trans_block(else_bcx_in, &elseif_blk, dest)\n             }\n-            ast::expr_block(ref blk) => {\n+            ast::ExprBlock(ref blk) => {\n                 trans_block(else_bcx_in, blk, dest)\n             }\n             // would be nice to have a constraint on ifs\n@@ -153,7 +153,7 @@ pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block\n     return out;\n }\n \n-pub fn trans_while(bcx: @mut Block, cond: @ast::expr, body: &ast::Block) -> @mut Block {\n+pub fn trans_while(bcx: @mut Block, cond: @ast::Expr, body: &ast::Block) -> @mut Block {\n     let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n@@ -206,10 +206,10 @@ pub fn trans_loop(bcx:@mut Block,\n     return next_bcx;\n }\n \n-pub fn trans_log(log_ex: &ast::expr,\n-                 lvl: @ast::expr,\n+pub fn trans_log(log_ex: &ast::Expr,\n+                 lvl: @ast::Expr,\n                  bcx: @mut Block,\n-                 e: @ast::expr) -> @mut Block {\n+                 e: @ast::Expr) -> @mut Block {\n     let _icx = push_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n@@ -334,7 +334,7 @@ pub fn trans_cont(bcx: @mut Block, label_opt: Option<Ident>) -> @mut Block {\n     return trans_break_cont(bcx, label_opt, false);\n }\n \n-pub fn trans_ret(bcx: @mut Block, e: Option<@ast::expr>) -> @mut Block {\n+pub fn trans_ret(bcx: @mut Block, e: Option<@ast::Expr>) -> @mut Block {\n     let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let dest = match bcx.fcx.llretptr {\n@@ -354,7 +354,7 @@ pub fn trans_ret(bcx: @mut Block, e: Option<@ast::expr>) -> @mut Block {\n \n pub fn trans_fail_expr(bcx: @mut Block,\n                        sp_opt: Option<Span>,\n-                       fail_expr: Option<@ast::expr>)\n+                       fail_expr: Option<@ast::Expr>)\n                     -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;"}, {"sha": "8ee38b950bf5232ef6c2527444b36fe46a2608a5", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -726,7 +726,7 @@ impl Datum {\n     }\n \n     /// expr: The deref expression.\n-    pub fn deref(&self, bcx: @mut Block, expr: &ast::expr, derefs: uint)\n+    pub fn deref(&self, bcx: @mut Block, expr: &ast::Expr, derefs: uint)\n                  -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },"}, {"sha": "71a9f4de4a0dbcb989fb8008f435967aa260a0fa", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -357,7 +357,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n-                ast::expr_fn_block(ref fn_decl, ref top_level_block) => {\n+                ast::ExprFnBlock(ref fn_decl, ref top_level_block) => {\n                     let name = gensym_name(\"fn\");\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n@@ -864,7 +864,7 @@ fn tuple_metadata(cx: &mut CrateContext,\n \n fn enum_metadata(cx: &mut CrateContext,\n                  enum_type: ty::t,\n-                 enum_def_id: ast::def_id,\n+                 enum_def_id: ast::DefId,\n                  span: Span)\n               -> DIType {\n \n@@ -1236,7 +1236,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n \n     assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n \n-    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_imm });\n+    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::MutImmutable });\n \n     let member_type_metadata = &[type_metadata(cx, data_ptr_type, span),\n                                  type_metadata(cx, ty::mk_uint(), span)];\n@@ -1531,7 +1531,7 @@ fn assert_fcx_has_span(fcx: &FunctionContext) {\n // descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n // shadowing.\n fn populate_scope_map(cx: &mut CrateContext,\n-                      arg_pats: &[@ast::pat],\n+                      arg_pats: &[@ast::Pat],\n                       fn_entry_block: Option<&ast::Block>,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -1608,10 +1608,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n             scope_map.insert(ast_util::stmt_id(statement), scope_stack.last().scope_metadata);\n \n             match statement.node {\n-                ast::stmt_decl(@ref decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n-                ast::stmt_expr(@ref exp, _) |\n-                ast::stmt_semi(@ref exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n-                ast::stmt_mac(*) => () // ignore macros (which should be expanded anyway)\n+                ast::StmtDecl(@ref decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n+                ast::StmtExpr(@ref exp, _) |\n+                ast::StmtSemi(@ref exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n+                ast::StmtMac(*) => () // ignore macros (which should be expanded anyway)\n             }\n         }\n \n@@ -1621,11 +1621,11 @@ fn populate_scope_map(cx: &mut CrateContext,\n     }\n \n     fn walk_decl(cx: &mut CrateContext,\n-                 decl: &ast::decl,\n+                 decl: &ast::Decl,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n-            codemap::Spanned { node: ast::decl_local(@ref local), _ } => {\n+            codemap::Spanned { node: ast::DeclLocal(@ref local), _ } => {\n                 scope_map.insert(local.id, scope_stack.last().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n@@ -1639,7 +1639,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n     }\n \n     fn walk_pattern(cx: &mut CrateContext,\n-                    pat: @ast::pat,\n+                    pat: @ast::Pat,\n                     scope_stack: &mut ~[ScopeStackEntry],\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n@@ -1649,7 +1649,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         // because we have to visit *all* nodes in order to put them into the scope map. The above\n         // functions don't do that.\n         match pat.node {\n-            ast::pat_ident(_, ref path_ref, ref sub_pat_opt) => {\n+            ast::PatIdent(_, ref path_ref, ref sub_pat_opt) => {\n \n                 // Check if this is a binding. If so we need to put it on the scope stack and maybe\n                 // introduce an articial scope\n@@ -1716,11 +1716,11 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::pat_wild => {\n+            ast::PatWild => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n             }\n \n-            ast::pat_enum(_, ref sub_pats_opt) => {\n+            ast::PatEnum(_, ref sub_pats_opt) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n \n                 for ref sub_pats in sub_pats_opt.iter() {\n@@ -1730,41 +1730,41 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::pat_struct(_, ref field_pats, _) => {\n+            ast::PatStruct(_, ref field_pats, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n \n-                for &ast::field_pat { pat: sub_pat, _ } in field_pats.iter() {\n+                for &ast::FieldPat { pat: sub_pat, _ } in field_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::pat_tup(ref sub_pats) => {\n+            ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n \n                 for &sub_pat in sub_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::pat_box(sub_pat)    |\n-            ast::pat_uniq(sub_pat)   |\n-            ast::pat_region(sub_pat) => {\n+            ast::PatBox(sub_pat)    |\n+            ast::PatUniq(sub_pat)   |\n+            ast::PatRegion(sub_pat) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n                 walk_pattern(cx, sub_pat, scope_stack, scope_map);\n             }\n \n-            ast::pat_lit(@ref exp) => {\n+            ast::PatLit(@ref exp) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, exp, scope_stack, scope_map);\n             }\n \n-            ast::pat_range(@ref exp1, @ref exp2) => {\n+            ast::PatRange(@ref exp1, @ref exp2) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, exp1, scope_stack, scope_map);\n                 walk_expr(cx, exp2, scope_stack, scope_map);\n             }\n \n-            ast::pat_vec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+            ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n \n                 for &sub_pat in front_sub_pats.iter() {\n@@ -1783,58 +1783,58 @@ fn populate_scope_map(cx: &mut CrateContext,\n     }\n \n     fn walk_expr(cx: &mut CrateContext,\n-                 exp: &ast::expr,\n+                 exp: &ast::Expr,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n         scope_map.insert(exp.id, scope_stack.last().scope_metadata);\n \n         match exp.node {\n-            ast::expr_self     |\n-            ast::expr_lit(_)   |\n-            ast::expr_break(_) |\n-            ast::expr_again(_) |\n-            ast::expr_path(_)  => (),\n-\n-            ast::expr_vstore(@ref sub_exp, _)   |\n-            ast::expr_cast(@ref sub_exp, _)     |\n-            ast::expr_addr_of(_, @ref sub_exp)  |\n-            ast::expr_field(@ref sub_exp, _, _) |\n-            ast::expr_paren(@ref sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n-\n-            ast::expr_ret(exp_opt) => match exp_opt {\n+            ast::ExprSelf     |\n+            ast::ExprLit(_)   |\n+            ast::ExprBreak(_) |\n+            ast::ExprAgain(_) |\n+            ast::ExprPath(_)  => (),\n+\n+            ast::ExprVstore(@ref sub_exp, _)   |\n+            ast::ExprCast(@ref sub_exp, _)     |\n+            ast::ExprAddrOf(_, @ref sub_exp)  |\n+            ast::ExprField(@ref sub_exp, _, _) |\n+            ast::ExprParen(@ref sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+\n+            ast::ExprRet(exp_opt) => match exp_opt {\n                 Some(@ref sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n                 None => ()\n             },\n \n-            ast::expr_unary(node_id, _, @ref sub_exp) => {\n+            ast::ExprUnary(node_id, _, @ref sub_exp) => {\n                 scope_map.insert(node_id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, sub_exp, scope_stack, scope_map);\n             }\n \n-            ast::expr_assign_op(node_id, _, @ref lhs, @ref rhs) |\n-            ast::expr_index(node_id, @ref lhs, @ref rhs)        |\n-            ast::expr_binary(node_id, _, @ref lhs, @ref rhs)    => {\n+            ast::ExprAssignOp(node_id, _, @ref lhs, @ref rhs) |\n+            ast::ExprIndex(node_id, @ref lhs, @ref rhs)        |\n+            ast::ExprBinary(node_id, _, @ref lhs, @ref rhs)    => {\n                 scope_map.insert(node_id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, lhs, scope_stack, scope_map);\n                 walk_expr(cx, rhs, scope_stack, scope_map);\n             }\n \n-            ast::expr_vec(ref init_expressions, _) |\n-            ast::expr_tup(ref init_expressions)    => {\n+            ast::ExprVec(ref init_expressions, _) |\n+            ast::ExprTup(ref init_expressions)    => {\n                 for &@ref ie in init_expressions.iter() {\n                     walk_expr(cx, ie, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::expr_assign(@ref sub_exp1, @ref sub_exp2)    |\n-            ast::expr_log(@ref sub_exp1, @ref sub_exp2)       |\n-            ast::expr_repeat(@ref sub_exp1, @ref sub_exp2, _) => {\n+            ast::ExprAssign(@ref sub_exp1, @ref sub_exp2)    |\n+            ast::ExprLog(@ref sub_exp1, @ref sub_exp2)       |\n+            ast::ExprRepeat(@ref sub_exp1, @ref sub_exp2, _) => {\n                 walk_expr(cx, sub_exp1, scope_stack, scope_map);\n                 walk_expr(cx, sub_exp2, scope_stack, scope_map);\n             }\n \n-            ast::expr_if(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n+            ast::ExprIf(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n                 do with_new_scope(cx, then_block.span, scope_stack, scope_map) |cx,\n@@ -1849,7 +1849,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::expr_while(@ref cond_exp, ref loop_body) => {\n+            ast::ExprWhile(@ref cond_exp, ref loop_body) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n                 do with_new_scope(cx, loop_body.span, scope_stack, scope_map) |cx,\n@@ -1859,26 +1859,26 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::expr_for_loop(_, _, _) => {\n+            ast::ExprForLoop(_, _, _) => {\n                 cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                             Found unexpanded for-loop.\");\n             }\n \n-            ast::expr_mac(_) => {\n+            ast::ExprMac(_) => {\n                 cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n                                             Found unexpanded macro.\");\n             }\n \n-            ast::expr_loop(ref block, _) |\n-            ast::expr_block(ref block)   => {\n+            ast::ExprLoop(ref block, _) |\n+            ast::ExprBlock(ref block)   => {\n                 do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n                                                                            scope_stack,\n                                                                            scope_map| {\n                     walk_block(cx, block, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::expr_fn_block(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n+            ast::ExprFnBlock(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n                 do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n                                                                            scope_stack,\n                                                                            scope_map| {\n@@ -1891,9 +1891,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n             }\n \n             // ast::expr_loop_body(@ref inner_exp) |\n-            ast::expr_do_body(@ref inner_exp)   => {\n+            ast::ExprDoBody(@ref inner_exp)   => {\n                 let inner_expr_is_expr_fn_block = match *inner_exp {\n-                    ast::expr { node: ast::expr_fn_block(*), _ } => true,\n+                    ast::Expr { node: ast::ExprFnBlock(*), _ } => true,\n                     _ => false\n                 };\n \n@@ -1905,15 +1905,15 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 walk_expr(cx, inner_exp, scope_stack, scope_map);\n             }\n \n-            ast::expr_call(@ref fn_exp, ref args, _) => {\n+            ast::ExprCall(@ref fn_exp, ref args, _) => {\n                 walk_expr(cx, fn_exp, scope_stack, scope_map);\n \n                 for &@ref arg_exp in args.iter() {\n                     walk_expr(cx, arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::expr_method_call(node_id, @ref receiver_exp, _, _, ref args, _) => {\n+            ast::ExprMethodCall(node_id, @ref receiver_exp, _, _, ref args, _) => {\n                 scope_map.insert(node_id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, receiver_exp, scope_stack, scope_map);\n \n@@ -1922,7 +1922,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::expr_match(@ref discriminant_exp, ref arms) => {\n+            ast::ExprMatch(@ref discriminant_exp, ref arms) => {\n                 walk_expr(cx, discriminant_exp, scope_stack, scope_map);\n \n                 // for each arm we have to first walk the pattern as these might introduce new\n@@ -1948,7 +1948,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::expr_struct(_, ref fields, ref base_exp) => {\n+            ast::ExprStruct(_, ref fields, ref base_exp) => {\n                 for &ast::Field { expr: @ref exp, _ } in fields.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n@@ -1959,7 +1959,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 }\n             }\n \n-            ast::expr_inline_asm(ast::inline_asm { inputs: ref inputs,\n+            ast::ExprInlineAsm(ast::inline_asm { inputs: ref inputs,\n                                                    outputs: ref outputs,\n                                                    _ }) => {\n                 // inputs, outputs: ~[(@str, @expr)]"}, {"sha": "91f26b25865cb3833133201f870834637b933294", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 128, "deletions": 128, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -178,7 +178,7 @@ fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n     return bcx;\n }\n \n-pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n+pub fn trans_to_datum(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n@@ -249,7 +249,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n     fn auto_slice(bcx: @mut Block,\n                   autoderefs: uint,\n-                  expr: &ast::expr,\n+                  expr: &ast::Expr,\n                   datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n@@ -266,7 +266,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n         let slice_ty = ty::mk_evec(tcx,\n-                                   ty::mt { ty: unit_ty, mutbl: ast::m_imm },\n+                                   ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n                                    ty::vstore_slice(ty::re_static));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n@@ -275,7 +275,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn add_env(bcx: @mut Block, expr: &ast::expr, datum: Datum) -> DatumBlock {\n+    fn add_env(bcx: @mut Block, expr: &ast::Expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -296,15 +296,15 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n     fn auto_slice_and_ref(bcx: @mut Block,\n                           autoderefs: uint,\n-                          expr: &ast::expr,\n+                          expr: &ast::Expr,\n                           datum: Datum) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n \n     fn auto_borrow_obj(mut bcx: @mut Block,\n                        autoderefs: uint,\n-                       expr: @ast::expr,\n+                       expr: @ast::Expr,\n                        source_datum: Datum) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n@@ -395,7 +395,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n+pub fn trans_into(bcx: @mut Block, expr: @ast::Expr, dest: Dest) -> @mut Block {\n     if bcx.tcx().adjustments.contains_key(&expr.id) {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n@@ -453,7 +453,7 @@ pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n     };\n }\n \n-fn trans_lvalue(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n+fn trans_lvalue(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -472,7 +472,7 @@ fn trans_lvalue(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     };\n }\n \n-fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n+fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     /*!\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n@@ -538,44 +538,44 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n+fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n-        ast::expr_path(_) | ast::expr_self => {\n+        ast::ExprPath(_) | ast::ExprSelf => {\n             return trans_def_datum_unadjusted(bcx, expr, bcx.def(expr.id));\n         }\n-        ast::expr_vstore(contents, ast::expr_vstore_box) |\n-        ast::expr_vstore(contents, ast::expr_vstore_mut_box) => {\n+        ast::ExprVstore(contents, ast::ExprVstoreBox) |\n+        ast::ExprVstore(contents, ast::ExprVstoreMutBox) => {\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n                                                       expr, contents);\n         }\n-        ast::expr_vstore(contents, ast::expr_vstore_uniq) => {\n+        ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n             let heap = heap_for_unique(bcx, expr_ty(bcx, contents));\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n                                                       expr, contents);\n         }\n-        ast::expr_lit(lit) => {\n+        ast::ExprLit(lit) => {\n             return trans_immediate_lit(bcx, expr, *lit);\n         }\n-        ast::expr_binary(_, op, lhs, rhs) => {\n+        ast::ExprBinary(_, op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n             assert!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n-        ast::expr_unary(_, op, x) => {\n+        ast::ExprUnary(_, op, x) => {\n             return trans_unary_datum(bcx, expr, op, x);\n         }\n-        ast::expr_addr_of(_, x) => {\n+        ast::ExprAddrOf(_, x) => {\n             return trans_addr_of(bcx, expr, x);\n         }\n-        ast::expr_cast(val, _) => {\n+        ast::ExprCast(val, _) => {\n             return trans_imm_cast(bcx, val, expr.id);\n         }\n-        ast::expr_paren(e) => {\n+        ast::ExprParen(e) => {\n             return trans_rvalue_datum_unadjusted(bcx, e);\n         }\n         _ => {\n@@ -588,7 +588,7 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBloc\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::expr) -> @mut Block {\n+fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> @mut Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -599,39 +599,39 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::expr) -> @mut Block\n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n-        ast::expr_break(label_opt) => {\n+        ast::ExprBreak(label_opt) => {\n             return controlflow::trans_break(bcx, label_opt);\n         }\n-        ast::expr_again(label_opt) => {\n+        ast::ExprAgain(label_opt) => {\n             return controlflow::trans_cont(bcx, label_opt);\n         }\n-        ast::expr_ret(ex) => {\n+        ast::ExprRet(ex) => {\n             return controlflow::trans_ret(bcx, ex);\n         }\n-        ast::expr_log(lvl, a) => {\n+        ast::ExprLog(lvl, a) => {\n             return controlflow::trans_log(expr, lvl, bcx, a);\n         }\n-        ast::expr_while(cond, ref body) => {\n+        ast::ExprWhile(cond, ref body) => {\n             return controlflow::trans_while(bcx, cond, body);\n         }\n-        ast::expr_loop(ref body, opt_label) => {\n+        ast::ExprLoop(ref body, opt_label) => {\n             return controlflow::trans_loop(bcx, body, opt_label);\n         }\n-        ast::expr_assign(dst, src) => {\n+        ast::ExprAssign(dst, src) => {\n             let src_datum = unpack_datum!(\n                 bcx, trans_to_datum(bcx, src));\n             let dst_datum = unpack_datum!(\n                 bcx, trans_lvalue(bcx, dst));\n             return src_datum.store_to_datum(\n                 bcx, DROP_EXISTING, dst_datum);\n         }\n-        ast::expr_assign_op(callee_id, op, dst, src) => {\n+        ast::ExprAssignOp(callee_id, op, dst, src) => {\n             return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n         }\n-        ast::expr_paren(a) => {\n+        ast::ExprParen(a) => {\n             return trans_rvalue_stmt_unadjusted(bcx, a);\n         }\n-        ast::expr_inline_asm(ref a) => {\n+        ast::ExprInlineAsm(ref a) => {\n             return asm::trans_inline_asm(bcx, a);\n         }\n         _ => {\n@@ -644,53 +644,53 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::expr) -> @mut Block\n     };\n }\n \n-fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n+fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::Expr,\n                                dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n-        ast::expr_paren(e) => {\n+        ast::ExprParen(e) => {\n             return trans_rvalue_dps_unadjusted(bcx, e, dest);\n         }\n-        ast::expr_path(_) | ast::expr_self => {\n+        ast::ExprPath(_) | ast::ExprSelf => {\n             return trans_def_dps_unadjusted(bcx, expr,\n                                             bcx.def(expr.id), dest);\n         }\n-        ast::expr_if(cond, ref thn, els) => {\n+        ast::ExprIf(cond, ref thn, els) => {\n             return controlflow::trans_if(bcx, cond, thn, els, dest);\n         }\n-        ast::expr_match(discr, ref arms) => {\n+        ast::ExprMatch(discr, ref arms) => {\n             return _match::trans_match(bcx, expr, discr, *arms, dest);\n         }\n-        ast::expr_block(ref blk) => {\n+        ast::ExprBlock(ref blk) => {\n             return do base::with_scope(bcx, blk.info(),\n                                        \"block-expr body\") |bcx| {\n                 controlflow::trans_block(bcx, blk, dest)\n             };\n         }\n-        ast::expr_struct(_, ref fields, base) => {\n+        ast::ExprStruct(_, ref fields, base) => {\n             return trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest);\n         }\n-        ast::expr_tup(ref args) => {\n+        ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            let numbered_fields: ~[(uint, @ast::expr)] =\n+            let numbered_fields: ~[(uint, @ast::Expr)] =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n-        ast::expr_lit(@codemap::Spanned {node: ast::lit_str(s), _}) => {\n+        ast::ExprLit(@codemap::Spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n-        ast::expr_vstore(contents, ast::expr_vstore_slice) |\n-        ast::expr_vstore(contents, ast::expr_vstore_mut_slice) => {\n+        ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n+        ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {\n             return tvec::trans_slice_vstore(bcx, expr, contents, dest);\n         }\n-        ast::expr_vec(*) | ast::expr_repeat(*) => {\n+        ast::ExprVec(*) | ast::ExprRepeat(*) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n-        ast::expr_fn_block(ref decl, ref body) => {\n+        ast::ExprFnBlock(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             debug!(\"translating fn_block %s with type %s\",\n@@ -699,22 +699,22 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n             return closure::trans_expr_fn(bcx, sigil, decl, body,\n                                           expr.id, expr.id, dest);\n         }\n-        ast::expr_do_body(blk) => {\n+        ast::ExprDoBody(blk) => {\n             return trans_into(bcx, blk, dest);\n         }\n-        ast::expr_call(f, ref args, _) => {\n+        ast::ExprCall(f, ref args, _) => {\n             return callee::trans_call(\n                 bcx, expr, f, callee::ArgExprs(*args), expr.id, dest);\n         }\n-        ast::expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n+        ast::ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => {\n             return callee::trans_method_call(bcx,\n                                              expr,\n                                              callee_id,\n                                              rcvr,\n                                              callee::ArgExprs(*args),\n                                              dest);\n         }\n-        ast::expr_binary(callee_id, _, lhs, rhs) => {\n+        ast::ExprBinary(callee_id, _, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx,\n                                        expr,\n@@ -724,7 +724,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n                                        expr_ty(bcx, expr),\n                                        dest);\n         }\n-        ast::expr_unary(callee_id, _, subexpr) => {\n+        ast::ExprUnary(callee_id, _, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx,\n                                        expr,\n@@ -734,7 +734,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n                                        expr_ty(bcx, expr),\n                                        dest);\n         }\n-        ast::expr_index(callee_id, base, idx) => {\n+        ast::ExprIndex(callee_id, base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx,\n                                        expr,\n@@ -744,7 +744,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n                                        expr_ty(bcx, expr),\n                                        dest);\n         }\n-        ast::expr_cast(val, _) => {\n+        ast::ExprCast(val, _) => {\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n                 ty::ty_trait(_, _, store, _, _) => {\n                     return meth::trans_trait_cast(bcx, val, expr.id, dest,\n@@ -756,7 +756,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n                 }\n             }\n         }\n-        ast::expr_assign_op(callee_id, op, dst, src) => {\n+        ast::ExprAssignOp(callee_id, op, dst, src) => {\n             return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n         }\n         _ => {\n@@ -768,8 +768,8 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n     }\n }\n \n-fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::expr,\n-                            def: ast::def, dest: Dest) -> @mut Block {\n+fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n+                            def: ast::Def, dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n@@ -779,7 +779,7 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::expr,\n     };\n \n     match def {\n-        ast::def_variant(tid, vid) => {\n+        ast::DefVariant(tid, vid) => {\n             let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n@@ -795,7 +795,7 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::expr,\n                 return bcx;\n             }\n         }\n-        ast::def_struct(def_id) => {\n+        ast::DefStruct(def_id) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(ccx.tcx, did) => {\n@@ -819,17 +819,17 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::expr,\n }\n \n fn trans_def_datum_unadjusted(bcx: @mut Block,\n-                              ref_expr: &ast::expr,\n-                              def: ast::def) -> DatumBlock\n+                              ref_expr: &ast::Expr,\n+                              def: ast::Def) -> DatumBlock\n {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let fn_data = match def {\n-        ast::def_fn(did, _) |\n-        ast::def_static_method(did, ast::FromImpl(_), _) => {\n+        ast::DefFn(did, _) |\n+        ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n             callee::trans_fn_ref(bcx, did, ref_expr.id)\n         }\n-        ast::def_static_method(impl_did, ast::FromTrait(trait_did), _) => {\n+        ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n             meth::trans_static_method_callee(bcx,\n                                              impl_did,\n                                              trait_did,\n@@ -853,7 +853,7 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n     }\n }\n \n-fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n+fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -868,19 +868,19 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     return match expr.node {\n-        ast::expr_paren(e) => {\n+        ast::ExprParen(e) => {\n             trans_lvalue_unadjusted(bcx, e)\n         }\n-        ast::expr_path(_) | ast::expr_self => {\n+        ast::ExprPath(_) | ast::ExprSelf => {\n             trans_def_lvalue(bcx, expr, bcx.def(expr.id))\n         }\n-        ast::expr_field(base, ident, _) => {\n+        ast::ExprField(base, ident, _) => {\n             trans_rec_field(bcx, base, ident)\n         }\n-        ast::expr_index(_, base, idx) => {\n+        ast::ExprIndex(_, base, idx) => {\n             trans_index(bcx, expr, base, idx)\n         }\n-        ast::expr_unary(_, ast::deref, base) => {\n+        ast::ExprUnary(_, ast::UnDeref, base) => {\n             let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n             basedatum.deref(bcx, expr, 0)\n         }\n@@ -893,7 +893,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     };\n \n     fn trans_rec_field(bcx: @mut Block,\n-                       base: @ast::expr,\n+                       base: @ast::Expr,\n                        field: ast::Ident) -> DatumBlock {\n         //! Translates `base.field`.\n \n@@ -916,9 +916,9 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     }\n \n     fn trans_index(bcx: @mut Block,\n-                   index_expr: &ast::expr,\n-                   base: @ast::expr,\n-                   idx: @ast::expr) -> DatumBlock {\n+                   index_expr: &ast::Expr,\n+                   base: @ast::Expr,\n+                   idx: @ast::Expr) -> DatumBlock {\n         //! Translates `base[idx]`.\n \n         let _icx = push_ctxt(\"trans_index\");\n@@ -973,18 +973,18 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     }\n \n     fn trans_def_lvalue(bcx: @mut Block,\n-                        ref_expr: &ast::expr,\n-                        def: ast::def)\n+                        ref_expr: &ast::Expr,\n+                        def: ast::Def)\n         -> DatumBlock\n     {\n         //! Translates a reference to a path.\n \n         let _icx = push_ctxt(\"trans_def_lvalue\");\n         match def {\n-            ast::def_static(did, _) => {\n+            ast::DefStatic(did, _) => {\n                 let const_ty = expr_ty(bcx, ref_expr);\n \n-                fn get_val(bcx: @mut Block, did: ast::def_id, const_ty: ty::t)\n+                fn get_val(bcx: @mut Block, did: ast::DefId, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n                     if did.crate == ast::LOCAL_CRATE {\n@@ -1041,11 +1041,11 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n+pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n-        ast::def_upvar(nid, _, _, _) => {\n+        ast::DefUpvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.find(&nid) {\n@@ -1062,13 +1062,13 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n                 }\n             }\n         }\n-        ast::def_arg(nid, _) => {\n+        ast::DefArg(nid, _) => {\n             take_local(bcx, bcx.fcx.llargs, nid)\n         }\n-        ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n+        ast::DefLocal(nid, _) | ast::DefBinding(nid, _) => {\n             take_local(bcx, bcx.fcx.lllocals, nid)\n         }\n-        ast::def_self(nid) => {\n+        ast::DefSelf(nid) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n                 Some(ref self_info) => *self_info,\n                 None => {\n@@ -1137,7 +1137,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                 }\n                 Some(node_id) => {\n                     match tcx.def_map.get_copy(&node_id) {\n-                        ast::def_variant(enum_id, variant_id) => {\n+                        ast::DefVariant(enum_id, variant_id) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n                             op(variant_info.disr_val,\n@@ -1162,7 +1162,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n \n fn trans_rec_or_struct(bcx: @mut Block,\n                        fields: &[ast::Field],\n-                       base: Option<@ast::expr>,\n+                       base: Option<@ast::Expr>,\n                        expr_span: codemap::Span,\n                        id: ast::NodeId,\n                        dest: Dest) -> @mut Block\n@@ -1222,7 +1222,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n  */\n struct StructBaseInfo {\n     /// The base expression; will be evaluated after all explicit fields.\n-    expr: @ast::expr,\n+    expr: @ast::Expr,\n     /// The indices of fields to copy paired with their types.\n     fields: ~[(uint, ty::t)]\n }\n@@ -1238,7 +1238,7 @@ struct StructBaseInfo {\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n-             fields: &[(uint, @ast::expr)],\n+             fields: &[(uint, @ast::Expr)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_adt\");\n@@ -1285,7 +1285,7 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n }\n \n \n-fn trans_immediate_lit(bcx: @mut Block, expr: @ast::expr,\n+fn trans_immediate_lit(bcx: @mut Block, expr: @ast::Expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n@@ -1294,13 +1294,13 @@ fn trans_immediate_lit(bcx: @mut Block, expr: @ast::expr,\n }\n \n fn trans_unary_datum(bcx: @mut Block,\n-                     un_expr: &ast::expr,\n-                     op: ast::unop,\n-                     sub_expr: @ast::expr) -> DatumBlock {\n+                     un_expr: &ast::Expr,\n+                     op: ast::UnOp,\n+                     sub_expr: @ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n-    assert!(op != ast::deref);\n+    assert!(op != ast::UnDeref);\n \n     // if overloaded, would be RvalueDpsExpr\n     assert!(!bcx.ccx().maps.method_map.contains_key(&un_expr.id));\n@@ -1309,7 +1309,7 @@ fn trans_unary_datum(bcx: @mut Block,\n     let sub_ty = expr_ty(bcx, sub_expr);\n \n     return match op {\n-        ast::not => {\n+        ast::UnNot => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n \n             // If this is a boolean type, we must not use the LLVM Not\n@@ -1327,7 +1327,7 @@ fn trans_unary_datum(bcx: @mut Block,\n             };\n             immediate_rvalue_bcx(bcx, llresult, un_ty)\n         }\n-        ast::neg => {\n+        ast::UnNeg => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n             let llneg = {\n                 if ty::type_is_fp(un_ty) {\n@@ -1338,15 +1338,15 @@ fn trans_unary_datum(bcx: @mut Block,\n             };\n             immediate_rvalue_bcx(bcx, llneg, un_ty)\n         }\n-        ast::box(_) => {\n+        ast::UnBox(_) => {\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty,\n                              heap_managed)\n         }\n-        ast::uniq => {\n+        ast::UnUniq => {\n             let heap  = heap_for_unique(bcx, un_ty);\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap)\n         }\n-        ast::deref => {\n+        ast::UnDeref => {\n             bcx.sess().bug(\"deref expressions should have been \\\n                             translated using trans_lvalue(), not \\\n                             trans_unary_datum()\")\n@@ -1355,7 +1355,7 @@ fn trans_unary_datum(bcx: @mut Block,\n \n     fn trans_boxed_expr(bcx: @mut Block,\n                         box_ty: ty::t,\n-                        contents: @ast::expr,\n+                        contents: @ast::Expr,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n@@ -1379,8 +1379,8 @@ fn trans_unary_datum(bcx: @mut Block,\n     }\n }\n \n-fn trans_addr_of(bcx: @mut Block, expr: &ast::expr,\n-                 subexpr: @ast::expr) -> DatumBlock {\n+fn trans_addr_of(bcx: @mut Block, expr: &ast::Expr,\n+                 subexpr: @ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n@@ -1391,9 +1391,9 @@ fn trans_addr_of(bcx: @mut Block, expr: &ast::expr,\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n fn trans_eager_binop(bcx: @mut Block,\n-                     binop_expr: &ast::expr,\n+                     binop_expr: &ast::Expr,\n                      binop_ty: ty::t,\n-                     op: ast::binop,\n+                     op: ast::BinOp,\n                      lhs_datum: &Datum,\n                      rhs_datum: &Datum)\n                   -> DatumBlock {\n@@ -1420,19 +1420,19 @@ fn trans_eager_binop(bcx: @mut Block,\n \n     let mut bcx = bcx;\n     let val = match op {\n-      ast::add => {\n+      ast::BiAdd => {\n         if is_float { FAdd(bcx, lhs, rhs) }\n         else { Add(bcx, lhs, rhs) }\n       }\n-      ast::subtract => {\n+      ast::BiSub => {\n         if is_float { FSub(bcx, lhs, rhs) }\n         else { Sub(bcx, lhs, rhs) }\n       }\n-      ast::mul => {\n+      ast::BiMul => {\n         if is_float { FMul(bcx, lhs, rhs) }\n         else { Mul(bcx, lhs, rhs) }\n       }\n-      ast::div => {\n+      ast::BiDiv => {\n         if is_float {\n             FDiv(bcx, lhs, rhs)\n         } else {\n@@ -1446,7 +1446,7 @@ fn trans_eager_binop(bcx: @mut Block,\n             }\n         }\n       }\n-      ast::rem => {\n+      ast::BiRem => {\n         if is_float {\n             FRem(bcx, lhs, rhs)\n         } else {\n@@ -1460,16 +1460,16 @@ fn trans_eager_binop(bcx: @mut Block,\n             }\n         }\n       }\n-      ast::bitor => Or(bcx, lhs, rhs),\n-      ast::bitand => And(bcx, lhs, rhs),\n-      ast::bitxor => Xor(bcx, lhs, rhs),\n-      ast::shl => Shl(bcx, lhs, rhs),\n-      ast::shr => {\n+      ast::BiBitOr => Or(bcx, lhs, rhs),\n+      ast::BiBitAnd => And(bcx, lhs, rhs),\n+      ast::BiBitXor => Xor(bcx, lhs, rhs),\n+      ast::BiShl => Shl(bcx, lhs, rhs),\n+      ast::BiShr => {\n         if signed {\n             AShr(bcx, lhs, rhs)\n         } else { LShr(bcx, lhs, rhs) }\n       }\n-      ast::eq | ast::ne | ast::lt | ast::ge | ast::le | ast::gt => {\n+      ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_bot(rhs_t) {\n             C_bool(false)\n         } else {\n@@ -1494,10 +1494,10 @@ fn trans_eager_binop(bcx: @mut Block,\n enum lazy_binop_ty { lazy_and, lazy_or }\n \n fn trans_lazy_binop(bcx: @mut Block,\n-                    binop_expr: &ast::expr,\n+                    binop_expr: &ast::Expr,\n                     op: lazy_binop_ty,\n-                    a: @ast::expr,\n-                    b: @ast::expr) -> DatumBlock {\n+                    a: @ast::Expr,\n+                    b: @ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let bcx = bcx;\n@@ -1539,18 +1539,18 @@ fn trans_lazy_binop(bcx: @mut Block,\n }\n \n fn trans_binary(bcx: @mut Block,\n-                binop_expr: &ast::expr,\n-                op: ast::binop,\n-                lhs: @ast::expr,\n-                rhs: @ast::expr) -> DatumBlock\n+                binop_expr: &ast::Expr,\n+                op: ast::BinOp,\n+                lhs: @ast::Expr,\n+                rhs: @ast::Expr) -> DatumBlock\n {\n     let _icx = push_ctxt(\"trans_binary\");\n \n     match op {\n-        ast::and => {\n+        ast::BiAnd => {\n             trans_lazy_binop(bcx, binop_expr, lazy_and, lhs, rhs)\n         }\n-        ast::or => {\n+        ast::BiOr => {\n             trans_lazy_binop(bcx, binop_expr, lazy_or, lhs, rhs)\n         }\n         _ => {\n@@ -1565,10 +1565,10 @@ fn trans_binary(bcx: @mut Block,\n }\n \n fn trans_overloaded_op(bcx: @mut Block,\n-                       expr: &ast::expr,\n+                       expr: &ast::Expr,\n                        callee_id: ast::NodeId,\n-                       rcvr: @ast::expr,\n-                       args: ~[@ast::expr],\n+                       rcvr: @ast::Expr,\n+                       args: ~[@ast::Expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> @mut Block {\n@@ -1642,7 +1642,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast(bcx: @mut Block, expr: @ast::expr,\n+fn trans_imm_cast(bcx: @mut Block, expr: @ast::Expr,\n                   id: ast::NodeId) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n@@ -1711,11 +1711,11 @@ fn trans_imm_cast(bcx: @mut Block, expr: @ast::expr,\n }\n \n fn trans_assign_op(bcx: @mut Block,\n-                   expr: @ast::expr,\n+                   expr: @ast::Expr,\n                    callee_id: ast::NodeId,\n-                   op: ast::binop,\n-                   dst: @ast::expr,\n-                   src: @ast::expr) -> @mut Block\n+                   op: ast::BinOp,\n+                   dst: @ast::Expr,\n+                   src: @ast::Expr) -> @mut Block\n {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;"}, {"sha": "a305e3aa6b8b37063437c42b0498fb4cdd916c7b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -400,8 +400,8 @@ pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     }\n }\n \n-pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n-                              class_did: ast::def_id, substs: &ty::substs) -> @mut Block {\n+pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+                              class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n@@ -438,8 +438,8 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n     }\n }\n \n-pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n-                         class_did: ast::def_id, substs: &ty::substs) -> @mut Block {\n+pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+                         class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor"}, {"sha": "cfc9c8a2e17cf3c1f2690f4e4642191c5b4e3b9d", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -22,8 +22,8 @@ use syntax::ast;\n use syntax::ast_map::path_name;\n use syntax::ast_util::local_def;\n \n-pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id)\n-    -> ast::def_id {\n+pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n+    -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(&fn_id) {\n         Some(&Some(node_id)) => {"}, {"sha": "76cb943c6ed75334964a76410f8bd615a71a823b", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -138,7 +138,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n }\n \n pub fn trans_self_arg(bcx: @mut Block,\n-                      base: @ast::expr,\n+                      base: @ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n     let _icx = push_ctxt(\"impl::trans_self_arg\");\n@@ -155,7 +155,7 @@ pub fn trans_self_arg(bcx: @mut Block,\n \n pub fn trans_method_callee(bcx: @mut Block,\n                            callee_id: ast::NodeId,\n-                           this: @ast::expr,\n+                           this: @ast::Expr,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n@@ -212,8 +212,8 @@ pub fn trans_method_callee(bcx: @mut Block,\n }\n \n pub fn trans_static_method_callee(bcx: @mut Block,\n-                                  method_id: ast::def_id,\n-                                  trait_id: ast::def_id,\n+                                  method_id: ast::DefId,\n+                                  trait_id: ast::DefId,\n                                   callee_id: ast::NodeId)\n                                -> FnData {\n     let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n@@ -293,8 +293,8 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n }\n \n pub fn method_with_name(ccx: &mut CrateContext,\n-                        impl_id: ast::def_id,\n-                        name: ast::Ident) -> ast::def_id {\n+                        impl_id: ast::DefId,\n+                        name: ast::Ident) -> ast::DefId {\n     let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n     match meth_id_opt {\n         Some(m) => return m,\n@@ -312,9 +312,9 @@ pub fn method_with_name(ccx: &mut CrateContext,\n \n pub fn trans_monomorphized_callee(bcx: @mut Block,\n                                   callee_id: ast::NodeId,\n-                                  base: @ast::expr,\n+                                  base: @ast::Expr,\n                                   mentry: typeck::method_map_entry,\n-                                  trait_id: ast::def_id,\n+                                  trait_id: ast::DefId,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n                                   -> Callee {\n@@ -368,7 +368,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n }\n \n pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n-                                    mth_did: ast::def_id,\n+                                    mth_did: ast::DefId,\n                                     callee_id: ast::NodeId,\n                                     rcvr_substs: &[ty::t],\n                                     rcvr_origins: typeck::vtable_res)\n@@ -419,7 +419,7 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n pub fn trans_trait_callee(bcx: @mut Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n-                          self_expr: @ast::expr)\n+                          self_expr: @ast::Expr)\n                           -> Callee {\n     /*!\n      * Create a method callee where the method is coming from a trait\n@@ -580,7 +580,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n }\n \n fn emit_vtable_methods(bcx: @mut Block,\n-                       impl_id: ast::def_id,\n+                       impl_id: ast::DefId,\n                        substs: &[ty::t],\n                        vtables: typeck::vtable_res)\n                        -> ~[ValueRef] {\n@@ -621,7 +621,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n }\n \n pub fn trans_trait_cast(bcx: @mut Block,\n-                        val: @ast::expr,\n+                        val: @ast::Expr,\n                         id: ast::NodeId,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore)"}, {"sha": "0c0d3b7275bc5138bff987234fe734a13137d518", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -35,7 +35,7 @@ use syntax::ast_map::path_name;\n use syntax::ast_util::local_def;\n \n pub fn monomorphic_fn(ccx: @mut CrateContext,\n-                      fn_id: ast::def_id,\n+                      fn_id: ast::DefId,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n                       self_vtables: Option<typeck::vtable_param_res>,\n@@ -296,7 +296,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n }\n \n pub fn make_mono_id(ccx: @mut CrateContext,\n-                    item: ast::def_id,\n+                    item: ast::DefId,\n                     substs: &param_substs,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get"}, {"sha": "b83ddf27dba830dcd8c5c53f1f506e85d07db09b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -27,7 +27,7 @@ use util::ppaux::ty_to_str;\n use std::libc::c_uint;\n use std::option::None;\n use std::vec;\n-use syntax::ast::def_id;\n+use syntax::ast::DefId;\n use syntax::ast;\n use syntax::ast_map::path_name;\n use syntax::parse::token::special_idents;\n@@ -283,7 +283,8 @@ impl Reflector {\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n             let llptrty = type_of(ccx, t).ptr_to();\n             let opaquety = ty::get_opaque_ty(ccx.tcx).unwrap();\n-            let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n+            let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety,\n+                                                           mutbl: ast::MutImmutable });\n \n             let make_get_disr = || {\n                 let sub_path = bcx.fcx.path + &[path_name(special_idents::anon)];\n@@ -384,7 +385,7 @@ impl Reflector {\n pub fn emit_calls_to_trait_visit_ty(bcx: @mut Block,\n                                     t: ty::t,\n                                     visitor_val: ValueRef,\n-                                    visitor_trait_id: def_id)\n+                                    visitor_trait_id: DefId)\n                                  -> @mut Block {\n     let final = sub_block(bcx, \"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();"}, {"sha": "e38831cd5d77ee38ddcf3dc45610bced90320a0f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -158,8 +158,8 @@ impl VecTypes {\n }\n \n pub fn trans_fixed_vstore(bcx: @mut Block,\n-                          vstore_expr: @ast::expr,\n-                          content_expr: &ast::expr,\n+                          vstore_expr: @ast::Expr,\n+                          content_expr: &ast::Expr,\n                           dest: expr::Dest)\n                        -> @mut Block {\n     //!\n@@ -187,8 +187,8 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n }\n \n pub fn trans_slice_vstore(bcx: @mut Block,\n-                          vstore_expr: @ast::expr,\n-                          content_expr: @ast::expr,\n+                          vstore_expr: @ast::Expr,\n+                          content_expr: @ast::Expr,\n                           dest: expr::Dest)\n                        -> @mut Block {\n     //!\n@@ -205,7 +205,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::expr_lit(@codemap::Spanned {node: ast::lit_str(s), span: _}) => {\n+        ast::ExprLit(@codemap::Spanned {node: ast::lit_str(s), span: _}) => {\n             return trans_lit_str(bcx, content_expr, s, dest);\n         }\n         _ => {}\n@@ -222,7 +222,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n \n     // Arrange for the backing array to be cleaned up.\n     let fixed_ty = ty::mk_evec(bcx.tcx(),\n-                               ty::mt {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n+                               ty::mt {ty: vt.unit_ty, mutbl: ast::MutMutable},\n                                ty::vstore_fixed(count));\n     let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n@@ -246,7 +246,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n }\n \n pub fn trans_lit_str(bcx: @mut Block,\n-                     lit_expr: @ast::expr,\n+                     lit_expr: @ast::Expr,\n                      str_lit: @str,\n                      dest: Dest)\n                   -> @mut Block {\n@@ -280,8 +280,8 @@ pub fn trans_lit_str(bcx: @mut Block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @ast::expr,\n-                                    content_expr: &ast::expr) -> DatumBlock {\n+pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @ast::Expr,\n+                                    content_expr: &ast::Expr) -> DatumBlock {\n     //!\n     //\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n@@ -295,7 +295,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @a\n     match heap {\n         heap_exchange => {\n             match content_expr.node {\n-                ast::expr_lit(@codemap::Spanned {\n+                ast::ExprLit(@codemap::Spanned {\n                     node: ast::lit_str(s), span\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), s);\n@@ -343,8 +343,8 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @a\n \n pub fn write_content(bcx: @mut Block,\n                      vt: &VecTypes,\n-                     vstore_expr: @ast::expr,\n-                     content_expr: &ast::expr,\n+                     vstore_expr: @ast::Expr,\n+                     content_expr: &ast::Expr,\n                      dest: Dest)\n                   -> @mut Block {\n     let _icx = push_ctxt(\"tvec::write_content\");\n@@ -357,7 +357,7 @@ pub fn write_content(bcx: @mut Block,\n     let _indenter = indenter();\n \n     match content_expr.node {\n-        ast::expr_lit(@codemap::Spanned { node: ast::lit_str(s), _ }) => {\n+        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s), _ }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -371,7 +371,7 @@ pub fn write_content(bcx: @mut Block,\n                 }\n             }\n         }\n-        ast::expr_vec(ref elements, _) => {\n+        ast::ExprVec(ref elements, _) => {\n             match dest {\n                 Ignore => {\n                     for element in elements.iter() {\n@@ -397,7 +397,7 @@ pub fn write_content(bcx: @mut Block,\n             }\n             return bcx;\n         }\n-        ast::expr_repeat(element, count_expr, _) => {\n+        ast::ExprRepeat(element, count_expr, _) => {\n             match dest {\n                 Ignore => {\n                     return expr::trans_into(bcx, element, Ignore);\n@@ -469,7 +469,7 @@ pub fn write_content(bcx: @mut Block,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: @mut Block, vec_expr: &ast::expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: @mut Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n@@ -486,15 +486,15 @@ pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n               llunit_size: llunit_size}\n }\n \n-pub fn elements_required(bcx: @mut Block, content_expr: &ast::expr) -> uint {\n+pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::expr_lit(@codemap::Spanned { node: ast::lit_str(s), _ }) => {\n+        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s), _ }) => {\n             s.len()\n         },\n-        ast::expr_vec(ref es, _) => es.len(),\n-        ast::expr_repeat(_, count_expr, _) => {\n+        ast::ExprVec(ref es, _) => es.len(),\n+        ast::ExprRepeat(_, count_expr, _) => {\n             ty::eval_repeat_count(&bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,"}, {"sha": "3fc5bcc8f7bc8164bbec9c53e656014b4fa1426b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -324,7 +324,7 @@ pub enum named_ty { a_struct, an_enum }\n \n pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n-                      did: ast::def_id,\n+                      did: ast::DefId,\n                       tps: &[ty::t]) -> ~str {\n     let name = match what {\n         a_struct => { \"struct\" }"}, {"sha": "1a51cdfb60e01d57b456523e1b60e635683c4591", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -57,10 +57,10 @@ pub struct Context {\n     uses: @mut ~[type_uses]\n }\n \n-pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n+pub fn type_uses_for(ccx: @mut CrateContext, fn_id: DefId, n_tps: uint)\n     -> @~[type_uses] {\n \n-    fn store_type_uses(cx: Context, fn_id: def_id) -> @~[type_uses] {\n+    fn store_type_uses(cx: Context, fn_id: DefId) -> @~[type_uses] {\n         let Context { uses, ccx } = cx;\n         let uses = @(*uses).clone(); // freeze\n         ccx.type_use_cache.insert(fn_id, uses);\n@@ -231,7 +231,7 @@ pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {\n pub fn type_needs_inner(cx: &Context,\n                         use_: uint,\n                         ty: ty::t,\n-                        enums_seen: @List<def_id>) {\n+                        enums_seen: @List<DefId>) {\n     do ty::maybe_walk_ty(ty) |ty| {\n         if ty::type_has_params(ty) {\n             match ty::get(ty).sty {\n@@ -311,14 +311,14 @@ pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n     }\n }\n \n-pub fn mark_for_expr(cx: &Context, e: &expr) {\n+pub fn mark_for_expr(cx: &Context, e: &Expr) {\n     match e.node {\n-      expr_vstore(_, _) | expr_vec(_, _) | expr_struct(*) | expr_tup(_) |\n-      expr_unary(_, box(_), _) | expr_unary(_, uniq, _) |\n-      expr_binary(_, add, _, _) | expr_repeat(*) => {\n+      ExprVstore(_, _) | ExprVec(_, _) | ExprStruct(*) | ExprTup(_) |\n+      ExprUnary(_, UnBox(_), _) | ExprUnary(_, UnUniq, _) |\n+      ExprBinary(_, BiAdd, _, _) | ExprRepeat(*) => {\n         node_type_needs(cx, use_repr, e.id);\n       }\n-      expr_cast(base, _) => {\n+      ExprCast(base, _) => {\n         let result_t = ty::node_id_to_type(cx.ccx.tcx, e.id);\n         match ty::get(result_t).sty {\n             ty::ty_trait(*) => {\n@@ -329,15 +329,15 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n             _ => ()\n         }\n       }\n-      expr_binary(_, op, lhs, _) => {\n+      ExprBinary(_, op, lhs, _) => {\n         match op {\n-          eq | lt | le | ne | ge | gt => {\n+          BiEq | BiLt | BiLe | BiNe | BiGe | BiGt => {\n             node_type_needs(cx, use_tydesc, lhs.id)\n           }\n           _ => ()\n         }\n       }\n-      expr_path(_) | expr_self => {\n+      ExprPath(_) | ExprSelf => {\n         let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n         for ts in opt_ts.iter() {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n@@ -347,7 +347,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n             }\n         }\n       }\n-      expr_fn_block(*) => {\n+      ExprFnBlock(*) => {\n           match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n               ast::OwnedSigil => {}\n               ast::BorrowedSigil | ast::ManagedSigil => {\n@@ -358,35 +358,35 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n               }\n           }\n       }\n-      expr_assign(val, _) | expr_assign_op(_, _, val, _) |\n-      expr_ret(Some(val)) => {\n+      ExprAssign(val, _) | ExprAssignOp(_, _, val, _) |\n+      ExprRet(Some(val)) => {\n         node_type_needs(cx, use_repr, val.id);\n       }\n-      expr_index(callee_id, base, _) => {\n+      ExprIndex(callee_id, base, _) => {\n         // FIXME (#2537): could be more careful and not count fields after\n         // the chosen field.\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n         mark_for_method_call(cx, e.id, callee_id);\n       }\n-      expr_field(base, _, _) => {\n+      ExprField(base, _, _) => {\n         // Method calls are now a special syntactic form,\n         // so `a.b` should always be a field.\n         assert!(!cx.ccx.maps.method_map.contains_key(&e.id));\n \n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n       }\n-      expr_log(_, val) => {\n+      ExprLog(_, val) => {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n-      expr_call(f, _, _) => {\n+      ExprCall(f, _, _) => {\n           let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id));\n           for a in r.iter() {\n               type_needs(cx, use_repr, *a);\n           }\n       }\n-      expr_method_call(callee_id, rcvr, _, _, _, _) => {\n+      ExprMethodCall(callee_id, rcvr, _, _, _, _) => {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, rcvr.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n@@ -397,7 +397,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n         mark_for_method_call(cx, e.id, callee_id);\n       }\n \n-      expr_inline_asm(ref ia) => {\n+      ExprInlineAsm(ref ia) => {\n         for &(_, input) in ia.inputs.iter() {\n           node_type_needs(cx, use_repr, input.id);\n         }\n@@ -406,22 +406,22 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n         }\n       }\n \n-      expr_paren(e) => mark_for_expr(cx, e),\n+      ExprParen(e) => mark_for_expr(cx, e),\n \n-      expr_match(*) | expr_block(_) | expr_if(*) | expr_while(*) |\n-      expr_break(_) | expr_again(_) | expr_unary(*) | expr_lit(_) |\n-      expr_mac(_) | expr_addr_of(*) | expr_ret(_) | expr_loop(*) |\n-      expr_do_body(_) => (),\n+      ExprMatch(*) | ExprBlock(_) | ExprIf(*) | ExprWhile(*) |\n+      ExprBreak(_) | ExprAgain(_) | ExprUnary(*) | ExprLit(_) |\n+      ExprMac(_) | ExprAddrOf(*) | ExprRet(_) | ExprLoop(*) |\n+      ExprDoBody(_) => (),\n \n-      expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\")\n+      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n \n struct TypeUseVisitor;\n \n impl<'self> Visitor<&'self Context> for TypeUseVisitor {\n \n-    fn visit_expr<'a>(&mut self, e:@expr, cx: &'a Context) {\n+    fn visit_expr<'a>(&mut self, e:@Expr, cx: &'a Context) {\n             visit::walk_expr(self, e, cx);\n             mark_for_expr(cx, e);\n     }\n@@ -431,7 +431,7 @@ impl<'self> Visitor<&'self Context> for TypeUseVisitor {\n             node_type_needs(cx, use_repr, l.id);\n     }\n \n-    fn visit_pat<'a>(&mut self, p:@pat, cx: &'a Context) {\n+    fn visit_pat<'a>(&mut self, p:@Pat, cx: &'a Context) {\n             visit::walk_pat(self, p, cx);\n             node_type_needs(cx, use_repr, p.id);\n     }"}, {"sha": "3266ec5c9abf4a05936087541b79f3e026bb2802", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 201, "deletions": 201, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -62,8 +62,8 @@ pub struct field {\n \n #[deriving(Clone)]\n pub enum MethodContainer {\n-    TraitContainer(ast::def_id),\n-    ImplContainer(ast::def_id),\n+    TraitContainer(ast::DefId),\n+    ImplContainer(ast::DefId),\n }\n \n #[deriving(Clone)]\n@@ -74,11 +74,11 @@ pub struct Method {\n     fty: BareFnTy,\n     explicit_self: ast::explicit_self_,\n     vis: ast::visibility,\n-    def_id: ast::def_id,\n+    def_id: ast::DefId,\n     container: MethodContainer,\n \n     // If this method is provided, we need to know where it came from\n-    provided_source: Option<ast::def_id>\n+    provided_source: Option<ast::DefId>\n }\n \n impl Method {\n@@ -88,9 +88,9 @@ impl Method {\n                fty: BareFnTy,\n                explicit_self: ast::explicit_self_,\n                vis: ast::visibility,\n-               def_id: ast::def_id,\n+               def_id: ast::DefId,\n                container: MethodContainer,\n-               provided_source: Option<ast::def_id>)\n+               provided_source: Option<ast::DefId>)\n                -> Method {\n         // Check the invariants.\n         if explicit_self == ast::sty_static {\n@@ -112,7 +112,7 @@ impl Method {\n         }\n     }\n \n-    pub fn container_id(&self) -> ast::def_id {\n+    pub fn container_id(&self) -> ast::DefId {\n         match self.container {\n             TraitContainer(id) => id,\n             ImplContainer(id) => id,\n@@ -121,15 +121,15 @@ impl Method {\n }\n \n pub struct Impl {\n-    did: def_id,\n+    did: DefId,\n     ident: Ident,\n     methods: ~[@Method]\n }\n \n #[deriving(Clone, Eq, IterBytes)]\n pub struct mt {\n     ty: t,\n-    mutbl: ast::mutability,\n+    mutbl: ast::Mutability,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n@@ -157,7 +157,7 @@ pub enum SelfMode {\n \n pub struct field_ty {\n     ident: Ident,\n-    id: def_id,\n+    id: DefId,\n     vis: ast::visibility,\n }\n \n@@ -229,22 +229,22 @@ pub struct AutoDerefRef {\n #[deriving(Decodable, Encodable)]\n pub enum AutoRef {\n     /// Convert from T to &T\n-    AutoPtr(Region, ast::mutability),\n+    AutoPtr(Region, ast::Mutability),\n \n     /// Convert from @[]/~[]/&[] to &[] (or str)\n-    AutoBorrowVec(Region, ast::mutability),\n+    AutoBorrowVec(Region, ast::Mutability),\n \n     /// Convert from @[]/~[]/&[] to &&[] (or str)\n-    AutoBorrowVecRef(Region, ast::mutability),\n+    AutoBorrowVecRef(Region, ast::Mutability),\n \n     /// Convert from @fn()/~fn()/&fn() to &fn()\n     AutoBorrowFn(Region),\n \n     /// Convert from T to *T\n-    AutoUnsafe(ast::mutability),\n+    AutoUnsafe(ast::Mutability),\n \n     /// Convert from @Trait/~Trait/&Trait to &Trait\n-    AutoBorrowObj(Region, ast::mutability),\n+    AutoBorrowObj(Region, ast::Mutability),\n }\n \n pub type ctxt = @ctxt_;\n@@ -272,21 +272,21 @@ struct ctxt_ {\n     node_type_substs: @mut HashMap<NodeId, ~[t]>,\n \n     // Maps from a method to the method \"descriptor\"\n-    methods: @mut HashMap<def_id, @Method>,\n+    methods: @mut HashMap<DefId, @Method>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    trait_method_def_ids: @mut HashMap<def_id, @~[def_id]>,\n+    trait_method_def_ids: @mut HashMap<DefId, @~[DefId]>,\n \n     // A cache for the trait_methods() routine\n-    trait_methods_cache: @mut HashMap<def_id, @~[@Method]>,\n+    trait_methods_cache: @mut HashMap<DefId, @~[@Method]>,\n \n-    impl_trait_cache: @mut HashMap<ast::def_id, Option<@ty::TraitRef>>,\n+    impl_trait_cache: @mut HashMap<ast::DefId, Option<@ty::TraitRef>>,\n \n     trait_refs: @mut HashMap<NodeId, @TraitRef>,\n-    trait_defs: @mut HashMap<def_id, @TraitDef>,\n+    trait_defs: @mut HashMap<DefId, @TraitDef>,\n \n     items: ast_map::map,\n-    intrinsic_defs: @mut HashMap<ast::def_id, t>,\n+    intrinsic_defs: @mut HashMap<ast::DefId, t>,\n     freevars: freevars::freevar_map,\n     tcache: type_cache,\n     rcache: creader_cache,\n@@ -295,37 +295,37 @@ struct ctxt_ {\n     needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<NodeId, ast_ty_to_ty_cache_entry>,\n-    enum_var_cache: @mut HashMap<def_id, @~[@VariantInfo]>,\n+    enum_var_cache: @mut HashMap<DefId, @~[@VariantInfo]>,\n     ty_param_defs: @mut HashMap<ast::NodeId, TypeParameterDef>,\n     adjustments: @mut HashMap<ast::NodeId, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n-    provided_method_sources: @mut HashMap<ast::def_id, ast::def_id>,\n-    supertraits: @mut HashMap<ast::def_id, @~[@TraitRef]>,\n+    provided_method_sources: @mut HashMap<ast::DefId, ast::DefId>,\n+    supertraits: @mut HashMap<ast::DefId, @~[@TraitRef]>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n     // populated during the coherence phase of typechecking.\n-    destructor_for_type: @mut HashMap<ast::def_id, ast::def_id>,\n+    destructor_for_type: @mut HashMap<ast::DefId, ast::DefId>,\n \n     // A method will be in this list if and only if it is a destructor.\n-    destructors: @mut HashSet<ast::def_id>,\n+    destructors: @mut HashSet<ast::DefId>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    trait_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+    trait_impls: @mut HashMap<ast::DefId, @mut ~[@Impl]>,\n \n     // Maps a def_id of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+    inherent_impls: @mut HashMap<ast::DefId, @mut ~[@Impl]>,\n \n     // Maps a def_id of an impl to an Impl structure.\n     // Note that this contains all of the impls that we know about,\n     // including ones in other crates. It's not clear that this is the best\n     // way to do it.\n-    impls: @mut HashMap<ast::def_id, @Impl>,\n+    impls: @mut HashMap<ast::DefId, @Impl>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n@@ -341,11 +341,11 @@ struct ctxt_ {\n \n     // The set of external nominal types whose implementations have been read.\n     // This is used for lazy resolution of methods.\n-    populated_external_types: @mut HashSet<ast::def_id>,\n+    populated_external_types: @mut HashSet<ast::DefId>,\n \n     // The set of external traits whose implementations have been read. This\n     // is used for lazy resolution of traits.\n-    populated_external_traits: @mut HashSet<ast::def_id>,\n+    populated_external_traits: @mut HashSet<ast::DefId>,\n }\n \n pub enum tbox_flag {\n@@ -439,7 +439,7 @@ pub struct FnSig {\n #[deriving(Clone, Eq, IterBytes)]\n pub struct param_ty {\n     idx: uint,\n-    def_id: def_id\n+    def_id: DefId\n }\n \n /// Representation of regions:\n@@ -613,20 +613,20 @@ pub enum sty {\n     ty_uint(ast::uint_ty),\n     ty_float(ast::float_ty),\n     ty_estr(vstore),\n-    ty_enum(def_id, substs),\n+    ty_enum(DefId, substs),\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_evec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n     ty_closure(ClosureTy),\n-    ty_trait(def_id, substs, TraitStore, ast::mutability, BuiltinBounds),\n-    ty_struct(def_id, substs),\n+    ty_trait(DefId, substs, TraitStore, ast::Mutability, BuiltinBounds),\n+    ty_struct(DefId, substs),\n     ty_tup(~[t]),\n \n     ty_param(param_ty), // type parameter\n-    ty_self(def_id), /* special, implicit `self` type parameter;\n+    ty_self(DefId), /* special, implicit `self` type parameter;\n                       * def_id is the id of the trait */\n \n     ty_infer(InferTy), // something used only during inference/typeck\n@@ -643,7 +643,7 @@ pub enum sty {\n \n #[deriving(Eq, IterBytes)]\n pub struct TraitRef {\n-    def_id: def_id,\n+    def_id: DefId,\n     substs: substs\n }\n \n@@ -698,7 +698,7 @@ pub enum type_err {\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n     terr_float_mismatch(expected_found<ast::float_ty>),\n-    terr_traits(expected_found<ast::def_id>),\n+    terr_traits(expected_found<ast::DefId>),\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n }\n \n@@ -849,7 +849,7 @@ impl ToStr for IntVarValue {\n #[deriving(Clone)]\n pub struct TypeParameterDef {\n     ident: ast::Ident,\n-    def_id: ast::def_id,\n+    def_id: ast::DefId,\n     bounds: @ParamBounds\n }\n \n@@ -895,9 +895,9 @@ pub struct ty_param_substs_and_ty {\n     ty: ty::t\n }\n \n-type type_cache = @mut HashMap<ast::def_id, ty_param_bounds_and_ty>;\n+type type_cache = @mut HashMap<ast::DefId, ty_param_bounds_and_ty>;\n \n-type constness_cache = @mut HashMap<ast::def_id, const_eval::constness>;\n+type constness_cache = @mut HashMap<ast::DefId, const_eval::constness>;\n \n pub type node_type_table = @mut HashMap<uint,t>;\n \n@@ -1180,44 +1180,44 @@ pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n }\n \n-pub fn mk_enum(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n+pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n pub fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n \n pub fn mk_imm_box(cx: ctxt, ty: t) -> t {\n-    mk_box(cx, mt {ty: ty, mutbl: ast::m_imm})\n+    mk_box(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n pub fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n \n pub fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n-    mk_uniq(cx, mt {ty: ty, mutbl: ast::m_imm})\n+    mk_uniq(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n pub fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n pub fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n pub fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n-    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_mutbl})\n+    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n pub fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n-    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_imm})\n+    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n pub fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n-    mk_ptr(cx, mt {ty: ty, mutbl: ast::m_mutbl})\n+    mk_ptr(cx, mt {ty: ty, mutbl: ast::MutMutable})\n }\n \n pub fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n-    mk_ptr(cx, mt {ty: ty, mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n pub fn mk_nil_ptr(cx: ctxt) -> t {\n-    mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n pub fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n@@ -1228,7 +1228,7 @@ pub fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n     mk_t(cx, ty_unboxed_vec(tm))\n }\n pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n-    mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n+    mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n }\n \n pub fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n@@ -1257,17 +1257,17 @@ pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n \n \n pub fn mk_trait(cx: ctxt,\n-                did: ast::def_id,\n+                did: ast::DefId,\n                 substs: substs,\n                 store: TraitStore,\n-                mutability: ast::mutability,\n+                mutability: ast::Mutability,\n                 bounds: BuiltinBounds)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_trait(did, substs, store, mutability, bounds))\n }\n \n-pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, substs: substs) -> t {\n+pub fn mk_struct(cx: ctxt, struct_id: ast::DefId, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n@@ -1280,9 +1280,9 @@ pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n pub fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n-pub fn mk_self(cx: ctxt, did: ast::def_id) -> t { mk_t(cx, ty_self(did)) }\n+pub fn mk_self(cx: ctxt, did: ast::DefId) -> t { mk_t(cx, ty_self(did)) }\n \n-pub fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n+pub fn mk_param(cx: ctxt, n: uint, k: DefId) -> t {\n     mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n }\n \n@@ -2140,7 +2140,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_estr(vstore_slice(r)) => {\n-                borrowed_contents(r, m_imm)\n+                borrowed_contents(r, MutImmutable)\n             }\n \n             ty_estr(vstore_fixed(_)) => {\n@@ -2234,11 +2234,11 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n              mt: mt,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n-        let mc = if mt.mutbl == m_mutbl {TC_MUTABLE} else {TC_NONE};\n+        let mc = if mt.mutbl == MutMutable {TC_MUTABLE} else {TC_NONE};\n         mc + tc_ty(cx, mt.ty, cache)\n     }\n \n-    fn apply_tc_attr(cx: ctxt, did: def_id, mut tc: TypeContents) -> TypeContents {\n+    fn apply_tc_attr(cx: ctxt, did: DefId, mut tc: TypeContents) -> TypeContents {\n         if has_attr(cx, did, \"no_freeze\") {\n             tc = tc + TC_MUTABLE;\n         }\n@@ -2249,9 +2249,9 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     }\n \n     fn borrowed_contents(region: ty::Region,\n-                         mutbl: ast::mutability) -> TypeContents\n+                         mutbl: ast::Mutability) -> TypeContents\n     {\n-        let mc = if mutbl == m_mutbl {\n+        let mc = if mutbl == MutMutable {\n             TC_MUTABLE + TC_BORROWED_MUT\n         } else {\n             TC_NONE\n@@ -2290,17 +2290,17 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         // even more stuff.\n         let st = match cty.sigil {\n             ast::BorrowedSigil =>\n-                trait_contents(RegionTraitStore(cty.region), m_imm, cty.bounds)\n+                trait_contents(RegionTraitStore(cty.region), MutImmutable, cty.bounds)\n                     + TC_BORROWED_POINTER, // might be an env packet even if static\n             ast::ManagedSigil =>\n-                trait_contents(BoxTraitStore, m_imm, cty.bounds),\n+                trait_contents(BoxTraitStore, MutImmutable, cty.bounds),\n             ast::OwnedSigil =>\n-                trait_contents(UniqTraitStore, m_imm, cty.bounds),\n+                trait_contents(UniqTraitStore, MutImmutable, cty.bounds),\n         };\n         // FIXME(#3569): This borrowed_contents call should be taken care of in\n         // trait_contents, after ~Traits and @Traits can have region bounds too.\n         // This one here is redundant for &fns but important for ~fns and @fns.\n-        let rt = borrowed_contents(cty.region, m_imm);\n+        let rt = borrowed_contents(cty.region, MutImmutable);\n         // This also prohibits \"@once fn\" from being copied, which allows it to\n         // be called. Neither way really makes much sense.\n         let ot = match cty.onceness {\n@@ -2316,14 +2316,14 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         st + rt + ot + ct\n     }\n \n-    fn trait_contents(store: TraitStore, mutbl: ast::mutability,\n+    fn trait_contents(store: TraitStore, mutbl: ast::Mutability,\n                       bounds: BuiltinBounds) -> TypeContents {\n         let st = match store {\n             UniqTraitStore      => TC_OWNED_POINTER,\n             BoxTraitStore       => TC_MANAGED,\n             RegionTraitStore(r) => borrowed_contents(r, mutbl),\n         };\n-        let mt = match mutbl { ast::m_mutbl => TC_MUTABLE, _ => TC_NONE };\n+        let mt = match mutbl { ast::MutMutable => TC_MUTABLE, _ => TC_NONE };\n         // We get additional \"special type contents\" for each bound that *isn't*\n         // on the trait. So iterate over the inverse of the bounds that are set.\n         // This is like with typarams below, but less \"pessimistic\" and also\n@@ -2386,7 +2386,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-    fn type_requires(cx: ctxt, seen: &mut ~[def_id],\n+    fn type_requires(cx: ctxt, seen: &mut ~[DefId],\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires(%s, %s)?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2404,7 +2404,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: ctxt, seen: &mut ~[def_id],\n+    fn subtypes_require(cx: ctxt, seen: &mut ~[DefId],\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require(%s, %s)?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2706,7 +2706,7 @@ pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         let variants = enum_variants(cx, did);\n         if (*variants).len() == 1u && variants[0].args.len() == 1u {\n             let v_t = subst(cx, substs, variants[0].args[0]);\n-            Some(mt {ty: v_t, mutbl: ast::m_imm})\n+            Some(mt {ty: v_t, mutbl: ast::MutImmutable})\n         } else {\n             None\n         }\n@@ -2716,7 +2716,7 @@ pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         let fields = struct_fields(cx, did, substs);\n         if fields.len() == 1 && fields[0].ident ==\n                 syntax::parse::token::special_idents::unnamed_field {\n-            Some(mt {ty: fields[0].mt.ty, mutbl: ast::m_imm})\n+            Some(mt {ty: fields[0].mt.ty, mutbl: ast::MutImmutable})\n         } else {\n             None\n         }\n@@ -2744,7 +2744,7 @@ pub fn index(t: t) -> Option<mt> {\n pub fn index_sty(sty: &sty) -> Option<mt> {\n     match *sty {\n       ty_evec(mt, _) => Some(mt),\n-      ty_estr(_) => Some(mt {ty: mk_u8(), mutbl: ast::m_imm}),\n+      ty_estr(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n       _ => None\n     }\n }\n@@ -2957,7 +2957,7 @@ pub fn block_ty(cx: ctxt, b: &ast::Block) -> t {\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-pub fn pat_ty(cx: ctxt, pat: &ast::pat) -> t {\n+pub fn pat_ty(cx: ctxt, pat: &ast::Pat) -> t {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -2973,11 +2973,11 @@ pub fn pat_ty(cx: ctxt, pat: &ast::pat) -> t {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-pub fn expr_ty(cx: ctxt, expr: &ast::expr) -> t {\n+pub fn expr_ty(cx: ctxt, expr: &ast::Expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::expr) -> t {\n+pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -3056,7 +3056,7 @@ pub fn adjust_ty(cx: ctxt,\n \n                         AutoBorrowVecRef(r, m) => {\n                             adjusted_ty = borrow_vec(cx, span, r, m, adjusted_ty);\n-                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: ast::m_imm})\n+                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: ast::MutImmutable})\n                         }\n \n                         AutoBorrowFn(r) => {\n@@ -3077,7 +3077,7 @@ pub fn adjust_ty(cx: ctxt,\n     };\n \n     fn borrow_vec(cx: ctxt, span: Span,\n-                  r: Region, m: ast::mutability,\n+                  r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_evec(mt, _) => {\n@@ -3117,7 +3117,7 @@ pub fn adjust_ty(cx: ctxt,\n     }\n \n     fn borrow_obj(cx: ctxt, span: Span, r: Region,\n-                  m: ast::mutability, ty: ty::t) -> ty::t {\n+                  m: ast::Mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_trait(trt_did, ref trt_substs, _, _, b) => {\n                 ty::mk_trait(cx, trt_did, trt_substs.clone(),\n@@ -3152,15 +3152,15 @@ pub struct ParamsTy {\n }\n \n pub fn expr_ty_params_and_ty(cx: ctxt,\n-                             expr: &ast::expr)\n+                             expr: &ast::Expr)\n                           -> ParamsTy {\n     ParamsTy {\n         params: node_id_to_type_params(cx, expr.id),\n         ty: node_id_to_type(cx, expr.id)\n     }\n }\n \n-pub fn expr_has_ty_params(cx: ctxt, expr: &ast::expr) -> bool {\n+pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n@@ -3197,7 +3197,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n     }\n }\n \n-pub fn resolve_expr(tcx: ctxt, expr: &ast::expr) -> ast::def {\n+pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n     match tcx.def_map.find(&expr.id) {\n         Some(&def) => def,\n         None => {\n@@ -3209,7 +3209,7 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::expr) -> ast::def {\n \n pub fn expr_is_lval(tcx: ctxt,\n                     method_map: typeck::method_map,\n-                    e: &ast::expr) -> bool {\n+                    e: &ast::Expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n         LvalueExpr => true,\n         RvalueDpsExpr | RvalueDatumExpr | RvalueStmtExpr => false\n@@ -3230,34 +3230,34 @@ pub enum ExprKind {\n \n pub fn expr_kind(tcx: ctxt,\n                  method_map: typeck::method_map,\n-                 expr: &ast::expr) -> ExprKind {\n+                 expr: &ast::Expr) -> ExprKind {\n     if method_map.contains_key(&expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n         // exception, as its result is always unit.\n         return match expr.node {\n-            ast::expr_assign_op(*) => RvalueStmtExpr,\n+            ast::ExprAssignOp(*) => RvalueStmtExpr,\n             _ => RvalueDpsExpr\n         };\n     }\n \n     match expr.node {\n-        ast::expr_path(*) | ast::expr_self => {\n+        ast::ExprPath(*) | ast::ExprSelf => {\n             match resolve_expr(tcx, expr) {\n-                ast::def_variant(*) | ast::def_struct(*) => RvalueDpsExpr,\n+                ast::DefVariant(*) | ast::DefStruct(*) => RvalueDpsExpr,\n \n                 // Fn pointers are just scalar values.\n-                ast::def_fn(*) | ast::def_static_method(*) => RvalueDatumExpr,\n+                ast::DefFn(*) | ast::DefStaticMethod(*) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // def_args, particularly those of immediate type, ought to\n                 // considered rvalues.\n-                ast::def_static(*) |\n-                ast::def_binding(*) |\n-                ast::def_upvar(*) |\n-                ast::def_arg(*) |\n-                ast::def_local(*) |\n-                ast::def_self(*) => LvalueExpr,\n+                ast::DefStatic(*) |\n+                ast::DefBinding(*) |\n+                ast::DefUpvar(*) |\n+                ast::DefArg(*) |\n+                ast::DefLocal(*) |\n+                ast::DefSelf(*) => LvalueExpr,\n \n                 def => {\n                     tcx.sess.span_bug(expr.span, fmt!(\n@@ -3267,30 +3267,30 @@ pub fn expr_kind(tcx: ctxt,\n             }\n         }\n \n-        ast::expr_unary(_, ast::deref, _) |\n-        ast::expr_field(*) |\n-        ast::expr_index(*) => {\n+        ast::ExprUnary(_, ast::UnDeref, _) |\n+        ast::ExprField(*) |\n+        ast::ExprIndex(*) => {\n             LvalueExpr\n         }\n \n-        ast::expr_call(*) |\n-        ast::expr_method_call(*) |\n-        ast::expr_struct(*) |\n-        ast::expr_tup(*) |\n-        ast::expr_if(*) |\n-        ast::expr_match(*) |\n-        ast::expr_fn_block(*) |\n-        ast::expr_do_body(*) |\n-        ast::expr_block(*) |\n-        ast::expr_repeat(*) |\n-        ast::expr_lit(@codemap::Spanned {node: lit_str(_), _}) |\n-        ast::expr_vstore(_, ast::expr_vstore_slice) |\n-        ast::expr_vstore(_, ast::expr_vstore_mut_slice) |\n-        ast::expr_vec(*) => {\n+        ast::ExprCall(*) |\n+        ast::ExprMethodCall(*) |\n+        ast::ExprStruct(*) |\n+        ast::ExprTup(*) |\n+        ast::ExprIf(*) |\n+        ast::ExprMatch(*) |\n+        ast::ExprFnBlock(*) |\n+        ast::ExprDoBody(*) |\n+        ast::ExprBlock(*) |\n+        ast::ExprRepeat(*) |\n+        ast::ExprLit(@codemap::Spanned {node: lit_str(_), _}) |\n+        ast::ExprVstore(_, ast::ExprVstoreSlice) |\n+        ast::ExprVstore(_, ast::ExprVstoreMutSlice) |\n+        ast::ExprVec(*) => {\n             RvalueDpsExpr\n         }\n \n-        ast::expr_cast(*) => {\n+        ast::ExprCast(*) => {\n             match tcx.node_types.find(&(expr.id as uint)) {\n                 Some(&t) => {\n                     if ty::type_is_immediate(tcx, t) {\n@@ -3316,46 +3316,46 @@ pub fn expr_kind(tcx: ctxt,\n             }\n         }\n \n-        ast::expr_break(*) |\n-        ast::expr_again(*) |\n-        ast::expr_ret(*) |\n-        ast::expr_log(*) |\n-        ast::expr_while(*) |\n-        ast::expr_loop(*) |\n-        ast::expr_assign(*) |\n-        ast::expr_inline_asm(*) |\n-        ast::expr_assign_op(*) => {\n+        ast::ExprBreak(*) |\n+        ast::ExprAgain(*) |\n+        ast::ExprRet(*) |\n+        ast::ExprLog(*) |\n+        ast::ExprWhile(*) |\n+        ast::ExprLoop(*) |\n+        ast::ExprAssign(*) |\n+        ast::ExprInlineAsm(*) |\n+        ast::ExprAssignOp(*) => {\n             RvalueStmtExpr\n         }\n \n-        ast::expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+        ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n-        ast::expr_lit(_) | // Note: lit_str is carved out above\n-        ast::expr_unary(*) |\n-        ast::expr_addr_of(*) |\n-        ast::expr_binary(*) |\n-        ast::expr_vstore(_, ast::expr_vstore_box) |\n-        ast::expr_vstore(_, ast::expr_vstore_mut_box) |\n-        ast::expr_vstore(_, ast::expr_vstore_uniq) => {\n+        ast::ExprLit(_) | // Note: lit_str is carved out above\n+        ast::ExprUnary(*) |\n+        ast::ExprAddrOf(*) |\n+        ast::ExprBinary(*) |\n+        ast::ExprVstore(_, ast::ExprVstoreBox) |\n+        ast::ExprVstore(_, ast::ExprVstoreMutBox) |\n+        ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n             RvalueDatumExpr\n         }\n \n-        ast::expr_paren(e) => expr_kind(tcx, method_map, e),\n+        ast::ExprParen(e) => expr_kind(tcx, method_map, e),\n \n-        ast::expr_mac(*) => {\n+        ast::ExprMac(*) => {\n             tcx.sess.span_bug(\n                 expr.span,\n                 \"macro expression remains after expansion\");\n         }\n     }\n }\n \n-pub fn stmt_node_id(s: &ast::stmt) -> ast::NodeId {\n+pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n     match s.node {\n-      ast::stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) => {\n+      ast::StmtDecl(_, id) | StmtExpr(_, id) | StmtSemi(_, id) => {\n         return id;\n       }\n-      ast::stmt_mac(*) => fail!(\"unexpanded macro in trans\")\n+      ast::StmtMac(*) => fail!(\"unexpanded macro in trans\")\n     }\n }\n \n@@ -3627,19 +3627,19 @@ pub fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n     }\n }\n \n-pub fn def_has_ty_params(def: ast::def) -> bool {\n+pub fn def_has_ty_params(def: ast::Def) -> bool {\n     match def {\n-      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_struct(_)\n+      ast::DefFn(_, _) | ast::DefVariant(_, _) | ast::DefStruct(_)\n         => true,\n       _ => false\n     }\n }\n \n-pub fn provided_source(cx: ctxt, id: ast::def_id) -> Option<ast::def_id> {\n+pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     cx.provided_method_sources.find(&id).map_move(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[@Method] {\n+pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     if is_local(id) {\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n@@ -3658,7 +3658,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[@Method] {\n }\n \n pub fn trait_supertraits(cx: ctxt,\n-                         id: ast::def_id) -> @~[@TraitRef]\n+                         id: ast::DefId) -> @~[@TraitRef]\n {\n     // Check the cache.\n     match cx.supertraits.find(&id) {\n@@ -3685,8 +3685,8 @@ pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef]\n \n fn lookup_locally_or_in_crate_store<V:Clone>(\n     descr: &str,\n-    def_id: ast::def_id,\n-    map: &mut HashMap<ast::def_id, V>,\n+    def_id: ast::DefId,\n+    map: &mut HashMap<ast::DefId, V>,\n     load_external: &fn() -> V) -> V\n {\n     /*!\n@@ -3713,13 +3713,13 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n+pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n     let method_def_id = ty::trait_method_def_ids(cx, trait_did)[idx];\n     ty::method(cx, method_def_id)\n }\n \n \n-pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n+pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @~[@Method] {\n     match cx.trait_methods_cache.find(&trait_did) {\n         Some(&methods) => methods,\n         None => {\n@@ -3731,19 +3731,19 @@ pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n     }\n }\n \n-pub fn method(cx: ctxt, id: ast::def_id) -> @Method {\n+pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n     lookup_locally_or_in_crate_store(\n         \"methods\", id, cx.methods,\n         || @csearch::get_method(cx, id))\n }\n \n-pub fn trait_method_def_ids(cx: ctxt, id: ast::def_id) -> @~[def_id] {\n+pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @~[DefId] {\n     lookup_locally_or_in_crate_store(\n         \"methods\", id, cx.trait_method_def_ids,\n         || @csearch::get_trait_method_def_ids(cx.cstore, id))\n }\n \n-pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n+pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     match cx.impl_trait_cache.find(&id) {\n         Some(&ret) => { return ret; }\n         None => {}\n@@ -3769,13 +3769,13 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n     return ret;\n }\n \n-pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::trait_ref) -> ast::def_id {\n+pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::trait_ref) -> ast::DefId {\n     let def = tcx.def_map.find(&tr.ref_id).expect(\"no def-map entry for trait\");\n     ast_util::def_id_of_def(*def)\n }\n \n pub fn try_add_builtin_trait(tcx: ctxt,\n-                             trait_def_id: ast::def_id,\n+                             trait_def_id: ast::DefId,\n                              builtin_bounds: &mut BuiltinBounds) -> bool {\n     //! Checks whether `trait_ref` refers to one of the builtin\n     //! traits, like `Send`, and adds the corresponding\n@@ -3788,7 +3788,7 @@ pub fn try_add_builtin_trait(tcx: ctxt,\n     }\n }\n \n-pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n+pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     match get(ty).sty {\n       ty_trait(id, _, _, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n       _ => None\n@@ -3798,7 +3798,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n /// Returns the def ID of the constructor for the given tuple-like struct, or\n /// None if the struct is not tuple-like. Fails if the given def ID does not\n /// refer to a struct at all.\n-fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n+fn struct_ctor_id(cx: ctxt, struct_did: ast::DefId) -> Option<ast::DefId> {\n     if struct_did.crate != ast::LOCAL_CRATE {\n         // XXX: Cross-crate functionality.\n         cx.sess.unimpl(\"constructor ID of cross-crate tuple structs\");\n@@ -3826,7 +3826,7 @@ pub struct VariantInfo {\n     arg_names: Option<~[ast::Ident]>,\n     ctor_ty: t,\n     name: ast::Ident,\n-    id: ast::def_id,\n+    id: ast::DefId,\n     disr_val: Disr,\n     vis: visibility\n }\n@@ -3886,7 +3886,7 @@ impl VariantInfo {\n }\n \n pub fn substd_enum_variants(cx: ctxt,\n-                            id: ast::def_id,\n+                            id: ast::DefId,\n                             substs: &substs)\n                          -> ~[@VariantInfo] {\n     do enum_variants(cx, id).iter().map |variant_info| {\n@@ -3903,13 +3903,13 @@ pub fn substd_enum_variants(cx: ctxt,\n     }.collect()\n }\n \n-pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n+pub fn item_path_str(cx: ctxt, id: ast::DefId) -> ~str {\n     ast_map::path_to_str(item_path(cx, id), token::get_ident_interner())\n }\n \n pub enum DtorKind {\n     NoDtor,\n-    TraitDtor(def_id, bool)\n+    TraitDtor(DefId, bool)\n }\n \n impl DtorKind {\n@@ -3934,7 +3934,7 @@ impl DtorKind {\n \n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n-pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n+pub fn ty_dtor(cx: ctxt, struct_id: DefId) -> DtorKind {\n     match cx.destructor_for_type.find(&struct_id) {\n         Some(&method_def_id) => {\n             let flag = !has_attr(cx, struct_id, \"unsafe_no_drop_flag\");\n@@ -3945,11 +3945,11 @@ pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     }\n }\n \n-pub fn has_dtor(cx: ctxt, struct_id: def_id) -> bool {\n+pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n     ty_dtor(cx, struct_id).is_present()\n }\n \n-pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n+pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n     if id.crate != ast::LOCAL_CRATE {\n         csearch::get_item_path(cx, id)\n     } else {\n@@ -4002,7 +4002,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     }\n }\n \n-pub fn enum_is_univariant(cx: ctxt, id: ast::def_id) -> bool {\n+pub fn enum_is_univariant(cx: ctxt, id: ast::DefId) -> bool {\n     enum_variants(cx, id).len() == 1\n }\n \n@@ -4013,7 +4013,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n+pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n     match cx.enum_var_cache.find(&id) {\n       Some(&variants) => return variants,\n       _ => { /* fallthrough */ }\n@@ -4070,8 +4070,8 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n \n // Returns information about the enum variant with the given ID:\n pub fn enum_variant_with_id(cx: ctxt,\n-                            enum_id: ast::def_id,\n-                            variant_id: ast::def_id)\n+                            enum_id: ast::DefId,\n+                            variant_id: ast::DefId)\n                          -> @VariantInfo {\n     let variants = enum_variants(cx, enum_id);\n     let mut i = 0;\n@@ -4087,23 +4087,23 @@ pub fn enum_variant_with_id(cx: ctxt,\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n pub fn lookup_item_type(cx: ctxt,\n-                        did: ast::def_id)\n+                        did: ast::DefId)\n                      -> ty_param_bounds_and_ty {\n     lookup_locally_or_in_crate_store(\n         \"tcache\", did, cx.tcache,\n         || csearch::get_type(cx, did))\n }\n \n pub fn lookup_impl_vtables(cx: ctxt,\n-                           did: ast::def_id)\n+                           did: ast::DefId)\n                      -> typeck::impl_res {\n     lookup_locally_or_in_crate_store(\n         \"impl_vtables\", did, cx.impl_vtables,\n         || csearch::get_impl_vtables(cx, did) )\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n+pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n     match cx.trait_defs.find(&did) {\n         Some(&trait_def) => {\n             // The item is in this crate. The caller should have added it to the\n@@ -4120,7 +4120,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n }\n \n /// Determine whether an item is annotated with an attribute\n-pub fn has_attr(tcx: ctxt, did: def_id, attr: &str) -> bool {\n+pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n     if is_local(did) {\n         match tcx.items.find(&did.node) {\n             Some(\n@@ -4141,20 +4141,20 @@ pub fn has_attr(tcx: ctxt, did: def_id, attr: &str) -> bool {\n }\n \n /// Determine whether an item is annotated with `#[packed]`\n-pub fn lookup_packed(tcx: ctxt, did: def_id) -> bool {\n+pub fn lookup_packed(tcx: ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"packed\")\n }\n \n /// Determine whether an item is annotated with `#[simd]`\n-pub fn lookup_simd(tcx: ctxt, did: def_id) -> bool {\n+pub fn lookup_simd(tcx: ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type(tcx: ctxt,\n-                         struct_id: def_id,\n-                         id: def_id,\n+                         struct_id: DefId,\n+                         id: DefId,\n                          substs: &substs)\n                       -> ty::t {\n     let t = if id.crate == ast::LOCAL_CRATE {\n@@ -4175,7 +4175,7 @@ pub fn lookup_field_type(tcx: ctxt,\n \n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n-pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n+pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n   if did.crate == ast::LOCAL_CRATE {\n     match cx.items.find(&did.node) {\n        Some(&ast_map::node_item(i,_)) => {\n@@ -4211,8 +4211,8 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n }\n \n pub fn lookup_struct_field(cx: ctxt,\n-                           parent: ast::def_id,\n-                           field_id: ast::def_id)\n+                           parent: ast::DefId,\n+                           field_id: ast::DefId)\n                         -> field_ty {\n     let r = lookup_struct_fields(cx, parent);\n     match r.iter().find(\n@@ -4246,20 +4246,20 @@ fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n-pub fn struct_fields(cx: ctxt, did: ast::def_id, substs: &substs)\n+pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n                      -> ~[field] {\n     do lookup_struct_fields(cx, did).map |f| {\n        field {\n             ident: f.ident,\n             mt: mt {\n                 ty: lookup_field_type(cx, did, f.id, substs),\n-                mutbl: m_imm\n+                mutbl: MutImmutable\n             }\n         }\n     }\n }\n \n-pub fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n+pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n     static tycat_int: int = 2;\n@@ -4276,26 +4276,26 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n     static opcat_bit: int = 6;\n     static opcat_logic: int = 7;\n \n-    fn opcat(op: ast::binop) -> int {\n+    fn opcat(op: ast::BinOp) -> int {\n         match op {\n-          ast::add => opcat_add,\n-          ast::subtract => opcat_sub,\n-          ast::mul => opcat_mult,\n-          ast::div => opcat_mult,\n-          ast::rem => opcat_mult,\n-          ast::and => opcat_logic,\n-          ast::or => opcat_logic,\n-          ast::bitxor => opcat_bit,\n-          ast::bitand => opcat_bit,\n-          ast::bitor => opcat_bit,\n-          ast::shl => opcat_shift,\n-          ast::shr => opcat_shift,\n-          ast::eq => opcat_eq,\n-          ast::ne => opcat_eq,\n-          ast::lt => opcat_rel,\n-          ast::le => opcat_rel,\n-          ast::ge => opcat_rel,\n-          ast::gt => opcat_rel\n+          ast::BiAdd => opcat_add,\n+          ast::BiSub => opcat_sub,\n+          ast::BiMul => opcat_mult,\n+          ast::BiDiv => opcat_mult,\n+          ast::BiRem => opcat_mult,\n+          ast::BiAnd => opcat_logic,\n+          ast::BiOr => opcat_logic,\n+          ast::BiBitXor => opcat_bit,\n+          ast::BiBitAnd => opcat_bit,\n+          ast::BiBitOr => opcat_bit,\n+          ast::BiShl => opcat_shift,\n+          ast::BiShr => opcat_shift,\n+          ast::BiEq => opcat_eq,\n+          ast::BiNe => opcat_eq,\n+          ast::BiLt => opcat_rel,\n+          ast::BiLe => opcat_rel,\n+          ast::BiGe => opcat_rel,\n+          ast::BiGt => opcat_rel\n         }\n     }\n \n@@ -4413,12 +4413,12 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n }\n \n pub trait ExprTyProvider {\n-    fn expr_ty(&self, ex: &ast::expr) -> t;\n+    fn expr_ty(&self, ex: &ast::Expr) -> t;\n     fn ty_ctxt(&self) -> ctxt;\n }\n \n impl ExprTyProvider for ctxt {\n-    fn expr_ty(&self, ex: &ast::expr) -> t {\n+    fn expr_ty(&self, ex: &ast::Expr) -> t {\n         expr_ty(*self, ex)\n     }\n \n@@ -4428,7 +4428,7 @@ impl ExprTyProvider for ctxt {\n }\n \n // Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::expr) -> uint {\n+pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n       Ok(ref const_val) => match *const_val {\n         const_eval::const_int(count) => if count < 0 {\n@@ -4572,13 +4572,13 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n                  RegionTraitStore(region),\n-                 ast::m_mutbl,\n+                 ast::MutMutable,\n                  EmptyBuiltinBounds())))\n }\n \n /// Records a trait-to-implementation mapping.\n fn record_trait_implementation(tcx: ctxt,\n-                               trait_def_id: def_id,\n+                               trait_def_id: DefId,\n                                implementation: @Impl) {\n     let implementation_list;\n     match tcx.trait_impls.find(&trait_def_id) {\n@@ -4597,7 +4597,7 @@ fn record_trait_implementation(tcx: ctxt,\n /// Populates the type context with all the implementations for the given type\n /// if necessary.\n pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n-                                                      type_id: ast::def_id) {\n+                                                      type_id: ast::DefId) {\n     if type_id.crate == LOCAL_CRATE {\n         return\n     }\n@@ -4652,7 +4652,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n /// trait if necessary.\n pub fn populate_implementations_for_trait_if_necessary(\n         tcx: ctxt,\n-        trait_id: ast::def_id) {\n+        trait_id: ast::DefId) {\n     if trait_id.crate == LOCAL_CRATE {\n         return\n     }\n@@ -4684,8 +4684,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n /// If the given def ID describes a trait method, returns the ID of the trait\n /// that the method belongs to. Otherwise, returns `None`.\n-pub fn trait_of_method(tcx: ctxt, def_id: ast::def_id)\n-                       -> Option<ast::def_id> {\n+pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n+                       -> Option<ast::DefId> {\n     match tcx.methods.find(&def_id) {\n         Some(method_descriptor) => {\n             match method_descriptor.container {"}, {"sha": "c0825a9c0b6b8d01e7fd233608581631d6d657a9", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -74,8 +74,8 @@ use util::common::indenter;\n \n pub trait AstConv {\n     fn tcx(&self) -> ty::ctxt;\n-    fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n-    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef;\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty;\n+    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> ty::t;\n@@ -132,7 +132,7 @@ pub fn ast_region_to_region<AC:AstConv,RS:RegionScope + Clone + 'static>(\n fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n-    def_id: ast::def_id,\n+    def_id: ast::DefId,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n     path: &ast::Path) -> ty::substs\n@@ -203,7 +203,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n                                  RS:RegionScope + Clone + 'static>(\n                                  this: &AC,\n                                  rscope: &RS,\n-                                 did: ast::def_id,\n+                                 did: ast::DefId,\n                                  path: &ast::Path)\n                                  -> ty_param_substs_and_ty {\n     let tcx = this.tcx();\n@@ -220,7 +220,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n-    trait_def_id: ast::def_id,\n+    trait_def_id: ast::DefId,\n     self_ty: Option<ty::t>,\n     path: &ast::Path) -> @ty::TraitRef\n {\n@@ -243,7 +243,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         this: &AC,\n         rscope: &RS,\n-        did: ast::def_id,\n+        did: ast::DefId,\n         path: &ast::Path)\n      -> ty_param_substs_and_ty\n {\n@@ -286,7 +286,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n         match a_seq_ty.ty.node {\n             ast::ty_vec(ref mt) => {\n                 let mut mt = ast_mt_to_mt(this, rscope, mt);\n-                if a_seq_ty.mutbl == ast::m_mutbl {\n+                if a_seq_ty.mutbl == ast::MutMutable {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n@@ -296,11 +296,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n                 match tcx.def_map.find(&id) {\n-                    Some(&ast::def_prim_ty(ast::ty_str)) if a_seq_ty.mutbl == ast::m_imm => {\n+                    Some(&ast::DefPrimTy(ast::ty_str)) if a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n                     }\n-                    Some(&ast::def_trait(trait_def_id)) => {\n+                    Some(&ast::DefTrait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n                             this, rscope, trait_def_id, None, path);\n                         let trait_store = match vst {\n@@ -430,14 +430,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n         // Kind bounds on path types are only supported for traits.\n         match a_def {\n             // But don't emit the error if the user meant to do a trait anyway.\n-            ast::def_trait(*) => { },\n+            ast::DefTrait(*) => { },\n             _ if bounds.is_some() =>\n                 tcx.sess.span_err(ast_ty.span,\n                     \"kind bounds can only be used on trait types\"),\n             _ => { },\n         }\n         match a_def {\n-          ast::def_trait(_) => {\n+          ast::DefTrait(_) => {\n               let path_str = path_to_str(path, tcx.sess.intr());\n               tcx.sess.span_err(\n                   ast_ty.span,\n@@ -446,10 +446,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n                        path_str, path_str, path_str, path_str));\n               ty::mk_err()\n           }\n-          ast::def_ty(did) | ast::def_struct(did) => {\n+          ast::DefTy(did) | ast::DefStruct(did) => {\n             ast_path_to_ty(this, rscope, did, path).ty\n           }\n-          ast::def_prim_ty(nty) => {\n+          ast::DefPrimTy(nty) => {\n             match nty {\n               ast::ty_bool => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -475,11 +475,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n               }\n             }\n           }\n-          ast::def_ty_param(id, n) => {\n+          ast::DefTyParam(id, n) => {\n             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, n, id)\n           }\n-          ast::def_self_ty(id) => {\n+          ast::DefSelfTy(id) => {\n             // n.b.: resolve guarantees that the this type only appears in a\n             // trait, which we rely upon in various places when creating\n             // substs\n@@ -684,7 +684,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n             ast::sty_uniq => {\n                 Some(ty::mk_uniq(this.tcx(),\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n-                                         mutbl: ast::m_imm}))\n+                                         mutbl: ast::MutImmutable}))\n             }\n         }\n     }\n@@ -788,7 +788,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n                 match *ast_bound {\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n-                            ast::def_trait(trait_did) => {\n+                            ast::DefTrait(trait_did) => {\n                                 if ty::try_add_builtin_trait(tcx, trait_did,\n                                                              &mut builtin_bounds) {\n                                     loop; // success"}, {"sha": "bb3ed2e15d03f34104e6e789e71aae2db592360a", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -25,9 +25,9 @@ use syntax::codemap::Span;\n use syntax::print::pprust;\n \n pub fn check_match(fcx: @mut FnCtxt,\n-                   expr: @ast::expr,\n-                   discrim: @ast::expr,\n-                   arms: &[ast::arm]) {\n+                   expr: @ast::Expr,\n+                   discrim: @ast::Expr,\n+                   arms: &[ast::Arm]) {\n     let tcx = fcx.ccx.tcx;\n \n     let discrim_ty = fcx.infcx().next_ty_var();\n@@ -105,8 +105,8 @@ pub struct pat_ctxt {\n     map: PatIdMap,\n }\n \n-pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n-                         subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n+                         subpats: &Option<~[@ast::Pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -286,9 +286,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: Span,\n                                path: &ast::Path,\n-                               fields: &[ast::field_pat],\n+                               fields: &[ast::FieldPat],\n                                class_fields: ~[ty::field_ty],\n-                               class_id: ast::def_id,\n+                               class_id: ast::DefId,\n                                substitutions: &ty::substs,\n                                etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -340,8 +340,8 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n                         expected: ty::t, path: &ast::Path,\n-                        fields: &[ast::field_pat], etc: bool,\n-                        struct_id: ast::def_id,\n+                        fields: &[ast::FieldPat], etc: bool,\n+                        struct_id: ast::DefId,\n                         substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -350,11 +350,11 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n \n     // Check to ensure that the struct is the one specified.\n     match tcx.def_map.find(&pat_id) {\n-        Some(&ast::def_struct(supplied_def_id))\n+        Some(&ast::DefStruct(supplied_def_id))\n                 if supplied_def_id == struct_id => {\n             // OK.\n         }\n-        Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n+        Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               fmt!(\"mismatched types: expected `%s` but found `%s`\",\n@@ -375,24 +375,24 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           span: Span,\n                                           expected: ty::t,\n                                           path: &ast::Path,\n-                                          fields: &[ast::field_pat],\n+                                          fields: &[ast::FieldPat],\n                                           etc: bool,\n-                                          enum_id: ast::def_id,\n+                                          enum_id: ast::DefId,\n                                           substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Find the variant that was specified.\n     match tcx.def_map.find(&pat_id) {\n-        Some(&ast::def_variant(found_enum_id, variant_id))\n+        Some(&ast::DefVariant(found_enum_id, variant_id))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n             let class_fields = ty::lookup_struct_fields(tcx, variant_id);\n \n             check_struct_pat_fields(pcx, span, path, fields, class_fields,\n                                     variant_id, substitutions, etc);\n         }\n-        Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n+        Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               fmt!(\"mismatched types: expected `%s` but \\\n@@ -408,19 +408,19 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n     match pat.node {\n-      ast::pat_wild => {\n+      ast::PatWild => {\n         fcx.write_ty(pat.id, expected);\n       }\n-      ast::pat_lit(lt) => {\n+      ast::PatLit(lt) => {\n         check_expr_has_type(fcx, lt, expected);\n         fcx.write_ty(pat.id, fcx.expr_ty(lt));\n       }\n-      ast::pat_range(begin, end) => {\n+      ast::PatRange(begin, end) => {\n         check_expr_has_type(fcx, begin, expected);\n         check_expr_has_type(fcx, end, expected);\n         let b_ty =\n@@ -451,18 +451,18 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n-      ast::pat_enum(*) |\n-      ast::pat_ident(*) if pat_is_const(tcx.def_map, pat) => {\n+      ast::PatEnum(*) |\n+      ast::PatIdent(*) if pat_is_const(tcx.def_map, pat) => {\n         let const_did = ast_util::def_id_of_def(tcx.def_map.get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n-      ast::pat_ident(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n-          ast::bind_by_ref(mutbl) => {\n+          ast::BindByRef(mutbl) => {\n             // if the binding is like\n             //    ref x | ref const x | ref mut x\n             // then the type of x is &M T where M is the mutability\n@@ -475,7 +475,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n           // otherwise the type of x is the expected type T\n-          ast::bind_infer => {\n+          ast::BindInfer => {\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }\n@@ -494,13 +494,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ => ()\n         }\n       }\n-      ast::pat_ident(_, ref path, _) => {\n+      ast::PatIdent(_, ref path, _) => {\n         check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n       }\n-      ast::pat_enum(ref path, ref subpats) => {\n+      ast::PatEnum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_struct(ref path, ref fields, etc) => {\n+      ast::PatStruct(ref path, ref fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         let mut error_happened = false;\n@@ -524,7 +524,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                                          Some(expected), ~\"a structure pattern\",\n                                          None);\n                 match tcx.def_map.find(&pat.id) {\n-                    Some(&ast::def_struct(supplied_def_id)) => {\n+                    Some(&ast::DefStruct(supplied_def_id)) => {\n                          check_struct_pat(pcx, pat.id, pat.span, ty::mk_err(), path, *fields, etc,\n                          supplied_def_id,\n                          &ty::substs { self_ty: None, tps: ~[], regions: ty::ErasedRegions} );\n@@ -542,7 +542,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.write_ty(pat.id, expected);\n         }\n       }\n-      ast::pat_tup(ref elts) => {\n+      ast::PatTup(ref elts) => {\n         let s = structure_of(fcx, pat.span, expected);\n         let e_count = elts.len();\n         match *s {\n@@ -572,16 +572,16 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n         }\n       }\n-      ast::pat_box(inner) => {\n+      ast::PatBox(inner) => {\n           check_pointer_pat(pcx, Managed, inner, pat.id, pat.span, expected);\n       }\n-      ast::pat_uniq(inner) => {\n+      ast::PatUniq(inner) => {\n           check_pointer_pat(pcx, Send, inner, pat.id, pat.span, expected);\n       }\n-      ast::pat_region(inner) => {\n+      ast::PatRegion(inner) => {\n           check_pointer_pat(pcx, Borrowed, inner, pat.id, pat.span, expected);\n       }\n-      ast::pat_vec(ref before, slice, ref after) => {\n+      ast::PatVec(ref before, slice, ref after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n@@ -649,7 +649,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n // Helper function to check @, ~ and & patterns\n pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n-                         inner: @ast::pat,\n+                         inner: @ast::Pat,\n                          pat_id: ast::NodeId,\n                          span: Span,\n                          expected: ty::t) {"}, {"sha": "dc718bbef752f41108769bdb327b29e157132cb5", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -57,7 +57,7 @@ pub fn eqtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n pub fn coerce(fcx: @mut FnCtxt,\n               sp: Span,\n               expected: ty::t,\n-              expr: @ast::expr) {\n+              expr: @ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "75ccfdbf9ddbd000009ab307119c5c1c93e45b4e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -100,9 +100,9 @@ use std::hashmap::HashSet;\n use std::result;\n use std::vec;\n use extra::list::Nil;\n-use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n+use syntax::ast::{DefId, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, NodeId};\n-use syntax::ast::{m_mutbl, m_imm};\n+use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::ast_map;\n \n@@ -122,8 +122,8 @@ pub fn lookup(\n         fcx: @mut FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: @ast::expr,                   // The expression `a.b(...)`.\n-        self_expr: @ast::expr,              // The expression `a`.\n+        expr: @ast::Expr,                   // The expression `a.b(...)`.\n+        self_expr: @ast::Expr,              // The expression `a`.\n         callee_id: NodeId,                  /* Where to store `a.b`'s type,\n                                              * also the scope of the call */\n         m_name: ast::Ident,                 // The ident `b`.\n@@ -170,12 +170,12 @@ pub fn lookup(\n \n pub struct LookupContext<'self> {\n     fcx: @mut FnCtxt,\n-    expr: @ast::expr,\n-    self_expr: @ast::expr,\n+    expr: @ast::Expr,\n+    self_expr: @ast::Expr,\n     callee_id: NodeId,\n     m_name: ast::Ident,\n     supplied_tps: &'self [ty::t],\n-    impl_dups: @mut HashSet<def_id>,\n+    impl_dups: @mut HashSet<DefId>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n@@ -205,7 +205,7 @@ pub struct Candidate {\n /// because traits are not types, this is a pain to do.\n #[deriving(Clone)]\n enum RcvrMatchCondition {\n-    RcvrMatchesIfObject(ast::def_id),\n+    RcvrMatchesIfObject(ast::DefId),\n     RcvrMatchesIfSubtype(ty::t)\n }\n \n@@ -371,7 +371,7 @@ impl<'self> LookupContext<'self> {\n     // to a trait and its supertraits.\n     fn get_method_index(&self,\n                         trait_ref: @TraitRef,\n-                        subtrait_id: ast::def_id,\n+                        subtrait_id: ast::DefId,\n                         n_method: uint) -> uint {\n         let tcx = self.tcx();\n \n@@ -395,7 +395,7 @@ impl<'self> LookupContext<'self> {\n \n \n     fn push_inherent_candidates_from_object(&self,\n-                                            did: def_id,\n+                                            did: DefId,\n                                             substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_object(did=%s, substs=%s)\",\n                self.did_to_str(did),\n@@ -468,7 +468,7 @@ impl<'self> LookupContext<'self> {\n \n     fn push_inherent_candidates_from_self(&self,\n                                               self_ty: ty::t,\n-                                              did: def_id) {\n+                                              did: DefId) {\n         let tcx = self.tcx();\n \n         let trait_ref = ty::lookup_trait_def(tcx, did).trait_ref;\n@@ -537,7 +537,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n \n-    fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n+    fn push_inherent_impl_candidates_for_type(&self, did: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n@@ -686,7 +686,7 @@ impl<'self> LookupContext<'self> {\n             // the default method code fails when you try to reborrow\n             // because it is not handling types correctly. In lieu of\n             // fixing that, I am introducing this horrible hack. - ndm\n-            self_mt.mutbl == m_imm && ty::type_is_self(self_mt.ty)\n+            self_mt.mutbl == MutImmutable && ty::type_is_self(self_mt.ty)\n         }\n     }\n \n@@ -708,7 +708,7 @@ impl<'self> LookupContext<'self> {\n             ty_evec(mt, vstore_fixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVec, autoderefs, [m_imm, m_mutbl],\n+                    AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_evec(tcx,\n                                       ty::mt {ty:mt.ty, mutbl:m},\n                                       vstore_slice(r)));\n@@ -717,7 +717,7 @@ impl<'self> LookupContext<'self> {\n \n                 // Then try to borrow to a slice *and* borrow a pointer.\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVecRef, autoderefs, [m_imm, m_mutbl],\n+                    AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| {\n                         let slice_ty = ty::mk_evec(tcx,\n                                                    ty::mt {ty:mt.ty, mutbl:m},\n@@ -727,21 +727,21 @@ impl<'self> LookupContext<'self> {\n                         // to a temporary pointer (the borrowed\n                         // slice), so any update the callee makes to\n                         // it can't be observed.\n-                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m_imm})\n+                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n                     })\n             }\n \n             ty_estr(vstore_box) |\n             ty_estr(vstore_uniq) |\n             ty_estr(vstore_fixed(_)) => {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVec, autoderefs, [m_imm],\n+                    AutoBorrowVec, autoderefs, [MutImmutable],\n                     |_m,r| ty::mk_estr(tcx, vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n \n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVecRef, autoderefs, [m_imm],\n+                    AutoBorrowVecRef, autoderefs, [MutImmutable],\n                     |m,r| {\n                         let slice_ty = ty::mk_estr(tcx, vstore_slice(r));\n                         ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n@@ -752,7 +752,7 @@ impl<'self> LookupContext<'self> {\n                 // Coerce ~/@/&Trait instances to &Trait.\n \n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowObj, autoderefs, [m_imm, m_mutbl],\n+                    AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n                     |trt_mut, reg| {\n                         ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n                                      RegionTraitStore(reg), trt_mut, b)\n@@ -787,7 +787,7 @@ impl<'self> LookupContext<'self> {\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n             ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoPtr, autoderefs, [m_imm, m_mutbl],\n+                    AutoPtr, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n@@ -803,10 +803,10 @@ impl<'self> LookupContext<'self> {\n \n     fn search_for_some_kind_of_autorefd_method(\n         &self,\n-        kind: &fn(Region, ast::mutability) -> ty::AutoRef,\n+        kind: &fn(Region, ast::Mutability) -> ty::AutoRef,\n         autoderefs: uint,\n-        mutbls: &[ast::mutability],\n-        mk_autoref_ty: &fn(ast::mutability, ty::Region) -> ty::t)\n+        mutbls: &[ast::Mutability],\n+        mk_autoref_ty: &fn(ast::Mutability, ty::Region) -> ty::t)\n         -> Option<method_map_entry> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n@@ -1050,7 +1050,7 @@ impl<'self> LookupContext<'self> {\n \n     fn construct_transformed_self_ty_for_object(\n         &self,\n-        trait_def_id: ast::def_id,\n+        trait_def_id: ast::DefId,\n         rcvr_substs: &ty::substs,\n         method_ty: &ty::Method) -> ty::t\n     {\n@@ -1252,7 +1252,7 @@ impl<'self> LookupContext<'self> {\n             }\n         };\n \n-        fn rcvr_matches_object(self_did: ast::def_id,\n+        fn rcvr_matches_object(self_did: ast::DefId,\n                                candidate: &Candidate) -> bool {\n             match candidate.rcvr_match_condition {\n                 RcvrMatchesIfObject(desired_did) => {\n@@ -1277,8 +1277,8 @@ impl<'self> LookupContext<'self> {\n             }\n         }\n \n-        fn mutability_matches(self_mutbl: ast::mutability,\n-                              candidate_mutbl: ast::mutability)\n+        fn mutability_matches(self_mutbl: ast::Mutability,\n+                              candidate_mutbl: ast::Mutability)\n                               -> bool {\n             //! True if `self_mutbl <: candidate_mutbl`\n             self_mutbl == candidate_mutbl\n@@ -1299,7 +1299,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn report_static_candidate(&self, idx: uint, did: def_id) {\n+    fn report_static_candidate(&self, idx: uint, did: DefId) {\n         let span = if did.crate == ast::LOCAL_CRATE {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n@@ -1315,15 +1315,15 @@ impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn report_param_candidate(&self, idx: uint, did: def_id) {\n+    fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn report_trait_candidate(&self, idx: uint, did: def_id) {\n+    fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the type of the receiver, \\\n@@ -1351,7 +1351,7 @@ impl<'self> LookupContext<'self> {\n              cand.origin)\n     }\n \n-    fn did_to_str(&self, did: def_id) -> ~str {\n+    fn did_to_str(&self, did: DefId) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n "}, {"sha": "ddf5a91202b5e0f690b7d79692d7338d65bf4cf8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -288,7 +288,7 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n }\n \n impl ExprTyProvider for FnCtxt {\n-    fn expr_ty(&self, ex: &ast::expr) -> ty::t {\n+    fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n         self.expr_ty(ex)\n     }\n \n@@ -371,9 +371,9 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n     }\n         // Add pattern bindings.\n-    fn visit_pat(&mut self, p:@ast::pat, _:()) {\n+    fn visit_pat(&mut self, p:@ast::Pat, _:()) {\n             match p.node {\n-              ast::pat_ident(_, ref path, _)\n+              ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n@@ -657,11 +657,11 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n impl AstConv for FnCtxt {\n     fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n \n-    fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n@@ -800,11 +800,11 @@ impl FnCtxt {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n-    pub fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n+    pub fn pat_to_str(&self, pat: @ast::Pat) -> ~str {\n         pat.repr(self.tcx())\n     }\n \n-    pub fn expr_ty(&self, ex: &ast::expr) -> ty::t {\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n         match self.inh.node_types.find(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -867,7 +867,7 @@ impl FnCtxt {\n     }\n \n     pub fn mk_assignty(&self,\n-                       expr: @ast::expr,\n+                       expr: @ast::Expr,\n                        sub: ty::t,\n                        sup: ty::t)\n                        -> Result<(), ty::type_err> {\n@@ -1040,8 +1040,8 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n }\n \n pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n-                          from: @ast::expr,\n-                          to: @ast::expr)\n+                          from: @ast::Expr,\n+                          to: @ast::Expr)\n                        -> Option<bool> {\n     match const_eval::compare_lit_exprs(ccx.tcx, from, to) {\n         Some(val) => Some(val <= 0),\n@@ -1050,34 +1050,34 @@ pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n }\n \n pub fn check_expr_has_type(\n-    fcx: @mut FnCtxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     }\n }\n \n pub fn check_expr_coercable_to_type(\n-    fcx: @mut FnCtxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::coerce(fcx, expr.span, expected, expr)\n     }\n }\n \n pub fn check_expr_with_hint(\n-    fcx: @mut FnCtxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n pub fn check_expr_with_opt_hint(\n-    fcx: @mut FnCtxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::expr)  {\n+pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1088,7 +1088,7 @@ pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::expr)  {\n pub fn impl_self_ty(vcx: &VtableContext,\n                     location_info: &LocationInfo, // (potential) receiver for\n                                                   // this impl\n-                    did: ast::def_id)\n+                    did: ast::DefId)\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n \n@@ -1114,7 +1114,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n pub fn lookup_field_ty(tcx: ty::ctxt,\n-                       class_id: ast::def_id,\n+                       class_id: ast::DefId,\n                        items: &[ty::field_ty],\n                        fieldname: ast::Ident,\n                        substs: &ty::substs) -> Option<ty::t> {\n@@ -1151,7 +1151,7 @@ fn generics_of_static_method_container(type_context: ty::ctxt,\n // locations.\n fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                                           path: &ast::Path,\n-                                          def: ast::def) {\n+                                          def: ast::Def) {\n     // We only care about checking the case in which the path has two or\n     // more segments.\n     if path.segments.len() < 2 {\n@@ -1193,7 +1193,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n         // ensure that the segment of the path which names the trait or\n         // implementation (the penultimate segment) is annotated with the\n         // right number of type parameters.\n-        ast::def_static_method(_, provenance, _) => {\n+        ast::DefStaticMethod(_, provenance, _) => {\n             let generics =\n                 generics_of_static_method_container(function_context.ccx.tcx,\n                                                     provenance);\n@@ -1299,7 +1299,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n-                               expr: @ast::expr,\n+                               expr: @ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: &fn()) {\n     debug!(\">> typechecking\");\n@@ -1308,8 +1308,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx: @mut FnCtxt,\n         sp: Span,\n         method_fn_ty: ty::t,\n-        callee_expr: @ast::expr,\n-        args: &[@ast::expr],\n+        callee_expr: @ast::Expr,\n+        args: &[@ast::Expr],\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> ty::t\n     {\n@@ -1338,8 +1338,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx: @mut FnCtxt,\n         sp: Span,\n         fn_inputs: &[ty::t],\n-        callee_expr: @ast::expr,\n-        args: &[@ast::expr],\n+        callee_expr: @ast::Expr,\n+        args: &[@ast::Expr],\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs)\n     {\n@@ -1403,8 +1403,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n             for (i, arg) in args.iter().enumerate() {\n                 let is_block = match arg.node {\n-                    ast::expr_fn_block(*) |\n-                    ast::expr_do_body(*) => true,\n+                    ast::ExprFnBlock(*) |\n+                    ast::ExprDoBody(*) => true,\n                     _ => false\n                 };\n \n@@ -1439,8 +1439,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // A generic function for checking assignment expressions\n     fn check_assignment(fcx: @mut FnCtxt,\n-                        lhs: @ast::expr,\n-                        rhs: @ast::expr,\n+                        lhs: @ast::Expr,\n+                        rhs: @ast::Expr,\n                         id: ast::NodeId) {\n         check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n@@ -1450,7 +1450,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn write_call(fcx: @mut FnCtxt,\n-                  call_expr: @ast::expr,\n+                  call_expr: @ast::Expr,\n                   output: ty::t,\n                   sugar: ast::CallSugar) {\n         let ret_ty = match sugar {\n@@ -1472,9 +1472,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @mut FnCtxt,\n                   callee_id: ast::NodeId,\n-                  call_expr: @ast::expr,\n-                  f: @ast::expr,\n-                  args: &[@ast::expr],\n+                  call_expr: @ast::Expr,\n+                  f: @ast::Expr,\n+                  args: &[@ast::Expr],\n                   sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n@@ -1534,10 +1534,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // Checks a method call.\n     fn check_method_call(fcx: @mut FnCtxt,\n                          callee_id: ast::NodeId,\n-                         expr: @ast::expr,\n-                         rcvr: @ast::expr,\n+                         expr: @ast::Expr,\n+                         rcvr: @ast::Expr,\n                          method_name: ast::Ident,\n-                         args: &[@ast::expr],\n+                         args: &[@ast::Expr],\n                          tps: &[ast::Ty],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n@@ -1593,9 +1593,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @mut FnCtxt,\n-                       cond_expr: @ast::expr,\n+                       cond_expr: @ast::Expr,\n                        then_blk: &ast::Block,\n-                       opt_else_expr: Option<@ast::expr>,\n+                       opt_else_expr: Option<@ast::Expr>,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Option<ty::t>) {\n@@ -1633,11 +1633,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn lookup_op_method(fcx: @mut FnCtxt,\n                         callee_id: ast::NodeId,\n-                        op_ex: @ast::expr,\n-                        self_ex: @ast::expr,\n+                        op_ex: @ast::Expr,\n+                        self_ex: @ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Ident,\n-                        args: ~[@ast::expr],\n+                        args: ~[@ast::Expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: &fn(),\n@@ -1671,10 +1671,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // could be either a expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @mut FnCtxt,\n                    callee_id: ast::NodeId,\n-                   expr: @ast::expr,\n-                   op: ast::binop,\n-                   lhs: @ast::expr,\n-                   rhs: @ast::expr,\n+                   expr: @ast::Expr,\n+                   op: ast::BinOp,\n+                   lhs: @ast::Expr,\n+                   rhs: @ast::Expr,\n                    // Used only in the error case\n                    expected_result: Option<ty::t>,\n                    allow_overloaded_operators: AllowOverloadedOperatorsFlag\n@@ -1701,8 +1701,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             check_expr_has_type(fcx, rhs, tvar);\n \n             let result_t = match op {\n-                ast::eq | ast::ne | ast::lt | ast::le | ast::ge |\n-                ast::gt => {\n+                ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n+                ast::BiGt => {\n                     ty::mk_bool()\n                 }\n                 _ => {\n@@ -1714,7 +1714,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             return;\n         }\n \n-        if op == ast::or || op == ast::and {\n+        if op == ast::BiOr || op == ast::BiAnd {\n             // This is an error; one of the operands must have the wrong\n             // type\n             fcx.write_error(expr.id);\n@@ -1759,11 +1759,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_user_binop(fcx: @mut FnCtxt,\n                         callee_id: ast::NodeId,\n-                        ex: @ast::expr,\n-                        lhs_expr: @ast::expr,\n+                        ex: @ast::Expr,\n+                        lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n-                        op: ast::binop,\n-                        rhs: @ast::expr,\n+                        op: ast::BinOp,\n+                        rhs: @ast::Expr,\n                        expected_result: Option<ty::t>) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n@@ -1786,7 +1786,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n-        if op == ast::or {\n+        if op == ast::BiOr {\n             match ty::get(lhs_resolved_t).sty {\n                 ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n                     tcx.sess.span_note(\n@@ -1803,8 +1803,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                        callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n-                       ex: @ast::expr,\n-                       rhs_expr: @ast::expr,\n+                       ex: @ast::Expr,\n+                       rhs_expr: @ast::Expr,\n                        rhs_t: ty::t,\n                        expected_t: Option<ty::t>)\n                     -> ty::t {\n@@ -1840,7 +1840,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_expr_fn(fcx: @mut FnCtxt,\n-                     expr: @ast::expr,\n+                     expr: @ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n@@ -1934,8 +1934,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // Check field access expressions\n     fn check_field(fcx: @mut FnCtxt,\n-                   expr: @ast::expr,\n-                   base: @ast::expr,\n+                   expr: @ast::Expr,\n+                   base: @ast::Expr,\n                    field: ast::Ident,\n                    tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n@@ -2006,7 +2006,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n                                       span: Span,\n-                                      class_id: ast::def_id,\n+                                      class_id: ast::DefId,\n                                       node_id: ast::NodeId,\n                                       substitutions: ty::substs,\n                                       field_types: &[ty::field_ty],\n@@ -2097,9 +2097,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_struct_constructor(fcx: @mut FnCtxt,\n                                 id: ast::NodeId,\n                                 span: codemap::Span,\n-                                class_id: ast::def_id,\n+                                class_id: ast::DefId,\n                                 fields: &[ast::Field],\n-                                base_expr: Option<@ast::expr>) {\n+                                base_expr: Option<@ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -2186,8 +2186,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_struct_enum_variant(fcx: @mut FnCtxt,\n                                  id: ast::NodeId,\n                                  span: codemap::Span,\n-                                 enum_id: ast::def_id,\n-                                 variant_id: ast::def_id,\n+                                 enum_id: ast::DefId,\n+                                 variant_id: ast::DefId,\n                                  fields: &[ast::Field]) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -2257,20 +2257,20 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n-      ast::expr_vstore(ev, vst) => {\n+      ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n-          ast::expr_lit(@codemap::Spanned { node: ast::lit_str(_), _ }) => {\n+          ast::ExprLit(@codemap::Spanned { node: ast::lit_str(_), _ }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_estr(tcx, tt)\n           }\n-          ast::expr_vec(ref args, mutbl) => {\n+          ast::ExprVec(ref args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability;\n             let mut any_error = false;\n             let mut any_bot = false;\n             match vst {\n-                ast::expr_vstore_mut_box | ast::expr_vstore_mut_slice => {\n-                    mutability = ast::m_mutbl\n+                ast::ExprVstoreMutBox | ast::ExprVstoreMutSlice => {\n+                    mutability = ast::MutMutable\n                 }\n                 _ => mutability = mutbl\n             }\n@@ -2295,13 +2295,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n-          ast::expr_repeat(element, count_expr, mutbl) => {\n+          ast::ExprRepeat(element, count_expr, mutbl) => {\n             check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n             let _ = ty::eval_repeat_count(fcx, count_expr);\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability = match vst {\n-                ast::expr_vstore_mut_box | ast::expr_vstore_mut_slice => {\n-                    ast::m_mutbl\n+                ast::ExprVstoreMutBox | ast::ExprVstoreMutSlice => {\n+                    ast::MutMutable\n                 }\n                 _ => mutbl\n             };\n@@ -2323,11 +2323,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n \n-      ast::expr_lit(lit) => {\n+      ast::ExprLit(lit) => {\n         let typ = check_lit(fcx, lit);\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_binary(callee_id, op, lhs, rhs) => {\n+      ast::ExprBinary(callee_id, op, lhs, rhs) => {\n         check_binop(fcx,\n                     callee_id,\n                     expr,\n@@ -2348,7 +2348,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::expr_assign_op(callee_id, op, lhs, rhs) => {\n+      ast::ExprAssignOp(callee_id, op, lhs, rhs) => {\n         check_binop(fcx,\n                     callee_id,\n                     expr,\n@@ -2370,32 +2370,32 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(expr.id);\n         }\n       }\n-      ast::expr_unary(callee_id, unop, oprnd) => {\n+      ast::ExprUnary(callee_id, unop, oprnd) => {\n         let exp_inner = do unpack_expected(fcx, expected) |sty| {\n             match unop {\n-              ast::box(_) | ast::uniq => match *sty {\n+              ast::UnBox(_) | ast::UnUniq => match *sty {\n                 ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => Some(mt.ty),\n                 _ => None\n               },\n-              ast::not | ast::neg => expected,\n-              ast::deref => None\n+              ast::UnNot | ast::UnNeg => expected,\n+              ast::UnDeref => None\n             }\n         };\n         check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n         if !ty::type_is_error(oprnd_t) &&\n               !ty::type_is_bot(oprnd_t) {\n             match unop {\n-                ast::box(mutbl) => {\n+                ast::UnBox(mutbl) => {\n                     oprnd_t = ty::mk_box(tcx,\n                                          ty::mt {ty: oprnd_t, mutbl: mutbl});\n                 }\n-                ast::uniq => {\n+                ast::UnUniq => {\n                     oprnd_t = ty::mk_uniq(tcx,\n                                           ty::mt {ty: oprnd_t,\n-                                                  mutbl: ast::m_imm});\n+                                                  mutbl: ast::MutImmutable});\n                 }\n-                ast::deref => {\n+                ast::UnDeref => {\n                     let sty = structure_of(fcx, expr.span, oprnd_t);\n                     let operand_ty = ty::deref_sty(tcx, sty, true);\n                     match operand_ty {\n@@ -2425,7 +2425,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         }\n                     }\n                 }\n-                ast::not => {\n+                ast::UnNot => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n@@ -2435,7 +2435,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                   expected);\n                     }\n                 }\n-                ast::neg => {\n+                ast::UnNeg => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n@@ -2448,7 +2448,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::expr_addr_of(mutbl, oprnd) => {\n+      ast::ExprAddrOf(mutbl, oprnd) => {\n           let hint = unpack_expected(\n               fcx, expected,\n               |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n@@ -2482,20 +2482,20 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::expr_path(ref pth) => {\n+      ast::ExprPath(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n \n         check_type_parameter_positions_in_path(fcx, pth, defn);\n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n         instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n-      ast::expr_self => {\n+      ast::ExprSelf => {\n         let definition = lookup_def(fcx, expr.span, id);\n         let ty_param_bounds_and_ty =\n             ty_param_bounds_and_ty_for_def(fcx, expr.span, definition);\n         fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n       }\n-      ast::expr_inline_asm(ref ia) => {\n+      ast::ExprInlineAsm(ref ia) => {\n           for &(_, input) in ia.inputs.iter() {\n               check_expr(fcx, input);\n           }\n@@ -2504,10 +2504,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           }\n           fcx.write_nil(id);\n       }\n-      ast::expr_mac(_) => tcx.sess.bug(\"unexpanded macro\"),\n-      ast::expr_break(_) => { fcx.write_bot(id); }\n-      ast::expr_again(_) => { fcx.write_bot(id); }\n-      ast::expr_ret(expr_opt) => {\n+      ast::ExprMac(_) => tcx.sess.bug(\"unexpanded macro\"),\n+      ast::ExprBreak(_) => { fcx.write_bot(id); }\n+      ast::ExprAgain(_) => { fcx.write_bot(id); }\n+      ast::ExprRet(expr_opt) => {\n         let ret_ty = fcx.ret_ty;\n         match expr_opt {\n           None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n@@ -2525,7 +2525,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n         fcx.write_bot(id);\n       }\n-      ast::expr_log(lv, e) => {\n+      ast::ExprLog(lv, e) => {\n         check_expr_has_type(fcx, lv,\n                                   ty::mk_mach_uint(ast::ty_u32));\n \n@@ -2538,11 +2538,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::expr_paren(a) => {\n+      ast::ExprParen(a) => {\n         check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n-      ast::expr_assign(lhs, rhs) => {\n+      ast::ExprAssign(lhs, rhs) => {\n         check_assignment(fcx, lhs, rhs, id);\n         let lhs_ty = fcx.expr_ty(lhs);\n         let rhs_ty = fcx.expr_ty(rhs);\n@@ -2556,11 +2556,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::expr_if(cond, ref then_blk, opt_else_expr) => {\n+      ast::ExprIf(cond, ref then_blk, opt_else_expr) => {\n         check_then_else(fcx, cond, then_blk, opt_else_expr,\n                         id, expr.span, expected);\n       }\n-      ast::expr_while(cond, ref body) => {\n+      ast::ExprWhile(cond, ref body) => {\n         check_expr_has_type(fcx, cond, ty::mk_bool());\n         check_block_no_value(fcx, body);\n         let cond_ty = fcx.expr_ty(cond);\n@@ -2575,9 +2575,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::expr_for_loop(*) =>\n+      ast::ExprForLoop(*) =>\n           fail!(\"non-desugared expr_for_loop\"),\n-      ast::expr_loop(ref body, _) => {\n+      ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, (body));\n         if !may_break(tcx, expr.id, body) {\n             fcx.write_bot(id);\n@@ -2586,14 +2586,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::expr_match(discrim, ref arms) => {\n+      ast::ExprMatch(discrim, ref arms) => {\n         _match::check_match(fcx, expr, discrim, *arms);\n       }\n-      ast::expr_fn_block(ref decl, ref body) => {\n+      ast::ExprFnBlock(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n                       decl, body, Vanilla, expected);\n       }\n-      ast::expr_do_body(b) => {\n+      ast::ExprDoBody(b) => {\n         let expected_sty = unpack_expected(fcx,\n                                            expected,\n                                            |x| Some((*x).clone()));\n@@ -2618,7 +2618,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         };\n         match b.node {\n-          ast::expr_fn_block(ref decl, ref body) => {\n+          ast::ExprFnBlock(ref decl, ref body) => {\n             check_expr_fn(fcx, b, None,\n                           decl, body, DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n@@ -2628,11 +2628,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n-      ast::expr_block(ref b) => {\n+      ast::ExprBlock(ref b) => {\n         check_block_with_expected(fcx, b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n-      ast::expr_call(f, ref args, sugar) => {\n+      ast::ExprCall(f, ref args, sugar) => {\n           check_call(fcx, expr.id, expr, f, *args, sugar);\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.iter().fold((false, false),\n@@ -2648,7 +2648,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n               fcx.write_bot(id);\n           }\n       }\n-      ast::expr_method_call(callee_id, rcvr, ident, ref tps, ref args, sugar) => {\n+      ast::ExprMethodCall(callee_id, rcvr, ident, ref tps, ref args, sugar) => {\n         check_method_call(fcx, callee_id, expr, rcvr, ident, *args, *tps, sugar);\n         let f_ty = fcx.expr_ty(rcvr);\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n@@ -2663,7 +2663,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::expr_cast(e, ref t) => {\n+      ast::ExprCast(e, ref t) => {\n         check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n@@ -2757,7 +2757,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_ty(id, t_1);\n         }\n       }\n-      ast::expr_vec(ref args, mutbl) => {\n+      ast::ExprVec(ref args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n         for e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n@@ -2766,7 +2766,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_repeat(element, count_expr, mutbl) => {\n+      ast::ExprRepeat(element, count_expr, mutbl) => {\n         check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, count_expr);\n         let t: ty::t = fcx.infcx().next_ty_var();\n@@ -2784,7 +2784,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_ty(id, t);\n         }\n       }\n-      ast::expr_tup(ref elts) => {\n+      ast::ExprTup(ref elts) => {\n         let flds = unpack_expected(fcx, expected, |sty| {\n             match *sty {\n                 ty::ty_tup(ref flds) => Some((*flds).clone()),\n@@ -2814,14 +2814,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n       }\n-      ast::expr_struct(ref path, ref fields, base_expr) => {\n+      ast::ExprStruct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(&id) {\n-            Some(&ast::def_struct(type_def_id)) => {\n+            Some(&ast::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          *fields, base_expr);\n             }\n-            Some(&ast::def_variant(enum_id, variant_id)) => {\n+            Some(&ast::DefVariant(enum_id, variant_id)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, *fields);\n             }\n@@ -2831,10 +2831,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         }\n       }\n-      ast::expr_field(base, field, ref tys) => {\n+      ast::ExprField(base, field, ref tys) => {\n         check_field(fcx, expr, base, field, *tys);\n       }\n-      ast::expr_index(callee_id, base, idx) => {\n+      ast::ExprIndex(callee_id, base, idx) => {\n           check_expr(fcx, base);\n           check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n@@ -2908,7 +2908,7 @@ pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n \n pub fn check_decl_initializer(fcx: @mut FnCtxt,\n                               nid: ast::NodeId,\n-                              init: @ast::expr)\n+                              init: @ast::Expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n@@ -2942,39 +2942,39 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n+pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n     match stmt.node {\n-      ast::stmt_decl(decl, id) => {\n+      ast::StmtDecl(decl, id) => {\n         node_id = id;\n         match decl.node {\n-          ast::decl_local(ref l) => {\n+          ast::DeclLocal(ref l) => {\n               check_decl_local(fcx, *l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || ty::type_is_bot(l_t);\n               saw_err = saw_err || ty::type_is_error(l_t);\n           }\n-          ast::decl_item(_) => {/* ignore for now */ }\n+          ast::DeclItem(_) => {/* ignore for now */ }\n         }\n       }\n-      ast::stmt_expr(expr, id) => {\n+      ast::StmtExpr(expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n         check_expr_has_type(fcx, expr, ty::mk_nil());\n         let expr_ty = fcx.expr_ty(expr);\n         saw_bot = saw_bot || ty::type_is_bot(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n       }\n-      ast::stmt_semi(expr, id) => {\n+      ast::StmtSemi(expr, id) => {\n         node_id = id;\n         check_expr(fcx, expr);\n         let expr_ty = fcx.expr_ty(expr);\n         saw_bot |= ty::type_is_bot(expr_ty);\n         saw_err |= ty::type_is_error(expr_ty);\n       }\n-      ast::stmt_mac(*) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n+      ast::StmtMac(*) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n     }\n     if saw_bot {\n         fcx.write_bot(node_id);\n@@ -3022,9 +3022,9 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n             let s_id = ast_util::stmt_id(*s);\n             let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n-                  ast::stmt_decl(@codemap::Spanned { node: ast::decl_local(_),\n+                  ast::StmtDecl(@codemap::Spanned { node: ast::DeclLocal(_),\n                                                  _}, _) |\n-                  ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n+                  ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => {\n                     true\n                   }\n                   _ => false\n@@ -3071,7 +3071,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n \n pub fn check_const(ccx: @mut CrateCtxt,\n                    sp: Span,\n-                   e: @ast::expr,\n+                   e: @ast::Expr,\n                    id: ast::NodeId) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n@@ -3081,7 +3081,7 @@ pub fn check_const(ccx: @mut CrateCtxt,\n \n pub fn check_const_with_ty(fcx: @mut FnCtxt,\n                            _: Span,\n-                           e: @ast::expr,\n+                           e: @ast::Expr,\n                            declty: ty::t) {\n     check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n@@ -3236,54 +3236,54 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) -> ast::def {\n+pub fn lookup_def(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n                                       sp: Span,\n-                                      defn: ast::def)\n+                                      defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n-      ast::def_arg(nid, _) | ast::def_local(nid, _) | ast::def_self(nid) |\n-      ast::def_binding(nid, _) => {\n+      ast::DefArg(nid, _) | ast::DefLocal(nid, _) | ast::DefSelf(nid) |\n+      ast::DefBinding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n-      ast::def_fn(id, _) | ast::def_static_method(id, _, _) |\n-      ast::def_static(id, _) | ast::def_variant(_, id) |\n-      ast::def_struct(id) => {\n+      ast::DefFn(id, _) | ast::DefStaticMethod(id, _, _) |\n+      ast::DefStatic(id, _) | ast::DefVariant(_, id) |\n+      ast::DefStruct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n-      ast::def_upvar(_, inner, _, _) => {\n+      ast::DefUpvar(_, inner, _, _) => {\n         return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n-      ast::def_trait(_) |\n-      ast::def_ty(_) |\n-      ast::def_prim_ty(_) |\n-      ast::def_ty_param(*)=> {\n+      ast::DefTrait(_) |\n+      ast::DefTy(_) |\n+      ast::DefPrimTy(_) |\n+      ast::DefTyParam(*)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type\");\n       }\n-      ast::def_mod(*) | ast::def_foreign_mod(*) => {\n+      ast::DefMod(*) | ast::DefForeignMod(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found module\");\n       }\n-      ast::def_use(*) => {\n+      ast::DefUse(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found use\");\n       }\n-      ast::def_region(*) => {\n+      ast::DefRegion(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found region\");\n       }\n-      ast::def_typaram_binder(*) => {\n+      ast::DefTyParamBinder(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type parameter\");\n       }\n-      ast::def_label(*) => {\n+      ast::DefLabel(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found label\");\n       }\n-      ast::def_self_ty(*) => {\n+      ast::DefSelfTy(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n-      ast::def_method(*) => {\n+      ast::DefMethod(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found method\");\n       }\n     }\n@@ -3294,7 +3294,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n-                        def: ast::def,\n+                        def: ast::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n@@ -3341,7 +3341,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     // of type parameters actually manifest in the AST. This will differ from\n     // the internal type parameter count when there are self types involved.\n     let (user_type_parameter_count, self_parameter_index) = match def {\n-        ast::def_static_method(_, provenance @ ast::FromTrait(_), _) => {\n+        ast::DefStaticMethod(_, provenance @ ast::FromTrait(_), _) => {\n             let generics = generics_of_static_method_container(fcx.ccx.tcx,\n                                                                provenance);\n             (ty_param_count - 1, Some(generics.type_param_defs.len()))\n@@ -3455,13 +3455,13 @@ pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n }\n \n pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n-                                 e: @ast::expr,\n-                                 v: ast::expr_vstore)\n+                                 e: @ast::Expr,\n+                                 v: ast::ExprVstore)\n                               -> ty::vstore {\n     match v {\n-        ast::expr_vstore_uniq => ty::vstore_uniq,\n-        ast::expr_vstore_box | ast::expr_vstore_mut_box => ty::vstore_box,\n-        ast::expr_vstore_slice | ast::expr_vstore_mut_slice => {\n+        ast::ExprVstoreUniq => ty::vstore_uniq,\n+        ast::ExprVstoreBox | ast::ExprVstoreMutBox => ty::vstore_box,\n+        ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n             let r = fcx.infcx().next_region_var(infer::AddrOfSlice(e.span));\n             ty::vstore_slice(r)\n         }\n@@ -3474,17 +3474,17 @@ pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // inside the loop?\n     (loop_query(b, |e| {\n         match *e {\n-            ast::expr_break(_) => true,\n+            ast::ExprBreak(_) => true,\n             _ => false\n         }\n     })) ||\n    // Second: is there a labeled break with label\n    // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n         match e.node {\n-            ast::expr_break(Some(_)) =>\n+            ast::ExprBreak(Some(_)) =>\n                 match cx.def_map.find(&e.id) {\n-                    Some(&ast::def_label(loop_id)) if id == loop_id => true,\n+                    Some(&ast::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 },\n             _ => false\n@@ -3610,7 +3610,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n-                  mutbl: ast::m_imm\n+                  mutbl: ast::MutImmutable\n               });\n               (1u, ~[], td_ptr)\n             }\n@@ -3627,7 +3627,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n \n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n-                  mutbl: ast::m_imm\n+                  mutbl: ast::MutImmutable\n               });\n               (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n             }\n@@ -3654,25 +3654,25 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_imm\n+                      mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_int()\n                ],\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n-                   mutbl: ast::m_imm\n+                   mutbl: ast::MutImmutable\n                }))\n             }\n             \"memcpy32\" => {\n               (1,\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_mutbl\n+                      mutbl: ast::MutMutable\n                   }),\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_imm\n+                      mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_u32()\n                ],\n@@ -3683,11 +3683,11 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_mutbl\n+                      mutbl: ast::MutMutable\n                   }),\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_imm\n+                      mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_u64()\n                ],\n@@ -3698,11 +3698,11 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_mutbl\n+                      mutbl: ast::MutMutable\n                   }),\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_imm\n+                      mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_u32()\n                ],\n@@ -3713,11 +3713,11 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_mutbl\n+                      mutbl: ast::MutMutable\n                   }),\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_imm\n+                      mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_u64()\n                ],\n@@ -3728,7 +3728,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_mutbl\n+                      mutbl: ast::MutMutable\n                   }),\n                   ty::mk_u8(),\n                   ty::mk_u32()\n@@ -3740,7 +3740,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ~[\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n-                      mutbl: ast::m_mutbl\n+                      mutbl: ast::MutMutable\n                   }),\n                   ty::mk_u8(),\n                   ty::mk_u64()"}, {"sha": "d121496af2b2dec398c13dee98ffd5ac3bdfb4d4", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -40,7 +40,7 @@ use util::ppaux::{ty_to_str, region_to_str};\n use middle::pat_util;\n \n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n-use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n+use syntax::ast::{DefArg, DefBinding, DefLocal, DefSelf, DefUpvar};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -54,14 +54,14 @@ pub struct Rcx {\n     repeating_scope: ast::NodeId,\n }\n \n-fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n+fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n-        def_local(node_id, _) | def_arg(node_id, _) |\n-        def_self(node_id) | def_binding(node_id, _) => {\n+        DefLocal(node_id, _) | DefArg(node_id, _) |\n+        DefSelf(node_id) | DefBinding(node_id, _) => {\n             tcx.region_maps.encl_region(node_id)\n         }\n-        def_upvar(_, subdef, closure_id, body_id) => {\n+        DefUpvar(_, subdef, closure_id, body_id) => {\n             match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n                 BorrowedSigil => encl_region_of_def(fcx, *subdef),\n                 ManagedSigil | OwnedSigil => re_scope(body_id)\n@@ -127,7 +127,7 @@ impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n+    pub fn resolve_expr_type_adjusted(@mut self, expr: @ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n             ty_unadjusted\n@@ -140,7 +140,7 @@ impl Rcx {\n     }\n }\n \n-pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n+pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n     let rcx = @mut Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n     if fcx.err_count_since_creation() == 0 {\n@@ -175,11 +175,11 @@ impl Visitor<@mut Rcx> for RegionckVisitor {\n \n     fn visit_item(&mut self, i:@ast::item, e:@mut Rcx) { visit_item(self, i, e); }\n \n-    fn visit_expr(&mut self, ex:@ast::expr, e:@mut Rcx) { visit_expr(self, ex, e); }\n+    fn visit_expr(&mut self, ex:@ast::Expr, e:@mut Rcx) { visit_expr(self, ex, e); }\n \n         //visit_pat: visit_pat, // (*) see above\n \n-    fn visit_arm(&mut self, a:&ast::arm, e:@mut Rcx) { visit_arm(self, a, e); }\n+    fn visit_arm(&mut self, a:&ast::Arm, e:@mut Rcx) { visit_arm(self, a, e); }\n \n     fn visit_local(&mut self, l:@ast::Local, e:@mut Rcx) { visit_local(self, l, e); }\n \n@@ -199,7 +199,7 @@ fn visit_block(v: &mut RegionckVisitor, b: &ast::Block, rcx: @mut Rcx) {\n     visit::walk_block(v, b, rcx);\n }\n \n-fn visit_arm(v: &mut RegionckVisitor, arm: &ast::arm, rcx: @mut Rcx) {\n+fn visit_arm(v: &mut RegionckVisitor, arm: &ast::Arm, rcx: @mut Rcx) {\n     // see above\n     for &p in arm.pats.iter() {\n         constrain_bindings_in_pat(p, rcx);\n@@ -214,7 +214,7 @@ fn visit_local(v: &mut RegionckVisitor, l: @ast::Local, rcx: @mut Rcx) {\n     visit::walk_local(v, l, rcx);\n }\n \n-fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n+fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: @mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat=%s)\", pat.repr(tcx));\n     do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n@@ -248,7 +248,7 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n     }\n }\n \n-fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n+fn visit_expr(v: &mut RegionckVisitor, expr: @ast::Expr, rcx: @mut Rcx) {\n     debug!(\"regionck::visit_expr(e=%s, repeating_scope=%?)\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n@@ -271,32 +271,32 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n         //\n         // ast::expr_assign_op(*) |\n \n-        ast::expr_index(*) |\n-        ast::expr_binary(*) |\n-        ast::expr_unary(*) if has_method_map => {\n+        ast::ExprIndex(*) |\n+        ast::ExprBinary(*) |\n+        ast::ExprUnary(*) if has_method_map => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n         }\n-        ast::expr_binary(_, ast::and, lhs, rhs) |\n-        ast::expr_binary(_, ast::or, lhs, rhs) => {\n+        ast::ExprBinary(_, ast::BiAnd, lhs, rhs) |\n+        ast::ExprBinary(_, ast::BiOr, lhs, rhs) => {\n             tcx.region_maps.record_cleanup_scope(lhs.id);\n             tcx.region_maps.record_cleanup_scope(rhs.id);\n         }\n-        ast::expr_call(*) |\n-        ast::expr_method_call(*) => {\n+        ast::ExprCall(*) |\n+        ast::ExprMethodCall(*) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n         }\n-        ast::expr_match(_, ref arms) => {\n+        ast::ExprMatch(_, ref arms) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n             for arm in arms.iter() {\n                 for guard in arm.guard.iter() {\n                     tcx.region_maps.record_cleanup_scope(guard.id);\n                 }\n             }\n         }\n-        ast::expr_loop(ref body, _) => {\n+        ast::ExprLoop(ref body, _) => {\n             tcx.region_maps.record_cleanup_scope(body.id);\n         }\n-        ast::expr_while(cond, ref body) => {\n+        ast::ExprWhile(cond, ref body) => {\n             tcx.region_maps.record_cleanup_scope(cond.id);\n             tcx.region_maps.record_cleanup_scope(body.id);\n         }\n@@ -332,22 +332,22 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n     }\n \n     match expr.node {\n-        ast::expr_call(callee, ref args, _) => {\n+        ast::ExprCall(callee, ref args, _) => {\n             constrain_callee(rcx, callee.id, expr, callee);\n             constrain_call(rcx, callee.id, expr, None, *args, false);\n \n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_method_call(callee_id, arg0, _, _, ref args, _) => {\n+        ast::ExprMethodCall(callee_id, arg0, _, _, ref args, _) => {\n             constrain_call(rcx, callee_id, expr, Some(arg0), *args, false);\n \n             visit::walk_expr(v,expr, rcx);\n         }\n \n-        ast::expr_index(callee_id, lhs, rhs) |\n-        ast::expr_assign_op(callee_id, _, lhs, rhs) |\n-        ast::expr_binary(callee_id, _, lhs, rhs) if has_method_map => {\n+        ast::ExprIndex(callee_id, lhs, rhs) |\n+        ast::ExprAssignOp(callee_id, _, lhs, rhs) |\n+        ast::ExprBinary(callee_id, _, lhs, rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n@@ -357,30 +357,30 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_unary(callee_id, _, lhs) if has_method_map => {\n+        ast::ExprUnary(callee_id, _, lhs) if has_method_map => {\n             // As above.\n             constrain_call(rcx, callee_id, expr, Some(lhs), [], true);\n \n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_unary(_, ast::deref, base) => {\n+        ast::ExprUnary(_, ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let base_ty = rcx.resolve_node_type(base.id);\n             constrain_derefs(rcx, expr, 1, base_ty);\n \n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_index(_, vec_expr, _) => {\n+        ast::ExprIndex(_, vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_cast(source, _) => {\n+        ast::ExprCast(source, _) => {\n             // Determine if we are casting `source` to an trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n@@ -410,7 +410,7 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_addr_of(_, base) => {\n+        ast::ExprAddrOf(_, base) => {\n             guarantor::for_addr_of(rcx, expr, base);\n \n             // Require that when you write a `&expr` expression, the\n@@ -426,23 +426,23 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_match(discr, ref arms) => {\n+        ast::ExprMatch(discr, ref arms) => {\n             guarantor::for_match(rcx, discr, *arms);\n \n             visit::walk_expr(v, expr, rcx);\n         }\n \n-        ast::expr_fn_block(*) => {\n+        ast::ExprFnBlock(*) => {\n             check_expr_fn_block(rcx, expr, v);\n         }\n \n-        ast::expr_loop(ref body, _) => {\n+        ast::ExprLoop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n             visit::walk_expr(v, expr, rcx);\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        ast::expr_while(cond, ref body) => {\n+        ast::ExprWhile(cond, ref body) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n             v.visit_expr(cond, rcx);\n \n@@ -459,11 +459,11 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::expr, rcx: @mut Rcx) {\n }\n \n fn check_expr_fn_block(rcx: @mut Rcx,\n-                       expr: @ast::expr,\n+                       expr: @ast::Expr,\n                        v: &mut RegionckVisitor) {\n     let tcx = rcx.fcx.tcx();\n     match expr.node {\n-        ast::expr_fn_block(_, ref body) => {\n+        ast::ExprFnBlock(_, ref body) => {\n             let function_type = rcx.resolve_node_type(expr.id);\n             match ty::get(function_type).sty {\n                 ty::ty_closure(\n@@ -503,8 +503,8 @@ fn check_expr_fn_block(rcx: @mut Rcx,\n \n fn constrain_callee(rcx: @mut Rcx,\n                     callee_id: ast::NodeId,\n-                    call_expr: @ast::expr,\n-                    callee_expr: @ast::expr)\n+                    call_expr: @ast::Expr,\n+                    callee_expr: @ast::Expr)\n {\n     let call_region = ty::re_scope(call_expr.id);\n \n@@ -530,9 +530,9 @@ fn constrain_call(rcx: @mut Rcx,\n                   // might be expr_call, expr_method_call, or an overloaded\n                   // operator\n                   callee_id: ast::NodeId,\n-                  call_expr: @ast::expr,\n-                  receiver: Option<@ast::expr>,\n-                  arg_exprs: &[@ast::expr],\n+                  call_expr: @ast::Expr,\n+                  receiver: Option<@ast::Expr>,\n+                  arg_exprs: &[@ast::Expr],\n                   implicitly_ref_args: bool)\n {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n@@ -590,7 +590,7 @@ fn constrain_call(rcx: @mut Rcx,\n }\n \n fn constrain_derefs(rcx: @mut Rcx,\n-                    deref_expr: @ast::expr,\n+                    deref_expr: @ast::Expr,\n                     derefs: uint,\n                     mut derefd_ty: ty::t)\n {\n@@ -635,7 +635,7 @@ pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n \n \n fn constrain_index(rcx: @mut Rcx,\n-                   index_expr: @ast::expr,\n+                   index_expr: @ast::Expr,\n                    indexed_ty: ty::t)\n {\n     /*!\n@@ -661,7 +661,7 @@ fn constrain_index(rcx: @mut Rcx,\n \n fn constrain_free_variables(rcx: @mut Rcx,\n                             region: ty::Region,\n-                            expr: @ast::expr) {\n+                            expr: @ast::Expr) {\n     /*!\n      * Make sure that all free variables referenced inside the closure\n      * outlive the closure itself.\n@@ -812,7 +812,7 @@ pub mod guarantor {\n     use syntax::codemap::Span;\n     use util::ppaux::{ty_to_str};\n \n-    pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::expr, base: @ast::expr) {\n+    pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::Expr, base: @ast::Expr) {\n         /*!\n          * Computes the guarantor for an expression `&base` and then\n          * ensures that the lifetime of the resulting pointer is linked\n@@ -825,7 +825,7 @@ pub mod guarantor {\n         link(rcx, expr.span, expr.id, guarantor);\n     }\n \n-    pub fn for_match(rcx: @mut Rcx, discr: @ast::expr, arms: &[ast::arm]) {\n+    pub fn for_match(rcx: @mut Rcx, discr: @ast::Expr, arms: &[ast::Arm]) {\n         /*!\n          * Computes the guarantors for any ref bindings in a match and\n          * then ensures that the lifetime of the resulting pointer is\n@@ -843,7 +843,7 @@ pub mod guarantor {\n     }\n \n     pub fn for_autoref(rcx: @mut Rcx,\n-                       expr: @ast::expr,\n+                       expr: @ast::Expr,\n                        autoderefs: uint,\n                        autoref: &ty::AutoRef) {\n         /*!\n@@ -883,7 +883,7 @@ pub mod guarantor {\n \n         fn maybe_make_subregion(\n             rcx: @mut Rcx,\n-            expr: @ast::expr,\n+            expr: @ast::Expr,\n             sub_region: ty::Region,\n             sup_region: Option<ty::Region>)\n         {\n@@ -895,7 +895,7 @@ pub mod guarantor {\n     }\n \n     pub fn for_by_ref(rcx: @mut Rcx,\n-                      expr: @ast::expr,\n+                      expr: @ast::Expr,\n                       callee_scope: ast::NodeId) {\n         /*!\n          * Computes the guarantor for cases where the `expr` is\n@@ -974,7 +974,7 @@ pub mod guarantor {\n         ty: ty::t\n     }\n \n-    fn guarantor(rcx: @mut Rcx, expr: @ast::expr) -> Option<ty::Region> {\n+    fn guarantor(rcx: @mut Rcx, expr: @ast::Expr) -> Option<ty::Region> {\n         /*!\n          *\n          * Computes the guarantor of `expr`, or None if `expr` is\n@@ -985,23 +985,23 @@ pub mod guarantor {\n \n         debug!(\"guarantor()\");\n         match expr.node {\n-            ast::expr_unary(_, ast::deref, b) => {\n+            ast::ExprUnary(_, ast::UnDeref, b) => {\n                 let cat = categorize(rcx, b);\n                 guarantor_of_deref(&cat)\n             }\n-            ast::expr_field(b, _, _) => {\n+            ast::ExprField(b, _, _) => {\n                 categorize(rcx, b).guarantor\n             }\n-            ast::expr_index(_, b, _) => {\n+            ast::ExprIndex(_, b, _) => {\n                 let cat = categorize(rcx, b);\n                 guarantor_of_deref(&cat)\n             }\n \n-            ast::expr_paren(e) => {\n+            ast::ExprParen(e) => {\n                 guarantor(rcx, e)\n             }\n \n-            ast::expr_path(*) | ast::expr_self => {\n+            ast::ExprPath(*) | ast::ExprSelf => {\n                 // Either a variable or constant and hence resides\n                 // in constant memory or on the stack frame.  Either way,\n                 // not guaranteed by a region pointer.\n@@ -1010,42 +1010,42 @@ pub mod guarantor {\n \n             // All of these expressions are rvalues and hence their\n             // value is not guaranteed by a region pointer.\n-            ast::expr_inline_asm(*) |\n-            ast::expr_mac(*) |\n-            ast::expr_lit(_) |\n-            ast::expr_unary(*) |\n-            ast::expr_addr_of(*) |\n-            ast::expr_binary(*) |\n-            ast::expr_vstore(*) |\n-            ast::expr_break(*) |\n-            ast::expr_again(*) |\n-            ast::expr_ret(*) |\n-            ast::expr_log(*) |\n-            ast::expr_while(*) |\n-            ast::expr_loop(*) |\n-            ast::expr_assign(*) |\n-            ast::expr_assign_op(*) |\n-            ast::expr_cast(*) |\n-            ast::expr_call(*) |\n-            ast::expr_method_call(*) |\n-            ast::expr_struct(*) |\n-            ast::expr_tup(*) |\n-            ast::expr_if(*) |\n-            ast::expr_match(*) |\n-            ast::expr_fn_block(*) |\n-            ast::expr_do_body(*) |\n-            ast::expr_block(*) |\n-            ast::expr_repeat(*) |\n-            ast::expr_vec(*) => {\n+            ast::ExprInlineAsm(*) |\n+            ast::ExprMac(*) |\n+            ast::ExprLit(_) |\n+            ast::ExprUnary(*) |\n+            ast::ExprAddrOf(*) |\n+            ast::ExprBinary(*) |\n+            ast::ExprVstore(*) |\n+            ast::ExprBreak(*) |\n+            ast::ExprAgain(*) |\n+            ast::ExprRet(*) |\n+            ast::ExprLog(*) |\n+            ast::ExprWhile(*) |\n+            ast::ExprLoop(*) |\n+            ast::ExprAssign(*) |\n+            ast::ExprAssignOp(*) |\n+            ast::ExprCast(*) |\n+            ast::ExprCall(*) |\n+            ast::ExprMethodCall(*) |\n+            ast::ExprStruct(*) |\n+            ast::ExprTup(*) |\n+            ast::ExprIf(*) |\n+            ast::ExprMatch(*) |\n+            ast::ExprFnBlock(*) |\n+            ast::ExprDoBody(*) |\n+            ast::ExprBlock(*) |\n+            ast::ExprRepeat(*) |\n+            ast::ExprVec(*) => {\n                 assert!(!ty::expr_is_lval(\n                     rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }\n-            ast::expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n         }\n     }\n \n-    fn categorize(rcx: @mut Rcx, expr: @ast::expr) -> ExprCategorization {\n+    fn categorize(rcx: @mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n         debug!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n@@ -1097,7 +1097,7 @@ pub mod guarantor {\n     }\n \n     fn categorize_unadjusted(rcx: @mut Rcx,\n-                             expr: @ast::expr)\n+                             expr: @ast::Expr)\n                           -> ExprCategorizationType {\n         debug!(\"categorize_unadjusted()\");\n \n@@ -1121,7 +1121,7 @@ pub mod guarantor {\n \n     fn apply_autoderefs(\n         rcx: @mut Rcx,\n-        expr: @ast::expr,\n+        expr: @ast::Expr,\n         autoderefs: uint,\n         ct: ExprCategorizationType)\n      -> ExprCategorizationType {\n@@ -1199,7 +1199,7 @@ pub mod guarantor {\n \n     fn link_ref_bindings_in_pat(\n         rcx: @mut Rcx,\n-        pat: @ast::pat,\n+        pat: @ast::Pat,\n         guarantor: Option<ty::Region>) {\n         /*!\n          *\n@@ -1215,45 +1215,45 @@ pub mod guarantor {\n                rcx.fcx.pat_to_str(pat), guarantor);\n \n         match pat.node {\n-            ast::pat_wild => {}\n-            ast::pat_ident(ast::bind_by_ref(_), _, opt_p) => {\n+            ast::PatWild => {}\n+            ast::PatIdent(ast::BindByRef(_), _, opt_p) => {\n                 link(rcx, pat.span, pat.id, guarantor);\n \n                 for p in opt_p.iter() {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n-            ast::pat_ident(_, _, opt_p) => {\n+            ast::PatIdent(_, _, opt_p) => {\n                 for p in opt_p.iter() {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n-            ast::pat_enum(_, None) => {}\n-            ast::pat_enum(_, Some(ref pats)) => {\n+            ast::PatEnum(_, None) => {}\n+            ast::PatEnum(_, Some(ref pats)) => {\n                 link_ref_bindings_in_pats(rcx, pats, guarantor);\n             }\n-            ast::pat_struct(_, ref fpats, _) => {\n+            ast::PatStruct(_, ref fpats, _) => {\n                 for fpat in fpats.iter() {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n                 }\n             }\n-            ast::pat_tup(ref ps) => {\n+            ast::PatTup(ref ps) => {\n                 link_ref_bindings_in_pats(rcx, ps, guarantor)\n             }\n-            ast::pat_box(p) => {\n+            ast::PatBox(p) => {\n                 link_ref_bindings_in_pat(rcx, p, None)\n             }\n-            ast::pat_uniq(p) => {\n+            ast::PatUniq(p) => {\n                 link_ref_bindings_in_pat(rcx, p, guarantor)\n             }\n-            ast::pat_region(p) => {\n+            ast::PatRegion(p) => {\n                 let rptr_ty = rcx.resolve_node_type(pat.id);\n                 let r = ty::ty_region(rcx.fcx.tcx(), pat.span, rptr_ty);\n                 link_ref_bindings_in_pat(rcx, p, Some(r));\n             }\n-            ast::pat_lit(*) => {}\n-            ast::pat_range(*) => {}\n-            ast::pat_vec(ref before, ref slice, ref after) => {\n+            ast::PatLit(*) => {}\n+            ast::PatRange(*) => {}\n+            ast::PatVec(ref before, ref slice, ref after) => {\n                 let vec_ty = rcx.resolve_node_type(pat.id);\n                 let vstore = ty::ty_vstore(vec_ty);\n                 let guarantor1 = match vstore {\n@@ -1272,7 +1272,7 @@ pub mod guarantor {\n     }\n \n     fn link_ref_bindings_in_pats(rcx: @mut Rcx,\n-                                 pats: &~[@ast::pat],\n+                                 pats: &~[@ast::Pat],\n                                  guarantor: Option<ty::Region>) {\n         for pat in pats.iter() {\n             link_ref_bindings_in_pat(rcx, *pat, guarantor);"}, {"sha": "b96f85b676b279214d8ef30a6b3aa221ae705264", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -473,7 +473,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n fn fixup_substs(vcx: &VtableContext,\n                 location_info: &LocationInfo,\n-                id: ast::def_id,\n+                id: ast::DefId,\n                 substs: ty::substs,\n                 is_early: bool)\n                 -> Option<ty::substs> {\n@@ -482,7 +482,7 @@ fn fixup_substs(vcx: &VtableContext,\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n                          ty::RegionTraitStore(ty::re_static),\n-                         ast::m_imm,\n+                         ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n@@ -516,7 +516,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      impl_substs: &ty::substs,\n                      trait_ref: @ty::TraitRef,\n-                     impl_did: ast::def_id)\n+                     impl_did: ast::DefId)\n {\n     let tcx = vcx.tcx();\n \n@@ -538,7 +538,7 @@ fn insert_vtables(fcx: @mut FnCtxt,\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n }\n \n-pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n+pub fn location_info_for_expr(expr: @ast::Expr) -> LocationInfo {\n     LocationInfo {\n         span: expr.span,\n         id: expr.id\n@@ -551,7 +551,7 @@ pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n     }\n }\n \n-pub fn early_resolve_expr(ex: @ast::expr,\n+pub fn early_resolve_expr(ex: @ast::Expr,\n                           fcx: @mut FnCtxt,\n                           is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n@@ -560,7 +560,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n \n     let cx = fcx.ccx;\n     match ex.node {\n-      ast::expr_path(*) => {\n+      ast::ExprPath(*) => {\n         do fcx.opt_node_ty_substs(ex.id) |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr %s\",\n                    ex.repr(fcx.tcx()));\n@@ -584,16 +584,16 @@ pub fn early_resolve_expr(ex: @ast::expr,\n         };\n       }\n \n-      ast::expr_paren(e) => {\n+      ast::ExprParen(e) => {\n           early_resolve_expr(e, fcx, is_early);\n       }\n \n       // Must resolve bounds on methods with bounded params\n-      ast::expr_binary(callee_id, _, _, _) |\n-      ast::expr_unary(callee_id, _, _) |\n-      ast::expr_assign_op(callee_id, _, _, _) |\n-      ast::expr_index(callee_id, _, _) |\n-      ast::expr_method_call(callee_id, _, _, _, _, _) => {\n+      ast::ExprBinary(callee_id, _, _, _) |\n+      ast::ExprUnary(callee_id, _, _) |\n+      ast::ExprAssignOp(callee_id, _, _, _) |\n+      ast::ExprIndex(callee_id, _, _) |\n+      ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n             debug!(\"vtable resolution on parameter bounds for method call %s\",\n@@ -611,17 +611,17 @@ pub fn early_resolve_expr(ex: @ast::expr,\n           None => ()\n         }\n       }\n-      ast::expr_cast(src, _) => {\n+      ast::ExprCast(src, _) => {\n           debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n               // Bounds of type's contents are not checked here, but in kind.rs.\n               ty::ty_trait(target_def_id, ref target_substs, store,\n                            target_mutbl, _bounds) => {\n-                  fn mutability_allowed(a_mutbl: ast::mutability,\n-                                        b_mutbl: ast::mutability) -> bool {\n+                  fn mutability_allowed(a_mutbl: ast::Mutability,\n+                                        b_mutbl: ast::Mutability) -> bool {\n                       a_mutbl == b_mutbl ||\n-                      (a_mutbl == ast::m_mutbl && b_mutbl == ast::m_imm)\n+                      (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n                   }\n                   // Look up vtables for the type we're casting to,\n                   // passing in the source and target type.  The source\n@@ -721,7 +721,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n }\n \n fn resolve_expr(v: &mut VtableResolveVisitor,\n-                ex: @ast::expr,\n+                ex: @ast::Expr,\n                 fcx: @mut FnCtxt) {\n     early_resolve_expr(ex, fcx, false);\n     visit::walk_expr(v, ex, fcx);\n@@ -774,7 +774,7 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n struct VtableResolveVisitor;\n \n impl visit::Visitor<@mut FnCtxt> for VtableResolveVisitor {\n-    fn visit_expr(&mut self, ex:@ast::expr, e:@mut FnCtxt) {\n+    fn visit_expr(&mut self, ex:@ast::Expr, e:@mut FnCtxt) {\n         resolve_expr(self, ex, e);\n     }\n     fn visit_item(&mut self, _:@ast::item, _:@mut FnCtxt) {"}, {"sha": "1d5cc7490c2e11fd346001ef0f40fbd93c88a734", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -216,13 +216,13 @@ struct WbCtxt {\n \n type wb_vt = oldvisit::vt<@mut WbCtxt>;\n \n-fn visit_stmt(s: @ast::stmt, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n+fn visit_stmt(s: @ast::Stmt, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     oldvisit::visit_stmt(s, (wbcx, v));\n }\n \n-fn visit_expr(e: @ast::expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n+fn visit_expr(e: @ast::Expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success {\n         return;\n     }\n@@ -246,20 +246,20 @@ fn visit_expr(e: @ast::expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     }\n \n     match e.node {\n-        ast::expr_fn_block(ref decl, _) => {\n+        ast::ExprFnBlock(ref decl, _) => {\n             for input in decl.inputs.iter() {\n                 let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n         }\n \n-        ast::expr_binary(callee_id, _, _, _) |\n-        ast::expr_unary(callee_id, _, _) |\n-        ast::expr_assign_op(callee_id, _, _, _) |\n-        ast::expr_index(callee_id, _, _) => {\n+        ast::ExprBinary(callee_id, _, _, _) |\n+        ast::ExprUnary(callee_id, _, _) |\n+        ast::ExprAssignOp(callee_id, _, _, _) |\n+        ast::ExprIndex(callee_id, _, _) => {\n             maybe_resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n \n-        ast::expr_method_call(callee_id, _, _, _, _, _) => {\n+        ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n             // We must always have written in a callee ID type for these.\n             resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n@@ -279,7 +279,7 @@ fn visit_block(b: &ast::Block, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     oldvisit::visit_block(b, (wbcx, v));\n }\n \n-fn visit_pat(p: @ast::pat, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n+fn visit_pat(p: @ast::Pat, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n     if !wbcx.success {\n         return;\n     }\n@@ -329,7 +329,7 @@ fn mk_visitor() -> oldvisit::vt<@mut WbCtxt> {\n                                   .. *oldvisit::default_visitor()})\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::Expr) -> bool {\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_expr)(e, (wbcx, visit));"}, {"sha": "3f18b21dcd39056ea47a7c85620f98244d50f216", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -35,7 +35,7 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n-use syntax::ast::{Crate, def_id, def_struct, def_ty};\n+use syntax::ast::{Crate, DefId, DefStruct, DefTy};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n use syntax::ast::{LOCAL_CRATE, trait_ref, ty_path};\n use syntax::ast;\n@@ -123,7 +123,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                             span: Span,\n                             original_type: t)\n-                         -> Option<def_id> {\n+                         -> Option<DefId> {\n     match get_base_type(inference_context, span, original_type) {\n         None => {\n             return None;\n@@ -322,7 +322,7 @@ impl CoherenceChecker {\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n     pub fn instantiate_default_methods(&self,\n-                                       impl_id: ast::def_id,\n+                                       impl_id: ast::DefId,\n                                        trait_ref: &ty::TraitRef,\n                                        all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n@@ -378,7 +378,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn add_inherent_impl(&self,\n-                             base_def_id: def_id,\n+                             base_def_id: DefId,\n                              implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n@@ -396,7 +396,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn add_trait_impl(&self,\n-                          base_def_id: def_id,\n+                          base_def_id: DefId,\n                           implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n@@ -420,7 +420,7 @@ impl CoherenceChecker {\n         };\n     }\n \n-    pub fn check_implementation_coherence_of(&self, trait_def_id: def_id) {\n+    pub fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n         // Unify pairs of polytypes.\n         do self.iter_impls_of_trait(trait_def_id) |a| {\n             let implementation_a = a;\n@@ -452,7 +452,7 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n+    pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: &fn(@Impl)) {\n         match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n                 for &im in impls.iter() {\n@@ -533,7 +533,7 @@ impl CoherenceChecker {\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n \n-    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> def_id {\n+    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> DefId {\n         let def_map = self.crate_context.tcx.def_map;\n         let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n@@ -545,7 +545,7 @@ impl CoherenceChecker {\n     pub fn check_trait_methods_are_implemented(\n         &self,\n         all_methods: &mut ~[@Method],\n-        trait_did: def_id,\n+        trait_did: DefId,\n         trait_ref_span: Span) {\n \n         let tcx = self.crate_context.tcx;\n@@ -575,7 +575,7 @@ impl CoherenceChecker {\n         match original_type.node {\n             ty_path(_, _, path_id) => {\n                 match self.crate_context.tcx.def_map.get_copy(&path_id) {\n-                    def_ty(def_id) | def_struct(def_id) => {\n+                    DefTy(def_id) | DefStruct(def_id) => {\n                         if def_id.crate != LOCAL_CRATE {\n                             return false;\n                         }\n@@ -663,8 +663,8 @@ impl CoherenceChecker {\n     // External crate handling\n \n     pub fn add_external_impl(&self,\n-                             impls_seen: &mut HashSet<def_id>,\n-                             impl_def_id: def_id) {\n+                             impls_seen: &mut HashSet<DefId>,\n+                             impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n         let implementation = @csearch::get_impl(tcx, impl_def_id);\n \n@@ -766,7 +766,7 @@ impl CoherenceChecker {\n }\n \n pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n-                                      impl_id: ast::def_id,\n+                                      impl_id: ast::DefId,\n                                       trait_ref: &ty::TraitRef,\n                                       method: &ty::Method)\n                                       -> ty::substs {\n@@ -814,11 +814,11 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n }\n \n fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n-                                     impl_id: ast::def_id,\n+                                     impl_id: ast::DefId,\n                                      trait_ref: &ty::TraitRef,\n-                                     new_def_id: ast::def_id,\n+                                     new_def_id: ast::DefId,\n                                      method: &ty::Method,\n-                                     provided_source: Option<ast::def_id>)\n+                                     provided_source: Option<ast::DefId>)\n                                      -> ty::Method {\n \n     let combined_substs = make_substs_for_receiver_types("}, {"sha": "8056831537f59b99154e1e9ca97dc503559b0c7a", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -79,7 +79,7 @@ impl visit::Visitor<()> for CollectItemTypesVisitor {\n \n pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n-                              lang_item: ast::def_id) {\n+                              lang_item: ast::DefId) {\n         let ty::ty_param_bounds_and_ty { ty: ty, _ } =\n             ccx.get_item_ty(lang_item);\n         ccx.tcx.intrinsic_defs.insert(lang_item, ty);\n@@ -117,7 +117,7 @@ impl ToTy for CrateCtxt {\n impl AstConv for CrateCtxt {\n     fn tcx(&self) -> ty::ctxt { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         if id.crate != ast::LOCAL_CRATE {\n             csearch::get_type(self.tcx, id)\n         } else {\n@@ -136,7 +136,7 @@ impl AstConv for CrateCtxt {\n         }\n     }\n \n-    fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n         get_trait_def(self, id)\n     }\n \n@@ -288,7 +288,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n         let tcx = ccx.tcx;\n \n-        let dummy_defid = ast::def_id {crate: 0, node: 0};\n+        let dummy_defid = ast::DefId {crate: 0, node: 0};\n \n         // Represents [A',B',C']\n         let num_trait_bounds = trait_ty_generics.type_param_defs.len();\n@@ -1027,7 +1027,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     let rscope = TypeRscope(rp);\n \n     match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n-        ast::def_trait(trait_did) => {\n+        ast::DefTrait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n@@ -1045,7 +1045,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     }\n }\n \n-fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::def_id) -> @ty::TraitDef {\n+fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     if trait_id.crate != ast::LOCAL_CRATE {\n         ty::lookup_trait_def(ccx.tcx, trait_id)\n     } else {\n@@ -1276,7 +1276,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n \n pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              decl: &ast::fn_decl,\n-                             def_id: ast::def_id,\n+                             def_id: ast::DefId,\n                              ast_generics: &ast::Generics,\n                              abis: AbiSet)\n                           -> ty::ty_param_bounds_and_ty {"}, {"sha": "99c7725c7a2dab23871897639743ebb7a3e2caf3", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -77,7 +77,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::indenter;\n \n-use syntax::ast::m_imm;\n+use syntax::ast::MutImmutable;\n use syntax::ast;\n \n // Note: Coerce is not actually a combiner, in that it does not\n@@ -238,7 +238,7 @@ impl Coerce {\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoBorrowVec(r_a, m_imm))\n+            autoref: Some(AutoBorrowVec(r_a, MutImmutable))\n         })))\n     }\n \n@@ -275,7 +275,7 @@ impl Coerce {\n                               a: ty::t,\n                               sty_a: &ty::sty,\n                               b: ty::t,\n-                              b_mutbl: ast::mutability) -> CoerceResult\n+                              b_mutbl: ast::Mutability) -> CoerceResult\n     {\n         debug!(\"coerce_borrowed_object(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,"}, {"sha": "1939987d7f0784885f2cc010526442867b3448ff", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -21,7 +21,7 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn, m_imm, m_mutbl};\n+use syntax::ast::{Many, Once, extern_fn, impure_fn, MutImmutable, MutMutable};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use util::common::{indenter};\n@@ -52,23 +52,23 @@ impl Combine for Glb {\n         match (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n-          (m_mutbl, m_mutbl) => {\n+          (MutMutable, MutMutable) => {\n             eq_tys(self, a.ty, b.ty).then(|| {\n-                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: a.ty, mutbl: MutMutable})\n             })\n           }\n \n           // If one side or both is immutable, we can use the GLB of\n-          // both sides but mutbl must be `m_imm`.\n-          (m_imm, m_imm) => {\n+          // both sides but mutbl must be `MutImmutable`.\n+          (MutImmutable, MutImmutable) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                Ok(ty::mt {ty: t, mutbl: m_imm})\n+                Ok(ty::mt {ty: t, mutbl: MutImmutable})\n             })\n           }\n \n           // There is no mutual subtype of these combinations.\n-          (m_mutbl, m_imm) |\n-          (m_imm, m_mutbl) => {\n+          (MutMutable, MutImmutable) |\n+          (MutImmutable, MutMutable) => {\n               Err(ty::terr_mutability)\n           }\n         }"}, {"sha": "db5873f09fe2ca70b616dae833927c9eae64d012", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -61,11 +61,11 @@ impl Combine for Lub {\n \n         let m = a.mutbl;\n         match m {\n-          m_imm => {\n+          MutImmutable => {\n             self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n-          m_mutbl => {\n+          MutMutable => {\n             self.infcx.try(|| {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})"}, {"sha": "a2d2cd92e135ab2d6976fd1c95911500f5c92bca", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -41,7 +41,7 @@ use std::result;\n use std::vec;\n use extra::list::Nil;\n use extra::smallintmap::SmallIntMap;\n-use syntax::ast::{m_imm, m_mutbl};\n+use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n@@ -106,7 +106,7 @@ pub enum TypeOrigin {\n     MethodCompatCheck(Span),\n \n     // Checking that this expression can be assigned where it needs to be\n-    ExprAssignable(@ast::expr),\n+    ExprAssignable(@ast::Expr),\n \n     // Relating trait refs when resolving vtables\n     RelateTraitRefs(Span),\n@@ -678,7 +678,7 @@ impl InferCtxt {\n                                   trait_ref.def_id,\n                                   trait_ref.substs.clone(),\n                                   ty::UniqTraitStore,\n-                                  ast::m_imm,\n+                                  ast::MutImmutable,\n                                   ty::EmptyBuiltinBounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {"}, {"sha": "36c5f8a50d28ab5c4ded6f1c5b432ed3cd002457", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -72,12 +72,12 @@ impl Combine for Sub {\n         }\n \n         match b.mutbl {\n-          m_mutbl => {\n+          MutMutable => {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n             eq_tys(self, a.ty, b.ty).then(|| Ok(*a))\n           }\n-          m_imm => {\n+          MutImmutable => {\n             // Otherwise we can be covariant:\n             self.tys(a.ty, b.ty).chain(|_t| Ok(*a) )\n           }"}, {"sha": "8d7dbdf263ed8555a1aa09accbc87d3819fbfefe", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -82,7 +82,7 @@ pub enum param_index {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum method_origin {\n     // fully statically resolved method\n-    method_static(ast::def_id),\n+    method_static(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n     method_param(method_param),\n@@ -97,7 +97,7 @@ pub enum method_origin {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct method_param {\n     // the trait containing the method to be invoked\n-    trait_id: ast::def_id,\n+    trait_id: ast::DefId,\n \n     // index of the method to be invoked amongst the trait's methods\n     method_num: uint,\n@@ -114,10 +114,10 @@ pub struct method_param {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct method_object {\n     // the (super)trait containing the method to be invoked\n-    trait_id: ast::def_id,\n+    trait_id: ast::DefId,\n \n     // the actual base trait id of the object\n-    object_trait_id: ast::def_id,\n+    object_trait_id: ast::DefId,\n \n     // index of the method to be invoked amongst the trait's methods\n     method_num: uint,\n@@ -161,7 +161,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::def_id, ~[ty::t], vtable_res),\n+    vtable_static(ast::DefId, ~[ty::t], vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -214,7 +214,7 @@ impl Repr for impl_res {\n     }\n }\n \n-pub type impl_vtable_map = @mut HashMap<ast::def_id, impl_res>;\n+pub type impl_vtable_map = @mut HashMap<ast::DefId, impl_res>;\n \n pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n@@ -249,7 +249,7 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::def {\n+pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     match tcx.def_map.find(&id) {\n       Some(&x) => x,\n       _ => {\n@@ -259,7 +259,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::def {\n }\n \n pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n-                   -> ast::def {\n+                   -> ast::Def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n "}, {"sha": "eb9206a52b1257e9937efaa644f3928a5d4b0cac", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -54,51 +54,51 @@ pub fn indenter() -> _indenter {\n     _indenter(())\n }\n \n-pub fn field_expr(f: ast::Field) -> @ast::expr { return f.expr; }\n+pub fn field_expr(f: ast::Field) -> @ast::Expr { return f.expr; }\n \n-pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::expr] {\n+pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n     fields.map(|f| f.expr)\n }\n \n struct LoopQueryVisitor {\n-    p: @fn(&ast::expr_) -> bool\n+    p: @fn(&ast::Expr_) -> bool\n }\n \n impl Visitor<@mut bool> for LoopQueryVisitor {\n-    fn visit_expr(&mut self, e:@ast::expr, flag:@mut bool) {\n+    fn visit_expr(&mut self, e:@ast::Expr, flag:@mut bool) {\n         *flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::expr_loop(*) | ast::expr_while(*) => {}\n+          ast::ExprLoop(*) | ast::ExprWhile(*) => {}\n           _ => visit::walk_expr(self, e, flag)\n         }\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: @fn(&ast::expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::Block, p: @fn(&ast::Expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let mut v = LoopQueryVisitor { p: p };\n     visit::walk_block(&mut v, b, rs);\n     return *rs;\n }\n \n struct BlockQueryVisitor {\n-    p: @fn(@ast::expr) -> bool\n+    p: @fn(@ast::Expr) -> bool\n }\n \n impl Visitor<@mut bool> for BlockQueryVisitor {\n-    fn visit_expr(&mut self, e:@ast::expr, flag:@mut bool) {\n+    fn visit_expr(&mut self, e:@ast::Expr, flag:@mut bool) {\n         *flag |= (self.p)(e);\n         visit::walk_expr(self, e, flag)\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: @fn(@ast::expr) -> bool) -> bool {\n+pub fn block_query(b: &ast::Block, p: @fn(@ast::Expr) -> bool) -> bool {\n     let rs = @mut false;\n     let mut v = BlockQueryVisitor { p: p };\n     visit::walk_block(&mut v, b, rs);"}, {"sha": "104c3753452bfb968fefa2a5501c6312ebf5f1e8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -81,11 +81,11 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           }\n           Some(&ast_map::node_expr(expr)) => {\n             match expr.node {\n-              ast::expr_call(*) => explain_span(cx, \"call\", expr.span),\n-              ast::expr_method_call(*) => {\n+              ast::ExprCall(*) => explain_span(cx, \"call\", expr.span),\n+              ast::ExprMethodCall(*) => {\n                 explain_span(cx, \"method call\", expr.span)\n               },\n-              ast::expr_match(*) => explain_span(cx, \"match\", expr.span),\n+              ast::ExprMatch(*) => explain_span(cx, \"match\", expr.span),\n               _ => explain_span(cx, \"expression\", expr.span)\n             }\n           }\n@@ -173,18 +173,18 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n       }\n       Some(&ast_map::node_expr(expr)) => {\n         match expr.node {\n-          ast::expr_call(*) => {\n+          ast::ExprCall(*) => {\n             fmt!(\"<call at %s>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n-          ast::expr_match(*) => {\n+          ast::ExprMatch(*) => {\n             fmt!(\"<match at %s>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n-          ast::expr_assign_op(*) |\n-          ast::expr_unary(*) |\n-          ast::expr_binary(*) |\n-          ast::expr_index(*) => {\n+          ast::ExprAssignOp(*) |\n+          ast::ExprUnary(*) |\n+          ast::ExprBinary(*) |\n+          ast::ExprIndex(*) => {\n             fmt!(\"<method at %s>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n@@ -235,10 +235,10 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     }\n }\n \n-fn mutability_to_str(m: ast::mutability) -> ~str {\n+fn mutability_to_str(m: ast::Mutability) -> ~str {\n     match m {\n-        ast::m_mutbl => ~\"mut \",\n-        ast::m_imm => ~\"\",\n+        ast::MutMutable => ~\"mut \",\n+        ast::MutImmutable => ~\"\",\n     }\n }\n \n@@ -613,15 +613,15 @@ impl Repr for ty::TraitRef {\n     }\n }\n \n-impl Repr for ast::expr {\n+impl Repr for ast::Expr {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         fmt!(\"expr(%d: %s)\",\n              self.id,\n              pprust::expr_to_str(self, tcx.sess.intr()))\n     }\n }\n \n-impl Repr for ast::pat {\n+impl Repr for ast::Pat {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         fmt!(\"pat(%d: %s)\",\n              self.id,\n@@ -641,7 +641,7 @@ impl Repr for ty::Region {\n     }\n }\n \n-impl Repr for ast::def_id {\n+impl Repr for ast::DefId {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now"}, {"sha": "9208191e364cd347d500a61e18e05c2c963f6472", "filename": "src/librusti/program.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -295,7 +295,7 @@ impl Program {\n                         // &T encoded will decode to T, so we need to be sure to\n                         // re-take a loan after decoding\n                         ty::ty_rptr(_, mt) => {\n-                            if mt.mutbl == ast::m_mutbl {\n+                            if mt.mutbl == ast::MutMutable {\n                                 tystr.push_str(\"&mut \");\n                             } else {\n                                 tystr.push_str(\"&\");\n@@ -354,9 +354,9 @@ impl Program {\n             do find_user_block(blk) |blk| {\n                 for stmt in blk.stmts.iter() {\n                     match stmt.node {\n-                        ast::stmt_decl(d, _) => {\n+                        ast::StmtDecl(d, _) => {\n                             match d.node {\n-                                ast::decl_local(l) => { f(l); }\n+                                ast::DeclLocal(l) => { f(l); }\n                                 _ => {}\n                             }\n                         }\n@@ -369,9 +369,9 @@ impl Program {\n         fn find_user_block(blk: &ast::Block, f: &fn(&ast::Block)) {\n             for stmt in blk.stmts.iter() {\n                 match stmt.node {\n-                    ast::stmt_semi(e, _) => {\n+                    ast::StmtSemi(e, _) => {\n                         match e.node {\n-                            ast::expr_block(ref blk) => { return f(blk); }\n+                            ast::ExprBlock(ref blk) => { return f(blk); }\n                             _ => {}\n                         }\n                     }"}, {"sha": "5bd941759f4d7e81c1473dac3c66335500de2f8b", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -166,9 +166,9 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n         for stmt in blk.stmts.iter() {\n             let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n             match stmt.node {\n-                ast::stmt_decl(d, _) => {\n+                ast::StmtDecl(d, _) => {\n                     match d.node {\n-                        ast::decl_item(it) => {\n+                        ast::DeclItem(it) => {\n                             let name = sess.str_of(it.ident);\n                             match it.node {\n                                 // Structs are treated specially because to make\n@@ -184,7 +184,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n \n                         // Local declarations must be specially dealt with,\n                         // record all local declarations for use later on\n-                        ast::decl_local(l) => {\n+                        ast::DeclLocal(l) => {\n                             let mutbl = l.is_mutbl;\n                             do each_binding(l) |path, _| {\n                                 let s = do with_pp(intr) |pp, _| {\n@@ -198,7 +198,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n                 }\n \n                 // run statements with expressions (they have effects)\n-                ast::stmt_mac(*) | ast::stmt_semi(*) | ast::stmt_expr(*) => {\n+                ast::StmtMac(*) | ast::StmtSemi(*) | ast::StmtExpr(*) => {\n                     to_run.push(s);\n                 }\n             }"}, {"sha": "400399253a5d0c3bfe7bacdec4675037073cc012", "filename": "src/librusti/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -20,9 +20,9 @@ struct EachBindingVisitor {\n }\n \n impl visit::Visitor<()> for EachBindingVisitor {\n-    fn visit_pat(&mut self, pat:@ast::pat, _:()) {\n+    fn visit_pat(&mut self, pat:@ast::Pat, _:()) {\n                 match pat.node {\n-                    ast::pat_ident(_, ref path, _) => {\n+                    ast::PatIdent(_, ref path, _) => {\n                         (self.f)(path, pat.id);\n                     }\n                     _ => {}"}, {"sha": "b411316d6266b19b317927d3bbf73be703889dcf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -29,7 +29,7 @@ pub struct Ident { name: Name, ctxt: SyntaxContext }\n \n impl Ident {\n     /// Construct an identifier with the given name and an empty context:\n-    pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: empty_ctxt}}\n+    pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n }\n \n /// A SyntaxContext represents a chain of macro-expandings\n@@ -52,9 +52,10 @@ pub struct SCTable {\n     mark_memo : HashMap<(SyntaxContext,Mrk),SyntaxContext>,\n     rename_memo : HashMap<(SyntaxContext,Ident,Name),SyntaxContext>\n }\n+\n // NB: these must be placed in any SCTable...\n-pub static empty_ctxt : uint = 0;\n-pub static illegal_ctxt : uint = 1;\n+pub static EMPTY_CTXT : uint = 0;\n+pub static ILLEGAL_CTXT : uint = 1;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum SyntaxContext_ {\n@@ -69,7 +70,7 @@ pub enum SyntaxContext_ {\n     // in the \"from\" slot. In essence, they're all\n     // pointers to a single \"rename\" event node.\n     Rename (Ident,Name,SyntaxContext),\n-    IllegalCtxt()\n+    IllegalCtxt\n }\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n@@ -92,7 +93,7 @@ impl<D:Decoder> Decodable<D> for Ident {\n }\n \n /// Function name (not all functions have names)\n-pub type fn_ident = Option<Ident>;\n+pub type FnIdent = Option<Ident>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Lifetime {\n@@ -133,7 +134,7 @@ pub type CrateNum = int;\n pub type NodeId = int;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n-pub struct def_id {\n+pub struct DefId {\n     crate: CrateNum,\n     node: NodeId,\n }\n@@ -178,40 +179,39 @@ impl Generics {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum MethodProvenance {\n-    FromTrait(def_id),\n-    FromImpl(def_id),\n+    FromTrait(DefId),\n+    FromImpl(DefId),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum def {\n-    def_fn(def_id, purity),\n-    def_static_method(/* method */ def_id, MethodProvenance, purity),\n-    def_self(NodeId),\n-    def_self_ty(/* trait id */ NodeId),\n-    def_mod(def_id),\n-    def_foreign_mod(def_id),\n-    def_static(def_id, bool /* is_mutbl */),\n-    def_arg(NodeId, bool /* is_mutbl */),\n-    def_local(NodeId, bool /* is_mutbl */),\n-    def_variant(def_id /* enum */, def_id /* variant */),\n-    def_ty(def_id),\n-    def_trait(def_id),\n-    def_prim_ty(prim_ty),\n-    def_ty_param(def_id, uint),\n-    def_binding(NodeId, binding_mode),\n-    def_use(def_id),\n-    def_upvar(NodeId,  // id of closed over var\n-              @def,     // closed over def\n+pub enum Def {\n+    DefFn(DefId, purity),\n+    DefStaticMethod(/* method */ DefId, MethodProvenance, purity),\n+    DefSelf(NodeId),\n+    DefSelfTy(/* trait id */ NodeId),\n+    DefMod(DefId),\n+    DefForeignMod(DefId),\n+    DefStatic(DefId, bool /* is_mutbl */),\n+    DefArg(NodeId, bool /* is_mutbl */),\n+    DefLocal(NodeId, bool /* is_mutbl */),\n+    DefVariant(DefId /* enum */, DefId /* variant */),\n+    DefTy(DefId),\n+    DefTrait(DefId),\n+    DefPrimTy(prim_ty),\n+    DefTyParam(DefId, uint),\n+    DefBinding(NodeId, BindingMode),\n+    DefUse(DefId),\n+    DefUpvar(NodeId,  // id of closed over var\n+              @Def,     // closed over def\n               NodeId,  // expr node that creates the closure\n               NodeId), // id for the block/body of the closure expr\n-    def_struct(def_id),\n-    def_typaram_binder(NodeId), /* struct, impl or trait with ty params */\n-    def_region(NodeId),\n-    def_label(NodeId),\n-    def_method(def_id /* method */, Option<def_id> /* trait */),\n+    DefStruct(DefId),\n+    DefTyParamBinder(NodeId), /* struct, impl or trait with ty params */\n+    DefRegion(NodeId),\n+    DefLabel(NodeId),\n+    DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n-\n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type CrateConfig = ~[@MetaItem];\n@@ -261,61 +261,61 @@ impl Eq for MetaItem_ {\n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct Block {\n     view_items: ~[view_item],\n-    stmts: ~[@stmt],\n-    expr: Option<@expr>,\n+    stmts: ~[@Stmt],\n+    expr: Option<@Expr>,\n     id: NodeId,\n     rules: BlockCheckMode,\n     span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct pat {\n+pub struct Pat {\n     id: NodeId,\n-    node: pat_,\n+    node: Pat_,\n     span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct field_pat {\n+pub struct FieldPat {\n     ident: Ident,\n-    pat: @pat,\n+    pat: @Pat,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum binding_mode {\n-    bind_by_ref(mutability),\n-    bind_infer\n+pub enum BindingMode {\n+    BindByRef(Mutability),\n+    BindInfer\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum pat_ {\n-    pat_wild,\n+pub enum Pat_ {\n+    PatWild,\n     // A pat_ident may either be a new bound variable,\n     // or a nullary enum (in which case the second field\n     // is None).\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n     // records this pattern's NodeId in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(binding_mode, Path, Option<@pat>),\n-    pat_enum(Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+    PatIdent(BindingMode, Path, Option<@Pat>),\n+    PatEnum(Path, Option<~[@Pat]>), /* \"none\" means a * pattern where\n                                        * we don't bind the fields to names */\n-    pat_struct(Path, ~[field_pat], bool),\n-    pat_tup(~[@pat]),\n-    pat_box(@pat),\n-    pat_uniq(@pat),\n-    pat_region(@pat), // borrowed pointer pattern\n-    pat_lit(@expr),\n-    pat_range(@expr, @expr),\n+    PatStruct(Path, ~[FieldPat], bool),\n+    PatTup(~[@Pat]),\n+    PatBox(@Pat),\n+    PatUniq(@Pat),\n+    PatRegion(@Pat), // borrowed pointer pattern\n+    PatLit(@Expr),\n+    PatRange(@Expr, @Expr),\n     // [a, b, ..i, y, z] is represented as\n     // pat_vec(~[a, b], Some(i), ~[y, z])\n-    pat_vec(~[@pat], Option<@pat>, ~[@pat])\n+    PatVec(~[@Pat], Option<@Pat>, ~[@Pat])\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum mutability {\n-    m_mutbl,\n-    m_imm,\n+pub enum Mutability {\n+    MutMutable,\n+    MutImmutable,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -336,69 +336,69 @@ impl ToStr for Sigil {\n }\n \n #[deriving(Eq, Encodable, Decodable, IterBytes)]\n-pub enum vstore {\n+pub enum Vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n-    vstore_fixed(Option<uint>),     // [1,2,3,4]\n-    vstore_uniq,                    // ~[1,2,3,4]\n-    vstore_box,                     // @[1,2,3,4]\n-    vstore_slice(Option<Lifetime>) // &'foo? [1,2,3,4]\n+    VstoreFixed(Option<uint>),     // [1,2,3,4]\n+    VstoreUniq,                    // ~[1,2,3,4]\n+    VstoreBox,                     // @[1,2,3,4]\n+    VstoreSlice(Option<Lifetime>)  // &'foo? [1,2,3,4]\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum expr_vstore {\n-    expr_vstore_uniq,                  // ~[1,2,3,4]\n-    expr_vstore_box,                   // @[1,2,3,4]\n-    expr_vstore_mut_box,               // @mut [1,2,3,4]\n-    expr_vstore_slice,                 // &[1,2,3,4]\n-    expr_vstore_mut_slice,             // &mut [1,2,3,4]\n+pub enum ExprVstore {\n+    ExprVstoreUniq,                 // ~[1,2,3,4]\n+    ExprVstoreBox,                  // @[1,2,3,4]\n+    ExprVstoreMutBox,               // @mut [1,2,3,4]\n+    ExprVstoreSlice,                // &[1,2,3,4]\n+    ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum binop {\n-    add,\n-    subtract,\n-    mul,\n-    div,\n-    rem,\n-    and,\n-    or,\n-    bitxor,\n-    bitand,\n-    bitor,\n-    shl,\n-    shr,\n-    eq,\n-    lt,\n-    le,\n-    ne,\n-    ge,\n-    gt,\n+pub enum BinOp {\n+    BiAdd,\n+    BiSub,\n+    BiMul,\n+    BiDiv,\n+    BiRem,\n+    BiAnd,\n+    BiOr,\n+    BiBitXor,\n+    BiBitAnd,\n+    BiBitOr,\n+    BiShl,\n+    BiShr,\n+    BiEq,\n+    BiLt,\n+    BiLe,\n+    BiNe,\n+    BiGe,\n+    BiGt,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum unop {\n-    box(mutability),\n-    uniq,\n-    deref,\n-    not,\n-    neg\n+pub enum UnOp {\n+    UnBox(Mutability),\n+    UnUniq,\n+    UnDeref,\n+    UnNot,\n+    UnNeg\n }\n \n-pub type stmt = Spanned<stmt_>;\n+pub type Stmt = Spanned<Stmt_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum stmt_ {\n+pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n-    stmt_decl(@decl, NodeId),\n+    StmtDecl(@Decl, NodeId),\n \n     // expr without trailing semi-colon (must have unit type):\n-    stmt_expr(@expr, NodeId),\n+    StmtExpr(@Expr, NodeId),\n \n     // expr with trailing semi-colon (may have any type):\n-    stmt_semi(@expr, NodeId),\n+    StmtSemi(@Expr, NodeId),\n \n     // bool: is there a trailing sem-colon?\n-    stmt_mac(mac, bool),\n+    StmtMac(mac, bool),\n }\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n@@ -407,33 +407,33 @@ pub enum stmt_ {\n pub struct Local {\n     is_mutbl: bool,\n     ty: Ty,\n-    pat: @pat,\n-    init: Option<@expr>,\n+    pat: @Pat,\n+    init: Option<@Expr>,\n     id: NodeId,\n     span: Span,\n }\n \n-pub type decl = Spanned<decl_>;\n+pub type Decl = Spanned<Decl_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum decl_ {\n+pub enum Decl_ {\n     // a local (let) binding:\n-    decl_local(@Local),\n+    DeclLocal(@Local),\n     // an item binding:\n-    decl_item(@item),\n+    DeclItem(@item),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct arm {\n-    pats: ~[@pat],\n-    guard: Option<@expr>,\n+pub struct Arm {\n+    pats: ~[@Pat],\n+    guard: Option<@Expr>,\n     body: Block,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Field {\n     ident: Ident,\n-    expr: @expr,\n+    expr: @Expr,\n     span: Span,\n }\n \n@@ -444,20 +444,20 @@ pub enum BlockCheckMode {\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct expr {\n+pub struct Expr {\n     id: NodeId,\n-    node: expr_,\n+    node: Expr_,\n     span: Span,\n }\n \n-impl expr {\n+impl Expr {\n     pub fn get_callee_id(&self) -> Option<NodeId> {\n         match self.node {\n-            expr_method_call(callee_id, _, _, _, _, _) |\n-            expr_index(callee_id, _, _) |\n-            expr_binary(callee_id, _, _, _) |\n-            expr_assign_op(callee_id, _, _, _) |\n-            expr_unary(callee_id, _, _) => Some(callee_id),\n+            ExprMethodCall(callee_id, _, _, _, _, _) |\n+            ExprIndex(callee_id, _, _) |\n+            ExprBinary(callee_id, _, _, _) |\n+            ExprAssignOp(callee_id, _, _, _) |\n+            ExprUnary(callee_id, _, _) => Some(callee_id),\n             _ => None,\n         }\n     }\n@@ -471,54 +471,54 @@ pub enum CallSugar {\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum expr_ {\n-    expr_vstore(@expr, expr_vstore),\n-    expr_vec(~[@expr], mutability),\n-    expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(NodeId, @expr, Ident, ~[Ty], ~[@expr], CallSugar),\n-    expr_tup(~[@expr]),\n-    expr_binary(NodeId, binop, @expr, @expr),\n-    expr_unary(NodeId, unop, @expr),\n-    expr_lit(@lit),\n-    expr_cast(@expr, Ty),\n-    expr_if(@expr, Block, Option<@expr>),\n-    expr_while(@expr, Block),\n-    expr_for_loop(@pat, @expr, Block),\n+pub enum Expr_ {\n+    ExprVstore(@Expr, ExprVstore),\n+    ExprVec(~[@Expr], Mutability),\n+    ExprCall(@Expr, ~[@Expr], CallSugar),\n+    ExprMethodCall(NodeId, @Expr, Ident, ~[Ty], ~[@Expr], CallSugar),\n+    ExprTup(~[@Expr]),\n+    ExprBinary(NodeId, BinOp, @Expr, @Expr),\n+    ExprUnary(NodeId, UnOp, @Expr),\n+    ExprLit(@lit),\n+    ExprCast(@Expr, Ty),\n+    ExprIf(@Expr, Block, Option<@Expr>),\n+    ExprWhile(@Expr, Block),\n+    ExprForLoop(@Pat, @Expr, Block),\n     /* Conditionless loop (can be exited with break, cont, or ret)\n        Same semantics as while(true) { body }, but typestate knows that the\n        (implicit) condition is always true. */\n-    expr_loop(Block, Option<Ident>),\n-    expr_match(@expr, ~[arm]),\n-    expr_fn_block(fn_decl, Block),\n-    expr_do_body(@expr),\n-    expr_block(Block),\n-\n-    expr_assign(@expr, @expr),\n-    expr_assign_op(NodeId, binop, @expr, @expr),\n-    expr_field(@expr, Ident, ~[Ty]),\n-    expr_index(NodeId, @expr, @expr),\n-    expr_path(Path),\n+    ExprLoop(Block, Option<Ident>),\n+    ExprMatch(@Expr, ~[Arm]),\n+    ExprFnBlock(fn_decl, Block),\n+    ExprDoBody(@Expr),\n+    ExprBlock(Block),\n+\n+    ExprAssign(@Expr, @Expr),\n+    ExprAssignOp(NodeId, BinOp, @Expr, @Expr),\n+    ExprField(@Expr, Ident, ~[Ty]),\n+    ExprIndex(NodeId, @Expr, @Expr),\n+    ExprPath(Path),\n \n     /// The special identifier `self`.\n-    expr_self,\n-    expr_addr_of(mutability, @expr),\n-    expr_break(Option<Ident>),\n-    expr_again(Option<Ident>),\n-    expr_ret(Option<@expr>),\n-    expr_log(@expr, @expr),\n+    ExprSelf,\n+    ExprAddrOf(Mutability, @Expr),\n+    ExprBreak(Option<Ident>),\n+    ExprAgain(Option<Ident>),\n+    ExprRet(Option<@Expr>),\n+    ExprLog(@Expr, @Expr),\n \n-    expr_inline_asm(inline_asm),\n+    ExprInlineAsm(inline_asm),\n \n-    expr_mac(mac),\n+    ExprMac(mac),\n \n     // A struct literal expression.\n-    expr_struct(Path, ~[Field], Option<@expr> /* base */),\n+    ExprStruct(Path, ~[Field], Option<@Expr> /* base */),\n \n     // A vector literal constructed from one repeated element.\n-    expr_repeat(@expr /* element */, @expr /* count */, mutability),\n+    ExprRepeat(@Expr /* element */, @Expr /* count */, Mutability),\n \n     // No-op: used solely so we can pretty-print faithfully\n-    expr_paren(@expr)\n+    ExprParen(@Expr)\n }\n \n // When the main rust parser encounters a syntax-extension invocation, it\n@@ -646,7 +646,7 @@ pub enum lit_ {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct mt {\n     ty: ~Ty,\n-    mutbl: mutability,\n+    mutbl: Mutability,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -785,15 +785,15 @@ pub enum ty_ {\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_vec(mt),\n-    ty_fixed_length_vec(mt, @expr),\n+    ty_fixed_length_vec(mt, @Expr),\n     ty_ptr(mt),\n     ty_rptr(Option<Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[Ty]),\n     ty_path(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n     ty_mac(mac),\n-    ty_typeof(@expr),\n+    ty_typeof(@Expr),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n     // nested in one.\n@@ -810,8 +810,8 @@ pub enum asm_dialect {\n pub struct inline_asm {\n     asm: @str,\n     clobbers: @str,\n-    inputs: ~[(@str, @expr)],\n-    outputs: ~[(@str, @expr)],\n+    inputs: ~[(@str, @Expr)],\n+    outputs: ~[(@str, @Expr)],\n     volatile: bool,\n     alignstack: bool,\n     dialect: asm_dialect\n@@ -821,7 +821,7 @@ pub struct inline_asm {\n pub struct arg {\n     is_mutbl: bool,\n     ty: Ty,\n-    pat: @pat,\n+    pat: @Pat,\n     id: NodeId,\n }\n \n@@ -861,8 +861,8 @@ pub enum ret_style {\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n-    sty_region(Option<Lifetime>, mutability), // `&'lt self`\n-    sty_box(mutability),                       // `@self`\n+    sty_region(Option<Lifetime>, Mutability), // `&'lt self`\n+    sty_box(Mutability),                       // `@self`\n     sty_uniq                                   // `~self`\n }\n \n@@ -927,7 +927,7 @@ pub struct variant_ {\n     attrs: ~[Attribute],\n     kind: variant_kind,\n     id: NodeId,\n-    disr_expr: Option<@expr>,\n+    disr_expr: Option<@Expr>,\n     vis: visibility,\n }\n \n@@ -1067,7 +1067,7 @@ pub struct item {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum item_ {\n-    item_static(Ty, mutability, @expr),\n+    item_static(Ty, Mutability, @Expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, Block),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n@@ -1105,7 +1105,7 @@ pub enum foreign_item_ {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum inlined_item {\n     ii_item(@item),\n-    ii_method(def_id /* impl id */, bool /* is provided */, @method),\n+    ii_method(DefId /* impl id */, bool /* is provided */, @method),\n     ii_foreign(@foreign_item),\n }\n "}, {"sha": "ccaadcbad4df461b77461ea82e47402570d6313d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -67,17 +67,17 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n pub enum ast_node {\n     node_item(@item, @path),\n     node_foreign_item(@foreign_item, AbiSet, visibility, @path),\n-    node_trait_method(@trait_method, def_id /* trait did */,\n+    node_trait_method(@trait_method, DefId /* trait did */,\n                       @path /* path to the trait */),\n-    node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n+    node_method(@method, DefId /* impl did */, @path /* path to the impl */),\n     node_variant(variant, @item, @path),\n-    node_expr(@expr),\n-    node_stmt(@stmt),\n+    node_expr(@Expr),\n+    node_stmt(@Stmt),\n     node_arg,\n     node_local(Ident),\n     node_block(Block),\n     node_struct_ctor(@struct_def, @item, @path),\n-    node_callee_scope(@expr)\n+    node_callee_scope(@Expr)\n }\n \n pub type map = @mut HashMap<NodeId, ast_node>;\n@@ -94,7 +94,7 @@ impl Ctx {\n     }\n \n     fn map_method(&mut self,\n-                  impl_did: def_id,\n+                  impl_did: DefId,\n                   impl_path: @path,\n                   m: @method,\n                   is_provided: bool) {\n@@ -130,7 +130,7 @@ impl Ctx {\n         }\n     }\n \n-    fn map_expr(&mut self, ex: @expr) {\n+    fn map_expr(&mut self, ex: @Expr) {\n         self.map.insert(ex.id, node_expr(ex));\n \n         // Expressions which are or might be calls:\n@@ -156,7 +156,7 @@ impl Ctx {\n         visit::walk_fn(self, fk, decl, body, sp, id, ());\n     }\n \n-    fn map_stmt(&mut self, stmt: @stmt) {\n+    fn map_stmt(&mut self, stmt: @Stmt) {\n         self.map.insert(stmt_id(stmt), node_stmt(stmt));\n         visit::walk_stmt(self, stmt, ());\n     }\n@@ -167,9 +167,9 @@ impl Ctx {\n         visit::walk_block(self, b, ());\n     }\n \n-    fn map_pat(&mut self, pat: @pat) {\n+    fn map_pat(&mut self, pat: @Pat) {\n         match pat.node {\n-            pat_ident(_, ref path, _) => {\n+            PatIdent(_, ref path, _) => {\n                 // Note: this is at least *potentially* a pattern...\n                 self.map.insert(pat.id,\n                                 node_local(ast_util::path_to_ident(path)));\n@@ -265,16 +265,16 @@ impl Visitor<()> for Ctx {\n         self.path.pop();\n     }\n \n-    fn visit_pat(&mut self, pat: @pat, _: ()) {\n+    fn visit_pat(&mut self, pat: @Pat, _: ()) {\n         self.map_pat(pat);\n         visit::walk_pat(self, pat, ())\n     }\n \n-    fn visit_expr(&mut self, expr: @expr, _: ()) {\n+    fn visit_expr(&mut self, expr: @Expr, _: ()) {\n         self.map_expr(expr)\n     }\n \n-    fn visit_stmt(&mut self, stmt: @stmt, _: ()) {\n+    fn visit_stmt(&mut self, stmt: @Stmt, _: ()) {\n         self.map_stmt(stmt)\n     }\n \n@@ -310,15 +310,15 @@ impl Visitor<()> for Ctx {\n         visit::walk_local(self, local, ())\n     }\n \n-    fn visit_arm(&mut self, arm: &arm, _: ()) {\n+    fn visit_arm(&mut self, arm: &Arm, _: ()) {\n         visit::walk_arm(self, arm, ())\n     }\n \n-    fn visit_decl(&mut self, decl: @decl, _: ()) {\n+    fn visit_decl(&mut self, decl: @Decl, _: ()) {\n         visit::walk_decl(self, decl, ())\n     }\n \n-    fn visit_expr_post(&mut self, _: @expr, _: ()) {\n+    fn visit_expr_post(&mut self, _: @Expr, _: ()) {\n         // Empty!\n     }\n "}, {"sha": "62b8fc687a6b553b1ccb84115cdce521db3b23f7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 149, "deletions": 149, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -32,121 +32,121 @@ pub fn path_to_ident(path: &Path) -> Ident {\n     path.segments.last().identifier\n }\n \n-pub fn local_def(id: NodeId) -> def_id {\n-    ast::def_id { crate: LOCAL_CRATE, node: id }\n+pub fn local_def(id: NodeId) -> DefId {\n+    ast::DefId { crate: LOCAL_CRATE, node: id }\n }\n \n-pub fn is_local(did: ast::def_id) -> bool { did.crate == LOCAL_CRATE }\n+pub fn is_local(did: ast::DefId) -> bool { did.crate == LOCAL_CRATE }\n \n-pub fn stmt_id(s: &stmt) -> NodeId {\n+pub fn stmt_id(s: &Stmt) -> NodeId {\n     match s.node {\n-      stmt_decl(_, id) => id,\n-      stmt_expr(_, id) => id,\n-      stmt_semi(_, id) => id,\n-      stmt_mac(*) => fail!(\"attempted to analyze unexpanded stmt\")\n+      StmtDecl(_, id) => id,\n+      StmtExpr(_, id) => id,\n+      StmtSemi(_, id) => id,\n+      StmtMac(*) => fail!(\"attempted to analyze unexpanded stmt\")\n     }\n }\n \n-pub fn variant_def_ids(d: def) -> Option<(def_id, def_id)> {\n+pub fn variant_def_ids(d: Def) -> Option<(DefId, DefId)> {\n     match d {\n-      def_variant(enum_id, var_id) => {\n+      DefVariant(enum_id, var_id) => {\n           Some((enum_id, var_id))\n       }\n       _ => None\n     }\n }\n \n-pub fn def_id_of_def(d: def) -> def_id {\n+pub fn def_id_of_def(d: Def) -> DefId {\n     match d {\n-      def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n-      def_foreign_mod(id) | def_static(id, _) |\n-      def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_struct(id) | def_trait(id) | def_method(id, _) => {\n+      DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n+      DefForeignMod(id) | DefStatic(id, _) |\n+      DefVariant(_, id) | DefTy(id) | DefTyParam(id, _) |\n+      DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n         id\n       }\n-      def_arg(id, _) | def_local(id, _) | def_self(id) | def_self_ty(id)\n-      | def_upvar(id, _, _, _) | def_binding(id, _) | def_region(id)\n-      | def_typaram_binder(id) | def_label(id) => {\n+      DefArg(id, _) | DefLocal(id, _) | DefSelf(id) | DefSelfTy(id)\n+      | DefUpvar(id, _, _, _) | DefBinding(id, _) | DefRegion(id)\n+      | DefTyParamBinder(id) | DefLabel(id) => {\n         local_def(id)\n       }\n \n-      def_prim_ty(_) => fail!()\n+      DefPrimTy(_) => fail!()\n     }\n }\n \n-pub fn binop_to_str(op: binop) -> ~str {\n+pub fn binop_to_str(op: BinOp) -> ~str {\n     match op {\n-      add => return ~\"+\",\n-      subtract => return ~\"-\",\n-      mul => return ~\"*\",\n-      div => return ~\"/\",\n-      rem => return ~\"%\",\n-      and => return ~\"&&\",\n-      or => return ~\"||\",\n-      bitxor => return ~\"^\",\n-      bitand => return ~\"&\",\n-      bitor => return ~\"|\",\n-      shl => return ~\"<<\",\n-      shr => return ~\">>\",\n-      eq => return ~\"==\",\n-      lt => return ~\"<\",\n-      le => return ~\"<=\",\n-      ne => return ~\"!=\",\n-      ge => return ~\">=\",\n-      gt => return ~\">\"\n-    }\n-}\n-\n-pub fn binop_to_method_name(op: binop) -> Option<~str> {\n+      BiAdd => return ~\"+\",\n+      BiSub => return ~\"-\",\n+      BiMul => return ~\"*\",\n+      BiDiv => return ~\"/\",\n+      BiRem => return ~\"%\",\n+      BiAnd => return ~\"&&\",\n+      BiOr => return ~\"||\",\n+      BiBitXor => return ~\"^\",\n+      BiBitAnd => return ~\"&\",\n+      BiBitOr => return ~\"|\",\n+      BiShl => return ~\"<<\",\n+      BiShr => return ~\">>\",\n+      BiEq => return ~\"==\",\n+      BiLt => return ~\"<\",\n+      BiLe => return ~\"<=\",\n+      BiNe => return ~\"!=\",\n+      BiGe => return ~\">=\",\n+      BiGt => return ~\">\"\n+    }\n+}\n+\n+pub fn binop_to_method_name(op: BinOp) -> Option<~str> {\n     match op {\n-      add => return Some(~\"add\"),\n-      subtract => return Some(~\"sub\"),\n-      mul => return Some(~\"mul\"),\n-      div => return Some(~\"div\"),\n-      rem => return Some(~\"rem\"),\n-      bitxor => return Some(~\"bitxor\"),\n-      bitand => return Some(~\"bitand\"),\n-      bitor => return Some(~\"bitor\"),\n-      shl => return Some(~\"shl\"),\n-      shr => return Some(~\"shr\"),\n-      lt => return Some(~\"lt\"),\n-      le => return Some(~\"le\"),\n-      ge => return Some(~\"ge\"),\n-      gt => return Some(~\"gt\"),\n-      eq => return Some(~\"eq\"),\n-      ne => return Some(~\"ne\"),\n-      and | or => return None\n-    }\n-}\n-\n-pub fn lazy_binop(b: binop) -> bool {\n+      BiAdd => return Some(~\"add\"),\n+      BiSub => return Some(~\"sub\"),\n+      BiMul => return Some(~\"mul\"),\n+      BiDiv => return Some(~\"div\"),\n+      BiRem => return Some(~\"rem\"),\n+      BiBitXor => return Some(~\"bitxor\"),\n+      BiBitAnd => return Some(~\"bitand\"),\n+      BiBitOr => return Some(~\"bitor\"),\n+      BiShl => return Some(~\"shl\"),\n+      BiShr => return Some(~\"shr\"),\n+      BiLt => return Some(~\"lt\"),\n+      BiLe => return Some(~\"le\"),\n+      BiGe => return Some(~\"ge\"),\n+      BiGt => return Some(~\"gt\"),\n+      BiEq => return Some(~\"eq\"),\n+      BiNe => return Some(~\"ne\"),\n+      BiAnd | BiOr => return None\n+    }\n+}\n+\n+pub fn lazy_binop(b: BinOp) -> bool {\n     match b {\n-      and => true,\n-      or => true,\n+      BiAnd => true,\n+      BiOr => true,\n       _ => false\n     }\n }\n \n-pub fn is_shift_binop(b: binop) -> bool {\n+pub fn is_shift_binop(b: BinOp) -> bool {\n     match b {\n-      shl => true,\n-      shr => true,\n+      BiShl => true,\n+      BiShr => true,\n       _ => false\n     }\n }\n \n-pub fn unop_to_str(op: unop) -> ~str {\n+pub fn unop_to_str(op: UnOp) -> ~str {\n     match op {\n-      box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n-      uniq => ~\"~\",\n-      deref => ~\"*\",\n-      not => ~\"!\",\n-      neg => ~\"-\"\n+      UnBox(mt) => if mt == MutMutable { ~\"@mut \" } else { ~\"@\" },\n+      UnUniq => ~\"~\",\n+      UnDeref => ~\"*\",\n+      UnNot => ~\"!\",\n+      UnNeg => ~\"-\"\n     }\n }\n \n-pub fn is_path(e: @expr) -> bool {\n-    return match e.node { expr_path(_) => true, _ => false };\n+pub fn is_path(e: @Expr) -> bool {\n+    return match e.node { ExprPath(_) => true, _ => false };\n }\n \n pub fn int_ty_to_str(t: int_ty) -> ~str {\n@@ -192,19 +192,19 @@ pub fn float_ty_to_str(t: float_ty) -> ~str {\n     match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n-pub fn is_call_expr(e: @expr) -> bool {\n-    match e.node { expr_call(*) => true, _ => false }\n+pub fn is_call_expr(e: @Expr) -> bool {\n+    match e.node { ExprCall(*) => true, _ => false }\n }\n \n-pub fn block_from_expr(e: @expr) -> Block {\n-    let mut blk = default_block(~[], option::Some::<@expr>(e), e.id);\n+pub fn block_from_expr(e: @Expr) -> Block {\n+    let mut blk = default_block(~[], option::Some::<@Expr>(e), e.id);\n     blk.span = e.span;\n     return blk;\n }\n \n pub fn default_block(\n-    stmts1: ~[@stmt],\n-    expr1: Option<@expr>,\n+    stmts1: ~[@Stmt],\n+    expr1: Option<@Expr>,\n     id1: NodeId\n ) -> Block {\n     ast::Block {\n@@ -231,20 +231,20 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @pat {\n-    @ast::pat { id: id,\n-                node: pat_ident(bind_infer, ident_to_path(s, i), None),\n+pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @Pat {\n+    @ast::Pat { id: id,\n+                node: PatIdent(BindInfer, ident_to_path(s, i), None),\n                 span: s }\n }\n \n-pub fn is_unguarded(a: &arm) -> bool {\n+pub fn is_unguarded(a: &Arm) -> bool {\n     match a.guard {\n       None => true,\n       _    => false\n     }\n }\n \n-pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n+pub fn unguarded_pat(a: &Arm) -> Option<~[@Pat]> {\n     if is_unguarded(a) {\n         Some(/* FIXME (#2543) */ a.pats.clone())\n     } else {\n@@ -335,28 +335,28 @@ impl inlined_item_utils for inlined_item {\n \n /* True if d is either a def_self, or a chain of def_upvars\n  referring to a def_self */\n-pub fn is_self(d: ast::def) -> bool {\n+pub fn is_self(d: ast::Def) -> bool {\n   match d {\n-    def_self(*)           => true,\n-    def_upvar(_, d, _, _) => is_self(*d),\n+    DefSelf(*)           => true,\n+    DefUpvar(_, d, _, _) => is_self(*d),\n     _                     => false\n   }\n }\n \n /// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::binop) -> uint {\n+pub fn operator_prec(op: ast::BinOp) -> uint {\n   match op {\n       // 'as' sits here with 12\n-      mul | div | rem   => 11u,\n-      add | subtract    => 10u,\n-      shl | shr         =>  9u,\n-      bitand            =>  8u,\n-      bitxor            =>  7u,\n-      bitor             =>  6u,\n-      lt | le | ge | gt =>  4u,\n-      eq | ne           =>  3u,\n-      and               =>  2u,\n-      or                =>  1u\n+      BiMul | BiDiv | BiRem     => 11u,\n+      BiAdd | BiSub             => 10u,\n+      BiShl | BiShr             =>  9u,\n+      BiBitAnd                  =>  8u,\n+      BiBitXor                  =>  7u,\n+      BiBitOr                   =>  6u,\n+      BiLt | BiLe | BiGe | BiGt =>  4u,\n+      BiEq | BiNe               =>  3u,\n+      BiAnd                     =>  2u,\n+      BiOr                      =>  1u\n   }\n }\n \n@@ -497,27 +497,27 @@ impl Visitor<()> for IdVisitor {\n         visit::walk_block(self, block, env)\n     }\n \n-    fn visit_stmt(&mut self, statement: @stmt, env: ()) {\n+    fn visit_stmt(&mut self, statement: @Stmt, env: ()) {\n         (self.visit_callback)(ast_util::stmt_id(statement));\n         visit::walk_stmt(self, statement, env)\n     }\n \n     // XXX: Default\n-    fn visit_arm(&mut self, arm: &arm, env: ()) {\n+    fn visit_arm(&mut self, arm: &Arm, env: ()) {\n         visit::walk_arm(self, arm, env)\n     }\n \n-    fn visit_pat(&mut self, pattern: @pat, env: ()) {\n+    fn visit_pat(&mut self, pattern: @Pat, env: ()) {\n         (self.visit_callback)(pattern.id);\n         visit::walk_pat(self, pattern, env)\n     }\n \n     // XXX: Default\n-    fn visit_decl(&mut self, declaration: @decl, env: ()) {\n+    fn visit_decl(&mut self, declaration: @Decl, env: ()) {\n         visit::walk_decl(self, declaration, env)\n     }\n \n-    fn visit_expr(&mut self, expression: @expr, env: ()) {\n+    fn visit_expr(&mut self, expression: @Expr, env: ()) {\n         {\n             let optional_callee_id = expression.get_callee_id();\n             for callee_id in optional_callee_id.iter() {\n@@ -529,7 +529,7 @@ impl Visitor<()> for IdVisitor {\n     }\n \n     // XXX: Default\n-    fn visit_expr_post(&mut self, _: @expr, _: ()) {\n+    fn visit_expr_post(&mut self, _: @Expr, _: ()) {\n         // Empty!\n     }\n \n@@ -654,29 +654,29 @@ pub fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n+pub fn walk_pat(pat: @Pat, it: &fn(@Pat) -> bool) -> bool {\n     if !it(pat) {\n         return false;\n     }\n \n     match pat.node {\n-        pat_ident(_, _, Some(p)) => walk_pat(p, it),\n-        pat_struct(_, ref fields, _) => {\n+        PatIdent(_, _, Some(p)) => walk_pat(p, it),\n+        PatStruct(_, ref fields, _) => {\n             fields.iter().advance(|f| walk_pat(f.pat, |p| it(p)))\n         }\n-        pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n+        PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n             s.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n-        pat_box(s) | pat_uniq(s) | pat_region(s) => {\n+        PatBox(s) | PatUniq(s) | PatRegion(s) => {\n             walk_pat(s, it)\n         }\n-        pat_vec(ref before, ref slice, ref after) => {\n+        PatVec(ref before, ref slice, ref after) => {\n             before.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n                 slice.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n                 after.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n-        pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n-        pat_enum(_, _) => {\n+        PatWild | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n+        PatEnum(_, _) => {\n             true\n         }\n     }\n@@ -709,22 +709,22 @@ impl SimpleVisitor for EachViewItemData {\n     fn visit_block(&mut self, _: &Block) {\n         // XXX: Default method.\n     }\n-    fn visit_stmt(&mut self, _: @stmt) {\n+    fn visit_stmt(&mut self, _: @Stmt) {\n         // XXX: Default method.\n     }\n-    fn visit_arm(&mut self, _: &arm) {\n+    fn visit_arm(&mut self, _: &Arm) {\n         // XXX: Default method.\n     }\n-    fn visit_pat(&mut self, _: @pat) {\n+    fn visit_pat(&mut self, _: @Pat) {\n         // XXX: Default method.\n     }\n-    fn visit_decl(&mut self, _: @decl) {\n+    fn visit_decl(&mut self, _: @Decl) {\n         // XXX: Default method.\n     }\n-    fn visit_expr(&mut self, _: @expr) {\n+    fn visit_expr(&mut self, _: @Expr) {\n         // XXX: Default method.\n     }\n-    fn visit_expr_post(&mut self, _: @expr) {\n+    fn visit_expr_post(&mut self, _: @Expr) {\n         // XXX: Default method.\n     }\n     fn visit_ty(&mut self, _: &Ty) {\n@@ -817,9 +817,9 @@ pub enum Privacy {\n \n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n-pub fn pat_is_ident(pat: @ast::pat) -> bool {\n+pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n     match pat.node {\n-        ast::pat_ident(*) => true,\n+        ast::PatIdent(*) => true,\n         _ => false,\n     }\n }\n@@ -1015,7 +1015,7 @@ mod test {\n     // convert a list of uints to an @[ident]\n     // (ignores the interner completely)\n     fn uints_to_idents (uints: &~[uint]) -> @~[Ident] {\n-        @uints.map(|u| Ident {name:*u, ctxt: empty_ctxt})\n+        @uints.map(|u| Ident {name:*u, ctxt: EMPTY_CTXT})\n     }\n \n     fn id (u : uint, s: SyntaxContext) -> Ident {\n@@ -1065,7 +1065,7 @@ mod test {\n         let mut t = new_sctable_internal();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n-        assert_eq!(unfold_test_sc(test_sc.clone(),empty_ctxt,&mut t),4);\n+        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         assert_eq!(t.table[2],Mark(9,0));\n         assert_eq!(t.table[3],Rename(id(101,0),14,2));\n         assert_eq!(t.table[4],Mark(3,3));\n@@ -1082,7 +1082,7 @@ mod test {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),3);\n+        assert_eq!(unfold_marks(~[3,7],EMPTY_CTXT,&mut t),3);\n         assert_eq!(t.table[2],Mark(7,0));\n         assert_eq!(t.table[3],Mark(3,2));\n     }\n@@ -1091,31 +1091,31 @@ mod test {\n         let stopname = 242;\n         let name1 = 243;\n         let mut t = new_sctable_internal();\n-        assert_eq!(marksof (empty_ctxt,stopname,&t),~[]);\n+        assert_eq!(marksof (EMPTY_CTXT,stopname,&t),~[]);\n         // FIXME #5074: ANF'd to dodge nested calls\n-        { let ans = unfold_marks(~[4,98],empty_ctxt,&mut t);\n+        { let ans = unfold_marks(~[4,98],EMPTY_CTXT,&mut t);\n          assert_eq! (marksof (ans,stopname,&t),~[4,98]);}\n         // does xoring work?\n-        { let ans = unfold_marks(~[5,5,16],empty_ctxt,&mut t);\n+        { let ans = unfold_marks(~[5,5,16],EMPTY_CTXT,&mut t);\n          assert_eq! (marksof (ans,stopname,&t), ~[16]);}\n         // does nested xoring work?\n-        { let ans = unfold_marks(~[5,10,10,5,16],empty_ctxt,&mut t);\n+        { let ans = unfold_marks(~[5,10,10,5,16],EMPTY_CTXT,&mut t);\n          assert_eq! (marksof (ans, stopname,&t), ~[16]);}\n         // rename where stop doesn't match:\n         { let chain = ~[M(9),\n                         R(id(name1,\n-                             new_mark_internal (4, empty_ctxt,&mut t)),\n+                             new_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           100101102),\n                         M(14)];\n-         let ans = unfold_test_sc(chain,empty_ctxt,&mut t);\n+         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n          assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n         // rename where stop does match\n-        { let name1sc = new_mark_internal(4, empty_ctxt, &mut t);\n+        { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = ~[M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n                        M(14)];\n-         let ans = unfold_test_sc(chain,empty_ctxt,&mut t);\n+         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n          assert_eq! (marksof (ans, stopname, &t), ~[9]); }\n     }\n \n@@ -1124,38 +1124,38 @@ mod test {\n         let a = 40;\n         let mut t = new_sctable_internal();\n         // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,empty_ctxt),&mut t),a);\n+        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t),a);\n         // - simple ignored marks\n-        { let sc = unfold_marks(~[1,2,3],empty_ctxt,&mut t);\n+        { let sc = unfold_marks(~[1,2,3],EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n         // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(~[R(id(50,empty_ctxt),51),M(12)],empty_ctxt,&mut t);\n+        { let sc = unfold_test_sc(~[R(id(50,EMPTY_CTXT),51),M(12)],EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = new_mark_internal(1,empty_ctxt,&mut t);\n+        { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n-                                 empty_ctxt,&mut t);\n+                                 EMPTY_CTXT,&mut t);\n         assert_eq!(resolve_internal(id(a,sc),&mut t), a);}\n         // - rename where names and marks match\n-        { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],empty_ctxt,&mut t);\n+        { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n         // - rename where names and marks match by literal sharing\n-        { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n+        { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n-        { let sc = unfold_test_sc(~[R(id(a,empty_ctxt),50),\n-                                    R(id(a,empty_ctxt),51)],\n-                                  empty_ctxt,&mut t);\n+        { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n+                                    R(id(a,EMPTY_CTXT),51)],\n+                                  EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = new_rename_internal(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n+        { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n          let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n          assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t),51);\n          // mark on the outside doesn't stop rename:\n@@ -1171,10 +1171,10 @@ mod test {\n \n     #[test] fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(new_mark_internal(12,empty_ctxt,&mut t),2);\n-        assert_eq!(new_mark_internal(13,empty_ctxt,&mut t),3);\n+        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(new_mark_internal(13,EMPTY_CTXT,&mut t),3);\n         // using the same one again should result in the same index:\n-        assert_eq!(new_mark_internal(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n         // I'm assuming that the rename table will behave the same....\n     }\n "}, {"sha": "3937cd8e416d18ae47bf1c49bea5a3d918151c47", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -75,10 +75,10 @@ pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     let out = p.parse_expr();\n                     p.expect(&token::RPAREN);\n \n-                    let out = @ast::expr {\n+                    let out = @ast::Expr {\n                         id: cx.next_id(),\n                         span: out.span,\n-                        node: ast::expr_addr_of(ast::m_mutbl, out)\n+                        node: ast::ExprAddrOf(ast::MutMutable, out)\n                     };\n \n                     outputs.push((constraint, out));\n@@ -171,9 +171,9 @@ pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n         }\n     }\n \n-    MRExpr(@ast::expr {\n+    MRExpr(@ast::Expr {\n         id: cx.next_id(),\n-        node: ast::expr_inline_asm(ast::inline_asm {\n+        node: ast::ExprInlineAsm(ast::inline_asm {\n             asm: asm,\n             clobbers: cons.to_managed(),\n             inputs: inputs,"}, {"sha": "50683358f876aa91228d6534fbc81a41ea2b0b27", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -62,11 +62,11 @@ pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n                                     -> MacResult;\n \n pub enum MacResult {\n-    MRExpr(@ast::expr),\n+    MRExpr(@ast::Expr),\n     MRItem(@ast::item),\n-    MRAny(@fn() -> @ast::expr,\n+    MRAny(@fn() -> @ast::Expr,\n           @fn() -> Option<@ast::item>,\n-          @fn() -> @ast::stmt),\n+          @fn() -> @ast::Stmt),\n     MRDef(MacroDef)\n }\n \n@@ -319,9 +319,9 @@ impl ExtCtxt {\n     }\n }\n \n-pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: &str) -> @str {\n+pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::Expr, err_msg: &str) -> @str {\n     match expr.node {\n-      ast::expr_lit(l) => match l.node {\n+      ast::ExprLit(l) => match l.node {\n         ast::lit_str(s) => s,\n         _ => cx.span_fatal(l.span, err_msg)\n       },\n@@ -353,7 +353,7 @@ pub fn get_single_str_from_tts(cx: @ExtCtxt,\n \n pub fn get_exprs_from_tts(cx: @ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::token_tree]) -> ~[@ast::expr] {\n+                          tts: &[ast::token_tree]) -> ~[@ast::Expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n                                        tts.to_owned());"}, {"sha": "339583ed426cca8c6b900e67c217cd9e94b6ad32", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 182, "deletions": 182, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -21,7 +21,7 @@ use opt_vec::OptVec;\n \n pub struct Field {\n     ident: ast::Ident,\n-    ex: @ast::expr\n+    ex: @ast::Expr\n }\n \n // Transitional reexports so qquote can find the paths it is looking for\n@@ -43,7 +43,7 @@ pub trait AstBuilder {\n         -> ast::Path;\n \n     // types\n-    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::Mutability) -> ast::mt;\n \n     fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty;\n     fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n@@ -52,9 +52,9 @@ pub trait AstBuilder {\n     fn ty_rptr(&self, span: Span,\n                ty: ast::Ty,\n                lifetime: Option<ast::Lifetime>,\n-               mutbl: ast::mutability) -> ast::Ty;\n+               mutbl: ast::Mutability) -> ast::Ty;\n     fn ty_uniq(&self, span: Span, ty: ast::Ty) -> ast::Ty;\n-    fn ty_box(&self, span: Span, ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty;\n+    fn ty_box(&self, span: Span, ty: ast::Ty, mutbl: ast::Mutability) -> ast::Ty;\n \n     fn ty_option(&self, ty: ast::Ty) -> ast::Ty;\n     fn ty_infer(&self, sp: Span) -> ast::Ty;\n@@ -72,101 +72,101 @@ pub trait AstBuilder {\n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;\n \n     // statements\n-    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::expr) -> @ast::stmt;\n+    fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: ast::Ty,\n-                      ex: @ast::expr)\n-                      -> @ast::stmt;\n+                      ex: @ast::Expr)\n+                      -> @ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::Block;\n-    fn block_expr(&self, expr: @ast::expr) -> ast::Block;\n+    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@ast::Expr>) -> ast::Block;\n+    fn block_expr(&self, expr: @ast::Expr) -> ast::Block;\n     fn block_all(&self, span: Span,\n                  view_items: ~[ast::view_item],\n-                 stmts: ~[@ast::stmt],\n-                 expr: Option<@ast::expr>) -> ast::Block;\n+                 stmts: ~[@ast::Stmt],\n+                 expr: Option<@ast::Expr>) -> ast::Block;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::expr_) -> @ast::expr;\n-    fn expr_path(&self, path: ast::Path) -> @ast::expr;\n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::expr;\n-\n-    fn expr_self(&self, span: Span) -> @ast::expr;\n-    fn expr_binary(&self, sp: Span, op: ast::binop,\n-                   lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr;\n-    fn expr_deref(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n-    fn expr_unary(&self, sp: Span, op: ast::unop, e: @ast::expr) -> @ast::expr;\n-\n-    fn expr_managed(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n-    fn expr_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n-    fn expr_mut_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n-    fn expr_field_access(&self, span: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr;\n-    fn expr_call(&self, span: Span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr;\n+    fn expr_path(&self, path: ast::Path) -> @ast::Expr;\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::Expr;\n+\n+    fn expr_self(&self, span: Span) -> @ast::Expr;\n+    fn expr_binary(&self, sp: Span, op: ast::BinOp,\n+                   lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr;\n+    fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr) -> @ast::Expr;\n+\n+    fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n+    fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n+    fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n+    fn expr_field_access(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n+    fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n-                        args: ~[@ast::expr]) -> @ast::expr;\n+                        args: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::expr, ident: ast::Ident,\n-                        args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_block(&self, b: ast::Block) -> @ast::expr;\n+                        expr: @ast::Expr, ident: ast::Ident,\n+                        args: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_block(&self, b: ast::Block) -> @ast::Expr;\n \n-    fn field_imm(&self, span: Span, name: Ident, e: @ast::expr) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr;\n-    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: ~[ast::Field]) -> @ast::expr;\n+    fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n+    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr;\n \n-    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::expr;\n+    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::Expr;\n \n-    fn expr_uint(&self, span: Span, i: uint) -> @ast::expr;\n-    fn expr_int(&self, sp: Span, i: int) -> @ast::expr;\n-    fn expr_u8(&self, sp: Span, u: u8) -> @ast::expr;\n-    fn expr_bool(&self, sp: Span, value: bool) -> @ast::expr;\n+    fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr;\n+    fn expr_int(&self, sp: Span, i: int) -> @ast::Expr;\n+    fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr;\n+    fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr;\n \n-    fn expr_vstore(&self, sp: Span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr;\n-    fn expr_vec(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_str(&self, sp: Span, s: @str) -> @ast::expr;\n-    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::expr;\n+    fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr;\n+    fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr;\n+    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr;\n \n-    fn expr_unreachable(&self, span: Span) -> @ast::expr;\n+    fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n \n-    fn pat(&self, span: Span, pat: ast::pat_) -> @ast::pat;\n-    fn pat_wild(&self, span: Span) -> @ast::pat;\n-    fn pat_lit(&self, span: Span, expr: @ast::expr) -> @ast::pat;\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::pat;\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n+    fn pat_wild(&self, span: Span) -> @ast::Pat;\n+    fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat;\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat;\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::binding_mode) -> @ast::pat;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+                              bm: ast::BindingMode) -> @ast::Pat;\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::Pat]) -> @ast::Pat;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n+                  path: ast::Path, field_pats: ~[ast::FieldPat]) -> @ast::Pat;\n \n-    fn arm(&self, span: Span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n-    fn arm_unreachable(&self, span: Span) -> ast::arm;\n+    fn arm(&self, span: Span, pats: ~[@ast::Pat], expr: @ast::Expr) -> ast::Arm;\n+    fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: @ast::expr, arms: ~[ast::arm]) -> @ast::expr;\n+    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: ~[ast::Arm]) -> @ast::Expr;\n     fn expr_if(&self, span: Span,\n-               cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr;\n+               cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n \n-    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr;\n+    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::Expr;\n \n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::expr;\n-    fn lambda0(&self, span: Span, blk: ast::Block) -> @ast::expr;\n-    fn lambda1(&self, span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::expr;\n+    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::Expr;\n+    fn lambda0(&self, span: Span, blk: ast::Block) -> @ast::Expr;\n+    fn lambda1(&self, span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr;\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], blk: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_0(&self, span: Span, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr;\n+    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], blk: @ast::Expr) -> @ast::Expr;\n+    fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n+    fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], blk: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::Ident) -> @ast::expr;\n+    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], blk: ~[@ast::Stmt]) -> @ast::Expr;\n+    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::Stmt]) -> @ast::Expr;\n+    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::Stmt], ident: ast::Ident) -> @ast::Expr;\n \n     // items\n     fn item(&self, span: Span,\n@@ -268,7 +268,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::Mutability) -> ast::mt {\n         ast::mt {\n             ty: ~ty,\n             mutbl: mutbl\n@@ -300,16 +300,16 @@ impl AstBuilder for @ExtCtxt {\n                span: Span,\n                ty: ast::Ty,\n                lifetime: Option<ast::Lifetime>,\n-               mutbl: ast::mutability)\n+               mutbl: ast::Mutability)\n         -> ast::Ty {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n     fn ty_uniq(&self, span: Span, ty: ast::Ty) -> ast::Ty {\n-        self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n+        self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::MutImmutable)))\n     }\n     fn ty_box(&self, span: Span,\n-                 ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty {\n+                 ty: ast::Ty, mutbl: ast::Mutability) -> ast::Ty {\n         self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n \n@@ -329,7 +329,7 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::TypeField {\n         ast::TypeField {\n             ident: name,\n-            mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n+            mt: ast::mt { ty: ~ty, mutbl: ast::MutImmutable },\n             span: span,\n         }\n     }\n@@ -389,11 +389,11 @@ impl AstBuilder for @ExtCtxt {\n         ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n     }\n \n-    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n-        @respan(expr.span, ast::stmt_semi(expr, self.next_id()))\n+    fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt {\n+        @respan(expr.span, ast::StmtSemi(expr, self.next_id()))\n     }\n \n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::expr) -> @ast::stmt {\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt {\n         let pat = self.pat_ident(sp, ident);\n         let local = @ast::Local {\n             is_mutbl: mutbl,\n@@ -403,17 +403,17 @@ impl AstBuilder for @ExtCtxt {\n             id: self.next_id(),\n             span: sp,\n         };\n-        let decl = respan(sp, ast::decl_local(local));\n-        @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n+        let decl = respan(sp, ast::DeclLocal(local));\n+        @respan(sp, ast::StmtDecl(@decl, self.next_id()))\n     }\n \n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: ast::Ty,\n-                      ex: @ast::expr)\n-                      -> @ast::stmt {\n+                      ex: @ast::Expr)\n+                      -> @ast::Stmt {\n         let pat = self.pat_ident(sp, ident);\n         let local = @ast::Local {\n             is_mutbl: mutbl,\n@@ -423,22 +423,22 @@ impl AstBuilder for @ExtCtxt {\n             id: self.next_id(),\n             span: sp,\n         };\n-        let decl = respan(sp, ast::decl_local(local));\n-        @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n+        let decl = respan(sp, ast::DeclLocal(local));\n+        @respan(sp, ast::StmtDecl(@decl, self.next_id()))\n     }\n \n-    fn block(&self, span: Span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::Block {\n+    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@Expr>) -> ast::Block {\n         self.block_all(span, ~[], stmts, expr)\n     }\n \n-    fn block_expr(&self, expr: @ast::expr) -> ast::Block {\n+    fn block_expr(&self, expr: @ast::Expr) -> ast::Block {\n         self.block_all(expr.span, ~[], ~[], Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n                  view_items: ~[ast::view_item],\n-                 stmts: ~[@ast::stmt],\n-                 expr: Option<@ast::expr>) -> ast::Block {\n+                 stmts: ~[@ast::Stmt],\n+                 expr: Option<@ast::Expr>) -> ast::Block {\n            ast::Block {\n                view_items: view_items,\n                stmts: stmts,\n@@ -449,122 +449,122 @@ impl AstBuilder for @ExtCtxt {\n            }\n     }\n \n-    fn expr(&self, span: Span, node: ast::expr_) -> @ast::expr {\n-        @ast::expr {\n+    fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr {\n+        @ast::Expr {\n             id: self.next_id(),\n             node: node,\n             span: span,\n         }\n     }\n \n-    fn expr_path(&self, path: ast::Path) -> @ast::expr {\n-        self.expr(path.span, ast::expr_path(path))\n+    fn expr_path(&self, path: ast::Path) -> @ast::Expr {\n+        self.expr(path.span, ast::ExprPath(path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::expr {\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::Expr {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: Span) -> @ast::expr {\n-        self.expr(span, ast::expr_self)\n+    fn expr_self(&self, span: Span) -> @ast::Expr {\n+        self.expr(span, ast::ExprSelf)\n     }\n \n-    fn expr_binary(&self, sp: Span, op: ast::binop,\n-                   lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n-        self.expr(sp, ast::expr_binary(self.next_id(), op, lhs, rhs))\n+    fn expr_binary(&self, sp: Span, op: ast::BinOp,\n+                   lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr {\n+        self.expr(sp, ast::ExprBinary(self.next_id(), op, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n-        self.expr_unary(sp, ast::deref, e)\n+    fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+        self.expr_unary(sp, ast::UnDeref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::unop, e: @ast::expr)\n-        -> @ast::expr {\n-        self.expr(sp, ast::expr_unary(self.next_id(), op, e))\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr)\n+        -> @ast::Expr {\n+        self.expr(sp, ast::ExprUnary(self.next_id(), op, e))\n     }\n \n-    fn expr_managed(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n-        self.expr_unary(sp, ast::box(ast::m_imm), e)\n+    fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+        self.expr_unary(sp, ast::UnBox(ast::MutImmutable), e)\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr {\n-        self.expr(sp, ast::expr_field(expr, ident, ~[]))\n+    fn expr_field_access(&self, sp: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n+        self.expr(sp, ast::ExprField(expr, ident, ~[]))\n     }\n-    fn expr_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n-        self.expr(sp, ast::expr_addr_of(ast::m_imm, e))\n+    fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+        self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n-        self.expr(sp, ast::expr_addr_of(ast::m_mutbl, e))\n+    fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+        self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n+    fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr {\n+        self.expr(span, ast::ExprCall(expr, args, ast::NoSugar))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr {\n         self.expr(span,\n-                  ast::expr_call(self.expr_ident(span, id), args, ast::NoSugar))\n+                  ast::ExprCall(self.expr_ident(span, id), args, ast::NoSugar))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n-                      args: ~[@ast::expr]) -> @ast::expr {\n+                      args: ~[@ast::Expr]) -> @ast::Expr {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::expr,\n+                        expr: @ast::Expr,\n                         ident: ast::Ident,\n-                        args: ~[@ast::expr]) -> @ast::expr {\n+                        args: ~[@ast::Expr]) -> @ast::Expr {\n         self.expr(span,\n-                  ast::expr_method_call(self.next_id(), expr, ident, ~[], args, ast::NoSugar))\n+                  ast::ExprMethodCall(self.next_id(), expr, ident, ~[], args, ast::NoSugar))\n     }\n-    fn expr_block(&self, b: ast::Block) -> @ast::expr {\n-        self.expr(b.span, ast::expr_block(b))\n+    fn expr_block(&self, b: ast::Block) -> @ast::Expr {\n+        self.expr(b.span, ast::ExprBlock(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: @ast::expr) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field {\n         ast::Field { ident: name, expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr {\n-        self.expr(span, ast::expr_struct(path, fields, None))\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr {\n+        self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: ~[ast::Field]) -> @ast::expr {\n+                         id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::expr {\n-        self.expr(sp, ast::expr_lit(@respan(sp, lit)))\n+    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::Expr {\n+        self.expr(sp, ast::ExprLit(@respan(sp, lit)))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> @ast::expr {\n+    fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr {\n         self.expr_lit(span, ast::lit_uint(i as u64, ast::ty_u))\n     }\n-    fn expr_int(&self, sp: Span, i: int) -> @ast::expr {\n+    fn expr_int(&self, sp: Span, i: int) -> @ast::Expr {\n         self.expr_lit(sp, ast::lit_int(i as i64, ast::ty_i))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> @ast::expr {\n+    fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr {\n         self.expr_lit(sp, ast::lit_uint(u as u64, ast::ty_u8))\n     }\n-    fn expr_bool(&self, sp: Span, value: bool) -> @ast::expr {\n+    fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr {\n         self.expr_lit(sp, ast::lit_bool(value))\n     }\n \n-    fn expr_vstore(&self, sp: Span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr {\n-        self.expr(sp, ast::expr_vstore(expr, vst))\n+    fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr {\n+        self.expr(sp, ast::ExprVstore(expr, vst))\n     }\n-    fn expr_vec(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr {\n-        self.expr(sp, ast::expr_vec(exprs, ast::m_imm))\n+    fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+        self.expr(sp, ast::ExprVec(exprs, ast::MutImmutable))\n     }\n-    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr {\n-        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_uniq)\n+    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreUniq)\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr {\n-        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_slice)\n+    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n-    fn expr_str(&self, sp: Span, s: @str) -> @ast::expr {\n+    fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr {\n         self.expr_lit(sp, ast::lit_str(s))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::expr {\n-        self.expr_vstore(sp, self.expr_str(sp, s), ast::expr_vstore_uniq)\n+    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr {\n+        self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n     }\n \n \n-    fn expr_unreachable(&self, span: Span) -> @ast::expr {\n+    fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -582,110 +582,110 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n \n-    fn pat(&self, span: Span, pat: ast::pat_) -> @ast::pat {\n-        @ast::pat { id: self.next_id(), node: pat, span: span }\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat {\n+        @ast::Pat { id: self.next_id(), node: pat, span: span }\n     }\n-    fn pat_wild(&self, span: Span) -> @ast::pat {\n-        self.pat(span, ast::pat_wild)\n+    fn pat_wild(&self, span: Span) -> @ast::Pat {\n+        self.pat(span, ast::PatWild)\n     }\n-    fn pat_lit(&self, span: Span, expr: @ast::expr) -> @ast::pat {\n-        self.pat(span, ast::pat_lit(expr))\n+    fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat {\n+        self.pat(span, ast::PatLit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::pat {\n-        self.pat_ident_binding_mode(span, ident, ast::bind_infer)\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat {\n+        self.pat_ident_binding_mode(span, ident, ast::BindInfer)\n     }\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::binding_mode) -> @ast::pat {\n+                              bm: ast::BindingMode) -> @ast::Pat {\n         let path = self.path_ident(span, ident);\n-        let pat = ast::pat_ident(bm, path, None);\n+        let pat = ast::PatIdent(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n-        let pat = ast::pat_enum(path, Some(subpats));\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::Pat]) -> @ast::Pat {\n+        let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n-        let pat = ast::pat_struct(path, field_pats, false);\n+                  path: ast::Path, field_pats: ~[ast::FieldPat]) -> @ast::Pat {\n+        let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n \n-    fn arm(&self, _span: Span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm {\n-        ast::arm {\n+    fn arm(&self, _span: Span, pats: ~[@ast::Pat], expr: @ast::Expr) -> ast::Arm {\n+        ast::Arm {\n             pats: pats,\n             guard: None,\n             body: self.block_expr(expr)\n         }\n     }\n \n-    fn arm_unreachable(&self, span: Span) -> ast::arm {\n+    fn arm_unreachable(&self, span: Span) -> ast::Arm {\n         self.arm(span, ~[self.pat_wild(span)], self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: @ast::expr, arms: ~[ast::arm]) -> @expr {\n-        self.expr(span, ast::expr_match(arg, arms))\n+    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: ~[ast::Arm]) -> @Expr {\n+        self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n     fn expr_if(&self, span: Span,\n-               cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr {\n+               cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr {\n         let els = els.map_move(|x| self.expr_block(self.block_expr(x)));\n-        self.expr(span, ast::expr_if(cond, self.block_expr(then), els))\n+        self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n-    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr {\n-        self.expr(span, ast::expr_fn_block(fn_decl, blk))\n+    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::Expr {\n+        self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::expr {\n+    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::Expr {\n         let fn_decl = self.fn_decl(\n             ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::expr_fn_block(fn_decl, blk))\n+        self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n     #[cfg(stage0)]\n-    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::expr {\n+    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::Expr {\n         let ext_cx = *self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n+        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n         quote_expr!(|| $blk_e )\n     }\n     #[cfg(not(stage0))]\n-    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::expr {\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n+    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::Expr {\n+        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n         quote_expr!(*self, || $blk_e )\n     }\n \n     #[cfg(stage0)]\n-    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::expr {\n+    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr {\n         let ext_cx = *self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n+        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n         quote_expr!(|$ident| $blk_e )\n     }\n     #[cfg(not(stage0))]\n-    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::expr {\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n+    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr {\n+        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n         quote_expr!(*self, |$ident| $blk_e )\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], expr: @ast::expr) -> @ast::expr {\n+    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], expr: @ast::Expr) -> @ast::Expr {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n-    fn lambda_expr_0(&self, span: Span, expr: @ast::expr) -> @ast::expr {\n+    fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr {\n+    fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], stmts: ~[@ast::Stmt]) -> @ast::Expr {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::Stmt]) -> @ast::Expr {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::Ident) -> @ast::expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::Stmt], ident: ast::Ident) -> @ast::Expr {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -889,8 +889,8 @@ pub trait Duplicate {\n     fn duplicate(&self, cx: @ExtCtxt) -> Self;\n }\n \n-impl Duplicate for @ast::expr {\n-    fn duplicate(&self, cx: @ExtCtxt) -> @ast::expr {\n+impl Duplicate for @ast::Expr {\n+    fn duplicate(&self, cx: @ExtCtxt) -> @ast::Expr {\n         let folder = fold::default_ast_fold();\n         let folder = @fold::AstFoldFns {\n             new_id: |_| cx.next_id(),"}, {"sha": "faf3e2653b91f97412e1370f92430124b2368121", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -24,7 +24,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> bas\n     for expr in exprs.iter() {\n         match expr.node {\n             // expression is a literal\n-            ast::expr_lit(lit) => match lit.node {\n+            ast::ExprLit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n                     for byte in s.byte_iter() {"}, {"sha": "16e54093a147af550e33ee0fe26981eaa197a340", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -34,9 +34,9 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     }\n     let res = str_to_ident(res_str);\n \n-    let e = @ast::expr {\n+    let e = @ast::Expr {\n         id: cx.next_id(),\n-        node: ast::expr_path(\n+        node: ast::ExprPath(\n             ast::Path {\n                  span: sp,\n                  global: false,"}, {"sha": "9ef995b0d5700f04511f13c2d77b366939f157a1", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -69,7 +69,7 @@ pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n fn cs_clone(\n     name: &str,\n     cx: @ExtCtxt, span: Span,\n-    substr: &Substructure) -> @expr {\n+    substr: &Substructure) -> @Expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;"}, {"sha": "d147875d5e12fd7a23f6a1baa08d1db8af130d91", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -20,11 +20,11 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n+    fn cs_eq(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n+    fn cs_ne(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "33f45d45bdb85677552f572993a3b355843e561a", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -48,8 +48,8 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n-    let op = if less {ast::lt} else {ast::gt};\n+fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,\n         |cx, span, subexpr, self_f, other_fs| {\n@@ -79,13 +79,13 @@ fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: Span, substr: &Substructur\n                                      cx.expr_deref(span, self_f),\n                                      cx.expr_deref(span, other_f));\n \n-            let not_cmp = cx.expr_unary(span, ast::not,\n+            let not_cmp = cx.expr_unary(span, ast::UnNot,\n                                         cx.expr_binary(span, op,\n                                                        cx.expr_deref(span, other_f),\n                                                        cx.expr_deref(span, self_f)));\n \n-            let and = cx.expr_binary(span, ast::and, not_cmp, subexpr);\n-            cx.expr_binary(span, ast::or, cmp, and)\n+            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n+            cx.expr_binary(span, ast::BiOr, cmp, and)\n         },\n         cx.expr_bool(span, equal),\n         |cx, span, args, _| {"}, {"sha": "c6123451071b4fa7a70b4c4f8563c9f9e2259e50", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -18,7 +18,7 @@ pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n                                span: Span,\n                                mitem: @MetaItem,\n                                in_items: ~[@item]) -> ~[@item] {\n-    fn cs_equals(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n+    fn cs_equals(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)\n     }"}, {"sha": "34c6d1104dac22d26aa20a83218a5e1332d18573", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -54,7 +54,7 @@ pub fn ordering_const(cx: @ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n }\n \n pub fn cs_cmp(cx: @ExtCtxt, span: Span,\n-              substr: &Substructure) -> @expr {\n+              substr: &Substructure) -> @Expr {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = ordering_const(cx, span, Equal);\n \n@@ -89,7 +89,7 @@ pub fn cs_cmp(cx: @ExtCtxt, span: Span,\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n-            let cond = cx.expr_binary(span, ast::eq,\n+            let cond = cx.expr_binary(span, ast::BiEq,\n                                       cx.expr_ident(span, test_id),\n                                       cx.expr_path(equals_path.clone()));\n             let if_ = cx.expr_if(span,"}, {"sha": "66cd2d511a89db82c6b5419630f4e185941592c5", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -15,7 +15,7 @@ encodable.rs for more.\n \n use std::vec;\n \n-use ast::{MetaItem, item, expr, m_mutbl};\n+use ast::{MetaItem, item, Expr, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -39,7 +39,7 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n                 args: ~[Ptr(~Literal(Path::new_local(\"__D\")),\n-                            Borrowed(None, m_mutbl))],\n+                            Borrowed(None, MutMutable))],\n                 ret_ty: Self,\n                 const_nonmatching: true,\n                 combine_substructure: decodable_substructure,\n@@ -51,7 +51,7 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n }\n \n fn decodable_substructure(cx: @ExtCtxt, span: Span,\n-                          substr: &Substructure) -> @expr {\n+                          substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n     let recurse = ~[cx.ident_of(\"extra\"),\n                     cx.ident_of(\"serialize\"),"}, {"sha": "99b2359232c2a47853ed814fa1d8b4e30e0d6612", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -75,7 +75,7 @@ would yield functions like:\n     }\n */\n \n-use ast::{MetaItem, item, expr, m_imm, m_mutbl};\n+use ast::{MetaItem, item, Expr, MutImmutable, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -97,9 +97,9 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds::empty(),\n-                explicit_self: Some(Some(Borrowed(None, m_imm))),\n+                explicit_self: Some(Some(Borrowed(None, MutImmutable))),\n                 args: ~[Ptr(~Literal(Path::new_local(\"__E\")),\n-                            Borrowed(None, m_mutbl))],\n+                            Borrowed(None, MutMutable))],\n                 ret_ty: nil_ty(),\n                 const_nonmatching: true,\n                 combine_substructure: encodable_substructure,\n@@ -111,7 +111,7 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n }\n \n fn encodable_substructure(cx: @ExtCtxt, span: Span,\n-                          substr: &Substructure) -> @expr {\n+                          substr: &Substructure) -> @Expr {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");"}, {"sha": "7050cfbedb73e0eb3ec00c55c97d0df78ecb79fe", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -163,7 +163,7 @@ StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n */\n \n use ast;\n-use ast::{enum_def, expr, Ident, Generics, struct_def};\n+use ast::{enum_def, Expr, Ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -220,9 +220,9 @@ pub struct Substructure<'self> {\n     /// ident of the method\n     method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n-    self_args: &'self [@expr],\n+    self_args: &'self [@Expr],\n     /// verbatim access to any other arguments\n-    nonself_args: &'self [@expr],\n+    nonself_args: &'self [@Expr],\n     fields: &'self SubstructureFields<'self>\n }\n \n@@ -234,21 +234,21 @@ pub enum SubstructureFields<'self> {\n     ident is the ident of the current field (`None` for all fields in tuple\n     structs).\n     */\n-    Struct(~[(Option<Ident>, @expr, ~[@expr])]),\n+    Struct(~[(Option<Ident>, @Expr, ~[@Expr])]),\n \n     /**\n     Matching variants of the enum: variant index, ast::variant,\n     fields: `(field ident, self, [others])`, where the field ident is\n     only non-`None` in the case of a struct variant.\n     */\n-    EnumMatching(uint, &'self ast::variant, ~[(Option<Ident>, @expr, ~[@expr])]),\n+    EnumMatching(uint, &'self ast::variant, ~[(Option<Ident>, @Expr, ~[@Expr])]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n     [field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<Ident>, @expr)])]),\n+    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<Ident>, @Expr)])]),\n \n     /// A static method where Self is a struct\n     StaticStruct(&'self ast::struct_def, Either<uint, ~[Ident]>),\n@@ -263,7 +263,7 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'self> =\n-    &'self fn(@ExtCtxt, Span, &Substructure) -> @expr;\n+    &'self fn(@ExtCtxt, Span, &Substructure) -> @Expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n@@ -273,8 +273,8 @@ representing each variant: (variant index, ast::variant instance,\n pub type EnumNonMatchFunc<'self> =\n     &'self fn(@ExtCtxt, Span,\n               &[(uint, ast::variant,\n-                 ~[(Option<Ident>, @expr)])],\n-              &[@expr]) -> @expr;\n+                 ~[(Option<Ident>, @Expr)])],\n+              &[@Expr]) -> @Expr;\n \n \n impl<'self> TraitDef<'self> {\n@@ -440,10 +440,10 @@ impl<'self> MethodDef<'self> {\n                                 cx: @ExtCtxt,\n                                 span: Span,\n                                 type_ident: Ident,\n-                                self_args: &[@expr],\n-                                nonself_args: &[@expr],\n+                                self_args: &[@Expr],\n+                                nonself_args: &[@Expr],\n                                 fields: &SubstructureFields)\n-        -> @expr {\n+        -> @Expr {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n@@ -466,7 +466,7 @@ impl<'self> MethodDef<'self> {\n \n     fn split_self_nonself_args(&self, cx: @ExtCtxt, span: Span,\n                              type_ident: Ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(Ident, ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@Expr], ~[@Expr], ~[(Ident, ast::Ty)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -515,7 +515,7 @@ impl<'self> MethodDef<'self> {\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n                      arg_types: ~[(Ident, ast::Ty)],\n-                     body: @expr) -> @ast::method {\n+                     body: @Expr) -> @ast::method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n@@ -572,17 +572,17 @@ impl<'self> MethodDef<'self> {\n                                  span: Span,\n                                  struct_def: &struct_def,\n                                  type_ident: Ident,\n-                                 self_args: &[@expr],\n-                                 nonself_args: &[@expr])\n-        -> @expr {\n+                                 self_args: &[@Expr],\n+                                 nonself_args: &[@Expr])\n+        -> @Expr {\n \n         let mut raw_fields = ~[]; // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = ~[];\n         for i in range(0u, self_args.len()) {\n             let (pat, ident_expr) = create_struct_pattern(cx, span,\n                                                           type_ident, struct_def,\n-                                                          fmt!(\"__self_%u\", i), ast::m_imm);\n+                                                          fmt!(\"__self_%u\", i), ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -626,9 +626,9 @@ impl<'self> MethodDef<'self> {\n                                         span: Span,\n                                         struct_def: &struct_def,\n                                         type_ident: Ident,\n-                                        self_args: &[@expr],\n-                                        nonself_args: &[@expr])\n-        -> @expr {\n+                                        self_args: &[@Expr],\n+                                        nonself_args: &[@Expr])\n+        -> @Expr {\n         let summary = summarise_struct(cx, span, struct_def);\n \n         self.call_substructure_method(cx, span,\n@@ -668,9 +668,9 @@ impl<'self> MethodDef<'self> {\n                                span: Span,\n                                enum_def: &enum_def,\n                                type_ident: Ident,\n-                               self_args: &[@expr],\n-                               nonself_args: &[@expr])\n-        -> @expr {\n+                               self_args: &[@Expr],\n+                               nonself_args: &[@Expr])\n+        -> @Expr {\n         let mut matches = ~[];\n         self.build_enum_match(cx, span, enum_def, type_ident,\n                               self_args, nonself_args,\n@@ -703,12 +703,12 @@ impl<'self> MethodDef<'self> {\n                         cx: @ExtCtxt, span: Span,\n                         enum_def: &enum_def,\n                         type_ident: Ident,\n-                        self_args: &[@expr],\n-                        nonself_args: &[@expr],\n+                        self_args: &[@Expr],\n+                        nonself_args: &[@Expr],\n                         matching: Option<uint>,\n                         matches_so_far: &mut ~[(uint, ast::variant,\n-                                              ~[(Option<Ident>, @expr)])],\n-                        match_count: uint) -> @expr {\n+                                              ~[(Option<Ident>, @Expr)])],\n+                        match_count: uint) -> @Expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n@@ -787,7 +787,7 @@ impl<'self> MethodDef<'self> {\n                 let (pattern, idents) = create_enum_variant_pattern(cx, span,\n                                                                     variant,\n                                                                     current_match_str,\n-                                                                    ast::m_imm);\n+                                                                    ast::MutImmutable);\n \n                 matches_so_far.push((index,\n                                      /*bad*/ (*variant).clone(),\n@@ -818,7 +818,7 @@ impl<'self> MethodDef<'self> {\n                     let (pattern, idents) = create_enum_variant_pattern(cx, span,\n                                                                        variant,\n                                                                        current_match_str,\n-                                                                       ast::m_imm);\n+                                                                       ast::MutImmutable);\n \n                     matches_so_far.push((index,\n                                          /*bad*/ (*variant).clone(),\n@@ -853,9 +853,9 @@ impl<'self> MethodDef<'self> {\n                                span: Span,\n                                enum_def: &enum_def,\n                                type_ident: Ident,\n-                               self_args: &[@expr],\n-                               nonself_args: &[@expr])\n-        -> @expr {\n+                               self_args: &[@Expr],\n+                               nonself_args: &[@Expr])\n+        -> @Expr {\n         let summary = do enum_def.variants.map |v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n@@ -898,11 +898,11 @@ fn summarise_struct(cx: @ExtCtxt, span: Span,\n pub fn create_subpatterns(cx: @ExtCtxt,\n                           span: Span,\n                           field_paths: ~[ast::Path],\n-                          mutbl: ast::mutability)\n-                   -> ~[@ast::pat] {\n+                          mutbl: ast::Mutability)\n+                   -> ~[@ast::Pat] {\n     do field_paths.map |path| {\n         cx.pat(span,\n-               ast::pat_ident(ast::bind_by_ref(mutbl), (*path).clone(), None))\n+               ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n     }\n }\n \n@@ -916,12 +916,12 @@ fn create_struct_pattern(cx: @ExtCtxt,\n                              struct_ident: Ident,\n                              struct_def: &struct_def,\n                              prefix: &str,\n-                             mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<Ident>, @expr)]) {\n+                             mutbl: ast::Mutability)\n+    -> (@ast::Pat, ~[(Option<Ident>, @Expr)]) {\n     if struct_def.fields.is_empty() {\n         return (\n             cx.pat_ident_binding_mode(\n-                span, struct_ident, ast::bind_infer),\n+                span, struct_ident, ast::BindInfer),\n             ~[]);\n     }\n \n@@ -961,7 +961,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         let field_pats = do vec::build |push| {\n             for (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n                 // id is guaranteed to be Some\n-                push(ast::field_pat { ident: id.unwrap(), pat: pat })\n+                push(ast::FieldPat { ident: id.unwrap(), pat: pat })\n             }\n         };\n         cx.pat_struct(span, matching_path, field_pats)\n@@ -976,15 +976,15 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n                                    span: Span,\n                                    variant: &ast::variant,\n                                    prefix: &str,\n-                                   mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<Ident>, @expr)]) {\n+                                   mutbl: ast::Mutability)\n+    -> (@ast::Pat, ~[(Option<Ident>, @Expr)]) {\n \n     let variant_ident = variant.node.name;\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref variant_args) => {\n             if variant_args.is_empty() {\n                 return (cx.pat_ident_binding_mode(\n-                    span, variant_ident, ast::bind_infer), ~[]);\n+                    span, variant_ident, ast::BindInfer), ~[]);\n             }\n \n             let matching_path = cx.path_ident(span, variant_ident);\n@@ -1023,13 +1023,13 @@ left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n                f: &fn(@ExtCtxt, Span,\n-                      old: @expr,\n-                      self_f: @expr,\n-                      other_fs: &[@expr]) -> @expr,\n-               base: @expr,\n+                      old: @Expr,\n+                      self_f: @Expr,\n+                      other_fs: &[@Expr]) -> @Expr,\n+               base: @Expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n                cx: @ExtCtxt, span: Span,\n-               substructure: &Substructure) -> @expr {\n+               substructure: &Substructure) -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1064,10 +1064,10 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@expr]) -> @expr,\n+pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@Expr]) -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: @ExtCtxt, span: Span,\n-                      substructure: &Substructure) -> @expr {\n+                      substructure: &Substructure) -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1097,11 +1097,11 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: &fn(@ExtCtxt, Span, @expr, @expr) -> @expr,\n-                           base: @expr,\n+                           f: &fn(@ExtCtxt, Span, @Expr, @Expr) -> @Expr,\n+                           base: @Expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n                            cx: @ExtCtxt, span: Span,\n-                           substructure: &Substructure) -> @expr {\n+                           substructure: &Substructure) -> @Expr {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n@@ -1124,10 +1124,10 @@ Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n #[inline]\n-pub fn cs_binop(binop: ast::binop, base: @expr,\n+pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n                 cx: @ExtCtxt, span: Span,\n-                substructure: &Substructure) -> @expr {\n+                substructure: &Substructure) -> @Expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n@@ -1145,17 +1145,17 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: @ExtCtxt, span: Span,\n-             substructure: &Substructure) -> @expr {\n-    cs_binop(ast::or, cx.expr_bool(span, false),\n+             substructure: &Substructure) -> @Expr {\n+    cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: @ExtCtxt, span: Span,\n-              substructure: &Substructure) -> @expr {\n-    cs_binop(ast::and, cx.expr_bool(span, true),\n+              substructure: &Substructure) -> @Expr {\n+    cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }"}, {"sha": "0f4e57b0889ab22138265d6ae21fd82b1d44b7c2", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, expr, and};\n+use ast::{MetaItem, item, Expr, BiAnd};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -42,7 +42,7 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n+fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let (lsb0, f)= match substr.nonself_args {\n         [l, f] => (l, f),\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n@@ -90,6 +90,6 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @\n     }\n \n     do exprs.slice(1, exprs.len()).iter().fold(exprs[0]) |prev, me| {\n-        cx.expr_binary(span, and, prev, *me)\n+        cx.expr_binary(span, BiAnd, prev, *me)\n     }\n }"}, {"sha": "8afd99e80af0fbc3a89665d6acf64450f8db6994", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, expr, Ident};\n+use ast::{MetaItem, item, Expr, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder, Duplicate};\n@@ -37,7 +37,7 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n                 explicit_self: None,\n                 args: ~[\n                     Ptr(~Literal(Path::new_local(\"R\")),\n-                        Borrowed(None, ast::m_mutbl))\n+                        Borrowed(None, ast::MutMutable))\n                 ],\n                 ret_ty: Self,\n                 const_nonmatching: false,\n@@ -48,7 +48,7 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n+fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -100,7 +100,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n             // rand() % variants.len()\n             let value_ref = cx.expr_ident(span, value_ident);\n             let rand_variant = cx.expr_binary(span,\n-                                              ast::rem,\n+                                              ast::BiRem,\n                                               value_ref,\n                                               variant_count);\n \n@@ -115,7 +115,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n                                rand_thing(cx, span, ident, summary, || rand_call()))\n                     }\n                 }\n-            }.collect::<~[ast::arm]>();\n+            }.collect::<~[ast::Arm]>();\n \n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(span));\n@@ -131,7 +131,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n     fn rand_thing(cx: @ExtCtxt, span: Span,\n                   ctor_ident: Ident,\n                   summary: &Either<uint, ~[Ident]>,\n-                  rand_call: &fn() -> @expr) -> @expr {\n+                  rand_call: &fn() -> @Expr) -> @Expr {\n         match *summary {\n             Left(count) => {\n                 if count == 0 {"}, {"sha": "fa13f78d0f9b6b158c558d14dd7ede4491ffb7b9", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -44,11 +44,11 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n // to_str() method on each field. Hence we mirror the logic of the log_str()\n // method, but with tweaks to call to_str() on sub-fields.\n fn to_str_substructure(cx: @ExtCtxt, span: Span,\n-                       substr: &Substructure) -> @expr {\n+                       substr: &Substructure) -> @Expr {\n     let to_str = cx.ident_of(\"to_str\");\n \n     let doit = |start: &str, end: @str, name: ast::Ident,\n-                fields: &[(Option<ast::Ident>, @expr, ~[@expr])]| {\n+                fields: &[(Option<ast::Ident>, @Expr, ~[@Expr])]| {\n         if fields.len() == 0 {\n             cx.expr_str_uniq(span, cx.str_of(name))\n         } else {\n@@ -58,7 +58,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n             let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n             let push_str = cx.ident_of(\"push_str\");\n \n-            let push = |s: @expr| {\n+            let push = |s: @Expr| {\n                 let ebuf = cx.expr_ident(span, buf);\n                 let call = cx.expr_method_call(span, ebuf, push_str, ~[s]);\n                 stmts.push(cx.stmt_expr(call));"}, {"sha": "d6f5e2df5a49a906ffbbb8b8a049dc296947d518", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -14,7 +14,7 @@ explicit `Self` type to use when specifying impls to be derived.\n */\n \n use ast;\n-use ast::{expr,Generics,Ident};\n+use ast::{Expr,Generics,Ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n@@ -23,8 +23,8 @@ use opt_vec;\n /// The types of pointers\n pub enum PtrTy<'self> {\n     Send, // ~\n-    Managed(ast::mutability), // @[mut]\n-    Borrowed(Option<&'self str>, ast::mutability), // &['lifetime] [mut]\n+    Managed(ast::Mutability), // @[mut]\n+    Borrowed(Option<&'self str>, ast::Mutability), // &['lifetime] [mut]\n }\n \n /// A path, e.g. `::std::option::Option::<int>` (global). Has support\n@@ -91,7 +91,7 @@ pub enum Ty<'self> {\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n-    Borrowed(None, ast::m_imm)\n+    Borrowed(None, ast::MutImmutable)\n }\n pub fn borrowed<'r>(ty: ~Ty<'r>) -> Ty<'r> {\n     Ptr(ty, borrowed_ptrty())\n@@ -236,7 +236,7 @@ impl<'self> LifetimeBounds<'self> {\n \n \n pub fn get_explicit_self(cx: @ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (@expr, ast::explicit_self) {\n+    -> (@Expr, ast::explicit_self) {\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {"}, {"sha": "fc527d44b5332d5c3da41cac8e88257247e6959a", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, expr};\n+use ast::{MetaItem, item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -55,7 +55,7 @@ pub fn expand_deriving_zero(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n+fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let zero_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "adccf513ea93efc40d7a04b8e21e9ffbc35af845", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, NodeId, expr_, expr_mac, Ident, mac_invoc_tt};\n-use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n-use ast::{illegal_ctxt};\n+use ast::{Block, Crate, NodeId, Expr_, ExprMac, Ident, mac_invoc_tt};\n+use ast::{item_mac, Stmt_, StmtMac, StmtExpr, StmtSemi};\n+use ast::{ILLEGAL_CTXT};\n use ast;\n use ast_util::{new_rename, new_mark, resolve};\n use attr;\n@@ -31,15 +31,15 @@ use std::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n-                   e: &expr_,\n+                   e: &Expr_,\n                    s: Span,\n                    fld: @ast_fold,\n-                   orig: @fn(&expr_, Span, @ast_fold) -> (expr_, Span))\n-                -> (expr_, Span) {\n+                   orig: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span))\n+                -> (Expr_, Span) {\n     match *e {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n-        expr_mac(ref mac) => {\n+        ExprMac(ref mac) => {\n             match (*mac).node {\n                 // Token-tree macros:\n                 mac_invoc_tt(ref pth, ref tts) => {\n@@ -104,7 +104,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n \n         // Desugar expr_for_loop\n         // From: `for <src_pat> in <src_expr> <src_loop_block>`\n-        ast::expr_for_loop(src_pat, src_expr, ref src_loop_block) => {\n+        ast::ExprForLoop(src_pat, src_expr, ref src_loop_block) => {\n             let src_pat = src_pat.clone();\n             let src_expr = src_expr.clone();\n \n@@ -118,17 +118,17 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             let hi = s.hi;\n \n             pub fn mk_expr(cx: @ExtCtxt, span: Span,\n-                           node: expr_) -> @ast::expr {\n-                @ast::expr {\n+                           node: Expr_) -> @ast::Expr {\n+                @ast::Expr {\n                     id: cx.next_id(),\n                     node: node,\n                     span: span,\n                 }\n             }\n \n             fn mk_block(cx: @ExtCtxt,\n-                        stmts: &[@ast::stmt],\n-                        expr: Option<@ast::expr>,\n+                        stmts: &[@ast::Stmt],\n+                        expr: Option<@ast::Expr>,\n                         span: Span) -> ast::Block {\n                 ast::Block {\n                     view_items: ~[],\n@@ -186,33 +186,33 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 let local = @ast::Local {\n                     is_mutbl: false,\n                     ty: ty,\n-                    pat: @ast::pat {\n+                    pat: @ast::Pat {\n                         id: cx.next_id(),\n-                        node: ast::pat_ident(ast::bind_infer, local_path_1, None),\n+                        node: ast::PatIdent(ast::BindInfer, local_path_1, None),\n                         span: src_expr.span\n                     },\n                     init: Some(mk_expr(cx, src_expr.span,\n-                                       ast::expr_addr_of(ast::m_mutbl, src_expr))),\n+                                       ast::ExprAddrOf(ast::MutMutable, src_expr))),\n                     id: cx.next_id(),\n                     span: src_expr.span,\n                 };\n                 let e = @spanned(src_expr.span.lo,\n                                  src_expr.span.hi,\n-                                 ast::decl_local(local));\n-                @spanned(lo, hi, ast::stmt_decl(e, cx.next_id()))\n+                                 ast::DeclLocal(local));\n+                @spanned(lo, hi, ast::StmtDecl(e, cx.next_id()))\n             };\n \n             // `None => break;`\n             let none_arm = {\n-                let break_expr = mk_expr(cx, span, ast::expr_break(None));\n-                let break_stmt = @spanned(lo, hi, ast::stmt_expr(break_expr, cx.next_id()));\n+                let break_expr = mk_expr(cx, span, ast::ExprBreak(None));\n+                let break_stmt = @spanned(lo, hi, ast::StmtExpr(break_expr, cx.next_id()));\n                 let none_block = mk_block(cx, [break_stmt], None, span);\n-                let none_pat = @ast::pat {\n+                let none_pat = @ast::Pat {\n                     id: cx.next_id(),\n-                    node: ast::pat_ident(ast::bind_infer, none_path, None),\n+                    node: ast::PatIdent(ast::BindInfer, none_path, None),\n                     span: span\n                 };\n-                ast::arm {\n+                ast::Arm {\n                     pats: ~[none_pat],\n                     guard: None,\n                     body: none_block\n@@ -221,12 +221,12 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n \n             // `Some(<src_pat>) => <src_loop_block>`\n             let some_arm = {\n-                let pat = @ast::pat {\n+                let pat = @ast::Pat {\n                     id: cx.next_id(),\n-                    node: ast::pat_enum(some_path, Some(~[src_pat])),\n+                    node: ast::PatEnum(some_path, Some(~[src_pat])),\n                     span: src_pat.span\n                 };\n-                ast::arm {\n+                ast::Arm {\n                     pats: ~[pat],\n                     guard: None,\n                     body: src_loop_block\n@@ -235,27 +235,27 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n \n             // `match i.next() { ... }`\n             let match_stmt = {\n-                let local_expr = mk_expr(cx, span, ast::expr_path(local_path_2));\n+                let local_expr = mk_expr(cx, span, ast::ExprPath(local_path_2));\n                 let next_call_expr = mk_expr(cx, span,\n-                                             ast::expr_method_call(cx.next_id(),\n+                                             ast::ExprMethodCall(cx.next_id(),\n                                                                    local_expr, next_ident,\n                                                                    ~[], ~[], ast::NoSugar));\n-                let match_expr = mk_expr(cx, span, ast::expr_match(next_call_expr,\n+                let match_expr = mk_expr(cx, span, ast::ExprMatch(next_call_expr,\n                                                                    ~[none_arm, some_arm]));\n-                @spanned(lo, hi, ast::stmt_expr(match_expr, cx.next_id()))\n+                @spanned(lo, hi, ast::StmtExpr(match_expr, cx.next_id()))\n             };\n \n             // `loop { ... }`\n             let loop_block = {\n                 let loop_body_block = mk_block(cx, [match_stmt], None, span);\n-                let loop_body_expr = mk_expr(cx, span, ast::expr_loop(loop_body_block, None));\n-                let loop_body_stmt = @spanned(lo, hi, ast::stmt_expr(loop_body_expr, cx.next_id()));\n+                let loop_body_expr = mk_expr(cx, span, ast::ExprLoop(loop_body_block, None));\n+                let loop_body_stmt = @spanned(lo, hi, ast::StmtExpr(loop_body_expr, cx.next_id()));\n                 mk_block(cx, [iter_decl_stmt,\n                               loop_body_stmt],\n                          None, span)\n             };\n \n-            (ast::expr_block(loop_block), span)\n+            (ast::ExprBlock(loop_block), span)\n         }\n \n         _ => orig(e, s, fld)\n@@ -448,14 +448,14 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n-                   s: &stmt_,\n+                   s: &Stmt_,\n                    sp: Span,\n                    fld: @ast_fold,\n-                   orig: @fn(&stmt_, Span, @ast_fold)\n-                             -> (Option<stmt_>, Span))\n-                -> (Option<stmt_>, Span) {\n+                   orig: @fn(&Stmt_, Span, @ast_fold)\n+                             -> (Option<Stmt_>, Span))\n+                -> (Option<Stmt_>, Span) {\n     let (mac, pth, tts, semi) = match *s {\n-        stmt_mac(ref mac, semi) => {\n+        StmtMac(ref mac, semi) => {\n             match mac.node {\n                 mac_invoc_tt(ref pth, ref tts) => {\n                     ((*mac).clone(), pth, (*tts).clone(), semi)\n@@ -484,7 +484,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             });\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n-                    @codemap::Spanned { node: stmt_expr(e, cx.next_id()),\n+                    @codemap::Spanned { node: StmtExpr(e, cx.next_id()),\n                                     span: e.span},\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n@@ -515,7 +515,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     };\n \n     (match fully_expanded {\n-        stmt_expr(e, stmt_id) if semi => Some(stmt_semi(e, stmt_id)),\n+        StmtExpr(e, stmt_id) if semi => Some(StmtSemi(e, stmt_id)),\n         _ => { Some(fully_expanded) } /* might already have a semi */\n     }, sp)\n \n@@ -527,12 +527,12 @@ struct NewNameFinderContext {\n }\n \n impl Visitor<()> for NewNameFinderContext {\n-    fn visit_pat(&mut self, pattern: @ast::pat, _: ()) {\n+    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n         match *pattern {\n             // we found a pat_ident!\n-            ast::pat {\n+            ast::Pat {\n                 id: _,\n-                node: ast::pat_ident(_, ref path, ref inner),\n+                node: ast::PatIdent(_, ref path, ref inner),\n                 span: _\n             } => {\n                 match path {\n@@ -589,23 +589,23 @@ impl Visitor<()> for NewNameFinderContext {\n         visit::walk_block(self, block, ())\n     }\n \n-    fn visit_stmt(&mut self, stmt: @ast::stmt, _: ()) {\n+    fn visit_stmt(&mut self, stmt: @ast::Stmt, _: ()) {\n         visit::walk_stmt(self, stmt, ())\n     }\n \n-    fn visit_arm(&mut self, arm: &ast::arm, _: ()) {\n+    fn visit_arm(&mut self, arm: &ast::Arm, _: ()) {\n         visit::walk_arm(self, arm, ())\n     }\n \n-    fn visit_decl(&mut self, decl: @ast::decl, _: ()) {\n+    fn visit_decl(&mut self, decl: @ast::Decl, _: ()) {\n         visit::walk_decl(self, decl, ())\n     }\n \n-    fn visit_expr(&mut self, expr: @ast::expr, _: ()) {\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n         visit::walk_expr(self, expr, ())\n     }\n \n-    fn visit_expr_post(&mut self, _: @ast::expr, _: ()) {\n+    fn visit_expr_post(&mut self, _: @ast::Expr, _: ()) {\n         // Empty!\n     }\n \n@@ -714,7 +714,7 @@ fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n }\n \n // perform a bunch of renames\n-fn apply_pending_renames(folder : @ast_fold, stmt : ast::stmt) -> @ast::stmt {\n+fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n     match folder.fold_stmt(&stmt) {\n         Some(s) => s,\n         None => fail!(fmt!(\"renaming of stmt produced None\"))\n@@ -1182,7 +1182,7 @@ pub fn new_ident_resolver() ->\n     |id : ast::Ident|\n     ast::Ident {\n         name : resolve(id),\n-        ctxt : illegal_ctxt\n+        ctxt : ILLEGAL_CTXT\n     }\n }\n \n@@ -1191,7 +1191,7 @@ pub fn new_ident_resolver() ->\n mod test {\n     use super::*;\n     use ast;\n-    use ast::{Attribute_, AttrOuter, MetaWord, empty_ctxt};\n+    use ast::{Attribute_, AttrOuter, MetaWord, EMPTY_CTXT};\n     use codemap;\n     use codemap::Spanned;\n     use parse;\n@@ -1304,7 +1304,7 @@ mod test {\n         };\n         let a_name = intern(\"a\");\n         let a2_name = intern(\"a2\");\n-        let renamer = new_ident_renamer(ast::Ident{name:a_name,ctxt:empty_ctxt},\n+        let renamer = new_ident_renamer(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n         let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n         let resolver = new_ident_resolver();"}, {"sha": "9adb02ecc987f3c5fe242eee968c577437c47196", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -48,24 +48,24 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n // expressions.  Also: Cleanup the naming of these functions.\n // Note: Moved many of the common ones to build.rs --kevina\n fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n-                  pieces: ~[Piece], args: ~[@ast::expr])\n-   -> @ast::expr {\n+                  pieces: ~[Piece], args: ~[@ast::Expr])\n+   -> @ast::Expr {\n     fn make_path_vec(ident: &str) -> ~[ast::Ident] {\n         return ~[str_to_ident(\"std\"),\n                  str_to_ident(\"unstable\"),\n                  str_to_ident(\"extfmt\"),\n                  str_to_ident(\"rt\"),\n                  str_to_ident(ident)];\n     }\n-    fn make_rt_path_expr(cx: @ExtCtxt, sp: Span, nm: &str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: @ExtCtxt, sp: Span, nm: &str) -> @ast::Expr {\n         let path = make_path_vec(nm);\n         cx.expr_path(cx.path_global(sp, path))\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: @ExtCtxt, sp: Span, cnv: &Conv) -> @ast::expr {\n-        fn make_flags(cx: @ExtCtxt, sp: Span, flags: &[Flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ExtCtxt, sp: Span, cnv: &Conv) -> @ast::Expr {\n+        fn make_flags(cx: @ExtCtxt, sp: Span, flags: &[Flag]) -> @ast::Expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for f in flags.iter() {\n                 let fstr = match *f {\n@@ -75,12 +75,12 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n                   FlagSignAlways => \"flag_sign_always\",\n                   FlagAlternate => \"flag_alternate\"\n                 };\n-                tmp_expr = cx.expr_binary(sp, ast::bitor, tmp_expr,\n+                tmp_expr = cx.expr_binary(sp, ast::BiBitOr, tmp_expr,\n                                           make_rt_path_expr(cx, sp, fstr));\n             }\n             return tmp_expr;\n         }\n-        fn make_count(cx: @ExtCtxt, sp: Span, cnt: Count) -> @ast::expr {\n+        fn make_count(cx: @ExtCtxt, sp: Span, cnt: Count) -> @ast::Expr {\n             match cnt {\n               CountImplied => {\n                 return make_rt_path_expr(cx, sp, \"CountImplied\");\n@@ -94,7 +94,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n               _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n         }\n-        fn make_ty(cx: @ExtCtxt, sp: Span, t: Ty) -> @ast::expr {\n+        fn make_ty(cx: @ExtCtxt, sp: Span, t: Ty) -> @ast::Expr {\n             let rt_type = match t {\n               TyHex(c) => match c {\n                 CaseUpper =>  \"TyHexUpper\",\n@@ -106,9 +106,9 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n             };\n             return make_rt_path_expr(cx, sp, rt_type);\n         }\n-        fn make_conv_struct(cx: @ExtCtxt, sp: Span, flags_expr: @ast::expr,\n-                         width_expr: @ast::expr, precision_expr: @ast::expr,\n-                         ty_expr: @ast::expr) -> @ast::expr {\n+        fn make_conv_struct(cx: @ExtCtxt, sp: Span, flags_expr: @ast::Expr,\n+                         width_expr: @ast::Expr, precision_expr: @ast::Expr,\n+                         ty_expr: @ast::Expr) -> @ast::Expr {\n             cx.expr_struct(\n                 sp,\n                 cx.path_global(sp, make_path_vec(\"Conv\")),\n@@ -128,7 +128,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n                          rt_conv_precision, rt_conv_ty)\n     }\n     fn make_conv_call(cx: @ExtCtxt, sp: Span, conv_type: &str, cnv: &Conv,\n-                      arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n+                      arg: @ast::Expr, buf: @ast::Expr) -> @ast::Expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n@@ -137,7 +137,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n     }\n \n     fn make_new_conv(cx: @ExtCtxt, sp: Span, cnv: &Conv,\n-                     arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n+                     arg: @ast::Expr, buf: @ast::Expr) -> @ast::Expr {\n         fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {\n               TyInt(s) => match s {"}, {"sha": "ddddd44c7f1e02350795f42ba4fb6b4619209e23", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -34,14 +34,14 @@ struct Context {\n \n     // Parsed argument expressions and the types that we've found so far for\n     // them.\n-    args: ~[@ast::expr],\n+    args: ~[@ast::Expr],\n     arg_types: ~[Option<ArgumentType>],\n     // Parsed named expressions and the types that we've found for them so far\n-    names: HashMap<@str, @ast::expr>,\n+    names: HashMap<@str, @ast::Expr>,\n     name_types: HashMap<@str, ArgumentType>,\n \n     // Collection of the compiled `rt::Piece` structures\n-    pieces: ~[@ast::expr],\n+    pieces: ~[@ast::Expr],\n     name_positions: HashMap<@str, uint>,\n     method_statics: ~[@ast::item],\n \n@@ -55,8 +55,8 @@ impl Context {\n     /// there's a parse error so we can continue parsing other fmt! expressions.\n     fn parse_args(&mut self, sp: Span,\n                   leading_expr: bool,\n-                  tts: &[ast::token_tree]) -> (Option<@ast::expr>,\n-                                               Option<@ast::expr>) {\n+                  tts: &[ast::token_tree]) -> (Option<@ast::Expr>,\n+                                               Option<@ast::Expr>) {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                              self.ecx.cfg(),\n                                              tts.to_owned());\n@@ -327,7 +327,7 @@ impl Context {\n     }\n \n     /// Translate a `parse::Piece` to a static `rt::Piece`\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::expr {\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::Expr {\n         let sp = self.fmtsp;\n         let parsepath = |s: &str| {\n             ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n@@ -345,7 +345,7 @@ impl Context {\n             let p = self.ecx.path(sp, ~[self.ecx.ident_of(\"None\")]);\n             self.ecx.expr_path(p)\n         };\n-        let some = |e: @ast::expr| {\n+        let some = |e: @ast::Expr| {\n             self.ecx.expr_call_ident(sp, self.ecx.ident_of(\"Some\"), ~[e])\n         };\n         let trans_count = |c: parse::Count| {\n@@ -444,7 +444,7 @@ impl Context {\n                 Some(life),\n                 ~[]\n             ), None);\n-            let st = ast::item_static(ty, ast::m_imm, method);\n+            let st = ast::item_static(ty, ast::MutImmutable, method);\n             let static_name = self.ecx.ident_of(fmt!(\"__static_method_%u\",\n                                                      self.method_statics.len()));\n             // Flag these statics as `address_insignificant` so LLVM can\n@@ -542,16 +542,16 @@ impl Context {\n \n     /// Actually builds the expression which the ifmt! block will be expanded\n     /// to\n-    fn to_expr(&self, extra: Option<@ast::expr>, f: &str) -> @ast::expr {\n+    fn to_expr(&self, extra: Option<@ast::Expr>, f: &str) -> @ast::Expr {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n \n         // First, declare all of our methods that are statics\n         for &method in self.method_statics.iter() {\n-            let decl = respan(self.fmtsp, ast::decl_item(method));\n+            let decl = respan(self.fmtsp, ast::DeclItem(method));\n             lets.push(@respan(self.fmtsp,\n-                              ast::stmt_decl(@decl, self.ecx.next_id())));\n+                              ast::StmtDecl(@decl, self.ecx.next_id())));\n         }\n \n         // Next, build up the static array which will become our precompiled\n@@ -570,19 +570,19 @@ impl Context {\n                     Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n                     ~[]\n                 ), None),\n-                ast::m_imm\n+                ast::MutImmutable\n             ),\n             self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n         );\n         let ty = self.ecx.ty(self.fmtsp, ty);\n-        let st = ast::item_static(ty, ast::m_imm, fmt);\n+        let st = ast::item_static(ty, ast::MutImmutable, fmt);\n         let static_name = self.ecx.ident_of(\"__static_fmtstr\");\n         // see above comment for `address_insignificant` and why we do it\n         let unnamed = self.ecx.meta_word(self.fmtsp, @\"address_insignificant\");\n         let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n         let item = self.ecx.item(self.fmtsp, static_name, ~[unnamed], st);\n-        let decl = respan(self.fmtsp, ast::decl_item(item));\n-        lets.push(@respan(self.fmtsp, ast::stmt_decl(@decl, self.ecx.next_id())));\n+        let decl = respan(self.fmtsp, ast::DeclItem(item));\n+        lets.push(@respan(self.fmtsp, ast::StmtDecl(@decl, self.ecx.next_id())));\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -637,7 +637,7 @@ impl Context {\n     }\n \n     fn format_arg(&self, sp: Span, arg: Either<uint, @str>,\n-                  ident: ast::Ident) -> @ast::expr {\n+                  ident: ast::Ident) -> @ast::Expr {\n         let ty = match arg {\n             Left(i) => self.arg_types[i].unwrap(),\n             Right(s) => *self.name_types.get(&s)"}, {"sha": "adc246ab89aafd6221b0aada1a892477aa556a14", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -29,9 +29,9 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n             get_ident_interner()));\n \n     //trivial expression\n-    MRExpr(@ast::expr {\n+    MRExpr(@ast::Expr {\n         id: cx.next_id(),\n-        node: ast::expr_lit(@codemap::Spanned {\n+        node: ast::ExprLit(@codemap::Spanned {\n             node: ast::lit_nil,\n             span: sp\n         }),"}, {"sha": "8d43872e9c13bcb44cc944cb81131d269c3f0ae3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -104,7 +104,7 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::expr {\n+    impl ToSource for @ast::Expr {\n         fn to_source(&self) -> @str {\n             pprust::expr_to_str(*self, get_ident_interner()).to_managed()\n         }\n@@ -222,7 +222,7 @@ pub mod rt {\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_self!(&'self [ast::Ty])\n     impl_to_tokens!(Generics)\n-    impl_to_tokens!(@ast::expr)\n+    impl_to_tokens!(@ast::Expr)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens_self!(&'self str)\n     impl_to_tokens!(int)\n@@ -238,8 +238,8 @@ pub mod rt {\n \n     pub trait ExtParseUtils {\n         fn parse_item(&self, s: @str) -> @ast::item;\n-        fn parse_expr(&self, s: @str) -> @ast::expr;\n-        fn parse_stmt(&self, s: @str) -> @ast::stmt;\n+        fn parse_expr(&self, s: @str) -> @ast::Expr;\n+        fn parse_stmt(&self, s: @str) -> @ast::Stmt;\n         fn parse_tts(&self, s: @str) -> ~[ast::token_tree];\n     }\n \n@@ -261,7 +261,7 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: @str) -> @ast::stmt {\n+        fn parse_stmt(&self, s: @str) -> @ast::Stmt {\n             parse::parse_stmt_from_source_str(\n                 @\"<quote expansion>\",\n                 s,\n@@ -270,7 +270,7 @@ pub mod rt {\n                 self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: @str) -> @ast::expr {\n+        fn parse_expr(&self, s: @str) -> @ast::Expr {\n             parse::parse_expr_from_source_str(\n                 @\"<quote expansion>\",\n                 s,\n@@ -343,21 +343,21 @@ fn id_ext(str: &str) -> ast::Ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::expr {\n+fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n     let e_str = cx.expr_str(sp, cx.str_of(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n                         ~[e_str])\n }\n \n-fn mk_bytepos(cx: @ExtCtxt, sp: Span, bpos: BytePos) -> @ast::expr {\n+fn mk_bytepos(cx: @ExtCtxt, sp: Span, bpos: BytePos) -> @ast::Expr {\n     let path = id_ext(\"BytePos\");\n     let arg = cx.expr_uint(sp, bpos.to_uint());\n     cx.expr_call_ident(sp, path, ~[arg])\n }\n \n-fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::expr {\n+fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::Expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -373,7 +373,7 @@ fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::expr {\n     cx.expr_ident(sp, id_ext(name))\n }\n \n-fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::expr {\n+fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -515,7 +515,7 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::expr {\n \n \n fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n-    -> ~[@ast::stmt] {\n+    -> ~[@ast::Stmt] {\n \n     match *tt {\n \n@@ -557,7 +557,7 @@ fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n }\n \n fn mk_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n-    -> ~[@ast::stmt] {\n+    -> ~[@ast::Stmt] {\n     let mut ss = ~[];\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n@@ -567,7 +567,7 @@ fn mk_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n \n fn expand_tts(cx: @ExtCtxt,\n               sp: Span,\n-              tts: &[ast::token_tree]) -> (@ast::expr, @ast::expr) {\n+              tts: &[ast::token_tree]) -> (@ast::Expr, @ast::Expr) {\n \n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n@@ -640,8 +640,8 @@ fn expand_tts(cx: @ExtCtxt,\n \n fn expand_wrapper(cx: @ExtCtxt,\n                   sp: Span,\n-                  cx_expr: @ast::expr,\n-                  expr: @ast::expr) -> @ast::expr {\n+                  cx_expr: @ast::Expr,\n+                  expr: @ast::Expr) -> @ast::Expr {\n     let uses = ~[ cx.view_use_glob(sp, ast::public,\n                                    ids_ext(~[~\"syntax\",\n                                              ~\"ext\",\n@@ -656,8 +656,8 @@ fn expand_wrapper(cx: @ExtCtxt,\n fn expand_parse_call(cx: @ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: ~[@ast::expr],\n-                     tts: &[ast::token_tree]) -> @ast::expr {\n+                     arg_exprs: ~[@ast::Expr],\n+                     tts: &[ast::token_tree]) -> @ast::Expr {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call("}, {"sha": "e76ade0dc3dae78fb774cb0111316570d5b5df09", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -105,7 +105,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n-        let u8_exprs: ~[@ast::expr] = src.iter().map(|char| cx.expr_u8(sp, *char)).collect();\n+        let u8_exprs: ~[@ast::Expr] = src.iter().map(|char| cx.expr_u8(sp, *char)).collect();\n         base::MRExpr(cx.expr_vec(sp, u8_exprs))\n       }\n       result::Err(ref e) => {"}, {"sha": "7aa0f3abe87cd3bb39ff588b5b0f9349cc8d720d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -23,19 +23,19 @@ pub trait ast_fold {\n     fn fold_item_underscore(@self, &item_) -> item_;\n     fn fold_method(@self, @method) -> @method;\n     fn fold_block(@self, &Block) -> Block;\n-    fn fold_stmt(@self, &stmt) -> Option<@stmt>;\n-    fn fold_arm(@self, &arm) -> arm;\n-    fn fold_pat(@self, @pat) -> @pat;\n-    fn fold_decl(@self, @decl) -> Option<@decl>;\n-    fn fold_expr(@self, @expr) -> @expr;\n+    fn fold_stmt(@self, &Stmt) -> Option<@Stmt>;\n+    fn fold_arm(@self, &Arm) -> Arm;\n+    fn fold_pat(@self, @Pat) -> @Pat;\n+    fn fold_decl(@self, @Decl) -> Option<@Decl>;\n+    fn fold_expr(@self, @Expr) -> @Expr;\n     fn fold_ty(@self, &Ty) -> Ty;\n     fn fold_mod(@self, &_mod) -> _mod;\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n     fn fold_ident(@self, Ident) -> Ident;\n     fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @Local) -> @Local;\n-    fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n+    fn map_exprs(@self, @fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr];\n     fn new_id(@self, NodeId) -> NodeId;\n     fn new_span(@self, Span) -> Span;\n }\n@@ -52,19 +52,19 @@ pub struct AstFoldFns {\n     fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n     fold_method: @fn(@method, @ast_fold) -> @method,\n     fold_block: @fn(&Block, @ast_fold) -> Block,\n-    fold_stmt: @fn(&stmt_, Span, @ast_fold) -> (Option<stmt_>, Span),\n-    fold_arm: @fn(&arm, @ast_fold) -> arm,\n-    fold_pat: @fn(&pat_, Span, @ast_fold) -> (pat_, Span),\n-    fold_decl: @fn(&decl_, Span, @ast_fold) -> (Option<decl_>, Span),\n-    fold_expr: @fn(&expr_, Span, @ast_fold) -> (expr_, Span),\n+    fold_stmt: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span),\n+    fold_arm: @fn(&Arm, @ast_fold) -> Arm,\n+    fold_pat: @fn(&Pat_, Span, @ast_fold) -> (Pat_, Span),\n+    fold_decl: @fn(&Decl_, Span, @ast_fold) -> (Option<Decl_>, Span),\n+    fold_expr: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span),\n     fold_ty: @fn(&ty_, Span, @ast_fold) -> (ty_, Span),\n     fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n     fold_variant: @fn(&variant_, Span, @ast_fold) -> (variant_, Span),\n     fold_ident: @fn(Ident, @ast_fold) -> Ident,\n     fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(@Local, @ast_fold) -> @Local,\n-    map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n+    map_exprs: @fn(@fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr],\n     new_id: @fn(NodeId) -> NodeId,\n     new_span: @fn(Span) -> Span\n }\n@@ -395,69 +395,69 @@ pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n     }\n }\n \n-fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> Option<stmt_> {\n+fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n     let fold_mac = |x| fold_mac_(x, fld);\n     match *s {\n-        stmt_decl(d, nid) => {\n+        StmtDecl(d, nid) => {\n             match fld.fold_decl(d) {\n-                Some(d) => Some(stmt_decl(d, fld.new_id(nid))),\n+                Some(d) => Some(StmtDecl(d, fld.new_id(nid))),\n                 None => None,\n             }\n         }\n-        stmt_expr(e, nid) => {\n-            Some(stmt_expr(fld.fold_expr(e), fld.new_id(nid)))\n+        StmtExpr(e, nid) => {\n+            Some(StmtExpr(fld.fold_expr(e), fld.new_id(nid)))\n         }\n-        stmt_semi(e, nid) => {\n-            Some(stmt_semi(fld.fold_expr(e), fld.new_id(nid)))\n+        StmtSemi(e, nid) => {\n+            Some(StmtSemi(fld.fold_expr(e), fld.new_id(nid)))\n         }\n-        stmt_mac(ref mac, semi) => Some(stmt_mac(fold_mac(mac), semi))\n+        StmtMac(ref mac, semi) => Some(StmtMac(fold_mac(mac), semi))\n     }\n }\n \n-fn noop_fold_arm(a: &arm, fld: @ast_fold) -> arm {\n-    arm {\n+fn noop_fold_arm(a: &Arm, fld: @ast_fold) -> Arm {\n+    Arm {\n         pats: a.pats.map(|x| fld.fold_pat(*x)),\n         guard: a.guard.map_move(|x| fld.fold_expr(x)),\n         body: fld.fold_block(&a.body),\n     }\n }\n \n-pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n+pub fn noop_fold_pat(p: &Pat_, fld: @ast_fold) -> Pat_ {\n     match *p {\n-        pat_wild => pat_wild,\n-        pat_ident(binding_mode, ref pth, ref sub) => {\n-            pat_ident(\n+        PatWild => PatWild,\n+        PatIdent(binding_mode, ref pth, ref sub) => {\n+            PatIdent(\n                 binding_mode,\n                 fld.fold_path(pth),\n                 sub.map_move(|x| fld.fold_pat(x))\n             )\n         }\n-        pat_lit(e) => pat_lit(fld.fold_expr(e)),\n-        pat_enum(ref pth, ref pats) => {\n-            pat_enum(\n+        PatLit(e) => PatLit(fld.fold_expr(e)),\n+        PatEnum(ref pth, ref pats) => {\n+            PatEnum(\n                 fld.fold_path(pth),\n                 pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n             )\n         }\n-        pat_struct(ref pth, ref fields, etc) => {\n+        PatStruct(ref pth, ref fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n-                ast::field_pat {\n+                ast::FieldPat {\n                     ident: f.ident,\n                     pat: fld.fold_pat(f.pat)\n                 }\n             };\n-            pat_struct(pth_, fs, etc)\n-        }\n-        pat_tup(ref elts) => pat_tup(elts.map(|x| fld.fold_pat(*x))),\n-        pat_box(inner) => pat_box(fld.fold_pat(inner)),\n-        pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n-        pat_region(inner) => pat_region(fld.fold_pat(inner)),\n-        pat_range(e1, e2) => {\n-            pat_range(fld.fold_expr(e1), fld.fold_expr(e2))\n+            PatStruct(pth_, fs, etc)\n+        }\n+        PatTup(ref elts) => PatTup(elts.map(|x| fld.fold_pat(*x))),\n+        PatBox(inner) => PatBox(fld.fold_pat(inner)),\n+        PatUniq(inner) => PatUniq(fld.fold_pat(inner)),\n+        PatRegion(inner) => PatRegion(fld.fold_pat(inner)),\n+        PatRange(e1, e2) => {\n+            PatRange(fld.fold_expr(e1), fld.fold_expr(e2))\n         },\n-        pat_vec(ref before, ref slice, ref after) => {\n-            pat_vec(\n+        PatVec(ref before, ref slice, ref after) => {\n+            PatVec(\n                 before.map(|x| fld.fold_pat(*x)),\n                 slice.map_move(|x| fld.fold_pat(x)),\n                 after.map(|x| fld.fold_pat(*x))\n@@ -466,12 +466,12 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n     }\n }\n \n-fn noop_fold_decl(d: &decl_, fld: @ast_fold) -> Option<decl_> {\n+fn noop_fold_decl(d: &Decl_, fld: @ast_fold) -> Option<Decl_> {\n     match *d {\n-        decl_local(ref l) => Some(decl_local(fld.fold_local(*l))),\n-        decl_item(it) => {\n+        DeclLocal(ref l) => Some(DeclLocal(fld.fold_local(*l))),\n+        DeclItem(it) => {\n             match fld.fold_item(it) {\n-                Some(it_folded) => Some(decl_item(it_folded)),\n+                Some(it_folded) => Some(DeclItem(it_folded)),\n                 None => None,\n             }\n         }\n@@ -486,7 +486,7 @@ pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n     result\n }\n \n-pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n+pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n     fn fold_field_(field: Field, fld: @ast_fold) -> Field {\n         ast::Field {\n             ident: fld.fold_ident(field.ident),\n@@ -499,25 +499,25 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n \n     match *e {\n-        expr_vstore(e, v) => {\n-            expr_vstore(fld.fold_expr(e), v)\n+        ExprVstore(e, v) => {\n+            ExprVstore(fld.fold_expr(e), v)\n         }\n-        expr_vec(ref exprs, mutt) => {\n-            expr_vec(fld.map_exprs(|x| fld.fold_expr(x), *exprs), mutt)\n+        ExprVec(ref exprs, mutt) => {\n+            ExprVec(fld.map_exprs(|x| fld.fold_expr(x), *exprs), mutt)\n         }\n-        expr_repeat(expr, count, mutt) => {\n-            expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt)\n+        ExprRepeat(expr, count, mutt) => {\n+            ExprRepeat(fld.fold_expr(expr), fld.fold_expr(count), mutt)\n         }\n-        expr_tup(ref elts) => expr_tup(elts.map(|x| fld.fold_expr(*x))),\n-        expr_call(f, ref args, blk) => {\n-            expr_call(\n+        ExprTup(ref elts) => ExprTup(elts.map(|x| fld.fold_expr(*x))),\n+        ExprCall(f, ref args, blk) => {\n+            ExprCall(\n                 fld.fold_expr(f),\n                 fld.map_exprs(|x| fld.fold_expr(x), *args),\n                 blk\n             )\n         }\n-        expr_method_call(callee_id, f, i, ref tps, ref args, blk) => {\n-            expr_method_call(\n+        ExprMethodCall(callee_id, f, i, ref tps, ref args, blk) => {\n+            ExprMethodCall(\n                 fld.new_id(callee_id),\n                 fld.fold_expr(f),\n                 fld.fold_ident(i),\n@@ -526,118 +526,118 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 blk\n             )\n         }\n-        expr_binary(callee_id, binop, lhs, rhs) => {\n-            expr_binary(\n+        ExprBinary(callee_id, binop, lhs, rhs) => {\n+            ExprBinary(\n                 fld.new_id(callee_id),\n                 binop,\n                 fld.fold_expr(lhs),\n                 fld.fold_expr(rhs)\n             )\n         }\n-        expr_unary(callee_id, binop, ohs) => {\n-            expr_unary(\n+        ExprUnary(callee_id, binop, ohs) => {\n+            ExprUnary(\n                 fld.new_id(callee_id),\n                 binop,\n                 fld.fold_expr(ohs)\n             )\n         }\n-        expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n-        expr_lit(_) => (*e).clone(),\n-        expr_cast(expr, ref ty) => {\n-            expr_cast(fld.fold_expr(expr), (*ty).clone())\n+        ExprDoBody(f) => ExprDoBody(fld.fold_expr(f)),\n+        ExprLit(_) => (*e).clone(),\n+        ExprCast(expr, ref ty) => {\n+            ExprCast(fld.fold_expr(expr), (*ty).clone())\n         }\n-        expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n-        expr_if(cond, ref tr, fl) => {\n-            expr_if(\n+        ExprAddrOf(m, ohs) => ExprAddrOf(m, fld.fold_expr(ohs)),\n+        ExprIf(cond, ref tr, fl) => {\n+            ExprIf(\n                 fld.fold_expr(cond),\n                 fld.fold_block(tr),\n                 fl.map_move(|x| fld.fold_expr(x))\n             )\n         }\n-        expr_while(cond, ref body) => {\n-            expr_while(fld.fold_expr(cond), fld.fold_block(body))\n+        ExprWhile(cond, ref body) => {\n+            ExprWhile(fld.fold_expr(cond), fld.fold_block(body))\n         }\n-        expr_for_loop(pat, iter, ref body) => {\n-            expr_for_loop(fld.fold_pat(pat),\n+        ExprForLoop(pat, iter, ref body) => {\n+            ExprForLoop(fld.fold_pat(pat),\n                           fld.fold_expr(iter),\n                           fld.fold_block(body))\n         }\n-        expr_loop(ref body, opt_ident) => {\n-            expr_loop(\n+        ExprLoop(ref body, opt_ident) => {\n+            ExprLoop(\n                 fld.fold_block(body),\n                 opt_ident.map_move(|x| fld.fold_ident(x))\n             )\n         }\n-        expr_match(expr, ref arms) => {\n-            expr_match(\n+        ExprMatch(expr, ref arms) => {\n+            ExprMatch(\n                 fld.fold_expr(expr),\n                 arms.map(|x| fld.fold_arm(x))\n             )\n         }\n-        expr_fn_block(ref decl, ref body) => {\n-            expr_fn_block(\n+        ExprFnBlock(ref decl, ref body) => {\n+            ExprFnBlock(\n                 fold_fn_decl(decl, fld),\n                 fld.fold_block(body)\n             )\n         }\n-        expr_block(ref blk) => expr_block(fld.fold_block(blk)),\n-        expr_assign(el, er) => {\n-            expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n+        ExprBlock(ref blk) => ExprBlock(fld.fold_block(blk)),\n+        ExprAssign(el, er) => {\n+            ExprAssign(fld.fold_expr(el), fld.fold_expr(er))\n         }\n-        expr_assign_op(callee_id, op, el, er) => {\n-            expr_assign_op(\n+        ExprAssignOp(callee_id, op, el, er) => {\n+            ExprAssignOp(\n                 fld.new_id(callee_id),\n                 op,\n                 fld.fold_expr(el),\n                 fld.fold_expr(er)\n             )\n         }\n-        expr_field(el, id, ref tys) => {\n-            expr_field(\n+        ExprField(el, id, ref tys) => {\n+            ExprField(\n                 fld.fold_expr(el), fld.fold_ident(id),\n                 tys.map(|x| fld.fold_ty(x))\n             )\n         }\n-        expr_index(callee_id, el, er) => {\n-            expr_index(\n+        ExprIndex(callee_id, el, er) => {\n+            ExprIndex(\n                 fld.new_id(callee_id),\n                 fld.fold_expr(el),\n                 fld.fold_expr(er)\n             )\n         }\n-        expr_path(ref pth) => expr_path(fld.fold_path(pth)),\n-        expr_self => expr_self,\n-        expr_break(ref opt_ident) => {\n-            expr_break(opt_ident.map_move(|x| fld.fold_ident(x)))\n+        ExprPath(ref pth) => ExprPath(fld.fold_path(pth)),\n+        ExprSelf => ExprSelf,\n+        ExprBreak(ref opt_ident) => {\n+            ExprBreak(opt_ident.map_move(|x| fld.fold_ident(x)))\n         }\n-        expr_again(ref opt_ident) => {\n-            expr_again(opt_ident.map_move(|x| fld.fold_ident(x)))\n+        ExprAgain(ref opt_ident) => {\n+            ExprAgain(opt_ident.map_move(|x| fld.fold_ident(x)))\n         }\n-        expr_ret(ref e) => {\n-            expr_ret(e.map_move(|x| fld.fold_expr(x)))\n+        ExprRet(ref e) => {\n+            ExprRet(e.map_move(|x| fld.fold_expr(x)))\n         }\n-        expr_log(lv, e) => {\n-            expr_log(\n+        ExprLog(lv, e) => {\n+            ExprLog(\n                 fld.fold_expr(lv),\n                 fld.fold_expr(e)\n             )\n         }\n-        expr_inline_asm(ref a) => {\n-            expr_inline_asm(inline_asm {\n+        ExprInlineAsm(ref a) => {\n+            ExprInlineAsm(inline_asm {\n                 inputs: a.inputs.map(|&(c, input)| (c, fld.fold_expr(input))),\n                 outputs: a.outputs.map(|&(c, out)| (c, fld.fold_expr(out))),\n                 .. (*a).clone()\n             })\n         }\n-        expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n-        expr_struct(ref path, ref fields, maybe_expr) => {\n-            expr_struct(\n+        ExprMac(ref mac) => ExprMac(fold_mac(mac)),\n+        ExprStruct(ref path, ref fields, maybe_expr) => {\n+            ExprStruct(\n                 fld.fold_path(path),\n                 fields.map(|x| fold_field(*x)),\n                 maybe_expr.map_move(|x| fld.fold_expr(x))\n             )\n         },\n-        expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n+        ExprParen(ex) => ExprParen(fld.fold_expr(ex))\n     }\n }\n \n@@ -787,7 +787,7 @@ fn noop_fold_local(l: @Local, fld: @ast_fold) -> @Local {\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: @fn(@expr) -> @expr, es: &[@expr]) -> ~[@expr] {\n+fn noop_map_exprs(f: @fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n     es.map(|x| f(*x))\n }\n \n@@ -862,34 +862,34 @@ impl ast_fold for AstFoldFns {\n     fn fold_block(@self, x: &Block) -> Block {\n         (self.fold_block)(x, self as @ast_fold)\n     }\n-    fn fold_stmt(@self, x: &stmt) -> Option<@stmt> {\n+    fn fold_stmt(@self, x: &Stmt) -> Option<@Stmt> {\n         let (n_opt, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n         match n_opt {\n             Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n             None => None,\n         }\n     }\n-    fn fold_arm(@self, x: &arm) -> arm {\n+    fn fold_arm(@self, x: &Arm) -> Arm {\n         (self.fold_arm)(x, self as @ast_fold)\n     }\n-    fn fold_pat(@self, x: @pat) -> @pat {\n+    fn fold_pat(@self, x: @Pat) -> @Pat {\n         let (n, s) =  (self.fold_pat)(&x.node, x.span, self as @ast_fold);\n-        @pat {\n+        @Pat {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_decl(@self, x: @decl) -> Option<@decl> {\n+    fn fold_decl(@self, x: @Decl) -> Option<@Decl> {\n         let (n_opt, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n         match n_opt {\n             Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n             None => None,\n         }\n     }\n-    fn fold_expr(@self, x: @expr) -> @expr {\n+    fn fold_expr(@self, x: @Expr) -> @Expr {\n         let (n, s) = (self.fold_expr)(&x.node, x.span, self as @ast_fold);\n-        @expr {\n+        @Expr {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n@@ -923,9 +923,9 @@ impl ast_fold for AstFoldFns {\n         (self.fold_local)(x, self as @ast_fold)\n     }\n     fn map_exprs(@self,\n-                 f: @fn(@expr) -> @expr,\n-                 e: &[@expr])\n-              -> ~[@expr] {\n+                 f: @fn(@Expr) -> @Expr,\n+                 e: &[@Expr])\n+              -> ~[@Expr] {\n         (self.map_exprs)(f, e)\n     }\n     fn new_id(@self, node_id: ast::NodeId) -> NodeId {"}, {"sha": "e9d7b5c4a0dd1a9b0f1bc4750f414d8fa201f818", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -77,12 +77,12 @@ pub struct Visitor<E> {\n     visit_item: @fn(@item, (E, vt<E>)),\n     visit_local: @fn(@Local, (E, vt<E>)),\n     visit_block: @fn(&Block, (E, vt<E>)),\n-    visit_stmt: @fn(@stmt, (E, vt<E>)),\n-    visit_arm: @fn(&arm, (E, vt<E>)),\n-    visit_pat: @fn(@pat, (E, vt<E>)),\n-    visit_decl: @fn(@decl, (E, vt<E>)),\n-    visit_expr: @fn(@expr, (E, vt<E>)),\n-    visit_expr_post: @fn(@expr, (E, vt<E>)),\n+    visit_stmt: @fn(@Stmt, (E, vt<E>)),\n+    visit_arm: @fn(&Arm, (E, vt<E>)),\n+    visit_pat: @fn(@Pat, (E, vt<E>)),\n+    visit_decl: @fn(@Decl, (E, vt<E>)),\n+    visit_expr: @fn(@Expr, (E, vt<E>)),\n+    visit_expr_post: @fn(@Expr, (E, vt<E>)),\n     visit_ty: @fn(&Ty, (E, vt<E>)),\n     visit_generics: @fn(&Generics, (E, vt<E>)),\n     visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId, (E, vt<E>)),\n@@ -294,43 +294,43 @@ pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {\n+pub fn visit_pat<E:Clone>(p: &Pat, (e, v): (E, vt<E>)) {\n     match p.node {\n-        pat_enum(ref path, ref children) => {\n+        PatEnum(ref path, ref children) => {\n             visit_path(path, (e.clone(), v));\n             for children in children.iter() {\n                 for child in children.iter() {\n                     (v.visit_pat)(*child, (e.clone(), v));\n                 }\n             }\n         }\n-        pat_struct(ref path, ref fields, _) => {\n+        PatStruct(ref path, ref fields, _) => {\n             visit_path(path, (e.clone(), v));\n             for f in fields.iter() {\n                 (v.visit_pat)(f.pat, (e.clone(), v));\n             }\n         }\n-        pat_tup(ref elts) => {\n+        PatTup(ref elts) => {\n             for elt in elts.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v))\n             }\n         },\n-        pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n+        PatBox(inner) | PatUniq(inner) | PatRegion(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n-        pat_ident(_, ref path, ref inner) => {\n+        PatIdent(_, ref path, ref inner) => {\n             visit_path(path, (e.clone(), v));\n             for subpat in inner.iter() {\n                 (v.visit_pat)(*subpat, (e.clone(), v))\n             }\n         }\n-        pat_lit(ex) => (v.visit_expr)(ex, (e, v)),\n-        pat_range(e1, e2) => {\n+        PatLit(ex) => (v.visit_expr)(ex, (e, v)),\n+        PatRange(e1, e2) => {\n             (v.visit_expr)(e1, (e.clone(), v));\n             (v.visit_expr)(e2, (e, v));\n         }\n-        pat_wild => (),\n-        pat_vec(ref before, ref slice, ref after) => {\n+        PatWild => (),\n+        PatVec(ref before, ref slice, ref after) => {\n             for elt in before.iter() {\n                 (v.visit_pat)(*elt, (e.clone(), v));\n             }\n@@ -446,94 +446,94 @@ pub fn visit_block<E:Clone>(b: &Block, (e, v): (E, vt<E>)) {\n     visit_expr_opt(b.expr, (e, v));\n }\n \n-pub fn visit_stmt<E>(s: &stmt, (e, v): (E, vt<E>)) {\n+pub fn visit_stmt<E>(s: &Stmt, (e, v): (E, vt<E>)) {\n     match s.node {\n-      stmt_decl(d, _) => (v.visit_decl)(d, (e, v)),\n-      stmt_expr(ex, _) => (v.visit_expr)(ex, (e, v)),\n-      stmt_semi(ex, _) => (v.visit_expr)(ex, (e, v)),\n-      stmt_mac(ref mac, _) => visit_mac(mac, (e, v))\n+      StmtDecl(d, _) => (v.visit_decl)(d, (e, v)),\n+      StmtExpr(ex, _) => (v.visit_expr)(ex, (e, v)),\n+      StmtSemi(ex, _) => (v.visit_expr)(ex, (e, v)),\n+      StmtMac(ref mac, _) => visit_mac(mac, (e, v))\n     }\n }\n \n-pub fn visit_decl<E:Clone>(d: &decl, (e, v): (E, vt<E>)) {\n+pub fn visit_decl<E:Clone>(d: &Decl, (e, v): (E, vt<E>)) {\n     match d.node {\n-        decl_local(ref loc) => (v.visit_local)(*loc, (e, v)),\n-        decl_item(it) => (v.visit_item)(it, (e, v))\n+        DeclLocal(ref loc) => (v.visit_local)(*loc, (e, v)),\n+        DeclItem(it) => (v.visit_item)(it, (e, v))\n     }\n }\n \n-pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n+pub fn visit_expr_opt<E>(eo: Option<@Expr>, (e, v): (E, vt<E>)) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, (e, v)) }\n }\n \n-pub fn visit_exprs<E:Clone>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n+pub fn visit_exprs<E:Clone>(exprs: &[@Expr], (e, v): (E, vt<E>)) {\n     for ex in exprs.iter() { (v.visit_expr)(*ex, (e.clone(), v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n     /* no user-serviceable parts inside */\n }\n \n-pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n+pub fn visit_expr<E:Clone>(ex: @Expr, (e, v): (E, vt<E>)) {\n     match ex.node {\n-        expr_vstore(x, _) => (v.visit_expr)(x, (e.clone(), v)),\n-        expr_vec(ref es, _) => visit_exprs(*es, (e.clone(), v)),\n-        expr_repeat(element, count, _) => {\n+        ExprVstore(x, _) => (v.visit_expr)(x, (e.clone(), v)),\n+        ExprVec(ref es, _) => visit_exprs(*es, (e.clone(), v)),\n+        ExprRepeat(element, count, _) => {\n             (v.visit_expr)(element, (e.clone(), v));\n             (v.visit_expr)(count, (e.clone(), v));\n         }\n-        expr_struct(ref p, ref flds, base) => {\n+        ExprStruct(ref p, ref flds, base) => {\n             visit_path(p, (e.clone(), v));\n             for f in flds.iter() {\n                 (v.visit_expr)(f.expr, (e.clone(), v));\n             }\n             visit_expr_opt(base, (e.clone(), v));\n         }\n-        expr_tup(ref elts) => {\n+        ExprTup(ref elts) => {\n             for el in elts.iter() { (v.visit_expr)(*el, (e.clone(), v)) }\n         }\n-        expr_call(callee, ref args, _) => {\n+        ExprCall(callee, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n             (v.visit_expr)(callee, (e.clone(), v));\n         }\n-        expr_method_call(_, callee, _, ref tys, ref args, _) => {\n+        ExprMethodCall(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (e.clone(), v));\n             for tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n             (v.visit_expr)(callee, (e.clone(), v));\n         }\n-        expr_binary(_, _, a, b) => {\n+        ExprBinary(_, _, a, b) => {\n             (v.visit_expr)(a, (e.clone(), v));\n             (v.visit_expr)(b, (e.clone(), v));\n         }\n-        expr_addr_of(_, x) | expr_unary(_, _, x) |\n-        expr_do_body(x) => (v.visit_expr)(x, (e.clone(), v)),\n-        expr_lit(_) => (),\n-        expr_cast(x, ref t) => {\n+        ExprAddrOf(_, x) | ExprUnary(_, _, x) |\n+        ExprDoBody(x) => (v.visit_expr)(x, (e.clone(), v)),\n+        ExprLit(_) => (),\n+        ExprCast(x, ref t) => {\n             (v.visit_expr)(x, (e.clone(), v));\n             (v.visit_ty)(t, (e.clone(), v));\n         }\n-        expr_if(x, ref b, eo) => {\n+        ExprIf(x, ref b, eo) => {\n             (v.visit_expr)(x, (e.clone(), v));\n             (v.visit_block)(b, (e.clone(), v));\n             visit_expr_opt(eo, (e.clone(), v));\n         }\n-        expr_while(x, ref b) => {\n+        ExprWhile(x, ref b) => {\n             (v.visit_expr)(x, (e.clone(), v));\n             (v.visit_block)(b, (e.clone(), v));\n         }\n-        expr_for_loop(pattern, subexpression, ref block) => {\n+        ExprForLoop(pattern, subexpression, ref block) => {\n             (v.visit_pat)(pattern, (e.clone(), v));\n             (v.visit_expr)(subexpression, (e.clone(), v));\n             (v.visit_block)(block, (e.clone(), v))\n         }\n-        expr_loop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n-        expr_match(x, ref arms) => {\n+        ExprLoop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n+        ExprMatch(x, ref arms) => {\n             (v.visit_expr)(x, (e.clone(), v));\n             for a in arms.iter() { (v.visit_arm)(a, (e.clone(), v)); }\n         }\n-        expr_fn_block(ref decl, ref body) => {\n+        ExprFnBlock(ref decl, ref body) => {\n             (v.visit_fn)(\n                 &fk_fn_block,\n                 decl,\n@@ -543,37 +543,37 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n                 (e.clone(), v)\n             );\n         }\n-        expr_block(ref b) => (v.visit_block)(b, (e.clone(), v)),\n-        expr_assign(a, b) => {\n+        ExprBlock(ref b) => (v.visit_block)(b, (e.clone(), v)),\n+        ExprAssign(a, b) => {\n             (v.visit_expr)(b, (e.clone(), v));\n             (v.visit_expr)(a, (e.clone(), v));\n         }\n-        expr_assign_op(_, _, a, b) => {\n+        ExprAssignOp(_, _, a, b) => {\n             (v.visit_expr)(b, (e.clone(), v));\n             (v.visit_expr)(a, (e.clone(), v));\n         }\n-        expr_field(x, _, ref tys) => {\n+        ExprField(x, _, ref tys) => {\n             (v.visit_expr)(x, (e.clone(), v));\n             for tp in tys.iter() {\n                 (v.visit_ty)(tp, (e.clone(), v));\n             }\n         }\n-        expr_index(_, a, b) => {\n+        ExprIndex(_, a, b) => {\n             (v.visit_expr)(a, (e.clone(), v));\n             (v.visit_expr)(b, (e.clone(), v));\n         }\n-        expr_path(ref p) => visit_path(p, (e.clone(), v)),\n-        expr_self => (),\n-        expr_break(_) => (),\n-        expr_again(_) => (),\n-        expr_ret(eo) => visit_expr_opt(eo, (e.clone(), v)),\n-        expr_log(lv, x) => {\n+        ExprPath(ref p) => visit_path(p, (e.clone(), v)),\n+        ExprSelf => (),\n+        ExprBreak(_) => (),\n+        ExprAgain(_) => (),\n+        ExprRet(eo) => visit_expr_opt(eo, (e.clone(), v)),\n+        ExprLog(lv, x) => {\n             (v.visit_expr)(lv, (e.clone(), v));\n             (v.visit_expr)(x, (e.clone(), v));\n         }\n-        expr_mac(ref mac) => visit_mac(mac, (e.clone(), v)),\n-        expr_paren(x) => (v.visit_expr)(x, (e.clone(), v)),\n-        expr_inline_asm(ref a) => {\n+        ExprMac(ref mac) => visit_mac(mac, (e.clone(), v)),\n+        ExprParen(x) => (v.visit_expr)(x, (e.clone(), v)),\n+        ExprInlineAsm(ref a) => {\n             for &(_, input) in a.inputs.iter() {\n                 (v.visit_expr)(input, (e.clone(), v));\n             }\n@@ -585,7 +585,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n     (v.visit_expr_post)(ex, (e, v));\n }\n \n-pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n+pub fn visit_arm<E:Clone>(a: &Arm, (e, v): (E, vt<E>)) {\n     for p in a.pats.iter() { (v.visit_pat)(*p, (e.clone(), v)); }\n     visit_expr_opt(a.guard, (e.clone(), v));\n     (v.visit_block)(&a.body, (e.clone(), v));\n@@ -601,12 +601,12 @@ pub struct SimpleVisitor {\n     visit_item: @fn(@item),\n     visit_local: @fn(@Local),\n     visit_block: @fn(&Block),\n-    visit_stmt: @fn(@stmt),\n-    visit_arm: @fn(&arm),\n-    visit_pat: @fn(@pat),\n-    visit_decl: @fn(@decl),\n-    visit_expr: @fn(@expr),\n-    visit_expr_post: @fn(@expr),\n+    visit_stmt: @fn(@Stmt),\n+    visit_arm: @fn(&Arm),\n+    visit_pat: @fn(@Pat),\n+    visit_decl: @fn(@Decl),\n+    visit_expr: @fn(@Expr),\n+    visit_expr_post: @fn(@Expr),\n     visit_ty: @fn(&Ty),\n     visit_generics: @fn(&Generics),\n     visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId),\n@@ -677,27 +677,27 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(bl);\n         visit_block(bl, (e, v));\n     }\n-    fn v_stmt(f: @fn(@stmt), st: @stmt, (e, v): ((), vt<()>)) {\n+    fn v_stmt(f: @fn(@Stmt), st: @Stmt, (e, v): ((), vt<()>)) {\n         f(st);\n         visit_stmt(st, (e, v));\n     }\n-    fn v_arm(f: @fn(&arm), a: &arm, (e, v): ((), vt<()>)) {\n+    fn v_arm(f: @fn(&Arm), a: &Arm, (e, v): ((), vt<()>)) {\n         f(a);\n         visit_arm(a, (e, v));\n     }\n-    fn v_pat(f: @fn(@pat), p: @pat, (e, v): ((), vt<()>)) {\n+    fn v_pat(f: @fn(@Pat), p: @Pat, (e, v): ((), vt<()>)) {\n         f(p);\n         visit_pat(p, (e, v));\n     }\n-    fn v_decl(f: @fn(@decl), d: @decl, (e, v): ((), vt<()>)) {\n+    fn v_decl(f: @fn(@Decl), d: @Decl, (e, v): ((), vt<()>)) {\n         f(d);\n         visit_decl(d, (e, v));\n     }\n-    fn v_expr(f: @fn(@expr), ex: @expr, (e, v): ((), vt<()>)) {\n+    fn v_expr(f: @fn(@Expr), ex: @Expr, (e, v): ((), vt<()>)) {\n         f(ex);\n         visit_expr(ex, (e, v));\n     }\n-    fn v_expr_post(f: @fn(@expr), ex: @expr, (_e, _v): ((), vt<()>)) {\n+    fn v_expr_post(f: @fn(@Expr), ex: @Expr, (_e, _v): ((), vt<()>)) {\n         f(ex);\n     }\n     fn v_ty(f: @fn(&Ty), ty: &Ty, (e, v): ((), vt<()>)) {"}, {"sha": "a4df5f4a5fc4dd917a545234630b8352815bbf7e", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -21,25 +21,25 @@ use ast;\n // 'if true {...} else {...}\n //  |x| 5 '\n // isn't parsed as (if true {...} else {...} | x) | 5\n-pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n+pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n     match e.node {\n-      ast::expr_if(*)\n-      | ast::expr_match(*)\n-      | ast::expr_block(_)\n-      | ast::expr_while(*)\n-      | ast::expr_loop(*)\n-      | ast::expr_for_loop(*)\n-      | ast::expr_call(_, _, ast::DoSugar)\n-      | ast::expr_call(_, _, ast::ForSugar)\n-      | ast::expr_method_call(_, _, _, _, _, ast::DoSugar)\n-      | ast::expr_method_call(_, _, _, _, _, ast::ForSugar) => false,\n+      ast::ExprIf(*)\n+      | ast::ExprMatch(*)\n+      | ast::ExprBlock(_)\n+      | ast::ExprWhile(*)\n+      | ast::ExprLoop(*)\n+      | ast::ExprForLoop(*)\n+      | ast::ExprCall(_, _, ast::DoSugar)\n+      | ast::ExprCall(_, _, ast::ForSugar)\n+      | ast::ExprMethodCall(_, _, _, _, _, ast::DoSugar)\n+      | ast::ExprMethodCall(_, _, _, _, _, ast::ForSugar) => false,\n       _ => true\n     }\n }\n \n-pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n+pub fn expr_is_simple_block(e: @ast::Expr) -> bool {\n     match e.node {\n-        ast::expr_block(\n+        ast::ExprBlock(\n             ast::Block { rules: ast::DefaultBlock, _ }\n         ) => true,\n       _ => false\n@@ -49,16 +49,16 @@ pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n // this statement requires a semicolon after it.\n // note that in one case (stmt_semi), we've already\n // seen the semicolon, and thus don't need another.\n-pub fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n+pub fn stmt_ends_with_semi(stmt: &ast::Stmt) -> bool {\n     return match stmt.node {\n-        ast::stmt_decl(d, _) => {\n+        ast::StmtDecl(d, _) => {\n             match d.node {\n-                ast::decl_local(_) => true,\n-                ast::decl_item(_) => false\n+                ast::DeclLocal(_) => true,\n+                ast::DeclItem(_) => false\n             }\n         }\n-        ast::stmt_expr(e, _) => { expr_requires_semi_to_be_stmt(e) }\n-        ast::stmt_semi(*) => { false }\n-        ast::stmt_mac(*) => { false }\n+        ast::StmtExpr(e, _) => { expr_requires_semi_to_be_stmt(e) }\n+        ast::StmtSemi(*) => { false }\n+        ast::StmtMac(*) => { false }\n     }\n }"}, {"sha": "5fa28ff21ae6f4223d15a10f29a2dbd110d2e2e7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -101,7 +101,7 @@ pub fn parse_expr_from_source_str(\n     source: @str,\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n-) -> @ast::expr {\n+) -> @ast::Expr {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -148,7 +148,7 @@ pub fn parse_stmt_from_source_str(\n     cfg: ast::CrateConfig,\n     attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n-) -> @ast::stmt {\n+) -> @ast::Stmt {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -363,9 +363,9 @@ mod test {\n \n     #[test] fn path_exprs_1() {\n         assert_eq!(string_to_expr(@\"a\"),\n-                   @ast::expr{\n+                   @ast::Expr{\n                     id: 1,\n-                    node: ast::expr_path(ast::Path {\n+                    node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n                         segments: ~[\n@@ -382,9 +382,9 @@ mod test {\n \n     #[test] fn path_exprs_2 () {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n-                   @ast::expr {\n+                   @ast::Expr {\n                     id:1,\n-                    node: ast::expr_path(ast::Path {\n+                    node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n                             segments: ~[\n@@ -440,11 +440,11 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert_eq!(string_to_expr(@\"return d\"),\n-                   @ast::expr{\n+                   @ast::Expr{\n                     id:2,\n-                    node:ast::expr_ret(Some(@ast::expr{\n+                    node:ast::ExprRet(Some(@ast::Expr{\n                         id:1,\n-                        node:ast::expr_path(ast::Path{\n+                        node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n                             segments: ~[\n@@ -464,9 +464,9 @@ mod test {\n     #[test] fn parse_stmt_1 () {\n         assert_eq!(string_to_stmt(@\"b;\"),\n                    @Spanned{\n-                       node: ast::stmt_expr(@ast::expr {\n+                       node: ast::StmtExpr(@ast::Expr {\n                            id: 1,\n-                           node: ast::expr_path(ast::Path {\n+                           node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n                                global:false,\n                                segments: ~[\n@@ -490,9 +490,9 @@ mod test {\n     #[test] fn parse_ident_pat () {\n         let parser = string_to_parser(@\"b\");\n         assert_eq!(parser.parse_pat(),\n-                   @ast::pat{id:1, // fixme\n-                             node: ast::pat_ident(\n-                                ast::bind_infer,\n+                   @ast::Pat{id:1, // fixme\n+                             node: ast::PatIdent(\n+                                ast::BindInfer,\n                                 ast::Path {\n                                     span:sp(0,1),\n                                     global:false,\n@@ -536,10 +536,10 @@ mod test {\n                                         }, None, 2),\n                                         span:sp(10,13)\n                                     },\n-                                    pat: @ast::pat {\n+                                    pat: @ast::Pat {\n                                         id:1, // fixme\n-                                        node: ast::pat_ident(\n-                                            ast::bind_infer,\n+                                        node: ast::PatIdent(\n+                                            ast::BindInfer,\n                                             ast::Path {\n                                                 span:sp(6,7),\n                                                 global:false,\n@@ -572,9 +572,9 @@ mod test {\n                                     ast::Block {\n                                         view_items: ~[],\n                                         stmts: ~[@Spanned{\n-                                            node: ast::stmt_semi(@ast::expr{\n+                                            node: ast::StmtSemi(@ast::Expr{\n                                                 id: 6,\n-                                                node: ast::expr_path(\n+                                                node: ast::ExprPath(\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,"}, {"sha": "b056b39eb6e89e4769985adbfecabf4ff669e906", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -17,7 +17,7 @@ Obsolete syntax that becomes too hard to parse can be\n removed.\n */\n \n-use ast::{expr, expr_lit, lit_nil, Attribute};\n+use ast::{Expr, ExprLit, lit_nil, Attribute};\n use ast;\n use codemap::{Span, respan};\n use parse::parser::Parser;\n@@ -79,7 +79,7 @@ pub trait ParserObsoleteMethods {\n     fn obsolete(&self, sp: Span, kind: ObsoleteSyntax);\n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @expr;\n+    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n     fn report(&self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n@@ -263,9 +263,9 @@ impl ParserObsoleteMethods for Parser {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @expr {\n+    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, expr_lit(@respan(sp, lit_nil)))\n+        self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, lit_nil)))\n     }\n \n     fn report(&self,"}, {"sha": "6e7d54e4f7611f4537b3e71cb55f7c3cf8a0c37c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 242, "deletions": 242, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -17,44 +17,44 @@ use ast::{CallSugar, NoSugar, DoSugar};\n use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n-use ast::{_mod, add, arg, arm, Attribute, bind_by_ref, bind_infer};\n-use ast::{bitand, bitor, bitxor, Block};\n-use ast::{BlockCheckMode, box};\n-use ast::{Crate, CrateConfig, decl, decl_item};\n-use ast::{decl_local, DefaultBlock, deref, div, enum_def, explicit_self};\n-use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n-use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n-use ast::{expr_break, expr_call, expr_cast, expr_do_body};\n-use ast::{expr_field, expr_fn_block, expr_if, expr_index};\n-use ast::{expr_lit, expr_log, expr_loop, expr_mac};\n-use ast::{expr_method_call, expr_paren, expr_path, expr_repeat};\n-use ast::{expr_ret, expr_self, expr_struct, expr_tup, expr_unary};\n-use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n-use ast::{expr_vstore_slice, expr_vstore_box};\n-use ast::{expr_vstore_mut_slice, expr_while, expr_for_loop, extern_fn, Field, fn_decl};\n-use ast::{expr_vstore_uniq, Onceness, Once, Many};\n+use ast::{_mod, BiAdd, arg, Arm, Attribute, BindByRef, BindInfer};\n+use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n+use ast::{BlockCheckMode, UnBox};\n+use ast::{Crate, CrateConfig, Decl, DeclItem};\n+use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, enum_def, explicit_self};\n+use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n+use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock};\n+use ast::{ExprBreak, ExprCall, ExprCast, ExprDoBody};\n+use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n+use ast::{ExprLit, ExprLog, ExprLoop, ExprMac};\n+use ast::{ExprMethodCall, ExprParen, ExprPath, ExprRepeat};\n+use ast::{ExprRet, ExprSelf, ExprStruct, ExprTup, ExprUnary};\n+use ast::{ExprVec, ExprVstore, ExprVstoreMutBox};\n+use ast::{ExprVstoreSlice, ExprVstoreBox};\n+use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, extern_fn, Field, fn_decl};\n+use ast::{ExprVstoreUniq, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_static, foreign_item_fn, foreign_mod};\n use ast::{Ident, impure_fn, inherited, item, item_, item_static};\n use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n-use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n-use ast::{match_seq, match_tok, method, mt, mul, mutability};\n-use ast::{named_field, neg, NodeId, noreturn, not, pat, pat_box, pat_enum};\n-use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n-use ast::{pat_tup, pat_uniq, pat_wild, private};\n-use ast::{rem, required};\n-use ast::{ret_style, return_val, shl, shr, stmt, stmt_decl};\n-use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n-use ast::{struct_variant_kind, subtract};\n+use ast::{MutImmutable, MutMutable, mac_, mac_invoc_tt, matcher, match_nonterminal};\n+use ast::{match_seq, match_tok, method, mt, BiMul, Mutability};\n+use ast::{named_field, UnNeg, NodeId, noreturn, UnNot, Pat, PatBox, PatEnum};\n+use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n+use ast::{PatTup, PatUniq, PatWild, private};\n+use ast::{BiRem, required};\n+use ast::{ret_style, return_val, BiShl, BiShr, Stmt, StmtDecl};\n+use ast::{StmtExpr, StmtSemi, StmtMac, struct_def, struct_field};\n+use ast::{struct_variant_kind, BiSub};\n use ast::{sty_box, sty_region, sty_static, sty_uniq, sty_value};\n use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n use ast::{TypeField, ty_fixed_length_vec, ty_closure, ty_bare_fn, ty_typeof};\n use ast::{ty_infer, TypeMethod};\n use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rptr};\n-use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, uniq};\n+use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, UnUniq};\n use ast::{unnamed_field, UnsafeBlock, unsafe_fn, view_item};\n use ast::{view_item_, view_item_extern_mod, view_item_use};\n use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n@@ -160,7 +160,7 @@ macro_rules! maybe_whole_expr (\n                     Some($p.mk_expr(\n                         ($p).span.lo,\n                         ($p).span.hi,\n-                        expr_path(/* bad */ (**pt).clone())))\n+                        ExprPath(/* bad */ (**pt).clone())))\n                 }\n                 _ => None\n             };\n@@ -442,10 +442,10 @@ impl Parser {\n     // Commit to parsing a complete expression `e` expected to be\n     // followed by some token from the set edible + inedible.  Recover\n     // from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&self, e: @expr, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_expr(&self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_expr %?\", e);\n         match e.node {\n-            expr_path(*) => {\n+            ExprPath(*) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n                 let expected = vec::append(edible.to_owned(), inedible);\n                 self.check_for_erroneous_unit_struct_expecting(expected);\n@@ -455,14 +455,14 @@ impl Parser {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_expr_expecting(&self, e: @expr, edible: token::Token) {\n+    pub fn commit_expr_expecting(&self, e: @Expr, edible: token::Token) {\n         self.commit_expr(e, &[edible], &[])\n     }\n \n     // Commit to parsing a complete statement `s`, which expects to be\n     // followed by some token from the set edible + inedible.  Check\n     // for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&self, s: @stmt, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_stmt(&self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_stmt %?\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.map_default(false, |t|is_ident_or_path(*t)) {\n@@ -472,7 +472,7 @@ impl Parser {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&self, s: @stmt, edible: token::Token) {\n+    pub fn commit_stmt_expecting(&self, s: @Stmt, edible: token::Token) {\n         self.commit_stmt(s, &[edible], &[])\n     }\n \n@@ -1112,7 +1112,7 @@ impl Parser {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n             let mt = self.parse_mt();\n-            if mt.mutbl == m_mutbl {    // `m_const` too after snapshot\n+            if mt.mutbl == MutMutable {    // `m_const` too after snapshot\n                 self.obsolete(*self.last_span, ObsoleteMutVector);\n             }\n \n@@ -1191,7 +1191,7 @@ impl Parser {\n         // reflected in the AST type.\n         let mt = self.parse_mt();\n \n-        if mt.mutbl != m_imm && sigil == OwnedSigil {\n+        if mt.mutbl != MutImmutable && sigil == OwnedSigil {\n             self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n         }\n \n@@ -1308,7 +1308,7 @@ impl Parser {\n         })\n     }\n \n-    pub fn maybe_parse_fixed_vstore(&self) -> Option<@ast::expr> {\n+    pub fn maybe_parse_fixed_vstore(&self) -> Option<@ast::Expr> {\n         if self.eat(&token::BINOP(token::STAR)) {\n             self.obsolete(*self.last_span, ObsoleteFixedLengthVectorType);\n             Some(self.parse_expr())\n@@ -1353,18 +1353,18 @@ impl Parser {\n     }\n \n     // matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&self) -> @expr {\n+    pub fn parse_literal_maybe_minus(&self) -> @Expr {\n         let minus_lo = self.span.lo;\n         let minus_present = self.eat(&token::BINOP(token::MINUS));\n \n         let lo = self.span.lo;\n         let literal = @self.parse_lit();\n         let hi = self.span.hi;\n-        let expr = self.mk_expr(lo, hi, expr_lit(literal));\n+        let expr = self.mk_expr(lo, hi, ExprLit(literal));\n \n         if minus_present {\n             let minus_hi = self.span.hi;\n-            self.mk_expr(minus_lo, minus_hi, self.mk_unary(neg, expr))\n+            self.mk_expr(minus_lo, minus_hi, self.mk_unary(UnNeg, expr))\n         } else {\n             expr\n         }\n@@ -1618,14 +1618,14 @@ impl Parser {\n     }\n \n     // parse mutability declaration (mut/const/imm)\n-    pub fn parse_mutability(&self) -> mutability {\n+    pub fn parse_mutability(&self) -> Mutability {\n         if self.eat_keyword(keywords::Mut) {\n-            m_mutbl\n+            MutMutable\n         } else if self.eat_keyword(keywords::Const) {\n             self.obsolete(*self.last_span, ObsoleteConstPointer);\n-            m_imm\n+            MutImmutable\n         } else {\n-            m_imm\n+            MutImmutable\n         }\n     }\n \n@@ -1642,79 +1642,79 @@ impl Parser {\n         }\n     }\n \n-    pub fn mk_expr(&self, lo: BytePos, hi: BytePos, node: expr_) -> @expr {\n-        @expr {\n+    pub fn mk_expr(&self, lo: BytePos, hi: BytePos, node: Expr_) -> @Expr {\n+        @Expr {\n             id: self.get_id(),\n             node: node,\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_unary(&self, unop: ast::unop, expr: @expr) -> ast::expr_ {\n-        expr_unary(self.get_id(), unop, expr)\n+    pub fn mk_unary(&self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n+        ExprUnary(self.get_id(), unop, expr)\n     }\n \n-    pub fn mk_binary(&self, binop: ast::binop, lhs: @expr, rhs: @expr) -> ast::expr_ {\n-        expr_binary(self.get_id(), binop, lhs, rhs)\n+    pub fn mk_binary(&self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+        ExprBinary(self.get_id(), binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&self, f: @expr, args: ~[@expr], sugar: CallSugar) -> ast::expr_ {\n-        expr_call(f, args, sugar)\n+    pub fn mk_call(&self, f: @Expr, args: ~[@Expr], sugar: CallSugar) -> ast::Expr_ {\n+        ExprCall(f, args, sugar)\n     }\n \n     pub fn mk_method_call(&self,\n-                      rcvr: @expr,\n+                      rcvr: @Expr,\n                       ident: Ident,\n                       tps: ~[Ty],\n-                      args: ~[@expr],\n-                      sugar: CallSugar) -> ast::expr_ {\n-        expr_method_call(self.get_id(), rcvr, ident, tps, args, sugar)\n+                      args: ~[@Expr],\n+                      sugar: CallSugar) -> ast::Expr_ {\n+        ExprMethodCall(self.get_id(), rcvr, ident, tps, args, sugar)\n     }\n \n-    pub fn mk_index(&self, expr: @expr, idx: @expr) -> ast::expr_ {\n-        expr_index(self.get_id(), expr, idx)\n+    pub fn mk_index(&self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n+        ExprIndex(self.get_id(), expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @expr, ident: Ident, tys: ~[Ty]) -> ast::expr_ {\n-        expr_field(expr, ident, tys)\n+    pub fn mk_field(&self, expr: @Expr, ident: Ident, tys: ~[Ty]) -> ast::Expr_ {\n+        ExprField(expr, ident, tys)\n     }\n \n-    pub fn mk_assign_op(&self, binop: ast::binop, lhs: @expr, rhs: @expr) -> ast::expr_ {\n-        expr_assign_op(self.get_id(), binop, lhs, rhs)\n+    pub fn mk_assign_op(&self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+        ExprAssignOp(self.get_id(), binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n-        @expr {\n+    pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @Expr {\n+        @Expr {\n             id: self.get_id(),\n-            node: expr_mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_lit_u32(&self, i: u32) -> @expr {\n+    pub fn mk_lit_u32(&self, i: u32) -> @Expr {\n         let span = self.span;\n         let lv_lit = @codemap::Spanned {\n             node: lit_uint(i as u64, ty_u32),\n             span: *span\n         };\n \n-        @expr {\n+        @Expr {\n             id: self.get_id(),\n-            node: expr_lit(lv_lit),\n+            node: ExprLit(lv_lit),\n             span: *span,\n         }\n     }\n \n     // at the bottom (top?) of the precedence hierarchy,\n     // parse things like parenthesized exprs,\n     // macros, return, etc.\n-    pub fn parse_bottom_expr(&self) -> @expr {\n+    pub fn parse_bottom_expr(&self) -> @Expr {\n         maybe_whole_expr!(self);\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n-        let ex: expr_;\n+        let ex: Expr_;\n \n         if *self.token == token::LPAREN {\n             self.bump();\n@@ -1725,7 +1725,7 @@ impl Parser {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = @spanned(lo, hi, lit_nil);\n-                return self.mk_expr(lo, hi, expr_lit(lit));\n+                return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n             self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n@@ -1743,28 +1743,28 @@ impl Parser {\n             self.commit_expr_expecting(*es.last(), token::RPAREN);\n \n             return if es.len() == 1 && !trailing_comma {\n-                self.mk_expr(lo, self.span.hi, expr_paren(es[0]))\n+                self.mk_expr(lo, self.span.hi, ExprParen(es[0]))\n             }\n             else {\n-                self.mk_expr(lo, hi, expr_tup(es))\n+                self.mk_expr(lo, hi, ExprTup(es))\n             }\n         } else if *self.token == token::LBRACE {\n             self.bump();\n             let blk = self.parse_block_tail(lo, DefaultBlock);\n             return self.mk_expr(blk.span.lo, blk.span.hi,\n-                                 expr_block(blk));\n+                                 ExprBlock(blk));\n         } else if token::is_bar(&*self.token) {\n             return self.parse_lambda_expr();\n         } else if self.eat_keyword(keywords::Self) {\n-            ex = expr_self;\n+            ex = ExprSelf;\n             hi = self.span.hi;\n         } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(keywords::For) {\n             return self.parse_for_expr();\n         } else if self.eat_keyword(keywords::Do) {\n             return self.parse_sugary_call_expr(lo, ~\"do\", DoSugar,\n-                                               expr_do_body);\n+                                               ExprDoBody);\n         } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n         } else if self.token_is_lifetime(&*self.token) {\n@@ -1782,14 +1782,14 @@ impl Parser {\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n-            if mutbl == m_mutbl {\n+            if mutbl == MutMutable {\n                 self.obsolete(*self.last_span, ObsoleteMutVector);\n             }\n \n             if *self.token == token::RBRACKET {\n                 // Empty vector.\n                 self.bump();\n-                ex = expr_vec(~[], mutbl);\n+                ex = ExprVec(~[], mutbl);\n             } else {\n                 // Nonempty vector.\n                 let first_expr = self.parse_expr();\n@@ -1800,7 +1800,7 @@ impl Parser {\n                     self.bump();\n                     let count = self.parse_expr();\n                     self.expect(&token::RBRACKET);\n-                    ex = expr_repeat(first_expr, count, mutbl);\n+                    ex = ExprRepeat(first_expr, count, mutbl);\n                 } else if *self.token == token::COMMA {\n                     // Vector with two or more elements.\n                     self.bump();\n@@ -1809,11 +1809,11 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_expr()\n                     );\n-                    ex = expr_vec(~[first_expr] + remaining_exprs, mutbl);\n+                    ex = ExprVec(~[first_expr] + remaining_exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n                     self.expect(&token::RBRACKET);\n-                    ex = expr_vec(~[first_expr], mutbl);\n+                    ex = ExprVec(~[first_expr], mutbl);\n                 }\n             }\n             hi = self.last_span.hi;\n@@ -1823,24 +1823,24 @@ impl Parser {\n             let lvl = self.parse_expr();\n             self.expect(&token::COMMA);\n             let e = self.parse_expr();\n-            ex = expr_log(lvl, e);\n+            ex = ExprLog(lvl, e);\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n         } else if self.eat_keyword(keywords::Return) {\n             // RETURN expression\n             if can_begin_expr(&*self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n-                ex = expr_ret(Some(e));\n-            } else { ex = expr_ret(None); }\n+                ex = ExprRet(Some(e));\n+            } else { ex = ExprRet(None); }\n         } else if self.eat_keyword(keywords::Break) {\n             // BREAK expression\n             if self.token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n                 self.bump();\n-                ex = expr_break(Some(lifetime));\n+                ex = ExprBreak(Some(lifetime));\n             } else {\n-                ex = expr_break(None);\n+                ex = ExprBreak(None);\n             }\n             hi = self.span.hi;\n         } else if *self.token == token::MOD_SEP ||\n@@ -1896,38 +1896,38 @@ impl Parser {\n \n                     hi = pth.span.hi;\n                     self.commit_expr_expecting(fields.last().expr, token::RBRACE);\n-                    ex = expr_struct(pth, fields, base);\n+                    ex = ExprStruct(pth, fields, base);\n                     return self.mk_expr(lo, hi, ex);\n                 }\n             }\n \n             hi = pth.span.hi;\n-            ex = expr_path(pth);\n+            ex = ExprPath(pth);\n         } else {\n             // other literal expression\n             let lit = self.parse_lit();\n             hi = lit.span.hi;\n-            ex = expr_lit(@lit);\n+            ex = ExprLit(@lit);\n         }\n \n         return self.mk_expr(lo, hi, ex);\n     }\n \n     // parse a block or unsafe block\n     pub fn parse_block_expr(&self, lo: BytePos, blk_mode: BlockCheckMode)\n-                            -> @expr {\n+                            -> @Expr {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n-        return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n+        return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n     }\n \n     // parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&self) -> @expr {\n+    pub fn parse_dot_or_call_expr(&self) -> @Expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&self, e0: @expr) -> @expr {\n+    pub fn parse_dot_or_call_expr_with(&self, e0: @Expr) -> @Expr {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2185,7 +2185,7 @@ impl Parser {\n     }\n \n     // parse a prefix-operator expr\n-    pub fn parse_prefix_expr(&self) -> @expr {\n+    pub fn parse_prefix_expr(&self) -> @Expr {\n         let lo = self.span.lo;\n         let hi;\n \n@@ -2195,21 +2195,21 @@ impl Parser {\n             self.bump();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            ex = self.mk_unary(not, e);\n+            ex = self.mk_unary(UnNot, e);\n           }\n           token::BINOP(b) => {\n             match b {\n               token::MINUS => {\n                 self.bump();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                ex = self.mk_unary(neg, e);\n+                ex = self.mk_unary(UnNeg, e);\n               }\n               token::STAR => {\n                 self.bump();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                ex = self.mk_unary(deref, e);\n+                ex = self.mk_unary(UnDeref, e);\n               }\n               token::AND => {\n                 self.bump();\n@@ -2219,16 +2219,16 @@ impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  expr_vec(*) | expr_lit(@codemap::Spanned {\n+                  ExprVec(*) | ExprLit(@codemap::Spanned {\n                     node: lit_str(_), span: _\n                   })\n-                  if m == m_imm => {\n-                    expr_vstore(e, expr_vstore_slice)\n+                  if m == MutImmutable => {\n+                    ExprVstore(e, ExprVstoreSlice)\n                   }\n-                  expr_vec(*) if m == m_mutbl => {\n-                    expr_vstore(e, expr_vstore_mut_slice)\n+                  ExprVec(*) if m == MutMutable => {\n+                    ExprVstore(e, ExprVstoreMutSlice)\n                   }\n-                  _ => expr_addr_of(m, e)\n+                  _ => ExprAddrOf(m, e)\n                 };\n               }\n               _ => return self.parse_dot_or_call_expr()\n@@ -2241,29 +2241,29 @@ impl Parser {\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n             ex = match e.node {\n-              expr_vec(*) | expr_repeat(*) if m == m_mutbl =>\n-                expr_vstore(e, expr_vstore_mut_box),\n-              expr_vec(*) |\n-              expr_lit(@codemap::Spanned { node: lit_str(_), span: _}) |\n-              expr_repeat(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n-              _ => self.mk_unary(box(m), e)\n+              ExprVec(*) | ExprRepeat(*) if m == MutMutable =>\n+                ExprVstore(e, ExprVstoreMutBox),\n+              ExprVec(*) |\n+              ExprLit(@codemap::Spanned { node: lit_str(_), span: _}) |\n+              ExprRepeat(*) if m == MutImmutable => ExprVstore(e, ExprVstoreBox),\n+              _ => self.mk_unary(UnBox(m), e)\n             };\n           }\n           token::TILDE => {\n             self.bump();\n             let m = self.parse_mutability();\n-            if m != m_imm {\n+            if m != MutImmutable {\n                 self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n             }\n \n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n-              expr_vec(*) |\n-              expr_lit(@codemap::Spanned { node: lit_str(_), span: _}) |\n-              expr_repeat(*) => expr_vstore(e, expr_vstore_uniq),\n-              _ => self.mk_unary(uniq, e)\n+              ExprVec(*) |\n+              ExprLit(@codemap::Spanned { node: lit_str(_), span: _}) |\n+              ExprRepeat(*) => ExprVstore(e, ExprVstoreUniq),\n+              _ => self.mk_unary(UnUniq, e)\n             };\n           }\n           _ => return self.parse_dot_or_call_expr()\n@@ -2272,12 +2272,12 @@ impl Parser {\n     }\n \n     // parse an expression of binops\n-    pub fn parse_binops(&self) -> @expr {\n+    pub fn parse_binops(&self) -> @Expr {\n         self.parse_more_binops(self.parse_prefix_expr(), 0)\n     }\n \n     // parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&self, lhs: @expr, min_prec: uint) -> @expr {\n+    pub fn parse_more_binops(&self, lhs: @Expr, min_prec: uint) -> @Expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n \n         // Prevent dynamic borrow errors later on by limiting the\n@@ -2314,7 +2314,7 @@ impl Parser {\n                     let rhs = self.parse_ty(true);\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n-                                           expr_cast(lhs, rhs));\n+                                           ExprCast(lhs, rhs));\n                     self.parse_more_binops(_as, min_prec)\n                 } else {\n                     lhs\n@@ -2326,29 +2326,29 @@ impl Parser {\n     // parse an assignment expression....\n     // actually, this seems to be the main entry point for\n     // parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&self) -> @expr {\n+    pub fn parse_assign_expr(&self) -> @Expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match *self.token {\n           token::EQ => {\n               self.bump();\n               let rhs = self.parse_expr();\n-              self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs))\n+              self.mk_expr(lo, rhs.span.hi, ExprAssign(lhs, rhs))\n           }\n           token::BINOPEQ(op) => {\n               self.bump();\n               let rhs = self.parse_expr();\n               let aop = match op {\n-                  token::PLUS =>    add,\n-                  token::MINUS =>   subtract,\n-                  token::STAR =>    mul,\n-                  token::SLASH =>   div,\n-                  token::PERCENT => rem,\n-                  token::CARET =>   bitxor,\n-                  token::AND =>     bitand,\n-                  token::OR =>      bitor,\n-                  token::SHL =>     shl,\n-                  token::SHR =>     shr\n+                  token::PLUS =>    BiAdd,\n+                  token::MINUS =>   BiSub,\n+                  token::STAR =>    BiMul,\n+                  token::SLASH =>   BiDiv,\n+                  token::PERCENT => BiRem,\n+                  token::CARET =>   BiBitXor,\n+                  token::AND =>     BiBitAnd,\n+                  token::OR =>      BiBitOr,\n+                  token::SHL =>     BiShl,\n+                  token::SHR =>     BiShr\n               };\n               self.mk_expr(lo, rhs.span.hi,\n                            self.mk_assign_op(aop, lhs, rhs))\n@@ -2360,14 +2360,14 @@ impl Parser {\n               self.bump(); // rhs\n               self.bump(); // ;\n               self.mk_expr(lo, self.span.hi,\n-                           expr_break(None))\n+                           ExprBreak(None))\n           }\n           token::DARROW => {\n             self.obsolete(*self.span, ObsoleteSwap);\n             self.bump();\n             // Ignore what we get, this is an error anyway\n             self.parse_expr();\n-            self.mk_expr(lo, self.span.hi, expr_break(None))\n+            self.mk_expr(lo, self.span.hi, ExprBreak(None))\n           }\n           _ => {\n               lhs\n@@ -2376,22 +2376,22 @@ impl Parser {\n     }\n \n     // parse an 'if' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&self) -> @expr {\n+    pub fn parse_if_expr(&self) -> @Expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n-        let mut els: Option<@expr> = None;\n+        let mut els: Option<@Expr> = None;\n         let mut hi = thn.span.hi;\n         if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr();\n             els = Some(elexpr);\n             hi = elexpr.span.hi;\n         }\n-        self.mk_expr(lo, hi, expr_if(cond, thn, els))\n+        self.mk_expr(lo, hi, ExprIf(cond, thn, els))\n     }\n \n     // `|args| { ... }` or `{ ...}` like in `do` expressions\n-    pub fn parse_lambda_block_expr(&self) -> @expr {\n+    pub fn parse_lambda_block_expr(&self) -> @Expr {\n         self.parse_lambda_expr_(\n             || {\n                 match *self.token {\n@@ -2414,12 +2414,12 @@ impl Parser {\n             },\n             || {\n                 let blk = self.parse_block();\n-                self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk))\n+                self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk))\n             })\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&self) -> @expr {\n+    pub fn parse_lambda_expr(&self) -> @Expr {\n         self.parse_lambda_expr_(|| self.parse_fn_block_decl(),\n                                 || self.parse_expr())\n     }\n@@ -2429,8 +2429,8 @@ impl Parser {\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&self,\n                               parse_decl: &fn() -> fn_decl,\n-                              parse_body: &fn() -> @expr)\n-                              -> @expr {\n+                              parse_body: &fn() -> @Expr)\n+                              -> @Expr {\n         let lo = self.last_span.lo;\n         let decl = parse_decl();\n         let body = parse_body();\n@@ -2444,20 +2444,20 @@ impl Parser {\n         };\n \n         return self.mk_expr(lo, body.span.hi,\n-                            expr_fn_block(decl, fakeblock));\n+                            ExprFnBlock(decl, fakeblock));\n     }\n \n-    pub fn parse_else_expr(&self) -> @expr {\n+    pub fn parse_else_expr(&self) -> @Expr {\n         if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n             let blk = self.parse_block();\n-            return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n+            return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n         }\n     }\n \n     // parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&self) -> @expr {\n+    pub fn parse_for_expr(&self) -> @Expr {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n@@ -2467,7 +2467,7 @@ impl Parser {\n         let loop_block = self.parse_block();\n         let hi = self.span.hi;\n \n-        self.mk_expr(lo, hi, expr_for_loop(pat, expr, loop_block))\n+        self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block))\n     }\n \n \n@@ -2477,8 +2477,8 @@ impl Parser {\n     pub fn parse_sugary_call_expr(&self, lo: BytePos,\n                                   keyword: ~str,\n                                   sugar: CallSugar,\n-                                  ctor: &fn(v: @expr) -> expr_)\n-                                  -> @expr {\n+                                  ctor: &fn(v: @Expr) -> Expr_)\n+                                  -> @Expr {\n         // Parse the callee `foo` in\n         //    for foo || {\n         //    for foo.bar || {\n@@ -2490,14 +2490,14 @@ impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, ref args, NoSugar) => {\n+            ExprCall(f, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append((*args).clone(), [last_arg]);\n-                self.mk_expr(lo, block.span.hi, expr_call(f, args, sugar))\n+                self.mk_expr(lo, block.span.hi, ExprCall(f, args, sugar))\n             }\n-            expr_method_call(_, f, i, ref tps, ref args, NoSugar) => {\n+            ExprMethodCall(_, f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n@@ -2509,7 +2509,7 @@ impl Parser {\n                                                  args,\n                                                  sugar))\n             }\n-            expr_field(f, i, ref tps) => {\n+            ExprField(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n@@ -2520,8 +2520,8 @@ impl Parser {\n                                                  ~[last_arg],\n                                                  sugar))\n             }\n-            expr_path(*) | expr_call(*) | expr_method_call(*) |\n-                expr_paren(*) => {\n+            ExprPath(*) | ExprCall(*) | ExprMethodCall(*) |\n+                ExprParen(*) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n@@ -2542,15 +2542,15 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_while_expr(&self) -> @expr {\n+    pub fn parse_while_expr(&self) -> @Expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block();\n         let hi = body.span.hi;\n-        return self.mk_expr(lo, hi, expr_while(cond, body));\n+        return self.mk_expr(lo, hi, ExprWhile(cond, body));\n     }\n \n-    pub fn parse_loop_expr(&self, opt_ident: Option<ast::Ident>) -> @expr {\n+    pub fn parse_loop_expr(&self, opt_ident: Option<ast::Ident>) -> @Expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n             *self.token == token::LBRACE\n@@ -2562,7 +2562,7 @@ impl Parser {\n             let lo = self.last_span.lo;\n             let body = self.parse_block();\n             let hi = body.span.hi;\n-            return self.mk_expr(lo, hi, expr_loop(body, opt_ident));\n+            return self.mk_expr(lo, hi, ExprLoop(body, opt_ident));\n         } else {\n             // This is a 'continue' expression\n             if opt_ident.is_some() {\n@@ -2574,9 +2574,9 @@ impl Parser {\n             let ex = if self.token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n                 self.bump();\n-                expr_again(Some(lifetime))\n+                ExprAgain(Some(lifetime))\n             } else {\n-                expr_again(None)\n+                ExprAgain(None)\n             };\n             let hi = self.span.hi;\n             return self.mk_expr(lo, hi, ex);\n@@ -2591,11 +2591,11 @@ impl Parser {\n               self.look_ahead(2, |t| *t == token::COLON)))\n     }\n \n-    fn parse_match_expr(&self) -> @expr {\n+    fn parse_match_expr(&self) -> @Expr {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n-        let mut arms: ~[arm] = ~[];\n+        let mut arms: ~[Arm] = ~[];\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n@@ -2624,20 +2624,20 @@ impl Parser {\n                 span: expr.span,\n             };\n \n-            arms.push(ast::arm { pats: pats, guard: guard, body: blk });\n+            arms.push(ast::Arm { pats: pats, guard: guard, body: blk });\n         }\n         let hi = self.span.hi;\n         self.bump();\n-        return self.mk_expr(lo, hi, expr_match(discriminant, arms));\n+        return self.mk_expr(lo, hi, ExprMatch(discriminant, arms));\n     }\n \n     // parse an expression\n-    pub fn parse_expr(&self) -> @expr {\n+    pub fn parse_expr(&self) -> @Expr {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     // parse an expression, subject to the given restriction\n-    fn parse_expr_res(&self, r: restriction) -> @expr {\n+    fn parse_expr_res(&self, r: restriction) -> @Expr {\n         let old = *self.restriction;\n         *self.restriction = r;\n         let e = self.parse_assign_expr();\n@@ -2646,7 +2646,7 @@ impl Parser {\n     }\n \n     // parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&self) -> Option<@expr> {\n+    fn parse_initializer(&self) -> Option<@Expr> {\n         match *self.token {\n           token::EQ => {\n             self.bump();\n@@ -2665,7 +2665,7 @@ impl Parser {\n     }\n \n     // parse patterns, separated by '|' s\n-    fn parse_pats(&self) -> ~[@pat] {\n+    fn parse_pats(&self) -> ~[@Pat] {\n         let mut pats = ~[];\n         loop {\n             pats.push(self.parse_pat());\n@@ -2676,7 +2676,7 @@ impl Parser {\n \n     fn parse_pat_vec_elements(\n         &self,\n-    ) -> (~[@pat], Option<@pat>, ~[@pat]) {\n+    ) -> (~[@Pat], Option<@Pat>, ~[@Pat]) {\n         let mut before = ~[];\n         let mut slice = None;\n         let mut after = ~[];\n@@ -2699,9 +2699,9 @@ impl Parser {\n             let subpat = self.parse_pat();\n             if is_slice {\n                 match subpat {\n-                    @ast::pat { node: pat_wild, _ } => (),\n-                    @ast::pat { node: pat_ident(_, _, _), _ } => (),\n-                    @ast::pat { span, _ } => self.span_fatal(\n+                    @ast::Pat { node: PatWild, _ } => (),\n+                    @ast::Pat { node: PatIdent(_, _, _), _ } => (),\n+                    @ast::Pat { span, _ } => self.span_fatal(\n                         span, \"expected an identifier or `_`\"\n                     )\n                 }\n@@ -2719,7 +2719,7 @@ impl Parser {\n     }\n \n     // parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&self) -> (~[ast::field_pat], bool) {\n+    fn parse_pat_fields(&self) -> (~[ast::FieldPat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n         let mut first = true;\n@@ -2751,19 +2751,19 @@ impl Parser {\n                 self.bump();\n                 subpat = self.parse_pat();\n             } else {\n-                subpat = @ast::pat {\n+                subpat = @ast::Pat {\n                     id: self.get_id(),\n-                    node: pat_ident(bind_infer, fieldpath, None),\n+                    node: PatIdent(BindInfer, fieldpath, None),\n                     span: *self.last_span\n                 };\n             }\n-            fields.push(ast::field_pat { ident: fieldname, pat: subpat });\n+            fields.push(ast::FieldPat { ident: fieldname, pat: subpat });\n         }\n         return (fields, etc);\n     }\n \n     // parse a pattern.\n-    pub fn parse_pat(&self) -> @pat {\n+    pub fn parse_pat(&self) -> @Pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n@@ -2773,9 +2773,9 @@ impl Parser {\n             // parse _\n           token::UNDERSCORE => {\n             self.bump();\n-            pat = pat_wild;\n+            pat = PatWild;\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2788,22 +2788,22 @@ impl Parser {\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n-              pat_lit(e@@expr {\n-                node: expr_lit(@codemap::Spanned {\n+              PatLit(e@@Expr {\n+                node: ExprLit(@codemap::Spanned {\n                     node: lit_str(_),\n                     span: _}), _\n               }) => {\n-                let vst = @expr {\n+                let vst = @Expr {\n                     id: self.get_id(),\n-                    node: expr_vstore(e, expr_vstore_box),\n+                    node: ExprVstore(e, ExprVstoreBox),\n                     span: mk_sp(lo, hi),\n                 };\n-                pat_lit(vst)\n+                PatLit(vst)\n               }\n-              _ => pat_box(sub)\n+              _ => PatBox(sub)\n             };\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2816,22 +2816,22 @@ impl Parser {\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n-              pat_lit(e@@expr {\n-                node: expr_lit(@codemap::Spanned {\n+              PatLit(e@@Expr {\n+                node: ExprLit(@codemap::Spanned {\n                     node: lit_str(_),\n                     span: _}), _\n               }) => {\n-                let vst = @expr {\n+                let vst = @Expr {\n                     id: self.get_id(),\n-                    node: expr_vstore(e, expr_vstore_uniq),\n+                    node: ExprVstore(e, ExprVstoreUniq),\n                     span: mk_sp(lo, hi),\n                 };\n-                pat_lit(vst)\n+                PatLit(vst)\n               }\n-              _ => pat_uniq(sub)\n+              _ => PatUniq(sub)\n             };\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2845,21 +2845,21 @@ impl Parser {\n               hi = sub.span.hi;\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n-                  pat_lit(e@@expr {\n-                      node: expr_lit(@codemap::Spanned {\n+                  PatLit(e@@Expr {\n+                      node: ExprLit(@codemap::Spanned {\n                             node: lit_str(_), span: _}), _\n                   }) => {\n-                      let vst = @expr {\n+                      let vst = @Expr {\n                           id: self.get_id(),\n-                          node: expr_vstore(e, expr_vstore_slice),\n+                          node: ExprVstore(e, ExprVstoreSlice),\n                           span: mk_sp(lo, hi)\n                       };\n-                      pat_lit(vst)\n+                      PatLit(vst)\n                   }\n-              _ => pat_region(sub)\n+              _ => PatRegion(sub)\n             };\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2870,9 +2870,9 @@ impl Parser {\n             let (_, _) = self.parse_pat_fields();\n             self.bump();\n             self.obsolete(*self.span, ObsoleteRecordPattern);\n-            pat = pat_wild;\n+            pat = PatWild;\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2887,8 +2887,8 @@ impl Parser {\n                 let lit = @codemap::Spanned {\n                     node: lit_nil,\n                     span: mk_sp(lo, hi)};\n-                let expr = self.mk_expr(lo, hi, expr_lit(lit));\n-                pat = pat_lit(expr);\n+                let expr = self.mk_expr(lo, hi, ExprLit(lit));\n+                pat = PatLit(expr);\n             } else {\n                 let mut fields = ~[self.parse_pat()];\n                 if self.look_ahead(1, |t| *t != token::RPAREN) {\n@@ -2899,10 +2899,10 @@ impl Parser {\n                 }\n                 if fields.len() == 1 { self.expect(&token::COMMA); }\n                 self.expect(&token::RPAREN);\n-                pat = pat_tup(fields);\n+                pat = PatTup(fields);\n             }\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2915,9 +2915,9 @@ impl Parser {\n                 self.parse_pat_vec_elements();\n \n             self.expect(&token::RBRACKET);\n-            pat = ast::pat_vec(before, slice, after);\n+            pat = ast::PatVec(before, slice, after);\n             hi = self.last_span.hi;\n-            return @ast::pat {\n+            return @ast::Pat {\n                 id: self.get_id(),\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2940,18 +2940,18 @@ impl Parser {\n                     let path = self.parse_path(LifetimeAndTypesWithColons)\n                                    .path;\n                     let hi = self.span.hi;\n-                    self.mk_expr(lo, hi, expr_path(path))\n+                    self.mk_expr(lo, hi, ExprPath(path))\n                 } else {\n                     self.parse_literal_maybe_minus()\n                 };\n-                pat = pat_range(val, end);\n+                pat = PatRange(val, end);\n             } else {\n-                pat = pat_lit(val);\n+                pat = PatLit(val);\n             }\n         } else if self.eat_keyword(keywords::Ref) {\n             // parse ref pat\n             let mutbl = self.parse_mutability();\n-            pat = self.parse_pat_ident(bind_by_ref(mutbl));\n+            pat = self.parse_pat_ident(BindByRef(mutbl));\n         } else {\n             let can_be_enum_or_struct = do self.look_ahead(1) |t| {\n                 match *t {\n@@ -2965,7 +2965,7 @@ impl Parser {\n                 let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 self.eat(&token::DOTDOT);\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n-                pat = pat_range(start, end);\n+                pat = PatRange(start, end);\n             } else if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n                 let name = self.parse_path(NoTypesAllowed).path;\n                 let sub;\n@@ -2976,7 +2976,7 @@ impl Parser {\n                     // or just foo\n                     sub = None;\n                 }\n-                pat = pat_ident(bind_infer, name, sub);\n+                pat = PatIdent(BindInfer, name, sub);\n             } else {\n                 // parse an enum pat\n                 let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n@@ -2987,10 +2987,10 @@ impl Parser {\n                         let (fields, etc) =\n                             self.parse_pat_fields();\n                         self.bump();\n-                        pat = pat_struct(enum_path, fields, etc);\n+                        pat = PatStruct(enum_path, fields, etc);\n                     }\n                     _ => {\n-                        let mut args: ~[@pat] = ~[];\n+                        let mut args: ~[@Pat] = ~[];\n                         match *self.token {\n                           token::LPAREN => {\n                             let is_star = do self.look_ahead(1) |t| {\n@@ -3004,27 +3004,27 @@ impl Parser {\n                                 self.bump();\n                                 self.bump();\n                                 self.expect(&token::RPAREN);\n-                                pat = pat_enum(enum_path, None);\n+                                pat = PatEnum(enum_path, None);\n                             } else {\n                                 args = self.parse_unspanned_seq(\n                                     &token::LPAREN,\n                                     &token::RPAREN,\n                                     seq_sep_trailing_disallowed(token::COMMA),\n                                     |p| p.parse_pat()\n                                 );\n-                                pat = pat_enum(enum_path, Some(args));\n+                                pat = PatEnum(enum_path, Some(args));\n                             }\n                           },\n                           _ => {\n                               if enum_path.segments.len() == 1 {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n-                                  pat = pat_ident(bind_infer,\n+                                  pat = PatIdent(BindInfer,\n                                                   enum_path,\n                                                   None);\n                               } else {\n-                                  pat = pat_enum(enum_path, Some(args));\n+                                  pat = PatEnum(enum_path, Some(args));\n                               }\n                           }\n                         }\n@@ -3033,7 +3033,7 @@ impl Parser {\n             }\n         }\n         hi = self.last_span.hi;\n-        @ast::pat {\n+        @ast::Pat {\n             id: self.get_id(),\n             node: pat,\n             span: mk_sp(lo, hi),\n@@ -3044,8 +3044,8 @@ impl Parser {\n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&self,\n-                       binding_mode: ast::binding_mode)\n-                       -> ast::pat_ {\n+                       binding_mode: ast::BindingMode)\n+                       -> ast::Pat_ {\n         if !is_plain_ident(&*self.token) {\n             self.span_fatal(*self.last_span,\n                             \"expected identifier, found path\");\n@@ -3070,7 +3070,7 @@ impl Parser {\n                 \"expected identifier, found enum pattern\");\n         }\n \n-        pat_ident(binding_mode, name, sub)\n+        PatIdent(binding_mode, name, sub)\n     }\n \n     // parse a local variable declaration\n@@ -3100,15 +3100,15 @@ impl Parser {\n     }\n \n     // parse a \"let\" stmt\n-    fn parse_let(&self) -> @decl {\n+    fn parse_let(&self) -> @Decl {\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let lo = self.span.lo;\n         let local = self.parse_local(is_mutbl);\n         while self.eat(&token::COMMA) {\n             let _ = self.parse_local(is_mutbl);\n             self.obsolete(*self.span, ObsoleteMultipleLocalDecl);\n         }\n-        return @spanned(lo, self.last_span.hi, decl_local(local));\n+        return @spanned(lo, self.last_span.hi, DeclLocal(local));\n     }\n \n     // parse a structure field\n@@ -3132,7 +3132,7 @@ impl Parser {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&self, item_attrs: ~[Attribute]) -> @stmt {\n+    pub fn parse_stmt(&self, item_attrs: ~[Attribute]) -> @Stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, found_attrs: bool) {\n@@ -3147,7 +3147,7 @@ impl Parser {\n             check_expected_item(self, !item_attrs.is_empty());\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n-            return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n+            return @spanned(lo, decl.span.hi, StmtDecl(decl, self.get_id()));\n         } else if is_ident(&*self.token)\n             && !token::is_any_keyword(self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n@@ -3186,12 +3186,12 @@ impl Parser {\n             let hi = self.span.hi;\n \n             if id == token::special_idents::invalid {\n-                return @spanned(lo, hi, stmt_mac(\n+                return @spanned(lo, hi, StmtMac(\n                     spanned(lo, hi, mac_invoc_tt(pth, tts)), false));\n             } else {\n                 // if it has a special ident, it's definitely an item\n-                return @spanned(lo, hi, stmt_decl(\n-                    @spanned(lo, hi, decl_item(\n+                return @spanned(lo, hi, StmtDecl(\n+                    @spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             item_mac(spanned(lo, hi, mac_invoc_tt(pth, tts))),\n@@ -3204,8 +3204,8 @@ impl Parser {\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 iovi_item(i) => {\n                     let hi = i.span.hi;\n-                    let decl = @spanned(lo, hi, decl_item(i));\n-                    return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n+                    let decl = @spanned(lo, hi, DeclItem(i));\n+                    return @spanned(lo, hi, StmtDecl(decl, self.get_id()));\n                 }\n                 iovi_view_item(vi) => {\n                     self.span_fatal(vi.span,\n@@ -3221,12 +3221,12 @@ impl Parser {\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-            return @spanned(lo, e.span.hi, stmt_expr(e, self.get_id()));\n+            return @spanned(lo, e.span.hi, StmtExpr(e, self.get_id()));\n         }\n     }\n \n     // is this expression a successfully-parsed statement?\n-    fn expr_is_complete(&self, e: @expr) -> bool {\n+    fn expr_is_complete(&self, e: @Expr) -> bool {\n         return *self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n     }\n@@ -3284,9 +3284,9 @@ impl Parser {\n                                             false, false);\n \n         for item in items.iter() {\n-            let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n+            let decl = @spanned(item.span.lo, item.span.hi, DeclItem(*item));\n             stmts.push(@spanned(item.span.lo, item.span.hi,\n-                                stmt_decl(decl, self.get_id())));\n+                                StmtDecl(decl, self.get_id())));\n         }\n \n         let mut attributes_box = attrs_remaining;\n@@ -3310,7 +3310,7 @@ impl Parser {\n                     let stmt = self.parse_stmt(attributes_box);\n                     attributes_box = ~[];\n                     match stmt.node {\n-                        stmt_expr(e, stmt_id) => {\n+                        StmtExpr(e, stmt_id) => {\n                             // expression without semicolon\n                             if classify::stmt_ends_with_semi(stmt) {\n                                 // Just check for errors and recover; do not eat semicolon yet.\n@@ -3321,7 +3321,7 @@ impl Parser {\n                                 token::SEMI => {\n                                     self.bump();\n                                     stmts.push(@codemap::Spanned {\n-                                        node: stmt_semi(e, stmt_id),\n+                                        node: StmtSemi(e, stmt_id),\n                                         span: stmt.span,\n                                     });\n                                 }\n@@ -3333,7 +3333,7 @@ impl Parser {\n                                 }\n                             }\n                         }\n-                        stmt_mac(ref m, _) => {\n+                        StmtMac(ref m, _) => {\n                             // statement macro; might be an expr\n                             let has_semi;\n                             match *self.token {\n@@ -3358,7 +3358,7 @@ impl Parser {\n                             if has_semi {\n                                 self.bump();\n                                 stmts.push(@codemap::Spanned {\n-                                    node: stmt_mac((*m).clone(), true),\n+                                    node: StmtMac((*m).clone(), true),\n                                     span: stmt.span,\n                                 });\n                             }\n@@ -3531,7 +3531,7 @@ impl Parser {\n         &fn(&Parser) -> arg_or_capture_item\n     ) -> (explicit_self, fn_decl) {\n         fn maybe_parse_explicit_self(\n-            cnstr: &fn(v: mutability) -> ast::explicit_self_,\n+            cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n             p: &Parser\n         ) -> ast::explicit_self_ {\n             // We need to make sure it isn't a mode or a type\n@@ -3562,7 +3562,7 @@ impl Parser {\n             if this.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                 this.bump();\n                 this.expect_self_ident();\n-                sty_region(None, m_imm)\n+                sty_region(None, MutImmutable)\n             } else if this.look_ahead(1, |t| this.token_is_mutability(t)) &&\n                     this.look_ahead(2,\n                                     |t| token::is_keyword(keywords::Self,\n@@ -3578,7 +3578,7 @@ impl Parser {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n-                sty_region(Some(lifetime), m_imm)\n+                sty_region(Some(lifetime), MutImmutable)\n             } else if this.look_ahead(1, |t| this.token_is_lifetime(t)) &&\n                       this.look_ahead(2, |t| this.token_is_mutability(t)) &&\n                       this.look_ahead(3, |t| token::is_keyword(keywords::Self,\n@@ -3607,7 +3607,7 @@ impl Parser {\n           }\n           token::TILDE => {\n             maybe_parse_explicit_self(|mutability| {\n-                if mutability != m_imm {\n+                if mutability != MutImmutable {\n                     self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n                 }\n                 sty_uniq\n@@ -4077,7 +4077,7 @@ impl Parser {\n     }\n \n     fn parse_item_const(&self) -> item_info {\n-        let m = if self.eat_keyword(keywords::Mut) {m_mutbl} else {m_imm};\n+        let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);"}, {"sha": "1092b2ddf575dcf28759547973e3b45e1ca9a71d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02", "patch": "@@ -100,9 +100,9 @@ pub enum Token {\n pub enum nonterminal {\n     nt_item(@ast::item),\n     nt_block(~ast::Block),\n-    nt_stmt(@ast::stmt),\n-    nt_pat( @ast::pat),\n-    nt_expr(@ast::expr),\n+    nt_stmt(@ast::Stmt),\n+    nt_pat( @ast::Pat),\n+    nt_expr(@ast::Expr),\n     nt_ty(  ~ast::Ty),\n     nt_ident(~ast::Ident, bool),\n     nt_attr(@ast::Attribute),   // #[foo]\n@@ -353,26 +353,26 @@ pub mod special_idents {\n  * Maps a token to a record specifying the corresponding binary\n  * operator\n  */\n-pub fn token_to_binop(tok: &Token) -> Option<ast::binop> {\n+pub fn token_to_binop(tok: &Token) -> Option<ast::BinOp> {\n   match *tok {\n-      BINOP(STAR)    => Some(ast::mul),\n-      BINOP(SLASH)   => Some(ast::div),\n-      BINOP(PERCENT) => Some(ast::rem),\n-      BINOP(PLUS)    => Some(ast::add),\n-      BINOP(MINUS)   => Some(ast::subtract),\n-      BINOP(SHL)     => Some(ast::shl),\n-      BINOP(SHR)     => Some(ast::shr),\n-      BINOP(AND)     => Some(ast::bitand),\n-      BINOP(CARET)   => Some(ast::bitxor),\n-      BINOP(OR)      => Some(ast::bitor),\n-      LT             => Some(ast::lt),\n-      LE             => Some(ast::le),\n-      GE             => Some(ast::ge),\n-      GT             => Some(ast::gt),\n-      EQEQ           => Some(ast::eq),\n-      NE             => Some(ast::ne),\n-      ANDAND         => Some(ast::and),\n-      OROR           => Some(ast::or),\n+      BINOP(STAR)    => Some(ast::BiMul),\n+      BINOP(SLASH)   => Some(ast::BiDiv),\n+      BINOP(PERCENT) => Some(ast::BiRem),\n+      BINOP(PLUS)    => Some(ast::BiAdd),\n+      BINOP(MINUS)   => Some(ast::BiSub),\n+      BINOP(SHL)     => Some(ast::BiShl),\n+      BINOP(SHR)     => Some(ast::BiShr),\n+      BINOP(AND)     => Some(ast::BiBitAnd),\n+      BINOP(CARET)   => Some(ast::BiBitXor),\n+      BINOP(OR)      => Some(ast::BiBitOr),\n+      LT             => Some(ast::BiLt),\n+      LE             => Some(ast::BiLe),\n+      GE             => Some(ast::BiGe),\n+      GT             => Some(ast::BiGt),\n+      EQEQ           => Some(ast::BiEq),\n+      NE             => Some(ast::BiNe),\n+      ANDAND         => Some(ast::BiAnd),\n+      OROR           => Some(ast::BiOr),\n       _              => None\n   }\n }"}, {"sha": "e1a0e1bf08da6fee4b88c5bebca7c89c369f95f4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02"}, {"sha": "ca1e53f7fcd9e5c8bdef7143c930e7ae86625c2c", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02"}, {"sha": "ae2044cb979527a3e801f2b98cbf24b0c45792d2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74190853373c7963d933e2fb5c2ac2f761fdbc02/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=74190853373c7963d933e2fb5c2ac2f761fdbc02"}]}