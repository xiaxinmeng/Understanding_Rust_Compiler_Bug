{"sha": "76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZmM5YmU1YTE2MzRjOGI3ZWJmNzY2ZjUxYWQ1OTRkOTAxMmZlOWM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T02:46:35Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:54Z"}, "message": "std: convert each_split_str to an iterator", "tree": {"sha": "27d905bdb69320044890e4e257e0217bfaa57ead", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27d905bdb69320044890e4e257e0217bfaa57ead"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "html_url": "https://github.com/rust-lang/rust/commit/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee41ad4168a0e9316d8621ad5ceda2208c553f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee41ad4168a0e9316d8621ad5ceda2208c553f76", "html_url": "https://github.com/rust-lang/rust/commit/ee41ad4168a0e9316d8621ad5ceda2208c553f76"}], "stats": {"total": 231, "additions": 114, "deletions": 117}, "files": [{"sha": "ffa3c815b289d4960de97a8a2c566903118832b2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "patch": "@@ -40,7 +40,7 @@ use syntax::visit::{visit_foreign_item, visit_item};\n use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n-use core::str::each_split_str;\n+use core::iterator::IteratorUtil;\n use core::str;\n use core::uint;\n use core::vec;\n@@ -1737,8 +1737,7 @@ impl Resolver {\n                         entry: %s (%?)\",\n                     path_string, def_like);\n \n-            let mut pieces = ~[];\n-            for each_split_str(path_string, \"::\") |s| { pieces.push(s.to_owned()) }\n+            let mut pieces: ~[&str] = path_string.split_str_iter(\"::\").collect();\n             let final_ident_str = pieces.pop();\n             let final_ident = self.session.ident_of(final_ident_str);\n "}, {"sha": "46bf0b08c1039acadb3d8459e9cde8caaa65e3fa", "filename": "src/libstd/str.rs", "status": "modified", "additions": 112, "deletions": 114, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "patch": "@@ -667,6 +667,7 @@ impl<'self> StrCharSplitSeparator for extern \"Rust\" fn(char) -> bool {\n }\n \n impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n+    #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n \n@@ -709,88 +710,69 @@ impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIte\n     }\n }\n \n-// See Issue #1932 for why this is a naive search\n-fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n-                       f: &fn(uint, uint) -> bool) -> bool {\n-    let (sep_len, l) = (sep.len(), s.len());\n-    assert!(sep_len > 0u);\n-    let mut (i, match_start, match_i) = (0u, 0u, 0u);\n+/// An iterator over the start and end indicies of the matches of a\n+/// substring within a larger string\n+pub struct StrMatchesIndexIterator<'self> {\n+    priv haystack: &'self str,\n+    priv needle: &'self str,\n+    priv position: uint,\n+}\n \n-    while i < l {\n-        if s[i] == sep[match_i] {\n-            if match_i == 0u { match_start = i; }\n-            match_i += 1u;\n-            // Found a match\n-            if match_i == sep_len {\n-                if !f(match_start, i + 1u) { return false; }\n-                match_i = 0u;\n-            }\n-            i += 1u;\n-        } else {\n-            // Failed match, backtrack\n-            if match_i > 0u {\n-                match_i = 0u;\n-                i = match_start + 1u;\n+/// An iterator over the substrings of a string separated by a given\n+/// search string\n+pub struct StrStrSplitIterator<'self> {\n+    priv it: StrMatchesIndexIterator<'self>,\n+    priv last_end: uint,\n+    priv finished: bool\n+}\n+\n+impl<'self> Iterator<(uint, uint)> for StrMatchesIndexIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        // See Issue #1932 for why this is a naive search\n+        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n+        let mut (match_start, match_i) = (0, 0);\n+\n+        while self.position < h_len {\n+            if self.haystack[self.position] == self.needle[match_i] {\n+                if match_i == 0 { match_start = self.position; }\n+                match_i += 1;\n+                self.position += 1;\n+\n+                if match_i == n_len {\n+                    // found a match!\n+                    return Some((match_start, self.position));\n+                }\n             } else {\n-                i += 1u;\n+                // failed match, backtrack\n+                if match_i > 0 {\n+                    match_i = 0;\n+                    self.position = match_start;\n+                }\n+                self.position += 1;\n             }\n         }\n+        None\n     }\n-    return true;\n-}\n-\n-fn iter_between_matches<'a,'b>(s: &'a str,\n-                               sep: &'b str,\n-                               f: &fn(uint, uint) -> bool) -> bool {\n-    let mut last_end = 0u;\n-    for iter_matches(s, sep) |from, to| {\n-        if !f(last_end, from) { return false; }\n-        last_end = to;\n-    }\n-    return f(last_end, s.len());\n }\n \n-/**\n- * Splits a string into a vector of the substrings separated by a given string\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let mut v = ~[];\n- * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n- * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n- * ~~~\n- */\n-pub fn each_split_str<'a,'b>(s: &'a str,\n-                             sep: &'b str,\n-                             it: &fn(&'a str) -> bool) -> bool {\n-    for iter_between_matches(s, sep) |from, to| {\n-        if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return false; }\n-    }\n-    return true;\n-}\n+impl<'self> Iterator<&'self str> for StrStrSplitIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self str> {\n+        if self.finished { return None; }\n \n-/**\n- * Splits the string `s` based on `sep`, yielding all splits to the iterator\n- * function provide\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let mut v = ~[];\n- * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n- * assert!(v == [\"XXX\", \"YYY\"]);\n- * ~~~\n- */\n-pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n-                                      sep: &'b str,\n-                                      it: &fn(&'a str) -> bool) -> bool {\n-    for iter_between_matches(s, sep) |from, to| {\n-        if to > from {\n-            if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return false; }\n+        match self.it.next() {\n+            Some((from, to)) => {\n+                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                self.last_end = to;\n+                ret\n+            }\n+            None => {\n+                self.finished = true;\n+                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+            }\n         }\n     }\n-    return true;\n }\n \n /// Levenshtein Distance between two strings\n@@ -929,15 +911,13 @@ pub fn each_split_within<'a>(ss: &'a str,\n  * The original string with all occurances of `from` replaced with `to`\n  */\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n-    let mut (result, first) = (~\"\", true);\n-    for iter_between_matches(s, from) |start, end| {\n-        if first {\n-            first = false;\n-        } else {\n-            push_str(&mut result, to);\n-        }\n-        push_str(&mut result, unsafe{raw::slice_bytes(s, start, end)});\n+    let mut (result, last_end) = (~\"\", 0);\n+    for s.matches_index_iter(from).advance |(start, end)| {\n+        result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n+        result.push_str(to);\n+        last_end = end;\n     }\n+    result.push_str(unsafe{raw::slice_bytes(s, last_end, s.len())});\n     result\n }\n \n@@ -2441,6 +2421,20 @@ pub trait StrSlice<'self> {\n     fn split_options_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep,\n                                                       count: uint, allow_trailing_empty: bool)\n         -> StrCharSplitIterator<'self, Sep>;\n+    /// An iterator over the start and end indices of each match of\n+    /// `sep` within `self`.\n+    fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self>;\n+    /**\n+     * An iterator over the substrings of `self` separated by `sep`.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let v: ~[&str] = \".XXX.YYY.\".split_str_iter(\".\").collect()\n+     * assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n+     * ~~~\n+     */\n+    fn split_str_iter(&self, &'self str) -> StrStrSplitIterator<'self>;\n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`).\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n@@ -2454,7 +2448,6 @@ pub trait StrSlice<'self> {\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool;\n     fn starts_with<'a>(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n@@ -2529,6 +2522,21 @@ impl<'self> StrSlice<'self> for &'self str {\n             only_ascii: only_ascii\n         }\n     }\n+    fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self> {\n+        assert!(!sep.is_empty())\n+        StrMatchesIndexIterator {\n+            haystack: *self,\n+            needle: sep,\n+            position: 0\n+        }\n+    }\n+    fn split_str_iter(&self, sep: &'self str) -> StrStrSplitIterator<'self> {\n+        StrStrSplitIterator {\n+            it: self.matches_index_iter(sep),\n+            last_end: 0,\n+            finished: false\n+        }\n+    }\n \n     fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n         self.split_options_iter('\\n', self.len(), false)\n@@ -2581,15 +2589,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         assert!(is_char_boundary(*self, end));\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n-    /**\n-     * Splits a string into a vector of the substrings separated by a given\n-     * string\n-     */\n-    #[inline]\n-    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool {\n-        each_split_str(*self, sep, it)\n-    }\n-    /// Returns true if one string starts with another\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         starts_with(*self, needle)\n@@ -2836,30 +2835,6 @@ mod tests {\n         let _cc3 = pop_char(&mut data);\n     }\n \n-    #[test]\n-    fn test_split_str() {\n-        fn t<'a>(s: &str, sep: &'a str, u: &[~str]) {\n-            let mut v = ~[];\n-            for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        t(\"--1233345--\", \"12345\", [~\"--1233345--\"]);\n-        t(\"abc::hello::there\", \"::\", [~\"abc\", ~\"hello\", ~\"there\"]);\n-        t(\"::hello::there\", \"::\", [~\"\", ~\"hello\", ~\"there\"]);\n-        t(\"hello::there::\", \"::\", [~\"hello\", ~\"there\", ~\"\"]);\n-        t(\"::hello::there::\", \"::\", [~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzzYYYzz\", \"zz\", [~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n-        t(\"zzXXXzYYYz\", \"XXX\", [~\"zz\", ~\"zYYYz\"]);\n-        t(\".XXX.YYY.\", \".\", [~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n-        t(\"\", \".\", [~\"\"]);\n-        t(\"zz\", \"zz\", [~\"\",~\"\"]);\n-        t(\"ok\", \"z\", [~\"ok\"]);\n-        t(\"zzz\", \"zz\", [~\"\",~\"z\"]);\n-        t(\"zzzzz\", \"zz\", [~\"\",~\"\",~\"z\"]);\n-    }\n-\n-\n     #[test]\n     fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n@@ -3727,4 +3702,27 @@ mod tests {\n         let lines: ~[&str] = data.line_iter().collect();\n         assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n+\n+\n+    #[test]\n+    fn test_split_str_iterator() {\n+        fn t<'a>(s: &str, sep: &'a str, u: ~[&str]) {\n+            let v: ~[&str] = s.split_str_iter(sep).collect();\n+            assert_eq!(v, u);\n+        }\n+        t(\"--1233345--\", \"12345\", ~[\"--1233345--\"]);\n+        t(\"abc::hello::there\", \"::\", ~[\"abc\", \"hello\", \"there\"]);\n+        t(\"::hello::there\", \"::\", ~[\"\", \"hello\", \"there\"]);\n+        t(\"hello::there::\", \"::\", ~[\"hello\", \"there\", \"\"]);\n+        t(\"::hello::there::\", \"::\", ~[\"\", \"hello\", \"there\", \"\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzzYYYzz\", \"zz\", ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"zzXXXzYYYz\", \"XXX\", ~[\"zz\", \"zYYYz\"]);\n+        t(\".XXX.YYY.\", \".\", ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"\", \".\", ~[\"\"]);\n+        t(\"zz\", \"zz\", ~[\"\",\"\"]);\n+        t(\"ok\", \"z\", ~[\"ok\"]);\n+        t(\"zzz\", \"zz\", ~[\"\",\"z\"]);\n+        t(\"zzzzz\", \"zz\", ~[\"\",\"\",\"z\"]);\n+    }\n }"}]}