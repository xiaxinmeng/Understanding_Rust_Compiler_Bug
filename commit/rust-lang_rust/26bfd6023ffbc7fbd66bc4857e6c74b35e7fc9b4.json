{"sha": "26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "node_id": "C_kwDOAAsO6NoAKDI2YmZkNjAyM2ZmYmM3ZmJkNjZiYzQ4NTdlNmM3NGIzNWU3ZmM5YjQ", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-11-14T19:13:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-12T13:54:09Z"}, "message": "Switch parser to use tokens", "tree": {"sha": "59beae86c4b66f623484c0acfade46f2bc9a16dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59beae86c4b66f623484c0acfade46f2bc9a16dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "html_url": "https://github.com/rust-lang/rust/commit/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5ad0f3ca03e4ffbdfafb46a5e12d23059bc760e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ad0f3ca03e4ffbdfafb46a5e12d23059bc760e", "html_url": "https://github.com/rust-lang/rust/commit/d5ad0f3ca03e4ffbdfafb46a5e12d23059bc760e"}], "stats": {"total": 100, "additions": 47, "deletions": 53}, "files": [{"sha": "4b9c579a0521230ed9c4314f4133fa8ed68a0850", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "patch": "@@ -296,10 +296,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n         T![&] => {\n             m = p.start();\n             p.bump(T![&]);\n-            if p.at(IDENT)\n-                && p.at_contextual_kw(\"raw\")\n-                && (p.nth_at(1, T![mut]) || p.nth_at(1, T![const]))\n-            {\n+            if p.at_contextual_kw(T![raw]) && (p.nth_at(1, T![mut]) || p.nth_at(1, T![const])) {\n                 p.bump_remap(T![raw]);\n                 p.bump_any();\n             } else {"}, {"sha": "896efaf37572dd36d1b175c06156048a729aabe1", "filename": "crates/parser/src/grammar/items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs?ref=26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "patch": "@@ -122,14 +122,14 @@ pub(super) fn opt_item(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n         has_mods = true;\n         abi(p);\n     }\n-    if p.at(IDENT) && p.at_contextual_kw(\"auto\") && p.nth(1) == T![trait] {\n+    if p.at_contextual_kw(T![auto]) && p.nth(1) == T![trait] {\n         p.bump_remap(T![auto]);\n         has_mods = true;\n     }\n \n     // test default_item\n     // default impl T for Foo {}\n-    if p.at(IDENT) && p.at_contextual_kw(\"default\") {\n+    if p.at_contextual_kw(T![default]) {\n         match p.nth(1) {\n             T![fn] | T![type] | T![const] | T![impl] => {\n                 p.bump_remap(T![default]);\n@@ -176,7 +176,7 @@ pub(super) fn opt_item(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n \n     // test existential_type\n     // existential type Foo: Fn() -> usize;\n-    if p.at(IDENT) && p.at_contextual_kw(\"existential\") && p.nth(1) == T![type] {\n+    if p.at_contextual_kw(T![existential]) && p.nth(1) == T![type] {\n         p.bump_remap(T![existential]);\n         has_mods = true;\n     }\n@@ -224,10 +224,10 @@ fn opt_item_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n         T![type] => type_alias(p, m),\n         T![struct] => adt::strukt(p, m),\n         T![enum] => adt::enum_(p, m),\n-        IDENT if p.at_contextual_kw(\"union\") && p.nth(1) == IDENT => adt::union(p, m),\n+        IDENT if p.at_contextual_kw(T![union]) && p.nth(1) == IDENT => adt::union(p, m),\n \n         T![macro] => macro_def(p, m),\n-        IDENT if p.at_contextual_kw(\"macro_rules\") && p.nth(1) == BANG => macro_rules(p, m),\n+        IDENT if p.at_contextual_kw(T![macro_rules]) && p.nth(1) == BANG => macro_rules(p, m),\n \n         T![const] if (la == IDENT || la == T![_] || la == T![mut]) => consts::konst(p, m),\n         T![static] => consts::static_(p, m),\n@@ -319,7 +319,7 @@ pub(crate) fn extern_item_list(p: &mut Parser) {\n }\n \n fn macro_rules(p: &mut Parser, m: Marker) {\n-    assert!(p.at_contextual_kw(\"macro_rules\"));\n+    assert!(p.at_contextual_kw(T![macro_rules]));\n     p.bump_remap(T![macro_rules]);\n     p.expect(T![!]);\n "}, {"sha": "83b7ff05786693085344866925c7cd7fe51464ac", "filename": "crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "patch": "@@ -10,7 +10,7 @@ pub(super) fn strukt(p: &mut Parser, m: Marker) {\n // test union_item\n // struct U { i: i32, f: f32 }\n pub(super) fn union(p: &mut Parser, m: Marker) {\n-    assert!(p.at_contextual_kw(\"union\"));\n+    assert!(p.at_contextual_kw(T![union]));\n     p.bump_remap(T![union]);\n     struct_or_union(p, m, false);\n }"}, {"sha": "fd447194bf933476f208b33f56ccad9a9821a9b8", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "patch": "@@ -26,6 +26,8 @@ pub(crate) use token_set::TokenSet;\n \n pub use syntax_kind::SyntaxKind;\n \n+use crate::tokens::Tokens;\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParseError(pub Box<String>);\n \n@@ -53,6 +55,7 @@ pub struct Token {\n \n     /// Is the current token joined to the next one (`> >` vs `>>`).\n     pub is_jointed_to_next: bool,\n+    pub contextual_kw: SyntaxKind,\n }\n \n /// `TreeSink` abstracts details of a particular syntax tree implementation.\n@@ -93,15 +96,11 @@ pub enum ParserEntryPoint {\n }\n \n /// Parse given tokens into the given sink as a rust file.\n-pub fn parse_source_file(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse(token_source, tree_sink, ParserEntryPoint::SourceFile);\n+pub fn parse_source_file(tokens: &Tokens, tree_sink: &mut dyn TreeSink) {\n+    parse(tokens, tree_sink, ParserEntryPoint::SourceFile);\n }\n \n-pub fn parse(\n-    token_source: &mut dyn TokenSource,\n-    tree_sink: &mut dyn TreeSink,\n-    entry_point: ParserEntryPoint,\n-) {\n+pub fn parse(tokens: &Tokens, tree_sink: &mut dyn TreeSink, entry_point: ParserEntryPoint) {\n     let entry_point: fn(&'_ mut parser::Parser) = match entry_point {\n         ParserEntryPoint::SourceFile => grammar::entry_points::source_file,\n         ParserEntryPoint::Path => grammar::entry_points::path,\n@@ -119,7 +118,7 @@ pub fn parse(\n         ParserEntryPoint::Attr => grammar::entry_points::attr,\n     };\n \n-    let mut p = parser::Parser::new(token_source);\n+    let mut p = parser::Parser::new(tokens);\n     entry_point(&mut p);\n     let events = p.finish();\n     event::process(tree_sink, events);\n@@ -142,9 +141,9 @@ impl Reparser {\n     ///\n     /// Tokens must start with `{`, end with `}` and form a valid brace\n     /// sequence.\n-    pub fn parse(self, token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    pub fn parse(self, tokens: &Tokens, tree_sink: &mut dyn TreeSink) {\n         let Reparser(r) = self;\n-        let mut p = parser::Parser::new(token_source);\n+        let mut p = parser::Parser::new(tokens);\n         r(&mut p);\n         let events = p.finish();\n         event::process(tree_sink, events);"}, {"sha": "759f87f4966802a967b2d41618d392e4b515cb8a", "filename": "crates/parser/src/parser.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "patch": "@@ -7,9 +7,10 @@ use limit::Limit;\n \n use crate::{\n     event::Event,\n+    tokens::Tokens,\n     ParseError,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n-    TokenSet, TokenSource, T,\n+    TokenSet, T,\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -22,16 +23,17 @@ use crate::{\n /// \"start expression, consume number literal,\n /// finish expression\". See `Event` docs for more.\n pub(crate) struct Parser<'t> {\n-    token_source: &'t mut dyn TokenSource,\n+    tokens: &'t Tokens,\n+    pos: usize,\n     events: Vec<Event>,\n     steps: Cell<u32>,\n }\n \n static PARSER_STEP_LIMIT: Limit = Limit::new(15_000_000);\n \n impl<'t> Parser<'t> {\n-    pub(super) fn new(token_source: &'t mut dyn TokenSource) -> Parser<'t> {\n-        Parser { token_source, events: Vec::new(), steps: Cell::new(0) }\n+    pub(super) fn new(tokens: &'t Tokens) -> Parser<'t> {\n+        Parser { tokens, pos: 0, events: Vec::new(), steps: Cell::new(0) }\n     }\n \n     pub(crate) fn finish(self) -> Vec<Event> {\n@@ -54,7 +56,7 @@ impl<'t> Parser<'t> {\n         assert!(PARSER_STEP_LIMIT.check(steps as usize).is_ok(), \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        self.token_source.lookahead_nth(n).kind\n+        self.tokens.get(self.pos + n).kind\n     }\n \n     /// Checks if the current token is `kind`.\n@@ -90,7 +92,7 @@ impl<'t> Parser<'t> {\n             T![<<=] => self.at_composite3(n, T![<], T![<], T![=]),\n             T![>>=] => self.at_composite3(n, T![>], T![>], T![=]),\n \n-            _ => self.token_source.lookahead_nth(n).kind == kind,\n+            _ => self.tokens.get(self.pos + n).kind == kind,\n         }\n     }\n \n@@ -129,24 +131,24 @@ impl<'t> Parser<'t> {\n     }\n \n     fn at_composite2(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind) -> bool {\n-        let t1 = self.token_source.lookahead_nth(n);\n+        let t1 = self.tokens.get(self.pos + n);\n         if t1.kind != k1 || !t1.is_jointed_to_next {\n             return false;\n         }\n-        let t2 = self.token_source.lookahead_nth(n + 1);\n+        let t2 = self.tokens.get(self.pos + n + 1);\n         t2.kind == k2\n     }\n \n     fn at_composite3(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind, k3: SyntaxKind) -> bool {\n-        let t1 = self.token_source.lookahead_nth(n);\n+        let t1 = self.tokens.get(self.pos + n);\n         if t1.kind != k1 || !t1.is_jointed_to_next {\n             return false;\n         }\n-        let t2 = self.token_source.lookahead_nth(n + 1);\n+        let t2 = self.tokens.get(self.pos + n + 1);\n         if t2.kind != k2 || !t2.is_jointed_to_next {\n             return false;\n         }\n-        let t3 = self.token_source.lookahead_nth(n + 2);\n+        let t3 = self.tokens.get(self.pos + n + 2);\n         t3.kind == k3\n     }\n \n@@ -156,8 +158,8 @@ impl<'t> Parser<'t> {\n     }\n \n     /// Checks if the current token is contextual keyword with text `t`.\n-    pub(crate) fn at_contextual_kw(&self, kw: &str) -> bool {\n-        self.token_source.is_keyword(kw)\n+    pub(crate) fn at_contextual_kw(&self, kw: SyntaxKind) -> bool {\n+        self.tokens.get(self.pos).contextual_kw == kw\n     }\n \n     /// Starts a new node in the syntax tree. All nodes and tokens\n@@ -243,10 +245,7 @@ impl<'t> Parser<'t> {\n     }\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n-        for _ in 0..n_raw_tokens {\n-            self.token_source.bump();\n-        }\n-\n+        self.pos += n_raw_tokens as usize;\n         self.push_event(Event::Token { kind, n_raw_tokens });\n     }\n "}, {"sha": "495d9713ea9d6e3a08b7086ef0ffa001bb3654f9", "filename": "crates/parser/src/tokens.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4/crates%2Fparser%2Fsrc%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftokens.rs?ref=26bfd6023ffbc7fbd66bc4857e6c74b35e7fc9b4", "patch": "@@ -1,27 +1,26 @@\n-use crate::SyntaxKind;\n+use crate::{SyntaxKind, Token};\n \n+#[allow(non_camel_case_types)]\n type bits = u64;\n \n-pub type IdentKind = u8;\n-\n /// Main input to the parser.\n ///\n /// A sequence of tokens represented internally as a struct of arrays.\n #[derive(Default)]\n pub struct Tokens {\n     kind: Vec<SyntaxKind>,\n     joint: Vec<bits>,\n-    ident_kind: Vec<IdentKind>,\n+    contextual_kw: Vec<SyntaxKind>,\n }\n \n impl Tokens {\n     pub fn push(&mut self, was_joint: bool, kind: SyntaxKind) {\n-        self.push_impl(was_joint, kind, 0)\n+        self.push_impl(was_joint, kind, SyntaxKind::EOF)\n     }\n-    pub fn push_ident(&mut self, ident_kind: IdentKind) {\n-        self.push_impl(false, SyntaxKind::IDENT, ident_kind)\n+    pub fn push_ident(&mut self, contextual_kw: SyntaxKind) {\n+        self.push_impl(false, SyntaxKind::IDENT, contextual_kw)\n     }\n-    fn push_impl(&mut self, was_joint: bool, kind: SyntaxKind, ctx: IdentKind) {\n+    fn push_impl(&mut self, was_joint: bool, kind: SyntaxKind, contextual_kw: SyntaxKind) {\n         let idx = self.len();\n         if idx % (bits::BITS as usize) == 0 {\n             self.joint.push(0);\n@@ -30,7 +29,7 @@ impl Tokens {\n             self.set_joint(idx - 1);\n         }\n         self.kind.push(kind);\n-        self.ident_kind.push(ctx);\n+        self.contextual_kw.push(contextual_kw);\n     }\n     fn set_joint(&mut self, n: usize) {\n         let (idx, b_idx) = self.bit_index(n);\n@@ -49,18 +48,18 @@ impl Tokens {\n     pub fn len(&self) -> usize {\n         self.kind.len()\n     }\n-    pub(crate) fn get(&self, idx: usize) -> (SyntaxKind, bool, IdentKind) {\n+    pub(crate) fn get(&self, idx: usize) -> Token {\n         if idx > self.len() {\n             return self.eof();\n         }\n         let kind = self.kind[idx];\n-        let joint = self.get_joint(idx);\n-        let ident_kind = self.ident_kind[idx];\n-        (kind, joint, ident_kind)\n+        let is_jointed_to_next = self.get_joint(idx);\n+        let contextual_kw = self.contextual_kw[idx];\n+        Token { kind, is_jointed_to_next, contextual_kw }\n     }\n \n     #[cold]\n-    fn eof(&self) -> (SyntaxKind, bool, IdentKind) {\n-        (SyntaxKind::EOF, false, 0)\n+    fn eof(&self) -> Token {\n+        Token { kind: SyntaxKind::EOF, is_jointed_to_next: false, contextual_kw: SyntaxKind::EOF }\n     }\n }"}]}