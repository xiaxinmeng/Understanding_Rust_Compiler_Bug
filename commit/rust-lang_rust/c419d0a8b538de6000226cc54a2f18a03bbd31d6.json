{"sha": "c419d0a8b538de6000226cc54a2f18a03bbd31d6", "node_id": "C_kwDOAAsO6NoAKGM0MTlkMGE4YjUzOGRlNjAwMDIyNmNjNTRhMmYxOGEwM2JiZDMxZDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-18T15:57:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-18T15:57:37Z"}, "message": "Auto merge of #9136 - smoelius:enhance-needless-borrow, r=Jarcho\n\nEnhance `needless_borrow` to consider trait implementations\n\nThe proposed enhancement causes `needless_borrow` to suggest removing `&` from `&e` when `&e` is an argument position requiring trait implementations, and `e` implements the required traits. Example:\n```\nerror: the borrowed expression implements the required traits\n  --> $DIR/needless_borrow.rs:131:51\n   |\nLL |     let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n   |                                                   ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n```\n\nr? `@Jarcho`\n\nchangelog: Enhance `needless_borrow` to consider trait implementations", "tree": {"sha": "b7fd53474938b37734582ac023fbaad386a27d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7fd53474938b37734582ac023fbaad386a27d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c419d0a8b538de6000226cc54a2f18a03bbd31d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c419d0a8b538de6000226cc54a2f18a03bbd31d6", "html_url": "https://github.com/rust-lang/rust/commit/c419d0a8b538de6000226cc54a2f18a03bbd31d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c419d0a8b538de6000226cc54a2f18a03bbd31d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "849c1c0465426339f42e8491e861ad0473b9a062", "url": "https://api.github.com/repos/rust-lang/rust/commits/849c1c0465426339f42e8491e861ad0473b9a062", "html_url": "https://github.com/rust-lang/rust/commit/849c1c0465426339f42e8491e861ad0473b9a062"}, {"sha": "032f112745d2632fc37175fad7bab98215062586", "url": "https://api.github.com/repos/rust-lang/rust/commits/032f112745d2632fc37175fad7bab98215062586", "html_url": "https://github.com/rust-lang/rust/commit/032f112745d2632fc37175fad7bab98215062586"}], "stats": {"total": 663, "additions": 585, "deletions": 78}, "files": [{"sha": "92b2771f3fe73aeccc27b51c1edd243108f0e35d", "filename": "clippy_dev/src/bless.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fbless.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -37,7 +37,7 @@ fn update_reference_file(test_output_entry: &DirEntry, ignore_timestamp: bool) {\n         return;\n     }\n \n-    let test_output_file = fs::read(&test_output_path).expect(\"Unable to read test output file\");\n+    let test_output_file = fs::read(test_output_path).expect(\"Unable to read test output file\");\n     let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n \n     if test_output_file != reference_file {"}, {"sha": "357cf6fc43aadada9baabbce3ac08cd70c5d0f93", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -46,7 +46,7 @@ pub fn run(check: bool, verbose: bool) {\n         // dependency\n         if fs::read_to_string(project_root.join(\"Cargo.toml\"))\n             .expect(\"Failed to read clippy Cargo.toml\")\n-            .contains(&\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\")\n+            .contains(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\")\n         {\n             return Err(CliError::IntellijSetupActive);\n         }\n@@ -193,10 +193,10 @@ fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n     let args = &[\"--version\"];\n \n     if context.verbose {\n-        println!(\"{}\", format_command(&program, &dir, args));\n+        println!(\"{}\", format_command(program, &dir, args));\n     }\n \n-    let output = Command::new(&program).current_dir(&dir).args(args.iter()).output()?;\n+    let output = Command::new(program).current_dir(&dir).args(args.iter()).output()?;\n \n     if output.status.success() {\n         Ok(())\n@@ -207,7 +207,7 @@ fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n         Err(CliError::RustfmtNotInstalled)\n     } else {\n         Err(CliError::CommandFailed(\n-            format_command(&program, &dir, args),\n+            format_command(program, &dir, args),\n             std::str::from_utf8(&output.stderr).unwrap_or(\"\").to_string(),\n         ))\n     }"}, {"sha": "c503142e5e4552b1cdc28877dca9ab3734ba2083", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -418,7 +418,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n             .expect(\"failed to find `impl_lint_pass` terminator\");\n \n         impl_lint_pass_end += impl_lint_pass_start;\n-        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(&lint_name_upper) {\n+        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(lint_name_upper) {\n             let mut lint_name_end = impl_lint_pass_start + (lint_name_pos + lint_name_upper.len());\n             for c in content[lint_name_end..impl_lint_pass_end].chars() {\n                 // Remove trailing whitespace\n@@ -451,7 +451,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n                 }\n \n                 let mut content =\n-                    fs::read_to_string(&path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n+                    fs::read_to_string(path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n \n                 eprintln!(\n                     \"warn: you will have to manually remove any code related to `{}` from `{}`\","}, {"sha": "e38704701ea64a947af8d894ab6945e53f698131", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 276, "deletions": 31, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -1,24 +1,31 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, ty_sig, variant_of_res};\n-use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n+use clippy_utils::ty::{contains_ty, expr_sig, is_copy, peel_mid_ty_refs, ty_sig, variant_of_res};\n+use clippy_utils::{fn_def_id, get_parent_expr, is_lint_allowed, meets_msrv, msrvs, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy, GenericArg, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n-    TraitItemKind, TyKind, UnOp,\n+    self as hir, def_id::DefId, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy,\n+    GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n+    Path, QPath, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n+use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Binder, BoundVariableKind, List, Ty, TyCtxt, TypeVisitable, TypeckResults};\n+use rustc_middle::ty::{\n+    self, subst::Subst, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n+    ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n+};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n-use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use std::collections::VecDeque;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -151,13 +158,27 @@ pub struct Dereferencing {\n     /// been finished. Note we can't lint at the end of every body as they can be nested within each\n     /// other.\n     current_body: Option<BodyId>,\n+\n     /// The list of locals currently being checked by the lint.\n     /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n     /// This is needed for or patterns where one of the branches can be linted, but another can not\n     /// be.\n     ///\n     /// e.g. `m!(x) | Foo::Bar(ref x)`\n     ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n+\n+    // `IntoIterator` for arrays requires Rust 1.53.\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Dereferencing {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Dereferencing::default()\n+        }\n+    }\n }\n \n struct StateData {\n@@ -170,6 +191,7 @@ struct StateData {\n struct DerefedBorrow {\n     count: usize,\n     msg: &'static str,\n+    snip_expr: Option<HirId>,\n }\n \n enum State {\n@@ -250,7 +272,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n         match (self.state.take(), kind) {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n-                let (position, adjustments) = walk_parents(cx, expr);\n+                let (position, adjustments) = walk_parents(cx, expr, self.msrv);\n \n                 match kind {\n                     RefOp::Deref => {\n@@ -331,20 +353,23 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         let deref_msg =\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n+                        let impl_msg = \"the borrowed expression implements the required traits\";\n \n-                        let (required_refs, msg) = if position.can_auto_borrow() {\n-                            (1, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        let (required_refs, msg, snip_expr) = if position.can_auto_borrow() {\n+                            (1, if deref_count == 1 { borrow_msg } else { deref_msg }, None)\n+                        } else if let Position::ImplArg(hir_id) = position {\n+                            (0, impl_msg, Some(hir_id))\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n                             if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n-                                (3, deref_msg)\n+                                (3, deref_msg, None)\n                             } else {\n-                                (2, deref_msg)\n+                                (2, deref_msg, None)\n                             }\n                         } else {\n-                            (2, deref_msg)\n+                            (2, deref_msg, None)\n                         };\n \n                         if deref_count >= required_refs {\n@@ -354,6 +379,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n                                     msg,\n+                                    snip_expr,\n                                 }),\n                                 StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n@@ -510,7 +536,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             spans: vec![pat.span],\n                             app,\n                             replacements: vec![(pat.span, snip.into())],\n-                            hir_id: pat.hir_id\n+                            hir_id: pat.hir_id,\n                         }),\n                     );\n                 }\n@@ -542,6 +568,8 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n             self.current_body = None;\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n fn try_parse_ref_op<'tcx>(\n@@ -594,6 +622,7 @@ enum Position {\n     /// The method is defined on a reference type. e.g. `impl Foo for &T`\n     MethodReceiverRefImpl,\n     Callee,\n+    ImplArg(HirId),\n     FieldAccess(Symbol),\n     Postfix,\n     Deref,\n@@ -630,7 +659,7 @@ impl Position {\n             | Self::Callee\n             | Self::FieldAccess(_)\n             | Self::Postfix => PREC_POSTFIX,\n-            Self::Deref => PREC_PREFIX,\n+            Self::ImplArg(_) | Self::Deref => PREC_PREFIX,\n             Self::DerefStable(p, _) | Self::ReborrowStable(p) | Self::Other(p) => p,\n         }\n     }\n@@ -639,8 +668,12 @@ impl Position {\n /// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n /// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n /// locations as those follow different rules.\n-#[allow(clippy::too_many_lines)]\n-fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n+#[expect(clippy::too_many_lines)]\n+fn walk_parents<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) -> (Position, &'tcx [Adjustment<'tcx>]) {\n     let mut adjustments = [].as_slice();\n     let mut precedence = 0i8;\n     let ctxt = e.span.ctxt();\n@@ -732,13 +765,20 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .iter()\n                     .position(|arg| arg.hir_id == child_id)\n                     .zip(expr_sig(cx, func))\n-                    .and_then(|(i, sig)| sig.input_with_hir(i))\n-                    .map(|(hir_ty, ty)| match hir_ty {\n-                        // Type inference for closures can depend on how they're called. Only go by the explicit\n-                        // types here.\n-                        Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n-                        None => ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n-                            .position_for_arg(),\n+                    .and_then(|(i, sig)| {\n+                        sig.input_with_hir(i).map(|(hir_ty, ty)| match hir_ty {\n+                            // Type inference for closures can depend on how they're called. Only go by the explicit\n+                            // types here.\n+                            Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n+                            None => {\n+                                if let ty::Param(param_ty) = ty.skip_binder().kind() {\n+                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                } else {\n+                                    ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                                        .position_for_arg()\n+                                }\n+                            },\n+                        })\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -779,12 +819,17 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            ty_auto_deref_stability(\n-                                cx,\n-                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                precedence,\n-                            )\n-                            .position_for_arg()\n+                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n+                            if let ty::Param(param_ty) = ty.kind() {\n+                                needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                            } else {\n+                                ty_auto_deref_stability(\n+                                    cx,\n+                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                    precedence,\n+                                )\n+                                .position_for_arg()\n+                            }\n                         }\n                     })\n                 },\n@@ -946,6 +991,205 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+// Checks whether:\n+// * child is an expression of the form `&e` in an argument position requiring an `impl Trait`\n+// * `e`'s type implements `Trait` and is copyable\n+// If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n+//   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n+// be moved, but it cannot be.\n+fn needless_borrow_impl_arg_position<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    parent: &Expr<'tcx>,\n+    arg_index: usize,\n+    param_ty: ParamTy,\n+    mut expr: &Expr<'tcx>,\n+    precedence: i8,\n+    msrv: Option<RustcVersion>,\n+) -> Position {\n+    let destruct_trait_def_id = cx.tcx.lang_items().destruct_trait();\n+    let sized_trait_def_id = cx.tcx.lang_items().sized_trait();\n+\n+    let Some(callee_def_id) = fn_def_id(cx, parent) else { return Position::Other(precedence) };\n+    let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+    let substs_with_expr_ty = cx\n+        .typeck_results()\n+        .node_substs(if let ExprKind::Call(callee, _) = parent.kind {\n+            callee.hir_id\n+        } else {\n+            parent.hir_id\n+        });\n+\n+    let predicates = cx.tcx.param_env(callee_def_id).caller_bounds();\n+    let projection_predicates = predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+                Some(projection_predicate)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    let mut trait_with_ref_mut_self_method = false;\n+\n+    // If no traits were found, or only the `Destruct`, `Sized`, or `Any` traits were found, return.\n+    if predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+                && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n+            {\n+                Some(trait_predicate.trait_ref.def_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .inspect(|trait_def_id| {\n+            trait_with_ref_mut_self_method |= has_ref_mut_self_method(cx, *trait_def_id);\n+        })\n+        .all(|trait_def_id| {\n+            Some(trait_def_id) == destruct_trait_def_id\n+                || Some(trait_def_id) == sized_trait_def_id\n+                || cx.tcx.is_diagnostic_item(sym::Any, trait_def_id)\n+        })\n+    {\n+        return Position::Other(precedence);\n+    }\n+\n+    // `substs_with_referent_ty` can be constructed outside of `check_referent` because the same\n+    // elements are modified each time `check_referent` is called.\n+    let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n+\n+    let mut check_referent = |referent| {\n+        let referent_ty = cx.typeck_results().expr_ty(referent);\n+\n+        if !is_copy(cx, referent_ty) {\n+            return false;\n+        }\n+\n+        // https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+        if trait_with_ref_mut_self_method && !matches!(referent_ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+            return false;\n+        }\n+\n+        if !replace_types(\n+            cx,\n+            param_ty,\n+            referent_ty,\n+            fn_sig,\n+            arg_index,\n+            &projection_predicates,\n+            &mut substs_with_referent_ty,\n+        ) {\n+            return false;\n+        }\n+\n+        predicates.iter().all(|predicate| {\n+            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+                && cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_predicate.trait_ref.def_id)\n+                && let ty::Param(param_ty) = trait_predicate.self_ty().kind()\n+                && let GenericArgKind::Type(ty) = substs_with_referent_ty[param_ty.index as usize].unpack()\n+                && ty.is_array()\n+                && !meets_msrv(msrv, msrvs::ARRAY_INTO_ITERATOR)\n+            {\n+                return false;\n+            }\n+\n+            let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n+            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+            cx.tcx\n+                .infer_ctxt()\n+                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+        })\n+    };\n+\n+    let mut needless_borrow = false;\n+    while let ExprKind::AddrOf(_, _, referent) = expr.kind {\n+        if !check_referent(referent) {\n+            break;\n+        }\n+        expr = referent;\n+        needless_borrow = true;\n+    }\n+\n+    if needless_borrow {\n+        Position::ImplArg(expr.hir_id)\n+    } else {\n+        Position::Other(precedence)\n+    }\n+}\n+\n+fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n+    cx.tcx\n+        .associated_items(trait_def_id)\n+        .in_definition_order()\n+        .any(|assoc_item| {\n+            if assoc_item.fn_has_self_parameter {\n+                let self_ty = cx.tcx.fn_sig(assoc_item.def_id).skip_binder().inputs()[0];\n+                matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Mut))\n+            } else {\n+                false\n+            }\n+        })\n+}\n+\n+// Iteratively replaces `param_ty` with `new_ty` in `substs`, and similarly for each resulting\n+// projected type that is a type parameter. Returns `false` if replacing the types would have an\n+// effect on the function signature beyond substituting `new_ty` for `param_ty`.\n+// See: https://github.com/rust-lang/rust-clippy/pull/9136#discussion_r927212757\n+fn replace_types<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_ty: ParamTy,\n+    new_ty: Ty<'tcx>,\n+    fn_sig: FnSig<'tcx>,\n+    arg_index: usize,\n+    projection_predicates: &[ProjectionPredicate<'tcx>],\n+    substs: &mut [ty::GenericArg<'tcx>],\n+) -> bool {\n+    let mut replaced = BitSet::new_empty(substs.len());\n+\n+    let mut deque = VecDeque::with_capacity(substs.len());\n+    deque.push_back((param_ty, new_ty));\n+\n+    while let Some((param_ty, new_ty)) = deque.pop_front() {\n+        // If `replaced.is_empty()`, then `param_ty` and `new_ty` are those initially passed in.\n+        if !fn_sig\n+            .inputs_and_output\n+            .iter()\n+            .enumerate()\n+            .all(|(i, ty)| (replaced.is_empty() && i == arg_index) || !contains_ty(ty, param_ty.to_ty(cx.tcx)))\n+        {\n+            return false;\n+        }\n+\n+        substs[param_ty.index as usize] = ty::GenericArg::from(new_ty);\n+\n+        // The `replaced.insert(...)` check provides some protection against infinite loops.\n+        if replaced.insert(param_ty.index) {\n+            for projection_predicate in projection_predicates {\n+                if projection_predicate.projection_ty.self_ty() == param_ty.to_ty(cx.tcx)\n+                    && let ty::Term::Ty(term_ty) = projection_predicate.term\n+                    && let ty::Param(term_param_ty) = term_ty.kind()\n+                {\n+                    let item_def_id = projection_predicate.projection_ty.item_def_id;\n+                    let assoc_item = cx.tcx.associated_item(item_def_id);\n+                    let projection = cx.tcx\n+                        .mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(new_ty, &[]));\n+\n+                    if let Ok(projected_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, projection)\n+                        && substs[term_param_ty.index as usize] != ty::GenericArg::from(projected_ty)\n+                    {\n+                        deque.push_back((*term_param_ty, projected_ty));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    true\n+}\n+\n struct TyPosition<'tcx> {\n     position: Position,\n     ty: Option<Ty<'tcx>>,\n@@ -1084,7 +1328,8 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n         },\n         State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n-            let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            let snip_expr = state.snip_expr.map_or(expr, |hir_id| cx.tcx.hir().expect_expr(hir_id));\n+            let (snip, snip_is_macro) = snippet_with_context(cx, snip_expr.span, data.span.ctxt(), \"..\", &mut app);\n             span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n                 let calls_field = matches!(expr.kind, ExprKind::Field(..)) && matches!(data.position, Position::Callee);\n                 let sugg = if !snip_is_macro"}, {"sha": "521739c28ff64a39cacfd2f7f3f292b231886e25", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -821,7 +821,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(verbose_file_reads::VerboseFileReads));\n     store.register_late_pass(|| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n     store.register_late_pass(|| Box::new(unnamed_address::UnnamedAddress));\n-    store.register_late_pass(|| Box::new(dereference::Dereferencing::default()));\n+    store.register_late_pass(move || Box::new(dereference::Dereferencing::new(msrv)));\n     store.register_late_pass(|| Box::new(option_if_let_else::OptionIfLetElse));\n     store.register_late_pass(|| Box::new(future_not_send::FutureNotSend));\n     store.register_late_pass(|| Box::new(if_let_mutex::IfLetMutex));"}, {"sha": "e4624167ad0c07012a43fba0e8a55d385d330332", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -6,9 +6,8 @@ use clippy_utils::ty::{\n     contains_ty, get_associated_type, get_iterator_item_ty, implements_trait, is_copy, is_type_diagnostic_item,\n     peel_mid_ty_refs,\n };\n-use clippy_utils::{meets_msrv, msrvs};\n-\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -373,25 +372,15 @@ fn get_input_traits_and_projections<'tcx>(\n ) -> (Vec<TraitPredicate<'tcx>>, Vec<ProjectionPredicate<'tcx>>) {\n     let mut trait_predicates = Vec::new();\n     let mut projection_predicates = Vec::new();\n-    for (predicate, _) in cx.tcx.predicates_of(callee_def_id).predicates.iter() {\n-        // `substs` should have 1 + n elements. The first is the type on the left hand side of an\n-        // `as`. The remaining n are trait parameters.\n-        let is_input_substs = |substs: SubstsRef<'tcx>| {\n-            if_chain! {\n-                if let Some(arg) = substs.iter().next();\n-                if let GenericArgKind::Type(arg_ty) = arg.unpack();\n-                if arg_ty == input;\n-                then { true } else { false }\n-            }\n-        };\n+    for predicate in cx.tcx.param_env(callee_def_id).caller_bounds() {\n         match predicate.kind().skip_binder() {\n             PredicateKind::Trait(trait_predicate) => {\n-                if is_input_substs(trait_predicate.trait_ref.substs) {\n+                if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n             },\n             PredicateKind::Projection(projection_predicate) => {\n-                if is_input_substs(projection_predicate.projection_ty.substs) {\n+                if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n             },"}, {"sha": "7fa0046a267bb9a9916aaab989b42c4ebbdbb611", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -13,7 +13,7 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,62,0 { BOOL_THEN_SOME }\n-    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN }\n+    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }\n     1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n     1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n     1,50,0 { BOOL_THEN }"}, {"sha": "429dddc42ea9157f6830be6792489b3ab3d08f95", "filename": "rustc_tools_util/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/rustc_tools_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/rustc_tools_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2Fsrc%2Flib.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -84,7 +84,7 @@ impl std::fmt::Debug for VersionInfo {\n #[must_use]\n pub fn get_commit_hash() -> Option<String> {\n     std::process::Command::new(\"git\")\n-        .args(&[\"rev-parse\", \"--short\", \"HEAD\"])\n+        .args([\"rev-parse\", \"--short\", \"HEAD\"])\n         .output()\n         .ok()\n         .and_then(|r| String::from_utf8(r.stdout).ok())\n@@ -93,7 +93,7 @@ pub fn get_commit_hash() -> Option<String> {\n #[must_use]\n pub fn get_commit_date() -> Option<String> {\n     std::process::Command::new(\"git\")\n-        .args(&[\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n+        .args([\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n         .output()\n         .ok()\n         .and_then(|r| String::from_utf8(r.stdout).ok())"}, {"sha": "e106583de4a2eb0a099d145cafe71b60453c2ef2", "filename": "tests/check-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fcheck-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fcheck-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcheck-fmt.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -13,7 +13,7 @@ fn fmt() {\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n     let output = Command::new(\"cargo\")\n         .current_dir(root_dir)\n-        .args(&[\"dev\", \"fmt\", \"--check\"])\n+        .args([\"dev\", \"fmt\", \"--check\"])\n         .output()\n         .unwrap();\n "}, {"sha": "961525bbd9101dfbc6759f69ba3f05d7aa94e170", "filename": "tests/dogfood.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -87,11 +87,11 @@ fn run_clippy_for_package(project: &str, args: &[&str]) {\n \n     if cfg!(feature = \"internal\") {\n         // internal lints only exist if we build with the internal feature\n-        command.args(&[\"-D\", \"clippy::internal\"]);\n+        command.args([\"-D\", \"clippy::internal\"]);\n     } else {\n         // running a clippy built without internal lints on the clippy source\n         // that contains e.g. `allow(clippy::invalid_paths)`\n-        command.args(&[\"-A\", \"unknown_lints\"]);\n+        command.args([\"-A\", \"unknown_lints\"]);\n     }\n \n     let output = command.output().unwrap();"}, {"sha": "23a9bef3ccceaee4b9df52ecb40afb848e8f1873", "filename": "tests/integration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fintegration.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -19,7 +19,7 @@ fn integration_test() {\n     repo_dir.push(crate_name);\n \n     let st = Command::new(\"git\")\n-        .args(&[\n+        .args([\n             OsStr::new(\"clone\"),\n             OsStr::new(\"--depth=1\"),\n             OsStr::new(&repo_url),\n@@ -37,7 +37,7 @@ fn integration_test() {\n         .current_dir(repo_dir)\n         .env(\"RUST_BACKTRACE\", \"full\")\n         .env(\"CARGO_TARGET_DIR\", target_dir)\n-        .args(&[\n+        .args([\n             \"clippy\",\n             \"--all-targets\",\n             \"--all-features\","}, {"sha": "2e0f4e76075b38a1eaec8e6380001dcd5109886a", "filename": "tests/lint_message_convention.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flint_message_convention.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -19,7 +19,7 @@ impl Message {\n         // we don't want the first letter after \"error: \", \"help: \" ... to be capitalized\n         // also no punctuation (except for \"?\" ?) at the end of a line\n         static REGEX_SET: LazyLock<RegexSet> = LazyLock::new(|| {\n-            RegexSet::new(&[\n+            RegexSet::new([\n                 r\"error: [A-Z]\",\n                 r\"help: [A-Z]\",\n                 r\"warning: [A-Z]\",\n@@ -37,7 +37,7 @@ impl Message {\n         // sometimes the first character is capitalized and it is legal (like in \"C-like enum variants\") or\n         // we want to ask a question ending in \"?\"\n         static EXCEPTIONS_SET: LazyLock<RegexSet> = LazyLock::new(|| {\n-            RegexSet::new(&[\n+            RegexSet::new([\n                 r\"\\.\\.\\.$\",\n                 r\".*C-like enum variant discriminant is not portable to 32-bit targets\",\n                 r\".*Intel x86 assembly syntax used\","}, {"sha": "8cf93bd248173ee93cef0b0ec5e87815e11f370b", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(lint_reasons)]\n+#![feature(custom_inner_attributes, lint_reasons)]\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables, clippy::unnecessary_mut_passed)]\n@@ -127,6 +127,20 @@ fn main() {\n             0\n         }\n     }\n+\n+    let _ = std::process::Command::new(\"ls\").args([\"-a\", \"-l\"]).status().unwrap();\n+    let _ = std::path::Path::new(\".\").join(\".\");\n+    deref_target_is_x(X);\n+    multiple_constraints([[\"\"]]);\n+    multiple_constraints_normalizes_to_same(X, X);\n+    let _ = Some(\"\").unwrap_or(\"\");\n+\n+    only_sized(&\"\"); // Don't lint. `Sized` is only bound\n+    let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n+    let _ = Box::new(&\"\"); // Don't lint. Type parameter appears in return type\n+    ref_as_ref_path(&\"\"); // Don't lint. Argument type is not a type parameter\n+    refs_only(&()); // Don't lint. `&T` implements trait, but `T` doesn't\n+    multiple_constraints_normalizes_to_different(&[[\"\"]], &[\"\"]); // Don't lint. Projected type appears in arguments\n }\n \n #[allow(clippy::needless_borrowed_reference)]\n@@ -183,3 +197,104 @@ mod issue9160 {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+struct X;\n+\n+impl std::ops::Deref for X {\n+    type Target = X;\n+    fn deref(&self) -> &Self::Target {\n+        self\n+    }\n+}\n+\n+fn deref_target_is_x<T>(_: T)\n+where\n+    T: std::ops::Deref<Target = X>,\n+{\n+}\n+\n+fn multiple_constraints<T, U, V, X, Y>(_: T)\n+where\n+    T: IntoIterator<Item = U> + IntoIterator<Item = X>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+    X: IntoIterator<Item = Y>,\n+    Y: AsRef<std::ffi::OsStr>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_same<T, U, V>(_: T, _: V)\n+where\n+    T: std::ops::Deref<Target = U>,\n+    U: std::ops::Deref<Target = V>,\n+{\n+}\n+\n+fn only_sized<T>(_: T) {}\n+\n+fn ref_as_ref_path<T: 'static>(_: &'static T)\n+where\n+    &'static T: AsRef<std::path::Path>,\n+{\n+}\n+\n+trait RefsOnly {\n+    type Referent;\n+}\n+\n+impl<T> RefsOnly for &T {\n+    type Referent = T;\n+}\n+\n+fn refs_only<T, U>(_: T)\n+where\n+    T: RefsOnly<Referent = U>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_different<T, U, V>(_: T, _: U)\n+where\n+    T: IntoIterator<Item = U>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+{\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+#[allow(dead_code)]\n+mod copyable_iterator {\n+    #[derive(Clone, Copy)]\n+    struct Iter;\n+    impl Iterator for Iter {\n+        type Item = ();\n+        fn next(&mut self) -> Option<Self::Item> {\n+            None\n+        }\n+    }\n+    fn takes_iter(_: impl Iterator) {}\n+    fn dont_warn(mut x: Iter) {\n+        takes_iter(&mut x);\n+    }\n+    fn warn(mut x: &mut Iter) {\n+        takes_iter(&mut x)\n+    }\n+}\n+\n+mod under_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.52.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}\n+\n+mod meets_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.53.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args([\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}"}, {"sha": "fd9b2a11df96f1cba7dcd147dd7d6ca96774435d", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(lint_reasons)]\n+#![feature(custom_inner_attributes, lint_reasons)]\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables, clippy::unnecessary_mut_passed)]\n@@ -127,6 +127,20 @@ fn main() {\n             0\n         }\n     }\n+\n+    let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    let _ = std::path::Path::new(\".\").join(&&\".\");\n+    deref_target_is_x(&X);\n+    multiple_constraints(&[[\"\"]]);\n+    multiple_constraints_normalizes_to_same(&X, X);\n+    let _ = Some(\"\").unwrap_or(&\"\");\n+\n+    only_sized(&\"\"); // Don't lint. `Sized` is only bound\n+    let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n+    let _ = Box::new(&\"\"); // Don't lint. Type parameter appears in return type\n+    ref_as_ref_path(&\"\"); // Don't lint. Argument type is not a type parameter\n+    refs_only(&()); // Don't lint. `&T` implements trait, but `T` doesn't\n+    multiple_constraints_normalizes_to_different(&[[\"\"]], &[\"\"]); // Don't lint. Projected type appears in arguments\n }\n \n #[allow(clippy::needless_borrowed_reference)]\n@@ -183,3 +197,104 @@ mod issue9160 {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+struct X;\n+\n+impl std::ops::Deref for X {\n+    type Target = X;\n+    fn deref(&self) -> &Self::Target {\n+        self\n+    }\n+}\n+\n+fn deref_target_is_x<T>(_: T)\n+where\n+    T: std::ops::Deref<Target = X>,\n+{\n+}\n+\n+fn multiple_constraints<T, U, V, X, Y>(_: T)\n+where\n+    T: IntoIterator<Item = U> + IntoIterator<Item = X>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+    X: IntoIterator<Item = Y>,\n+    Y: AsRef<std::ffi::OsStr>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_same<T, U, V>(_: T, _: V)\n+where\n+    T: std::ops::Deref<Target = U>,\n+    U: std::ops::Deref<Target = V>,\n+{\n+}\n+\n+fn only_sized<T>(_: T) {}\n+\n+fn ref_as_ref_path<T: 'static>(_: &'static T)\n+where\n+    &'static T: AsRef<std::path::Path>,\n+{\n+}\n+\n+trait RefsOnly {\n+    type Referent;\n+}\n+\n+impl<T> RefsOnly for &T {\n+    type Referent = T;\n+}\n+\n+fn refs_only<T, U>(_: T)\n+where\n+    T: RefsOnly<Referent = U>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_different<T, U, V>(_: T, _: U)\n+where\n+    T: IntoIterator<Item = U>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+{\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+#[allow(dead_code)]\n+mod copyable_iterator {\n+    #[derive(Clone, Copy)]\n+    struct Iter;\n+    impl Iterator for Iter {\n+        type Item = ();\n+        fn next(&mut self) -> Option<Self::Item> {\n+            None\n+        }\n+    }\n+    fn takes_iter(_: impl Iterator) {}\n+    fn dont_warn(mut x: Iter) {\n+        takes_iter(&mut x);\n+    }\n+    fn warn(mut x: &mut Iter) {\n+        takes_iter(&mut x)\n+    }\n+}\n+\n+mod under_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.52.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}\n+\n+mod meets_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.53.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}"}, {"sha": "5af68706d4ba579311308199b560dbfcad016ad2", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -120,17 +120,59 @@ error: this expression creates a reference which is immediately dereferenced by\n LL |     (&&5).foo();\n    |     ^^^^^ help: change this to: `(&5)`\n \n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:131:51\n+   |\n+LL |     let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+   |                                                   ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:132:44\n+   |\n+LL |     let _ = std::path::Path::new(\".\").join(&&\".\");\n+   |                                            ^^^^^ help: change this to: `\".\"`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:133:23\n+   |\n+LL |     deref_target_is_x(&X);\n+   |                       ^^ help: change this to: `X`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:134:26\n+   |\n+LL |     multiple_constraints(&[[\"\"]]);\n+   |                          ^^^^^^^ help: change this to: `[[\"\"]]`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:135:45\n+   |\n+LL |     multiple_constraints_normalizes_to_same(&X, X);\n+   |                                             ^^ help: change this to: `X`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:136:32\n+   |\n+LL |     let _ = Some(\"\").unwrap_or(&\"\");\n+   |                                ^^^ help: change this to: `\"\"`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:173:13\n+  --> $DIR/needless_borrow.rs:187:13\n    |\n LL |             (&self.f)()\n    |             ^^^^^^^^^ help: change this to: `(self.f)`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:182:13\n+  --> $DIR/needless_borrow.rs:196:13\n    |\n LL |             (&mut self.f)()\n    |             ^^^^^^^^^^^^^ help: change this to: `(self.f)`\n \n-error: aborting due to 22 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:298:55\n+   |\n+LL |         let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+   |                                                       ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n+\n+error: aborting due to 29 previous errors\n "}, {"sha": "f0e1a8128d7c36b5bc44d3d77c7ee270988780d7", "filename": "tests/ui/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused)]\n+#![allow(unused, clippy::needless_borrow)]\n #![warn(clippy::invalid_regex, clippy::trivial_regex)]\n \n extern crate regex;"}, {"sha": "af01a8df71b015cff39987006088878f8a4db000", "filename": "tests/ui/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -151,6 +151,7 @@ fn main() {\n \n     // Fix #6987\n     let mut vec = Vec::new();\n+    #[allow(clippy::needless_borrow)]\n     for _ in 0..10 {\n         vec.push(1);\n         vec.extend(&[2]);"}, {"sha": "df267e9872a0a0a6bdd6984c7aeca3e77c4e4d88", "filename": "tests/ui/verbose_file_reads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fui%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fverbose_file_reads.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -18,7 +18,7 @@ fn main() -> std::io::Result<()> {\n     s.read_to_end();\n     s.read_to_string();\n     // Should catch this\n-    let mut f = File::open(&path)?;\n+    let mut f = File::open(path)?;\n     let mut buffer = Vec::new();\n     f.read_to_end(&mut buffer)?;\n     // ...and this"}, {"sha": "95325e06037829c2fb9a519f5b3a50e10ddee1e1", "filename": "tests/workspace.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c419d0a8b538de6000226cc54a2f18a03bbd31d6/tests%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fworkspace.rs?ref=c419d0a8b538de6000226cc54a2f18a03bbd31d6", "patch": "@@ -20,8 +20,8 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n         .current_dir(&cwd)\n         .env(\"CARGO_TARGET_DIR\", &target_dir)\n         .arg(\"clean\")\n-        .args(&[\"-p\", \"subcrate\"])\n-        .args(&[\"-p\", \"path_dep\"])\n+        .args([\"-p\", \"subcrate\"])\n+        .args([\"-p\", \"path_dep\"])\n         .output()\n         .unwrap();\n \n@@ -32,11 +32,11 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n         .env(\"CARGO_TARGET_DIR\", &target_dir)\n         .arg(\"clippy\")\n-        .args(&[\"-p\", \"subcrate\"])\n+        .args([\"-p\", \"subcrate\"])\n         .arg(\"--no-deps\")\n         .arg(\"--\")\n         .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-        .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+        .args([\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n         .output()\n         .unwrap();\n     println!(\"status: {}\", output.status);\n@@ -52,10 +52,10 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .env(\"CARGO_TARGET_DIR\", &target_dir)\n             .arg(\"clippy\")\n-            .args(&[\"-p\", \"subcrate\"])\n+            .args([\"-p\", \"subcrate\"])\n             .arg(\"--\")\n             .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .args([\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n             .output()\n             .unwrap();\n         println!(\"status: {}\", output.status);\n@@ -79,7 +79,7 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .env(\"CARGO_TARGET_DIR\", &target_dir)\n             .arg(\"clippy\")\n-            .args(&[\"-p\", \"subcrate\"])\n+            .args([\"-p\", \"subcrate\"])\n             .arg(\"--\")\n             .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n             .output()"}]}