{"sha": "15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "node_id": "C_kwDOAAsO6NoAKDE1NDgzY2NmOWQwYTBiZWZiNDcyZTRkZDNhMWJmYmE3NTRhMWNkMTE", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-05-10T19:50:50Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-12-07T01:30:15Z"}, "message": "Annotate comments onto the LT algorithm", "tree": {"sha": "0bd58949d5f5153dfa4bf3a79c372952a40cbb59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bd58949d5f5153dfa4bf3a79c372952a40cbb59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "html_url": "https://github.com/rust-lang/rust/commit/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31874800702537252a2d1450d4b3c6e2d2321c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/31874800702537252a2d1450d4b3c6e2d2321c22", "html_url": "https://github.com/rust-lang/rust/commit/31874800702537252a2d1450d4b3c6e2d2321c22"}], "stats": {"total": 104, "additions": 102, "deletions": 2}, "files": [{"sha": "0d2ae115cb0d29d3bf561f22f35e9314fc3a440d", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 102, "deletions": 2, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15483ccf9d0a0befb472e4dd3a1bfba754a1cd11/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=15483ccf9d0a0befb472e4dd3a1bfba754a1cd11", "patch": "@@ -2,7 +2,12 @@\n //!\n //! Algorithm based on Loukas Georgiadis,\n //! \"Linear-Time Algorithms for Dominators and Related Problems\",\n-//! ftp://ftp.cs.princeton.edu/techreports/2005/737.pdf\n+//! <ftp://ftp.cs.princeton.edu/techreports/2005/737.pdf>\n+//!\n+//! Additionally useful is the original Lengauer-Tarjan paper on this subject,\n+//! \"A Fast Algorithm for Finding Dominators in a Flowgraph\"\n+//! Thomas Lengauer and Robert Endre Tarjan.\n+//! <https://www.cs.princeton.edu/courses/archive/spr03/cs423/download/dominators.pdf>\n \n use super::ControlFlowGraph;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -42,6 +47,14 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     real_to_pre_order[graph.start_node()] = Some(PreorderIndex::new(0));\n     let mut post_order_idx = 0;\n \n+    // Traverse the graph, collecting a number of things:\n+    //\n+    // * Preorder mapping (to it, and back to the actual ordering)\n+    // * Postorder mapping (used exclusively for rank_partial_cmp on the final product)\n+    // * Parents for each vertex in the preorder tree\n+    //\n+    // These are all done here rather than through one of the 'standard'\n+    // graph traversals to help make this fast.\n     'recurse: while let Some(frame) = stack.last_mut() {\n         while let Some(successor) = frame.iter.next() {\n             if real_to_pre_order[successor].is_none() {\n@@ -67,26 +80,95 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     let mut bucket = IndexVec::from_elem_n(vec![], reachable_vertices);\n     let mut lastlinked = None;\n \n+    // We loop over vertices in reverse preorder. This implements the pseudocode\n+    // of the simple Lengauer-Tarjan algorithm. A few key facts are noted here\n+    // which are helpful for understanding the code (full proofs and such are\n+    // found in various papers, including one cited at the top of this file).\n+    //\n+    // For each vertex w (which is not the root),\n+    //  * semi[w] is a proper ancestor of the vertex w (i.e., semi[w] != w)\n+    //  * idom[w] is an ancestor of semi[w] (i.e., idom[w] may equal semi[w])\n+    //\n+    // An immediate dominator of w (idom[w]) is a vertex v where v dominates w\n+    // and every other dominator of w dominates v. (Every vertex except the root has\n+    // a unique immediate dominator.)\n+    //\n+    // A semidominator for a given vertex w (semi[w]) is the vertex v with minimum\n+    // preorder number such that there exists a path from v to w in which all elements (other than w) have\n+    // preorder numbers greater than w (i.e., this path is not the tree path to\n+    // w).\n     for w in (PreorderIndex::new(1)..PreorderIndex::new(reachable_vertices)).rev() {\n         // Optimization: process buckets just once, at the start of the\n         // iteration. Do not explicitly empty the bucket (even though it will\n         // not be used again), to save some instructions.\n+        //\n+        // The bucket here contains the vertices whose semidominator is the\n+        // vertex w, which we are guaranteed to have found: all vertices who can\n+        // be semidominated by w must have a preorder number exceeding w, so\n+        // they have been placed in the bucket.\n+        //\n+        // We compute a partial set of immediate dominators here.\n         let z = parent[w];\n         for &v in bucket[z].iter() {\n+            // This uses the result of Lemma 5 from section 2 from the original\n+            // 1979 paper, to compute either the immediate or relative dominator\n+            // for a given vertex v.\n+            //\n+            // eval returns a vertex y, for which semi[y] is minimum among\n+            // vertices semi[v] +> y *> v. Note that semi[v] = z as we're in the\n+            // z bucket.\n+            //\n+            // Given such a vertex y, semi[y] <= semi[v] and idom[y] = idom[v].\n+            // If semi[y] = semi[v], though, idom[v] = semi[v].\n+            //\n+            // Using this, we can either set idom[v] to be:\n+            //  * semi[v] (i.e. z), if semi[y] is z\n+            //  * idom[y], otherwise\n+            //\n+            // We don't directly set to idom[y] though as it's not necessarily\n+            // known yet. The second preorder traversal will cleanup by updating\n+            // the idom for any that were missed in this pass.\n             let y = eval(&mut parent, lastlinked, &semi, &mut label, v);\n             idom[v] = if semi[y] < z { y } else { z };\n         }\n \n+        // This loop computes the semi[w] for w.\n         semi[w] = w;\n         for v in graph.predecessors(pre_order_to_real[w]) {\n             let v = real_to_pre_order[v].unwrap();\n+\n+            // eval returns a vertex x from which semi[x] is minimum among\n+            // vertices semi[v] +> x *> v.\n+            //\n+            // From Lemma 4 from section 2, we know that the semidominator of a\n+            // vertex w is the minimum (by preorder number) vertex of the\n+            // following:\n+            //\n+            //  * direct predecessors of w with preorder number less than w\n+            //  * semidominators of u such that u > w and there exists (v, w)\n+            //    such that u *> v\n+            //\n+            // This loop therefore identifies such a minima. Note that any\n+            // semidominator path to w must have all but the first vertex go\n+            // through vertices numbered greater than w, so the reverse preorder\n+            // traversal we are using guarantees that all of the information we\n+            // might need is available at this point.\n+            //\n+            // The eval call will give us semi[x], which is either:\n+            //\n+            //  * v itself, if v has not yet been processed\n+            //  * A possible 'best' semidominator for w.\n             let x = eval(&mut parent, lastlinked, &semi, &mut label, v);\n             semi[w] = std::cmp::min(semi[w], semi[x]);\n         }\n-        // semi[w] is now semidominator(w).\n+        // semi[w] is now semidominator(w) and won't change any more.\n \n         // Optimization: Do not insert into buckets if parent[w] = semi[w], as\n         // we then immediately know the idom.\n+        //\n+        // If we don't yet know the idom directly, then push this vertex into\n+        // our semidominator's bucket, where it will get processed at a later\n+        // stage to compute its immediate dominator.\n         if parent[w] != semi[w] {\n             bucket[semi[w]].push(w);\n         } else {\n@@ -97,6 +179,14 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // processed elements; lastlinked represents the divider.\n         lastlinked = Some(w);\n     }\n+\n+    // Finalize the idoms for any that were not fully settable during initial\n+    // traversal.\n+    //\n+    // If idom[w] != semi[w] then we know that we've stored vertex y from above\n+    // into idom[w]. It is known to be our 'relative dominator', which means\n+    // that it's one of w's ancestors and has the same immediate dominator as w,\n+    // so use that idom.\n     for w in PreorderIndex::new(1)..PreorderIndex::new(reachable_vertices) {\n         if idom[w] != semi[w] {\n             idom[w] = idom[idom[w]];\n@@ -111,6 +201,16 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     Dominators { post_order_rank, immediate_dominators }\n }\n \n+/// Evaluate the link-eval virtual forest, providing the currently minimum semi\n+/// value for the passed `node` (which may be itself).\n+///\n+/// This maintains that for every vertex v, `label[v]` is such that:\n+///\n+/// ```text\n+/// semi[eval(v)] = min { semi[label[u]] | root_in_forest(v) +> u *> v }\n+/// ```\n+///\n+/// where `+>` is a proper ancestor and `*>` is just an ancestor.\n #[inline]\n fn eval(\n     ancestor: &mut IndexVec<PreorderIndex, PreorderIndex>,"}]}