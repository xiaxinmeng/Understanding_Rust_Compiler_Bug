{"sha": "608c395818c18ac2a91d0f4409296b788bd4e4ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwOGMzOTU4MThjMThhYzJhOTFkMGY0NDA5Mjk2Yjc4OGJkNGU0ZWY=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-26T15:32:23Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-29T09:13:00Z"}, "message": "A few cleanups and minor improvements to typeck", "tree": {"sha": "96b4524c4f0651daf1296e52b98f6b59a8a72540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96b4524c4f0651daf1296e52b98f6b59a8a72540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/608c395818c18ac2a91d0f4409296b788bd4e4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/608c395818c18ac2a91d0f4409296b788bd4e4ef", "html_url": "https://github.com/rust-lang/rust/commit/608c395818c18ac2a91d0f4409296b788bd4e4ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/608c395818c18ac2a91d0f4409296b788bd4e4ef/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6622172734a6c456ea85e17b765ad1dbc0e42907", "url": "https://api.github.com/repos/rust-lang/rust/commits/6622172734a6c456ea85e17b765ad1dbc0e42907", "html_url": "https://github.com/rust-lang/rust/commit/6622172734a6c456ea85e17b765ad1dbc0e42907"}], "stats": {"total": 736, "additions": 344, "deletions": 392}, "files": [{"sha": "00c6ebafec0d5b4132438f076878396dac8ba32e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -147,7 +147,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     bound_region: ty::BrNamed(id, name)\n                 }))\n \n-                    // (*) -- not late-bound, won't change\n+                // (*) -- not late-bound, won't change\n             }\n \n             None => {\n@@ -167,8 +167,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         };\n \n         debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\",\n-                lifetime,\n-                r);\n+               lifetime,\n+               r);\n \n         r\n     }\n@@ -218,7 +218,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 span,\n                 E0632,\n                 \"cannot provide explicit type parameters when `impl Trait` is \\\n-                used in argument position.\"\n+                 used in argument position.\"\n             };\n \n             err.emit();\n@@ -538,7 +538,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n-               generic_args={:?})\",\n+                generic_args={:?})\",\n                def_id, self_ty, generic_args);\n \n         let tcx = self.tcx();\n@@ -609,7 +609,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                             if default_needs_object_self(param) {\n                                 struct_span_err!(tcx.sess, span, E0393,\n                                                     \"the type parameter `{}` must be explicitly \\\n-                                                    specified\",\n+                                                     specified\",\n                                                     param.name)\n                                     .span_label(span,\n                                                 format!(\"missing reference to `{}`\", param.name))\n@@ -623,7 +623,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                 self.normalize_ty(\n                                     span,\n                                     tcx.at(span).type_of(param.def_id)\n-                                        .subst_spanned(tcx, substs.unwrap(), Some(span))\n+                                       .subst_spanned(tcx, substs.unwrap(), Some(span))\n                                 ).into()\n                             }\n                         } else if infer_types {\n@@ -851,7 +851,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                 binding.span,\n                                 E0582,\n                                 \"binding for associated type `{}` references lifetime `{}`, \\\n-                                which does not appear in the trait input types\",\n+                                 which does not appear in the trait input types\",\n                                 binding.item_name, br_name)\n                     .emit();\n             }\n@@ -891,7 +891,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                         ref_id,\n                         binding.span,\n                         &format!(\"associated type binding `{}` specified more than once\",\n-                                binding.item_name)\n+                                 binding.item_name)\n                     );\n                     err.span_label(binding.span, \"used more than once\");\n                     err.span_label(*prev_span, format!(\"first use of `{}`\", binding.item_name));\n@@ -994,7 +994,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         if !object_safety_violations.is_empty() {\n             tcx.report_object_safety_error(\n                 span, principal.def_id(), object_safety_violations)\n-                .emit();\n+               .emit();\n             return tcx.types.err;\n         }\n \n@@ -1014,13 +1014,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         for item_def_id in associated_types {\n             let assoc_item = tcx.associated_item(item_def_id);\n             let trait_def_id = assoc_item.container.id();\n-            struct_span_err!(tcx.sess, span, E0191,\n-                \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                        assoc_item.ident,\n-                        tcx.item_path_str(trait_def_id))\n-                        .span_label(span, format!(\n-                            \"missing associated type `{}` value\", assoc_item.ident))\n-                        .emit();\n+            struct_span_err!(tcx.sess, span, E0191, \"the value of the associated type `{}` \\\n+                                                     (from the trait `{}`) must be specified\",\n+                                                    assoc_item.ident,\n+                                                    tcx.item_path_str(trait_def_id))\n+                .span_label(span, format!(\"missing associated type `{}` value\",\n+                                          assoc_item.ident))\n+                .emit();\n         }\n \n         // Dedup auto traits so that `dyn Trait + Send + Send` is the same as `dyn Trait + Send`.\n@@ -1032,12 +1032,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n             .chain(existential_projections\n-                   .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n+                .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         let existential_predicates = ty::Binder::bind(tcx.mk_existential_predicates(v.into_iter()));\n \n-\n         // Explicitly specified region bound. Use that.\n         let region_bound = if !lifetime.is_elided() {\n             self.ast_region_to_region(lifetime, None)\n@@ -1072,7 +1071,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\")\n             .span_label(span, \"ambiguous associated type\")\n             .note(&format!(\"specify the type using the syntax `<{} as {}>::{}`\",\n-                  type_str, trait_str, name))\n+                           type_str, trait_str, name))\n             .emit();\n \n     }\n@@ -1094,8 +1093,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n-        let suitable_bounds =\n-            traits::transitive_bounds(tcx, &bounds)\n+        let suitable_bounds = traits::transitive_bounds(tcx, &bounds)\n             .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n         let param_node_id = tcx.hir.as_local_node_id(ty_param_def_id).unwrap();\n@@ -1110,20 +1108,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     // Checks that bounds contains exactly one element and reports appropriate\n     // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n-                                mut bounds: I,\n-                                ty_param_name: &str,\n-                                assoc_name: ast::Ident,\n-                                span: Span)\n+                                   mut bounds: I,\n+                                   ty_param_name: &str,\n+                                   assoc_name: ast::Ident,\n+                                   span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n         where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n     {\n         let bound = match bounds.next() {\n             Some(bound) => bound,\n             None => {\n                 struct_span_err!(self.tcx().sess, span, E0220,\n-                          \"associated type `{}` not found for `{}`\",\n-                          assoc_name,\n-                          ty_param_name)\n+                                 \"associated type `{}` not found for `{}`\",\n+                                 assoc_name,\n+                                 ty_param_name)\n                   .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n                   .emit();\n                 return Err(ErrorReported);\n@@ -1142,14 +1140,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             for bound in bounds {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n                     item.kind == ty::AssociatedKind::Type &&\n-                    self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n+                        self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n                 })\n                 .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n                 if let Some(span) = bound_span {\n                     err.span_label(span, format!(\"ambiguous `{}` from `{}`\",\n-                                                  assoc_name,\n-                                                  bound));\n+                                                 assoc_name,\n+                                                 bound));\n                 } else {\n                     span_note!(&mut err, span,\n                                \"associated type `{}` could derive from `{}`\",\n@@ -1198,8 +1196,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     }\n                 };\n \n-                let candidates =\n-                    traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n+                let candidates = traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n \n                 match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_name, span) {\n@@ -1230,7 +1227,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_name, trait_did, ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n-            i.ident.modern() == assoc_ident\n+                i.ident.modern() == assoc_ident\n         })\n         .expect(\"missing associated type\");\n \n@@ -1293,16 +1290,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                             if err_for_lt { continue }\n                             err_for_lt = true;\n                             (struct_span_err!(self.tcx().sess, lt.span, E0110,\n-                                            \"lifetime parameters are not allowed on \\\n-                                                this type\"),\n+                                              \"lifetime parameters are not allowed on this type\"),\n                              lt.span,\n                              \"lifetime\")\n                         }\n                         hir::GenericArg::Type(ty) => {\n                             if err_for_ty { continue }\n                             err_for_ty = true;\n                             (struct_span_err!(self.tcx().sess, ty.span, E0109,\n-                                            \"type parameters are not allowed on this type\"),\n+                                              \"type parameters are not allowed on this type\"),\n                              ty.span,\n                              \"type\")\n                         }\n@@ -1590,7 +1586,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         ));\n \n         // Find any late-bound regions declared in return type that do\n-        // not appear in the arguments. These are not wellformed.\n+        // not appear in the arguments. These are not well-formed.\n         //\n         // Example:\n         //     for<'a> fn() -> &'a str <-- 'a is bad"}, {"sha": "d9dee917b01e47446f63277ba6257ce30a9cc2f8", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n         let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n             format!(\"unused import: `{}`\", snippet)\n         } else {\n-            \"unused import\".to_string()\n+            \"unused import\".to_owned()\n         };\n         self.tcx.lint_node(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n     }"}, {"sha": "c54d9e4b47578e205484d37f482a907f5f01a939", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -55,33 +55,29 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n }\n \n fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n-    match tcx.type_of(impl_did).sty {\n-        ty::Adt(..) => {}\n-        _ => {\n-            // Destructors only work on nominal types.\n-            if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n-                match tcx.hir.find(impl_node_id) {\n-                    Some(Node::Item(item)) => {\n-                        let span = match item.node {\n-                            ItemKind::Impl(.., ref ty, _) => ty.span,\n-                            _ => item.span,\n-                        };\n-                        struct_span_err!(tcx.sess,\n-                                         span,\n-                                         E0120,\n-                                         \"the Drop trait may only be implemented on \\\n-                                         structures\")\n-                            .span_label(span, \"implementing Drop requires a struct\")\n-                            .emit();\n-                    }\n-                    _ => {\n-                        bug!(\"didn't find impl in ast map\");\n-                    }\n-                }\n+    if let ty::Adt(..) = tcx.type_of(impl_did).sty {\n+        /* do nothing */\n+    } else {\n+        // Destructors only work on nominal types.\n+        if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n+            if let Some(Node::Item(item)) = tcx.hir.find(impl_node_id) {\n+                let span = match item.node {\n+                    ItemKind::Impl(.., ref ty, _) => ty.span,\n+                    _ => item.span,\n+                };\n+                struct_span_err!(tcx.sess,\n+                                 span,\n+                                 E0120,\n+                                 \"the Drop trait may only be implemented on \\\n+                                  structures\")\n+                    .span_label(span, \"implementing Drop requires a struct\")\n+                    .emit();\n             } else {\n-                bug!(\"found external impl of Drop trait on \\\n-                      something other than a struct\");\n+                bug!(\"didn't find impl in ast map\");\n             }\n+        } else {\n+            bug!(\"found external impl of Drop trait on \\\n+                  something other than a struct\");\n         }\n     }\n }\n@@ -92,8 +88,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     let impl_node_id = if let Some(n) = tcx.hir.as_local_node_id(impl_did) {\n         n\n     } else {\n-        debug!(\"visit_implementation_of_copy(): impl not in this \\\n-                crate\");\n+        debug!(\"visit_implementation_of_copy(): impl not in this crate\");\n         return;\n     };\n \n@@ -119,11 +114,11 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n             };\n \n             let mut err = struct_span_err!(tcx.sess,\n-                                          span,\n-                                          E0204,\n-                                          \"the trait `Copy` may not be implemented for this type\");\n+                                           span,\n+                                           E0204,\n+                                           \"the trait `Copy` may not be implemented for this type\");\n             for span in fields.iter().map(|f| tcx.def_span(f.did)) {\n-                    err.span_label(span, \"this field does not implement `Copy`\");\n+                err.span_label(span, \"this field does not implement `Copy`\");\n             }\n             err.emit()\n         }\n@@ -173,12 +168,9 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n     let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = match gcx.lang_items().require(UnsizeTraitLangItem) {\n-        Ok(id) => id,\n-        Err(err) => {\n-            gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n-        }\n-    };\n+    let unsize_trait = gcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n+        gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+    });\n \n     // this provider should only get invoked for local def-ids\n     let impl_node_id = gcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n@@ -210,9 +202,9 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                            mk_ptr: &dyn Fn(Ty<'gcx>) -> Ty<'gcx>| {\n             if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                 infcx.report_mismatched_types(&cause,\n-                                             mk_ptr(mt_b.ty),\n-                                             target,\n-                                             ty::error::TypeError::Mutability)\n+                                              mk_ptr(mt_b.ty),\n+                                              target,\n+                                              ty::error::TypeError::Mutability)\n                     .emit();\n             }\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n@@ -235,7 +227,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             }\n \n             (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n-                                                                          def_b.is_struct() => {\n+                                                                      def_b.is_struct() => {\n                 if def_a != def_b {\n                     let source_path = gcx.item_path_str(def_a.did);\n                     let target_path = gcx.item_path_str(def_b.did);"}, {"sha": "1955a709dbfe5ef36c37108edbaefa3df8e73c1e", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -315,8 +315,7 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n                              E0116,\n                              \"cannot define inherent `impl` for a type outside of the crate \\\n                               where the type is defined\")\n-                .span_label(item.span,\n-                            \"impl for type defined outside of crate.\")\n+                .span_label(item.span, \"impl for type defined outside of crate.\")\n                 .note(\"define and implement a trait or new type instead\")\n                 .emit();\n         }"}, {"sha": "616ca97a7a75d99e751f000aef43cd8030159b9c", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -36,8 +36,8 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n         debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n-                trait_ref,\n-                tcx.item_path_str(impl_def_id));\n+               trait_ref,\n+               tcx.item_path_str(impl_def_id));\n \n         // Skip impls where one of the self type is an error type.\n         // This occurs with e.g. resolve failures (#30589)."}, {"sha": "b155587dddc419f284fcda6978e89a0201c98f98", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 113, "deletions": 118, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -33,131 +33,126 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n-        match item.node {\n-            hir::ItemKind::Impl(.., Some(_), _, _) => {\n-                // \"Trait\" impl\n-                debug!(\"coherence2::orphan check: trait impl {}\",\n-                       self.tcx.hir.node_to_string(item.id));\n-                let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n-                let trait_def_id = trait_ref.def_id;\n-                let cm = self.tcx.sess.source_map();\n-                let sp = cm.def_span(item.span);\n-                match traits::orphan_check(self.tcx, def_id) {\n-                    Ok(()) => {}\n-                    Err(traits::OrphanCheckErr::NoLocalInputType) => {\n-                        struct_span_err!(self.tcx.sess,\n-                                         sp,\n-                                         E0117,\n-                                         \"only traits defined in the current crate can be \\\n-                                          implemented for arbitrary types\")\n-                            .span_label(sp, \"impl doesn't use types inside crate\")\n-                            .note(\"the impl does not reference any types defined in this crate\")\n-                            .note(\"define and implement a trait or new type instead\")\n-                            .emit();\n-                        return;\n-                    }\n-                    Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n-                        struct_span_err!(self.tcx.sess,\n-                                         sp,\n-                                         E0210,\n-                                         \"type parameter `{}` must be used as the type parameter \\\n-                                          for some local type (e.g. `MyStruct<{}>`)\",\n-                                         param_ty,\n-                                         param_ty)\n-                            .span_label(sp,\n-                                        format!(\"type parameter `{}` must be used as the type \\\n-                                                 parameter for some local type\", param_ty))\n-                            .note(\"only traits defined in the current crate can be implemented \\\n-                                   for a type parameter\")\n-                            .emit();\n-                        return;\n-                    }\n+        // \"Trait\" impl\n+        if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n+            debug!(\"coherence2::orphan check: trait impl {}\",\n+                   self.tcx.hir.node_to_string(item.id));\n+            let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n+            let trait_def_id = trait_ref.def_id;\n+            let cm = self.tcx.sess.source_map();\n+            let sp = cm.def_span(item.span);\n+            match traits::orphan_check(self.tcx, def_id) {\n+                Ok(()) => {}\n+                Err(traits::OrphanCheckErr::NoLocalInputType) => {\n+                    struct_span_err!(self.tcx.sess,\n+                                     sp,\n+                                     E0117,\n+                                     \"only traits defined in the current crate can be \\\n+                                      implemented for arbitrary types\")\n+                        .span_label(sp, \"impl doesn't use types inside crate\")\n+                        .note(\"the impl does not reference any types defined in this crate\")\n+                        .note(\"define and implement a trait or new type instead\")\n+                        .emit();\n+                    return;\n+                }\n+                Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n+                    struct_span_err!(self.tcx.sess,\n+                                     sp,\n+                                     E0210,\n+                                     \"type parameter `{}` must be used as the type parameter \\\n+                                      for some local type (e.g. `MyStruct<{}>`)\",\n+                                     param_ty,\n+                                     param_ty)\n+                        .span_label(sp,\n+                                    format!(\"type parameter `{}` must be used as the type \\\n+                                             parameter for some local type\", param_ty))\n+                        .note(\"only traits defined in the current crate can be implemented \\\n+                               for a type parameter\")\n+                        .emit();\n+                    return;\n                 }\n+            }\n \n-                // In addition to the above rules, we restrict impls of auto traits\n-                // so that they can only be implemented on nominal types, such as structs,\n-                // enums or foreign types. To see why this restriction exists, consider the\n-                // following example (#22978). Imagine that crate A defines an auto trait\n-                // `Foo` and a fn that operates on pairs of types:\n-                //\n-                // ```\n-                // // Crate A\n-                // auto trait Foo { }\n-                // fn two_foos<A:Foo,B:Foo>(..) {\n-                //     one_foo::<(A,B)>(..)\n-                // }\n-                // fn one_foo<T:Foo>(..) { .. }\n-                // ```\n-                //\n-                // This type-checks fine; in particular the fn\n-                // `two_foos` is able to conclude that `(A,B):Foo`\n-                // because `A:Foo` and `B:Foo`.\n-                //\n-                // Now imagine that crate B comes along and does the following:\n-                //\n-                // ```\n-                // struct A { }\n-                // struct B { }\n-                // impl Foo for A { }\n-                // impl Foo for B { }\n-                // impl !Send for (A, B) { }\n-                // ```\n-                //\n-                // This final impl is legal according to the orpan\n-                // rules, but it invalidates the reasoning from\n-                // `two_foos` above.\n-                debug!(\"trait_ref={:?} trait_def_id={:?} trait_is_auto={}\",\n-                       trait_ref,\n-                       trait_def_id,\n-                       self.tcx.trait_is_auto(trait_def_id));\n-                if self.tcx.trait_is_auto(trait_def_id) &&\n-                   !trait_def_id.is_local() {\n-                    let self_ty = trait_ref.self_ty();\n-                    let opt_self_def_id = match self_ty.sty {\n-                        ty::Adt(self_def, _) => Some(self_def.did),\n-                        ty::Foreign(did) => Some(did),\n-                        _ => None,\n-                    };\n+            // In addition to the above rules, we restrict impls of auto traits\n+            // so that they can only be implemented on nominal types, such as structs,\n+            // enums or foreign types. To see why this restriction exists, consider the\n+            // following example (#22978). Imagine that crate A defines an auto trait\n+            // `Foo` and a fn that operates on pairs of types:\n+            //\n+            // ```\n+            // // Crate A\n+            // auto trait Foo { }\n+            // fn two_foos<A:Foo,B:Foo>(..) {\n+            //     one_foo::<(A,B)>(..)\n+            // }\n+            // fn one_foo<T:Foo>(..) { .. }\n+            // ```\n+            //\n+            // This type-checks fine; in particular the fn\n+            // `two_foos` is able to conclude that `(A,B):Foo`\n+            // because `A:Foo` and `B:Foo`.\n+            //\n+            // Now imagine that crate B comes along and does the following:\n+            //\n+            // ```\n+            // struct A { }\n+            // struct B { }\n+            // impl Foo for A { }\n+            // impl Foo for B { }\n+            // impl !Send for (A, B) { }\n+            // ```\n+            //\n+            // This final impl is legal according to the orpan\n+            // rules, but it invalidates the reasoning from\n+            // `two_foos` above.\n+            debug!(\"trait_ref={:?} trait_def_id={:?} trait_is_auto={}\",\n+                   trait_ref,\n+                   trait_def_id,\n+                   self.tcx.trait_is_auto(trait_def_id));\n+            if self.tcx.trait_is_auto(trait_def_id) &&\n+               !trait_def_id.is_local() {\n+                let self_ty = trait_ref.self_ty();\n+                let opt_self_def_id = match self_ty.sty {\n+                    ty::Adt(self_def, _) => Some(self_def.did),\n+                    ty::Foreign(did) => Some(did),\n+                    _ => None,\n+                };\n \n-                    let msg = match opt_self_def_id {\n-                        // We only want to permit nominal types, but not *all* nominal types.\n-                        // They must be local to the current crate, so that people\n-                        // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n-                        // `impl !Send for Box<SomethingLocalAndSend>`.\n-                        Some(self_def_id) => {\n-                            if self_def_id.is_local() {\n-                                None\n-                            } else {\n-                                Some((\n-                                    format!(\"cross-crate traits with a default impl, like `{}`, \\\n-                                             can only be implemented for a struct/enum type \\\n-                                             defined in the current crate\",\n-                                            self.tcx.item_path_str(trait_def_id)),\n-                                    \"can't implement cross-crate trait for type in another crate\"\n-                                ))\n-                            }\n-                        }\n-                        _ => {\n-                            Some((format!(\"cross-crate traits with a default impl, like `{}`, can \\\n-                                           only be implemented for a struct/enum type, not `{}`\",\n-                                          self.tcx.item_path_str(trait_def_id),\n-                                          self_ty),\n-                                  \"can't implement cross-crate trait with a default impl for \\\n-                                   non-struct/enum type\"))\n+                let msg = match opt_self_def_id {\n+                    // We only want to permit nominal types, but not *all* nominal types.\n+                    // They must be local to the current crate, so that people\n+                    // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n+                    // `impl !Send for Box<SomethingLocalAndSend>`.\n+                    Some(self_def_id) => {\n+                        if self_def_id.is_local() {\n+                            None\n+                        } else {\n+                            Some((\n+                                format!(\"cross-crate traits with a default impl, like `{}`, \\\n+                                         can only be implemented for a struct/enum type \\\n+                                         defined in the current crate\",\n+                                        self.tcx.item_path_str(trait_def_id)),\n+                                \"can't implement cross-crate trait for type in another crate\"\n+                            ))\n                         }\n-                    };\n-\n-                    if let Some((msg, label)) = msg {\n-                        struct_span_err!(self.tcx.sess, sp, E0321, \"{}\", msg)\n-                            .span_label(sp, label)\n-                            .emit();\n-                        return;\n                     }\n+                    _ => {\n+                        Some((format!(\"cross-crate traits with a default impl, like `{}`, can \\\n+                                       only be implemented for a struct/enum type, not `{}`\",\n+                                      self.tcx.item_path_str(trait_def_id),\n+                                      self_ty),\n+                              \"can't implement cross-crate trait with a default impl for \\\n+                               non-struct/enum type\"))\n+                    }\n+                };\n+\n+                if let Some((msg, label)) = msg {\n+                    struct_span_err!(self.tcx.sess, sp, E0321, \"{}\", msg)\n+                        .span_label(sp, label)\n+                        .emit();\n+                    return;\n                 }\n             }\n-            _ => {\n-                // Not an impl\n-            }\n         }\n     }\n "}, {"sha": "bdbf93ddec286c2506b7d2ce91b703f4fd8a31a5", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -29,52 +29,49 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                 item: &'v hir::Item,\n                                 impl_generics: Option<&hir::Generics>,\n                                 unsafety: hir::Unsafety,\n-                                polarity: hir::ImplPolarity) {\n-        match self.tcx.impl_trait_ref(self.tcx.hir.local_def_id(item.id)) {\n-            None => {}\n-\n-            Some(trait_ref) => {\n-                let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                let unsafe_attr = impl_generics.and_then(|generics| {\n-                    generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")\n-                });\n-                match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n-                    (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n-                        span_err!(self.tcx.sess,\n-                                  item.span,\n-                                  E0199,\n-                                  \"implementing the trait `{}` is not unsafe\",\n-                                  trait_ref);\n-                    }\n+                                polarity: hir::ImplPolarity)\n+    {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(self.tcx.hir.local_def_id(item.id)) {\n+            let trait_def = self.tcx.trait_def(trait_ref.def_id);\n+            let unsafe_attr = impl_generics.and_then(|generics| {\n+                generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")\n+            });\n+            match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n+                (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n+                    span_err!(self.tcx.sess,\n+                              item.span,\n+                              E0199,\n+                              \"implementing the trait `{}` is not unsafe\",\n+                              trait_ref);\n+                }\n \n-                    (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n-                        span_err!(self.tcx.sess,\n-                                  item.span,\n-                                  E0200,\n-                                  \"the trait `{}` requires an `unsafe impl` declaration\",\n-                                  trait_ref);\n-                    }\n+                (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                    span_err!(self.tcx.sess,\n+                              item.span,\n+                              E0200,\n+                              \"the trait `{}` requires an `unsafe impl` declaration\",\n+                              trait_ref);\n+                }\n \n-                    (Unsafety::Normal, Some(attr_name), Unsafety::Normal,\n-                        hir::ImplPolarity::Positive) =>\n-                    {\n-                        span_err!(self.tcx.sess,\n-                                  item.span,\n-                                  E0569,\n-                                  \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n-                                  attr_name);\n-                    }\n+                (Unsafety::Normal, Some(attr_name), Unsafety::Normal,\n+                    hir::ImplPolarity::Positive) =>\n+                {\n+                    span_err!(self.tcx.sess,\n+                              item.span,\n+                              E0569,\n+                              \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n+                              attr_name);\n+                }\n \n-                    (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n-                        // Reported in AST validation\n-                        self.tcx.sess.delay_span_bug(item.span, \"unsafe negative impl\");\n-                    }\n-                    (_, _, Unsafety::Normal, hir::ImplPolarity::Negative) |\n-                    (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n-                    (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n-                    (Unsafety::Normal, None, Unsafety::Normal, _) => {\n-                        // OK\n-                    }\n+                (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n+                    // Reported in AST validation\n+                    self.tcx.sess.delay_span_bug(item.span, \"unsafe negative impl\");\n+                }\n+                (_, _, Unsafety::Normal, hir::ImplPolarity::Negative) |\n+                (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                (Unsafety::Normal, None, Unsafety::Normal, _) => {\n+                    // OK\n                 }\n             }\n         }\n@@ -83,11 +80,8 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n \n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n-            hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) => {\n-                self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n-            }\n-            _ => {}\n+        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.node {\n+            self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n         }\n     }\n "}, {"sha": "bffdf7772401e8d5cca02ce6839afc4513fdb89d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -64,8 +64,8 @@ use std::iter;\n pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = CollectItemTypesVisitor { tcx: tcx };\n     tcx.hir\n-        .krate()\n-        .visit_all_item_likes(&mut visitor.as_deep_visitor());\n+       .krate()\n+       .visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -197,7 +197,8 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n             E0121,\n             \"the type placeholder `_` is not allowed within types on item signatures\"\n         ).span_label(span, \"not allowed in type signatures\")\n-            .emit();\n+         .emit();\n+\n         self.tcx().types.err\n     }\n \n@@ -529,12 +530,11 @@ fn convert_enum_variant_types<'a, 'tcx>(\n                 ).span_label(\n                     variant.span,\n                     format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n-                )\n-                    .note(&format!(\n-                        \"explicitly set `{} = {}` if that is desired outcome\",\n-                        variant.node.name, wrapped_discr\n-                    ))\n-                    .emit();\n+                ).note(&format!(\n+                    \"explicitly set `{} = {}` if that is desired outcome\",\n+                    variant.node.name, wrapped_discr\n+                ))\n+                .emit();\n                 None\n             }.unwrap_or(wrapped_discr),\n         );\n@@ -577,8 +577,8 @@ fn convert_variant<'a, 'tcx>(\n                     \"field `{}` is already declared\",\n                     f.ident\n                 ).span_label(f.span, \"field already declared\")\n-                    .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n-                    .emit();\n+                 .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n+                 .emit();\n             } else {\n                 seen_fields.insert(f.ident.modern(), f.span);\n             }\n@@ -824,14 +824,11 @@ fn has_late_bound_regions<'a, 'tcx>(\n             has_late_bound_regions: None,\n         };\n         for param in &generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    let hir_id = tcx.hir.node_to_hir_id(param.id);\n-                    if tcx.is_late_bound(hir_id) {\n-                        return Some(param.span);\n-                    }\n+            if let GenericParamKind::Lifetime { .. } = param.kind {\n+                let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                if tcx.is_late_bound(hir_id) {\n+                    return Some(param.span);\n                 }\n-                _ => {}\n             }\n         }\n         visitor.visit_fn_decl(decl);\n@@ -1314,6 +1311,7 @@ fn find_existential_constraints<'a, 'tcx>(\n         def_id: DefId,\n         found: Option<(Span, ty::Ty<'tcx>)>,\n     }\n+\n     impl<'a, 'tcx> ConstraintLocator<'a, 'tcx> {\n         fn check(&mut self, def_id: DefId) {\n             trace!(\"checking {:?}\", def_id);\n@@ -1347,6 +1345,7 @@ fn find_existential_constraints<'a, 'tcx>(\n             }\n         }\n     }\n+\n     impl<'a, 'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'a, 'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir)\n@@ -1373,14 +1372,17 @@ fn find_existential_constraints<'a, 'tcx>(\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n+\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,\n         found: None,\n     };\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let parent = tcx.hir.get_parent(node_id);\n+\n     trace!(\"parent_id: {:?}\", parent);\n+\n     if parent == ast::CRATE_NODE_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir.krate());\n     } else {\n@@ -1395,6 +1397,7 @@ fn find_existential_constraints<'a, 'tcx>(\n             ),\n         }\n     }\n+\n     match locator.found {\n         Some((_, ty)) => ty,\n         None => {\n@@ -1786,17 +1789,14 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n     for param in &ast_generics.params {\n-        match param.kind {\n-            GenericParamKind::Type { .. } => {\n-                let name = param.name.ident().as_interned_str();\n-                let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n-                index += 1;\n-\n-                let sized = SizedByDefault::Yes;\n-                let bounds = compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n-                predicates.extend(bounds.predicates(tcx, param_ty));\n-            }\n-            _ => {}\n+        if let GenericParamKind::Type { .. } = param.kind {\n+            let name = param.name.ident().as_interned_str();\n+            let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n+            index += 1;\n+\n+            let sized = SizedByDefault::Yes;\n+            let bounds = compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n+            predicates.extend(bounds.predicates(tcx, param_ty));\n         }\n     }\n \n@@ -1835,10 +1835,10 @@ fn explicit_predicates_of<'a, 'tcx>(\n                                 &mut projections,\n                             );\n \n-                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n-                            predicates.extend(projections.iter().map(|&(p, span)| {\n-                                (p.to_predicate(), span)\n-                            }));\n+                            predicates.extend(\n+                                iter::once((trait_ref.to_predicate(), poly_trait_ref.span)).chain(\n+                                    projections.iter().map(|&(p, span)| (p.to_predicate(), span)\n+                            )));\n                         }\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n@@ -1852,16 +1852,17 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n                 let r1 = AstConv::ast_region_to_region(&icx, &region_pred.lifetime, None);\n-                for bound in &region_pred.bounds {\n+                predicates.extend(region_pred.bounds.iter().map(|bound| {\n                     let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n                             (AstConv::ast_region_to_region(&icx, lt, None), lt.span)\n                         }\n                         _ => bug!(),\n                     };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n-                    predicates.push((ty::Predicate::RegionOutlives(pred), span))\n-                }\n+\n+                    (ty::Predicate::RegionOutlives(pred), span)\n+                }))\n             }\n \n             &hir::WherePredicate::EqPredicate(..) => {\n@@ -1876,9 +1877,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             let trait_item = tcx.hir.trait_item(trait_item_ref.id);\n             let bounds = match trait_item.node {\n                 hir::TraitItemKind::Type(ref bounds, _) => bounds,\n-                _ => {\n-                    return vec![].into_iter();\n-                }\n+                _ => return vec![].into_iter()\n             };\n \n             let assoc_ty =\n@@ -1939,6 +1938,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n ) -> Bounds<'tcx> {\n     let mut region_bounds = vec![];\n     let mut trait_bounds = vec![];\n+\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => trait_bounds.push(b),\n@@ -2032,16 +2032,16 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n         let check = |ast_ty: &hir::Ty, ty: Ty| {\n             if ty.is_simd() {\n                 tcx.sess\n-                    .struct_span_err(\n-                        ast_ty.span,\n-                        &format!(\n-                            \"use of SIMD type `{}` in FFI is highly experimental and \\\n-                             may result in invalid code\",\n-                            tcx.hir.node_to_pretty_string(ast_ty.id)\n-                        ),\n-                    )\n-                    .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n-                    .emit();\n+                   .struct_span_err(\n+                       ast_ty.span,\n+                       &format!(\n+                           \"use of SIMD type `{}` in FFI is highly experimental and \\\n+                            may result in invalid code\",\n+                           tcx.hir.node_to_pretty_string(ast_ty.id)\n+                       ),\n+                   )\n+                   .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n+                   .emit();\n             }\n         };\n         for (input, ty) in decl.inputs.iter().zip(*fty.inputs().skip_binder()) {\n@@ -2101,7 +2101,7 @@ fn from_target_feature(\n         };\n \n         // We allow comma separation to enable multiple features\n-        for feature in value.as_str().split(',') {\n+        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n             // Only allow whitelisted features per platform\n             let feature_gate = match whitelist.get(feature) {\n                 Some(g) => g,\n@@ -2120,7 +2120,7 @@ fn from_target_feature(\n                         }\n                     }\n                     err.emit();\n-                    continue;\n+                    return None;\n                 }\n             };\n \n@@ -2147,10 +2147,10 @@ fn from_target_feature(\n                     feature_gate::GateIssue::Language,\n                     &format!(\"the target feature `{}` is currently unstable\", feature),\n                 );\n-                continue;\n+                return None;\n             }\n-            target_features.push(Symbol::intern(feature));\n-        }\n+            Some(Symbol::intern(feature))\n+        }));\n     }\n }\n \n@@ -2183,7 +2183,7 @@ fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &\n                 tcx.sess.span_fatal(span, \"invalid linkage specified\")\n             } else {\n                 tcx.sess\n-                    .fatal(&format!(\"invalid linkage specified: {}\", name))\n+                   .fatal(&format!(\"invalid linkage specified: {}\", name))\n             }\n         }\n     }\n@@ -2281,7 +2281,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     E0558,\n                     \"`export_name` attribute has invalid format\"\n                 ).span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n-                    .emit();\n+                 .emit();\n             }\n         } else if attr.check_name(\"target_feature\") {\n             if tcx.fn_sig(id).unsafety() == Unsafety::Normal {"}, {"sha": "9299e9b7b8f159ddbfe14c943c1f5f06bde20259", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -77,11 +77,8 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match *r {\n-            ty::ReEarlyBound(data) => {\n-                self.parameters.push(Parameter::from(data));\n-            }\n-            _ => {}\n+        if let ty::ReEarlyBound(data) = *r {\n+            self.parameters.push(Parameter::from(data));\n         }\n         false\n     }\n@@ -204,6 +201,6 @@ pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt,\n         }\n         debug!(\"setup_constraining_predicates: predicates={:?} \\\n                 i={} impl_trait_ref={:?} input_parameters={:?}\",\n-           predicates, i, impl_trait_ref, input_parameters);\n+               predicates, i, impl_trait_ref, input_parameters);\n     }\n }"}, {"sha": "7e0a8d63e2889a13b70084ca38455829beed28f0", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -71,15 +71,12 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n-            hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n-                enforce_impl_params_are_constrained(self.tcx,\n-                                                    impl_def_id,\n-                                                    impl_item_refs);\n-                enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n-            }\n-            _ => { }\n+        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n+            let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+            enforce_impl_params_are_constrained(self.tcx,\n+                                                impl_def_id,\n+                                                impl_item_refs);\n+            enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n         }\n     }\n \n@@ -182,7 +179,7 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let impl_item = tcx.hir.impl_item(impl_item_ref.id);\n         let seen_items = match impl_item.node {\n             hir::ImplItemKind::Type(_) => &mut seen_type_items,\n-            _                    => &mut seen_value_items,\n+            _                          => &mut seen_value_items,\n         };\n         match seen_items.entry(impl_item.ident.modern()) {\n             Occupied(entry) => {\n@@ -191,7 +188,7 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                impl_item.ident);\n                 err.span_label(*entry.get(),\n                                format!(\"previous definition of `{}` here\",\n-                                        impl_item.ident));\n+                                       impl_item.ident));\n                 err.span_label(impl_item.span, \"duplicate definition\");\n                 err.emit();\n             }"}, {"sha": "a00a9f8613b64b75554a144fc50987ad75e5257b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -146,7 +146,7 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              span: Span) {\n     if decl.variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n-                  \"variadic function must have C or cdecl calling convention\");\n+            \"variadic function must have C or cdecl calling convention\");\n         err.span_label(span, \"variadics require C or cdecl calling convention\").emit();\n     }\n }\n@@ -186,35 +186,29 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n         ty::FnDef(..) => {\n-            match tcx.hir.find(main_id) {\n-                Some(Node::Item(it)) => {\n-                    match it.node {\n-                        hir::ItemKind::Fn(.., ref generics, _) => {\n-                            let mut error = false;\n-                            if !generics.params.is_empty() {\n-                                let msg = \"`main` function is not allowed to have generic \\\n-                                           parameters\".to_string();\n-                                let label = \"`main` cannot have generic parameters\".to_string();\n-                                struct_span_err!(tcx.sess, generics.span, E0131, \"{}\", msg)\n-                                    .span_label(generics.span, label)\n-                                    .emit();\n-                                error = true;\n-                            }\n-                            if let Some(sp) = generics.where_clause.span() {\n-                                struct_span_err!(tcx.sess, sp, E0646,\n-                                    \"`main` function is not allowed to have a `where` clause\")\n-                                    .span_label(sp, \"`main` cannot have a `where` clause\")\n-                                    .emit();\n-                                error = true;\n-                            }\n-                            if error {\n-                                return;\n-                            }\n-                        }\n-                        _ => ()\n+            if let Some(Node::Item(it)) = tcx.hir.find(main_id) {\n+                if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n+                    let mut error = false;\n+                    if !generics.params.is_empty() {\n+                        let msg = \"`main` function is not allowed to have generic \\\n+                                   parameters\".to_owned();\n+                        let label = \"`main` cannot have generic parameters\".to_string();\n+                        struct_span_err!(tcx.sess, generics.span, E0131, \"{}\", msg)\n+                            .span_label(generics.span, label)\n+                            .emit();\n+                        error = true;\n+                    }\n+                    if let Some(sp) = generics.where_clause.span() {\n+                        struct_span_err!(tcx.sess, sp, E0646,\n+                            \"`main` function is not allowed to have a `where` clause\")\n+                            .span_label(sp, \"`main` cannot have a `where` clause\")\n+                            .emit();\n+                        error = true;\n+                    }\n+                    if error {\n+                        return;\n                     }\n                 }\n-                _ => ()\n             }\n \n             let actual = tcx.fn_sig(main_def_id);\n@@ -258,34 +252,28 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n         ty::FnDef(..) => {\n-            match tcx.hir.find(start_id) {\n-                Some(Node::Item(it)) => {\n-                    match it.node {\n-                        hir::ItemKind::Fn(.., ref generics, _) => {\n-                            let mut error = false;\n-                            if !generics.params.is_empty() {\n-                                struct_span_err!(tcx.sess, generics.span, E0132,\n-                                    \"start function is not allowed to have type parameters\")\n-                                    .span_label(generics.span,\n-                                                \"start function cannot have type parameters\")\n-                                    .emit();\n-                                error = true;\n-                            }\n-                            if let Some(sp) = generics.where_clause.span() {\n-                                struct_span_err!(tcx.sess, sp, E0647,\n-                                    \"start function is not allowed to have a `where` clause\")\n-                                    .span_label(sp, \"start function cannot have a `where` clause\")\n-                                    .emit();\n-                                error = true;\n-                            }\n-                            if error {\n-                                return;\n-                            }\n-                        }\n-                        _ => ()\n+            if let Some(Node::Item(it)) = tcx.hir.find(start_id) {\n+                if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n+                    let mut error = false;\n+                    if !generics.params.is_empty() {\n+                        struct_span_err!(tcx.sess, generics.span, E0132,\n+                            \"start function is not allowed to have type parameters\")\n+                            .span_label(generics.span,\n+                                        \"start function cannot have type parameters\")\n+                            .emit();\n+                        error = true;\n+                    }\n+                    if let Some(sp) = generics.where_clause.span() {\n+                        struct_span_err!(tcx.sess, sp, E0647,\n+                            \"start function is not allowed to have a `where` clause\")\n+                            .span_label(sp, \"start function cannot have a `where` clause\")\n+                            .emit();\n+                        error = true;\n+                    }\n+                    if error {\n+                        return;\n                     }\n                 }\n-                _ => ()\n             }\n \n             let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(\n@@ -388,6 +376,7 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n     let env_node_id = tcx.hir.get_parent(hir_ty.id);\n     let env_def_id = tcx.hir.local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+\n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n@@ -403,6 +392,7 @@ pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait:\n     let principal = astconv::AstConv::instantiate_poly_trait_ref_inner(\n         &item_cx, hir_trait, tcx.types.err, &mut projections, true\n     );\n+\n     (principal, projections)\n }\n "}, {"sha": "cca77b20d9b30ba3a729aba5b59e974bafa8657a", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -55,9 +55,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n                         .iter()\n                         .map(|out_pred| match out_pred {\n                             ty::Predicate::RegionOutlives(p) => p.to_string(),\n-\n                             ty::Predicate::TypeOutlives(p) => p.to_string(),\n-\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         }).collect();\n                     pred.sort();"}, {"sha": "48c495e1c93170806f8a25939ce3c4f4d359b293", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -14,8 +14,8 @@ use rustc::ty::TyCtxt;\n \n pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir\n-        .krate()\n-        .visit_all_item_likes(&mut OutlivesTest { tcx });\n+       .krate()\n+       .visit_all_item_likes(&mut OutlivesTest { tcx });\n }\n \n struct OutlivesTest<'a, 'tcx: 'a> {"}, {"sha": "6bf7a3501bed997b092bdafbdc8e2b0c5b1530a2", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -148,15 +148,9 @@ fn is_free_region<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, region: Region<'_>) -> bool\n         //         field: &'static T, // this would generate a ReStatic\n         //     }\n         RegionKind::ReStatic => {\n-            if tcx\n-                .sess\n-                .features_untracked()\n-                .infer_static_outlives_requirements\n-            {\n-                true\n-            } else {\n-                false\n-            }\n+            tcx.sess\n+               .features_untracked()\n+               .infer_static_outlives_requirements\n         }\n \n         // Late-bound regions can appear in `fn` types:"}, {"sha": "25f6b259e96bcaebbf59488219fc690adbf8471a", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608c395818c18ac2a91d0f4409296b788bd4e4ef/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=608c395818c18ac2a91d0f4409296b788bd4e4ef", "patch": "@@ -55,7 +55,7 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n }\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n-                            -> Lrc<Vec<ty::Variance>> {\n+                          -> Lrc<Vec<ty::Variance>> {\n     let id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant."}]}