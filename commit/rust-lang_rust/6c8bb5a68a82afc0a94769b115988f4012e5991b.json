{"sha": "6c8bb5a68a82afc0a94769b115988f4012e5991b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOGJiNWE2OGE4MmFmYzBhOTQ3NjliMTE1OTg4ZjQwMTJlNTk5MWI=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-07T22:15:31Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T17:10:38Z"}, "message": "macro in method position parsing", "tree": {"sha": "292481a0f09c8fd173845c3785edc9018f79fcf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/292481a0f09c8fd173845c3785edc9018f79fcf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c8bb5a68a82afc0a94769b115988f4012e5991b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8bb5a68a82afc0a94769b115988f4012e5991b", "html_url": "https://github.com/rust-lang/rust/commit/6c8bb5a68a82afc0a94769b115988f4012e5991b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c8bb5a68a82afc0a94769b115988f4012e5991b/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee2155fe02cf5c7d8717358e2e10aff9a659b5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee2155fe02cf5c7d8717358e2e10aff9a659b5f", "html_url": "https://github.com/rust-lang/rust/commit/6ee2155fe02cf5c7d8717358e2e10aff9a659b5f"}], "stats": {"total": 55, "additions": 42, "deletions": 13}, "files": [{"sha": "e0c94dffb5cae342603ddb9cf1fcdc6e9e9dc777", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6c8bb5a68a82afc0a94769b115988f4012e5991b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8bb5a68a82afc0a94769b115988f4012e5991b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6c8bb5a68a82afc0a94769b115988f4012e5991b", "patch": "@@ -3246,6 +3246,7 @@ impl<'a> Parser<'a> {\n         } else if is_ident(&self.token)\n             && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n+            // it's a macro invocation:\n \n             check_expected_item(self, !item_attrs.is_empty());\n \n@@ -4021,7 +4022,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self,\n+    pub fn parse_method(&mut self,\n                     already_parsed_attrs: Option<Vec<Attribute>>) -> Gc<Method> {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n@@ -4031,22 +4032,50 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let visa = self.parse_visibility();\n-        let fn_style = self.parse_fn_style();\n-        let ident = self.parse_ident();\n-        let generics = self.parse_generics();\n-        let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n-            p.parse_arg()\n-        });\n+        // code copied from parse_macro_use_or_failure... abstraction!\n+        let (method_, hi, new_attrs) = {\n+            if !token::is_any_keyword(&self.token)\n+                && self.look_ahead(1, |t| *t == token::NOT)\n+                && (self.look_ahead(2, |t| *t == token::LPAREN)\n+                    || self.look_ahead(2, |t| *t == token::LBRACE)) {\n+                // method macro.\n+                let pth = self.parse_path(NoTypesAllowed).path;\n+                self.expect(&token::NOT);\n \n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-        let hi = body.span.hi;\n-        let attrs = attrs.append(inner_attrs.as_slice());\n+                // eat a matched-delimiter token tree:\n+                let tts = match token::close_delimiter_for(&self.token) {\n+                    Some(ket) => {\n+                        self.bump();\n+                        self.parse_seq_to_end(&ket,\n+                                              seq_sep_none(),\n+                                              |p| p.parse_token_tree())\n+                    }\n+                    None => self.fatal(\"expected open delimiter\")\n+                };\n+                let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n+                let m: ast::Mac = codemap::Spanned { node: m_,\n+                                                 span: mk_sp(self.span.lo,\n+                                                             self.span.hi) };\n+                (ast::MethMac(m), self.span.hi, attrs)\n+            } else {\n+                let visa = self.parse_visibility();\n+                let fn_style = self.parse_fn_style();\n+                let ident = self.parse_ident();\n+                let generics = self.parse_generics();\n+                let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n+                        p.parse_arg()\n+                    });\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n+                let new_attrs = attrs.append(inner_attrs.as_slice());\n+                (ast::MethDecl(ident, generics, explicit_self, fn_style, decl, body, visa),\n+                 body.span.hi, new_attrs)\n+            }\n+        };\n         box(GC) ast::Method {\n-            attrs: attrs,\n+            attrs: new_attrs,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n-            node: ast::MethDecl(ident, generics, explicit_self, fn_style, decl, body, visa),\n+            node: method_,\n         }\n     }\n "}]}