{"sha": "26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZTZlYjNkMTRkN2ZmM2JjYmZhNWNhNDQyYTY5Mjg3NzY5ODJlOTg=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-10T17:58:44Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-11T05:00:47Z"}, "message": "Handle failure conditions correctly in pipes.", "tree": {"sha": "81a017f6b8e77536ec47fb0b9045c34979edeec9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81a017f6b8e77536ec47fb0b9045c34979edeec9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "html_url": "https://github.com/rust-lang/rust/commit/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d07e537fc3daaf73b7baf652e13ee2d36706258e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d07e537fc3daaf73b7baf652e13ee2d36706258e", "html_url": "https://github.com/rust-lang/rust/commit/d07e537fc3daaf73b7baf652e13ee2d36706258e"}], "stats": {"total": 67, "additions": 48, "deletions": 19}, "files": [{"sha": "7e05f048dad923330d75473520bf3d5b9bb5e268", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "patch": "@@ -47,7 +47,7 @@ extern mod rustrt {\n     #[rust_stack]\n     fn task_clear_event_reject(task: *rust_task);\n \n-    fn task_wait_event(this: *rust_task) -> *libc::c_void;\n+    fn task_wait_event(this: *rust_task, killed: &mut bool) -> *libc::c_void;\n     fn task_signal_event(target: *rust_task, event: *libc::c_void);\n }\n \n@@ -57,6 +57,16 @@ unsafe fn uniquify<T>(x: *T) -> ~T {\n     unsafe { unsafe::reinterpret_cast(x) }\n }\n \n+fn wait_event(this: *rust_task) -> *libc::c_void {\n+    let mut killed = false;\n+\n+    let res = rustrt::task_wait_event(this, &mut killed);\n+    if killed && !task::failing() {\n+        fail \"killed\"\n+    }\n+    res\n+}\n+\n fn swap_state_acq(&dst: state, src: state) -> state {\n     unsafe {\n         reinterpret_cast(rusti::atomic_xchng_acq(\n@@ -113,23 +123,23 @@ fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n     p.header.blocked_task = some(this);\n+    let mut first = true;\n     loop {\n+        rustrt::task_clear_event_reject(this);\n         let old_state = swap_state_acq(p.header.state,\n                                        blocked);\n         #debug(\"%?\", old_state);\n         alt old_state {\n           empty {\n             #debug(\"no data available on %?, going to sleep.\", p_);\n-            rustrt::task_wait_event(this);\n+            wait_event(this);\n             #debug(\"woke up, p.state = %?\", p.header.state);\n-            if p.header.state == full {\n-                let mut payload = none;\n-                payload <-> (*p).payload;\n-                p.header.state = terminated;\n-                ret some(option::unwrap(payload))\n+          }\n+          blocked {\n+            if first {\n+                fail \"blocking on already blocked packet\"\n             }\n           }\n-          blocked { fail \"blocking on already blocked packet\" }\n           full {\n             let mut payload = none;\n             payload <-> (*p).payload;\n@@ -141,11 +151,12 @@ fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n             ret none;\n           }\n         }\n+        first = false;\n     }\n }\n \n /// Returns true if messages are available.\n-fn peek<T: send>(p: recv_packet<T>) -> bool {\n+pure fn peek<T: send>(p: recv_packet<T>) -> bool {\n     alt p.header().state {\n       empty { false }\n       blocked { fail \"peeking on blocked packet\" }\n@@ -236,7 +247,7 @@ fn wait_many(pkts: ~[&a.packet_header]) -> uint {\n \n     while !data_avail {\n         #debug(\"sleeping on %? packets\", pkts.len());\n-        let event = rustrt::task_wait_event(this) as *packet_header;\n+        let event = wait_event(this) as *packet_header;\n         let pos = vec::position(pkts, |p| ptr::addr_of(*p) == event);\n \n         alt pos {\n@@ -356,7 +367,7 @@ class recv_packet<T: send> {\n         option::unwrap(p)\n     }\n \n-    fn header() -> &self.packet_header {\n+    pure fn header() -> &self.packet_header {\n         alt self.p {\n           some(packet) {\n             unsafe {"}, {"sha": "3d05611aa98f831a489326dc41d6c771add565f5", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "patch": "@@ -46,6 +46,7 @@ export future_result;\n export future_task;\n export unsupervise;\n export run_listener;\n+export run_with;\n \n export spawn;\n export spawn_with;"}, {"sha": "aa314d2811e914e53e828ab5fc63409970a84dd2", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "patch": "@@ -930,11 +930,11 @@ task_clear_event_reject(rust_task *task) {\n // Waits on an event, returning the pointer to the event that unblocked this\n // task.\n extern \"C\" void *\n-task_wait_event(rust_task *task) {\n+task_wait_event(rust_task *task, bool *killed) {\n     // TODO: we should assert that the passed in task is the currently running\n     // task. We wouldn't want to wait some other task.\n \n-    return task->wait_event();\n+    return task->wait_event(killed);\n }\n \n extern \"C\" void"}, {"sha": "f5e2fcc9a085f1d18f6b3c708a0002b45a7edc51", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "patch": "@@ -713,16 +713,14 @@ rust_task::allow_kill() {\n }\n \n void *\n-rust_task::wait_event() {\n+rust_task::wait_event(bool *killed) {\n     scoped_lock with(state_lock);\n \n     if(!event_reject) {\n         block_locked(&event_cond, \"waiting on event\");\n-        bool killed = false;\n         state_lock.unlock();\n-        yield(&killed);\n+        yield(killed);\n         state_lock.lock();\n-        // TODO: what is the right thing to do if we are killed?\n     }\n \n     event_reject = false;"}, {"sha": "6cb6dbaa65358f30e7f711fbaebb7f2e7522368f", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "patch": "@@ -316,7 +316,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n         this->event_reject = false;\n     }\n \n-    void *wait_event();\n+    void *wait_event(bool *killed);\n     void signal_event(void *event);\n \n     void cleanup_after_turn();"}, {"sha": "ae9e178e74c21c51f3eebf2f5f1896d59244ebf0", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e6eb3d14d7ff3bcbfa5ca442a6928776982e98/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=26e6eb3d14d7ff3bcbfa5ca442a6928776982e98", "patch": "@@ -26,5 +26,24 @@ fn main() {\n         }\n     });\n \n-    sleep(iotask, 1000);\n+    sleep(iotask, 100);\n+\n+    let b = task::builder();\n+    task::unsupervise(b);\n+    task::run(b, failtest);\n+}\n+\n+// Make sure the right thing happens during failure.\n+fn failtest() {\n+    let iotask = uv::global_loop::get();\n+    \n+    let (c, p) = oneshot::init();\n+\n+    do task::spawn_with(c) |_c| { \n+        fail;\n+    }\n+\n+    #error(\"%?\", recv(p));\n+    // make sure we get killed if we missed it in the receive.\n+    loop { task::yield() }\n }"}]}