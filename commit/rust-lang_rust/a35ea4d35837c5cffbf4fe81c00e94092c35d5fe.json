{"sha": "a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNWVhNGQzNTgzN2M1Y2ZmYmY0ZmU4MWMwMGU5NDA5MmMzNWQ1ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-09T01:34:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-09T01:34:24Z"}, "message": "Auto merge of #26117 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #25898, #25909, #25948, #25968, #26073, #26078, #26099, #26104, #26105, #26112, #26113\n- Failed merges:", "tree": {"sha": "44ba8f8585c67fdfa9391cdf10078c1d1b1c6405", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44ba8f8585c67fdfa9391cdf10078c1d1b1c6405"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "html_url": "https://github.com/rust-lang/rust/commit/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c8028ce0eaf18abb67e4e2dafc5aae2e6e91de", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c8028ce0eaf18abb67e4e2dafc5aae2e6e91de", "html_url": "https://github.com/rust-lang/rust/commit/d6c8028ce0eaf18abb67e4e2dafc5aae2e6e91de"}, {"sha": "fd2c76cd947ac28f9394cf533db0218473f39f36", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd2c76cd947ac28f9394cf533db0218473f39f36", "html_url": "https://github.com/rust-lang/rust/commit/fd2c76cd947ac28f9394cf533db0218473f39f36"}], "stats": {"total": 121, "additions": 85, "deletions": 36}, "files": [{"sha": "875a65e69fa9ff993e670e9e25a3bb51ec48df7b", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -1038,7 +1038,7 @@ be undesired.\n \n * Deadlocks\n * Reading data from private fields (`std::repr`)\n-* Leaks due to reference count cycles, even in the global heap\n+* Leaks of memory and other resources\n * Exiting without calling destructors\n * Sending signals\n * Accessing/modifying the file system\n@@ -1418,9 +1418,13 @@ impl<T> Container for Vec<T> {\n ```\n \n Generic functions may use traits as _bounds_ on their type parameters. This\n-will have two effects: only types that have the trait may instantiate the\n-parameter, and within the generic function, the methods of the trait can be\n-called on values that have the parameter's type. For example:\n+will have two effects:\n+\n+- Only types that have the trait may instantiate the parameter.\n+- Within the generic function, the methods of the trait can be\n+  called on values that have the parameter's type.\n+\n+For example:\n \n ```\n # type Surface = i32;\n@@ -2831,13 +2835,13 @@ on the right-hand side.\n An example of an `as` expression:\n \n ```\n-# fn sum(v: &[f64]) -> f64 { 0.0 }\n-# fn len(v: &[f64]) -> i32 { 0 }\n+# fn sum(values: &[f64]) -> f64 { 0.0 }\n+# fn len(values: &[f64]) -> i32 { 0 }\n \n-fn avg(v: &[f64]) -> f64 {\n-  let sum: f64 = sum(v);\n-  let sz: f64 = len(v) as f64;\n-  return sum / sz;\n+fn average(values: &[f64]) -> f64 {\n+  let sum: f64 = sum(values);\n+  let size: f64 = len(values) as f64;\n+  sum / size\n }\n ```\n "}, {"sha": "4479fdb7baae5dcedf5f2f3c487b64550df0cd6e", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -33,8 +33,8 @@ let plus_two = |x| {\n assert_eq!(4, plus_two(2));\n ```\n \n-You\u2019ll notice a few things about closures that are a bit different than regular\n-functions defined with `fn`. The first of which is that we did not need to\n+You\u2019ll notice a few things about closures that are a bit different from regular\n+functions defined with `fn`. The first is that we did not need to\n annotate the types of arguments the closure takes or the values it returns. We\n can:\n \n@@ -48,18 +48,18 @@ But we don\u2019t have to. Why is this? Basically, it was chosen for ergonomic reas\n While specifying the full type for named functions is helpful with things like\n documentation and type inference, the types of closures are rarely documented\n since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n-that inferring named function types can.\n+problems that inferring named function types can.\n \n The second is that the syntax is similar, but a bit different. I\u2019ve added spaces\n-here to make them look a little closer:\n+here for easier comparison:\n \n ```rust\n fn  plus_one_v1   (x: i32) -> i32 { x + 1 }\n let plus_one_v2 = |x: i32| -> i32 { x + 1 };\n let plus_one_v3 = |x: i32|          x + 1  ;\n ```\n \n-Small differences, but they\u2019re similar in ways.\n+Small differences, but they\u2019re similar.\n \n # Closures and their environment\n \n@@ -99,7 +99,7 @@ note: previous borrow ends here\n fn main() {\n     let mut num = 5;\n     let plus_num = |x| x + num;\n-    \n+\n     let y = &mut num;\n }\n ^\n@@ -161,7 +161,7 @@ of `num`. So what\u2019s the difference?\n ```rust\n let mut num = 5;\n \n-{ \n+{\n     let mut add_num = |x: i32| num += x;\n \n     add_num(5);\n@@ -180,7 +180,7 @@ If we change to a `move` closure, it\u2019s different:\n ```rust\n let mut num = 5;\n \n-{ \n+{\n     let mut add_num = move |x: i32| num += x;\n \n     add_num(5);"}, {"sha": "7687d2a57da9238de0900ee3e2ffda6f1d95cf25", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -29,6 +29,9 @@ The other kind of comment is a doc comment. Doc comments use `///` instead of\n /// let five = 5;\n ///\n /// assert_eq!(6, add_one(5));\n+/// # fn add_one(x: i32) -> i32 {\n+/// #     x + 1\n+/// # }\n /// ```\n fn add_one(x: i32) -> i32 {\n     x + 1"}, {"sha": "a18d9bb442dd26601b05dfe1f36b7c17321e32f5", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -432,7 +432,9 @@ an extra annotation, `move`, to indicate that the closure is going to take\n ownership of the values it\u2019s capturing. Primarily, the `p` variable of the\n `map` function.\n \n-Inside the thread, all we do is call `eat()` on `p`.\n+Inside the thread, all we do is call `eat()` on `p`. Also note that the call to `thread::spawn` lacks a trailing semicolon, making this an expression. This distinction is important, yielding the correct return value. For more details, read [Expressions vs. Statements][es].\n+\n+[es]: functions.html#expressions-vs.-statements\n \n ```rust,ignore\n }).collect();"}, {"sha": "2a0e8ed16436e08a2380286db3225fdbac67658f", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -284,7 +284,7 @@ struct Info {\n }\n \n fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = try!(File::create(\"my_best_friends.txt\"));\n+    let mut file = File::create(\"my_best_friends.txt\").unwrap();\n \n     try!(writeln!(&mut file, \"name: {}\", info.name));\n     try!(writeln!(&mut file, \"age: {}\", info.age));"}, {"sha": "c28d7c71608bbf82e754daae4bd1560e26efc7c6", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -1,8 +1,8 @@\n % Generics\n \n Sometimes, when writing a function or data type, we may want it to work for\n-multiple types of arguments. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called \u2018parametric polymorphism\u2019 in type theory,\n+multiple types of arguments. In Rust, we can do this with generics.\n+Generics are called \u2018parametric polymorphism\u2019 in type theory,\n which means that they are types or functions that have multiple forms (\u2018poly\u2019\n is multiple, \u2018morph\u2019 is form) over a given parameter (\u2018parametric\u2019).\n "}, {"sha": "9920e8e00685bf43640d8906bac7d3d218561552", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -36,7 +36,7 @@ Note that since we're creating an executable, we used `main.rs`. If we\n want to make a library instead, we should use `lib.rs`. This convention is required\n for Cargo to successfully compile our projects, but it can be overridden if we wish. \n Custom file locations for the entry point can be specified\n-with a [`[[lib]]` or `[[bin]]`][crates-custom] key in the TOML file described below.\n+with a [`[lib]` or `[[bin]]`][crates-custom] key in the TOML file.\n \n [crates-custom]: http://doc.crates.io/manifest.html#configuring-a-target\n "}, {"sha": "46af311acf31547332961f38c2a980bbf260ee06", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -156,6 +156,46 @@ that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n But, unlike a move, we can still use `v` afterward. This is because an `i32`\n has no pointers to data somewhere else, copying it is a full copy.\n \n+All primitive types implement the `Copy` trait and their ownership is\n+therefore not moved like one would assume, following the \u00b4ownership rules\u00b4.\n+To give an example, the two following snippets of code only compile because the \n+`i32` and `bool` types implement the `Copy` trait. \n+\n+```rust\n+fn main() {\n+    let a = 5;\n+\n+    let _y = double(a);\n+    println!(\"{}\", a);\n+}\n+\n+fn double(x: i32) -> i32 {\n+    x * 2\n+}\n+```\n+\n+```rust\n+fn main() {\n+    let a = true;\n+\n+    let _y = change_truth(a);\n+    println!(\"{}\", a);\n+}\n+\n+fn change_truth(x: bool) -> bool {\n+    !x\n+}\n+```\n+\n+If we would have used types that do not implement the `Copy` trait,\n+we would have gotten a compile error because we tried to use a moved value.\n+\n+```text\n+error: use of moved value: `a`\n+println!(\"{}\", a);\n+               ^\n+```\n+\n We will discuss how to make your own types `Copy` in the [traits][traits]\n section.\n "}, {"sha": "3da29c9b817d2da9ce261b52d7329fb54b20aa46", "filename": "src/doc/trpl/trait-objects.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftrait-objects.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -261,7 +261,7 @@ static Foo_for_String_vtable: FooVtable = FooVtable {\n ```\n \n The `destructor` field in each vtable points to a function that will clean up\n-any resources of the vtable\u2019s type, for `u8` it is trivial, but for `String` it\n+any resources of the vtable\u2019s type: for `u8` it is trivial, but for `String` it\n will free the memory. This is necessary for owning trait objects like\n `Box<Foo>`, which need to clean-up both the `Box` allocation as well as the\n internal type when they go out of scope. The `size` and `align` fields store\n@@ -270,7 +270,7 @@ essentially unused at the moment since the information is embedded in the\n destructor, but will be used in the future, as trait objects are progressively\n made more flexible.\n \n-Suppose we\u2019ve got some values that implement `Foo`, then the explicit form of\n+Suppose we\u2019ve got some values that implement `Foo`. The explicit form of\n construction and use of `Foo` trait objects might look a bit like (ignoring the\n type mismatches: they\u2019re all just pointers anyway):\n "}, {"sha": "162a2db1ec7548216333d02e5907b6913e956175", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -45,7 +45,7 @@ but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n we use `impl Trait for Item`, rather than just `impl Item`.\n \n We can use traits to constrain our generics. Consider this function, which\n-does not compile, and gives us a similar error:\n+does not compile:\n \n ```rust,ignore\n fn print_area<T>(shape: T) {\n@@ -56,7 +56,7 @@ fn print_area<T>(shape: T) {\n Rust complains:\n \n ```text\n-error: type `T` does not implement any method in scope named `area`\n+error: no method named `area` found for type `T` in the current scope\n ```\n \n Because `T` can be any type, we can\u2019t be sure that it implements the `area`\n@@ -212,10 +212,10 @@ This will compile without error.\n This means that even if someone does something bad like add methods to `i32`,\n it won\u2019t affect you, unless you `use` that trait.\n \n-There\u2019s one more restriction on implementing traits. Either the trait or the\n-type you\u2019re writing the `impl` for must be defined by you. So, we could\n+There\u2019s one more restriction on implementing traits: either the trait, or the\n+type you\u2019re writing the `impl` for, must be defined by you. So, we could\n implement the `HasArea` type for `i32`, because `HasArea` is in our code. But\n-if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n+if we tried to implement `ToString`, a trait provided by Rust, for `i32`, we could\n not, because neither the trait nor the type are in our code.\n \n One last thing about traits: generic functions with a trait bound use"}, {"sha": "789d4f8b9d31096c5f457decce6925afac512eb4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -1663,11 +1663,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_vec(element_ty, ref len) => {\n-                // [T, ..n] and [T]\n+                // [T; n] and [T]\n                 match bound {\n                     ty::BoundCopy => {\n                         match *len {\n-                            // [T, ..n] is copy iff T is copy\n+                            // [T; n] is copy iff T is copy\n                             Some(_) => ok_if(vec![element_ty]),\n \n                             // [T] is unsized and hence affine"}, {"sha": "624312dac38736c96d54b15997cff9a2d0186dee", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -234,8 +234,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n \n-    // &[T, ..n] or &mut [T, ..n] -> &[T]\n-    // or &mut [T, ..n] -> &mut [T]\n+    // &[T; n] or &mut [T; n] -> &[T]\n+    // or &mut [T; n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n                       source: Ty<'tcx>,"}, {"sha": "b5d317d602538f2cf83cfed10e18680e35c417c1", "filename": "src/librustc_typeck/check/method/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -18,7 +18,7 @@ into a more explicit UFCS form:\n Here `ADJ` is some kind of adjustment, which is typically a series of\n autoderefs and then possibly an autoref (e.g., `&**receiver`). However\n we sometimes do other adjustments and coercions along the way, in\n-particular unsizing (e.g., converting from `[T, ..n]` to `[T]`).\n+particular unsizing (e.g., converting from `[T; n]` to `[T]`).\n \n ## The Two Phases\n "}, {"sha": "6f97239ae939eb188b69328d5ddd05e91c87f990", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35ea4d35837c5cffbf4fe81c00e94092c35d5fe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a35ea4d35837c5cffbf4fe81c00e94092c35d5fe", "patch": "@@ -2085,7 +2085,7 @@ fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         return final_mt;\n     }\n \n-    // After we have fully autoderef'd, if the resulting type is [T, ..n], then\n+    // After we have fully autoderef'd, if the resulting type is [T; n], then\n     // do a final unsized coercion to yield [T].\n     if let ty::ty_vec(element_ty, Some(_)) = ty.sty {\n         let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);"}]}