{"sha": "b335b10b2296c4dad734419f6c2ae106ed4911cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMzViMTBiMjI5NmM0ZGFkNzM0NDE5ZjZjMmFlMTA2ZWQ0OTExY2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-25T18:48:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-25T21:49:51Z"}, "message": "Rollup merge of #47701 - Manishearth:intra-fixes, r=QuietMisdreavus\n\nFixes for intra-doc-links\n\nTurn errors into warnings, also handle methods, trait items, and variants.\n\nr? @killercup @QuietMisdreavus", "tree": {"sha": "6173ff6c671541a59ae873a318ccba6bf880409d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6173ff6c671541a59ae873a318ccba6bf880409d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b335b10b2296c4dad734419f6c2ae106ed4911cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b335b10b2296c4dad734419f6c2ae106ed4911cc", "html_url": "https://github.com/rust-lang/rust/commit/b335b10b2296c4dad734419f6c2ae106ed4911cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b335b10b2296c4dad734419f6c2ae106ed4911cc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "024e3aaff7decb734c6697c56d15993e99ac848a", "url": "https://api.github.com/repos/rust-lang/rust/commits/024e3aaff7decb734c6697c56d15993e99ac848a", "html_url": "https://github.com/rust-lang/rust/commit/024e3aaff7decb734c6697c56d15993e99ac848a"}, {"sha": "08ca4fd1358e172de351df475ea55b4e52605a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ca4fd1358e172de351df475ea55b4e52605a21", "html_url": "https://github.com/rust-lang/rust/commit/08ca4fd1358e172de351df475ea55b4e52605a21"}], "stats": {"total": 200, "additions": 158, "deletions": 42}, "files": [{"sha": "0929b833c1965395337753946980f8f4db38ec84", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 138, "deletions": 41, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/b335b10b2296c4dad734419f6c2ae106ed4911cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b335b10b2296c4dad734419f6c2ae106ed4911cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b335b10b2296c4dad734419f6c2ae106ed4911cc", "patch": "@@ -659,7 +659,8 @@ pub struct Attributes {\n     pub other_attrs: Vec<ast::Attribute>,\n     pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n-    pub links: Vec<(String, DefId)>,\n+    /// map from Rust paths to resolved defs and potential URL fragments\n+    pub links: Vec<(String, DefId, Option<String>)>,\n }\n \n impl Attributes {\n@@ -820,8 +821,12 @@ impl Attributes {\n     /// Cache must be populated before call\n     pub fn links(&self) -> Vec<(String, String)> {\n         use html::format::href;\n-        self.links.iter().filter_map(|&(ref s, did)| {\n-            if let Some((href, ..)) = href(did) {\n+        self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n+            if let Some((mut href, ..)) = href(did) {\n+                if let Some(ref fragment) = *fragment {\n+                    href.push_str(\"#\");\n+                    href.push_str(fragment);\n+                }\n                 Some((s.clone(), href))\n             } else {\n                 None\n@@ -843,10 +848,8 @@ impl AttributesExt for Attributes {\n /// they exist in both namespaces (structs and modules)\n fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n     match def {\n-        // structs and mods exist in both namespaces. skip them\n-        Def::StructCtor(..) | Def::Mod(..) => None,\n-        Def::Variant(..) | Def::VariantCtor(..)\n-            => Some((\"variant\", format!(\"{}()\", path_str))),\n+        // structs, variants, and mods exist in both namespaces. skip them\n+        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) | Def::VariantCtor(..) => None,\n         Def::Fn(..)\n             => Some((\"function\", format!(\"{}()\", path_str))),\n         Def::Method(..)\n@@ -880,10 +883,10 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n     let sp = attrs.doc_strings.first()\n                   .map_or(DUMMY_SP, |a| a.span());\n     cx.sess()\n-      .struct_span_err(sp,\n-                       &format!(\"`{}` is both {} {} and {} {}\",\n-                                path_str, article1, kind1,\n-                                article2, kind2))\n+      .struct_span_warn(sp,\n+                        &format!(\"`{}` is both {} {} and {} {}\",\n+                                 path_str, article1, kind1,\n+                                 article2, kind2))\n       .help(&format!(\"try `{}` if you want to select the {}, \\\n                       or `{}` if you want to \\\n                       select the {}\",\n@@ -892,21 +895,114 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n              .emit();\n }\n \n+/// Given an enum variant's def, return the def of its enum and the associated fragment\n+fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n+    use rustc::ty::DefIdTree;\n+\n+    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n+        parent\n+    } else {\n+        return Err(())\n+    };\n+    let parent_def = Def::Enum(parent);\n+    let variant = cx.tcx.expect_variant_def(def);\n+    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n+}\n+\n /// Resolve a given string as a path, along with whether or not it is\n-/// in the value namespace\n-fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<hir::Path, ()> {\n+/// in the value namespace. Also returns an optional URL fragment in the case\n+/// of variants and methods\n+fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option<String>), ()> {\n     // In case we're in a module, try to resolve the relative\n     // path\n     if let Some(id) = cx.mod_ids.borrow().last() {\n-        cx.resolver.borrow_mut()\n-                   .with_scope(*id, |resolver| {\n-                        resolver.resolve_str_path_error(DUMMY_SP,\n-                                                        &path_str, is_val)\n-                    })\n+        let result = cx.resolver.borrow_mut()\n+                                .with_scope(*id,\n+            |resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP,\n+                                                &path_str, is_val)\n+        });\n+\n+        if let Ok(result) = result {\n+            // In case this is a trait item, skip the\n+            // early return and try looking for the trait\n+            let value = match result.def {\n+                Def::Method(_) | Def::AssociatedConst(_) => true,\n+                Def::AssociatedTy(_)  => false,\n+                Def::Variant(_) => return handle_variant(cx, result.def),\n+                // not a trait item, just return what we found\n+                _ => return Ok((result.def, None))\n+            };\n+\n+            if value != is_val {\n+                return Err(())\n+            }\n+        } else {\n+            // If resolution failed, it may still be a method\n+            // because methods are not handled by the resolver\n+            // If so, bail when we're not looking for a value\n+            if !is_val {\n+                return Err(())\n+            }\n+        }\n+\n+        // Try looking for methods and associated items\n+        let mut split = path_str.rsplitn(2, \"::\");\n+        let mut item_name = if let Some(first) = split.next() {\n+            first\n+        } else {\n+            return Err(())\n+        };\n+\n+        let mut path = if let Some(second) = split.next() {\n+            second\n+        } else {\n+            return Err(())\n+        };\n+\n+        let ty = cx.resolver.borrow_mut()\n+                            .with_scope(*id,\n+            |resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP,\n+                                                &path, false)\n+        })?;\n+        match ty.def {\n+            Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+                let item = cx.tcx.inherent_impls(did).iter()\n+                                 .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                                 .find(|item| item.name == item_name);\n+                if let Some(item) = item {\n+                    if item.kind == ty::AssociatedKind::Method && is_val {\n+                        Ok((ty.def, Some(format!(\"method.{}\", item_name))))\n+                    } else {\n+                        Err(())\n+                    }\n+                } else {\n+                    Err(())\n+                }\n+            }\n+            Def::Trait(did) => {\n+                let item = cx.tcx.associated_item_def_ids(did).iter()\n+                             .map(|item| cx.tcx.associated_item(*item))\n+                             .find(|item| item.name == item_name);\n+                if let Some(item) = item {\n+                    let kind = match item.kind {\n+                        ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                        ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n+                        ty::AssociatedKind::Method if is_val => \"tymethod\",\n+                        _ => return Err(())\n+                    };\n+\n+                    Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n+                } else {\n+                    Err(())\n+                }\n+            }\n+            _ => Err(())\n+        }\n+\n     } else {\n-        // FIXME(Manishearth) this branch doesn't seem to ever be hit, really\n-        cx.resolver.borrow_mut()\n-                   .resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n+        Err(())\n     }\n }\n \n@@ -955,7 +1051,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n         if UnstableFeatures::from_environment().is_nightly_build() {\n             let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n             for link in markdown_links(&dox, cx.render_type) {\n-                let def = {\n+                let (def, fragment)  = {\n                     let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) =\n                         [\"struct@\", \"enum@\", \"type@\",\n@@ -965,7 +1061,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         link.trim_left_matches(prefix)\n                     } else if let Some(prefix) =\n                         [\"const@\", \"static@\",\n-                         \"value@\", \"function@\", \"mod@\", \"fn@\", \"module@\"]\n+                         \"value@\", \"function@\", \"mod@\",\n+                         \"fn@\", \"module@\", \"method@\"]\n                             .iter().find(|p| link.starts_with(**p)) {\n                         kind = PathKind::Value;\n                         link.trim_left_matches(prefix)\n@@ -993,8 +1090,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n                     match kind {\n                         PathKind::Value => {\n-                            if let Ok(path) = resolve(cx, path_str, true) {\n-                                path.def\n+                            if let Ok(def) = resolve(cx, path_str, true) {\n+                                def\n                             } else {\n                                 // this could just be a normal link or a broken link\n                                 // we could potentially check if something is\n@@ -1003,8 +1100,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             }\n                         }\n                         PathKind::Type => {\n-                            if let Ok(path) = resolve(cx, path_str, false) {\n-                                path.def\n+                            if let Ok(def) = resolve(cx, path_str, false) {\n+                                def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;\n@@ -1013,50 +1110,50 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         PathKind::Unknown => {\n                             // try everything!\n                             if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                                if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                if let Ok(type_def) = resolve(cx, path_str, false) {\n                                     let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_path.def, path_str);\n+                                        = type_ns_kind(type_def.0, path_str);\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     article, type_kind, &type_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                     continue;\n-                                } else if let Ok(value_path) = resolve(cx, path_str, true) {\n+                                } else if let Ok(value_def) = resolve(cx, path_str, true) {\n                                     let (value_kind, value_disambig)\n-                                        = value_ns_kind(value_path.def, path_str)\n+                                        = value_ns_kind(value_def.0, path_str)\n                                             .expect(\"struct and mod cases should have been \\\n                                                      caught in previous branch\");\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     \"a\", value_kind, &value_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 }\n-                                macro_def\n-                            } else if let Ok(type_path) = resolve(cx, path_str, false) {\n+                                (macro_def, None)\n+                            } else if let Ok(type_def) = resolve(cx, path_str, false) {\n                                 // It is imperative we search for not-a-value first\n                                 // Otherwise we will find struct ctors for when we are looking\n                                 // for structs, and the link won't work.\n                                 // if there is something in both namespaces\n-                                if let Ok(value_path) = resolve(cx, path_str, true) {\n-                                    let kind = value_ns_kind(value_path.def, path_str);\n+                                if let Ok(value_def) = resolve(cx, path_str, true) {\n+                                    let kind = value_ns_kind(value_def.0, path_str);\n                                     if let Some((value_kind, value_disambig)) = kind {\n                                         let (type_kind, article, type_disambig)\n-                                            = type_ns_kind(type_path.def, path_str);\n+                                            = type_ns_kind(type_def.0, path_str);\n                                         ambiguity_error(cx, &attrs, path_str,\n                                                         article, type_kind, &type_disambig,\n                                                         \"a\", value_kind, &value_disambig);\n                                         continue;\n                                     }\n                                 }\n-                                type_path.def\n-                            } else if let Ok(value_path) = resolve(cx, path_str, true) {\n-                                value_path.def\n+                                type_def\n+                            } else if let Ok(value_def) = resolve(cx, path_str, true) {\n+                                value_def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;\n                             }\n                         }\n                         PathKind::Macro => {\n                             if let Some(def) = macro_resolve(cx, path_str) {\n-                                def\n+                                (def, None)\n                             } else {\n                                 continue\n                             }\n@@ -1066,7 +1163,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n \n                 let id = register_def(cx, def);\n-                attrs.links.push((link, id));\n+                attrs.links.push((link, id, fragment));\n             }\n \n             cx.sess().abort_if_errors();"}, {"sha": "4726323e11cef839a2170d109a94a4b85f58224d", "filename": "src/test/rustdoc/intra-links.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b335b10b2296c4dad734419f6c2ae106ed4911cc/src%2Ftest%2Frustdoc%2Fintra-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b335b10b2296c4dad734419f6c2ae106ed4911cc/src%2Ftest%2Frustdoc%2Fintra-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-links.rs?ref=b335b10b2296c4dad734419f6c2ae106ed4911cc", "patch": "@@ -10,7 +10,13 @@\n \n // @has intra_links/index.html\n // @has - '//a/@href' '../intra_links/struct.ThisType.html'\n+// @has - '//a/@href' '../intra_links/struct.ThisType.html#method.this_method'\n // @has - '//a/@href' '../intra_links/enum.ThisEnum.html'\n+// @has - '//a/@href' '../intra_links/enum.ThisEnum.html#ThisVariant.v'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html#tymethod.this_associated_method'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html#associatedtype.ThisAssociatedType'\n+// @has - '//a/@href' '../intra_links/trait.ThisTrait.html#associatedconstant.THIS_ASSOCIATED_CONST'\n // @has - '//a/@href' '../intra_links/trait.ThisTrait.html'\n // @has - '//a/@href' '../intra_links/type.ThisAlias.html'\n // @has - '//a/@href' '../intra_links/union.ThisUnion.html'\n@@ -23,8 +29,13 @@\n //! In this crate we would like to link to:\n //!\n //! * [`ThisType`](ThisType)\n+//! * [`ThisType::this_method`](ThisType::this_method)\n //! * [`ThisEnum`](ThisEnum)\n+//! * [`ThisEnum::ThisVariant`](ThisEnum::ThisVariant)\n //! * [`ThisTrait`](ThisTrait)\n+//! * [`ThisTrait::this_associated_method`](ThisTrait::this_associated_method)\n+//! * [`ThisTrait::ThisAssociatedType`](ThisTrait::ThisAssociatedType)\n+//! * [`ThisTrait::THIS_ASSOCIATED_CONST`](ThisTrait::THIS_ASSOCIATED_CONST)\n //! * [`ThisAlias`](ThisAlias)\n //! * [`ThisUnion`](ThisUnion)\n //! * [`this_function`](this_function())\n@@ -45,8 +56,16 @@ macro_rules! this_macro {\n }\n \n pub struct ThisType;\n+\n+impl ThisType {\n+    pub fn this_method() {}\n+}\n pub enum ThisEnum { ThisVariant, }\n-pub trait ThisTrait {}\n+pub trait ThisTrait {\n+    type ThisAssociatedType;\n+    const THIS_ASSOCIATED_CONST: u8;\n+    fn this_associated_method();\n+}\n pub type ThisAlias = Result<(), ()>;\n pub union ThisUnion { this_field: usize, }\n "}]}