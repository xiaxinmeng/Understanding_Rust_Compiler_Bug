{"sha": "d54195db22421c51fd14560aba3bbf9b79a52677", "node_id": "C_kwDOAAsO6NoAKGQ1NDE5NWRiMjI0MjFjNTFmZDE0NTYwYWJhM2JiZjliNzlhNTI2Nzc", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-11T07:18:06Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-11T07:18:06Z"}, "message": "Revert \"Auto merge of #92007 - oli-obk:lazy_tait2, r=nikomatsakis\"\n\nThis reverts commit e7cc3bddbe0d0e374d05e7003e662bba1742dbae, reversing\nchanges made to 734368a200904ef9c21db86c595dc04263c87be0.", "tree": {"sha": "dbca79885fa7302801114ff50a777d192628d68b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbca79885fa7302801114ff50a777d192628d68b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54195db22421c51fd14560aba3bbf9b79a52677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54195db22421c51fd14560aba3bbf9b79a52677", "html_url": "https://github.com/rust-lang/rust/commit/d54195db22421c51fd14560aba3bbf9b79a52677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54195db22421c51fd14560aba3bbf9b79a52677/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d8b8f359312210e34b251906179484ffc7287c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8b8f359312210e34b251906179484ffc7287c6", "html_url": "https://github.com/rust-lang/rust/commit/2d8b8f359312210e34b251906179484ffc7287c6"}], "stats": {"total": 5747, "additions": 2442, "deletions": 3305}, "files": [{"sha": "5597a8b091554769adc7dd0f07be095b02ea8739", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -124,9 +124,8 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n-    let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(hir_owner).enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         do_mir_borrowck(&infcx, input_body, promoted, false).0\n@@ -141,7 +140,7 @@ fn mir_borrowck<'tcx>(\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n-#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n+#[instrument(skip(infcx, input_body, input_promoted), level = \"debug\")]\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,"}, {"sha": "76b3be7976c61e9b8def72466f0d6a39f95f8cfb", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,6 +1,7 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n@@ -53,44 +54,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (Ty<'tcx>, Span, OpaqueTyOrigin)>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n         span: Span,\n     ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .map(|(opaque_type_key, (concrete_type, decl_span, origin))| {\n+            .filter_map(|(opaque_type_key, decl)| {\n                 let substs = opaque_type_key.substs;\n-                // FIXME: why are the spans in decl_span often DUMMY_SP?\n-                let span = decl_span.substitute_dummy(span);\n+                let concrete_type = decl.concrete_ty;\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n                 let universal_substs = infcx.tcx.fold_regions(substs, &mut false, |region, _| {\n-                    if let ty::RePlaceholder(..) = region {\n-                        // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n-                        return region;\n-                    }\n-                    let vid = self.to_region_vid(region);\n-                    trace!(?vid);\n-                    let scc = self.constraint_sccs.scc(vid);\n-                    trace!(?scc);\n-                    match self.scc_values.universal_regions_outlived_by(scc).find_map(|lb| {\n-                        self.eval_equal(vid, lb).then_some(self.definitions[lb].external_name?)\n-                    }) {\n-                        Some(region) => {\n-                            let vid = self.universal_regions.to_region_vid(region);\n-                            subst_regions.push(vid);\n-                            region\n-                        }\n-                        None => {\n-                            subst_regions.push(vid);\n-                            infcx.tcx.sess.delay_span_bug(\n-                                span,\n-                                \"opaque type with non-universal region substs\",\n-                            );\n-                            infcx.tcx.lifetimes.re_static\n-                        }\n-                    }\n+                    let vid = self.universal_regions.to_region_vid(region);\n+                    subst_regions.push(vid);\n+                    self.definitions[vid].external_name.unwrap_or_else(|| {\n+                        infcx\n+                            .tcx\n+                            .sess\n+                            .delay_span_bug(span, \"opaque type with non-universal region substs\");\n+                        infcx.tcx.lifetimes.re_static\n+                    })\n                 });\n \n                 subst_regions.sort();\n@@ -116,14 +100,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span,\n                 );\n \n-                (\n+                check_opaque_type_parameter_valid(\n+                    infcx.tcx,\n                     opaque_type_key,\n-                    if check_opaque_type_parameter_valid(infcx.tcx, opaque_type_key, origin, span) {\n-                        remapped_type\n-                    } else {\n-                        infcx.tcx.ty_error()\n-                    },\n+                    OpaqueTypeDecl { concrete_ty: remapped_type, ..decl },\n                 )\n+                .then_some((opaque_type_key, remapped_type))\n             })\n             .collect()\n     }\n@@ -167,10 +149,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n fn check_opaque_type_parameter_valid(\n     tcx: TyCtxt<'_>,\n     opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n-    span: Span,\n+    decl: OpaqueTypeDecl<'_>,\n ) -> bool {\n-    match origin {\n+    match decl.origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n         // by construction: we convert\n@@ -196,6 +177,7 @@ fn check_opaque_type_parameter_valid(\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n+    let span = decl.definition_span;\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n     let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {"}, {"sha": "bc740de5150659cc48f1954c0a17b8036fec98a9", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -147,9 +147,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Return types are a bit more complex. They may contain opaque `impl Trait` types.\n         let mir_output_ty = body.local_decls[RETURN_PLACE].ty;\n         let output_span = body.local_decls[RETURN_PLACE].source_info.span;\n-        if let Err(terr) = self.eq_types(\n-            normalized_output_ty,\n+        if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n+            normalized_output_ty,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -169,9 +169,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let user_provided_output_ty = user_provided_sig.output();\n             let user_provided_output_ty =\n                 self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_types(\n-                user_provided_output_ty,\n+            if let Err(err) = self.eq_opaque_type_and_type(\n                 mir_output_ty,\n+                user_provided_output_ty,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "73103643e3e16f2253edb83e036f440c25aa8930", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 201, "deletions": 48, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,7 +5,6 @@ use std::{fmt, iter, mem};\n \n use either::Either;\n \n-use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::vec_map::VecMap;\n@@ -16,6 +15,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n@@ -41,7 +41,7 @@ use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::Fallible;\n-use rustc_trait_selection::traits::{self, ObligationCause};\n+use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n \n use rustc_const_eval::transform::{\n     check_consts::ConstCx, promote_consts::is_const_fn_in_array_repeat_expression,\n@@ -75,7 +75,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.body().source.def_id(),\n+                $context.body.source.def_id(),\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -190,44 +190,59 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n-            let opaque_type_values =\n-                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+            let opaque_type_values = mem::take(&mut infcx.inner.borrow_mut().opaque_types);\n \n             opaque_type_values\n                 .into_iter()\n-                .map(|(opaque_type_key, decl)| {\n-                    cx.fully_perform_op(\n-                        Locations::All(body.span),\n-                        ConstraintCategory::OpaqueType,\n-                        CustomTypeOp::new(\n-                            |infcx| {\n-                                infcx.register_member_constraints(\n-                                    param_env,\n-                                    opaque_type_key,\n-                                    decl.hidden_type.ty,\n-                                    decl.hidden_type.span,\n-                                );\n-                                Ok(InferOk { value: (), obligations: vec![] })\n-                            },\n-                            || \"opaque_type_map\".to_string(),\n-                        ),\n-                    )\n-                    .unwrap();\n-                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type.ty);\n+                .filter_map(|(opaque_type_key, mut decl)| {\n+                    decl.concrete_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n                     trace!(\n                         \"finalized opaque type {:?} to {:#?}\",\n                         opaque_type_key,\n-                        hidden_type.kind()\n+                        decl.concrete_ty.kind()\n                     );\n-                    if hidden_type.has_infer_types_or_consts() {\n+                    if decl.concrete_ty.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n-                            decl.hidden_type.span,\n-                            &format!(\"could not resolve {:#?}\", hidden_type.kind()),\n+                            body.span,\n+                            &format!(\"could not resolve {:#?}\", decl.concrete_ty.kind()),\n                         );\n-                        hidden_type = infcx.tcx.ty_error();\n+                        decl.concrete_ty = infcx.tcx.ty_error();\n                     }\n+                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = decl.concrete_ty.kind()\n+                    {\n+                        *def_id == opaque_type_key.def_id\n+                    } else {\n+                        false\n+                    };\n \n-                    (opaque_type_key, (hidden_type, decl.hidden_type.span, decl.origin))\n+                    if concrete_is_opaque {\n+                        // We're using an opaque `impl Trait` type without\n+                        // 'revealing' it. For example, code like this:\n+                        //\n+                        // type Foo = impl Debug;\n+                        // fn foo1() -> Foo { ... }\n+                        // fn foo2() -> Foo { foo1() }\n+                        //\n+                        // In `foo2`, we're not revealing the type of `Foo` - we're\n+                        // just treating it as the opaque type.\n+                        //\n+                        // When this occurs, we do *not* want to try to equate\n+                        // the concrete type with the underlying defining type\n+                        // of the opaque type - this will always fail, since\n+                        // the defining type of an opaque type is always\n+                        // some other type (e.g. not itself)\n+                        // Essentially, none of the normal obligations apply here -\n+                        // we're just passing around some unknown opaque type,\n+                        // without actually looking at the underlying type it\n+                        // gets 'revealed' into\n+                        debug!(\n+                            \"eq_opaque_type_and_type: non-defining use of {:?}\",\n+                            opaque_type_key.def_id,\n+                        );\n+                        None\n+                    } else {\n+                        Some((opaque_type_key, decl))\n+                    }\n                 })\n                 .collect()\n         },\n@@ -259,7 +274,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         borrowck_context,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n         verifier.visit_body(&body);\n         verifier.errors_reported\n     };\n@@ -316,6 +331,7 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n+    body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n     errors_reported: bool,\n@@ -451,7 +467,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        let rval_ty = rvalue.ty(self.body(), self.tcx());\n+        let rval_ty = rvalue.ty(self.body, self.tcx());\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n@@ -510,13 +526,10 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n+        body: &'b Body<'tcx>,\n         promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n-    }\n-\n-    fn body(&self) -> &Body<'tcx> {\n-        self.cx.body\n+        TypeVerifier { body, promoted, cx, last_span: body.span, errors_reported: false }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -541,7 +554,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        let mut place_ty = PlaceTy::from_ty(self.body().local_decls[place.local].ty);\n+        let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n@@ -586,7 +599,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.cx.body, promoted_body);\n+        let parent_body = mem::replace(&mut self.body, promoted_body);\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n@@ -622,7 +635,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             self.cx.typeck_mir(promoted_body);\n         }\n \n-        self.cx.body = parent_body;\n+        self.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n         swap_constraints(self);\n \n@@ -684,7 +697,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }))\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::from(i).ty(self.body(), tcx).ty;\n+                let index_ty = Place::from(i).ty(self.body, tcx).ty;\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::from_ty(span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i))\n                 } else {\n@@ -893,7 +906,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, (Ty<'tcx>, Span, OpaqueTyOrigin)>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -1043,19 +1056,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n-    fn body(&self) -> &Body<'tcx> {\n-        self.body\n-    }\n-\n     fn unsized_feature_enabled(&self) -> bool {\n         let features = self.tcx().features();\n         features.unsized_locals || features.unsized_fn_params\n     }\n \n     /// Equate the inferred type and the annotated type for user type annotations\n-    #[instrument(skip(self), level = \"debug\")]\n     fn check_user_type_annotations(&mut self) {\n-        debug!(?self.user_type_annotations);\n+        debug!(\n+            \"check_user_type_annotations: user_type_annotations={:?}\",\n+            self.user_type_annotations\n+        );\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n@@ -1196,6 +1207,131 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         Ok(())\n     }\n \n+    /// Equates a type `anon_ty` that may contain opaque types whose\n+    /// values are to be inferred by the MIR.\n+    ///\n+    /// The type `revealed_ty` contains the same type as `anon_ty`, but with the\n+    /// hidden types for impl traits revealed.\n+    ///\n+    /// # Example\n+    ///\n+    /// Consider a piece of code like\n+    ///\n+    /// ```rust\n+    /// type Foo<U> = impl Debug;\n+    ///\n+    /// fn foo<T: Debug>(t: T) -> Box<Foo<T>> {\n+    ///      Box::new((t, 22_u32))\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, the function signature would be something like\n+    /// `fn(T) -> Box<impl Debug>`. The MIR return slot would have\n+    /// the type with the opaque type revealed, so `Box<(T, u32)>`.\n+    ///\n+    /// In terms of our function parameters:\n+    ///\n+    /// * `anon_ty` would be `Box<Foo<T>>` where `Foo<T>` is an opaque type\n+    ///   scoped to this function (note that it is parameterized by the\n+    ///   generics of `foo`). Note that `anon_ty` is not just the opaque type,\n+    ///   but the entire return type (which may contain opaque types within it).\n+    /// * `revealed_ty` would be `Box<(T, u32)>`\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn eq_opaque_type_and_type(\n+        &mut self,\n+        revealed_ty: Ty<'tcx>,\n+        anon_ty: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        // Fast path for the common case.\n+        if !anon_ty.has_opaque_types() {\n+            if let Err(terr) = self.eq_types(anon_ty, revealed_ty, locations, category) {\n+                span_mirbug!(\n+                    self,\n+                    locations,\n+                    \"eq_opaque_type_and_type: `{:?}=={:?}` failed with `{:?}`\",\n+                    revealed_ty,\n+                    anon_ty,\n+                    terr\n+                );\n+            }\n+            return Ok(());\n+        }\n+\n+        let param_env = self.param_env;\n+        let body = self.body;\n+        let mir_def_id = body.source.def_id().expect_local();\n+\n+        debug!(?mir_def_id);\n+        self.fully_perform_op(\n+            locations,\n+            category,\n+            CustomTypeOp::new(\n+                |infcx| {\n+                    let mut obligations = ObligationAccumulator::default();\n+\n+                    let dummy_body_id = hir::CRATE_HIR_ID;\n+\n+                    // Replace the opaque types defined by this function with\n+                    // inference variables, creating a map. In our example above,\n+                    // this would transform the type `Box<Foo<T>>` (where `Foo` is an opaque type)\n+                    // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n+                    // (Note that the key of the map is both the def-id of `Foo` along with\n+                    // any generic parameters.)\n+                    let output_ty = obligations.add(infcx.instantiate_opaque_types(\n+                        dummy_body_id,\n+                        param_env,\n+                        anon_ty,\n+                        locations.span(body),\n+                    ));\n+                    debug!(?output_ty, ?revealed_ty);\n+\n+                    // Make sure that the inferred types are well-formed. I'm\n+                    // not entirely sure this is needed (the HIR type check\n+                    // didn't do this) but it seems sensible to prevent opaque\n+                    // types hiding ill-formed types.\n+                    obligations.obligations.push(traits::Obligation::new(\n+                        ObligationCause::dummy(),\n+                        param_env,\n+                        ty::Binder::dummy(ty::PredicateKind::WellFormed(revealed_ty.into()))\n+                            .to_predicate(infcx.tcx),\n+                    ));\n+                    obligations.add(\n+                        infcx\n+                            .at(&ObligationCause::dummy(), param_env)\n+                            .eq(output_ty, revealed_ty)?,\n+                    );\n+\n+                    debug!(\"equated\");\n+\n+                    Ok(InferOk { value: (), obligations: obligations.into_vec() })\n+                },\n+                || \"input_output\".to_string(),\n+            ),\n+        )?;\n+\n+        // Finally, if we instantiated the anon types successfully, we\n+        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n+        // prove that `T: Iterator` where `T` is the type we\n+        // instantiated it with).\n+        let opaque_type_map = self.infcx.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_decl) in opaque_type_map {\n+            self.fully_perform_op(\n+                locations,\n+                ConstraintCategory::OpaqueType,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        infcx.constrain_opaque_type(opaque_type_key, &opaque_decl);\n+                        Ok(InferOk { value: (), obligations: vec![] })\n+                    },\n+                    || \"opaque_type_map\".to_string(),\n+                ),\n+            )?;\n+        }\n+        Ok(())\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -2637,3 +2773,20 @@ impl NormalizeLocation for Location {\n         Locations::Single(self)\n     }\n }\n+\n+#[derive(Debug, Default)]\n+struct ObligationAccumulator<'tcx> {\n+    obligations: PredicateObligations<'tcx>,\n+}\n+\n+impl<'tcx> ObligationAccumulator<'tcx> {\n+    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = value;\n+        self.obligations.extend(obligations);\n+        value\n+    }\n+\n+    fn into_vec(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}"}, {"sha": "cc3fe0a123c55bc79803e994cddc189e71f13c85", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,15 +1,13 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc_infer::infer::{InferOk, NllRegionVariableOrigin};\n-use rustc_infer::traits::ObligationCause;\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Const, Ty};\n-use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n-use crate::type_check::{CustomTypeOp, Locations, TypeChecker};\n+use crate::type_check::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -65,10 +63,6 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n }\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n-    fn span(&self) -> Span {\n-        self.locations.span(self.type_checker.body)\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.type_checker.param_env\n     }\n@@ -123,9 +117,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n     // We don't have to worry about the equality of consts during borrow checking\n     // as consts always have a static lifetime.\n-    // FIXME(oli-obk): is this really true? We can at least have HKL and with\n-    // inline consts we may have further lifetimes that may be unsound to treat as\n-    // 'static.\n     fn const_equate(&mut self, _a: &'tcx Const<'tcx>, _b: &'tcx Const<'tcx>) {}\n \n     fn normalization() -> NormalizationStrategy {\n@@ -135,33 +126,4 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n-\n-    fn register_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool) {\n-        let param_env = self.param_env();\n-        let span = self.span();\n-        let def_id = self.type_checker.body.source.def_id().expect_local();\n-        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n-        let cause = ObligationCause::misc(span, body_id);\n-        self.type_checker\n-            .fully_perform_op(\n-                self.locations,\n-                self.category,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        Ok(InferOk {\n-                            value: (),\n-                            obligations: vec![infcx.opaque_ty_obligation(\n-                                a,\n-                                b,\n-                                a_is_expected,\n-                                param_env,\n-                                cause,\n-                            )],\n-                        })\n-                    },\n-                    || \"register_opaque_type\".to_string(),\n-                ),\n-            )\n-            .unwrap();\n-    }\n }"}, {"sha": "16a903d5e593f75dd306d4859ee929aec251d94e", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -728,7 +728,6 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         self.tcx.fold_regions(value, &mut false, |_region, _depth| self.next_nll_region_var(origin))\n     }\n \n-    #[instrument(level = \"debug\", skip(self, indices))]\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -739,15 +738,22 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        debug!(\n+            \"replace_bound_regions_with_nll_infer_vars(value={:?}, all_outlive_scope={:?})\",\n+            value, all_outlive_scope,\n+        );\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n-            debug!(?br);\n+            debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope.to_def_id(),\n                 bound_region: br.kind,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n-            debug!(?liberated_region, ?region_vid);\n+            debug!(\n+                \"replace_bound_regions_with_nll_infer_vars: liberated_region={:?} => {:?}\",\n+                liberated_region, region_vid\n+            );\n             region_vid\n         });\n         value\n@@ -762,7 +768,6 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n-    #[instrument(skip(self, indices))]\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n         mir_def_id: LocalDefId,\n@@ -774,7 +779,6 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n-                debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });"}, {"sha": "6799514a4490db098206e2958dff72304158fb10", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n-use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeFoldable};\n+use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::SelectionContext;\n@@ -46,10 +46,7 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        // Peeking into opaque types causes cycles if the current function declares said opaque\n-        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n-        // analysis that looks at the actual usage within this function\n-        if !ty.has_opaque_types() && !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n+        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -103,10 +100,7 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        // Peeking into opaque types causes cycles if the current function declares said opaque\n-        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n-        // analysis that looks at the actual usage within this function\n-        if !ty.has_opaque_types() && !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n+        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -154,12 +148,7 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n \n             // If we know that all values of the return type are structurally matchable, there's no\n             // need to run dataflow.\n-            // Opaque types do not participate in const generics or pattern matching, so we can safely count them out.\n-            _ if ccx.body.return_ty().has_opaque_types()\n-                || !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n-            {\n-                false\n-            }\n+            _ if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) => false,\n \n             hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n@@ -406,7 +395,6 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n                     | ty::PredicateKind::Projection(_)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                     ty::PredicateKind::ObjectSafe(_) => {\n                         bug!(\"object safe predicate on function: {:#?}\", predicate)"}, {"sha": "cf15fc4ddc3a54fa3fe60f13453274462fbb6831", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -79,6 +79,7 @@ pub fn equal_up_to_regions<'tcx>(\n     }\n \n     // Normalize lifetimes away on both sides, then compare.\n+    let param_env = param_env.with_reveal_all_normalized(tcx);\n     let normalize = |ty: Ty<'tcx>| {\n         tcx.normalize_erasing_regions(\n             param_env,\n@@ -170,7 +171,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n         // Normalize projections and things like that.\n-        let param_env = self.param_env;\n+        // FIXME: We need to reveal_all, as some optimizations change types in ways\n+        // that require unfolding opaque types.\n+        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n         let src = self.tcx.normalize_erasing_regions(param_env, src);\n         let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n "}, {"sha": "cc7ec9432faed31803376bbc5113cebd642229ca", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -30,11 +30,6 @@ where\n         }\n     }\n \n-    /// Removes the entry from the map and returns the removed value\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n-        self.0.iter().position(|(k2, _)| k2 == k).map(|pos| self.0.remove(pos).1)\n-    }\n-\n     /// Gets a reference to the value in the entry.\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n     where\n@@ -44,15 +39,6 @@ where\n         self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n     }\n \n-    /// Gets a mutable reference to the value in the entry.\n-    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.0.iter_mut().find(|(key, _)| k == key.borrow()).map(|elem| &mut elem.1)\n-    }\n-\n     /// Returns the any value corresponding to the supplied predicate filter.\n     ///\n     /// The supplied predicate will be applied to each (key, value) pair and it will return a\n@@ -72,7 +58,7 @@ where\n         // This should return just one element, otherwise it's a bug\n         assert!(\n             filter.next().is_none(),\n-            \"Collection {:#?} should have just one matching element\",\n+            \"Collection {:?} should have just one matching element\",\n             self\n         );\n         Some(value)"}, {"sha": "c26ea4c9669036ea7395b9051d5f861038af9fd5", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -34,12 +34,6 @@ pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -55,7 +49,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env, define_opaque_types: true }\n+        At { infcx: self, cause, param_env }\n     }\n }\n \n@@ -70,10 +64,6 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n-    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n-        Self { define_opaque_types, ..self }\n-    }\n-\n     /// Hacky routine for equating two impl headers in coherence.\n     pub fn eq_impl_headers(\n         self,\n@@ -204,7 +194,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -221,7 +211,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -236,7 +226,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -251,7 +241,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)"}, {"sha": "5b4a9d9dfad456e43b201933ffe15107eb2f73d9", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -26,7 +26,6 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n \n@@ -90,7 +89,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             var_values: inference_vars,\n             region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n-            opaque_types: vec![],\n             value: answer,\n         })\n     }\n@@ -135,27 +133,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n \n-        let opaque_types = self.take_opaque_types_for_query_response();\n-\n         Ok(QueryResponse {\n             var_values: inference_vars,\n             region_constraints,\n             certainty,\n             value: answer,\n-            opaque_types,\n         })\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n-        self.inner\n-            .borrow_mut()\n-            .opaque_type_storage\n-            .take_opaque_types()\n-            .into_iter()\n-            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id, k.substs), v.hidden_type.ty))\n-            .collect()\n-    }\n-\n     /// Given the (canonicalized) result to a canonical query,\n     /// instantiates the result so it can be used, plugging in the\n     /// values from the canonical query. (Note that the result may\n@@ -238,12 +223,13 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n-        let InferOk { value: result_subst, mut obligations } = self\n-            .query_response_substitution_guess(cause, param_env, original_values, query_response)?;\n+        let result_subst =\n+            self.query_response_substitution_guess(cause, original_values, query_response);\n \n         // Compute `QueryOutlivesConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n+        let mut obligations = vec![];\n \n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n@@ -358,25 +344,20 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             original_values, query_response,\n         );\n \n-        let mut value = self.query_response_substitution_guess(\n-            cause,\n-            param_env,\n-            original_values,\n-            query_response,\n-        )?;\n+        let result_subst =\n+            self.query_response_substitution_guess(cause, original_values, query_response);\n \n-        value.obligations.extend(\n-            self.unify_query_response_substitution_guess(\n+        let obligations = self\n+            .unify_query_response_substitution_guess(\n                 cause,\n                 param_env,\n                 original_values,\n-                &value.value,\n+                &result_subst,\n                 query_response,\n             )?\n-            .into_obligations(),\n-        );\n+            .into_obligations();\n \n-        Ok(value)\n+        Ok(InferOk { value: result_subst, obligations })\n     }\n \n     /// Given the original values and the (canonicalized) result from\n@@ -391,10 +372,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n         original_values: &OriginalQueryValues<'tcx>,\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n-    ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n+    ) -> CanonicalVarValues<'tcx>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n@@ -494,16 +474,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 .collect(),\n         };\n \n-        let mut obligations = vec![];\n-\n-        // Carry all newly resolved opaque types to the caller's scope\n-        for &(a, b) in &query_response.value.opaque_types {\n-            let a = substitute_value(self.tcx, &result_subst, a);\n-            let b = substitute_value(self.tcx, &result_subst, b);\n-            obligations.extend(self.handle_opaque_type(a, b, cause, param_env)?.obligations);\n-        }\n-\n-        Ok(InferOk { value: result_subst, obligations })\n+        result_subst\n     }\n \n     /// Given a \"guess\" at the values for the canonical variables in\n@@ -660,10 +631,6 @@ struct QueryTypeRelatingDelegate<'a, 'tcx> {\n }\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n-    fn span(&self) -> Span {\n-        self.cause.span\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -719,14 +686,4 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n-\n-    fn register_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool) {\n-        self.obligations.push(self.infcx.opaque_ty_obligation(\n-            a,\n-            b,\n-            a_is_expected,\n-            self.param_env,\n-            self.cause.clone(),\n-        ));\n-    }\n }"}, {"sha": "a77fd8fae8d20d059cbfc110d90bda00580111d9", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -51,12 +51,6 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -328,7 +322,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// will first instantiate `b_vid` with a *generalized* version\n     /// of `a_ty`. Generalization introduces other inference\n     /// variables wherever subtyping could occur.\n-    #[instrument(skip(self), level = \"debug\")]\n     pub fn instantiate(\n         &mut self,\n         a_ty: Ty<'tcx>,\n@@ -341,6 +334,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // Get the actual variable that b_vid has been inferred to\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n+        debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n+\n         // Generalize type of `a_ty` appropriately depending on the\n         // direction.  As an example, assume:\n         //\n@@ -353,7 +348,10 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n         let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n-        debug!(?b_ty);\n+        debug!(\n+            \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n+            a_ty, dir, b_vid, b_ty\n+        );\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n         if needs_wf {\n@@ -394,13 +392,13 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n-    #[instrument(skip(self), level = \"trace\")]\n     fn generalize(\n         &self,\n         ty: Ty<'tcx>,\n         for_vid: ty::TyVid,\n         dir: RelationDir,\n     ) -> RelateResult<'tcx, Generalization<'tcx>> {\n+        debug!(\"generalize(ty={:?}, for_vid={:?}, dir={:?}\", ty, for_vid, dir);\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -414,7 +412,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             RelationDir::SupertypeOf => ty::Contravariant,\n         };\n \n-        trace!(?ambient_variance);\n+        debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n \n         let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n@@ -423,8 +421,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             TypeVariableValue::Unknown { universe } => universe,\n         };\n \n-        trace!(?for_universe);\n-        trace!(?self.trace);\n+        debug!(\"generalize: for_universe = {:?}\", for_universe);\n+        debug!(\"generalize: trace = {:?}\", self.trace);\n \n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -441,12 +439,12 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n-                debug!(?e, \"failure\");\n+                debug!(\"generalize: failure {:?}\", e);\n                 return Err(e);\n             }\n         };\n         let needs_wf = generalize.needs_wf;\n-        trace!(?ty, ?needs_wf, \"success\");\n+        debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n         Ok(Generalization { ty, needs_wf })\n     }\n "}, {"sha": "90c0ff9226f7783618ff2219672a0965043cfa73", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -66,19 +66,18 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.relate(a, b)\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }\n \n-        trace!(a = ?a.kind(), b = ?b.kind());\n-\n         let infcx = self.fields.infcx;\n-\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n \n+        debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n+\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);\n@@ -92,21 +91,6 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n             }\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                self.fields.infcx.super_combine_tys(self, a, b)?;\n-            }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-                if self.fields.define_opaque_types && did.is_local() =>\n-            {\n-                self.fields.obligations.push(infcx.opaque_ty_obligation(\n-                    a,\n-                    b,\n-                    self.a_is_expected(),\n-                    self.param_env(),\n-                    self.fields.trace.cause.clone(),\n-                ));\n-            }\n-\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }"}, {"sha": "862f5a5fbb8c1805ca84a47bc2e1ff71f7c9d7d2", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,7 +4,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::{ObligationCause, PredicateObligation};\n+use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -111,20 +111,12 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n-    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n-        self.fields.obligations.extend(obligations)\n-    }\n-\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(v, a)?;\n         sub.relate(v, b)?;\n         Ok(())\n     }\n-\n-    fn define_opaque_types(&self) -> bool {\n-        self.fields.define_opaque_types\n-    }\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {"}, {"sha": "c47d476963772e2adda260bca51b6a4f3e1f1c97", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -22,7 +22,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n-use crate::traits::{ObligationCause, PredicateObligation};\n+use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n use rustc_middle::ty::{self, Ty};\n@@ -32,10 +32,6 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n-    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n-\n-    fn define_opaque_types(&self) -> bool;\n-\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     //\n@@ -45,7 +41,6 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-#[instrument(skip(this), level = \"debug\")]\n pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n     this: &mut L,\n     a: Ty<'tcx>,\n@@ -54,17 +49,15 @@ pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n where\n     L: LatticeDir<'a, 'tcx>,\n {\n-    debug!(\"{}\", this.tag());\n+    debug!(\"{}.lattice_tys({:?}, {:?})\", this.tag(), a, b);\n \n     if a == b {\n         return Ok(a);\n     }\n \n     let infcx = this.infcx();\n-\n     let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n     let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n-\n     match (a.kind(), b.kind()) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n@@ -101,22 +94,6 @@ where\n             Ok(v)\n         }\n \n-        (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-            infcx.super_combine_tys(this, a, b)\n-        }\n-        (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-            if this.define_opaque_types() && did.is_local() =>\n-        {\n-            this.add_obligations(vec![infcx.opaque_ty_obligation(\n-                a,\n-                b,\n-                this.a_is_expected(),\n-                this.param_env(),\n-                this.cause().clone(),\n-            )]);\n-            Ok(a)\n-        }\n-\n         _ => infcx.super_combine_tys(this, a, b),\n     }\n }"}, {"sha": "5191d1c1cc1008c8706a9fcc2d866affe976360a", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,7 +4,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::{ObligationCause, PredicateObligation};\n+use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -117,18 +117,10 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n-    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n-        self.fields.obligations.extend(obligations)\n-    }\n-\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(a, v)?;\n         sub.relate(b, v)?;\n         Ok(())\n     }\n-\n-    fn define_opaque_types(&self) -> bool {\n-        self.fields.define_opaque_types\n-    }\n }"}, {"sha": "c18d36d1f74a2b93d45782d4c1398ddf86e402dd", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 45, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,7 +5,7 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n-use self::opaque_types::OpaqueTypeStorage;\n+use self::opaque_types::OpaqueTypeMap;\n pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n@@ -192,8 +192,18 @@ pub struct InferCtxtInner<'tcx> {\n \n     undo_log: InferCtxtUndoLogs<'tcx>,\n \n-    /// Caches for opaque type inference.\n-    pub opaque_type_storage: OpaqueTypeStorage<'tcx>,\n+    // Opaque types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // 'de-opaque' OpaqueTypeDecl outside of type inference.\n+    pub opaque_types: OpaqueTypeMap<'tcx>,\n+\n+    /// A map from inference variables created from opaque\n+    /// type instantiations (`ty::Infer`) to the actual opaque\n+    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n+    /// opaque type inference variables to their corresponding\n+    /// opaque type.\n+    pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n@@ -207,7 +217,8 @@ impl<'tcx> InferCtxtInner<'tcx> {\n             float_unification_storage: ut::UnificationTableStorage::new(),\n             region_constraint_storage: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n-            opaque_type_storage: Default::default(),\n+            opaque_types: Default::default(),\n+            opaque_types_vars: Default::default(),\n         }\n     }\n \n@@ -226,11 +237,6 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         self.type_variable_storage.with_log(&mut self.undo_log)\n     }\n \n-    #[inline]\n-    pub fn opaque_types(&mut self) -> opaque_types::OpaqueTypeTable<'_, 'tcx> {\n-        self.opaque_type_storage.with_log(&mut self.undo_log)\n-    }\n-\n     #[inline]\n     fn int_unification_table(\n         &mut self,\n@@ -291,10 +297,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n     pub defining_use_anchor: Option<LocalDefId>,\n \n-    /// Used by WF-checking to not have to figure out hidden types itself, but\n-    /// to just invoke type_of to get the already computed hidden type from typeck.\n-    pub reveal_defining_opaque_types: bool,\n-\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -563,7 +565,6 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: Option<LocalDefId>,\n-    reveal_defining_opaque_types: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -572,12 +573,7 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder {\n-            tcx: self,\n-            defining_use_anchor: None,\n-            fresh_typeck_results: None,\n-            reveal_defining_opaque_types: false,\n-        }\n+        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n     }\n }\n \n@@ -601,13 +597,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n-    /// WF-checking doesn't need to recompute opaque types and can instead use\n-    /// the type_of query to get them from typeck.\n-    pub fn reveal_defining_opaque_types(mut self) -> Self {\n-        self.reveal_defining_opaque_types = true;\n-        self\n-    }\n-\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -632,17 +621,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder {\n-            tcx,\n-            defining_use_anchor,\n-            reveal_defining_opaque_types,\n-            ref fresh_typeck_results,\n-        } = *self;\n+        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n-            reveal_defining_opaque_types,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n@@ -764,15 +747,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        define_opaque_types: bool,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n             cause: None,\n             param_env,\n             obligations: PredicateObligations::new(),\n-            define_opaque_types,\n         }\n     }\n \n@@ -1088,20 +1069,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(origin))\n     }\n \n-    pub fn next_ty_var_id_in_universe(\n-        &self,\n-        origin: TypeVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> TyVid {\n-        self.inner.borrow_mut().type_variables().new_var(universe, origin)\n-    }\n-\n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.next_ty_var_id_in_universe(origin, universe);\n+        let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n "}, {"sha": "0a210ed053ce4ec7f61c9bbc0aa4ea3e0e13c6e5", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -24,13 +24,11 @@\n use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n-use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n-use rustc_span::Span;\n use std::fmt::Debug;\n use std::ops::ControlFlow;\n \n@@ -77,7 +75,6 @@ where\n \n pub trait TypeRelatingDelegate<'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n-    fn span(&self) -> Span;\n \n     /// Push a constraint `sup: sub` -- this constraint must be\n     /// satisfied for the two types to be related. `sub` and `sup` may\n@@ -90,8 +87,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n-    fn register_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool);\n-\n     fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n@@ -282,6 +277,7 @@ where\n         projection_ty: ty::ProjectionTy<'tcx>,\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n+        use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n@@ -290,8 +286,6 @@ where\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n                 });\n-                // FIXME(lazy-normalization): This will always ICE, because the recursive\n-                // call will end up in the _ arm below.\n                 self.relate_projection_ty(projection_ty, var);\n                 self.relate_projection_ty(other_projection_ty, var);\n                 var\n@@ -537,8 +531,6 @@ where\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let infcx = self.infcx;\n-\n         let a = self.infcx.shallow_resolve(a);\n \n         if !D::forbid_inference_vars() {\n@@ -567,35 +559,6 @@ where\n \n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                self.infcx.super_combine_tys(self, a, b)\n-            }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n-                let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-                let mut generalize = |ty, ty_is_expected| {\n-                    let var = infcx.next_ty_var_id_in_universe(\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: self.delegate.span(),\n-                        },\n-                        ty::UniverseIndex::ROOT,\n-                    );\n-                    if ty_is_expected {\n-                        self.relate_ty_var((ty, var))\n-                    } else {\n-                        self.relate_ty_var((var, ty))\n-                    }\n-                };\n-                let (a, b) = match (a.kind(), b.kind()) {\n-                    (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n-                    (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n-                    _ => unreachable!(),\n-                };\n-                self.delegate.register_opaque_type(a, b, true);\n-                trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n-                Ok(a)\n-            }\n-\n             (&ty::Projection(projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {"}, {"sha": "e7dca94806cb740243e7ab0af2c141a84635e2ce", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 223, "deletions": 238, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,10 @@\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::{self, PredicateObligation};\n-use hir::def_id::{DefId, LocalDefId};\n-use hir::OpaqueTyOrigin;\n+use crate::traits;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_middle::traits::ObligationCause;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n@@ -15,28 +14,14 @@ use std::ops::ControlFlow;\n \n pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n-mod table;\n-\n-pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n-\n-use super::InferResult;\n-\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n-    /// The hidden types that have been inferred for this opaque type.\n-    /// There can be multiple, but they are all `lub`ed together at the end\n-    /// to obtain the canonical hidden type.\n-    pub hidden_type: OpaqueHiddenType<'tcx>,\n-\n-    /// The origin of the opaque type.\n-    pub origin: hir::OpaqueTyOrigin,\n-}\n+    /// The opaque type (`ty::Opaque`) for this declaration.\n+    pub opaque_type: Ty<'tcx>,\n \n-#[derive(Copy, Clone, Debug, TypeFoldable)]\n-pub struct OpaqueHiddenType<'tcx> {\n     /// The span of this particular definition of the opaque type. So\n     /// for example:\n     ///\n@@ -50,7 +35,7 @@ pub struct OpaqueHiddenType<'tcx> {\n     /// In cases where the fn returns `(impl Trait, impl Trait)` or\n     /// other such combinations, the result is currently\n     /// over-approximated, but better than nothing.\n-    pub span: Span,\n+    pub definition_span: Span,\n \n     /// The type variable that represents the value of the opaque type\n     /// that we require. In other words, after we compile this function,\n@@ -64,132 +49,54 @@ pub struct OpaqueHiddenType<'tcx> {\n     /// those that are arguments to `Foo` in the constraint above. (In\n     /// other words, `?C` should not include `'b`, even though it's a\n     /// lifetime parameter on `foo`.)\n-    pub ty: Ty<'tcx>,\n+    pub concrete_ty: Ty<'tcx>,\n+\n+    /// The origin of the opaque type.\n+    pub origin: hir::OpaqueTyOrigin,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn handle_opaque_type(\n+    /// Replaces all opaque types in `value` with fresh inference variables\n+    /// and creates appropriate obligations. For example, given the input:\n+    ///\n+    ///     impl Iterator<Item = impl Debug>\n+    ///\n+    /// this method would create two type variables, `?0` and `?1`. It would\n+    /// return the type `?0` but also the obligations:\n+    ///\n+    ///     ?0: Iterator<Item = ?1>\n+    ///     ?1: Debug\n+    ///\n+    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n+    /// info about the `impl Iterator<..>` type and `?1` to info about\n+    /// the `impl Debug` type.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n+    ///   is defined\n+    /// - `body_id` -- the body-id with which the resulting obligations should\n+    ///   be associated\n+    /// - `param_env` -- the in-scope parameter environment to be used for\n+    ///   obligations\n+    /// - `value` -- the value within which we are instantiating opaque types\n+    /// - `value_span` -- the span where the value came from, used in error reporting\n+    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        cause: &ObligationCause<'tcx>,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        if a.references_error() || b.references_error() {\n-            return Ok(InferOk { value: (), obligations: vec![] });\n-        }\n-        if self.defining_use_anchor.is_some() {\n-            let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n-                ty::Opaque(def_id, substs) => {\n-                    if let ty::Opaque(did2, _) = *b.kind() {\n-                        // We could accept this, but there are various ways to handle this situation, and we don't\n-                        // want to make a decision on it right now. Likely this case is so super rare anyway, that\n-                        // no one encounters it in practice.\n-                        // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n-                        // where it is of no concern, so we only check for TAITs.\n-                        if let Some(OpaqueTyOrigin::TyAlias) =\n-                            self.opaque_type_origin(did2, cause.span)\n-                        {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    cause.span,\n-                                    \"opaque type's hidden type cannot be another opaque type from the same scope\",\n-                                )\n-                                .span_label(cause.span, \"one of the two opaque types used here has to be outside its defining scope\")\n-                                .span_note(\n-                                    self.tcx.def_span(def_id),\n-                                    \"opaque type whose hidden type is being assigned\",\n-                                )\n-                                .span_note(\n-                                    self.tcx.def_span(did2),\n-                                    \"opaque type being used as hidden type\",\n-                                )\n-                                .emit();\n-                        }\n-                    }\n-                    Some(self.register_hidden_type(\n-                        OpaqueTypeKey { def_id, substs },\n-                        cause.clone(),\n-                        param_env,\n-                        b,\n-                        // Check that this is `impl Trait` type is\n-                        // declared by `parent_def_id` -- i.e., one whose\n-                        // value we are inferring.  At present, this is\n-                        // always true during the first phase of\n-                        // type-check, but not always true later on during\n-                        // NLL. Once we support named opaque types more fully,\n-                        // this same scenario will be able to arise during all phases.\n-                        //\n-                        // Here is an example using type alias `impl Trait`\n-                        // that indicates the distinction we are checking for:\n-                        //\n-                        // ```rust\n-                        // mod a {\n-                        //   pub type Foo = impl Iterator;\n-                        //   pub fn make_foo() -> Foo { .. }\n-                        // }\n-                        //\n-                        // mod b {\n-                        //   fn foo() -> a::Foo { a::make_foo() }\n-                        // }\n-                        // ```\n-                        //\n-                        // Here, the return type of `foo` references an\n-                        // `Opaque` indeed, but not one whose value is\n-                        // presently being inferred. You can get into a\n-                        // similar situation with closure return types\n-                        // today:\n-                        //\n-                        // ```rust\n-                        // fn foo() -> impl Iterator { .. }\n-                        // fn bar() {\n-                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                        // }\n-                        // ```\n-                        self.opaque_type_origin(def_id, cause.span)?,\n-                    ))\n-                }\n-                _ => None,\n-            };\n-            if let Some(res) = process(a, b) {\n-                res\n-            } else if let Some(res) = process(b, a) {\n-                res\n-            } else {\n-                // Rerun equality check, but this time error out due to\n-                // different types.\n-                match self.at(cause, param_env).define_opaque_types(false).eq(a, b) {\n-                    Ok(_) => span_bug!(\n-                        cause.span,\n-                        \"opaque types are never equal to anything but themselves: {:#?}\",\n-                        (a, b)\n-                    ),\n-                    Err(e) => Err(e),\n-                }\n-            }\n-        } else {\n-            let (opaque_type, hidden_ty) = match (a.kind(), b.kind()) {\n-                (ty::Opaque(..), _) => (a, b),\n-                (_, ty::Opaque(..)) => (b, a),\n-                types => span_bug!(\n-                    cause.span,\n-                    \"opaque type obligations only work for opaque types: {:#?}\",\n-                    types\n-                ),\n-            };\n-            let key = opaque_type.expect_opaque_type();\n-            let origin = self.opaque_ty_origin_unchecked(key.def_id, cause.span);\n-            let prev = self.inner.borrow_mut().opaque_types().register(\n-                key,\n-                OpaqueHiddenType { ty: hidden_ty, span: cause.span },\n-                origin,\n-            );\n-            match prev {\n-                Some(prev) => self.at(cause, param_env).eq(prev, hidden_ty),\n-                None => Ok(InferOk { value: (), obligations: vec![] }),\n-            }\n-        }\n+        value: T,\n+        value_span: Span,\n+    ) -> InferOk<'tcx, T> {\n+        debug!(\n+            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n+             param_env={:?}, value_span={:?})\",\n+            value, body_id, param_env, value_span,\n+        );\n+        let mut instantiator =\n+            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n+        let value = instantiator.instantiate_opaque_types_in_map(value);\n+        InferOk { value, obligations: instantiator.obligations }\n     }\n \n     /// Given the map `opaque_types` containing the opaque\n@@ -324,23 +231,51 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// but this is not necessary, because the opaque type we\n     /// create will be allowed to reference `T`. So we only generate a\n     /// constraint that `'0: 'a`.\n+    ///\n+    /// # The `free_region_relations` parameter\n+    ///\n+    /// The `free_region_relations` argument is used to find the\n+    /// \"minimum\" of the regions supplied to a given opaque type.\n+    /// It must be a relation that can answer whether `'a <= 'b`,\n+    /// where `'a` and `'b` are regions that appear in the \"substs\"\n+    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n+    ///\n+    /// Note that we do not impose the constraints based on the\n+    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n+    /// is because the constraints we are imposing here is basically\n+    /// the concern of the one generating the constraining type C1,\n+    /// which is the current function. It also means that we can\n+    /// take \"implied bounds\" into account in some cases:\n+    ///\n+    /// ```text\n+    /// trait SomeTrait<'a, 'b> { }\n+    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    /// ```\n+    ///\n+    /// Here, the fact that `'b: 'a` is known only because of the\n+    /// implied bounds from the `&'a &'b u32` parameter, and is not\n+    /// \"inherent\" to the opaque type definition.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n+    /// - `free_region_relations` -- something that can be used to relate\n+    ///   the free regions (`'a`) that appear in the impl trait.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub fn register_member_constraints(\n+    pub fn constrain_opaque_type(\n         &self,\n-        param_env: ty::ParamEnv<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        concrete_ty: Ty<'tcx>,\n-        span: Span,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n     ) {\n         let def_id = opaque_type_key.def_id;\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n \n         debug!(?concrete_ty);\n \n-        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n+        let first_own_region = match opaque_defn.origin {\n             hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n                 // We lower\n                 //\n@@ -384,7 +319,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             op: |r| {\n                 self.member_constraint(\n                     opaque_type_key.def_id,\n-                    span,\n+                    opaque_defn.definition_span,\n                     concrete_ty,\n                     r,\n                     &choice_regions,\n@@ -393,34 +328,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         });\n     }\n \n-    pub fn opaque_ty_obligation(\n-        &self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n-        param_env: ty::ParamEnv<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-    ) -> PredicateObligation<'tcx> {\n-        let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n-        PredicateObligation::new(\n-            cause,\n-            param_env,\n-            self.tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::OpaqueType(a, b))),\n-        )\n-    }\n-\n-    #[instrument(skip(self), level = \"trace\")]\n-    pub fn opaque_type_origin(&self, opaque_def_id: DefId, span: Span) -> Option<OpaqueTyOrigin> {\n-        let def_id = opaque_def_id.as_local()?;\n-        let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n+        let tcx = self.tcx;\n+        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = self.defining_use_anchor?;\n-        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n-\n+        let item_kind = &tcx.hir().expect_item(def_id).kind;\n         let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n             span_bug!(\n-                span,\n-                \"weird opaque type: {:#?}, {:#?}\",\n-                opaque_def_id,\n+                tcx.def_span(def_id),\n+                \"weird opaque type: {:#?}\",\n                 item_kind\n             )\n         };\n@@ -431,29 +347,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n             // Named `type Foo = impl Bar;`\n             hir::OpaqueTyOrigin::TyAlias => {\n-                may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n+                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n-        trace!(?origin);\n         in_definition_scope.then_some(*origin)\n     }\n-\n-    #[instrument(skip(self), level = \"trace\")]\n-    fn opaque_ty_origin_unchecked(&self, opaque_def_id: DefId, span: Span) -> OpaqueTyOrigin {\n-        let def_id = opaque_def_id.as_local().unwrap();\n-        let origin = match self.tcx.hir().expect_item(def_id).kind {\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n-            ref itemkind => {\n-                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", opaque_def_id, itemkind)\n-            }\n-        };\n-        trace!(?origin);\n-        origin\n-    }\n-\n-    pub fn opaque_types(&self) -> OpaqueTypeMap<'tcx> {\n-        self.inner.borrow().opaque_type_storage.opaque_types()\n-    }\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -528,93 +426,180 @@ where\n     }\n }\n \n-pub enum UseKind {\n-    DefiningUse,\n-    OpaqueUse,\n+struct Instantiator<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    body_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value_span: Span,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n }\n \n-impl UseKind {\n-    pub fn is_defining(self) -> bool {\n-        match self {\n-            UseKind::DefiningUse => true,\n-            UseKind::OpaqueUse => false,\n-        }\n+impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n+    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n+        let tcx = self.infcx.tcx;\n+        value.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            ty_op: |ty| {\n+                if ty.references_error() {\n+                    return tcx.ty_error();\n+                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    if let Some(def_id) = def_id.as_local() {\n+                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n+                            let opaque_type_key =\n+                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                        }\n+\n+                        debug!(\n+                            \"instantiate_opaque_types_in_map: \\\n+                             encountered opaque outside its definition scope \\\n+                             def_id={:?}\",\n+                            def_id,\n+                        );\n+                    }\n+                }\n+\n+                ty\n+            },\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+        })\n     }\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n-    fn register_hidden_type(\n-        &self,\n+    fn fold_opaque_ty(\n+        &mut self,\n+        ty: Ty<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        hidden_ty: Ty<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n-    ) -> InferResult<'tcx, ()> {\n-        let tcx = self.tcx;\n+    ) -> Ty<'tcx> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n+        // Use the same type variable if the exact same opaque type appears more\n+        // than once in the return type (e.g., if it's passed to a type alias).\n+        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n+            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n+            return opaque_defn.concrete_ty;\n+        }\n+\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::TypeInference,\n+            span: self.value_span,\n+        });\n+\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n-        let span = cause.span;\n+        let definition_span = self.value_span;\n \n-        let mut obligations = vec![];\n-        let prev = self.inner.borrow_mut().opaque_types().register(\n-            OpaqueTypeKey { def_id, substs },\n-            OpaqueHiddenType { ty: hidden_ty, span },\n-            origin,\n-        );\n-        if let Some(prev) = prev {\n-            obligations = self.at(&cause, param_env).eq(prev, hidden_ty)?.obligations;\n+        {\n+            let mut infcx = self.infcx.inner.borrow_mut();\n+            infcx.opaque_types.insert(\n+                OpaqueTypeKey { def_id, substs },\n+                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n+            );\n+            infcx.opaque_types_vars.insert(ty_var, ty);\n         }\n \n+        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n+\n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n+        self.obligations.reserve(item_bounds.len());\n         for (predicate, _) in item_bounds {\n             debug!(?predicate);\n             let predicate = predicate.subst(tcx, substs);\n+            debug!(?predicate);\n \n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n                 ty_op: |ty| match *ty.kind() {\n-                    // We can't normalize associated types from `rustc_infer`,\n-                    // but we can eagerly register inference variables for them.\n-                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => {\n-                        self.infer_projection(\n-                            param_env,\n-                            projection_ty,\n-                            cause.clone(),\n-                            0,\n-                            &mut obligations,\n-                        )\n-                    }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n                     // as the bounds must hold on the hidden type after all.\n                     ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n-                        hidden_ty\n+                        ty_var\n+                    }\n+                    // Instantiate nested instances of `impl Trait`.\n+                    ty::Opaque(..) => self.instantiate_opaque_types_in_map(ty),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n+\n+            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match ty.kind() {\n+                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => {\n+                        infcx.infer_projection(\n+                            self.param_env,\n+                            *projection_ty,\n+                            traits::ObligationCause::misc(self.value_span, self.body_id),\n+                            0,\n+                            &mut self.obligations,\n+                        )\n                     }\n                     _ => ty,\n                 },\n                 lt_op: |lt| lt,\n                 ct_op: |ct| ct,\n             });\n+            debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.term.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n-                    return Ok(InferOk { value: (), obligations: vec![] });\n+                    return tcx.ty_error();\n                 }\n-                trace!(\"{:#?}\", projection.term);\n             }\n+\n+            let cause =\n+                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n+\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n-            obligations.push(traits::Obligation::new(cause.clone(), param_env, predicate));\n+            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n-        Ok(InferOk { value: (), obligations })\n+\n+        ty_var\n     }\n }\n "}, {"sha": "9b8f225ce367b650c28b5e0daa1cae3e64023d8b", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,88 +0,0 @@\n-use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_hir::OpaqueTyOrigin;\n-use rustc_middle::ty::{self, OpaqueTypeKey, Ty};\n-use rustc_span::DUMMY_SP;\n-\n-use crate::infer::{InferCtxtUndoLogs, UndoLog};\n-\n-use super::{OpaqueHiddenType, OpaqueTypeDecl, OpaqueTypeMap};\n-\n-#[derive(Default, Debug)]\n-pub struct OpaqueTypeStorage<'tcx> {\n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n-    pub opaque_types: OpaqueTypeMap<'tcx>,\n-}\n-\n-impl<'tcx> OpaqueTypeStorage<'tcx> {\n-    #[instrument(level = \"debug\")]\n-    pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'tcx>, idx: Option<OpaqueHiddenType<'tcx>>) {\n-        if let Some(idx) = idx {\n-            self.opaque_types.get_mut(&key).unwrap().hidden_type = idx;\n-        } else {\n-            match self.opaque_types.remove(&key) {\n-                None => bug!(\"reverted opaque type inference that was never registered: {:?}\", key),\n-                Some(_) => {}\n-            }\n-        }\n-    }\n-\n-    pub fn get_decl(&self, key: &OpaqueTypeKey<'tcx>) -> Option<&OpaqueTypeDecl<'tcx>> {\n-        self.opaque_types.get(key)\n-    }\n-\n-    pub fn opaque_types(&self) -> OpaqueTypeMap<'tcx> {\n-        self.opaque_types.clone()\n-    }\n-\n-    #[instrument(level = \"debug\")]\n-    pub fn take_opaque_types(&mut self) -> OpaqueTypeMap<'tcx> {\n-        std::mem::take(&mut self.opaque_types)\n-    }\n-\n-    #[inline]\n-    pub(crate) fn with_log<'a>(\n-        &'a mut self,\n-        undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n-    ) -> OpaqueTypeTable<'a, 'tcx> {\n-        OpaqueTypeTable { storage: self, undo_log }\n-    }\n-}\n-\n-impl<'tcx> Drop for OpaqueTypeStorage<'tcx> {\n-    fn drop(&mut self) {\n-        if !self.opaque_types.is_empty() {\n-            ty::tls::with(|tcx| {\n-                tcx.sess.delay_span_bug(DUMMY_SP, &format!(\"{:?}\", self.opaque_types))\n-            });\n-        }\n-    }\n-}\n-\n-pub struct OpaqueTypeTable<'a, 'tcx> {\n-    storage: &'a mut OpaqueTypeStorage<'tcx>,\n-\n-    undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n-}\n-\n-impl<'a, 'tcx> OpaqueTypeTable<'a, 'tcx> {\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn register(\n-        &mut self,\n-        key: OpaqueTypeKey<'tcx>,\n-        hidden_type: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Option<Ty<'tcx>> {\n-        if let Some(decl) = self.storage.opaque_types.get_mut(&key) {\n-            let prev = std::mem::replace(&mut decl.hidden_type, hidden_type);\n-            self.undo_log.push(UndoLog::OpaqueTypes(key, Some(prev)));\n-            return Some(prev.ty);\n-        }\n-        let decl = OpaqueTypeDecl { hidden_type, origin };\n-        self.storage.opaque_types.insert(key, decl);\n-        self.undo_log.push(UndoLog::OpaqueTypes(key, None));\n-        None\n-    }\n-}"}, {"sha": "03d6c45a653459220fe75c4fbffe369549a44678", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -28,7 +28,6 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))"}, {"sha": "a5276afc5bfa7ed03b59fd2cc5ccecaa4378a70c", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -153,7 +153,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This function may have to perform normalizations, and hence it\n     /// returns an `InferOk` with subobligations that must be\n     /// processed.\n-    #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n     pub fn process_registered_region_obligations(\n         &self,\n         region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n@@ -165,6 +164,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             \"cannot process registered region obligations in a snapshot\"\n         );\n \n+        debug!(?param_env, \"process_registered_region_obligations()\");\n+\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for (body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {"}, {"sha": "ccac0efd6c9eec22084e869b9073afeb97aae04a", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,7 +2,6 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -75,16 +74,16 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n+\n         if a == b {\n             return Ok(a);\n         }\n \n         let infcx = self.fields.infcx;\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n-\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(_)), &ty::Infer(TyVar(_))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -122,40 +121,6 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(self.tcx().ty_error())\n             }\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                self.fields.infcx.super_combine_tys(self, a, b)?;\n-                Ok(a)\n-            }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-                if self.fields.define_opaque_types && did.is_local() =>\n-            {\n-                let mut generalize = |ty, ty_is_expected| {\n-                    let var = infcx.next_ty_var_id_in_universe(\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: self.fields.trace.cause.span,\n-                        },\n-                        ty::UniverseIndex::ROOT,\n-                    );\n-                    self.fields.instantiate(ty, RelationDir::SubtypeOf, var, ty_is_expected)?;\n-                    Ok(infcx.tcx.mk_ty_var(var))\n-                };\n-                let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n-                let (a, b) = match (a.kind(), b.kind()) {\n-                    (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n-                    (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n-                    _ => unreachable!(),\n-                };\n-                self.fields.obligations.push(infcx.opaque_ty_obligation(\n-                    a,\n-                    b,\n-                    true,\n-                    self.param_env(),\n-                    self.fields.trace.cause.clone(),\n-                ));\n-                Ok(a)\n-            }\n-\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)"}, {"sha": "89db8f464b4e7c7e41c2c003a4ab7def776c3341", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,23 +4,20 @@ use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::undo_log::{Rollback, UndoLogs};\n use rustc_data_structures::unify as ut;\n use rustc_middle::infer::unify_key::RegionVidKey;\n-use rustc_middle::ty::{self, OpaqueTypeKey};\n+use rustc_middle::ty;\n \n use crate::{\n     infer::{region_constraints, type_variable, InferCtxtInner},\n     traits,\n };\n \n-use super::opaque_types::OpaqueHiddenType;\n-\n pub struct Snapshot<'tcx> {\n     pub(crate) undo_len: usize,\n     _marker: PhantomData<&'tcx ()>,\n }\n \n /// Records the \"undo\" data for a single operation that affects some form of inference variable.\n pub(crate) enum UndoLog<'tcx> {\n-    OpaqueTypes(OpaqueTypeKey<'tcx>, Option<OpaqueHiddenType<'tcx>>),\n     TypeVariables(type_variable::UndoLog<'tcx>),\n     ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n     IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n@@ -67,7 +64,6 @@ impl_from! {\n impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {\n     fn reverse(&mut self, undo: UndoLog<'tcx>) {\n         match undo {\n-            UndoLog::OpaqueTypes(key, idx) => self.opaque_type_storage.remove(key, idx),\n             UndoLog::TypeVariables(undo) => self.type_variable_storage.reverse(undo),\n             UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),\n             UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),"}, {"sha": "674c75fdee56113bb3b1b29067d7b7ecb235d549", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -167,9 +167,6 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::PredicateKind::OpaqueType(..) => {\n-                todo!(\"{:#?}\", obligation)\n-            }\n             ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates."}, {"sha": "734b32bb92f1e88d4233b44de19690cc1769bbc1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1654,7 +1654,6 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n-                    OpaqueType(..) |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {"}, {"sha": "28217aeab13ee51d91d752fcfc5802b5d167cc49", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -178,12 +178,6 @@ pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub certainty: Certainty,\n-    /// List of opaque types which we tried to compare to another type.\n-    /// Inside the query we don't know yet whether the opaque type actually\n-    /// should get its hidden type inferred. So we bubble the opaque type\n-    /// and the type it was compared against upwards and let the query caller\n-    /// handle it.\n-    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n     pub value: R,\n }\n "}, {"sha": "e0e3febe6b3109b0c23cefe3b98f3cccffc95ca0", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -53,17 +53,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         self.relate(a, b)\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         Ok(a)\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }"}, {"sha": "a119655a90b20a53d260c8b6a873b959fefda8b1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -30,7 +30,6 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -465,13 +464,9 @@ pub struct TypeckResults<'tcx> {\n     /// this field will be set to `Some(ErrorReported)`.\n     pub tainted_by_errors: Option<ErrorReported>,\n \n-    /// All the opaque types that have hidden types set\n-    /// by this function. For return-position-impl-trait we also store the\n-    /// type here, so that mir-borrowck can figure out hidden types,\n-    /// even if they are only set in dead code (which doesn't show up in MIR).\n-    /// For type-alias-impl-trait, this map is only used to prevent query cycles,\n-    /// so the hidden types are all `None`.\n-    pub concrete_opaque_types: VecMap<DefId, Option<Ty<'tcx>>>,\n+    /// All the opaque types that are restricted to concrete types\n+    /// by this function.\n+    pub concrete_opaque_types: FxHashSet<DefId>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "f06a1b09cd82ab236553403b81ba572fd2d65dc6", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -265,10 +265,6 @@ impl FlagComputation {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n-            ty::PredicateKind::OpaqueType(opaque, ty) => {\n-                self.add_ty(opaque);\n-                self.add_ty(ty);\n-            }\n         }\n     }\n "}, {"sha": "3133cdfdd7a7211222a0e9336aa4240a798e0121", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1207,11 +1207,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\")]\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let flags = t.flags();\n-        trace!(t.flags=?t.flags());\n-        if flags.intersects(self.flags) {\n+    #[instrument(level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n+        debug!(\n+            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n+            t,\n+            t.flags(),\n+            self.flags\n+        );\n+        if t.flags().intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n             ControlFlow::CONTINUE\n@@ -1231,7 +1235,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(level = \"trace\")]\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);"}, {"sha": "8eb2793cc34e3b7fe6f636d6a64af2ed2897c6f4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -627,11 +627,6 @@ pub enum PredicateKind<'tcx> {\n     ///\n     /// Only used for Chalk.\n     TypeWellFormedFromEnv(Ty<'tcx>),\n-\n-    /// Represents a hidden type assignment for an opaque type.\n-    /// Such obligations get processed by checking whether the item currently being\n-    /// type-checked may acually define it.\n-    OpaqueType(Ty<'tcx>, Ty<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -991,7 +986,6 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n-            | PredicateKind::OpaqueType(..)\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1010,7 +1004,6 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n-            | PredicateKind::OpaqueType(..)\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1051,18 +1044,7 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    HashStable,\n-    TyEncodable,\n-    TyDecodable,\n-    TypeFoldable,\n-    Lift\n-)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "ddcc8680d835269bd4f34257bccb79f01db361c6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -644,23 +644,20 @@ pub trait PrettyPrinter<'tcx>:\n                     return Ok(self);\n                 }\n \n-                let parent = self.tcx().parent(def_id).expect(\"opaque types always have a parent\");\n-                match self.tcx().def_kind(parent) {\n-                    DefKind::TyAlias | DefKind::AssocTy => {\n-                        if let ty::Opaque(d, _) = *self.tcx().type_of(parent).kind() {\n-                            if d == def_id {\n-                                // If the type alias directly starts with the `impl` of the\n-                                // opaque type we're printing, then skip the `::{opaque#1}`.\n-                                p!(print_def_path(parent, substs));\n-                                return Ok(self);\n-                            }\n+                return with_no_queries(|| {\n+                    let def_key = self.tcx().def_key(def_id);\n+                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                        p!(write(\"{}\", name));\n+                        // FIXME(eddyb) print this with `print_def_path`.\n+                        if !substs.is_empty() {\n+                            p!(\"::\");\n+                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n                         }\n-                        // Complex opaque type, e.g. `type Foo = (i32, impl Debug);`\n-                        p!(print_def_path(def_id, substs));\n                         return Ok(self);\n                     }\n-                    _ => return self.pretty_print_opaque_impl_type(def_id, substs),\n-                }\n+\n+                    self.pretty_print_opaque_impl_type(def_id, substs)\n+                });\n             }\n             ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n@@ -2610,9 +2607,6 @@ define_print_and_forward_display! {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n-            ty::PredicateKind::OpaqueType(a, b) => {\n-                p!(\"opaque type assigment with `\", print(a), \"` == `\", print(b) ,\"`\")\n-            }\n         }\n     }\n "}, {"sha": "1c5bc7860db2de7280f0446399e3f3ec796fa051", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -191,9 +191,6 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n-            ty::PredicateKind::OpaqueType(a, b) => {\n-                write!(f, \"OpaqueType({:?}, {:?})\", a.kind(), b.kind())\n-            }\n         }\n     }\n }\n@@ -466,9 +463,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 tcx.lift(ty).map(ty::PredicateKind::TypeWellFormedFromEnv)\n             }\n-            ty::PredicateKind::OpaqueType(opaque, ty) => {\n-                Some(ty::PredicateKind::OpaqueType(tcx.lift(opaque)?, tcx.lift(ty)?))\n-            }\n         }\n     }\n }"}, {"sha": "786cf4fb25199cd5b6c77f39d17fe2c7a9374778", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1866,13 +1866,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn expect_opaque_type(&self) -> ty::OpaqueTypeKey<'tcx> {\n-        match *self.kind() {\n-            Opaque(def_id, substs) => ty::OpaqueTypeKey { def_id, substs },\n-            _ => bug!(\"`expect_opaque_type` called on non-opaque type: {}\", self),\n-        }\n-    }\n-\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {"}, {"sha": "df71379c1d88643c50813a1329565cc9c401bc90", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n+use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n-use rustc_middle::{mir::*, ty};\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n use rustc_span::Span;\n@@ -192,9 +192,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // This return type is usually `()`, unless the block is diverging, in which case the\n             // return type is `!`. For the unit type, we need to actually return the unit, but in\n             // the case of `!`, no return value is required, as the block will never return.\n-            // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n-            // type is actually unit. Otherwise there will be no defining use found in the MIR.\n-            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n+            if destination_ty.is_unit() {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "c95dff13d6615ffe71097d8f480fad6097a7f9c6", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -186,6 +186,7 @@ impl<K: DepKind> EncoderState<K> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, record_graph))]\n     fn encode_node(\n         &mut self,\n         node: &NodeInfo<K>,\n@@ -212,6 +213,7 @@ impl<K: DepKind> EncoderState<K> {\n             stat.edge_counter += edge_count as u64;\n         }\n \n+        debug!(?index, ?node);\n         let encoder = &mut self.encoder;\n         if self.result.is_ok() {\n             self.result = node.encode(encoder);"}, {"sha": "ea0ac6318bc9a71ff736d9d986b1825010a89eb6", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// purpose of this function is to do that translation.\n     ///\n     /// (*) C1 and C2 were introduced in the comments on\n-    /// `register_member_constraints`. Read that comment for more context.\n+    /// `constrain_opaque_type`. Read that comment for more context.\n     ///\n     /// # Parameters\n     ///\n@@ -48,10 +48,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n-        }\n-\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n         // Use substs to build up a reverse map from regions to their\n@@ -71,6 +67,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // after producing an error for each of them.\n         let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n             self.tcx,\n+            self.is_tainted_by_errors(),\n             def_id,\n             map,\n             instantiated_ty,\n@@ -85,6 +82,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n+    /// If errors have already been reported in this fn, we suppress\n+    /// our own errors because they are sometimes derivative.\n+    tainted_by_errors: bool,\n+\n     opaque_type_def_id: DefId,\n     map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n     map_missing_regions_to_empty: bool,\n@@ -99,13 +100,15 @@ struct ReverseMapper<'tcx> {\n impl<'tcx> ReverseMapper<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n+        tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n         map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n         Self {\n             tcx,\n+            tainted_by_errors,\n             opaque_type_def_id,\n             map,\n             map_missing_regions_to_empty: false,\n@@ -164,7 +167,9 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n+            None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n+                self.tcx.lifetimes.re_root_empty\n+            }\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n@@ -354,7 +359,6 @@ crate fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty"}, {"sha": "f2ed5ae26a3c268569cf3174c25ef9d77e04407a", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -853,7 +853,6 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n             };\n         }"}, {"sha": "603ab0622f0229327c3733358762802de1a7c728", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -90,11 +90,6 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         });\n         let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, impl_source);\n \n-        // We may constrain the hidden types of opaque types in this query, but this is\n-        // not information our callers need, as all that information is handled by borrowck\n-        // and typeck.\n-        drop(infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types());\n-\n         debug!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n         Ok(&*tcx.arena.alloc(impl_source))\n     })"}, {"sha": "f80fad19528da3499194e7a9f8053ad211af3f16", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -775,10 +775,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n-\n-                    ty::PredicateKind::OpaqueType(..) => {\n-                        todo!(\"{:#?}\", obligation);\n-                    }\n                 }\n             }\n "}, {"sha": "b594723aa0bd2790ffa768ee570d1bc92856000a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1328,7 +1328,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ty::Generator(..) => \"generator\",\n             _ => \"function\",\n         };\n-        let span = self.tcx.sess.source_map().guess_head_span(span);\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1681,7 +1680,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ));\n \n             let original_span = err.span.primary_span().unwrap();\n-            let original_span = self.tcx.sess.source_map().guess_head_span(original_span);\n             let mut span = MultiSpan::from_span(original_span);\n \n             let message = outer_generator"}, {"sha": "e7897887df7063896245eacb455be83a41d75f81", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -397,9 +397,6 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::OpaqueType(..) => {\n-                    todo!(\"{:#?}\", obligation);\n-                }\n             },\n             Some(pred) => match pred {\n                 ty::PredicateKind::Trait(data) => {\n@@ -645,20 +642,6 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::OpaqueType(a, b) => {\n-                    match self.selcx.infcx().handle_opaque_type(\n-                        a,\n-                        b,\n-                        &obligation.cause,\n-                        obligation.param_env,\n-                    ) {\n-                        Ok(value) => ProcessResult::Changed(mk_pending(value.obligations)),\n-                        Err(err) => ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n-                            ExpectedFound::new(true, a, b),\n-                            err,\n-                        )),\n-                    }\n-                }\n             },\n         }\n     }"}, {"sha": "7818053218decef33c5f9a848dc26cd8c9d884c6", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -313,7 +313,6 @@ fn predicate_references_self<'tcx>(\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n-        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }\n@@ -348,7 +347,6 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }\n     })"}, {"sha": "0a85676f4315e36a88893a759201e899d87b0754", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{InferCtxt, InferOk};\n use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n-use crate::traits::TraitEngine;\n+use crate::traits::{ObligationCause, TraitEngine};\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -60,6 +60,7 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<TypeOpOutput<'tcx, Op>> {\n     let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+    let dummy_body_id = ObligationCause::dummy().body_id;\n \n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n@@ -74,6 +75,7 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n+    debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n     fulfill_cx.register_predicate_obligations(infcx, obligations);\n     let errors = fulfill_cx.select_all_or_error(infcx);\n     if !errors.is_empty() {"}, {"sha": "db86041f6180b5efdc49a71aebda28ba7a8d2020", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -254,7 +254,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n-            debug!(ty = ?obligation.predicate.skip_binder().self_ty(), \"ambiguous inference var or opaque type\");\n             // Self is a type variable (e.g., `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really"}, {"sha": "47427395b93b36adff83c8dda2f9034cc12346bf", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -37,7 +37,6 @@ use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n-use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -698,19 +697,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n-                ty::PredicateKind::OpaqueType(a, b) => {\n-                    match self.infcx().handle_opaque_type(\n-                        a,\n-                        b,\n-                        &obligation.cause,\n-                        obligation.param_env,\n-                    ) {\n-                        Ok(res) => {\n-                            self.evaluate_predicates_recursively(previous_stack, res.obligations)\n-                        }\n-                        Err(_) => Ok(EvaluatedToErr),\n-                    }\n-                }\n             }\n         });\n \n@@ -1351,7 +1337,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self, param_env, cache_fresh_trait_pred, dep_node), level = \"debug\")]\n     fn insert_candidate_cache(\n         &mut self,\n         mut param_env: ty::ParamEnv<'tcx>,\n@@ -1392,15 +1377,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a projection, look at the bounds of `T::Bar`, see if we can find a\n     /// `Baz` bound. We return indexes into the list returned by\n     /// `tcx.item_bounds` for any applicable bounds.\n-    #[instrument(level = \"debug\", skip(self))]\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[usize; 2]> {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n-        debug!(?placeholder_trait_predicate);\n+        debug!(\n+            ?placeholder_trait_predicate,\n+            \"match_projection_obligation_against_definition_bounds\"\n+        );\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n@@ -1451,7 +1438,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .collect();\n \n-        debug!(?matching_bounds);\n+        debug!(?matching_bounds, \"match_projection_obligation_against_definition_bounds\");\n         matching_bounds\n     }\n \n@@ -1481,7 +1468,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .define_opaque_types(false)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n@@ -1537,7 +1523,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .define_opaque_types(false)\n             .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n@@ -2096,22 +2081,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n-                self.infcx.tcx.sess.delay_span_bug(\n-                    obligation.cause.span,\n-                    &format!(\n-                        \"Impl {:?} was matchable against {:?} but now is not\",\n-                        impl_def_id, obligation\n-                    ),\n+                bug!(\n+                    \"Impl {:?} was matchable against {:?} but now is not\",\n+                    impl_def_id,\n+                    obligation\n                 );\n-                let value = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n-                let err = self.tcx().ty_error();\n-                let value = value.fold_with(&mut BottomUpFolder {\n-                    tcx: self.tcx(),\n-                    ty_op: |_| err,\n-                    lt_op: |l| l,\n-                    ct_op: |c| c,\n-                });\n-                Normalized { value, obligations: vec![] }\n             }\n         }\n     }\n@@ -2248,11 +2222,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            // We don't want predicates for opaque types to just match all other types,\n-            // if there is an obligation on the opaque type, then that obligation must be met\n-            // opaquely. Otherwise we'd match any obligation to the opaque type and then error\n-            // out later.\n-            .define_opaque_types(false)\n             .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())"}, {"sha": "493cb199f114485d544538a14e22f1e8dbd7d41e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -146,10 +146,6 @@ pub fn predicate_obligations<'a, 'tcx>(\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n-        ty::PredicateKind::OpaqueType(opaque, ty) => {\n-            wf.compute(opaque.into());\n-            wf.compute(ty.into());\n-        }\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }"}, {"sha": "67d0ba39667d31127bb910d1283bace99b87356c", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -110,7 +110,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n@@ -197,7 +196,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n@@ -612,7 +610,6 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n@@ -742,7 +739,6 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }"}, {"sha": "09bfdabf4737357871a7fad22d2bfdd7f6f8577b", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -142,7 +142,6 @@ crate fn evaluate_goal<'tcx>(\n                 var_values: CanonicalVarValues { var_values },\n                 region_constraints: QueryRegionConstraints::default(),\n                 certainty: Certainty::Proven,\n-                opaque_types: vec![],\n                 value: (),\n             },\n         };\n@@ -171,7 +170,6 @@ crate fn evaluate_goal<'tcx>(\n                                     .make_identity(tcx),\n                                 region_constraints: QueryRegionConstraints::default(),\n                                 certainty: Certainty::Ambiguous,\n-                                opaque_types: vec![],\n                                 value: (),\n                             },\n                         };"}, {"sha": "90c698db8fb542eb212b88623332213d1ab8e7f6", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -105,7 +105,6 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);"}, {"sha": "46c2f7e4cf2ed2ada9587a72a69ff03ec8b77f54", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -69,7 +69,6 @@ fn not_outlives_predicate<'tcx>(p: &ty::Predicate<'tcx>) -> bool {\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n-        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,\n     }\n }"}, {"sha": "ec6fb622d32aa40c9f7d097115ed143fd1b609e3", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -61,14 +61,6 @@ bitflags! {\n                                           | TypeFlags::HAS_CT_INFER.bits\n                                           | TypeFlags::HAS_TY_PLACEHOLDER.bits\n                                           | TypeFlags::HAS_CT_PLACEHOLDER.bits\n-                                          // The `evaluate_obligation` query does not return further\n-                                          // obligations. If it evaluates an obligation with an opaque\n-                                          // type, that opaque type may get compared to another type,\n-                                          // constraining it. We would lose this information.\n-                                          // FIXME: differentiate between crate-local opaque types\n-                                          // and opaque types from other crates, as only opaque types\n-                                          // from the local crate can possibly be a local name\n-                                          | TypeFlags::HAS_TY_OPAQUE.bits\n                                           // We consider 'freshened' types and constants\n                                           // to depend on a particular fn.\n                                           // The freshening process throws away information,"}, {"sha": "405e4e8594a3ac60bd3d3210a49f57b73b35a4dc", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyS, TypeFoldable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n use rustc_span::{MultiSpan, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -98,7 +98,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n+            let opt_suggest_box_span =\n+                self.opt_suggest_box_span(arm.body.span, arm_ty, orig_expected);\n \n             let (arm_span, semi_span) =\n                 self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n@@ -503,15 +504,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n+        span: Span,\n         outer_ty: &'tcx TyS<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n-        match orig_expected {\n-            Expectation::ExpectHasType(expected)\n-                if self.in_tail_expr\n-                    && self.ret_coercion.as_ref()?.borrow().merged_ty().has_opaque_types()\n-                    && self.can_coerce(outer_ty, expected) =>\n+        match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {\n+            (Expectation::ExpectHasType(expected), Some((_id, ty)))\n+                if self.in_tail_expr && self.can_coerce(outer_ty, expected) =>\n             {\n+                let impl_trait_ret_ty =\n+                    self.infcx.instantiate_opaque_types(self.body_id, self.param_env, ty, span);\n+                assert!(\n+                    impl_trait_ret_ty.obligations.is_empty(),\n+                    \"we should never get new obligations here\"\n+                );\n                 let obligations = self.fulfillment_cx.borrow().pending_obligations();\n                 let mut suggest_box = !obligations.is_empty();\n                 for o in obligations {"}, {"sha": "0fea0afb572c9368f41cda8b8ccd6d1427c44b16", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -545,7 +545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n-        // `fn_sig` is the *signature* of the closure being called. We\n+        // `fn_sig` is the *signature* of the cosure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type."}, {"sha": "18a0a8767d45bf786d6ace91f4db58fd06d12465", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, ParamEnv, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, RegionKind, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -81,6 +81,8 @@ pub(super) fn check_fn<'a, 'tcx>(\n     can_be_generator: Option<hir::Movability>,\n     return_type_pre_known: bool,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n+    let mut fn_sig = fn_sig;\n+\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n@@ -93,8 +95,21 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n \n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(declared_ret_ty)));\n+    let revealed_ret_ty =\n+        fcx.instantiate_opaque_types_from_value(declared_ret_ty, decl.output.span());\n+    debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fcx.ret_type_span = Some(decl.output.span());\n+    if let ty::Opaque(..) = declared_ret_ty.kind() {\n+        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n+    }\n+    fn_sig = tcx.mk_fn_sig(\n+        fn_sig.inputs().iter().cloned(),\n+        revealed_ret_ty,\n+        fn_sig.c_variadic,\n+        fn_sig.unsafety,\n+        fn_sig.abi,\n+    );\n \n     let span = body.value.span;\n \n@@ -236,7 +251,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n             fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n         debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n     }\n-    fcx.demand_suptype(span, declared_ret_ty, actual_return_ty);\n+    fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n@@ -614,8 +629,6 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n-    let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n-\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n@@ -630,12 +643,24 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-            Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n-            Err(ty_err) => tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\"could not unify `{}` with revealed type:\\n{}\", hidden_type, ty_err,),\n-            ),\n+        let _ = inh.register_infer_ok_obligations(\n+            infcx.instantiate_opaque_types(hir_id, param_env, opaque_ty, span),\n+        );\n+\n+        let opaque_type_map = infcx.inner.borrow().opaque_types.clone();\n+        for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n+            let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n+            trace!(?hidden_type);\n+            match infcx.at(&misc_cause, param_env).eq(opaque_defn.concrete_ty, hidden_type) {\n+                Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+                Err(ty_err) => tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\n+                        \"could not check bounds on revealed type `{}`:\\n{}\",\n+                        hidden_type, ty_err,\n+                    ),\n+                ),\n+            }\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n@@ -647,7 +672,7 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         match origin {\n             // Checked when type checking the function containing them.\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => return,\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n                 // Finally, resolve all regions. This catches wily misuses of\n@@ -656,9 +681,6 @@ fn check_opaque_meets_bounds<'tcx>(\n                 fcx.regionck_item(hir_id, span, FxHashSet::default());\n             }\n         }\n-\n-        // Clean up after ourselves\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n     });\n }\n "}, {"sha": "e88099afa03539ce855f6e40d2320a40c968677c", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 16, "deletions": 79, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,20 +3,16 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n-use crate::rustc_middle::ty::subst::Subst;\n-use hir::OpaqueTyOrigin;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n-use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n-use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n@@ -176,29 +172,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n-            ty::Opaque(def_id, substs) => {\n-                let bounds = self.tcx.explicit_item_bounds(def_id);\n-                let sig = bounds.iter().find_map(|(pred, span)| match pred.kind().skip_binder() {\n-                    ty::PredicateKind::Projection(proj_predicate) => self\n-                        .deduce_sig_from_projection(\n-                            Some(*span),\n-                            pred.kind().rebind(proj_predicate.subst(self.tcx, substs)),\n-                        ),\n-                    _ => None,\n-                });\n-\n-                let kind = bounds\n-                    .iter()\n-                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(tp) => {\n-                            self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n-                        }\n-                        _ => None,\n-                    })\n-                    .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n-                trace!(?sig, ?kind);\n-                (sig, kind)\n-            }\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -224,7 +197,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let expected_sig =\n             self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(?obligation.predicate);\n+                debug!(\n+                    \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n+                    obligation.predicate\n+                );\n \n                 let bound_predicate = obligation.predicate.kind();\n                 if let ty::PredicateKind::Projection(proj_predicate) =\n@@ -425,14 +401,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // in this binder we are creating.\n         assert!(!expected_sig.sig.skip_binder().has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = expected_sig.sig.map_bound(|sig| {\n-            let output = self.hide_parent_opaque_types(\n-                sig.output(),\n-                expected_sig.cause_span.unwrap_or(DUMMY_SP),\n-                body.id().hir_id,\n-            );\n             self.tcx.mk_fn_sig(\n                 sig.inputs().iter().cloned(),\n-                output,\n+                sig.output(),\n                 sig.c_variadic,\n                 hir::Unsafety::Normal,\n                 Abi::RustCall,\n@@ -619,8 +590,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => astconv.ty_infer(None, decl.output.span()),\n             },\n         };\n-        let supplied_return =\n-            self.hide_parent_opaque_types(supplied_return, decl.output.span(), body.id().hir_id);\n \n         let result = ty::Binder::bind_with_vars(\n             self.tcx.mk_fn_sig(\n@@ -641,77 +610,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         result\n     }\n \n-    fn hide_parent_opaque_types(&self, ty: Ty<'tcx>, span: Span, body_id: hir::HirId) -> Ty<'tcx> {\n-        ty.fold_with(&mut ty::fold::BottomUpFolder {\n-            tcx: self.infcx.tcx,\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-            ty_op: |ty| match *ty.kind() {\n-                // Closures can't create hidden types for opaque types of their parent, as they\n-                // do not have all the outlives information available. Also `type_of` looks for\n-                // hidden types in the owner (so the closure's parent), so it would not find these\n-                // definitions.\n-                ty::Opaque(def_id, _substs)\n-                    if matches!(\n-                        self.infcx.opaque_type_origin(def_id, DUMMY_SP),\n-                        Some(OpaqueTyOrigin::FnReturn(..))\n-                    ) =>\n-                {\n-                    let ty_var = self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n-                        span,\n-                    });\n-                    let cause = ObligationCause::misc(span, body_id);\n-                    self.register_predicates(vec![self.infcx.opaque_ty_obligation(\n-                        ty,\n-                        ty_var,\n-                        true,\n-                        self.param_env,\n-                        cause,\n-                    )]);\n-                    ty_var\n-                }\n-                _ => ty,\n-            },\n-        })\n-    }\n-\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n     /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n-    #[instrument(skip(self), level = \"debug\")]\n     fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {\n+        debug!(\"deduce_future_output_from_obligations(expr_def_id={:?})\", expr_def_id);\n+\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n         });\n \n+        // In practice, the return type of the surrounding function is\n+        // always a (not yet resolved) inference variable, because it\n+        // is the hidden type for an `impl Trait` that we are going to\n+        // be inferring.\n         let ret_ty = ret_coercion.borrow().expected_ty();\n         let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-        let (def_id, substs) = match *ret_ty.kind() {\n-            ty::Opaque(def_id, substs) => (def_id, substs),\n+        let ret_vid = match *ret_ty.kind() {\n+            ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n             ty::Error(_) => return None,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),\n                 \"async fn generator return type not an inference variable\"\n             ),\n         };\n \n-        let item_bounds = self.tcx.explicit_item_bounds(def_id);\n-\n         // Search for a pending obligation like\n         //\n         // `<R as Future>::Output = T`\n         //\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n-        let output_ty = item_bounds.iter().find_map(|&(predicate, span)| {\n-            let bound_predicate = predicate.subst(self.tcx, substs).kind();\n+        let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n+            let bound_predicate = obligation.predicate.kind();\n             if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n                 self.deduce_future_output_from_projection(\n-                    span,\n+                    obligation.cause.span,\n                     bound_predicate.rebind(proj_predicate),\n                 )\n             } else {"}, {"sha": "3668ecd234c64e1c8b216af4f6d07e653ba8038b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1275,7 +1275,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n     /// Returns the current \"merged type\", representing our best-guess\n     /// at the LUB of the expressions we've seen so far (if any). This\n-    /// isn't *final* until you call `self.complete()`, which will return\n+    /// isn't *final* until you call `self.final()`, which will return\n     /// the merged type.\n     pub fn merged_ty(&self) -> Ty<'tcx> {\n         self.final_ty.unwrap_or(self.expected_ty)"}, {"sha": "e9e810344776b963d52a0eeb85fbd6ecbcc8c376", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,6 +1,5 @@\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_span::{self, Span};\n \n use super::Expectation::*;\n@@ -44,7 +43,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n     pub(super) fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match self.strip_opaque(fcx) {\n+        match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.shallow_resolve(ety);\n                 if !ety.is_ty_var() { ExpectHasType(ety) } else { NoExpectation }\n@@ -105,35 +104,14 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// for the program to type-check). `only_has_type` will return\n     /// such a constraint, if it exists.\n     pub(super) fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n-        match self.strip_opaque(fcx) {\n-            ExpectHasType(ty) => Some(ty),\n+        match self {\n+            ExpectHasType(ty) => Some(fcx.resolve_vars_if_possible(ty)),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) | IsLast(_) => {\n                 None\n             }\n         }\n     }\n \n-    /// We must not treat opaque types as expected types in their defining scope, as that\n-    /// will break `fn foo() -> impl Trait { if cond { a } else { b } }` if `a` and `b` are\n-    /// only \"equal\" if they coerce to a common target, like two different function items\n-    /// coercing to a function pointer if they have the same signature.\n-    fn strip_opaque(self, fcx: &FnCtxt<'a, 'tcx>) -> Self {\n-        match self {\n-            ExpectHasType(ty) => {\n-                let ty = fcx.resolve_vars_if_possible(ty);\n-                match *ty.kind() {\n-                    ty::Opaque(def_id, _)\n-                        if fcx.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() =>\n-                    {\n-                        NoExpectation\n-                    }\n-                    _ => self,\n-                }\n-            }\n-            _ => self,\n-        }\n-    }\n-\n     /// Like `only_has_type`, but instead of returning `None` if no\n     /// hard constraint exists, creates a fresh type variable.\n     pub(super) fn coercion_target_type(self, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> Ty<'tcx> {"}, {"sha": "0347b6a4ab82f7da77d9b7c719e3661ba7d3fd3f", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -956,7 +956,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             let else_diverges = self.diverges.get();\n \n-            let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);\n+            let opt_suggest_box_span =\n+                self.opt_suggest_box_span(else_expr.span, else_ty, orig_expected);\n             let if_cause =\n                 self.if_cause(sp, then_expr, else_expr, then_ty, else_ty, opt_suggest_box_span);\n "}, {"sha": "e5da33d113e7c48e95ab6e626d4e0dc8ff0711f8", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n-        // Check if we have any unsolved variables. If not, no need for fallback.\n+        // Check if we have any unsolved varibales. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n             return false;\n@@ -66,6 +66,16 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // refer to opaque types.\n         self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n+        // We now run fallback again, but this time we allow it to replace\n+        // unconstrained opaque type variables, in addition to performing\n+        // other kinds of fallback.\n+        for ty in &self.unsolved_variables() {\n+            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n+        }\n+\n+        // See if we can make any more progress.\n+        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n         fallback_has_occurred\n     }\n \n@@ -126,6 +136,59 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n+    /// Second round of fallback: Unconstrained type variables created\n+    /// from the instantiation of an opaque type fall back to the\n+    /// opaque type itself. This is a somewhat incomplete attempt to\n+    /// manage \"identity passthrough\" for `impl Trait` types.\n+    ///\n+    /// For example, in this code:\n+    ///\n+    ///```\n+    /// type MyType = impl Copy;\n+    /// fn defining_use() -> MyType { true }\n+    /// fn other_use() -> MyType { defining_use() }\n+    /// ```\n+    ///\n+    /// `defining_use` will constrain the instantiated inference\n+    /// variable to `bool`, while `other_use` will constrain\n+    /// the instantiated inference variable to `MyType`.\n+    ///\n+    /// When we process opaque types during writeback, we\n+    /// will handle cases like `other_use`, and not count\n+    /// them as defining usages\n+    ///\n+    /// However, we also need to handle cases like this:\n+    ///\n+    /// ```rust\n+    /// pub type Foo = impl Copy;\n+    /// fn produce() -> Option<Foo> {\n+    ///     None\n+    ///  }\n+    ///  ```\n+    ///\n+    /// In the above snippet, the inference variable created by\n+    /// instantiating `Option<Foo>` will be completely unconstrained.\n+    /// We treat this as a non-defining use by making the inference\n+    /// variable fall back to the opaque type itself.\n+    fn fallback_opaque_type_vars(&self, ty: Ty<'tcx>) -> bool {\n+        let span = self\n+            .infcx\n+            .type_var_origin(ty)\n+            .map(|origin| origin.span)\n+            .unwrap_or(rustc_span::DUMMY_SP);\n+        let oty = self.inner.borrow().opaque_types_vars.get(ty).copied();\n+        if let Some(opaque_ty) = oty {\n+            debug!(\n+                \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\",\n+                ty, opaque_ty\n+            );\n+            self.demand_eqtype(span, ty, opaque_ty);\n+            true\n+        } else {\n+            return false;\n+        }\n+    }\n+\n     /// The \"diverging fallback\" system is rather complicated. This is\n     /// a result of our need to balance 'do the right thing' with\n     /// backwards compatibility."}, {"sha": "0f9803b969fb74521feef9aefcbfe1b950845721", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -367,6 +367,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (result, spans)\n     }\n \n+    /// Replaces the opaque types from the given value with type variables,\n+    /// and records the `OpaqueTypeMap` for later use during writeback. See\n+    /// `InferCtxt::instantiate_opaque_types` for more details.\n+    #[instrument(skip(self, value_span), level = \"debug\")]\n+    pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n+        &self,\n+        value: T,\n+        value_span: Span,\n+    ) -> T {\n+        self.register_infer_ok_obligations(self.instantiate_opaque_types(\n+            self.body_id,\n+            self.param_env,\n+            value,\n+            value_span,\n+        ))\n+    }\n+\n     /// Convenience method which tracks extra diagnostic information for normalization\n     /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n     /// whose type is being wf-checked - this is used to construct a more precise span if\n@@ -703,7 +720,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // inference variable.\n                     ty::PredicateKind::ClosureKind(..) => None,\n                     ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-                    ty::PredicateKind::OpaqueType(..) => None,\n                 }\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))"}, {"sha": "3a81af03162862f8c8d99024fd92681fd8cb7acb", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -57,6 +57,8 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n+    pub(super) ret_coercion_impl_trait: Option<Ty<'tcx>>,\n+\n     pub(super) ret_type_span: Option<Span>,\n \n     /// Used exclusively to reduce cost of advanced evaluation used for\n@@ -128,6 +130,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n+            ret_coercion_impl_trait: None,\n             ret_type_span: None,\n             in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),"}, {"sha": "beb6b371b2bb8de1dba246009a5569c74f96a412", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -95,13 +95,6 @@ impl<'tcx> InheritedBuilder<'tcx> {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n-\n-    /// WF-checking doesn't need to recompute opaque types and can instead use\n-    /// the type_of query to get them from typeck.\n-    pub fn reveal_defining_opaque_types(mut self) -> Self {\n-        self.infcx = self.infcx.reveal_defining_opaque_types();\n-        self\n-    }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n@@ -126,8 +119,8 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n+        debug!(\"register_predicate({:?})\", obligation);\n         if obligation.has_escaping_bound_vars() {\n             span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n         }"}, {"sha": "cd1c0980a5521c8f3c11fa56b4e59867de652d9f", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -856,7 +856,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::TypeOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });\n@@ -1476,7 +1475,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n-                    .define_opaque_types(false)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n@@ -1506,7 +1504,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // First check that the self type can be related.\n             let sub_obligations = match self\n                 .at(&ObligationCause::dummy(), self.param_env)\n-                .define_opaque_types(false)\n                 .sup(probe.xform_self_ty, self_ty)\n             {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n@@ -1654,7 +1651,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     );\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n-                        .define_opaque_types(false)\n                         .sup(return_ty, xform_ret_ty)\n                         .is_err()\n                     {"}, {"sha": "6e0b902a00bda1014c19a4f0771d17fee2a9e0a2", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -341,7 +341,6 @@ fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::T\n     typeck_with_fallback(tcx, def_id, fallback)\n }\n \n-#[instrument(skip(tcx, fallback))]\n fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,"}, {"sha": "becae6c9dc920ad7ee67dcdcf406cebc18326b36", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -335,6 +335,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     // Returns a list of `Ty`s for each upvar.\n     fn final_upvar_tys(&self, closure_id: DefId) -> Vec<Ty<'tcx>> {\n+        // Presently an unboxed closure type cannot \"escape\" out of a\n+        // function, so we will only encounter ones that originated in the\n+        // local crate or were inlined into it along with some function.\n+        // This may change if abstract return types of some sort are\n+        // implemented.\n         self.typeck_results\n             .borrow()\n             .closure_min_captures_flattened(closure_id)"}, {"sha": "71f45320e49520192185a5a885662a2c8a09e4bf", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -895,7 +895,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n \n fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n     CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id).reveal_defining_opaque_types(),\n+        inherited: Inherited::build(tcx, def_id),\n         id: hir::HirId::make_owner(def_id),\n         span,\n         param_env: tcx.param_env(def_id),"}, {"sha": "ec88bdf4a370f8a8508d9da6f24e7e827aebdbeb", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -18,6 +18,7 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use std::mem;\n \n@@ -64,7 +65,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_opaque_types();\n+        wbcx.visit_opaque_types(body.value.span);\n         wbcx.visit_coercion_casts();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n@@ -495,18 +496,64 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.generator_interior_types.clone();\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n-    fn visit_opaque_types(&mut self) {\n-        let opaque_types =\n-            self.fcx.infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        for (opaque_type_key, decl) in opaque_types {\n-            let hidden_type = match decl.origin {\n-                hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_) => {\n-                    Some(self.resolve(decl.hidden_type.ty, &decl.hidden_type.span))\n+    #[instrument(skip(self, span), level = \"debug\")]\n+    fn visit_opaque_types(&mut self, span: Span) {\n+        let opaque_types = self.fcx.infcx.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_defn) in opaque_types {\n+            let hir_id =\n+                self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n+            let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n+\n+            debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n+\n+            let opaque_type_key = self.fcx.fully_resolve(opaque_type_key).unwrap();\n+\n+            // Prevent:\n+            // * `fn foo<T>() -> Foo<T>`\n+            // * `fn foo<T: Bound + Other>() -> Foo<T>`\n+            // from being defining.\n+\n+            // Also replace all generic params with the ones from the opaque type\n+            // definition so that\n+            // ```rust\n+            // type Foo<T> = impl Baz + 'static;\n+            // fn foo<U>() -> Foo<U> { .. }\n+            // ```\n+            // figures out the concrete type with `U`, but the stored type is with `T`.\n+\n+            // FIXME: why are we calling this here? This seems too early, and duplicated.\n+            let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n+                opaque_type_key,\n+                instantiated_ty,\n+                span,\n+            );\n+\n+            let mut skip_add = false;\n+\n+            if let ty::Opaque(definition_ty_def_id, _substs) = *definition_ty.kind() {\n+                if opaque_defn.origin == hir::OpaqueTyOrigin::TyAlias {\n+                    if opaque_type_key.def_id == definition_ty_def_id {\n+                        debug!(\n+                            \"skipping adding concrete definition for opaque type {:?} {:?}\",\n+                            opaque_defn, opaque_type_key.def_id\n+                        );\n+                        skip_add = true;\n+                    }\n                 }\n-                hir::OpaqueTyOrigin::TyAlias => None,\n-            };\n-            self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n+            }\n+\n+            if opaque_type_key.substs.needs_infer() {\n+                span_bug!(span, \"{:#?} has inference variables\", opaque_type_key.substs)\n+            }\n+\n+            // We only want to add an entry into `concrete_opaque_types`\n+            // if we actually found a defining usage of this opaque type.\n+            // Otherwise, we do nothing - we'll either find a defining usage\n+            // in some other location, or we'll end up emitting an error due\n+            // to the lack of defining usage\n+            if !skip_add {\n+                self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id);\n+            }\n         }\n     }\n "}, {"sha": "5cb0d309ff4ee020073f606b143ecaf103f37844", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -389,22 +389,28 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n                         .copied()\n                         .unwrap_or_else(|| {\n-                            let table = tcx.typeck(owner);\n-                            if let Some(ErrorReported) = table.tainted_by_errors {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n+                                    owner, def_id,\n+                                ),\n+                            );\n+                            if let Some(ErrorReported) =\n+                                tcx.typeck(owner).tainted_by_errors\n+                            {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n                                 // the `concrete_opaque_types` table.\n                                 tcx.ty_error()\n                             } else {\n-                                table.concrete_opaque_types.get(&def_id.to_def_id()).copied().unwrap_or_else(|| {\n-                                    // We failed to resolve the opaque type or it\n-                                    // resolves to itself. We interpret this as the\n-                                    // no values of the hidden type ever being constructed,\n-                                    // so we can just make the hidden type be `!`.\n-                                    // For backwards compatibility reasons, we fall back to\n-                                    // `()` until we the diverging default is changed.\n-                                    Some(tcx.mk_diverging_default())\n-                                }).expect(\"RPIT always have a hidden type from typeck\")\n+                                // We failed to resolve the opaque type or it\n+                                // resolves to itself. Return the non-revealed\n+                                // type, which should result in E0720.\n+                                tcx.mk_opaque(\n+                                    def_id.to_def_id(),\n+                                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+                                )\n                             }\n                         });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n@@ -598,21 +604,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            // ```rust\n-            // type Foo = impl Fn() -> usize; // when computing type for this\n-            // const fn bar() -> Foo {\n-            //     || 0usize\n-            // }\n-            // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n-            // // because we again need to reveal `Foo` so we can check whether the\n-            // // constant does not contain interior mutability.\n-            // ```\n-            let tables = self.tcx.typeck(def_id);\n-            if let Some(_) = tables.tainted_by_errors {\n-                self.found = Some((DUMMY_SP, self.tcx.ty_error()));\n-                return;\n-            }\n-            if tables.concrete_opaque_types.get(&self.def_id).is_none() {\n+            if !self.tcx.typeck(def_id).concrete_opaque_types.contains(&self.def_id) {\n                 debug!(\"no constraints in typeck results\");\n                 return;\n             }\n@@ -666,23 +658,23 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             self.check(it.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -692,12 +684,12 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n-    debug!(?scope);\n+    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n \n     if scope == hir::CRATE_HIR_ID {\n         tcx.hir().walk_toplevel_module(&mut locator);\n     } else {\n-        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n+        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n             // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n             // This allows our visitor to process the defining item itself, causing\n@@ -724,12 +716,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         Some((_, ty)) => ty,\n         None => {\n             let span = tcx.def_span(def_id);\n-            let name = tcx.item_name(tcx.parent(def_id.to_def_id()).unwrap());\n-            let label = format!(\n-                \"`{}` must be used in combination with a concrete type within the same module\",\n-                name\n-            );\n-            tcx.sess.struct_span_err(span, \"unconstrained opaque type\").note(&label).emit();\n+            tcx.sess.span_err(span, \"could not find defining uses\");\n             tcx.ty_error()\n         }\n     }"}, {"sha": "d87e670a8fb5a7bf912ea64031a9b1a5d70e4944", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -427,7 +427,6 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n-        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "bbf31de527eb3fb7205507ee6707981b3ec8859f", "filename": "compiler/rustc_typeck/src/outlives/explicit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -59,7 +59,6 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }"}, {"sha": "7105a2457e282329ebee43f59d269ffcd50bc635", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -147,12 +147,6 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n \n-    if let Ok(flags) = env::var(\"MAGIC_EXTRA_RUSTFLAGS\") {\n-        for flag in flags.split(' ') {\n-            cmd.arg(flag);\n-        }\n-    }\n-\n     let is_test = args.iter().any(|a| a == \"--test\");\n     if verbose > 2 {\n         let rust_env_vars ="}, {"sha": "f54fb4af26133a8f19389e4369ddb7117186d8d4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -297,7 +297,6 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n         }\n     }"}, {"sha": "4124eada188e862e990fc5e3d930c084ba8855c0", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -305,7 +305,7 @@ pub fn return_impl_trait() -> i32        {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[rustc_clean(cfg = \"cfail5\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail6\")]"}, {"sha": "4c36289f47b857ac0e5c50ae4fa9df26d9dc7863", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -30,7 +30,7 @@ impl Thing for AssocNoCopy {\n     type Out = Box<dyn Bar<Assoc: Copy>>;\n \n     fn func() -> Self::Out {\n-        Box::new(AssocNoCopy)\n         //~^ ERROR the trait bound `String: Copy` is not satisfied\n+        Box::new(AssocNoCopy)\n     }\n }"}, {"sha": "a32ab453152a0b4663c06788b189aaba8cd23431", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `String: Copy` is not satisfied\n-  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:33:9\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:32:18\n    |\n-LL |         Box::new(AssocNoCopy)\n-   |         ^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<Assoc = <AssocNoCopy as Thing>::Out::{opaque#0}>`\n+LL |     fn func() -> Self::Out {\n+   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `String`\n \n error: aborting due to previous error\n "}, {"sha": "5f994f26534bdeefb3a3a329cf547226d066b19d", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -23,8 +23,8 @@ fn bar() -> impl Bar {\n }\n \n fn baz() -> impl Bar<Item = i32> {\n+//~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n     bar()\n-    //~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n }\n \n fn main() {"}, {"sha": "283ecea735d4156209b9f2b22614e9262fc451db", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,16 +1,14 @@\n error[E0271]: type mismatch resolving `<impl Bar as Foo>::Item == i32`\n-  --> $DIR/impl-trait-return-missing-constraint.rs:26:5\n+  --> $DIR/impl-trait-return-missing-constraint.rs:25:13\n    |\n LL | fn bar() -> impl Bar {\n-   |             -------- the expected opaque type\n+   |             -------- the found opaque type\n ...\n-LL |     bar()\n-   |     ^^^^^ expected associated type, found `i32`\n+LL | fn baz() -> impl Bar<Item = i32> {\n+   |             ^^^^^^^^^^^^^^^^^^^^ expected `i32`, found associated type\n    |\n-   = note: expected associated type `<impl Bar as Foo>::Item`\n-                         found type `i32`\n-   = help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32` or calling a method that returns `<impl Bar as Foo>::Item`\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+   = note:         expected type `i32`\n+           found associated type `<impl Bar as Foo>::Item`\n help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32`\n    |\n LL | fn bar() -> impl Bar<Item = i32> {"}, {"sha": "44d60c1d80d881310f01d900ba00a075910bd06b", "filename": "src/test/ui/async-await/async-borrowck-escaping-block-error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,10 +8,10 @@ LL |     Box::new(async { x } )\n    |                    may outlive borrowed value `x`\n    |\n note: async block is returned here\n-  --> $DIR/async-borrowck-escaping-block-error.rs:6:5\n+  --> $DIR/async-borrowck-escaping-block-error.rs:4:20\n    |\n-LL |     Box::new(async { x } )\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn test_boxed() -> Box<impl std::future::Future<Output = u32>> {\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to force the async block to take ownership of `x` (and any other referenced variables), use the `move` keyword\n    |\n LL |     Box::new(async move { x } )"}, {"sha": "2538f34351e5a51fab1fc4432a1445861b08202c", "filename": "src/test/ui/async-await/issue-64130-4-async-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -13,9 +13,9 @@ impl Client {\n async fn get() { }\n \n pub fn foo() -> impl Future + Send {\n+    //~^ ERROR future cannot be sent between threads safely\n     let client = Client(Box::new(true));\n     async move {\n-        //~^ ERROR future cannot be sent between threads safely\n         match client.status() {\n             200 => {\n                 let _x = get().await;"}, {"sha": "d631e6dc7f7e968aa80446b2791fbe7114d8a7fb", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-64130-4-async-move.rs:17:5\n+  --> $DIR/issue-64130-4-async-move.rs:15:17\n    |\n-LL |     async move {\n-   |     ^^^^^^^^^^ future created by async block is not `Send`\n+LL | pub fn foo() -> impl Future + Send {\n+   |                 ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `(dyn Any + Send + 'static)`\n note: future is not `Send` as this value is used across an await"}, {"sha": "0609e4fc0817073f0782d9d0ed5b748f51561c54", "filename": "src/test/ui/async-await/issue-70818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,8 +2,8 @@\n \n use std::future::Future;\n fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n+//~^ Error future cannot be sent between threads safely\n     async { (ty, ty1) }\n-    //~^ Error future cannot be sent between threads safely\n }\n \n fn main() {}"}, {"sha": "20109d4d1166a0e3331d4289ef60d2628ae1b1d9", "filename": "src/test/ui/async-await/issue-70818.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,11 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70818.rs:5:5\n+  --> $DIR/issue-70818.rs:4:38\n    |\n-LL |     async { (ty, ty1) }\n-   |     ^^^^^ future created by async block is not `Send`\n+LL | fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n note: captured value is not `Send`\n-  --> $DIR/issue-70818.rs:5:18\n+  --> $DIR/issue-70818.rs:6:18\n    |\n LL |     async { (ty, ty1) }\n    |                  ^^^ has type `U` which is not `Send`"}, {"sha": "2965a7e0654a4edb39d33d962c1c889116ee1d4c", "filename": "src/test/ui/async-await/issue-70935-complex-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,8 +8,8 @@ async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n }\n \n fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n+    //~^ ERROR: future cannot be sent between threads safely\n     async move {\n-        //~^ ERROR: future cannot be sent between threads safely\n         baz(|| async{\n             foo(tx.clone());\n         }).await;"}, {"sha": "db3099381196b771692e3f1b29677d201c77aea1", "filename": "src/test/ui/async-await/issue-70935-complex-spans.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70935-complex-spans.rs:11:5\n+  --> $DIR/issue-70935-complex-spans.rs:10:45\n    |\n-LL |     async move {\n-   |     ^^^^^^^^^^ future created by async block is not `Send`\n+LL | fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n+   |                                             ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `Sender<i32>`\n note: future is not `Send` as this value is used across an await"}, {"sha": "2722c72c20a339a485453316d57e3382d39f4f7d", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.nll.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -14,16 +14,12 @@ LL | | }\n    = help: consider adding the following bound: `'a: 'b`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ret-impl-trait-one.rs:16:80\n+  --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n-LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |  ____________________________________--__________________________________________^\n-   | |                                    |\n-   | |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n-LL | |\n-LL | |     (a, b)\n-LL | | }\n-   | |_^\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |                                    --                           ^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "149692a2c6998e29981b192df521a48fa354c480", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,26 +1,19 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ret-impl-trait-one.rs:10:85\n+  --> $DIR/ret-impl-trait-one.rs:10:65\n    |\n-LL |   async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n-   |  ______________________________________________________------_____-------------------_^\n-   | |                                                      |\n-   | |                                                      this parameter and the return type are declared with different lifetimes...\n-LL | |\n-LL | |     (a, b)\n-LL | | }\n-   | |_^ ...but data from `a` is returned here\n+LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n+   |                                                      |          |\n+   |                                                      |          ...but data from `a` is returned here\n+   |                                                      this parameter and the return type are declared with different lifetimes...\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ret-impl-trait-one.rs:16:80\n+  --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n-LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |  ____________________________________--__________________________________________^\n-   | |                                    |\n-   | |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n-LL | |\n-LL | |     (a, b)\n-LL | | }\n-   | |_^\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |                                    --                           ^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "b3c59734e036f7b0a57b729d99c3cd6f3026cc75", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,4 +3,3 @@\n \n pub const async fn x() {}\n //~^ ERROR functions cannot be both `const` and `async`\n-//~| ERROR cycle detected"}, {"sha": "90ec646c8c09cbb6a8e9477fdbb830e8ee313f6e", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -7,36 +7,5 @@ LL | pub const async fn x() {}\n    |     |     `async` because of this\n    |     `const` because of this\n \n-error[E0391]: cycle detected when computing type of `x::{opaque#0}`\n-  --> $DIR/no-const-async.rs:4:24\n-   |\n-LL | pub const async fn x() {}\n-   |                        ^\n-   |\n-note: ...which requires borrow-checking `x`...\n-  --> $DIR/no-const-async.rs:4:1\n-   |\n-LL | pub const async fn x() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `x`...\n-  --> $DIR/no-const-async.rs:4:1\n-   |\n-LL | pub const async fn x() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const checking `x`...\n-  --> $DIR/no-const-async.rs:4:1\n-   |\n-LL | pub const async fn x() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n-   = note: ...which again requires computing type of `x::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/no-const-async.rs:4:1\n-   |\n-LL | pub const async fn x() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "aa7733194587da20ba4238a02da39f729f0445a0", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,8 +2,7 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden when using `async` and `await`.\n \n-async fn recursive_async_function() -> () {\n-    //~^ ERROR recursion in an `async fn` requires boxing\n+async fn recursive_async_function() -> () { //~ ERROR\n     recursive_async_function().await;\n }\n "}, {"sha": "c7c5b51e7334b87b27e40534c5541d9e7044b960", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -21,6 +21,7 @@ async fn dummy() {}\n async fn suggest_await_in_async_fn_return() {\n     dummy()\n     //~^ ERROR mismatched types [E0308]\n+    //~| HELP consider using a semicolon here\n     //~| HELP consider `await`ing on the `Future`\n     //~| SUGGESTION .await\n }"}, {"sha": "3cca9616a358a34d7489d0efbd75aca2c185c2ba", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -33,9 +33,13 @@ help: consider `await`ing on the `Future`\n    |\n LL |     dummy().await\n    |            ++++++\n+help: consider using a semicolon here\n+   |\n+LL |     dummy();\n+   |            +\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/suggest-missing-await.rs:34:9\n+  --> $DIR/suggest-missing-await.rs:35:9\n    |\n LL |       let _x = if true {\n    |  ______________-\n@@ -49,20 +53,15 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:18:18\n-   |\n-LL | async fn dummy() {}\n-   |                  ^ checked the `Output` of this `async fn`, expected opaque type\n-   = note: expected opaque type `impl Future<Output = ()>`\n-                found unit type `()`\n+   = note:   expected type `impl Future<Output = ()>`\n+           found unit type `()`\n help: consider `await`ing on the `Future`\n    |\n LL |         dummy().await\n    |                ++++++\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/suggest-missing-await.rs:44:14\n+  --> $DIR/suggest-missing-await.rs:45:14\n    |\n LL |       let _x = match 0usize {\n    |  ______________-\n@@ -90,7 +89,7 @@ LL ~         1 => dummy().await,\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:52:9\n+  --> $DIR/suggest-missing-await.rs:53:9\n    |\n LL |         () => {}\n    |         ^^ expected opaque type, found `()`\n@@ -108,13 +107,13 @@ LL |     let _x = match dummy().await {\n    |                           ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:66:9\n+  --> $DIR/suggest-missing-await.rs:67:9\n    |\n LL |         Ok(_) => {}\n    |         ^^^^^ expected opaque type, found enum `Result`\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:56:28\n+  --> $DIR/suggest-missing-await.rs:57:28\n    |\n LL | async fn dummy_result() -> Result<(), ()> {\n    |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n@@ -126,13 +125,13 @@ LL |     match dummy_result().await {\n    |                         ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:68:9\n+  --> $DIR/suggest-missing-await.rs:69:9\n    |\n LL |         Err(_) => {}\n    |         ^^^^^^ expected opaque type, found enum `Result`\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:56:28\n+  --> $DIR/suggest-missing-await.rs:57:28\n    |\n LL | async fn dummy_result() -> Result<(), ()> {\n    |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type"}, {"sha": "d4a0f9613055ee5abf87eccec3fffe4df7a0dff1", "filename": "src/test/ui/cast/casts-differing-anon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     // this is an `*mut fmt::Debug` in practice\n     let mut b_raw = Box::into_raw(b);\n     // ... and they should not be mixable\n-    b_raw = f_raw as *mut _; //~ ERROR mismatched types\n+    b_raw = f_raw as *mut _; //~ ERROR is invalid\n }"}, {"sha": "f9abfb5225f91c3f5b1fd693f14c6cb245887fed", "filename": "src/test/ui/cast/casts-differing-anon.stderr", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,19 +1,11 @@\n-error[E0308]: mismatched types\n+error[E0606]: casting `*mut impl Debug + ?Sized` as `*mut impl Debug + ?Sized` is invalid\n   --> $DIR/casts-differing-anon.rs:21:13\n    |\n-LL | fn foo() -> Box<impl fmt::Debug+?Sized> {\n-   |                 ---------------------- the found opaque type\n-...\n-LL | fn bar() -> Box<impl fmt::Debug+?Sized> {\n-   |                 ---------------------- the expected opaque type\n-...\n LL |     b_raw = f_raw as *mut _;\n-   |             ^^^^^ expected opaque type, found a different opaque type\n+   |             ^^^^^^^^^^^^^^^\n    |\n-   = note: expected opaque type `impl Debug + ?Sized` (opaque type at <$DIR/casts-differing-anon.rs:7:17>)\n-              found opaque type `impl Debug + ?Sized` (opaque type at <$DIR/casts-differing-anon.rs:3:17>)\n-   = note: distinct uses of `impl Trait` result in different opaque types\n+   = note: vtable kinds may not match\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0606`."}, {"sha": "bb00465758a4599de8d716969bf2a334989e8e5c", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/borrowck/borrowck-4.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,10 +8,10 @@ LL |        println!(\"{:?}\", p);\n    |                         - `p` is borrowed here\n    |\n note: closure is returned here\n-  --> $DIR/borrowck-4.rs:15:5\n+  --> $DIR/borrowck-4.rs:8:14\n    |\n-LL |     c\n-   |     ^\n+LL | fn foo () -> impl FnMut()->() {\n+   |              ^^^^^^^^^^^^^^^^\n help: to force the closure to take ownership of `p` (and any other referenced variables), use the `move` keyword\n    |\n LL |     let mut c = move || {"}, {"sha": "63a4df242f85f9897247a8b24d4101dd16eaeb35", "filename": "src/test/ui/conservative_impl_trait.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,8 @@\n error[E0277]: `()` is not an iterator\n-  --> $DIR/conservative_impl_trait.rs:3:60\n+  --> $DIR/conservative_impl_trait.rs:3:33\n    |\n-LL |   fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n-   |  ____________________________________________________________^\n-LL | |\n-LL | | }\n-   | |_^ `()` is not an iterator\n+LL | fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `()`\n "}, {"sha": "308c121a94111ad86386d09611be0325e5fede06", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,8 +4,8 @@ trait Trait {}\n impl<const N: u32> Trait for Uwu<N> {}\n \n fn rawr() -> impl Trait {\n-    Uwu::<10, 12>\n     //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n+    Uwu::<10, 12>\n }\n \n trait Traitor<const N: u8 = 1, const M: u8 = N> { }\n@@ -15,13 +15,13 @@ impl Traitor<1, 2> for u64 {}\n \n \n fn uwu<const N: u8>() -> impl Traitor<N> {\n-    1_u32\n     //~^ error: the trait bound `u32: Traitor<N, N>` is not satisfied\n+    1_u32\n }\n \n fn owo() -> impl Traitor {\n-    1_u64\n     //~^ error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n+    1_u64\n }\n \n fn main() {"}, {"sha": "8c8bfdc0e4847a82fb8c79c164ff78af1ed60cc8", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,26 +1,26 @@\n error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:7:5\n+  --> $DIR/rp_impl_trait_fail.rs:6:14\n    |\n-LL |     Uwu::<10, 12>\n-   |     ^^^^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n+LL | fn rawr() -> impl Trait {\n+   |              ^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n    |\n    = help: the following implementations were found:\n              <Uwu<N> as Trait>\n \n error[E0277]: the trait bound `u32: Traitor<N, N>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:18:5\n+  --> $DIR/rp_impl_trait_fail.rs:17:26\n    |\n-LL |     1_u32\n-   |     ^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n+LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n+   |                          ^^^^^^^^^^^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n    |\n    = help: the following implementations were found:\n              <u32 as Traitor<N, 2_u8>>\n \n error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:23:5\n+  --> $DIR/rp_impl_trait_fail.rs:22:13\n    |\n-LL |     1_u64\n-   |     ^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n+LL | fn owo() -> impl Traitor {\n+   |             ^^^^^^^^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n    |\n    = help: the following implementations were found:\n              <u64 as Traitor<1_u8, 2_u8>>"}, {"sha": "e0bb7dbfae9f1f793113f91a5ea60b519adfa496", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,9 +4,11 @@\n //~^^^ ERROR `main` function not found in crate\n pub mod foo {\n     type MainFn = impl Fn();\n+    //~^ ERROR could not find defining uses\n \n     fn bar() {}\n     pub const BAR: MainFn = bar;\n+    //~^ ERROR mismatched types [E0308]\n }\n \n use foo::BAR as main;"}, {"sha": "c731c32832222f7d480fadea359dd2a641920362", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.stderr", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -12,6 +12,25 @@ LL | | use foo::BAR as main;\n    |       |\n    |       non-function item at `crate::main` is found\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:10:29\n+   |\n+LL |     type MainFn = impl Fn();\n+   |                   --------- the expected opaque type\n+...\n+LL |     pub const BAR: MainFn = bar;\n+   |                             ^^^ expected opaque type, found fn item\n+   |\n+   = note: expected opaque type `impl Fn()`\n+                  found fn item `fn() {bar}`\n+\n+error: could not find defining uses\n+  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:6:19\n+   |\n+LL |     type MainFn = impl Fn();\n+   |                   ^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0601`.\n+Some errors have detailed explanations: E0308, E0601.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "ea82837d4bf55364de91c9d446cbe7fcacfbae4c", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,13 +1,13 @@\n // ignore-compare-mode-chalk\n-// check-pass\n #![feature(type_alias_impl_trait)]\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n+//~^ ERROR could not find defining uses\n \n struct Bar(Foo);\n fn define() -> Bar {\n-    Bar(42)\n+    Bar(42) //~ ERROR mismatched types\n }\n \n type Foo2 = impl Debug;\n@@ -17,18 +17,21 @@ fn define2() {\n }\n \n type Foo3 = impl Debug;\n+//~^ ERROR could not find defining uses\n \n fn define3(x: Foo3) {\n-    let y: i32 = x;\n+    let y: i32 = x; //~ ERROR mismatched types\n }\n fn define3_1() {\n-    define3(42)\n+    define3(42) //~ ERROR mismatched types\n }\n \n type Foo4 = impl Debug;\n+//~^ ERROR could not find defining uses\n \n fn define4() {\n     let y: Foo4 = 42;\n+    //~^ ERROR mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "da3ddb1c50979f852528bc26518b9b028dd54c88", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,73 @@\n+error[E0308]: mismatched types\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:10:9\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the expected opaque type\n+...\n+LL |     Bar(42)\n+   |         ^^ expected opaque type, found integer\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:23:18\n+   |\n+LL | type Foo3 = impl Debug;\n+   |             ---------- the found opaque type\n+...\n+LL |     let y: i32 = x;\n+   |            ---   ^ expected `i32`, found opaque type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:     expected type `i32`\n+           found opaque type `impl Debug`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:26:13\n+   |\n+LL | type Foo3 = impl Debug;\n+   |             ---------- the expected opaque type\n+...\n+LL |     define3(42)\n+   |             ^^ expected opaque type, found integer\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:33:19\n+   |\n+LL | type Foo4 = impl Debug;\n+   |             ---------- the expected opaque type\n+...\n+LL |     let y: Foo4 = 42;\n+   |            ----   ^^ expected opaque type, found integer\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `{integer}`\n+\n+error: could not find defining uses\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:5:12\n+   |\n+LL | type Foo = impl Debug;\n+   |            ^^^^^^^^^^\n+\n+error: could not find defining uses\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:19:13\n+   |\n+LL | type Foo3 = impl Debug;\n+   |             ^^^^^^^^^^\n+\n+error: could not find defining uses\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:29:13\n+   |\n+LL | type Foo4 = impl Debug;\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ce9159b53e0f0a5b147e1e5f87df731e217e10ef", "filename": "src/test/ui/generator/issue-88653.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,10 +6,10 @@\n use std::ops::Generator;\n \n fn foo(bar: bool) -> impl Generator<(bool,)> {\n+//~^ ERROR: type mismatch in generator arguments [E0631]\n+//~| NOTE: expected signature of `fn((bool,)) -> _`\n     |bar| {\n     //~^ NOTE: found signature of `fn(bool) -> _`\n-    //~| ERROR: type mismatch in generator arguments [E0631]\n-    //~| NOTE: expected signature of `fn((bool,)) -> _`\n         if bar {\n             yield bar;\n         }"}, {"sha": "5bd8ad129fef908d874662b5f04500e772afe288", "filename": "src/test/ui/generator/issue-88653.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,11 @@\n error[E0631]: type mismatch in generator arguments\n-  --> $DIR/issue-88653.rs:9:5\n+  --> $DIR/issue-88653.rs:8:22\n    |\n+LL | fn foo(bar: bool) -> impl Generator<(bool,)> {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn((bool,)) -> _`\n+...\n LL |     |bar| {\n-   |     ^^^^^\n-   |     |\n-   |     expected signature of `fn((bool,)) -> _`\n-   |     found signature of `fn(bool) -> _`\n+   |     ----- found signature of `fn(bool) -> _`\n \n error: aborting due to previous error\n "}, {"sha": "7774ff48f56b730b7bdc028dccf03771e07cee1e", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,8 +2,8 @@\n \n use std::ops::Generator;\n \n-fn foo() -> impl Generator<Return = i32> {\n-    || { //~ ERROR type mismatch\n+fn foo() -> impl Generator<Return = i32> { //~ ERROR type mismatch\n+    || {\n         if false {\n             return Ok(6);\n         }"}, {"sha": "3f1f33a3b123f40361e4d54bcbc01667e044a307", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -13,19 +13,13 @@ LL |             return Ok(6);\n    |                    ^^^^^\n \n error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6] as Generator>::Return == i32`\n-  --> $DIR/type-mismatch-signature-deduction.rs:6:5\n+  --> $DIR/type-mismatch-signature-deduction.rs:5:13\n    |\n-LL | /     || {\n-LL | |         if false {\n-LL | |             return Ok(6);\n-LL | |         }\n-...  |\n-LL | |         5\n-LL | |     }\n-   | |_____^ expected enum `Result`, found `i32`\n+LL | fn foo() -> impl Generator<Return = i32> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found enum `Result`\n    |\n-   = note: expected enum `Result<{integer}, _>`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found enum `Result<{integer}, _>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d9d17751fa6e25bdbb696e22945f49d987cc723c", "filename": "src/test/ui/generic-associated-types/issue-87258_a.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -16,8 +16,7 @@ pub trait Trait2 {\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = impl Trait1;\n-    //~^ ERROR unconstrained opaque type\n-    fn foo<'a>() -> Self::FooFuture<'a> {\n+    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "93513a4563f0701ce01eea50ff8a77c2bb040899", "filename": "src/test/ui/generic-associated-types/issue-87258_a.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,11 @@\n-error: unconstrained opaque type\n-  --> $DIR/issue-87258_a.rs:18:26\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/issue-87258_a.rs:19:21\n    |\n-LL |     type FooFuture<'a> = impl Trait1;\n-   |                          ^^^^^^^^^^^\n+LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n+   |                     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `FooFuture` must be used in combination with a concrete type within the same module\n+   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "b29a978f517fffdf9e22dbd01c9daa6beb721f2e", "filename": "src/test/ui/generic-associated-types/issue-87258_b.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -15,11 +15,10 @@ pub trait Trait2 {\n }\n \n type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n-//~^ ERROR unconstrained opaque type\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = Helper<'c, 'a, S>;\n-    fn foo<'a>() -> Self::FooFuture<'a> {\n+    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "e077a423400dfe74c9a035a0ecca4b8103d1d40d", "filename": "src/test/ui/generic-associated-types/issue-87258_b.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,11 @@\n-error: unconstrained opaque type\n-  --> $DIR/issue-87258_b.rs:17:49\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/issue-87258_b.rs:21:21\n    |\n-LL | type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n-   |                                                 ^^^^^^^^^^^\n+LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n+   |                     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `Helper` must be used in combination with a concrete type within the same module\n+   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "e397390783f66857560e8be8ad68f9dda875d229", "filename": "src/test/ui/generic-associated-types/issue-88595.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -18,6 +18,7 @@ struct C;\n impl<'a> A<'a> for C {\n     type B<'b> = impl Clone;\n     //~^ ERROR: lifetime bound not satisfied\n+    //~| ERROR: could not find defining uses\n \n     fn a(&'a self) -> Self::B<'a> {} //~ ERROR: non-defining opaque type use in defining scope\n }"}, {"sha": "cb462871ccd32b7ce26f81ece5e897455eef32b9", "filename": "src/test/ui/generic-associated-types/issue-88595.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -16,10 +16,10 @@ LL |     type B<'b> = impl Clone;\n    |            ^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-88595.rs:22:35\n+  --> $DIR/issue-88595.rs:23:23\n    |\n LL |     fn a(&'a self) -> Self::B<'a> {}\n-   |                                   ^^\n+   |                       ^^^^^^^^^^^\n    |\n note: lifetime used multiple times\n   --> $DIR/issue-88595.rs:18:6\n@@ -29,6 +29,12 @@ LL | impl<'a> A<'a> for C {\n LL |     type B<'b> = impl Clone;\n    |            ^^\n \n-error: aborting due to 2 previous errors\n+error: could not find defining uses\n+  --> $DIR/issue-88595.rs:19:18\n+   |\n+LL |     type B<'b> = impl Clone;\n+   |                  ^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0478`."}, {"sha": "72ade5774d749898fba7524c13e2a95cbcf6c42f", "filename": "src/test/ui/generic-associated-types/issue-92096.migrate.stderr", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,20 +1,18 @@\n error[E0311]: the parameter type `C` may not live long enough\n-  --> $DIR/issue-92096.rs:24:5\n+  --> $DIR/issue-92096.rs:20:33\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 - help: consider adding an explicit lifetime bound...: `C: 'a`\n-...\n-LL |     async move { c.connect().await }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |                 |\n+   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n \n error[E0311]: the parameter type `C` may not live long enough\n-  --> $DIR/issue-92096.rs:24:5\n+  --> $DIR/issue-92096.rs:20:33\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 - help: consider adding an explicit lifetime bound...: `C: 'a`\n-...\n-LL |     async move { c.connect().await }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |                 |\n+   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "066132a5d98bb8bea0323094eb2f72dcf672b3e2", "filename": "src/test/ui/generic-associated-types/issue-92096.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -18,12 +18,12 @@ trait Client {\n }\n \n fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n+//[migrate]~^ ERROR the parameter\n+//[migrate]~| ERROR the parameter\n where\n     C: Client + Send + Sync,\n {\n     async move { c.connect().await }\n-    //[migrate]~^ ERROR the parameter\n-    //[migrate]~| ERROR the parameter\n }\n \n fn main() {}"}, {"sha": "c2fbbf94fd66623678df17d392e4507993b2330e", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,7 +11,6 @@ fn main() {\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n     //~^ ERROR cycle detected\n-    //~| ERROR cycle detected\n     send(cycle2().clone());\n \n     Rc::new(Cell::new(5))"}, {"sha": "634ff14869eb4d371384f31a382a5d4b93a66005", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 15, "deletions": 97, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -30,129 +30,47 @@ note: ...which requires building MIR for `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires computing type of `cycle2::{opaque#0}`...\n-  --> $DIR/auto-trait-leak.rs:20:16\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   |                ^^^^^^^^^^\n-note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/auto-trait-leak.rs:1:1\n-   |\n-LL | / use std::cell::Cell;\n-LL | | use std::rc::Rc;\n-LL | |\n-LL | | fn send<T: Send>(_: T) {}\n-...  |\n-LL | |     Rc::new(String::from(\"foo\"))\n-LL | | }\n-   | |_^\n-\n-error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n-  --> $DIR/auto-trait-leak.rs:12:16\n+  --> $DIR/auto-trait-leak.rs:14:5\n    |\n-LL | fn cycle1() -> impl Clone {\n-   |                ^^^^^^^^^^\n-   |\n-note: ...which requires borrow-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     send(cycle2().clone());\n+   |     ^^^^\n+   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n note: ...which requires computing type of `cycle2::{opaque#0}`...\n-  --> $DIR/auto-trait-leak.rs:20:16\n+  --> $DIR/auto-trait-leak.rs:19:16\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n+  --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n+  --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n+  --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n+  --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n+  --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:1\n+  --> $DIR/auto-trait-leak.rs:20:5\n    |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     send(cycle1().clone());\n+   |     ^^^^\n+   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n    = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n@@ -166,6 +84,6 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "cf2773f4ef59dc921a6e919aab056bb13c89f94a", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -19,7 +19,7 @@ impl<T: Send> AnotherTrait for T {}\n // (We treat opaque types as \"foreign types\" that could grow more impls\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n }\n \n fn main() {}"}, {"sha": "26cd8fb6a9b5c44ecfab90bc567522a4b2a025f3", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,11 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n   --> $DIR/auto-trait.rs:21:1\n    |\n LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n \n error: aborting due to previous error\n "}, {"sha": "8ec06e534d14336bd569ab85a615539a542475b3", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -23,8 +23,8 @@ mod impl_trait {\n \n     /// `T::Assoc` can't be normalized any further here.\n     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n-        Foo(())\n         //~^ ERROR: type mismatch\n+        Foo(())\n     }\n }\n \n@@ -39,9 +39,9 @@ mod lifetimes {\n \n     /// Missing bound constraining `Assoc`, `T::Assoc` can't be normalized further.\n     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-        //~^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n-        Foo(())\n         //~^ ERROR: type mismatch\n+        //~^^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+        Foo(())\n     }\n }\n "}, {"sha": "afa21c1a858a2efe714f0a471403d0171b6834be", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,16 +1,16 @@\n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:26:9\n+  --> $DIR/bound-normalization-fail.rs:25:32\n    |\n-LL |         Foo(())\n-   |         ^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n+LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n    |\n-note: expected this to be `()`\n+note: expected this to be `<T as impl_trait::Trait>::Assoc`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note:    expected unit type `()`\n-           found associated type `<T as impl_trait::Trait>::Assoc`\n+   = note: expected associated type `<T as impl_trait::Trait>::Assoc`\n+                    found unit type `()`\n help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc` to `()`\n    |\n LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n@@ -23,18 +23,18 @@ LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:43:9\n+  --> $DIR/bound-normalization-fail.rs:41:41\n    |\n-LL |         Foo(())\n-   |         ^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n    |\n-note: expected this to be `()`\n+note: expected this to be `<T as lifetimes::Trait<'static>>::Assoc`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note:    expected unit type `()`\n-           found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n+   = note: expected associated type `<T as lifetimes::Trait<'static>>::Assoc`\n+                    found unit type `()`\n help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {"}, {"sha": "f4bd0fde3b6cbfe73efcf94692ea4e95b6002a67", "filename": "src/test/ui/impl-trait/does-not-live-long-enough.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -7,10 +7,10 @@ LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref\n    |                                 may outlive borrowed value `prefix`\n    |\n note: closure is returned here\n-  --> $DIR/does-not-live-long-enough.rs:6:9\n+  --> $DIR/does-not-live-long-enough.rs:5:55\n    |\n-LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     fn started_with<'a>(&'a self, prefix: &'a str) -> impl Iterator<Item=&'a str> {\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to force the closure to take ownership of `prefix` (and any other referenced variables), use the `move` keyword\n    |\n LL |         self.data.iter().filter(move |s| s.starts_with(prefix)).map(|s| s.as_ref())"}, {"sha": "9610618ca11f65f47880ea724d092bed83d6d31b", "filename": "src/test/ui/impl-trait/equality.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -17,8 +17,8 @@ fn two(x: bool) -> impl Foo {\n     //~| expected `i32`, found `u32`\n }\n \n-fn sum_to(n: u32) -> impl Foo {\n-    if n == 0 { //~ ERROR type annotations needed\n+fn sum_to(n: u32) -> impl Foo { //~ ERROR type annotations needed\n+    if n == 0 {\n         0\n     } else {\n         n + sum_to(n - 1)"}, {"sha": "d9819484a96126123a268201d97d08ef87b8e2b9", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -12,13 +12,19 @@ error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n LL | fn two(x: bool) -> impl Foo {\n-   |                    -------- the expected opaque type\n-...\n+   |                    -------- expected because this return type...\n+LL |     if x {\n+LL |         return 1_i32;\n+   |                ----- ...is found to be `i32` here\n+LL |     }\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n    |\n-   = note: expected opaque type `impl Foo`\n-                     found type `u32`\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: if the trait `Foo` were object safe, you could return a boxed trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11\n@@ -29,15 +35,10 @@ LL |         n + sum_to(n - 1)\n    = help: the trait `Add<impl Foo>` is not implemented for `u32`\n \n error[E0283]: type annotations needed\n-  --> $DIR/equality.rs:21:5\n-   |\n-LL | /     if n == 0 {\n-LL | |         0\n-LL | |     } else {\n-LL | |         n + sum_to(n - 1)\n-LL | |\n-LL | |     }\n-   | |_____^ cannot infer type for type `{integer}`\n+  --> $DIR/equality.rs:20:22\n+   |\n+LL | fn sum_to(n: u32) -> impl Foo {\n+   |                      ^^^^^^^^ cannot infer type for type `{integer}`\n    |\n    = note: multiple `impl`s satisfying `{integer}: ToString` found in the `alloc` crate:\n            - impl ToString for i8;"}, {"sha": "46053c6e7c1196f4cb10eb13c4814751856b6f33", "filename": "src/test/ui/impl-trait/equality2.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -15,7 +15,9 @@ LL | fn hide<T: Foo>(x: T) -> impl Foo {\n    |                          -------- the found opaque type\n ...\n LL |     let _: u32 = hide(0_u32);\n-   |                  ^^^^^^^^^^^ expected `u32`, found opaque type\n+   |            ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n+   |            |\n+   |            expected due to this\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Foo`"}, {"sha": "1e6eb5bb355888c04904570ec6cd6232dd1814db", "filename": "src/test/ui/impl-trait/fallback.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,9 +0,0 @@\n-// check-pass\n-\n-fn take_edge_counters(\n-    x: &mut Option<Vec<i32>>,\n-) -> Option<impl Iterator<Item = i32>> {\n-    x.take().map_or(None, |m| Some(m.into_iter()))\n-}\n-\n-fn main() {}"}, {"sha": "2ee004a37a6fc2568a37afbdc387d45f5f368ba5", "filename": "src/test/ui/impl-trait/hidden-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -26,8 +26,8 @@ impl<T> Swap for Rc<RefCell<T>> {\n // Here we are hiding `'b` making the caller believe that `&'a mut &'s T` and\n // `&'a mut &'l T` are the same type.\n fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-    x\n     //~^ ERROR hidden type\n+    x\n }\n \n fn dangle_ref() -> &'static [i32; 3] {\n@@ -43,8 +43,8 @@ fn dangle_ref() -> &'static [i32; 3] {\n // This is different to the previous example because the concrete return type\n // only has a single lifetime.\n fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-    x\n     //~^ ERROR hidden type\n+    x\n }\n \n fn dangle_rc_refcell() -> &'static [i32; 3] {"}, {"sha": "c6d11293eec530c3f86c4c59123d8d0d891da1e6", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,23 +1,23 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:29:5\n+  --> $DIR/hidden-lifetimes.rs:28:54\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-   |                 -- hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n-LL |     x\n-   |     ^\n+   |                 --                                   ^^^^^^^^^^^^^^\n+   |                 |\n+   |                 hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:46:5\n+  --> $DIR/hidden-lifetimes.rs:45:70\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-   |                        -- hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n-LL |     x\n-   |     ^\n+   |                        --                                            ^^^^^^^^^^^^^^\n+   |                        |\n+   |                        hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "46188636475db0362549d659208bef75878f060a", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -10,10 +10,11 @@ impl<S: Default> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T: Default>() -> Self::E {\n-        //~^ ERROR impl has stricter requirements than trait\n-        (S::default(), T::default())\n-        //~^ ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        //~| ERROR impl has stricter requirements than trait\n+        //~| ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n         //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n+        (S::default(), T::default())\n     }\n }\n "}, {"sha": "2d1142fd0c52cff2e0c8db7b6adf44d6a8f0458c", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,10 +8,10 @@ LL |     fn foo<T: Default>() -> Self::E {\n    |               ^^^^^^^ impl has extra requirement `T: Default`\n \n error[E0277]: the trait bound `S: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:14:9\n+  --> $DIR/issue-55872-1.rs:12:29\n    |\n-LL |         (S::default(), T::default())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n+LL |     fn foo<T: Default>() -> Self::E {\n+   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n@@ -20,18 +20,31 @@ LL | impl<S: Default + std::marker::Copy> Bar for S {\n    |                 +++++++++++++++++++\n \n error[E0277]: the trait bound `T: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:14:9\n+  --> $DIR/issue-55872-1.rs:12:29\n    |\n-LL |         (S::default(), T::default())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n+LL |     fn foo<T: Default>() -> Self::E {\n+   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n    |\n LL |     fn foo<T: Default + std::marker::Copy>() -> Self::E {\n    |                       +++++++++++++++++++\n \n-error: aborting due to 3 previous errors\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+  --> $DIR/issue-55872-1.rs:12:37\n+   |\n+LL |       fn foo<T: Default>() -> Self::E {\n+   |  _____________________________________^\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         (S::default(), T::default())\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0276, E0277.\n For more information about an error, try `rustc --explain E0276`."}, {"sha": "a519397806e0703ee7e83076dc191016722e607f", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,16 +4,17 @@\n #![feature(type_alias_impl_trait)]\n \n pub trait Bar {\n-    type E: Send;\n+    type E: Copy;\n \n     fn foo<T>() -> Self::E;\n }\n \n impl<S> Bar for S {\n-    type E = impl std::marker::Send;\n+    type E = impl std::marker::Copy;\n     fn foo<T>() -> Self::E {\n-        async {}\n         //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        //~| ERROR the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n+        async {}\n     }\n }\n "}, {"sha": "97545ba3d1124c755df086a10ff9195b445ef00f", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,20 @@\n+error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n+  --> $DIR/issue-55872-2.rs:14:20\n+   |\n+LL |     fn foo<T>() -> Self::E {\n+   |                    ^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n+\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-2.rs:15:9\n+  --> $DIR/issue-55872-2.rs:14:28\n    |\n-LL |         async {}\n-   |         ^^^^^^^^\n+LL |       fn foo<T>() -> Self::E {\n+   |  ____________________________^\n+LL | |\n+LL | |\n+LL | |         async {}\n+LL | |     }\n+   | |_____^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f50b31ff496ae25be1bb756a0685e56d29840e02", "filename": "src/test/ui/impl-trait/issue-55872-3.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,20 +0,0 @@\n-// edition:2018\n-// ignore-compare-mode-chalk\n-\n-#![feature(type_alias_impl_trait)]\n-\n-pub trait Bar {\n-    type E: Copy;\n-\n-    fn foo<T>() -> Self::E;\n-}\n-\n-impl<S> Bar for S {\n-    type E = impl std::marker::Copy;\n-    fn foo<T>() -> Self::E {\n-        async {}\n-        //~^ ERROR the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied [E0277]\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "bafd31f0083e8edec2106e267002116a7e338adb", "filename": "src/test/ui/impl-trait/issue-55872-3.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,9 +0,0 @@\n-error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n-  --> $DIR/issue-55872-3.rs:15:9\n-   |\n-LL |         async {}\n-   |         ^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "bbd940254178ce45ffe4dfff6ec5c35b8808f50d", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,8 +11,8 @@ impl<S> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T>() -> Self::E {\n-        || ()\n         //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        || ()\n     }\n }\n "}, {"sha": "60654ec34610fc24321c244905b55dc66950a454", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,12 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872.rs:14:9\n+  --> $DIR/issue-55872.rs:13:28\n    |\n-LL |         || ()\n-   |         ^^^^^\n+LL |       fn foo<T>() -> Self::E {\n+   |  ____________________________^\n+LL | |\n+LL | |         || ()\n+LL | |     }\n+   | |_____^\n \n error: aborting due to previous error\n "}, {"sha": "dee5a41f6de375d30f06611cc23677ea8770498f", "filename": "src/test/ui/impl-trait/issue-72911.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,7 +5,7 @@ pub struct Lint {}\n impl Lint {}\n \n pub fn gather_all() -> impl Iterator<Item = Lint> {\n-    //~^ ERROR `()` is not an iterator\n+    //~^ ERROR: cannot resolve opaque type\n     lint_files().flat_map(|f| gather_from_file(&f))\n }\n "}, {"sha": "e57fbf104dc6f5413643c60337b23cb82eb62bdf", "filename": "src/test/ui/impl-trait/issue-72911.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -10,15 +10,25 @@ error[E0433]: failed to resolve: use of undeclared crate or module `foo`\n LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n    |                                         ^^^ use of undeclared crate or module `foo`\n \n-error[E0277]: `()` is not an iterator\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/issue-72911.rs:7:24\n    |\n LL | pub fn gather_all() -> impl Iterator<Item = Lint> {\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n-   |\n-   = help: the trait `Iterator` is not implemented for `()`\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     lint_files().flat_map(|f| gather_from_file(&f))\n+   |     -----------------------------------------------\n+   |     |\n+   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n+   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n+...\n+LL | fn gather_from_file(dir_entry: &foo::MissingItem) -> impl Iterator<Item = Lint> {\n+   |                                                      -------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n+...\n+LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n+   |                    -------------------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0277, E0433.\n-For more information about an error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0433, E0720.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "853c2a82bede4b000b4045c55c48cbf2cf15c488", "filename": "src/test/ui/impl-trait/issues/issue-70877.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,7 +4,7 @@ type FooArg<'a> = &'a dyn ToString;\n type FooRet = impl std::fmt::Debug;\n \n type FooItem = Box<dyn Fn(FooArg) -> FooRet>;\n-type Foo = impl Iterator<Item = FooItem>;\n+type Foo = impl Iterator<Item = FooItem>; //~ ERROR: type mismatch\n \n #[repr(C)]\n struct Bar(u8);\n@@ -28,7 +28,7 @@ fn ham() -> Foo {\n fn oof() -> impl std::fmt::Debug {\n     let mut bar = ham();\n     let func = bar.next().unwrap();\n-    return func(&\"oof\"); //~ ERROR opaque type's hidden type cannot be another opaque type\n+    return func(&\"oof\");\n }\n \n fn main() {"}, {"sha": "fe48e92da5eacc7d44c4a758f24b0413679c0cd3", "filename": "src/test/ui/impl-trait/issues/issue-70877.stderr", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,19 +1,20 @@\n-error: opaque type's hidden type cannot be another opaque type from the same scope\n-  --> $DIR/issue-70877.rs:31:12\n+error[E0271]: type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n+  --> $DIR/issue-70877.rs:7:12\n    |\n-LL |     return func(&\"oof\");\n-   |            ^^^^^^^^^^^^ one of the two opaque types used here has to be outside its defining scope\n-   |\n-note: opaque type whose hidden type is being assigned\n-  --> $DIR/issue-70877.rs:28:13\n+LL | type FooRet = impl std::fmt::Debug;\n+   |               -------------------- the found opaque type\n+...\n+LL | type Foo = impl Iterator<Item = FooItem>;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n    |\n-LL | fn oof() -> impl std::fmt::Debug {\n-   |             ^^^^^^^^^^^^^^^^^^^^\n-note: opaque type being used as hidden type\n-  --> $DIR/issue-70877.rs:4:15\n+note: expected this to be `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n+  --> $DIR/issue-70877.rs:13:17\n    |\n-LL | type FooRet = impl std::fmt::Debug;\n-   |               ^^^^^^^^^^^^^^^^^^^^\n+LL |     type Item = FooItem;\n+   |                 ^^^^^^^\n+   = note: expected struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n+              found struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> impl Debug + 'static)>`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "bdbd20f9d2b884d500e152aee0cb66e2d947ebe8", "filename": "src/test/ui/impl-trait/issues/issue-78722.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -10,8 +10,7 @@ struct Bug {\n             async {}\n         }\n         let f: F = async { 1 };\n-        //~^ ERROR `async` blocks are not allowed in constants\n-        //~| ERROR destructors cannot be evaluated at compile-time\n+        //~^ ERROR mismatched types [E0308]\n         1\n     }],\n }"}, {"sha": "130678de2370cd47ed6978b7c50ef91a15a443d9", "filename": "src/test/ui/impl-trait/issues/issue-78722.stderr", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,22 +1,23 @@\n-error[E0658]: `async` blocks are not allowed in constants\n+error[E0308]: mismatched types\n   --> $DIR/issue-78722.rs:12:20\n    |\n+LL | type F = impl core::future::Future<Output = u8>;\n+   |          -------------------------------------- the expected opaque type\n+...\n LL |         let f: F = async { 1 };\n-   |                    ^^^^^^^^^^^\n+   |                -   ^^^^^^^^^^^ expected opaque type, found a different opaque type\n+   |                |\n+   |                expected due to this\n    |\n-   = note: see issue #85368 <https://github.com/rust-lang/rust/issues/85368> for more information\n-   = help: add `#![feature(const_async_blocks)]` to the crate attributes to enable\n-\n-error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/issue-78722.rs:12:13\n+  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n    |\n-LL |         let f: F = async { 1 };\n-   |             ^ constants cannot evaluate destructors\n-...\n-LL |     }],\n-   |     - value is dropped here\n+LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+   |                                           ------------------------------- the found opaque type\n+   |\n+   = note: expected opaque type `impl Future<Output = u8>`\n+              found opaque type `impl Future<Output = [async output]>`\n+   = note: distinct uses of `impl Trait` result in different opaque types\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0493, E0658.\n-For more information about an error, try `rustc --explain E0493`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e3386d29def02eabcb4840186426032754fc1bc0", "filename": "src/test/ui/impl-trait/issues/issue-86201.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,10 @@\n #![feature(unboxed_closures)]\n #![feature(type_alias_impl_trait)]\n \n-// check-pass\n-\n type FunType = impl Fn<()>;\n+//~^ ERROR could not find defining uses\n static STATIC_FN: FunType = some_fn;\n+//~^ ERROR mismatched types\n \n fn some_fn() {}\n "}, {"sha": "b1460096ded66d3119023e21099d1886ce602f53", "filename": "src/test/ui/impl-trait/issues/issue-86201.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-86201.rs:6:29\n+   |\n+LL | type FunType = impl Fn<()>;\n+   |                ----------- the expected opaque type\n+LL |\n+LL | static STATIC_FN: FunType = some_fn;\n+   |                             ^^^^^^^ expected opaque type, found fn item\n+   |\n+   = note: expected opaque type `impl Fn<()>`\n+                  found fn item `fn() {some_fn}`\n+\n+error: could not find defining uses\n+  --> $DIR/issue-86201.rs:4:16\n+   |\n+LL | type FunType = impl Fn<()>;\n+   |                ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "86323add77905060d354e973e935172f4ce16787", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.nll.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,39 +0,0 @@\n-error: higher-ranked subtype error\n-  --> $DIR/issue-88236-2.rs:17:5\n-   |\n-LL |     &()\n-   |     ^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-88236-2.rs:17:5\n-   |\n-LL |     &()\n-   |     ^^^\n-\n-error: lifetime may not live long enough\n-  --> $DIR/issue-88236-2.rs:20:5\n-   |\n-LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n-   |                  -- lifetime `'b` defined here\n-LL |     x\n-   |     ^ returning this value requires that `'b` must outlive `'static`\n-   |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'b`, add `'b` as a bound\n-   |\n-LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> + 'b {\n-   |                                                                                  ++++\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-88236-2.rs:20:5\n-   |\n-LL |     x\n-   |     ^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/issue-88236-2.rs:20:5\n-   |\n-LL |     x\n-   |     ^\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "f89ab7fbd364b92496e340662b88999eae63bbfa", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,23 +0,0 @@\n-// this used to cause stack overflows\n-\n-trait Hrtb<'a> {\n-    type Assoc;\n-}\n-\n-impl<'a> Hrtb<'a> for () {\n-    type Assoc = ();\n-}\n-\n-impl<'a> Hrtb<'a> for &'a () {\n-    type Assoc = ();\n-}\n-\n-fn make_impl() -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {}\n-fn make_weird_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n-    &() //~ ERROR implementation of `Hrtb` is not general enough\n-}\n-fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n-    x //~ ERROR implementation of `Hrtb` is not general enough\n-}\n-\n-fn main() {}"}, {"sha": "95c4a52803698345694324dc36c62cc5c2fdcbf1", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,20 +0,0 @@\n-error: implementation of `Hrtb` is not general enough\n-  --> $DIR/issue-88236-2.rs:17:5\n-   |\n-LL |     &()\n-   |     ^^^ implementation of `Hrtb` is not general enough\n-   |\n-   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n-   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n-\n-error: implementation of `Hrtb` is not general enough\n-  --> $DIR/issue-88236-2.rs:20:5\n-   |\n-LL |     x\n-   |     ^ implementation of `Hrtb` is not general enough\n-   |\n-   = note: `&()` must implement `Hrtb<'0>`, for any lifetime `'0`...\n-   = note: ...but `Hrtb<'_>` is actually implemented for the type `&()`\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "2ea35270a7e3b5cc0e6784bc8bff5375d7e693d4", "filename": "src/test/ui/impl-trait/issues/issue-88236.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,19 +0,0 @@\n-// check-pass\n-\n-// this used to cause stack overflows\n-\n-trait Hrtb<'a> {\n-    type Assoc;\n-}\n-\n-impl<'a> Hrtb<'a> for () {\n-    type Assoc = ();\n-}\n-\n-impl<'a> Hrtb<'a> for &'a () {\n-    type Assoc = ();\n-}\n-\n-fn make_impl() -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {}\n-\n-fn main() {}"}, {"sha": "834f2dc6cb5b6dfde14de37e2e7cd83d73e9c85e", "filename": "src/test/ui/impl-trait/lifetimes2.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,10 +0,0 @@\n-// check-pass\n-\n-pub fn keys<'a>(x: &'a Result<u32, u32>) -> impl std::fmt::Debug + 'a {\n-    match x {\n-        Ok(map) => Ok(map),\n-        Err(map) => Err(map),\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "72e9d96da3677fdd96650f93dacd0f477ec5b358", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,6 +8,7 @@ impl<T: Copy> Copy for CopyIfEq<T, T> {}\n type E<'a, 'b> = impl Sized;\n \n fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n     let v = CopyIfEq::<*mut _, *mut _>(&mut { x }, &mut y);\n \n     // This assignment requires that `x` and `y` have the same type due to the\n@@ -20,7 +21,6 @@ fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n         let _: &'b i32 = *u.0;\n     }\n     u.0\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "40bec0da2707d589d419fa88b82f9cb64b575084", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/error-handling-2.rs:22:5\n+  --> $DIR/error-handling-2.rs:10:60\n    |\n LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-   |        -- hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n-...\n-LL |     u.0\n-   |     ^^^\n+   |        --                                                  ^^^^^^^^^\n+   |        |\n+   |        hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n \n error: aborting due to previous error\n "}, {"sha": "3a97624647efd79be70c7549def20b0c8631c466", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -14,6 +14,7 @@ struct Ordinary<'a>(&'a u8);\n // by both `'a` and `'b`.\n \n fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n where\n     'a: 'e,\n     'b: 'd,\n@@ -26,7 +27,6 @@ where\n     // 'a in ['d, 'e]\n     // ```\n     if condition() { a } else { b }\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "32829a0a1b2fa60af0e0577a26e32fd92fa4e68b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unrelated.rs:28:33\n+  --> $DIR/ordinary-bounds-unrelated.rs:16:74\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n-...\n-LL |     if condition() { a } else { b }\n-   |                                 ^\n+   |                     --                                                   ^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "d4c60a4e89209c883a82972c11c7086f0749ea43", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -16,6 +16,7 @@ struct Ordinary<'a>(&'a u8);\n // consider the loans for both `'a` and `'b` alive.\n \n fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n {\n     // We return a value:\n     //\n@@ -29,7 +30,6 @@ fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n     //\n     // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n     if condition() { a } else { b }\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "83ad23b253bb3729ebdf6927fbe8ce195ac9e33e", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unsuited.rs:31:33\n+  --> $DIR/ordinary-bounds-unsuited.rs:18:62\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n-...\n-LL |     if condition() { a } else { b }\n-   |                                 ^\n+   |                     --                                       ^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "2f6bd8ff377a544bdc2f559567cf3e739d62bbc6", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----                 ^\n+   |              ----     ^^^^^^^^^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                             ^\n+   |             --                 ^^^^^^^^^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -67,23 +67,23 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n-LL |     move |_| println!(\"{}\", y)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                              --                             ^^^^^^^^^^^^^^^^\n+   |                              |\n+   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:39:5\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n    |\n-LL |     x\n-   |     ^\n+LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n+   |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "69d2843ff3f01b0f5184ee1c15209d638ad71a53", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -31,13 +31,13 @@ fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x } //~ ERRO\n // Tests that a closure type containing 'b cannot be returned from a type where\n // only 'a was expected.\n fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-    move |_| println!(\"{}\", y)\n     //~^ ERROR: captures lifetime that does not appear in bounds\n+    move |_| println!(\"{}\", y)\n }\n \n fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-    x\n     //~^ ERROR the parameter type `T` may not live long enough\n+    x\n }\n \n fn main() {}"}, {"sha": "07ac0a8db35a923946ff2603c0ae527e00714444", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----                 ^\n+   |              ----     ^^^^^^^^^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                             ^\n+   |             --                 ^^^^^^^^^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -28,10 +28,15 @@ error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'sta\n   --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n-   |               ----                           ^ ...is used and required to live as long as `'static` here\n+   |               ----                           ^ ...is used here...\n    |               |\n    |               this data with an anonymous lifetime `'_`...\n    |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |                        ^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n@@ -45,10 +50,15 @@ error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n-   |                     -------                           ^ ...is used and required to live as long as `'static` here\n+   |                     -------                           ^ ...is used here...\n    |                     |\n    |                     this data with lifetime `'a`...\n    |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:11:33\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |                                 ^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n@@ -59,10 +69,10 @@ LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n    |                     ~~~~~~~~~~~~\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:13:41\n+  --> $DIR/must_outlive_least_region_or_bound.rs:13:24\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n-   |               ----                      ^ lifetime `'a` required\n+   |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n@@ -85,8 +95,13 @@ error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                      ------- this data with lifetime `'a`...        ^ ...is used and required to live as long as `'static` here\n+   |                      ------- this data with lifetime `'a`...        ^ ...is used here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:29:34\n    |\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n@@ -97,25 +112,25 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ~~~~~~~~~~~~\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n-LL |     move |_| println!(\"{}\", y)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                              --                             ^^^^^^^^^^^^^^^^\n+   |                              |\n+   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:39:5\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 -- help: consider adding an explicit lifetime bound...: `T: 'static +`\n-LL |     x\n-   |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                                 |\n+   |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/must_outlive_least_region_or_bound.rs:16:50"}, {"sha": "d173fe83fb7913c35699f933005570245680faac", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -17,7 +17,7 @@ impl<T: std::fmt::Debug> AnotherTrait for T {}\n \n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n }\n \n fn main() {}"}, {"sha": "e39a8e53f7985cbe87b2f75059443eca18c1e88a", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,13 +1,13 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n   --> $DIR/negative-reasoning.rs:19:1\n    |\n LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n    | ------------------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n    |\n-   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `impl OpaqueTrait` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "be2c21a7743ce1e9687c4cf425ab8f141e9cf88f", "filename": "src/test/ui/impl-trait/nested_impl_trait.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,7 +4,6 @@ fn fine(x: impl Into<u32>) -> impl Into<u32> { x }\n \n fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n //~^ ERROR nested `impl Trait` is not allowed\n-//~| ERROR `impl Into<u32>` doesn't implement `Debug`\n \n fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n //~^ ERROR nested `impl Trait` is not allowed\n@@ -17,7 +16,6 @@ struct X;\n impl X {\n     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n     //~^ ERROR nested `impl Trait` is not allowed\n-    //~| ERROR `impl Into<u32>` doesn't implement `Debug`\n }\n \n fn allowed_in_assoc_type() -> impl Iterator<Item=impl Fn()> {"}, {"sha": "59c7e4d5f4e92b8aa0a8867f5e04120567f9a026", "filename": "src/test/ui/impl-trait/nested_impl_trait.stderr", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,7 +8,7 @@ LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                              outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:9:42\n+  --> $DIR/nested_impl_trait.rs:8:42\n    |\n LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                ----------^^^^^^^^^^-\n@@ -17,7 +17,7 @@ LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:13:37\n+  --> $DIR/nested_impl_trait.rs:12:37\n    |\n LL | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n    |                           ----------^^^^^^^^^^-\n@@ -26,7 +26,7 @@ LL | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n    |                           outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:18:44\n+  --> $DIR/nested_impl_trait.rs:17:44\n    |\n LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  ----------^^^^^^^^^^-\n@@ -35,40 +35,18 @@ LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  outer `impl Trait`\n \n error[E0562]: `impl Trait` not allowed outside of function and method return types\n-  --> $DIR/nested_impl_trait.rs:9:32\n+  --> $DIR/nested_impl_trait.rs:8:32\n    |\n LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and method return types\n-  --> $DIR/nested_impl_trait.rs:27:42\n+  --> $DIR/nested_impl_trait.rs:25:42\n    |\n LL | fn allowed_in_ret_type() -> impl Fn() -> impl Into<u32> {\n    |                                          ^^^^^^^^^^^^^^\n \n-error[E0277]: `impl Into<u32>` doesn't implement `Debug`\n-  --> $DIR/nested_impl_trait.rs:5:70\n-   |\n-LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n-   |                                                                      ^ `impl Into<u32>` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n-   |\n-help: consider further restricting this bound\n-   |\n-LL | fn bad_in_ret_position(x: impl Into<u32> + std::fmt::Debug) -> impl Into<impl Debug> { x }\n-   |                                          +++++++++++++++++\n-\n-error[E0277]: `impl Into<u32>` doesn't implement `Debug`\n-  --> $DIR/nested_impl_trait.rs:18:58\n-   |\n-LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n-   |                                                          ^ `impl Into<u32>` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n-   |\n-help: consider further restricting this bound\n-   |\n-LL |     fn bad(x: impl Into<u32> + std::fmt::Debug) -> impl Into<impl Debug> { x }\n-   |                              +++++++++++++++++\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0277, E0562, E0666.\n-For more information about an error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0562, E0666.\n+For more information about an error, try `rustc --explain E0562`."}, {"sha": "357166d112377aa56b82cfe7a1da18fa4465dbcd", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,25 +2,46 @@ error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n    |\n LL | fn can() -> impl NotObjectSafe {\n-   |             ------------------ the expected opaque type\n-...\n+   |             ------------------ expected because this return type...\n+LL |     if true {\n+LL |         return A;\n+   |                - ...is found to be `A` here\n+LL |     }\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n    |\n-   = note: expected opaque type `impl NotObjectSafe`\n-                   found struct `B`\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n    |\n LL | fn cat() -> impl ObjectSafe {\n-   |             --------------- the expected opaque type\n-...\n+   |             --------------- expected because this return type...\n+LL |     if true {\n+LL |         return A;\n+   |                - ...is found to be `A` here\n+LL |     }\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n    |\n-   = note: expected opaque type `impl ObjectSafe`\n-                   found struct `B`\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn cat() -> Box<dyn ObjectSafe> {\n+   |             ~~~~~~~           +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         return Box::new(A);\n+LL |     }\n+LL ~     Box::new(B)\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fa7664a83eee073f7588794011a8f5f73f336117", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -14,10 +14,10 @@ fn bar() -> impl std::fmt::Display {\n }\n \n fn baz() -> impl std::fmt::Display {\n-    if false { //~ ERROR mismatched types\n+    if false {\n         return 0i32;\n     } else {\n-        1u32\n+        1u32 //~ ERROR mismatched types\n     }\n }\n \n@@ -30,9 +30,9 @@ fn qux() -> impl std::fmt::Display {\n }\n \n fn bat() -> impl std::fmt::Display {\n-    match 13 { //~ ERROR mismatched types\n+    match 13 {\n         0 => return 0i32,\n-        _ => 1u32,\n+        _ => 1u32, //~ ERROR mismatched types\n     }\n }\n \n@@ -45,12 +45,12 @@ fn can() -> impl std::fmt::Display {\n }\n \n fn cat() -> impl std::fmt::Display {\n-    match 13 { //~ ERROR mismatched types\n+    match 13 {\n         0 => {\n             return 0i32;\n         }\n         _ => {\n-            1u32\n+            1u32 //~ ERROR mismatched types\n         }\n     }\n }"}, {"sha": "970abad5c72e9166c35412786b5fe18803192641", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 145, "deletions": 45, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,40 +2,82 @@ error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n LL | fn foo() -> impl std::fmt::Display {\n-   |             ---------------------- the expected opaque type\n-...\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n+LL |         return 0i32;\n+   |                ---- ...is found to be `i32` here\n+LL |     }\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n    |\n-   = note: expected opaque type `impl std::fmt::Display`\n-                     found type `u32`\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn foo() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         return Box::new(0i32);\n+LL |     }\n+LL ~     Box::new(1u32)\n+   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:12:16\n    |\n LL | fn bar() -> impl std::fmt::Display {\n-   |             ---------------------- the expected opaque type\n-...\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n+LL |         return 0i32;\n+   |                ---- ...is found to be `i32` here\n+LL |     } else {\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n    |\n-   = note: expected opaque type `impl std::fmt::Display`\n-                     found type `u32`\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn bar() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         return Box::new(0i32);\n+LL |     } else {\n+LL ~         return Box::new(1u32);\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:17:5\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:20:9\n    |\n-LL |   fn baz() -> impl std::fmt::Display {\n-   |               ---------------------- the expected opaque type\n-LL | /     if false {\n-LL | |         return 0i32;\n-LL | |     } else {\n-LL | |         1u32\n-LL | |     }\n-   | |_____^ expected `i32`, found `u32`\n+LL | fn baz() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n+LL |         return 0i32;\n+   |                ---- ...is found to be `i32` here\n+LL |     } else {\n+LL |         1u32\n+   |         ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn baz() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         return Box::new(0i32);\n+LL |     } else {\n+LL ~         Box::new(1u32)\n    |\n-   = note: expected opaque type `impl std::fmt::Display`\n-                     found type `u32`\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:28:9\n@@ -61,50 +103,87 @@ LL ~         Box::new(1u32)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:33:5\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n    |\n-LL |   fn bat() -> impl std::fmt::Display {\n-   |               ---------------------- the expected opaque type\n-LL | /     match 13 {\n-LL | |         0 => return 0i32,\n-LL | |         _ => 1u32,\n-LL | |     }\n-   | |_____^ expected `i32`, found `u32`\n+LL | fn bat() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+LL |     match 13 {\n+LL |         0 => return 0i32,\n+   |                     ---- ...is found to be `i32` here\n+LL |         _ => 1u32,\n+   |              ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn bat() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         0 => return Box::new(0i32),\n+LL ~         _ => Box::new(1u32),\n    |\n-   = note: expected opaque type `impl std::fmt::Display`\n-                     found type `u32`\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:40:5\n    |\n LL |   fn can() -> impl std::fmt::Display {\n-   |               ---------------------- the expected opaque type\n+   |               ---------------------- expected because this return type...\n LL | /     match 13 {\n LL | |         0 => return 0i32,\n+   | |                     ---- ...is found to be `i32` here\n LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n    |\n-   = note: expected opaque type `impl std::fmt::Display`\n-                     found type `u32`\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn can() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~     Box::new(match 13 {\n+LL ~         0 => return Box::new(0i32),\n+LL |         1 => 1u32,\n+LL |         _ => 2u32,\n+LL ~     })\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:48:5\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:53:13\n    |\n-LL |   fn cat() -> impl std::fmt::Display {\n-   |               ---------------------- the expected opaque type\n-LL | /     match 13 {\n-LL | |         0 => {\n-LL | |             return 0i32;\n-LL | |         }\n-...  |\n-LL | |         }\n-LL | |     }\n-   | |_____^ expected `i32`, found `u32`\n+LL | fn cat() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+...\n+LL |             return 0i32;\n+   |                    ---- ...is found to be `i32` here\n+...\n+LL |             1u32\n+   |             ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn cat() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~             return Box::new(0i32);\n+LL |         }\n+LL |         _ => {\n+LL ~             Box::new(1u32)\n    |\n-   = note: expected opaque type `impl std::fmt::Display`\n-                     found type `u32`\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n@@ -117,6 +196,16 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn dog() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         0 => Box::new(0i32),\n+LL ~         1 => Box::new(1u32),\n+   |\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n@@ -129,6 +218,17 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn apt() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         Box::new(0i32)\n+LL |     } else {\n+LL ~         Box::new(1u32)\n+   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13"}, {"sha": "b4fd6b3e74364d45c81e926c63f4f09213202236", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,8 +11,8 @@ pub trait Test {}\n impl<T> Test for T where T: Super<Assoc = ()> {}\n \n fn test() -> impl Test {\n-    ()\n     //~^ERROR type mismatch resolving `<() as Super>::Assoc == ()`\n+    ()\n }\n \n fn main() {"}, {"sha": "65daabe419d3f3b81862bc8904edf28257ca35ae", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,10 @@\n error[E0271]: type mismatch resolving `<() as Super>::Assoc == ()`\n-  --> $DIR/projection-mismatch-in-impl-where-clause.rs:14:5\n+  --> $DIR/projection-mismatch-in-impl-where-clause.rs:13:14\n    |\n-LL |     ()\n-   |     ^^ type mismatch resolving `<() as Super>::Assoc == ()`\n+LL | fn test() -> impl Test {\n+   |              ^^^^^^^^^ type mismatch resolving `<() as Super>::Assoc == ()`\n    |\n-note: expected this to be `u8`\n+note: expected this to be `()`\n   --> $DIR/projection-mismatch-in-impl-where-clause.rs:6:18\n    |\n LL |     type Assoc = u8;"}, {"sha": "211f7972dbca890e17e5af268e44acce89defd36", "filename": "src/test/ui/impl-trait/question_mark.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,13 +0,0 @@\n-// check-pass\n-\n-fn foo() -> impl MyTrait {\n-    panic!();\n-    MyStruct\n-}\n-\n-struct MyStruct;\n-trait MyTrait {}\n-\n-impl MyTrait for MyStruct {}\n-\n-fn main() {}"}, {"sha": "3cc537440977c09f96c24c6765d5f1d979d14f60", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,9 @@\n-// check-pass\n+// Test that an `impl Trait` type that expands to itself is an error.\n \n #![allow(unconditional_recursion)]\n \n fn test() -> impl Sized {\n+    //~^ ERROR E0720\n     test()\n }\n "}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,12 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n+   |\n+LL | fn test() -> impl Sized {\n+   |              ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     test()\n+   |     ------ returning here with type `impl Sized`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "e3c621f0c57424357bc30d7885f70c75b453c683", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,7 +5,7 @@\n #![allow(unconditional_recursion)]\n \n fn option(i: i32) -> impl Sized {\n-    //~^ ERROR cannot resolve opaque type\n+    //~^ ERROR\n     if i < 0 { None } else { Some((option(i - 1), i)) }\n }\n "}, {"sha": "a60e34c17b671aa0f8057e97913a68b1cd70f949", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,29 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-mod a {\n-    type Foo = impl PartialEq<(Foo, i32)>;\n-    //~^ ERROR unconstrained opaque type\n-\n-    struct Bar;\n-\n-    impl PartialEq<(Bar, i32)> for Bar {\n-        fn eq(&self, _other: &(Foo, i32)) -> bool {\n-            true\n-        }\n-    }\n-}\n-\n-mod b {\n-    type Foo = impl PartialEq<(Foo, i32)>;\n-    //~^ ERROR unconstrained opaque type\n-\n-    struct Bar;\n-\n-    impl PartialEq<(Foo, i32)> for Bar {\n-        fn eq(&self, _other: &(Bar, i32)) -> bool {\n-            true\n-        }\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "eae7d38d1162b72ec217394d909dd600baf6bc66", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,18 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:4:16\n-   |\n-LL |     type Foo = impl PartialEq<(Foo, i32)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `Foo` must be used in combination with a concrete type within the same module\n-\n-error: unconstrained opaque type\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:17:16\n-   |\n-LL |     type Foo = impl PartialEq<(Foo, i32)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `Foo` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "bdabc13c36a96ee17791ea11dd5315156be89cdd", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,37 +0,0 @@\n-// check-pass\n-\n-#![feature(type_alias_impl_trait)]\n-\n-mod direct {\n-    type Foo = impl PartialEq<(Foo, i32)>;\n-\n-    struct Bar;\n-\n-    impl PartialEq<(Foo, i32)> for Bar {\n-        fn eq(&self, _other: &(Foo, i32)) -> bool {\n-            true\n-        }\n-    }\n-\n-    fn foo() -> Foo {\n-        Bar\n-    }\n-}\n-\n-mod indirect {\n-    type Foo = impl PartialEq<(Foo, i32)>;\n-\n-    struct Bar;\n-\n-    impl PartialEq<(Bar, i32)> for Bar {\n-        fn eq(&self, _other: &(Bar, i32)) -> bool {\n-            true\n-        }\n-    }\n-\n-    fn foo() -> Foo {\n-        Bar\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "29243699e44fd11a00e210259009f3654856f41b", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -13,10 +13,10 @@ trait Trait<'a> { }\n impl Trait<'b> for Cell<&'a u32> { }\n \n fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n where 'x: 'y\n {\n     x\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n }\n \n fn main() { }"}, {"sha": "cf854f67d0456436bcbae328748c2e1283dba6ed", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/region-escape-via-bound.rs:18:5\n+  --> $DIR/region-escape-via-bound.rs:15:29\n    |\n+LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+   |                             ^^^^^^^^^^^^^^\n+LL |\n LL | where 'x: 'y\n    |       -- hidden type `Cell<&'x u32>` captures the lifetime `'x` as defined here\n-LL | {\n-LL |     x\n-   |     ^\n    |\n help: to declare that the `impl Trait` captures `'x`, you can add an explicit `'x` lifetime bound\n    |"}, {"sha": "d792c6eafb32f27ea889552ea03bea1b7fbfa288", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,14 +4,14 @@ struct A {\n \n impl A {\n     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n+        self.x.iter().map(|a| a.0)\n     }\n     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n+        self.x.iter().map(|a| a.0)\n     }\n }\n "}, {"sha": "7424da76182ab3bb703ff03322ce8eaae214d94f", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,49 +1,49 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:7:9\n+  --> $DIR/static-return-lifetime-infered.rs:6:35\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n-LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:7:9\n+  --> $DIR/static-return-lifetime-infered.rs:6:35\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n-LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:12:9\n+  --> $DIR/static-return-lifetime-infered.rs:11:37\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n-LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:12:9\n+  --> $DIR/static-return-lifetime-infered.rs:11:37\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n-LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |"}, {"sha": "6eb2a11b22c5f359e89099183bcdd64c9c54f301", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,19 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-type A = impl Foo;\n-type B = impl Foo;\n-\n-trait Foo {}\n-\n-fn muh(x: A) -> B {\n-    if false {\n-        return Bar; // B's hidden type is Bar\n-    }\n-    x // A's hidden type is `Bar`, because all the hidden types of `B` are compared with each other\n-    //~^ ERROR opaque type's hidden type cannot be another opaque type\n-}\n-\n-struct Bar;\n-impl Foo for Bar {}\n-\n-fn main() {}"}, {"sha": "1a42ac525a6a8f12f60f5a7b47f7ca4bf09d7714", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,19 +0,0 @@\n-error: opaque type's hidden type cannot be another opaque type from the same scope\n-  --> $DIR/two_tait_defining_each_other.rs:12:5\n-   |\n-LL |     x // A's hidden type is `Bar`, because all the hidden types of `B` are compared with each other\n-   |     ^ one of the two opaque types used here has to be outside its defining scope\n-   |\n-note: opaque type whose hidden type is being assigned\n-  --> $DIR/two_tait_defining_each_other.rs:4:10\n-   |\n-LL | type B = impl Foo;\n-   |          ^^^^^^^^\n-note: opaque type being used as hidden type\n-  --> $DIR/two_tait_defining_each_other.rs:3:10\n-   |\n-LL | type A = impl Foo;\n-   |          ^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "3b16d0f5e047f4fe9a4850b3a157f8a1b8e159ab", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,16 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-type A = impl Foo;\n-type B = impl Foo;\n-\n-trait Foo {}\n-\n-fn muh(x: A) -> B {\n-    x // B's hidden type is A (opaquely)\n-    //~^ ERROR opaque type's hidden type cannot be another opaque type\n-}\n-\n-struct Bar;\n-impl Foo for Bar {}\n-\n-fn main() {}"}, {"sha": "ef2089a6c5b176c2132d4b708df92f5ab25fd9d9", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other2.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,19 +0,0 @@\n-error: opaque type's hidden type cannot be another opaque type from the same scope\n-  --> $DIR/two_tait_defining_each_other2.rs:9:5\n-   |\n-LL |     x // B's hidden type is A (opaquely)\n-   |     ^ one of the two opaque types used here has to be outside its defining scope\n-   |\n-note: opaque type whose hidden type is being assigned\n-  --> $DIR/two_tait_defining_each_other2.rs:4:10\n-   |\n-LL | type B = impl Foo;\n-   |          ^^^^^^^^\n-note: opaque type being used as hidden type\n-  --> $DIR/two_tait_defining_each_other2.rs:3:10\n-   |\n-LL | type A = impl Foo;\n-   |          ^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "37f8ae1b84b55f50cd7ada951e389cd9b269d007", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other3.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,19 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-type A = impl Foo;\n-type B = impl Foo;\n-\n-trait Foo {}\n-\n-fn muh(x: A) -> B {\n-    if false {\n-        return x;  // B's hidden type is A (opaquely)\n-        //~^ ERROR opaque type's hidden type cannot be another opaque type\n-    }\n-    Bar // A's hidden type is `Bar`, because all the return types are compared with each other\n-}\n-\n-struct Bar;\n-impl Foo for Bar {}\n-\n-fn main() {}"}, {"sha": "b06dc16d5e700c505e179dc37298a1881b473d2e", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other3.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,19 +0,0 @@\n-error: opaque type's hidden type cannot be another opaque type from the same scope\n-  --> $DIR/two_tait_defining_each_other3.rs:10:16\n-   |\n-LL |         return x;  // B's hidden type is A (opaquely)\n-   |                ^ one of the two opaque types used here has to be outside its defining scope\n-   |\n-note: opaque type whose hidden type is being assigned\n-  --> $DIR/two_tait_defining_each_other3.rs:4:10\n-   |\n-LL | type B = impl Foo;\n-   |          ^^^^^^^^\n-note: opaque type being used as hidden type\n-  --> $DIR/two_tait_defining_each_other3.rs:3:10\n-   |\n-LL | type A = impl Foo;\n-   |          ^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "039cb62f86656a69f511b6364d7935181de85bde", "filename": "src/test/ui/impl-trait/type_parameters_captured.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:8:5\n+  --> $DIR/type_parameters_captured.rs:7:20\n    |\n-LL |     x\n-   |     ^\n+LL | fn foo<T>(x: T) -> impl Any + 'static {\n+   |                    ^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "6c9c9d4a42af5a2a592fe62a3691aeb4f633a996", "filename": "src/test/ui/impl-trait/type_parameters_captured.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,8 +5,8 @@ impl<T> Any for T {}\n \n // Check that type parameters are captured and not considered 'static\n fn foo<T>(x: T) -> impl Any + 'static {\n-    x\n     //~^ ERROR the parameter type `T` may not live long enough\n+    x\n }\n \n fn main() {}"}, {"sha": "40e50b9922f8d2e9f6269cc113ab756df0ec3cc1", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,10 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:8:5\n+  --> $DIR/type_parameters_captured.rs:7:20\n    |\n LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     x\n-   |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |        -           ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |        |\n+   |        help: consider adding an explicit lifetime bound...: `T: 'static`\n \n error: aborting due to previous error\n "}, {"sha": "462508f306ef34f4b1f3de692f996a79a3d894e8", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,7 +1,8 @@\n+//! Ideally, these tests would go in `where-allowed.rs`, but we bail out\n+//! too early to display them.\n use std::fmt::Debug;\n \n-// check-pass\n-\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+// Disallowed\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,13 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/where-allowed-2.rs:6:30\n+   |\n+LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n+   |                              |\n+   |                              cannot resolve opaque type\n+   |\n+   = help: this error will resolve once the item's body returns a concrete type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "fecba721ac9fdeb101053fd43ce0b7e2789ee00e", "filename": "src/test/ui/issues-71798.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fissues-71798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fissues-71798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,6 +1,5 @@\n fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-    *x\n-    //~^ ERROR `u32` is not a future\n+    *x //~^ ERROR `u32` is not a future\n }\n \n fn main() {"}, {"sha": "bc4dc9ebf9e00b4c6569c43cecde89d654d5ce6a", "filename": "src/test/ui/issues-71798.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fissues-71798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fissues-71798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,14 @@\n error[E0425]: cannot find value `u` in this scope\n-  --> $DIR/issues-71798.rs:7:24\n+  --> $DIR/issues-71798.rs:6:24\n    |\n LL |     let _ = test_ref & u;\n    |                        ^ not found in this scope\n \n error[E0277]: `u32` is not a future\n-  --> $DIR/issues-71798.rs:2:5\n+  --> $DIR/issues-71798.rs:1:25\n    |\n-LL |     *x\n-   |     ^^ `u32` is not a future\n+LL | fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `u32` is not a future\n    |\n    = help: the trait `Future` is not implemented for `u32`\n    = note: u32 must be a future or must implement `IntoFuture` to be awaited"}, {"sha": "fa13bf0b12719050bb268f8014248e718bc62c1d", "filename": "src/test/ui/lang-items/lang-item-missing-generator.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error: requires `generator` lang_item\n-  --> $DIR/lang-item-missing-generator.rs:15:22\n+  --> $DIR/lang-item-missing-generator.rs:15:17\n    |\n LL | pub fn abc() -> impl FnOnce(f32) {\n-   |                      ^^^^^^^^^^^\n+   |                 ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "84bfa2d848755a9c64991d460bc917b985ead622", "filename": "src/test/ui/lazy-type-alias-impl-trait/freeze_cycle.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,46 +0,0 @@\n-// check-pass\n-\n-#![feature(gen_future, generator_trait, negative_impls, const_fn_trait_bound, const_impl_trait)]\n-\n-use std::ops::{Generator, GeneratorState};\n-use std::task::{Poll, Context};\n-use std::future::{Future};\n-use std::ptr::NonNull;\n-use std::pin::Pin;\n-\n-fn main() {}\n-\n-#[derive(Debug, Copy, Clone)]\n-pub struct ResumeTy(NonNull<Context<'static>>);\n-\n-unsafe impl Send for ResumeTy {}\n-\n-unsafe impl Sync for ResumeTy {}\n-\n-pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-where\n-    T: Generator<ResumeTy, Yield = ()>,\n-{\n-    struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n-\n-    // We rely on the fact that async/await futures are immovable in order to create\n-    // self-referential borrows in the underlying generator.\n-    impl<T: Generator<ResumeTy, Yield = ()>> !Unpin for GenFuture<T> {}\n-\n-    impl<T: Generator<ResumeTy, Yield = ()>> Future for GenFuture<T> {\n-        type Output = T::Return;\n-        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n-            // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection.\n-            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n-\n-            // Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer. The\n-            // `.await` lowering will safely cast that back to a `&mut Context`.\n-            match gen.resume(ResumeTy(NonNull::from(cx).cast::<Context<'static>>())) {\n-                GeneratorState::Yielded(()) => Poll::Pending,\n-                GeneratorState::Complete(x) => Poll::Ready(x),\n-            }\n-        }\n-    }\n-\n-    GenFuture(gen)\n-}"}, {"sha": "d07d732c78570c74368044af764d6983cee5652c", "filename": "src/test/ui/lazy-type-alias-impl-trait/infer_cross_function.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,27 +0,0 @@\n-// check-pass\n-\n-fn main() {}\n-\n-trait Reader {}\n-\n-struct Unit<R>(R);\n-struct ResDwarf<R>(R);\n-\n-struct Context<R: Reader> {\n-    dwarf: ResDwarf<R>,\n-}\n-\n-struct Range;\n-\n-struct ResUnit<R>(R);\n-\n-impl<R: Reader + 'static> Context<R> {\n-    fn find_dwarf_unit(&self, probe: u64) -> Option<&Unit<R>> {\n-        let x = self.find_units(probe);\n-        None\n-    }\n-\n-    fn find_units(&self, probe: u64) -> impl Iterator<Item = &ResUnit<R>> {\n-        std::iter::empty()\n-    }\n-}"}, {"sha": "f75a88aa8f0645da33663b44e051b2a00a682f69", "filename": "src/test/ui/lazy-type-alias-impl-trait/lifetime_inference.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,7 +0,0 @@\n-// check-pass\n-\n-fn main() {}\n-\n-fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-    move || iter.nth(step)\n-}"}, {"sha": "f8291112739c116d0550b51f13b281a5747c40b8", "filename": "src/test/ui/lazy-type-alias-impl-trait/nested.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,23 +0,0 @@\n-// check-pass\n-\n-fn main() {}\n-\n-struct RawTableInner<A> {\n-    alloc: A,\n-}\n-\n-impl<A> RawTableInner<A> {\n-    fn prepare_resize(\n-        self,\n-    ) -> ScopeGuard<Self, impl FnMut(&mut Self)> {\n-        ScopeGuard { dropfn: move |self_| {}, value: self,  }\n-    }\n-}\n-\n-pub struct ScopeGuard<T, F>\n-where\n-    F: FnMut(&mut T),\n-{\n-    dropfn: F,\n-    value: T,\n-}"}, {"sha": "8d03b5158d66278c4521a579b743d3574d0c2ade", "filename": "src/test/ui/lazy-type-alias-impl-trait/opaque_vs_opaque.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,10 +0,0 @@\n-// check-pass\n-\n-fn main() {}\n-\n-fn filter_fold<T, Acc, PRED: FnMut(&T) -> bool, FOLD: FnMut(Acc, T) -> Acc>(\n-    mut predicate: PRED,\n-    mut fold: FOLD,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n-}"}, {"sha": "007101498238d7f12fc52fabec521565a7b97056", "filename": "src/test/ui/lazy-type-alias-impl-trait/unsized_sized_opaque.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,16 +0,0 @@\n-// check-pass\n-\n-fn main() {}\n-\n-pub struct PairSlices<'a, 'b, T> {\n-    pub(crate) a0: &'a mut [T],\n-    pub(crate) a1: &'a mut [T],\n-    pub(crate) b0: &'b [T],\n-    pub(crate) b1: &'b [T],\n-}\n-\n-impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n-        IntoIterator::into_iter([self.b0, self.b1])\n-    }\n-}"}, {"sha": "ea0d0ccbc553270c9fc290f10065a3080571377d", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,8 +6,8 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n+//~^ ERROR not satisfied\n     Ok(())\n-    //~^ ERROR not satisfied\n }\n \n fn main() {}"}, {"sha": "ef1127c59ac4cfee3380c9a506f1b5916723a07b", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Result<(), _>: Future` is not satisfied\n-  --> $DIR/lifetime-elision-return-type-trait.rs:9:5\n+  --> $DIR/lifetime-elision-return-type-trait.rs:8:13\n    |\n-LL |     Ok(())\n-   |     ^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n+LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n \n error: aborting due to previous error\n "}, {"sha": "6321b3c76e4d18a8bbedcf9e087aa0e17f24807e", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -23,7 +23,7 @@ impl Trait for () {\n     type T = Self;\n \n     #[inline] //~ ERROR attribute should be applied to function or closure\n-    type U = impl Trait; //~ ERROR unconstrained opaque type\n+    type U = impl Trait; //~ ERROR could not find defining uses\n }\n \n extern \"C\" {"}, {"sha": "6ac884c12ceb9a7df3455f0d8d7dcae478ad3e87", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -61,13 +61,11 @@ LL |     #[inline]\n LL |     type T;\n    |     ------- not a function or closure\n \n-error: unconstrained opaque type\n+error: could not find defining uses\n   --> $DIR/inline-trait-and-foreign-items.rs:26:14\n    |\n LL |     type U = impl Trait;\n    |              ^^^^^^^^^^\n-   |\n-   = note: `U` must be used in combination with a concrete type within the same module\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}, {"sha": "fe578f51b63a0e4280b580764c0458b5eb7f5139", "filename": "src/test/ui/lint/lint-ctypes-73249-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -23,7 +23,7 @@ pub struct A<T: Foo> {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A<()>; //~ ERROR: uses type `Qux`\n+    pub fn lint_me() -> A<()>; //~ ERROR: uses type `impl Baz`\n }\n \n fn main() {}"}, {"sha": "36dbe3217d75ada5d0e445ea6b3f217c669109cf", "filename": "src/test/ui/lint/lint-ctypes-73249-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `Qux`, which is not FFI-safe\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-2.rs:26:25\n    |\n LL |     pub fn lint_me() -> A<()>;"}, {"sha": "ec12de00739e4b7a24ad66fc80e0e7523ae4a4a4", "filename": "src/test/ui/lint/lint-ctypes-73249-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -17,7 +17,7 @@ pub struct A {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A; //~ ERROR: uses type `Qux`\n+    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n }\n \n fn main() {}"}, {"sha": "e987ec90228c1d4bc19027c8a4da6f8e4fe4b8e0", "filename": "src/test/ui/lint/lint-ctypes-73249-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `Qux`, which is not FFI-safe\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-3.rs:20:25\n    |\n LL |     pub fn lint_me() -> A;"}, {"sha": "58c2d7a501ad5060a4b2991b41f40c25bdf44d99", "filename": "src/test/ui/lint/lint-ctypes-73249-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -17,7 +17,7 @@ pub struct A {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A; //~ ERROR: uses type `Qux`\n+    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n }\n \n fn main() {}"}, {"sha": "749714c7df8d7535a446ac02a182f62890736157", "filename": "src/test/ui/lint/lint-ctypes-73249-5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `Qux`, which is not FFI-safe\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-5.rs:20:25\n    |\n LL |     pub fn lint_me() -> A;"}, {"sha": "dc4c7efd7ef233e5b5be66822eff261c43594b9d", "filename": "src/test/ui/lint/lint-ctypes-73251-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -20,7 +20,7 @@ fn assign() -> Qux {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `Qux`\n+    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `impl Baz`\n }\n \n fn main() {}"}, {"sha": "505ccd5a930ce4de02f6e80852f954da8c681e6b", "filename": "src/test/ui/lint/lint-ctypes-73251-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `Qux`, which is not FFI-safe\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73251-1.rs:23:25\n    |\n LL |     pub fn lint_me() -> <u32 as Foo>::Assoc;"}, {"sha": "717ca4986f700e6e0fca62692bfb1790f8eb656f", "filename": "src/test/ui/lint/lint-ctypes-73251-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -33,7 +33,7 @@ fn use_of_b() -> AliasB {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `AliasA`\n+    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `impl TraitA<Assoc = u32>`\n }\n \n fn main() {}"}, {"sha": "d7e10db441ec23eb11ca485e468a1bb96785682b", "filename": "src/test/ui/lint/lint-ctypes-73251-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `AliasA`, which is not FFI-safe\n+error: `extern` block uses type `impl TraitA<Assoc = u32>`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73251-2.rs:36:25\n    |\n LL |     pub fn lint_me() -> <AliasB as TraitB>::Assoc;"}, {"sha": "3a62b6a21a56a6dc859d77adc2bece27ea285ebc", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -9,7 +9,7 @@ pub fn ret_closure() -> A {\n \n extern \"C\" {\n     pub fn a(_: A);\n-    //~^ ERROR `extern` block uses type `A`, which is not FFI-safe [improper_ctypes]\n+    //~^ ERROR `extern` block uses type `impl Fn()`, which is not FFI-safe [improper_ctypes]\n }\n \n fn main() {}"}, {"sha": "5afbef778b3e35d29b38472d517b0f48729794fd", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `A`, which is not FFI-safe\n+error: `extern` block uses type `impl Fn()`, which is not FFI-safe\n   --> $DIR/opaque-ty-ffi-unsafe.rs:11:17\n    |\n LL |     pub fn a(_: A);"}, {"sha": "3b896ec9d70c2b1200b37bf22bd922d8e618cfb6", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,8 +6,7 @@ fn main() {}\n \n trait T {}\n \n-fn should_ret_unit() {\n-    foo(panic!()) //~ ERROR\n+fn should_ret_unit() -> impl T {\n+    //~^ ERROR the trait bound `(): T` is not satisfied\n+    panic!()\n }\n-\n-fn foo(_: impl T) {}"}, {"sha": "670f76867ce45122b29e6ebba4a3c628318c9507", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,8 @@\n error[E0277]: the trait bound `(): T` is not satisfied\n-  --> $DIR/feature-gate-never_type_fallback.rs:10:5\n+  --> $DIR/feature-gate-never_type_fallback.rs:9:25\n    |\n-LL |     foo(panic!())\n-   |     ^^^ the trait `T` is not implemented for `()`\n-   |\n-note: required by a bound in `foo`\n-  --> $DIR/feature-gate-never_type_fallback.rs:13:16\n-   |\n-LL | fn foo(_: impl T) {}\n-   |                ^ required by this bound in `foo`\n+LL | fn should_ret_unit() -> impl T {\n+   |                         ^^^^^^ the trait `T` is not implemented for `()`\n \n error: aborting due to previous error\n "}, {"sha": "cc9520c1b24c8818d8584b08c193f1764b997ae5", "filename": "src/test/ui/never_type/impl_trait_fallback.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,10 +0,0 @@\n-// check-pass\n-\n-fn main() {}\n-\n-trait T {}\n-impl T for () {}\n-\n-fn should_ret_unit() -> impl T {\n-    panic!()\n-}"}, {"sha": "f73d953bdbd0b6e10aaf2d268e53d2a802a315de", "filename": "src/test/ui/never_type/impl_trait_fallback2.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,21 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-fn main() {}\n-\n-trait T {}\n-impl T for i32 {}\n-\n-fn should_ret_unit() -> impl T {\n-    //~^ ERROR `(): T` is not satisfied\n-    panic!()\n-}\n-\n-type Foo = impl T;\n-\n-fn a() -> Foo {\n-    panic!()\n-}\n-\n-fn b() -> Foo {\n-    42\n-}"}, {"sha": "2f50b9d245900f0bb1f6c90c68085b3f755b06e5", "filename": "src/test/ui/never_type/impl_trait_fallback2.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,9 +0,0 @@\n-error[E0277]: the trait bound `(): T` is not satisfied\n-  --> $DIR/impl_trait_fallback2.rs:8:25\n-   |\n-LL | fn should_ret_unit() -> impl T {\n-   |                         ^^^^^^ the trait `T` is not implemented for `()`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "26ce9b93105e6fc3ed4c3c8f2c6e576b4bae96aa", "filename": "src/test/ui/never_type/impl_trait_fallback3.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,15 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-fn main() {}\n-\n-trait T {\n-    type Assoc;\n-}\n-\n-type Foo = impl T;\n-//~^ ERROR unconstrained opaque type\n-\n-fn a() -> Foo {\n-    // This is not a defining use, it doesn't actually constrain the opaque type.\n-    panic!()\n-}"}, {"sha": "121019d5f69aefe3739137e5f63c63b78a6a8030", "filename": "src/test/ui/never_type/impl_trait_fallback3.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/impl_trait_fallback3.rs:9:12\n-   |\n-LL | type Foo = impl T;\n-   |            ^^^^^^\n-   |\n-   = note: `Foo` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to previous error\n-"}, {"sha": "fe62773fa02dbd2be3cb1f9d8e03a4faf45357cf", "filename": "src/test/ui/never_type/impl_trait_fallback4.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,24 +0,0 @@\n-#![feature(type_alias_impl_trait)]\n-\n-trait T {\n-    type Assoc: Cake;\n-}\n-\n-trait Cake: std::fmt::Display {\n-    fn cake() -> Self;\n-}\n-\n-type Foo = impl T;\n-\n-fn foo() -> impl T {\n-    //~^ ERROR `(): T` is not satisfied\n-    panic!()\n-}\n-\n-fn a() -> Foo {\n-    foo()\n-}\n-\n-fn main() {\n-    println!(\"{}\", <Foo as T>::Assoc::cake());\n-}"}, {"sha": "f2e216e9044c00a50eac5adb4728813370bc3881", "filename": "src/test/ui/never_type/impl_trait_fallback4.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,9 +0,0 @@\n-error[E0277]: the trait bound `(): T` is not satisfied\n-  --> $DIR/impl_trait_fallback4.rs:13:13\n-   |\n-LL | fn foo() -> impl T {\n-   |             ^^^^^^ the trait `T` is not implemented for `()`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "0d7ee0376924dc618028d5db3d1b02375ce180cd", "filename": "src/test/ui/nll/issue-52113.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -29,9 +29,9 @@ fn produce3<'a, 'b: 'a>(data: &'a mut Vec<&'a u32>, value: &'b u32) -> impl Bazi\n fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n     let x = move || {\n         let value: &'a u32 = value;\n-        data.push(value); //~ ERROR lifetime may not live long enough\n+        data.push(value);\n     };\n-    x\n+    x //~ ERROR lifetime may not live long enough\n }\n \n fn main() {}"}, {"sha": "f70ae2edd7facd8555ad362fca93853a7a72edfe", "filename": "src/test/ui/nll/issue-52113.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,13 +1,13 @@\n error: lifetime may not live long enough\n-  --> $DIR/issue-52113.rs:32:9\n+  --> $DIR/issue-52113.rs:34:5\n    |\n LL | fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n ...\n-LL |         data.push(value);\n-   |         ^^^^^^^^^^^^^^^^ argument requires that `'a` must outlive `'b`\n+LL |     x\n+   |     ^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n "}, {"sha": "e29ba09b3694dbabcc901566b2d72813a67f55c0", "filename": "src/test/ui/nll/issue-73159-rpit-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -7,8 +7,8 @@ struct Foo<'a>(&'a [u8]);\n \n impl<'a> Foo<'a> {\n     fn make_it(&self) -> impl Iterator<Item = u8> {\n-        self.0.iter().copied()\n         //~^ ERROR: captures lifetime that does not appear in bounds\n+        self.0.iter().copied()\n     }\n }\n "}, {"sha": "6c7cd0c8254938c8b1f49c5abe5dd03cca59eb1c", "filename": "src/test/ui/nll/issue-73159-rpit-static.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-73159-rpit-static.rs:10:9\n+  --> $DIR/issue-73159-rpit-static.rs:9:26\n    |\n LL | impl<'a> Foo<'a> {\n    |      -- hidden type `Copied<std::slice::Iter<'a, u8>>` captures the lifetime `'a` as defined here\n LL |     fn make_it(&self) -> impl Iterator<Item = u8> {\n-LL |         self.0.iter().copied()\n-   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8af23aad7261b80a3bdba5c104be56bcb8abb76f", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,8 +8,8 @@ trait Foo<'a> {\n impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n+//~^ ERROR captures lifetime that does not appear in bounds\n     x\n-    //~^ ERROR captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "3e6fe789a8b55a71856e2f1606b5230c0e010161", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/impl-trait-captures.rs:11:5\n+  --> $DIR/impl-trait-captures.rs:10:25\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-   |                  -- hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n-LL |     x\n-   |     ^\n+   |                  --     ^^^^^^^^^^^^\n+   |                  |\n+   |                  hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n    |\n help: to declare that the `impl Trait` captures `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0))`, you can add an explicit `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0))` lifetime bound\n    |"}, {"sha": "0c7d8acb05223e2b3c8f918c6aaf7e0d8c5458b3", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,11 +5,11 @@\n use std::fmt::Debug;\n \n fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: Debug,\n {\n     x\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n@@ -20,11 +20,11 @@ where\n }\n \n fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: 'b + Debug,\n {\n     x\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a"}, {"sha": "053aef951f2644e2452fc13e464a9e0626dd1371", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,16 +1,16 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:11:5\n+  --> $DIR/impl-trait-outlives.rs:7:35\n    |\n-LL |     x\n-   |     ^\n+LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                   ^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:26:5\n+  --> $DIR/impl-trait-outlives.rs:22:42\n    |\n-LL |     x\n-   |     ^\n+LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                          ^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n "}, {"sha": "91a63bafd99a9688d6847e380c863a8ee8768dca", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -9,9 +9,8 @@ fn main() {\n     unsafe fn ff2() {} // OK.\n     const fn ff3() {} // OK.\n     extern \"C\" fn ff4() {} // OK.\n-    const async unsafe extern \"C\" fn ff5() {}\n+    const async unsafe extern \"C\" fn ff5() {} // OK.\n     //~^ ERROR functions cannot be both `const` and `async`\n-    //~| ERROR cycle detected\n \n     trait X {\n         async fn ft1(); //~ ERROR functions in traits cannot be declared `async`\n@@ -27,14 +26,15 @@ fn main() {\n     struct Y;\n     impl X for Y {\n         async fn ft1() {} //~ ERROR functions in traits cannot be declared `async`\n+        //~^ ERROR method `ft1` has an incompatible type for trait\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR functions in traits cannot be declared const\n         extern \"C\" fn ft4() {}\n         const async unsafe extern \"C\" fn ft5() {}\n         //~^ ERROR functions in traits cannot be declared `async`\n         //~| ERROR functions in traits cannot be declared const\n+        //~| ERROR method `ft5` has an incompatible type for trait\n         //~| ERROR functions cannot be both `const` and `async`\n-        //~| ERROR cycle detected\n     }\n \n     impl Y {\n@@ -44,7 +44,6 @@ fn main() {\n         extern \"C\" fn fi4() {} // OK.\n         const async unsafe extern \"C\" fn fi5() {}\n         //~^ ERROR functions cannot be both `const` and `async`\n-        //~| ERROR cycle detected\n     }\n \n     extern \"C\" {"}, {"sha": "8eaba559a6240b68ee31a730574a5a763f5ec850", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 41, "deletions": 113, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,14 @@\n error: functions cannot be both `const` and `async`\n   --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {}\n+LL |     const async unsafe extern \"C\" fn ff5() {} // OK.\n    |     ^^^^^-^^^^^------------------------------\n    |     |     |\n    |     |     `async` because of this\n    |     `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:17:9\n+  --> $DIR/fn-header-semantic-fail.rs:16:9\n    |\n LL |         async fn ft1();\n    |         -----^^^^^^^^^^\n@@ -19,19 +19,19 @@ LL |         async fn ft1();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:19:9\n+  --> $DIR/fn-header-semantic-fail.rs:18:9\n    |\n LL |         const fn ft3();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:21:9\n+  --> $DIR/fn-header-semantic-fail.rs:20:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:21:9\n+  --> $DIR/fn-header-semantic-fail.rs:20:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,7 +42,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:21:9\n+  --> $DIR/fn-header-semantic-fail.rs:20:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^-^^^^^----------------------------\n@@ -51,7 +51,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    |         `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:29:9\n+  --> $DIR/fn-header-semantic-fail.rs:28:9\n    |\n LL |         async fn ft1() {}\n    |         -----^^^^^^^^^^^^\n@@ -103,7 +103,7 @@ LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         `const` because of this\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:51:18\n+  --> $DIR/fn-header-semantic-fail.rs:50:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -116,7 +116,7 @@ LL |         fn fe1();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:52:19\n+  --> $DIR/fn-header-semantic-fail.rs:51:19\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -130,7 +130,7 @@ LL |         fn fe2();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:53:18\n+  --> $DIR/fn-header-semantic-fail.rs:52:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -144,7 +144,7 @@ LL |         fn fe3();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:54:23\n+  --> $DIR/fn-header-semantic-fail.rs:53:23\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -158,7 +158,7 @@ LL |         fn fe4();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:55:42\n+  --> $DIR/fn-header-semantic-fail.rs:54:42\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -172,123 +172,51 @@ LL |         fn fe5();\n    |         ~~\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:55:9\n+  --> $DIR/fn-header-semantic-fail.rs:54:9\n    |\n LL |         const async unsafe extern \"C\" fn fe5();\n    |         ^^^^^-^^^^^----------------------------\n    |         |     |\n    |         |     `async` because of this\n    |         `const` because of this\n \n-error[E0391]: cycle detected when computing type of `main::ff5::{opaque#0}`\n-  --> $DIR/fn-header-semantic-fail.rs:12:44\n+error[E0053]: method `ft1` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:28:24\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {}\n-   |                                            ^\n-   |\n-note: ...which requires borrow-checking `main::ff5`...\n-  --> $DIR/fn-header-semantic-fail.rs:12:5\n-   |\n-LL |     const async unsafe extern \"C\" fn ff5() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::ff5`...\n-  --> $DIR/fn-header-semantic-fail.rs:12:5\n+LL |         async fn ft1() {}\n+   |                        ^\n+   |                        |\n+   |                        checked the `Output` of this `async fn`, found opaque type\n+   |                        expected `()`, found opaque type\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const checking `main::ff5`...\n-  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/fn-header-semantic-fail.rs:16:23\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n-   = note: ...which again requires computing type of `main::ff5::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/fn-header-semantic-fail.rs:5:1\n-   |\n-LL | / #![feature(const_extern_fn)]\n-LL | |\n-LL | | fn main() {\n-LL | |     async fn ff1() {} // OK.\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL |         async fn ft1();\n+   |                       ^\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl Future<Output = ()>`\n \n-error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5::{opaque#0}`\n+error[E0053]: method `ft5` has an incompatible type for trait\n   --> $DIR/fn-header-semantic-fail.rs:33:48\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |                                                ^\n+   |                                                |\n+   |                                                checked the `Output` of this `async fn`, found opaque type\n+   |                                                expected `()`, found opaque type\n    |\n-note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n-  --> $DIR/fn-header-semantic-fail.rs:33:9\n-   |\n-LL |         const async unsafe extern \"C\" fn ft5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n-  --> $DIR/fn-header-semantic-fail.rs:33:9\n-   |\n-LL |         const async unsafe extern \"C\" fn ft5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n-  --> $DIR/fn-header-semantic-fail.rs:33:9\n-   |\n-LL |         const async unsafe extern \"C\" fn ft5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n-   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/fn-header-semantic-fail.rs:5:1\n-   |\n-LL | / #![feature(const_extern_fn)]\n-LL | |\n-LL | | fn main() {\n-LL | |     async fn ff1() {} // OK.\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n-\n-error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5::{opaque#0}`\n-  --> $DIR/fn-header-semantic-fail.rs:45:48\n-   |\n-LL |         const async unsafe extern \"C\" fn fi5() {}\n-   |                                                ^\n-   |\n-note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n-  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/fn-header-semantic-fail.rs:20:47\n    |\n-LL |         const async unsafe extern \"C\" fn fi5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n-  --> $DIR/fn-header-semantic-fail.rs:45:9\n-   |\n-LL |         const async unsafe extern \"C\" fn fi5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n-  --> $DIR/fn-header-semantic-fail.rs:45:9\n-   |\n-LL |         const async unsafe extern \"C\" fn fi5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n-   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/fn-header-semantic-fail.rs:5:1\n-   |\n-LL | / #![feature(const_extern_fn)]\n-LL | |\n-LL | | fn main() {\n-LL | |     async fn ff1() {} // OK.\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |                                               ^\n+   = note: expected fn pointer `unsafe extern \"C\" fn()`\n+              found fn pointer `unsafe extern \"C\" fn() -> impl Future<Output = ()>`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n \n-Some errors have detailed explanations: E0379, E0391, E0706.\n-For more information about an error, try `rustc --explain E0379`.\n+Some errors have detailed explanations: E0053, E0379, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "f295cf15d08c6005d850282b4ce3c36b790942f2", "filename": "src/test/ui/polymorphization/generators.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -32,6 +32,7 @@ where\n \n #[rustc_polymorphize_error]\n pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n+    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;\n@@ -57,6 +58,7 @@ pub fn used_type_in_return<R: Default>() -> impl Generator<(), Yield = u32, Retu\n \n #[rustc_polymorphize_error]\n pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n+    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;"}, {"sha": "c4e566a42d0cf53db6b4b69cdbaae952ab6da273", "filename": "src/test/ui/polymorphization/generators.stderr", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,10 +8,11 @@ LL | #![feature(generic_const_exprs, generators, generator_trait, rustc_attrs)]\n    = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:35:5\n+  --> $DIR/generators.rs:36:5\n    |\n LL |   pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                      - generic parameter `T` is unused\n+LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n@@ -20,16 +21,29 @@ LL | |     }\n    | |_____^\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:60:5\n+  --> $DIR/generators.rs:34:8\n+   |\n+LL | pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n+   |        ^^^^^^^^^^^ - generic parameter `T` is unused\n+\n+error: item has unused generic parameters\n+  --> $DIR/generators.rs:62:5\n    |\n LL |   pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                             - generic parameter `T` is unused\n+LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n LL | |         2\n LL | |     }\n    | |_____^\n \n-error: aborting due to 2 previous errors; 1 warning emitted\n+error: item has unused generic parameters\n+  --> $DIR/generators.rs:60:8\n+   |\n+LL | pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n+   |        ^^^^^^^^^^^^       - generic parameter `T` is unused\n+\n+error: aborting due to 4 previous errors; 1 warning emitted\n "}, {"sha": "cc36f054bc3a0c3ca9b2a4f170d708537d9c8e0d", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -14,6 +14,7 @@ trait B {\n impl B for A {\n     async fn associated(); //~ ERROR without body\n     //~^ ERROR cannot be declared `async`\n+    //~| ERROR incompatible type for trait\n }\n \n fn main() {}"}, {"sha": "d3214458eac13cc8f89bedfcf498812c5aad6116", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -44,6 +44,25 @@ LL |     async fn associated();\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-error: aborting due to 5 previous errors\n+error[E0053]: method `associated` has an incompatible type for trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:26\n+   |\n+LL |     async fn associated();\n+   |                          ^\n+   |                          |\n+   |                          checked the `Output` of this `async fn`, found opaque type\n+   |                          expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:11:26\n+   |\n+LL |     async fn associated();\n+   |                          ^\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl Future<Output = ()>`\n+\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0706`.\n+Some errors have detailed explanations: E0053, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "96af085c5b6b8d8692ed0c7d8e2f196447589cf1", "filename": "src/test/ui/save-analysis/issue-68621.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,7 +11,7 @@ trait Service {\n struct Struct;\n \n impl Service for Struct {\n-    type Future = impl Trait; //~ ERROR: unconstrained opaque type\n+    type Future = impl Trait; //~ ERROR: could not find defining uses\n }\n \n fn main() {}"}, {"sha": "3af6d0a3e076e74dcfb886c0e0d77e79037a64a2", "filename": "src/test/ui/save-analysis/issue-68621.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,8 @@\n-error: unconstrained opaque type\n+error: could not find defining uses\n   --> $DIR/issue-68621.rs:14:19\n    |\n LL |     type Future = impl Trait;\n    |                   ^^^^^^^^^^\n-   |\n-   = note: `Future` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "61ac7731777b473f1fe0ebbf445a980139e60ce7", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -                     ^^^^^^^^\n+   |                          -          ^^^^^^^^^^\n    |                          |\n    |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n    |"}, {"sha": "6f8200739b9deb222f6cd6ff7a7bd4d96380251a", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                    -----                   ^^^^\n+   |                    -----      ^^^^^^^^^^\n    |                    |\n    |                    hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |"}, {"sha": "d826222a06ae5d95fbd5838bc2b3fac95821e218", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,10 @@\n error[E0277]: the trait bound `(): Bar` is not satisfied\n-  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:22\n+  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:13\n    |\n-LL |   fn foo() -> impl Bar {\n-   |  ______________________^\n-LL | |     5;\n-LL | | }\n-   | |_^ the trait `Bar` is not implemented for `()`\n+LL | fn foo() -> impl Bar {\n+   |             ^^^^^^^^ the trait `Bar` is not implemented for `()`\n+LL |     5;\n+   |      - consider removing this semicolon\n \n error: aborting due to previous error\n "}, {"sha": "2a72159e5774bbc3e1fbb2fd6e000b036682567f", "filename": "src/test/ui/suggestions/issue-81098.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,23 +1,19 @@\n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:3:37\n+  --> $DIR/issue-81098.rs:3:13\n    |\n-LL |   fn wat() -> impl core::fmt::Display {\n-   |  _____________________________________^\n-LL | |     fn why() {}\n-LL | | }\n-   | |_^ `()` cannot be formatted with the default formatter\n+LL | fn wat() -> impl core::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n \n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:9:36\n+  --> $DIR/issue-81098.rs:9:12\n    |\n-LL |   fn ok() -> impl core::fmt::Display {\n-   |  ____________________________________^\n-LL | |     1;\n-LL | | }\n-   | |_^ `()` cannot be formatted with the default formatter\n+LL | fn ok() -> impl core::fmt::Display {\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n+LL |     1;\n+   |      - consider removing this semicolon\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead"}, {"sha": "a5b50634c71ea28103dbce76f4adef2b038b4a7f", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -7,18 +7,13 @@ LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used and required to live as long as `'static` here\n+   |                        ...is used here...\n    |\n-note: `'static` lifetime requirement introduced by the return type\n+note: ...and is required to live as long as `'static` here\n   --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n    |\n-LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n-LL | /         Iter {\n-LL | |             current: None,\n-LL | |             remaining: self.0.iter(),\n-LL | |         }\n-   | |_________- because of this returned expression\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n@@ -37,18 +32,13 @@ LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used and required to live as long as `'static` here\n+   |                        ...is used here...\n    |\n-note: `'static` lifetime requirement introduced by the return type\n+note: ...and is required to live as long as `'static` here\n   --> $DIR/trait-object-nested-in-impl-trait.rs:38:23\n    |\n-LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n-LL | /         Iter {\n-LL | |             current: None,\n-LL | |             remaining: self.0.iter(),\n-LL | |         }\n-   | |_________- because of this returned expression\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n@@ -63,18 +53,13 @@ LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used and required to live as long as `'static` here\n+   |                        ...is used here...\n    |\n-note: `'static` lifetime requirement introduced by the return type\n+note: ...and is required to live as long as `'static` here\n   --> $DIR/trait-object-nested-in-impl-trait.rs:49:30\n    |\n-LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n-LL | /         Iter {\n-LL | |             current: None,\n-LL | |             remaining: self.0.iter(),\n-LL | |         }\n-   | |_________- because of this returned expression\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n@@ -89,18 +74,13 @@ LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used and required to live as long as `'static` here\n+   |                        ...is used here...\n    |\n-note: `'static` lifetime requirement introduced by the return type\n+note: ...and is required to live as long as `'static` here\n   --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n    |\n-LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n-LL | /         Iter {\n-LL | |             current: None,\n-LL | |             remaining: self.0.iter(),\n-LL | |         }\n-   | |_________- because of this returned expression\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {"}, {"sha": "6aa93a24d2f04badad96d70142113ee6b07a00f6", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -16,9 +16,6 @@ fn extra_semicolon() {\n async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE while checking the return type of the `async fn`\n //~| NOTE in this expansion of desugaring of `async` block or function\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-//~| NOTE checked the `Output` of this `async fn`, expected opaque type\n async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE while checking the return type of the `async fn`\n@@ -34,7 +31,7 @@ async fn async_extra_semicolon_same() {\n         }\n         false => async_dummy(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n-        //~| NOTE expected unit type `()`\n+        //~| NOTE expected type `()`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -47,7 +44,7 @@ async fn async_extra_semicolon_different() {\n         }\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n-        //~| NOTE expected unit type `()`\n+        //~| NOTE expected type `()`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -58,7 +55,7 @@ async fn async_different_futures() {\n         //~| HELP consider `await`ing on both `Future`s\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected opaque type, found a different opaque type\n-        //~| NOTE expected opaque type `impl Future<Output = ()>`\n+        //~| NOTE expected type `impl Future<Output = ()>`\n         //~| NOTE distinct uses of `impl Trait` result in different opaque types\n     };\n }"}, {"sha": "b55c51b92809a35f5d9e020a6d0db9ee332d5afa", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:35:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:32:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -20,8 +20,8 @@ note: while checking the return type of the `async fn`\n    |\n LL | async fn async_dummy() {}\n    |                        ^ checked the `Output` of this `async fn`, found opaque type\n-   = note: expected unit type `()`\n-            found opaque type `impl Future<Output = ()>`\n+   = note:     expected type `()`\n+           found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy().await,\n@@ -33,7 +33,7 @@ LL +             async_dummy()\n    | \n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:48:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:45:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -50,12 +50,12 @@ LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n+  --> $DIR/match-prev-arm-needing-semi.rs:19:25\n    |\n LL | async fn async_dummy2() {}\n    |                         ^ checked the `Output` of this `async fn`, found opaque type\n-   = note: expected unit type `()`\n-            found opaque type `impl Future<Output = ()>`\n+   = note:     expected type `()`\n+           found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy2().await,\n@@ -69,7 +69,7 @@ LL ~         false => Box::new(async_dummy2()),\n    |\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:59:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:56:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -84,17 +84,12 @@ LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:16:24\n-   |\n-LL | async fn async_dummy() {}\n-   |                        ^ checked the `Output` of this `async fn`, expected opaque type\n-note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n+  --> $DIR/match-prev-arm-needing-semi.rs:19:25\n    |\n LL | async fn async_dummy2() {}\n    |                         ^ checked the `Output` of this `async fn`, found opaque type\n-   = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n-              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:22:25>)\n+   = note:     expected type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n+           found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:19:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "e065e0aaa8e0622480eef0c1d5d679d706a8ce28", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,9 +1,6 @@\n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/opaque-type-error.rs:20:9\n    |\n-LL |   fn thing_one() -> impl Future<Output = Result<(), ()>> {\n-   |                     ------------------------------------ the expected opaque type\n-...\n LL |   fn thing_two() -> impl Future<Output = Result<(), ()>> {\n    |                     ------------------------------------ the found opaque type\n ...\n@@ -16,8 +13,8 @@ LL | |         thing_two()\n LL | |     }.await\n    | |_____- `if` and `else` have incompatible types\n    |\n-   = note: expected opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n-              found opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n+   = note:     expected type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n+           found opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "0013d5d66f172389733c6123a51f0394ef2f1da4", "filename": "src/test/ui/traits/alias/issue-83613.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,6 +8,6 @@ fn mk_opaque() -> OpaqueType {\n trait AnotherTrait {}\n impl<T: Send> AnotherTrait for T {}\n impl AnotherTrait for OpaqueType {}\n-//~^ ERROR conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n+//~^ ERROR conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n //~| ERROR cannot implement trait on type alias impl trait\n fn main() {}"}, {"sha": "6a3498a389375e3806243cde691d6ae85f3064c0", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -10,13 +10,13 @@ note: type alias impl trait defined here\n LL | type OpaqueType = impl OpaqueTrait;\n    |                   ^^^^^^^^^^^^^^^^\n \n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n   --> $DIR/issue-83613.rs:10:1\n    |\n LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n LL | impl AnotherTrait for OpaqueType {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `impl OpaqueTrait`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8427b5b1fe854eec5fc8690e47951c65049559d6", "filename": "src/test/ui/type-alias-impl-trait/argument-types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,12 +1,14 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n-// check-pass\n+\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n \n+// FIXME: This should compile, but it currently doesn't\n fn foo1(mut x: Foo) {\n     x = 22_u32;\n+    //~^ ERROR: mismatched types [E0308]\n }\n \n fn foo2(mut x: Foo) {"}, {"sha": "a87e44a048b250c09704b31158b51aacf0c8a60c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,17 @@\n+error[E0308]: mismatched types\n+  --> $DIR/argument-types.rs:10:9\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the expected opaque type\n+...\n+LL | fn foo1(mut x: Foo) {\n+   |                --- expected due to this parameter type\n+LL |     x = 22_u32;\n+   |         ^^^^^^ expected opaque type, found `u32`\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4a49d6e4ab8fd7aaac23229cdcfea5e659138662", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -2,15 +2,15 @@ error[E0277]: `Rc<u32>` cannot be sent between threads safely\n   --> $DIR/auto-trait-leakage2.rs:17:13\n    |\n LL |     type Foo = impl std::fmt::Debug;\n-   |                -------------------- within this `Foo`\n+   |                -------------------- within this `impl Debug`\n ...\n LL |     is_send(m::foo());\n    |     ------- ^^^^^^^^ `Rc<u32>` cannot be sent between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `Foo`, the trait `Send` is not implemented for `Rc<u32>`\n-   = note: required because it appears within the type `Foo`\n+   = help: within `impl Debug`, the trait `Send` is not implemented for `Rc<u32>`\n+   = note: required because it appears within the type `impl Debug`\n note: required by a bound in `is_send`\n   --> $DIR/auto-trait-leakage2.rs:14:15\n    |"}, {"sha": "5fb7a9473d3dfbc57cef2537e10e59729a553908", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,7 +6,6 @@\n mod m {\n     type Foo = impl std::fmt::Debug;\n     //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n-    //~| ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n \n     pub fn foo() -> Foo {\n         22_u32"}, {"sha": "c0147e56c9364a6bb2d3f99d8c1f014a20768539", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.stderr", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,35 +5,18 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/auto-trait-leakage3.rs:15:5\n+  --> $DIR/auto-trait-leakage3.rs:15:9\n    |\n-LL |     pub fn bar() {\n-   |     ^^^^^^^^^^^^\n+LL |         is_send(foo());\n+   |         ^^^^^^^\n+   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/auto-trait-leakage3.rs:6:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n-  --> $DIR/auto-trait-leakage3.rs:7:16\n-   |\n-LL |     type Foo = impl std::fmt::Debug;\n-   |                ^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires type-checking `m::bar`...\n-  --> $DIR/auto-trait-leakage3.rs:15:5\n-   |\n-LL |     pub fn bar() {\n-   |     ^^^^^^^^^^^^\n-   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in module `m`\n-  --> $DIR/auto-trait-leakage3.rs:6:1\n-   |\n-LL | mod m {\n-   | ^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "cee8186dd8f8c432c3a2ccf10f49ae3822e120f5", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -7,12 +7,13 @@ trait TraitWithAssoc {\n }\n \n type Foo<V> = impl Trait<V>;\n+//~^ ERROR could not find defining uses\n \n trait Trait<U> {}\n \n impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+    //~^ ERROR non-defining opaque type use in defining scope\n     ()\n-    //~^ ERROR non-defining opaque type use\n }"}, {"sha": "03e696fe8980376392a3df6e8219d9ae3dbd03fc", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,20 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:5\n+  --> $DIR/bound_reduction2.rs:16:46\n    |\n-LL |     ()\n-   |     ^^\n+LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+   |                                              ^^^^^^^^^^^^^\n    |\n note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n   --> $DIR/bound_reduction2.rs:9:10\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |          ^\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/bound_reduction2.rs:9:15\n+   |\n+LL | type Foo<V> = impl Trait<V>;\n+   |               ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "eecef2338c146095d6e4ae31c4cc73c5612fc10a", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,11 +4,11 @@\n #![feature(type_alias_impl_trait)]\n \n type X<'a> = impl Into<&'static str> + From<&'a str>;\n+//~^ ERROR mismatched types\n \n fn f<'a: 'static>(t: &'a str) -> X<'a> {\n     //~^ WARNING unnecessary lifetime parameter\n     t\n-    //~^ ERROR non-defining opaque type use\n }\n \n fn extend_lt<'a>(o: &'a str) -> &'static str {"}, {"sha": "da9f81d6bd370cbebfb09a3d4b95c9fa89cd9d4e", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,19 +1,26 @@\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/bounds-are-checked.rs:8:6\n+  --> $DIR/bounds-are-checked.rs:9:6\n    |\n LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n    |      ^^^^^^^^^^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/bounds-are-checked.rs:10:5\n+error[E0308]: mismatched types\n+  --> $DIR/bounds-are-checked.rs:6:14\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |        -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n-...\n-LL |     t\n-   |     ^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected trait `From<&'a str>`\n+              found trait `From<&'static str>`\n+note: the lifetime `'a` as defined here...\n+  --> $DIR/bounds-are-checked.rs:6:8\n+   |\n+LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n+   |        ^^\n+   = note: ...does not necessarily outlive the static lifetime\n \n error: aborting due to previous error; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c4bf56a919721140d2f3168ebd76ef65c9673ecc", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,4 +3,4 @@\n fn main() {}\n \n // declared but never defined\n-type Bar = impl std::fmt::Debug; //~ ERROR unconstrained opaque type\n+type Bar = impl std::fmt::Debug; //~ ERROR could not find defining uses"}, {"sha": "21c2e8a9db618ceffe81427738ab2ddc426244b6", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,10 +1,8 @@\n-error: unconstrained opaque type\n+error: could not find defining uses\n   --> $DIR/declared_but_never_defined.rs:6:12\n    |\n LL | type Bar = impl std::fmt::Debug;\n    |            ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `Bar` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "7ea517eb734a459701bfd6d1887416af6f228559", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -4,7 +4,7 @@ fn main() {}\n \n mod boo {\n     // declared in module but not defined inside of it\n-    pub type Boo = impl ::std::fmt::Debug; //~ ERROR unconstrained opaque type\n+    pub type Boo = impl ::std::fmt::Debug; //~ ERROR could not find defining uses\n }\n \n fn bomp() -> boo::Boo {"}, {"sha": "0b4c262bbb43b97f0a52e7bb8d9a60cc75a83d2c", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,22 +1,22 @@\n-error: unconstrained opaque type\n+error: could not find defining uses\n   --> $DIR/declared_but_not_defined_in_scope.rs:7:20\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `Boo` must be used in combination with a concrete type within the same module\n \n error[E0308]: mismatched types\n   --> $DIR/declared_but_not_defined_in_scope.rs:11:5\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ---------------------- the expected opaque type\n ...\n+LL | fn bomp() -> boo::Boo {\n+   |              -------- expected `impl Debug` because of return type\n LL |     \"\"\n    |     ^^ expected opaque type, found `&str`\n    |\n-   = note: expected opaque type `Boo`\n-                found reference `&str`\n+   = note: expected opaque type `impl Debug`\n+                found reference `&'static str`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "95cbcfec2dc1557762ecb7b9976446b0c62d0234", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,5 +1,5 @@\n #![feature(type_alias_impl_trait)]\n-// check-pass\n+\n fn main() {}\n \n // two definitions with different types\n@@ -10,9 +10,11 @@ fn foo() -> Foo {\n }\n \n fn bar() -> Foo {\n+    //~^ ERROR concrete type differs from previous\n     panic!()\n }\n \n fn boo() -> Foo {\n+    //~^ ERROR concrete type differs from previous\n     loop {}\n }"}, {"sha": "6274029e4f524b0772100efea89953411b7bb57e", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,26 @@\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/different_defining_uses_never_type.rs:12:1\n+   |\n+LL | fn bar() -> Foo {\n+   | ^^^^^^^^^^^^^^^ expected `&'static str`, got `()`\n+   |\n+note: previous use here\n+  --> $DIR/different_defining_uses_never_type.rs:8:1\n+   |\n+LL | fn foo() -> Foo {\n+   | ^^^^^^^^^^^^^^^\n+\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/different_defining_uses_never_type.rs:17:1\n+   |\n+LL | fn boo() -> Foo {\n+   | ^^^^^^^^^^^^^^^ expected `&'static str`, got `()`\n+   |\n+note: previous use here\n+  --> $DIR/different_defining_uses_never_type.rs:8:1\n+   |\n+LL | fn foo() -> Foo {\n+   | ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "fe1ca2230dacade16cd3108df900f4f594ce49cb", "filename": "src/test/ui/type-alias-impl-trait/fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,5 +1,5 @@\n-// Tests that we correctly handle opaque types being used opaquely,\n-// even within their defining scope.\n+// Tests that we correctly handle the instantiated\n+// inference variable being completely unconstrained.\n //\n // check-pass\n #![feature(type_alias_impl_trait)]"}, {"sha": "91494a82d0fb201eaf492bd2932ca974aea52843", "filename": "src/test/ui/type-alias-impl-trait/field-types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,18 +1,20 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n-// check-pass\n+// FIXME This should compile, but it currently doesn't\n \n use std::fmt::Debug;\n \n type Foo = impl Debug;\n+//~^ ERROR: could not find defining uses\n \n struct Bar {\n     foo: Foo,\n }\n \n fn bar() -> Bar {\n     Bar { foo: \"foo\" }\n+    //~^ ERROR: mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "18c2abbdf37213900b5df5746159f6059519ce26", "filename": "src/test/ui/type-alias-impl-trait/field-types.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/field-types.rs:16:16\n+   |\n+LL | type Foo = impl Debug;\n+   |            ---------- the expected opaque type\n+...\n+LL |     Bar { foo: \"foo\" }\n+   |                ^^^^^ expected opaque type, found `&str`\n+   |\n+   = note: expected opaque type `impl Debug`\n+                found reference `&'static str`\n+\n+error: could not find defining uses\n+  --> $DIR/field-types.rs:8:12\n+   |\n+LL | type Foo = impl Debug;\n+   |            ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "885aae619d6a2bf5249b79df995508a4a63b336b", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,9 +3,9 @@\n fn main() {}\n \n type Two<'a, 'b> = impl std::fmt::Debug;\n-\n+//~^ ERROR could not find defining uses\n \n fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n-    t\n     //~^ ERROR non-defining opaque type use\n+    t\n }"}, {"sha": "b99c6a51f4b1d24faa3cf2984eb3d9ff09da53ec", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,20 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_lifetime_param.rs:9:5\n+  --> $DIR/generic_duplicate_lifetime_param.rs:8:26\n    |\n-LL |     t\n-   |     ^\n+LL | fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n+   |                          ^^^^^^^^^^^\n    |\n note: lifetime used multiple times\n   --> $DIR/generic_duplicate_lifetime_param.rs:5:10\n    |\n LL | type Two<'a, 'b> = impl std::fmt::Debug;\n    |          ^^  ^^\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_lifetime_param.rs:5:20\n+   |\n+LL | type Two<'a, 'b> = impl std::fmt::Debug;\n+   |                    ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "33cd2f6ba07539da18608740f78f3efa94f4de54", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,23 +6,23 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type TwoTys<T, U> = impl Debug;\n-\n+//~^ ERROR could not find defining uses\n type TwoLifetimes<'a, 'b> = impl Debug;\n-\n+//~^ ERROR could not find defining uses\n type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n-\n+//~^ ERROR could not find defining uses\n \n fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n-    t\n     //~^ ERROR non-defining opaque type use in defining scope\n+    t\n }\n \n fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n-    t\n     //~^ ERROR non-defining opaque type use in defining scope\n+    t\n }\n \n fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n-    t\n     //~^ ERROR non-defining opaque type use in defining scope\n+    t\n }"}, {"sha": "52c60d1777e49131ecfc4b132c9096dd71b700bb", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,38 +1,56 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:16:5\n+  --> $DIR/generic_duplicate_param_use.rs:15:30\n    |\n-LL |     t\n-   |     ^\n+LL | fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n+   |                              ^^^^^^^^^^^^\n    |\n note: type used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:8:13\n    |\n LL | type TwoTys<T, U> = impl Debug;\n    |             ^  ^\n \n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_param_use.rs:8:21\n+   |\n+LL | type TwoTys<T, U> = impl Debug;\n+   |                     ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:21:5\n+  --> $DIR/generic_duplicate_param_use.rs:20:36\n    |\n-LL |     t\n-   |     ^\n+LL | fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n    |\n note: lifetime used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:10:19\n    |\n LL | type TwoLifetimes<'a, 'b> = impl Debug;\n    |                   ^^  ^^\n \n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_param_use.rs:10:29\n+   |\n+LL | type TwoLifetimes<'a, 'b> = impl Debug;\n+   |                             ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:26:5\n+  --> $DIR/generic_duplicate_param_use.rs:25:50\n    |\n-LL |     t\n-   |     ^\n+LL | fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n+   |                                                  ^^^^^^^^^^^^^^^\n    |\n note: constant used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:12:22\n    |\n LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n    |                      ^               ^\n \n-error: aborting due to 3 previous errors\n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_param_use.rs:12:50\n+   |\n+LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n+   |                                                  ^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "04fb57b39c052c3467fb45d3a7a3ab6cde829cc1", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,6 +8,11 @@ fn main() {}\n type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n+fn one<T: Debug>(t: T) -> Two<T, T> {\n+    //~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n     t\n }"}, {"sha": "fca9b70d1844173127303eb69e8b2ca171e5a9c3", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,3 +1,15 @@\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use2.rs:11:27\n+   |\n+LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n+   |                           ^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use2.rs:8:10\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |          ^  ^\n+\n error[E0277]: `T` doesn't implement `Debug`\n   --> $DIR/generic_duplicate_param_use2.rs:8:18\n    |\n@@ -9,6 +21,6 @@ help: consider restricting type parameter `T`\n LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n    |           +++++++++++++++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "1a755d3902612f125a17b5f5477634743baf941a", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,6 +8,11 @@ fn main() {}\n type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n+fn one<T: Debug>(t: T) -> Two<T, T> {\n+    //~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n     t\n }"}, {"sha": "90b04c043a00ccb1d0fa28571d9e7ffaaa54fdee", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,11 +1,23 @@\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use3.rs:11:27\n+   |\n+LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n+   |                           ^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use3.rs:8:10\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |          ^  ^\n+\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/generic_duplicate_param_use3.rs:15:1\n+  --> $DIR/generic_duplicate_param_use3.rs:20:1\n    |\n LL | fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `T`, got `U`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use3.rs:11:1\n+  --> $DIR/generic_duplicate_param_use3.rs:16:1\n    |\n LL | fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -21,6 +33,6 @@ help: consider restricting type parameter `T`\n LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n    |           +++++++++++++++++\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "50d95c83d58e644600976228707615908d42cec6", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -8,6 +8,11 @@ fn main() {}\n type Two<T, U> = impl Debug;\n //~^ ERROR `U` doesn't implement `Debug`\n \n+fn one<T: Debug>(t: T) -> Two<T, T> {\n+    //~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n     u\n }"}, {"sha": "c4be2fa83f130fd068f7be5f14eddb4ac529ef93", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,3 +1,15 @@\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use4.rs:11:27\n+   |\n+LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n+   |                           ^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use4.rs:8:10\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |          ^  ^\n+\n error[E0277]: `U` doesn't implement `Debug`\n   --> $DIR/generic_duplicate_param_use4.rs:8:18\n    |\n@@ -9,6 +21,6 @@ help: consider restricting type parameter `U`\n LL | type Two<T, U: std::fmt::Debug> = impl Debug;\n    |              +++++++++++++++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "cf43085877f4c7864eefd534a8cb071c130989a6", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,25 +5,25 @@ use std::fmt::Debug;\n fn main() {}\n \n type OneTy<T> = impl Debug;\n-\n+//~^ ERROR could not find defining uses\n type OneLifetime<'a> = impl Debug;\n-\n+//~^ ERROR could not find defining uses\n type OneConst<const X: usize> = impl Debug;\n-\n+//~^ ERROR could not find defining uses\n \n // Not defining uses, because they doesn't define *all* possible generics.\n \n fn concrete_ty() -> OneTy<u32> {\n-    5u32\n     //~^ ERROR non-defining opaque type use in defining scope\n+    5u32\n }\n \n fn concrete_lifetime() -> OneLifetime<'static> {\n-    6u32\n     //~^ ERROR non-defining opaque type use in defining scope\n+    6u32\n }\n \n fn concrete_const() -> OneConst<{ 123 }> {\n-    7u32\n     //~^ ERROR non-defining opaque type use in defining scope\n+    7u32\n }"}, {"sha": "3aa42a25484d1dcc169f6ed6423f5b4ded454225", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,35 +1,53 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:17:5\n+  --> $DIR/generic_nondefining_use.rs:16:21\n    |\n-LL |     5u32\n-   |     ^^^^\n+LL | fn concrete_ty() -> OneTy<u32> {\n+   |                     ^^^^^^^^^^\n    |\n note: used non-generic type `u32` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:7:12\n    |\n LL | type OneTy<T> = impl Debug;\n    |            ^\n \n+error: could not find defining uses\n+  --> $DIR/generic_nondefining_use.rs:7:17\n+   |\n+LL | type OneTy<T> = impl Debug;\n+   |                 ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:22:5\n+  --> $DIR/generic_nondefining_use.rs:21:27\n    |\n LL | type OneLifetime<'a> = impl Debug;\n    |                  -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n ...\n-LL |     6u32\n-   |     ^^^^\n+LL | fn concrete_lifetime() -> OneLifetime<'static> {\n+   |                           ^^^^^^^^^^^^^^^^^^^^\n+\n+error: could not find defining uses\n+  --> $DIR/generic_nondefining_use.rs:9:24\n+   |\n+LL | type OneLifetime<'a> = impl Debug;\n+   |                        ^^^^^^^^^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:27:5\n+  --> $DIR/generic_nondefining_use.rs:26:24\n    |\n-LL |     7u32\n-   |     ^^^^\n+LL | fn concrete_const() -> OneConst<{ 123 }> {\n+   |                        ^^^^^^^^^^^^^^^^^\n    |\n note: used non-generic constant `123_usize` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:11:21\n    |\n LL | type OneConst<const X: usize> = impl Debug;\n    |                     ^\n \n-error: aborting due to 3 previous errors\n+error: could not find defining uses\n+  --> $DIR/generic_nondefining_use.rs:11:33\n+   |\n+LL | type OneConst<const X: usize> = impl Debug;\n+   |                                 ^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "dd6300a64f42e0c95193436578f432aeaedc50db", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,6 +6,6 @@ type WrongGeneric<T: 'static> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n-    v\n     //~^ ERROR type parameter `V` is part of concrete type but not used in parameter list\n+    v\n }"}, {"sha": "8015ff7eded9061fc4f84aec174c66bfe1db052d", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,10 +5,14 @@ LL | type WrongGeneric<T: 'static> = impl 'static;\n    |                                 ^^^^^^^^^^^^\n \n error: type parameter `V` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/generic_not_used.rs:9:5\n+  --> $DIR/generic_not_used.rs:8:73\n    |\n-LL |     v\n-   |     ^\n+LL |   fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n+   |  _________________________________________________________________________^\n+LL | |\n+LL | |     v\n+LL | | }\n+   | |_^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f4e1de8e50f688399b52757f244d6c5200f17405", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,29 +1,41 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n \n-error: non-defining opaque type use in defining scope\n+error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n LL |     let z: i32 = x;\n-   |                  ^\n+   |            ---   ^ expected `i32`, found opaque type\n+   |            |\n+   |            expected due to this\n+...\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                        ------------ the found opaque type\n    |\n-note: used non-generic type `&'static i32` for generic parameter\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:10:19\n+   = note:     expected type `i32`\n+           found opaque type `impl Sized`\n+\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n    |\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                   ^\n+LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n+   |                              ^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:14:5\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n    |\n-LL |     t\n-   |     ^\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                        ^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0310`.\n+Some errors have detailed explanations: E0308, E0310.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "78d25e30e0382eba41de11a042664471784ca8a2", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,14 +3,13 @@\n fn main() {\n     let y = 42;\n     let x = wrong_generic(&y);\n-    let z: i32 = x;\n-    //~^ ERROR non-defining opaque type use\n+    let z: i32 = x; //~ ERROR mismatched types\n }\n \n type WrongGeneric<T> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-    t\n     //~^ ERROR the parameter type `T` may not live long enough\n+    t\n }"}, {"sha": "568784372e5191db73218523175ccec67dafc72c", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,29 +1,32 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n \n-error: non-defining opaque type use in defining scope\n+error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n LL |     let z: i32 = x;\n-   |                  ^\n-   |\n-note: used non-generic type `&'static i32` for generic parameter\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:10:19\n-   |\n+   |            ---   ^ expected `i32`, found opaque type\n+   |            |\n+   |            expected due to this\n+...\n LL | type WrongGeneric<T> = impl 'static;\n-   |                   ^\n+   |                        ------------ the found opaque type\n+   |\n+   = note:     expected type `i32`\n+           found opaque type `impl Sized`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:14:5\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n    |\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     t\n-   |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |                  -           ^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                  |\n+   |                  help: consider adding an explicit lifetime bound...: `T: 'static`\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0310`.\n+Some errors have detailed explanations: E0308, E0310.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "c781e200bf8eeb5532ff513ad89e261ceef424d8", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -3,8 +3,7 @@\n \n mod m {\n     type Foo = impl std::fmt::Debug;\n-    //~^ ERROR cycle detected\n-    //~| ERROR cycle detected\n+    //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n \n     // Cycle: error today, but it'd be nice if it eventually worked\n \n@@ -18,6 +17,7 @@ mod m {\n \n     fn baz() {\n         let f: Foo = 22_u32;\n+        //~^ ERROR: mismatched types [E0308]\n     }\n \n     fn is_send<T: Send>(_: T) {}"}, {"sha": "e12124664778ed249087f4e88bb0011577b7e323", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.stderr", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,35 +5,33 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/inference-cycle.rs:15:5\n+  --> $DIR/inference-cycle.rs:15:9\n    |\n-LL |     pub fn bar() {\n-   |     ^^^^^^^^^^^^\n+LL |         is_send(foo()); // Today: error\n+   |         ^^^^^^^\n+   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/inference-cycle.rs:4:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n-  --> $DIR/inference-cycle.rs:5:16\n+error[E0308]: mismatched types\n+  --> $DIR/inference-cycle.rs:19:22\n    |\n LL |     type Foo = impl std::fmt::Debug;\n-   |                ^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires type-checking `m::bar`...\n-  --> $DIR/inference-cycle.rs:15:5\n-   |\n-LL |     pub fn bar() {\n-   |     ^^^^^^^^^^^^\n-   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n-note: cycle used when checking item types in module `m`\n-  --> $DIR/inference-cycle.rs:4:1\n-   |\n-LL | mod m {\n-   | ^^^^^\n+   |                -------------------- the expected opaque type\n+...\n+LL |         let f: Foo = 22_u32;\n+   |                ---   ^^^^^^ expected opaque type, found `u32`\n+   |                |\n+   |                expected due to this\n+   |\n+   = note: expected opaque type `impl Debug`\n+                     found type `u32`\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+Some errors have detailed explanations: E0308, E0391.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "37b330ba4b8fc39620c1b612155a76968db5b36b", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -18,8 +18,8 @@ impl Foo for S2 {\n     type Item = impl Debug;\n \n     fn foo<T: Debug>(_: T) -> Self::Item {\n-        S::<T>(Default::default())\n         //~^ Error type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        S::<T>(Default::default())\n     }\n }\n "}, {"sha": "4c8144a2359309a5f19a7724d317b9f0e2c91ec1", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,12 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-53598.rs:21:9\n+  --> $DIR/issue-53598.rs:20:42\n    |\n-LL |         S::<T>(Default::default())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn foo<T: Debug>(_: T) -> Self::Item {\n+   |  __________________________________________^\n+LL | |\n+LL | |         S::<T>(Default::default())\n+LL | |     }\n+   | |_____^\n \n error: aborting due to previous error\n "}, {"sha": "a4ccae4eb7ed99e7b5b49de3479f78aa5db2f44b", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,38 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-57611-trait-alias.rs:20:9\n+  --> $DIR/issue-57611-trait-alias.rs:21:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n error: higher-ranked subtype error\n-  --> $DIR/issue-57611-trait-alias.rs:20:9\n+  --> $DIR/issue-57611-trait-alias.rs:21:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r X,)>`\n+              found type `Fn<(&'static X,)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-57611-trait-alias.rs:21:9\n+   |\n+LL |         |x| x\n+   |         ^^^^^\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'static X) -> &'static X` must implement `FnOnce<(&'0 X,)>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `FnOnce<(&'static X,)>`\n+\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "625e46b6bc0122b4ed5e1d74367e150e5e2595dc", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -17,8 +17,8 @@ impl Foo for X {\n     type Bar = impl Baz<Self, Self>;\n \n     fn bar(&self) -> Self::Bar {\n-        |x| x\n         //~^ ERROR implementation of `FnOnce` is not general enough\n+        |x| x\n     }\n }\n "}, {"sha": "54d237159d80b56fd0edb903825ec19682ab342e", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,8 @@\n error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:20:9\n+  --> $DIR/issue-57611-trait-alias.rs:19:22\n    |\n-LL |         |x| x\n-   |         ^^^^^ implementation of `FnOnce` is not general enough\n+LL |     fn bar(&self) -> Self::Bar {\n+   |                      ^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n    = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n    = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`"}, {"sha": "f1db4d3291b40709ade965658f99167fefc8e654", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -14,8 +14,8 @@ impl<C> Foo for C {\n     type Bar = impl Foo;\n \n     fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n-        self\n         //~^ Error type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        self\n     }\n }\n "}, {"sha": "c701e3e74ef591cecee73607b7c2ca1df6cf8e52", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,8 +1,12 @@\n error: type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-57700.rs:17:9\n+  --> $DIR/issue-57700.rs:16:58\n    |\n-LL |         self\n-   |         ^^^^\n+LL |       fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n+   |  __________________________________________________________^\n+LL | |\n+LL | |         self\n+LL | |     }\n+   | |_____^\n \n error: aborting due to previous error\n "}, {"sha": "e4ba7f8e2a6238c87f13b61086309a636baf6820", "filename": "src/test/ui/type-alias-impl-trait/issue-58951-2.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8b8f359312210e34b251906179484ffc7287c6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs?ref=2d8b8f359312210e34b251906179484ffc7287c6", "patch": "@@ -1,18 +0,0 @@\n-// check-pass\n-\n-#![feature(type_alias_impl_trait)]\n-\n-mod defining_use_scope {\n-    pub type A = impl Iterator;\n-\n-    pub fn def_a() -> A {\n-        0..1\n-    }\n-}\n-use defining_use_scope::*;\n-\n-pub fn use_a() {\n-    def_a().map(|x| x);\n-}\n-\n-fn main() {}"}, {"sha": "9d2ba849c8667539ae6a40efbfb3505387ac0cbd", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,6 +11,7 @@ impl Bug for &() {\n \n     const FUN: fn() -> Self::Item = || ();\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n+    //~| ERROR non-defining opaque type use in defining scope\n }\n \n fn main() {}"}, {"sha": "62ab7eb456010c8d166c7640c89ec19b532b55c3", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -11,12 +11,21 @@ error[E0277]: the trait bound `(): Bug` is not satisfied\n   --> $DIR/issue-60371.rs:12:40\n    |\n LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                        ^^ the trait `Bug` is not implemented for `()`\n+   |                                        ^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: aborting due to 2 previous errors\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-60371.rs:12:37\n+   |\n+LL | impl Bug for &() {\n+   |              - cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL |     const FUN: fn() -> Self::Item = || ();\n+   |                                     ^^^^^\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0277, E0658.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "44dcec2c3da98f3ca47adaed7e089a8c88593ac1", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -6,6 +6,7 @@ trait IterBits {\n }\n \n type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+//~^ ERROR could not find defining uses\n \n impl<T: Copy, E> IterBits for T\n where\n@@ -17,8 +18,8 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-        (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n         //~^ ERROR non-defining opaque type use in defining scope\n+        (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n     }\n }\n "}, {"sha": "6b73fbef011ec8483e3b748637f32f905223ddfa", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,14 +1,20 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60564.rs:20:9\n+  --> $DIR/issue-60564.rs:20:34\n    |\n-LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n+   |                                  ^^^^^^^^^^^^^^\n    |\n note: used non-generic type `u8` for generic parameter\n   --> $DIR/issue-60564.rs:8:25\n    |\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n    |                         ^\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/issue-60564.rs:8:30\n+   |\n+LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "875cce4df2390b0d9ad38d7c9d2bab320a5a6986", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -5,10 +5,7 @@\n type Closure = impl FnOnce();\n \n fn c() -> Closure {\n-    || -> Closure { || () }\n-    //~^ ERROR: mismatched types\n-    //~| ERROR: mismatched types\n-    //~| ERROR: expected a `FnOnce<()>` closure, found `()`\n+    || -> Closure { || () } //~ ERROR: mismatched types\n }\n \n fn main() {}"}, {"sha": "5fde8c2ef1e1138e896cfa4d3b37d998a9cf3d24", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54195db22421c51fd14560aba3bbf9b79a52677/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=d54195db22421c51fd14560aba3bbf9b79a52677", "patch": "@@ -1,34 +1,17 @@\n-error[E0277]: expected a `FnOnce<()>` closure, found `()`\n-  --> $DIR/issue-63279.rs:8:11\n-   |\n-LL |     || -> Closure { || () }\n-   |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n-   |\n-   = help: the trait `FnOnce<()>` is not implemented for `()`\n-   = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-63279.rs:8:21\n-   |\n-LL |     || -> Closure { || () }\n-   |                     ^^^^^ expected `()`, found closure\n-   |\n-   = note: expected unit type `()`\n-                found closure `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n-\n error[E0308]: mismatched types\n   --> $DIR/issue-63279.rs:8:5\n    |\n LL | type Closure = impl FnOnce();\n-   |                ------------- the expected opaque type\n+   |                ------------- the found opaque type\n ...\n LL |     || -> Closure { || () }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found closure\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n    |\n-   = note: expected opaque type `Closure`\n-                  found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n+   = note: expected type `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n+           found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0277, E0308.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0308`."}]}