{"sha": "a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZTNjM2Q1Yjg1ZTQxNWFkMjA5NGY0NzZkOWYxYWMyOWE0OGU0MTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-08T19:21:27Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:07Z"}, "message": "collector: collect functions when they are called/reified\n\nThis avoids the creation of unneeded vtable shims.", "tree": {"sha": "e6a706d8aee71cacd92f4417e114bf22806c8576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6a706d8aee71cacd92f4417e114bf22806c8576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "html_url": "https://github.com/rust-lang/rust/commit/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65a4266f1f4ce9dac5a6ef588443b7cac911d265", "url": "https://api.github.com/repos/rust-lang/rust/commits/65a4266f1f4ce9dac5a6ef588443b7cac911d265", "html_url": "https://github.com/rust-lang/rust/commit/65a4266f1f4ce9dac5a6ef588443b7cac911d265"}], "stats": {"total": 179, "additions": 86, "deletions": 93}, "files": [{"sha": "40a89783d91cfee51c84915ee4cf7f290d1b9db9", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 86, "deletions": 93, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "patch": "@@ -202,7 +202,6 @@ use rustc::mir::{self, Location};\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use syntax::abi::Abi;\n use context::SharedCrateContext;\n use common::{def_ty, instance_ty};\n use glue::{self, DropGlueKind};\n@@ -486,6 +485,14 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                           self.output);\n                 }\n             }\n+            mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n+                let fn_ty = operand.ty(self.mir, self.scx.tcx());\n+                let fn_ty = monomorphize::apply_param_substs(\n+                    self.scx,\n+                    self.param_substs,\n+                    &fn_ty);\n+                visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n+            }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n                 match source_ty.sty {\n@@ -537,111 +544,97 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_lvalue(lvalue, context, location);\n     }\n \n-    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>, location: Location) {\n-        debug!(\"visiting operand {:?}\", *operand);\n-\n-        let callee = match *operand {\n-            mir::Operand::Constant(ref constant) => {\n-                if let ty::TyFnDef(def_id, substs, _) = constant.ty.sty {\n-                    // This is something that can act as a callee, proceed\n-                    Some((def_id, substs))\n-                } else {\n-                    // This is not a callee, but we still have to look for\n-                    // references to `const` items\n-                    if let mir::Literal::Item { def_id, substs } = constant.literal {\n-                        let substs = monomorphize::apply_param_substs(self.scx,\n-                                                                      self.param_substs,\n-                                                                      &substs);\n-                        let instance = monomorphize::resolve(self.scx, def_id, substs);\n-                        collect_neighbours(self.scx, instance, self.output);\n-                    }\n+    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n+        debug!(\"visiting constant {:?} @ {:?}\", *constant, location);\n \n-                    None\n-                }\n-            }\n-            _ => None\n-        };\n-\n-        if let Some((callee_def_id, callee_substs)) = callee {\n-            debug!(\" => operand is callable\");\n-\n-            // `callee_def_id` might refer to a trait method instead of a\n-            // concrete implementation, so we have to find the actual\n-            // implementation. For example, the call might look like\n-            //\n-            // std::cmp::partial_cmp(0i32, 1i32)\n-            //\n-            // Calling do_static_dispatch() here will map the def_id of\n-            // `std::cmp::partial_cmp` to the def_id of `i32::partial_cmp<i32>`\n+        if let ty::TyFnDef(..) = constant.ty.sty {\n+            // function definitions are zero-sized, and only generate\n+            // IR when they are called/reified.\n+            self.super_constant(constant, location);\n+            return\n+        }\n \n-            let callee_substs = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &callee_substs);\n-            let instance =\n-                monomorphize::resolve(self.scx, callee_def_id, callee_substs);\n-            if should_trans_locally(self.scx.tcx(), &instance) {\n-                if let ty::InstanceDef::ClosureOnceShim { .. } = instance.def {\n-                    // This call will instantiate an FnOnce adapter, which\n-                    // drops the closure environment. Therefore we need to\n-                    // make sure that we collect the drop-glue for the\n-                    // environment type.\n-\n-                    let env_ty = instance.substs.type_at(0);\n-                    let env_ty = glue::get_drop_glue_type(self.scx, env_ty);\n-                    if self.scx.type_needs_drop(env_ty) {\n-                        let dg = DropGlueKind::Ty(env_ty);\n-                        self.output.push(TransItem::DropGlue(dg));\n-                    }\n-                }\n-                self.output.push(create_fn_trans_item(instance));\n-            }\n+        if let mir::Literal::Item { def_id, substs } = constant.literal {\n+            let substs = monomorphize::apply_param_substs(self.scx,\n+                                                          self.param_substs,\n+                                                          &substs);\n+            let instance = monomorphize::resolve(self.scx, def_id, substs);\n+            collect_neighbours(self.scx, instance, self.output);\n         }\n \n-        self.super_operand(operand, location);\n+        self.super_constant(constant, location);\n     }\n \n-    // This takes care of the \"drop_in_place\" intrinsic for which we otherwise\n-    // we would not register drop-glues.\n     fn visit_terminator_kind(&mut self,\n                              block: mir::BasicBlock,\n                              kind: &mir::TerminatorKind<'tcx>,\n                              location: Location) {\n         let tcx = self.scx.tcx();\n-        match *kind {\n-            mir::TerminatorKind::Call {\n-                func: mir::Operand::Constant(ref constant),\n-                ref args,\n-                ..\n-            } => {\n-                match constant.ty.sty {\n-                    ty::TyFnDef(def_id, _, bare_fn_ty)\n-                        if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n-                        let operand_ty = args[0].ty(self.mir, tcx);\n-                        if let ty::TyRawPtr(mt) = operand_ty.sty {\n-                            let operand_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                              self.param_substs,\n-                                                                              &mt.ty);\n-                            let ty = glue::get_drop_glue_type(self.scx, operand_ty);\n-                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n-                        } else {\n-                            bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n-                        }\n-                    }\n-                    _ => { /* Nothing to do. */ }\n-                }\n-            }\n-            _ => { /* Nothing to do. */ }\n+        if let mir::TerminatorKind::Call {\n+            ref func,\n+            ..\n+        } = *kind {\n+            let callee_ty = func.ty(self.mir, tcx);\n+            let callee_ty = monomorphize::apply_param_substs(\n+                self.scx, self.param_substs, &callee_ty);\n+            visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n         }\n \n         self.super_terminator_kind(block, kind, location);\n+    }\n+}\n+\n+fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                          ty: ty::Ty<'tcx>,\n+                          is_direct_call: bool,\n+                          output: &mut Vec<TransItem<'tcx>>)\n+{\n+    debug!(\"visit_fn_use({:?}, is_direct_call={:?})\", ty, is_direct_call);\n+    let (def_id, substs) = match ty.sty {\n+        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n+        _ => return\n+    };\n \n-        fn is_drop_in_place_intrinsic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                def_id: DefId,\n-                                                bare_fn_ty: ty::PolyFnSig<'tcx>)\n-                                                -> bool {\n-            (bare_fn_ty.abi() == Abi::RustIntrinsic ||\n-             bare_fn_ty.abi() == Abi::PlatformIntrinsic) &&\n-            tcx.item_name(def_id) == \"drop_in_place\"\n+    let instance = monomorphize::resolve(scx, def_id, substs);\n+    if !should_trans_locally(scx.tcx(), &instance) {\n+        return\n+    }\n+\n+    match instance.def {\n+        ty::InstanceDef::ClosureOnceShim { .. } => {\n+            // This call will instantiate an FnOnce adapter, which\n+            // drops the closure environment. Therefore we need to\n+            // make sure that we collect the drop-glue for the\n+            // environment type along with the instance.\n+\n+            let env_ty = instance.substs.type_at(0);\n+            let env_ty = glue::get_drop_glue_type(scx, env_ty);\n+            if scx.type_needs_drop(env_ty) {\n+                let dg = DropGlueKind::Ty(env_ty);\n+                output.push(TransItem::DropGlue(dg));\n+            }\n+            output.push(create_fn_trans_item(instance));\n+        }\n+        ty::InstanceDef::Intrinsic(..) => {\n+            if !is_direct_call {\n+                bug!(\"intrinsic {:?} being reified\", ty);\n+            }\n+            if scx.tcx().item_name(def_id) == \"drop_in_place\" {\n+                // drop_in_place is a call to drop glue, need to instantiate\n+                // that.\n+                let ty = glue::get_drop_glue_type(scx, substs.type_at(0));\n+                output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+            }\n+        }\n+        ty::InstanceDef::Virtual(..) => {\n+            // don't need to emit shim if we are calling directly.\n+            if !is_direct_call {\n+                output.push(create_fn_trans_item(instance));\n+            }\n+        }\n+        ty::InstanceDef::Item(..) |\n+        ty::InstanceDef::FnPtrShim(..) => {\n+            output.push(create_fn_trans_item(instance));\n         }\n     }\n }\n@@ -657,8 +650,8 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n             call_once: _, closure_did: def_id\n         } => def_id,\n         ty::InstanceDef::Virtual(..) |\n-        ty::InstanceDef::FnPtrShim(..) => return true,\n-        ty::InstanceDef::Intrinsic(_) => return false\n+        ty::InstanceDef::FnPtrShim(..) |\n+        ty::InstanceDef::Intrinsic(_) => return true\n     };\n     match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => {"}]}