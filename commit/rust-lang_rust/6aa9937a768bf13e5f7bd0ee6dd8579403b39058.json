{"sha": "6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYTk5MzdhNzY4YmYxM2U1ZjdiZDBlZTZkZDg1Nzk0MDNiMzkwNTg=", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2021-08-08T14:49:13Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2021-08-15T19:18:26Z"}, "message": "Introduce hir::ExprKind::Let - Take 2", "tree": {"sha": "ad4c8d3c2233b953d6088456650d26972c3d581b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad4c8d3c2233b953d6088456650d26972c3d581b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "html_url": "https://github.com/rust-lang/rust/commit/6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d9f2eae84dc3988c5463fdd1b124a9b695447d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d9f2eae84dc3988c5463fdd1b124a9b695447d7", "html_url": "https://github.com/rust-lang/rust/commit/2d9f2eae84dc3988c5463fdd1b124a9b695447d7"}], "stats": {"total": 4224, "additions": 2054, "deletions": 2170}, "files": [{"sha": "575a00cdd0e430022a1f1877ac47bf9497e4f10d", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1302,7 +1302,9 @@ pub enum ExprKind {\n     Type(P<Expr>, P<Ty>),\n     /// A `let pat = expr` expression that is only semantically allowed in the condition\n     /// of `if` / `while` expressions. (e.g., `if let 0 = x { .. }`).\n-    Let(P<Pat>, P<Expr>),\n+    ///\n+    /// `Span` represents the whole `let pat = expr` statement.\n+    Let(P<Pat>, P<Expr>, Span),\n     /// An `if` block, with an optional `else` block.\n     ///\n     /// `if expr { block } else { expr }`"}, {"sha": "c8245831187223b7289e6bca7406caa63276eed7", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1237,7 +1237,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_ty(ty);\n         }\n         ExprKind::AddrOf(_, _, ohs) => vis.visit_expr(ohs),\n-        ExprKind::Let(pat, scrutinee) => {\n+        ExprKind::Let(pat, scrutinee, _) => {\n             vis.visit_pat(pat);\n             vis.visit_expr(scrutinee);\n         }"}, {"sha": "a377763983a4bfb4b6f4fd5245b85cb8d84795a3", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -779,9 +779,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pat, ref scrutinee) => {\n+        ExprKind::Let(ref pat, ref expr, _) => {\n             visitor.visit_pat(pat);\n-            visitor.visit_expr(scrutinee);\n+            visitor.visit_expr(expr);\n         }\n         ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);"}, {"sha": "bf7589e84adc42c8049e7d50341b6a684e53e4d1", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 56, "deletions": 207, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -86,32 +86,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::AddrOf(k, m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee) => {\n-                    self.lower_expr_let(e.span, pat, scrutinee)\n+                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                    hir::ExprKind::Let(self.lower_pat(pat), self.lower_expr(scrutinee), span)\n+                }\n+                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                    self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }\n-                ExprKind::If(ref cond, ref then, ref else_opt) => match cond.kind {\n-                    ExprKind::Let(ref pat, ref scrutinee) => {\n-                        self.lower_expr_if_let(e.span, pat, scrutinee, then, else_opt.as_deref())\n-                    }\n-                    ExprKind::Paren(ref paren) => match paren.peel_parens().kind {\n-                        ExprKind::Let(ref pat, ref scrutinee) => {\n-                            // A user has written `if (let Some(x) = foo) {`, we want to avoid\n-                            // confusing them with mentions of nightly features.\n-                            // If this logic is changed, you will also likely need to touch\n-                            // `unused::UnusedParens::check_expr`.\n-                            self.if_let_expr_with_parens(cond, &paren.peel_parens());\n-                            self.lower_expr_if_let(\n-                                e.span,\n-                                pat,\n-                                scrutinee,\n-                                then,\n-                                else_opt.as_deref(),\n-                            )\n-                        }\n-                        _ => self.lower_expr_if(cond, then, else_opt.as_deref()),\n-                    },\n-                    _ => self.lower_expr_if(cond, then, else_opt.as_deref()),\n-                },\n                 ExprKind::While(ref cond, ref body, opt_label) => self\n                     .with_loop_scope(e.id, |this| {\n                         this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n@@ -368,199 +348,69 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ExprKind::Call(f, self.lower_exprs(&real_args))\n     }\n \n-    fn if_let_expr_with_parens(&mut self, cond: &Expr, paren: &Expr) {\n-        let start = cond.span.until(paren.span);\n-        let end = paren.span.shrink_to_hi().until(cond.span.shrink_to_hi());\n-        self.sess\n-            .struct_span_err(\n-                vec![start, end],\n-                \"invalid parentheses around `let` expression in `if let`\",\n-            )\n-            .multipart_suggestion(\n-                \"`if let` needs to be written without parentheses\",\n-                vec![(start, String::new()), (end, String::new())],\n-                rustc_errors::Applicability::MachineApplicable,\n-            )\n-            .emit();\n-        // Ideally, we'd remove the feature gating of a `let` expression since we are already\n-        // complaining about it here, but `feature_gate::check_crate` has already run by now:\n-        // self.sess.parse_sess.gated_spans.ungate_last(sym::let_chains, paren.span);\n-    }\n-\n-    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n-    /// ```rust\n-    /// match scrutinee { pats => true, _ => false }\n-    /// ```\n-    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind<'hir> {\n-        // If we got here, the `let` expression is not allowed.\n-\n-        if self.sess.opts.unstable_features.is_nightly_build() {\n-            self.sess\n-                .struct_span_err(span, \"`let` expressions are not supported here\")\n-                .note(\n-                    \"only supported directly without parentheses in conditions of `if`- and \\\n-                     `while`-expressions, as well as in `let` chains within parentheses\",\n-                )\n-                .emit();\n-        } else {\n-            self.sess\n-                .struct_span_err(span, \"expected expression, found statement (`let`)\")\n-                .note(\"variable declaration using `let` is a statement\")\n-                .emit();\n-        }\n-\n-        // For better recovery, we emit:\n-        // ```\n-        // match scrutinee { pat => true, _ => false }\n-        // ```\n-        // While this doesn't fully match the user's intent, it has key advantages:\n-        // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pat` and `scrutinee`.\n-        // 3. `pat` is allowed to be refutable.\n-        // 4. The return type of the block is `bool` which seems like what the user wanted.\n-        let scrutinee = self.lower_expr(scrutinee);\n-        let then_arm = {\n-            let pat = self.lower_pat(pat);\n-            let expr = self.expr_bool(span, true);\n-            self.arm(pat, expr)\n-        };\n-        let else_arm = {\n-            let pat = self.pat_wild(span);\n-            let expr = self.expr_bool(span, false);\n-            self.arm(pat, expr)\n-        };\n-        hir::ExprKind::Match(\n-            scrutinee,\n-            arena_vec![self; then_arm, else_arm],\n-            hir::MatchSource::Normal,\n-        )\n-    }\n-\n     fn lower_expr_if(\n         &mut self,\n         cond: &Expr,\n         then: &Block,\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n-        let cond = self.lower_expr(cond);\n-        let wrapped_cond = match cond.kind {\n-            hir::ExprKind::Let(..) => cond,\n-            _ => self.expr_drop_temps(cond.span, cond, AttrVec::new()),\n-        };\n+        let lowered_cond = self.lower_expr(cond);\n+        let new_cond = self.manage_let_cond(lowered_cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n-            hir::ExprKind::If(\n-                wrapped_cond,\n-                self.arena.alloc(then_expr),\n-                Some(self.lower_expr(rslt)),\n-            )\n+            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n         } else {\n-            hir::ExprKind::If(wrapped_cond, self.arena.alloc(then_expr), None)\n+            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), None)\n         }\n     }\n \n-    fn lower_expr_if_let(\n-        &mut self,\n-        span: Span,\n-        pat: &Pat,\n-        scrutinee: &Expr,\n-        then: &Block,\n-        else_opt: Option<&Expr>,\n-    ) -> hir::ExprKind<'hir> {\n-        // FIXME(#53667): handle lowering of && and parens.\n-\n-        // `_ => else_block` where `else_block` is `{}` if there's `None`:\n-        let else_pat = self.pat_wild(span);\n-        let (else_expr, contains_else_clause) = match else_opt {\n-            None => (self.expr_block_empty(span.shrink_to_hi()), false),\n-            Some(els) => (self.lower_expr(els), true),\n-        };\n-        let else_arm = self.arm(else_pat, else_expr);\n-\n-        // Handle then + scrutinee:\n-        let scrutinee = self.lower_expr(scrutinee);\n-        let then_pat = self.lower_pat(pat);\n-\n-        let then_expr = self.lower_block_expr(then);\n-        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n-\n-        let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-        hir::ExprKind::Match(scrutinee, arena_vec![self; then_arm, else_arm], desugar)\n+    // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n+    // in a temporary block.\n+    fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n+        match cond.kind {\n+            hir::ExprKind::Let(..) => cond,\n+            _ => {\n+                let span_block =\n+                    self.mark_span_with_reason(DesugaringKind::CondTemporary, cond.span, None);\n+                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+            }\n+        }\n     }\n \n+    // We desugar: `'label: while $cond $body` into:\n+    //\n+    // ```\n+    // 'label: loop {\n+    //   if { let _t = $cond; _t } {\n+    //     $body\n+    //   }\n+    //   else {\n+    //     break;\n+    //   }\n+    // }\n+    // ```\n+    //\n+    // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+    // to preserve drop semantics since `while $cond { ... }` does not\n+    // let temporaries live outside of `cond`.\n     fn lower_expr_while_in_loop_scope(\n         &mut self,\n         span: Span,\n         cond: &Expr,\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n-        // FIXME(#53667): handle lowering of && and parens.\n-\n-        // Note that the block AND the condition are evaluated in the loop scope.\n-        // This is done to allow `break` from inside the condition of the loop.\n-\n-        // `_ => break`:\n-        let else_arm = {\n-            let else_pat = self.pat_wild(span);\n-            let else_expr = self.expr_break(span, ThinVec::new());\n-            self.arm(else_pat, else_expr)\n-        };\n-\n-        // Handle then + scrutinee:\n-        let (then_pat, scrutinee, desugar, source) = match cond.kind {\n-            ExprKind::Let(ref pat, ref scrutinee) => {\n-                // to:\n-                //\n-                //   [opt_ident]: loop {\n-                //     match <sub_expr> {\n-                //       <pat> => <body>,\n-                //       _ => break\n-                //     }\n-                //   }\n-                let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pat = self.lower_pat(pat);\n-                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n-            }\n-            _ => {\n-                // We desugar: `'label: while $cond $body` into:\n-                //\n-                // ```\n-                // 'label: loop {\n-                //     match drop-temps { $cond } {\n-                //         true => $body,\n-                //         _ => break,\n-                //     }\n-                // }\n-                // ```\n-\n-                // Lower condition:\n-                let cond = self.with_loop_condition_scope(|this| this.lower_expr(cond));\n-                let span_block =\n-                    self.mark_span_with_reason(DesugaringKind::CondTemporary, cond.span, None);\n-                // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                // to preserve drop semantics since `while cond { ... }` does not\n-                // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n-                // `true => <then>`:\n-                let pat = self.pat_bool(span, true);\n-                (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n-            }\n-        };\n-        let then_expr = self.lower_block_expr(body);\n-        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n-\n-        // `match <scrutinee> { ... }`\n-        let match_expr =\n-            self.expr_match(span, scrutinee, arena_vec![self; then_arm, else_arm], desugar);\n-\n-        // `[opt_ident]: loop { ... }`\n-        hir::ExprKind::Loop(\n-            self.block_expr(self.arena.alloc(match_expr)),\n-            opt_label,\n-            source,\n-            span.with_hi(cond.span.hi()),\n-        )\n+        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n+        let new_cond = self.manage_let_cond(lowered_cond);\n+        let then = self.lower_block_expr(body);\n+        let expr_break = self.expr_break(span, ThinVec::new());\n+        let stmt_break = self.stmt_expr(span, expr_break);\n+        let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n+        let else_expr = self.arena.alloc(self.expr_block(else_blk, ThinVec::new()));\n+        let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n+        let if_expr = self.expr(span, if_kind, ThinVec::new());\n+        let block = self.block_expr(self.arena.alloc(if_expr));\n+        hir::ExprKind::Loop(block, opt_label, hir::LoopSource::While, span.with_hi(cond.span.hi()))\n     }\n \n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n@@ -620,7 +470,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         let pat = self.lower_pat(&arm.pat);\n         let guard = arm.guard.as_ref().map(|cond| {\n-            if let ExprKind::Let(ref pat, ref scrutinee) = cond.kind {\n+            if let ExprKind::Let(ref pat, ref scrutinee, _) = cond.kind {\n                 hir::Guard::IfLet(self.lower_pat(pat), self.lower_expr(scrutinee))\n             } else {\n                 hir::Guard::If(self.lower_expr(cond))\n@@ -1468,7 +1318,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `::std::option::Option::None => break`\n         let break_arm = {\n             let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n+                self.with_loop_scope(e.id, |this| this.expr_break_alloc(e.span, ThinVec::new()));\n             let pat = self.pat_none(e.span);\n             self.arm(pat, break_expr)\n         };\n@@ -1681,12 +1531,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // Helper methods for building HIR.\n     // =========================================================================\n \n-    /// Constructs a `true` or `false` literal expression.\n-    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> &'hir hir::Expr<'hir> {\n-        let lit = Spanned { span, node: LitKind::Bool(val) };\n-        self.arena.alloc(self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new()))\n-    }\n-\n     /// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.\n     ///\n     /// In terms of drop order, it has the same effect as wrapping `expr` in\n@@ -1721,9 +1565,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> hir::Expr<'hir> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n-        self.arena.alloc(self.expr(span, expr_break, attrs))\n+        self.expr(span, expr_break, attrs)\n+    }\n+\n+    fn expr_break_alloc(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n+        let expr_break = self.expr_break(span, attrs);\n+        self.arena.alloc(expr_break)\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {"}, {"sha": "d41b3b81466244ed092a9973ab6413d5bb471496", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -2537,12 +2537,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(blk)\n     }\n \n-    /// Constructs a `true` or `false` literal pattern.\n-    fn pat_bool(&mut self, span: Span, val: bool) -> &'hir hir::Pat<'hir> {\n-        let expr = self.expr_bool(span, val);\n-        self.pat(span, hir::PatKind::Lit(expr))\n-    }\n-\n     fn pat_cf_continue(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n         let field = self.single_pat_field(span, pat);\n         self.pat_lang_item_variant(span, hir::LangItem::ControlFlowContinue, field)\n@@ -2624,10 +2618,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn pat_wild(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n-        self.pat(span, hir::PatKind::Wild)\n-    }\n-\n     fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n         self.arena.alloc(hir::Pat {\n             hir_id: self.next_id(),"}, {"sha": "cff1b70dda9073125b637d5e4f73f17c6d8dac58", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -18,6 +18,7 @@ use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use std::mem;\n@@ -80,6 +81,9 @@ struct AstValidator<'a> {\n     /// certain positions.\n     is_assoc_ty_bound_banned: bool,\n \n+    /// Used to allow `let` expressions in certain syntactic locations.\n+    is_let_allowed: bool,\n+\n     lint_buffer: &'a mut LintBuffer,\n }\n \n@@ -96,6 +100,27 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n+    fn with_let_allowed(&mut self, allowed: bool, f: impl FnOnce(&mut Self, bool)) {\n+        let old = mem::replace(&mut self.is_let_allowed, allowed);\n+        f(self, old);\n+        self.is_let_allowed = old;\n+    }\n+\n+    /// Emits an error banning the `let` expression provided in the given location.\n+    fn ban_let_expr(&self, expr: &'a Expr) {\n+        let sess = &self.session;\n+        if sess.opts.unstable_features.is_nightly_build() {\n+            sess.struct_span_err(expr.span, \"`let` expressions are not supported here\")\n+                .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                .emit();\n+        } else {\n+            sess.struct_span_err(expr.span, \"expected expression, found statement (`let`)\")\n+                .note(\"variable declaration using `let` is a statement\")\n+                .emit();\n+        }\n+    }\n+\n     fn with_banned_assoc_ty_bound(&mut self, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.is_assoc_ty_bound_banned, true);\n         f(self);\n@@ -978,20 +1003,49 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        match &expr.kind {\n-            ExprKind::LlvmInlineAsm(..) if !self.session.target.allow_asm => {\n+        self.with_let_allowed(false, |this, let_allowed| match &expr.kind {\n+            ExprKind::If(cond, then, opt_else) => {\n+                this.visit_block(then);\n+                walk_list!(this, visit_expr, opt_else);\n+                this.with_let_allowed(true, |this, _| this.visit_expr(cond));\n+                return;\n+            }\n+            ExprKind::Let(..) if !let_allowed => this.ban_let_expr(expr),\n+            ExprKind::LlvmInlineAsm(..) if !this.session.target.allow_asm => {\n                 struct_span_err!(\n-                    self.session,\n+                    this.session,\n                     expr.span,\n                     E0472,\n                     \"llvm_asm! is unsupported on this target\"\n                 )\n                 .emit();\n             }\n-            _ => {}\n-        }\n-\n-        visit::walk_expr(self, expr);\n+            ExprKind::Match(expr, arms) => {\n+                this.visit_expr(expr);\n+                for arm in arms {\n+                    this.visit_expr(&arm.body);\n+                    this.visit_pat(&arm.pat);\n+                    walk_list!(this, visit_attribute, &arm.attrs);\n+                    if let Some(ref guard) = arm.guard {\n+                        if let ExprKind::Let(_, ref expr, _) = guard.kind {\n+                            this.with_let_allowed(true, |this, _| this.visit_expr(expr));\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            ExprKind::Paren(_) | ExprKind::Binary(Spanned { node: BinOpKind::And, .. }, ..) => {\n+                this.with_let_allowed(let_allowed, |this, _| visit::walk_expr(this, expr));\n+                return;\n+            }\n+            ExprKind::While(cond, then, opt_label) => {\n+                walk_list!(this, visit_label, opt_label);\n+                this.visit_block(then);\n+                this.with_let_allowed(true, |this, _| this.visit_expr(cond));\n+                return;\n+            }\n+            _ => visit::walk_expr(this, expr),\n+        });\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n@@ -1634,6 +1688,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         bound_context: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n+        is_let_allowed: false,\n         lint_buffer: lints,\n     };\n     visit::walk_crate(&mut validator, krate);"}, {"sha": "b09c668273aa8192418b17c4d4537c4403630228", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1587,19 +1587,14 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n-    /// Print a `let pat = scrutinee` expression.\n-    crate fn print_let(&mut self, pat: &ast::Pat, scrutinee: &ast::Expr) {\n+    /// Print a `let pat = expr` expression.\n+    crate fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n         self.s.word(\"let \");\n-\n         self.print_pat(pat);\n         self.s.space();\n-\n         self.word_space(\"=\");\n-        self.print_expr_cond_paren(\n-            scrutinee,\n-            Self::cond_needs_par(scrutinee)\n-                || parser::needs_par_as_let_scrutinee(scrutinee.precedence().order()),\n-        )\n+        let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n     }\n \n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n@@ -1632,10 +1627,8 @@ impl<'a> State<'a> {\n \n     crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n         self.head(\"if\");\n-\n         self.print_expr_as_cond(test);\n         self.s.space();\n-\n         self.print_block(blk);\n         self.print_else(elseopt)\n     }\n@@ -1668,13 +1661,13 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n     }\n \n-    /// Does `expr` need parenthesis when printed in a condition position?\n+    // Does `expr` need parenthesis when printed in a condition position?\n+    //\n+    // These cases need parens due to the parse error observed in #26461: `if return {}`\n+    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n     fn cond_needs_par(expr: &ast::Expr) -> bool {\n         match expr.kind {\n-            // These cases need parens due to the parse error observed in #26461: `if return {}`\n-            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-            ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) | ast::ExprKind::Break(..) => true,\n-\n+            ast::ExprKind::Break(..) | ast::ExprKind::Closure(..) | ast::ExprKind::Ret(..) => true,\n             _ => parser::contains_exterior_struct_lit(expr),\n         }\n     }\n@@ -1919,7 +1912,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Let(ref pat, ref scrutinee) => {\n+            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n                 self.print_let(pat, scrutinee);\n             }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {"}, {"sha": "3ed99eab95c62665f88b8ada5bd9200831807647", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -354,6 +354,7 @@ pub trait MacResult {\n     fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n         None\n     }\n+\n     /// Creates zero or more items.\n     fn make_items(self: Box<Self>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n         None"}, {"sha": "4e233ed14577d1c933b20e5e87be7f6196c5b681", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1482,6 +1482,7 @@ impl Expr<'_> {\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::DropTemps(ref expr, ..) => expr.precedence(),\n             ExprKind::If(..) => ExprPrecedence::If,\n+            ExprKind::Let(..) => ExprPrecedence::Let,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n             ExprKind::Match(..) => ExprPrecedence::Match,\n             ExprKind::Closure(..) => ExprPrecedence::Closure,\n@@ -1552,6 +1553,7 @@ impl Expr<'_> {\n             | ExprKind::Break(..)\n             | ExprKind::Continue(..)\n             | ExprKind::Ret(..)\n+            | ExprKind::Let(..)\n             | ExprKind::Loop(..)\n             | ExprKind::Assign(..)\n             | ExprKind::InlineAsm(..)\n@@ -1634,6 +1636,7 @@ impl Expr<'_> {\n             | ExprKind::Break(..)\n             | ExprKind::Continue(..)\n             | ExprKind::Ret(..)\n+            | ExprKind::Let(..)\n             | ExprKind::Loop(..)\n             | ExprKind::Assign(..)\n             | ExprKind::InlineAsm(..)\n@@ -1725,6 +1728,11 @@ pub enum ExprKind<'hir> {\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n     DropTemps(&'hir Expr<'hir>),\n+    /// A `let $pat = $expr` expression.\n+    ///\n+    /// These are not `Local` and only occur as expressions.\n+    /// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.\n+    Let(&'hir Pat<'hir>, &'hir Expr<'hir>, Span),\n     /// An `if` block, with an optional else block.\n     ///\n     /// I.e., `if <expr> { <expr> } else { <expr> }`.\n@@ -1884,15 +1892,6 @@ pub enum LocalSource {\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n-    /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n-    IfLetDesugar { contains_else_clause: bool },\n-    /// An `if let _ = _ => { .. }` match guard.\n-    IfLetGuardDesugar,\n-    /// A `while _ { .. }` (which was desugared to a `loop { match _ { .. } }`).\n-    WhileDesugar,\n-    /// A `while let _ = _ { .. }` (which was desugared to a\n-    /// `loop { match _ { .. } }`).\n-    WhileLetDesugar,\n     /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n     /// A desugared `?` operator.\n@@ -1902,12 +1901,11 @@ pub enum MatchSource {\n }\n \n impl MatchSource {\n-    pub fn name(self) -> &'static str {\n+    #[inline]\n+    pub const fn name(self) -> &'static str {\n         use MatchSource::*;\n         match self {\n             Normal => \"match\",\n-            IfLetDesugar { .. } | IfLetGuardDesugar => \"if\",\n-            WhileDesugar | WhileLetDesugar => \"while\",\n             ForLoopDesugar => \"for\",\n             TryDesugar => \"?\",\n             AwaitDesugar => \".await\",\n@@ -1922,8 +1920,6 @@ pub enum LoopSource {\n     Loop,\n     /// A `while _ { .. }` loop.\n     While,\n-    /// A `while let _ = _ { .. }` loop.\n-    WhileLet,\n     /// A `for _ in _ { .. }` loop.\n     ForLoop,\n }\n@@ -1932,7 +1928,7 @@ impl LoopSource {\n     pub fn name(self) -> &'static str {\n         match self {\n             LoopSource::Loop => \"loop\",\n-            LoopSource::While | LoopSource::WhileLet => \"while\",\n+            LoopSource::While => \"while\",\n             LoopSource::ForLoop => \"for\",\n         }\n     }"}, {"sha": "1cbe3b12c820388991dba4f3a40e77e03332f1e8", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1163,6 +1163,10 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n+        ExprKind::Let(ref pat, ref expr, _) => {\n+            visitor.visit_expr(expr);\n+            visitor.visit_pat(pat);\n+        }\n         ExprKind::If(ref cond, ref then, ref else_opt) => {\n             visitor.visit_expr(cond);\n             visitor.visit_expr(then);"}, {"sha": "9c286ad5ccfe911c417f4c614b3195a02c4296ed", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1092,53 +1092,30 @@ impl<'a> State<'a> {\n     }\n \n     fn print_else(&mut self, els: Option<&hir::Expr<'_>>) {\n-        match els {\n-            Some(else_) => {\n-                match else_.kind {\n-                    // \"another else-if\"\n-                    hir::ExprKind::If(ref i, ref then, ref e) => {\n-                        self.cbox(INDENT_UNIT - 1);\n-                        self.ibox(0);\n-                        self.s.word(\" else if \");\n-                        self.print_expr_as_cond(&i);\n-                        self.s.space();\n-                        self.print_expr(&then);\n-                        self.print_else(e.as_ref().map(|e| &**e))\n-                    }\n-                    // \"final else\"\n-                    hir::ExprKind::Block(ref b, _) => {\n-                        self.cbox(INDENT_UNIT - 1);\n-                        self.ibox(0);\n-                        self.s.word(\" else \");\n-                        self.print_block(&b)\n-                    }\n-                    hir::ExprKind::Match(ref expr, arms, _) => {\n-                        // else if let desugared to match\n-                        assert!(arms.len() == 2, \"if let desugars to match with two arms\");\n-\n-                        self.s.word(\" else \");\n-                        self.s.word(\"{\");\n-\n-                        self.cbox(INDENT_UNIT);\n-                        self.ibox(INDENT_UNIT);\n-                        self.word_nbsp(\"match\");\n-                        self.print_expr_as_cond(&expr);\n-                        self.s.space();\n-                        self.bopen();\n-                        for arm in arms {\n-                            self.print_arm(arm);\n-                        }\n-                        self.bclose(expr.span);\n-\n-                        self.s.word(\"}\");\n-                    }\n-                    // BLEAH, constraints would be great here\n-                    _ => {\n-                        panic!(\"print_if saw if with weird alternative\");\n-                    }\n+        if let Some(els_inner) = els {\n+            match els_inner.kind {\n+                // Another `else if` block.\n+                hir::ExprKind::If(ref i, ref then, ref e) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.s.word(\" else if \");\n+                    self.print_expr_as_cond(&i);\n+                    self.s.space();\n+                    self.print_expr(&then);\n+                    self.print_else(e.as_ref().map(|e| &**e))\n+                }\n+                // Final `else` block.\n+                hir::ExprKind::Block(ref b, _) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.s.word(\" else \");\n+                    self.print_block(&b)\n+                }\n+                // Constraints would be great here!\n+                _ => {\n+                    panic!(\"print_if saw if with weird alternative\");\n                 }\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1165,37 +1142,52 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr<'_>, prec: i8) {\n-        let needs_par = expr.precedence().order() < prec;\n-        if needs_par {\n-            self.popen();\n-        }\n-        self.print_expr(expr);\n-        if needs_par {\n-            self.pclose();\n-        }\n+    fn print_expr_maybe_paren(&mut self, expr: &hir::Expr<'_>, prec: i8) {\n+        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n     }\n \n-    /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// Prints an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n     pub fn print_expr_as_cond(&mut self, expr: &hir::Expr<'_>) {\n-        let needs_par = match expr.kind {\n-            // These cases need parens due to the parse error observed in #26461: `if return {}`\n-            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-            hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) | hir::ExprKind::Break(..) => true,\n-\n-            _ => contains_exterior_struct_lit(expr),\n-        };\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n+    }\n \n+    /// Prints `expr` or `(expr)` when `needs_par` holds.\n+    fn print_expr_cond_paren(&mut self, expr: &hir::Expr<'_>, needs_par: bool) {\n         if needs_par {\n             self.popen();\n         }\n-        self.print_expr(expr);\n+        if let hir::ExprKind::DropTemps(ref actual_expr) = expr.kind {\n+            self.print_expr(actual_expr);\n+        } else {\n+            self.print_expr(expr);\n+        }\n         if needs_par {\n             self.pclose();\n         }\n     }\n \n+    /// Print a `let pat = expr` expression.\n+    fn print_let(&mut self, pat: &hir::Pat<'_>, expr: &hir::Expr<'_>) {\n+        self.s.word(\"let \");\n+        self.print_pat(pat);\n+        self.s.space();\n+        self.word_space(\"=\");\n+        let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n+    }\n+\n+    // Does `expr` need parenthesis when printed in a condition position?\n+    //\n+    // These cases need parens due to the parse error observed in #26461: `if return {}`\n+    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+    fn cond_needs_par(expr: &hir::Expr<'_>) -> bool {\n+        match expr.kind {\n+            hir::ExprKind::Break(..) | hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) => true,\n+            _ => contains_exterior_struct_lit(expr),\n+        }\n+    }\n+\n     fn print_expr_vec(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n@@ -1314,6 +1306,9 @@ impl<'a> State<'a> {\n             (&hir::ExprKind::Cast { .. }, hir::BinOpKind::Lt | hir::BinOpKind::Shl) => {\n                 parser::PREC_FORCE_PAREN\n             }\n+            (&hir::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n             _ => left_prec,\n         };\n \n@@ -1531,6 +1526,9 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, true);\n             }\n+            hir::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+                self.print_let(pat, scrutinee);\n+            }\n             hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));\n             }"}, {"sha": "b628381d5aadc8f33beb6470e7103149be95386f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -644,17 +644,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 scrut_span,\n                 ..\n             }) => match source {\n-                hir::MatchSource::IfLetDesugar { .. } => {\n-                    let msg = \"`if let` arms have incompatible types\";\n-                    err.span_label(cause.span, msg);\n-                    if let Some(ret_sp) = opt_suggest_box_span {\n-                        self.suggest_boxing_for_return_impl_trait(\n-                            err,\n-                            ret_sp,\n-                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n-                        );\n-                    }\n-                }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n                         let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n@@ -2581,9 +2570,6 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n             CompareImplTypeObligation { .. } => Error0308(\"type not compatible with trait\"),\n             MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => {\n                 Error0308(match source {\n-                    hir::MatchSource::IfLetDesugar { .. } => {\n-                        \"`if let` arms have incompatible types\"\n-                    }\n                     hir::MatchSource::TryDesugar => {\n                         \"try expression alternatives have incompatible types\"\n                     }\n@@ -2619,10 +2605,6 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             CompareImplTypeObligation { .. } => \"associated type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n-            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n-                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n-                _ => \"`match` arms have compatible types\",\n-            },\n             IfExpression { .. } => \"`if` and `else` have incompatible types\",\n             IfExpressionWithNoElse => \"`if` missing an `else` returns `()`\",\n             MainFunctionType => \"`main` function has the correct type\","}, {"sha": "f59ad0ac82d80abe5e41db984c21bcf3a08f897e", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -614,7 +614,8 @@ trait UnusedDelimLint {\n         let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n             // Do not lint `unused_braces` in `if let` expressions.\n             If(ref cond, ref block, _)\n-                if !matches!(cond.kind, Let(_, _)) || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n+                if !matches!(cond.kind, Let(_, _, _))\n+                    || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n             {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n@@ -623,7 +624,8 @@ trait UnusedDelimLint {\n \n             // Do not lint `unused_braces` in `while let` expressions.\n             While(ref cond, ref block, ..)\n-                if !matches!(cond.kind, Let(_, _)) || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n+                if !matches!(cond.kind, Let(_, _, _))\n+                    || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n             {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n@@ -774,7 +776,7 @@ impl UnusedDelimLint for UnusedParens {\n                     self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n                 }\n             }\n-            ast::ExprKind::Let(_, ref expr) => {\n+            ast::ExprKind::Let(_, ref expr, _) => {\n                 self.check_unused_delims_expr(\n                     cx,\n                     expr,\n@@ -828,7 +830,7 @@ impl UnusedParens {\n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         match e.kind {\n-            ExprKind::Let(ref pat, _) | ExprKind::ForLoop(ref pat, ..) => {\n+            ExprKind::Let(ref pat, _, _) | ExprKind::ForLoop(ref pat, ..) => {\n                 self.check_unused_parens_pat(cx, pat, false, false);\n             }\n             // We ignore parens in cases like `if (((let Some(0) = Some(1))))` because we already\n@@ -1012,7 +1014,7 @@ impl UnusedDelimLint for UnusedBraces {\n                     }\n                 }\n             }\n-            ast::ExprKind::Let(_, ref expr) => {\n+            ast::ExprKind::Let(_, ref expr, _) => {\n                 self.check_unused_delims_expr(\n                     cx,\n                     expr,"}, {"sha": "48337b8cb9617eee988c3d2806097059a2c81dec", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -292,6 +292,10 @@ pub enum ExprKind<'tcx> {\n     Loop {\n         body: ExprId,\n     },\n+    Let {\n+        expr: ExprId,\n+        pat: Pat<'tcx>,\n+    },\n     /// A `match` expression.\n     Match {\n         scrutinee: ExprId,"}, {"sha": "4a546a50215772b69937c3cee1a1b82d426d6b0d", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -565,6 +565,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::If { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::Block { .. }\n+            | ExprKind::Let { .. }\n             | ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n             | ExprKind::Break { .. }"}, {"sha": "1719f96f26d8ae79b5478cc15d1448d0f8d8be9e", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -284,6 +284,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::LogicalOp { .. }\n             | ExprKind::Call { .. }\n             | ExprKind::Field { .. }\n+            | ExprKind::Let { .. }\n             | ExprKind::Deref { .. }\n             | ExprKind::Index { .. }\n             | ExprKind::VarRef { .. }"}, {"sha": "fcda52e558126155cdabf09d2d83a2cccc1305de", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -46,6 +46,7 @@ impl Category {\n             ExprKind::LogicalOp { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::If { .. }\n+            | ExprKind::Let { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n             | ExprKind::Adt { .. }"}, {"sha": "3878cf4db99c9e1d8004833e5482d2558a27be4a", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -53,48 +53,66 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.match_expr(destination, expr_span, block, &this.thir[scrutinee], arms)\n             }\n             ExprKind::If { cond, then, else_opt } => {\n-                let place = unpack!(\n-                    block = this.as_temp(\n-                        block,\n-                        Some(this.local_scope()),\n-                        &this.thir[cond],\n-                        Mutability::Mut\n-                    )\n-                );\n-                let operand = Operand::Move(Place::from(place));\n-\n-                let mut then_block = this.cfg.start_new_block();\n-                let mut else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n-                this.cfg.terminate(block, source_info, term);\n-\n-                unpack!(\n-                    then_block = this.expr_into_dest(destination, then_block, &this.thir[then])\n-                );\n-                else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.expr_into_dest(destination, else_block, &this.thir[else_opt]))\n+                let local_scope = this.local_scope();\n+                let (mut then_blk, mut else_blk) =\n+                    this.then_else_blocks(block, &this.thir[cond], local_scope, source_info);\n+                unpack!(then_blk = this.expr_into_dest(destination, then_blk, &this.thir[then]));\n+                else_blk = if let Some(else_opt) = else_opt {\n+                    unpack!(this.expr_into_dest(destination, else_blk, &this.thir[else_opt]))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n                     let correct_si = this.source_info(expr_span.shrink_to_hi());\n-                    this.cfg.push_assign_unit(else_block, correct_si, destination, this.tcx);\n-                    else_block\n+                    this.cfg.push_assign_unit(else_blk, correct_si, destination, this.tcx);\n+                    else_blk\n                 };\n \n                 let join_block = this.cfg.start_new_block();\n                 this.cfg.terminate(\n-                    then_block,\n+                    then_blk,\n                     source_info,\n                     TerminatorKind::Goto { target: join_block },\n                 );\n                 this.cfg.terminate(\n-                    else_block,\n+                    else_blk,\n                     source_info,\n                     TerminatorKind::Goto { target: join_block },\n                 );\n \n                 join_block.unit()\n             }\n+            ExprKind::Let { ref pat, expr } => {\n+                let (true_block, false_block) =\n+                    this.lower_let(block, &this.thir[expr], pat, expr_span);\n+\n+                let join_block = this.cfg.start_new_block();\n+\n+                this.cfg.push_assign_constant(\n+                    true_block,\n+                    source_info,\n+                    destination,\n+                    Constant {\n+                        span: expr_span,\n+                        user_ty: None,\n+                        literal: ty::Const::from_bool(this.tcx, true).into(),\n+                    },\n+                );\n+\n+                this.cfg.push_assign_constant(\n+                    false_block,\n+                    source_info,\n+                    destination,\n+                    Constant {\n+                        span: expr_span,\n+                        user_ty: None,\n+                        literal: ty::Const::from_bool(this.tcx, false).into(),\n+                    },\n+                );\n+\n+                this.cfg.goto(true_block, source_info, join_block);\n+                this.cfg.goto(false_block, source_info, join_block);\n+                join_block.unit()\n+            }\n             ExprKind::NeverToAny { source } => {\n                 let source = &this.thir[source];\n                 let is_call ="}, {"sha": "f2a8109eb05077da8bed9d6dd91c5c48eb8ca72c", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -38,11 +38,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(crate) fn then_else_blocks(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: ExprRef<'tcx>,\n+        expr: &Expr<'tcx>,\n+        scope: region::Scope,\n         source_info: SourceInfo,\n     ) -> (BasicBlock, BasicBlock) {\n         let this = self;\n-        let expr = this.hir.mirror(expr);\n         let expr_span = expr.span;\n \n         match expr.kind {\n@@ -52,24 +52,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let else_block = unpack!(\n                     then_block = this.in_scope(region_scope, lint_level, |this| {\n                         let (then_block, else_block) =\n-                            this.then_else_blocks(block, value, source_info);\n+                            this.then_else_blocks(block, &this.thir[value], scope, source_info);\n                         then_block.and(else_block)\n                     })\n                 );\n                 (then_block, else_block)\n             }\n-            ExprKind::Let { expr, pat } => {\n-                // TODO: Use correct span.\n-                this.lower_let(block, &expr, &pat, expr_span)\n+            ExprKind::Let { expr, ref pat } => {\n+                // FIXME: Use correct span.\n+                this.lower_let(block, &this.thir[expr], pat, expr_span)\n             }\n             _ => {\n-                let local_scope = Some(this.local_scope());\n-                let place =\n-                    unpack!(block = this.as_temp(block, local_scope, expr, Mutability::Mut));\n+                let mutability = Mutability::Mut;\n+                let place = unpack!(block = this.as_temp(block, Some(scope), expr, mutability));\n                 let operand = Operand::Move(Place::from(place));\n                 let then_block = this.cfg.start_new_block();\n                 let else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n+                let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n                 (then_block, else_block)\n             }\n@@ -1699,6 +1698,46 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n // Pat binding - used for `let` and function parameters as well.\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn lower_let(\n+        &mut self,\n+        mut block: BasicBlock,\n+        expr: &Expr<'tcx>,\n+        pat: &Pat<'tcx>,\n+        span: Span,\n+    ) -> (BasicBlock, BasicBlock) {\n+        let expr_span = expr.span;\n+        let expr_place_builder = unpack!(block = self.lower_scrutinee(block, expr, expr_span));\n+        let mut guard_candidate = Candidate::new(expr_place_builder.clone(), &pat, false);\n+        let wildcard = Pat::wildcard_from_ty(pat.ty);\n+        let mut otherwise_candidate = Candidate::new(expr_place_builder.clone(), &wildcard, false);\n+        let fake_borrow_temps = self.lower_match_tree(\n+            block,\n+            pat.span,\n+            false,\n+            &mut [&mut guard_candidate, &mut otherwise_candidate],\n+        );\n+        let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n+        let expr_place: Place<'tcx>;\n+        if let Ok(expr_builder) =\n+            expr_place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            expr_place = expr_builder.into_place(self.tcx, self.typeck_results);\n+            opt_expr_place = Some((Some(&expr_place), expr_span));\n+        }\n+        self.declare_bindings(None, pat.span.to(span), pat, ArmHasGuard(false), opt_expr_place);\n+        let post_guard_block = self.bind_pattern(\n+            self.source_info(pat.span),\n+            guard_candidate,\n+            None,\n+            &fake_borrow_temps,\n+            expr.span,\n+            None,\n+            None,\n+        );\n+        let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n+        (post_guard_block, otherwise_post_guard_block)\n+    }\n+\n     /// Initializes each of the bindings from the candidate by\n     /// moving/copying/ref'ing the source as appropriate. Tests the guard, if\n     /// any, and then branches to the arm. Returns the block for the case where\n@@ -1852,48 +1891,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     (e.span, self.test_bool(block, e, source_info))\n                 }\n                 Guard::IfLet(ref pat, scrutinee) => {\n-                    let scrutinee = &self.thir[scrutinee];\n-                    let scrutinee_span = scrutinee.span;\n-                    let scrutinee_place_builder =\n-                        unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span));\n-                    let mut guard_candidate =\n-                        Candidate::new(scrutinee_place_builder.clone(), &pat, false);\n-                    let wildcard = Pat::wildcard_from_ty(pat.ty);\n-                    let mut otherwise_candidate =\n-                        Candidate::new(scrutinee_place_builder.clone(), &wildcard, false);\n-                    let fake_borrow_temps = self.lower_match_tree(\n-                        block,\n-                        pat.span,\n-                        false,\n-                        &mut [&mut guard_candidate, &mut otherwise_candidate],\n-                    );\n-                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n-                    let scrutinee_place: Place<'tcx>;\n-                    if let Ok(scrutinee_builder) =\n-                        scrutinee_place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n-                    {\n-                        scrutinee_place =\n-                            scrutinee_builder.into_place(self.tcx, self.typeck_results);\n-                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n-                    }\n-                    self.declare_bindings(\n-                        None,\n-                        pat.span.to(arm_span.unwrap()),\n-                        pat,\n-                        ArmHasGuard(false),\n-                        opt_scrutinee_place,\n-                    );\n-                    let post_guard_block = self.bind_pattern(\n-                        self.source_info(pat.span),\n-                        guard_candidate,\n-                        None,\n-                        &fake_borrow_temps,\n-                        scrutinee_span,\n-                        None,\n-                        None,\n-                    );\n-                    let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n-                    (scrutinee_span, (post_guard_block, otherwise_post_guard_block))\n+                    let s = &self.thir[scrutinee];\n+                    (s.span, self.lower_let(block, s, pat, arm_span.unwrap()))\n                 }\n             };\n             let source_info = self.source_info(guard_span);"}, {"sha": "05a5fcef16ae53adb459e44413e0669f459ccfb5", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -325,6 +325,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             | ExprKind::Return { .. }\n             | ExprKind::Yield { .. }\n             | ExprKind::Loop { .. }\n+            | ExprKind::Let { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::Box { .. }\n             | ExprKind::If { .. }\n@@ -475,6 +476,14 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n+            ExprKind::Let { expr: expr_id, .. } => {\n+                let let_expr = &self.thir[expr_id];\n+                if let ty::Adt(adt_def, _) = let_expr.ty.kind() {\n+                    if adt_def.is_union() {\n+                        self.requires_unsafe(expr.span, AccessToUnionField);\n+                    }\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, expr);"}, {"sha": "2b0aa41a4bd0d9b7a17994cb2543168578480047", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -590,6 +590,9 @@ impl<'tcx> Cx<'tcx> {\n                 },\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n             },\n+            hir::ExprKind::Let(ref pat, ref expr, _) => {\n+                ExprKind::Let { expr: self.mirror_expr(expr), pat: self.pattern_from_hir(pat) }\n+            }\n             hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n                 cond: self.mirror_expr(cond),\n                 then: self.mirror_expr(then),"}, {"sha": "50cbe0f71f552837c691295bf05eb7473156931f", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 129, "deletions": 63, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -55,9 +55,10 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         intravisit::walk_expr(self, ex);\n-\n-        if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.kind {\n-            self.check_match(scrut, arms, source);\n+        match &ex.kind {\n+            hir::ExprKind::Match(scrut, arms, source) => self.check_match(scrut, arms, *source),\n+            hir::ExprKind::Let(pat, scrut, span) => self.check_let(pat, scrut, *span),\n+            _ => {}\n         }\n     }\n \n@@ -117,6 +118,31 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         check_for_bindings_named_same_as_variants(self, pat);\n     }\n \n+    fn let_source(&mut self, pat: &'tcx hir::Pat<'tcx>, _expr: &hir::Expr<'_>) -> LetSource {\n+        let hir = self.tcx.hir();\n+        let parent = hir.get_parent_node(pat.hir_id);\n+        let parent_parent = hir.get_parent_node(parent);\n+        let parent_parent_node = hir.get(parent_parent);\n+\n+        let parent_parent_parent = hir.get_parent_node(parent_parent);\n+        let parent_parent_parent_parent = hir.get_parent_node(parent_parent_parent);\n+        let parent_parent_parent_parent_node = hir.get(parent_parent_parent_parent);\n+\n+        if let hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n+            ..\n+        }) = parent_parent_parent_parent_node\n+        {\n+            LetSource::WhileLet\n+        } else if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If { .. }, .. }) =\n+            parent_parent_node\n+        {\n+            LetSource::IfLet\n+        } else {\n+            LetSource::GenericLet\n+        }\n+    }\n+\n     fn lower_pattern<'p>(\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n@@ -144,6 +170,14 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         }\n     }\n \n+    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, expr: &hir::Expr<'_>, span: Span) {\n+        self.check_patterns(pat);\n+        let ls = self.let_source(pat, expr);\n+        let mut cx = self.new_cx(expr.hir_id);\n+        let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n+        check_let_reachability(&mut cx, ls, pat.hir_id, &tpat, span);\n+    }\n+\n     fn check_match(\n         &mut self,\n         scrut: &hir::Expr<'_>,\n@@ -158,7 +192,13 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n                 self.check_patterns(pat);\n                 let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-                check_if_let_guard(&mut cx, &tpat, pat.hir_id);\n+                check_let_reachability(\n+                    &mut cx,\n+                    LetSource::IfLetGuard,\n+                    pat.hir_id,\n+                    &tpat,\n+                    tpat.span,\n+                );\n             }\n         }\n \n@@ -181,8 +221,16 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n         let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n \n-        // Report unreachable arms.\n-        report_arm_reachability(&cx, &report, source);\n+        report_arm_reachability(&cx, &report, |_, arm_span, arm_hir_id, catchall| {\n+            match source {\n+                hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n+                    unreachable_pattern(cx.tcx, arm_span, arm_hir_id, catchall);\n+                }\n+                // Unreachable patterns in try and await expressions occur when one of\n+                // the arms are an uninhabited type. Which is OK.\n+                hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n+            }\n+        });\n \n         // Check if the match is exhaustive.\n         // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n@@ -349,89 +397,99 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n     });\n }\n \n-fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n-    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| match source {\n-        hir::MatchSource::IfLetDesugar { .. } => {\n-            let mut diag = lint.build(\"irrefutable `if let` pattern\");\n-            diag.note(\"this pattern will always match, so the `if let` is useless\");\n-            diag.help(\"consider replacing the `if let` with a `let`\");\n+fn irrefutable_let_pattern(id: HirId, ls: LetSource, span: Span, tcx: TyCtxt<'_>) {\n+    macro_rules! emit_diag {\n+        (\n+            $lint:expr,\n+            $source_name:expr,\n+            $note_sufix:expr,\n+            $help_sufix:expr\n+        ) => {{\n+            let mut diag = $lint.build(concat!(\"irrefutable \", $source_name, \" pattern\"));\n+            diag.note(concat!(\"this pattern will always match, so the \", $note_sufix));\n+            diag.help(concat!(\"consider \", $help_sufix));\n             diag.emit()\n+        }};\n+    }\n+\n+    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| match ls {\n+        LetSource::GenericLet => {\n+            emit_diag!(lint, \"`let`\", \"`let` is useless\", \"removing `let`\");\n         }\n-        hir::MatchSource::WhileLetDesugar => {\n-            let mut diag = lint.build(\"irrefutable `while let` pattern\");\n-            diag.note(\"this pattern will always match, so the loop will never exit\");\n-            diag.help(\"consider instead using a `loop { ... }` with a `let` inside it\");\n-            diag.emit()\n+        LetSource::IfLet => {\n+            emit_diag!(\n+                lint,\n+                \"`if let`\",\n+                \"`if let` is useless\",\n+                \"replacing the `if let` with a `let`\"\n+            );\n         }\n-        hir::MatchSource::IfLetGuardDesugar => {\n-            let mut diag = lint.build(\"irrefutable `if let` guard pattern\");\n-            diag.note(\"this pattern will always match, so the guard is useless\");\n-            diag.help(\"consider removing the guard and adding a `let` inside the match arm\");\n-            diag.emit()\n+        LetSource::IfLetGuard => {\n+            emit_diag!(\n+                lint,\n+                \"`if let` guard\",\n+                \"guard is useless\",\n+                \"removing the guard and adding a `let` inside the match arm\"\n+            );\n         }\n-        _ => {\n-            bug!(\n-                \"expected `if let`, `while let`, or `if let` guard HIR match source, found {:?}\",\n-                source,\n-            )\n+        LetSource::WhileLet => {\n+            emit_diag!(\n+                lint,\n+                \"`while let`\",\n+                \"loop will never exit\",\n+                \"instead using a `loop { ... }` with a `let` inside it\"\n+            );\n         }\n     });\n }\n \n-fn check_if_let_guard<'p, 'tcx>(\n+fn check_let_reachability<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    pat: &'p super::Pat<'tcx>,\n+    ls: LetSource,\n     pat_id: HirId,\n+    pat: &'p super::Pat<'tcx>,\n+    span: Span,\n ) {\n     let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n     let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty);\n-    report_arm_reachability(&cx, &report, hir::MatchSource::IfLetGuardDesugar);\n+\n+    report_arm_reachability(&cx, &report, |arm_index, arm_span, arm_hir_id, _| {\n+        match ls {\n+            LetSource::IfLet | LetSource::WhileLet => {\n+                match arm_index {\n+                    // The arm with the user-specified pattern.\n+                    0 => unreachable_pattern(cx.tcx, arm_span, arm_hir_id, None),\n+                    // The arm with the wildcard pattern.\n+                    1 => irrefutable_let_pattern(pat_id, ls, arm_span, cx.tcx),\n+                    _ => bug!(),\n+                }\n+            }\n+            LetSource::IfLetGuard if arm_index == 0 => {\n+                unreachable_pattern(cx.tcx, arm_span, arm_hir_id, None);\n+            }\n+            _ => {}\n+        }\n+    });\n \n     if report.non_exhaustiveness_witnesses.is_empty() {\n         // The match is exhaustive, i.e. the `if let` pattern is irrefutable.\n-        irrefutable_let_pattern(cx.tcx, pat.span, pat_id, hir::MatchSource::IfLetGuardDesugar)\n+        irrefutable_let_pattern(pat_id, ls, span, cx.tcx);\n     }\n }\n \n /// Report unreachable arms, if any.\n-fn report_arm_reachability<'p, 'tcx>(\n+fn report_arm_reachability<'p, 'tcx, F>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     report: &UsefulnessReport<'p, 'tcx>,\n-    source: hir::MatchSource,\n-) {\n+    unreachable: F,\n+) where\n+    F: Fn(usize, Span, HirId, Option<Span>),\n+{\n     use Reachability::*;\n     let mut catchall = None;\n     for (arm_index, (arm, is_useful)) in report.arm_usefulness.iter().enumerate() {\n         match is_useful {\n-            Unreachable => {\n-                match source {\n-                    hir::MatchSource::WhileDesugar => bug!(),\n-\n-                    hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n-                        // Check which arm we're on.\n-                        match arm_index {\n-                            // The arm with the user-specified pattern.\n-                            0 => unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, None),\n-                            // The arm with the wildcard pattern.\n-                            1 => irrefutable_let_pattern(cx.tcx, arm.pat.span, arm.hir_id, source),\n-                            _ => bug!(),\n-                        }\n-                    }\n-\n-                    hir::MatchSource::IfLetGuardDesugar => {\n-                        assert_eq!(arm_index, 0);\n-                        unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, None);\n-                    }\n-\n-                    hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                        unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, catchall);\n-                    }\n-\n-                    // Unreachable patterns in try and await expressions occur when one of\n-                    // the arms are an uninhabited type. Which is OK.\n-                    hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n-                }\n-            }\n+            Unreachable => unreachable(arm_index, arm.pat.span, arm.hir_id, catchall),\n             Reachable(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Reachable(unreachables) => {\n@@ -723,3 +781,11 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_\n         err.emit();\n     }\n }\n+\n+#[derive(Clone, Copy, Debug)]\n+pub enum LetSource {\n+    GenericLet,\n+    IfLet,\n+    IfLetGuard,\n+    WhileLet,\n+}"}, {"sha": "dda6c74d4decad0652f899684e7f50fe60491ec2", "filename": "compiler/rustc_mir_build/src/thir/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -57,6 +57,9 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n         Use { source } => visitor.visit_expr(&visitor.thir()[source]),\n         NeverToAny { source } => visitor.visit_expr(&visitor.thir()[source]),\n         Pointer { source, cast: _ } => visitor.visit_expr(&visitor.thir()[source]),\n+        Let { expr, .. } => {\n+            visitor.visit_expr(&visitor.thir()[expr]);\n+        }\n         Loop { body } => visitor.visit_expr(&visitor.thir()[body]),\n         Match { scrutinee, ref arms } => {\n             visitor.visit_expr(&visitor.thir()[scrutinee]);"}, {"sha": "6259eff5a1a0f0a6f6984d710dce400670684eb7", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1867,7 +1867,7 @@ impl<'a> Parser<'a> {\n         })?;\n         let span = lo.to(expr.span);\n         self.sess.gated_spans.gate(sym::let_chains, span);\n-        Ok(self.mk_expr(span, ExprKind::Let(pat, expr), attrs))\n+        Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span), attrs))\n     }\n \n     /// Parses an `else { ... }` expression (`else` token already eaten)."}, {"sha": "4a82252a32b13c95e55e145cc488f8e705f39e32", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -48,11 +48,8 @@ impl NonConstExpr {\n \n             Self::Match(TryDesugar) => &[sym::const_try],\n \n-            Self::Match(IfLetGuardDesugar) => bug!(\"`if let` guard outside a `match` expression\"),\n-\n             // All other expressions are allowed.\n-            Self::Loop(Loop | While | WhileLet)\n-            | Self::Match(WhileDesugar | WhileLetDesugar | Normal | IfLetDesugar { .. }) => &[],\n+            Self::Loop(Loop | While) | Self::Match(Normal) => &[],\n         };\n \n         Some(gates)\n@@ -277,9 +274,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n             hir::ExprKind::Match(_, _, source) => {\n                 let non_const_expr = match source {\n                     // These are handled by `ExprKind::Loop` above.\n-                    hir::MatchSource::WhileDesugar\n-                    | hir::MatchSource::WhileLetDesugar\n-                    | hir::MatchSource::ForLoopDesugar => None,\n+                    hir::MatchSource::ForLoopDesugar => None,\n \n                     _ => Some(NonConstExpr::Match(*source)),\n                 };"}, {"sha": "2cd780e1b9bbe9d92071e6b64b88c2078ec9d254", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -429,6 +429,11 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n+            hir::ExprKind::Let(ref pat, ..) => {\n+                self.add_from_pat(pat);\n+                intravisit::walk_expr(self, expr);\n+            }\n+\n             // live nodes required for interesting control flow:\n             hir::ExprKind::If(..) | hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) => {\n                 self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n@@ -852,6 +857,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n+            hir::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+                let succ = self.propagate_through_expr(scrutinee, succ);\n+                self.define_bindings_in_pat(pat, succ)\n+            }\n+\n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident\n             hir::ExprKind::Loop(ref blk, ..) => self.propagate_through_loop(expr, &blk, succ),\n@@ -1303,6 +1313,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n \n     fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         check_expr(self, ex);\n+        intravisit::walk_expr(self, ex);\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n@@ -1358,6 +1369,10 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n         }\n \n+        hir::ExprKind::Let(ref pat, ..) => {\n+            this.check_unused_vars_in_pat(pat, None, |_, _, _, _| {});\n+        }\n+\n         // no correctness conditions related to liveness\n         hir::ExprKind::Call(..)\n         | hir::ExprKind::MethodCall(..)\n@@ -1388,8 +1403,6 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::Type(..)\n         | hir::ExprKind::Err => {}\n     }\n-\n-    intravisit::walk_expr(this, expr);\n }\n \n impl<'tcx> Liveness<'_, 'tcx> {"}, {"sha": "d3ecd18a93c5a39a458f9457bac691f62d152261", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -221,6 +221,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n             | ExprKind::Index(..)\n             | ExprKind::Path(..)\n             | ExprKind::AddrOf(..)\n+            | ExprKind::Let(..)\n             | ExprKind::Break(..)\n             | ExprKind::Continue(..)\n             | ExprKind::Ret(..)"}, {"sha": "00d291946df685067e3fcc500629ab7ecb2b2889", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -2309,7 +2309,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.resolve_expr(e, Some(&expr));\n             }\n \n-            ExprKind::Let(ref pat, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee, _) => {\n                 self.visit_expr(scrutinee);\n                 self.resolve_pattern_top(pat, PatternSource::Let);\n             }"}, {"sha": "846c5fc09f2cfbe63df3f8b6e5926c76bb7680de", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 111, "deletions": 196, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -24,35 +24,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n-        use hir::MatchSource::*;\n-        let (source_if, if_no_else, force_scrutinee_bool) = match match_src {\n-            IfLetDesugar { contains_else_clause, .. } => (true, !contains_else_clause, false),\n-            WhileDesugar => (false, false, true),\n-            _ => (false, false, false),\n-        };\n-\n-        // Type check the discriminant and get its type.\n-        let scrutinee_ty = if force_scrutinee_bool {\n-            // Here we want to ensure:\n-            //\n-            // 1. That default match bindings are *not* accepted in the condition of an\n-            //    `if` expression. E.g. given `fn foo() -> &bool;` we reject `if foo() { .. }`.\n-            //\n-            // 2. By expecting `bool` for `expr` we get nice diagnostics for e.g. `if x = y { .. }`.\n-            //\n-            // FIXME(60707): Consider removing hack with principled solution.\n-            self.check_expr_has_type_or_error(scrut, self.tcx.types.bool, |_| {})\n-        } else {\n-            self.demand_scrutinee_type(scrut, arms_contain_ref_bindings(arms), arms.is_empty())\n-        };\n+        let acrb = arms_contain_ref_bindings(arms);\n+        let scrutinee_ty = self.demand_scrutinee_type(scrut, acrb, arms.is_empty());\n \n         // If there are no arms, that is a diverging match; a special case.\n         if arms.is_empty() {\n             self.diverges.set(self.diverges.get() | Diverges::always(expr.span));\n             return tcx.types.never;\n         }\n \n-        self.warn_arms_when_scrutinee_diverges(arms, match_src);\n+        self.warn_arms_when_scrutinee_diverges(arms);\n \n         // Otherwise, we have to union together the types that the arms produce and so forth.\n         let scrut_diverges = self.diverges.replace(Diverges::Maybe);\n@@ -112,128 +93,95 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             self.diverges.set(Diverges::Maybe);\n-            let arm_ty = if source_if\n-                && if_no_else\n-                && i != 0\n-                && self.if_fallback_coercion(\n-                    expr.span,\n-                    &arms[0].body,\n-                    &mut coercion,\n-                    |hir_id, span| self.coercion_reason_match(hir_id, span),\n-                ) {\n-                tcx.ty_error()\n-            } else {\n-                // Only call this if this is not an `if` expr with an expected type and no `else`\n-                // clause to avoid duplicated type errors. (#60254)\n-                self.check_expr_with_expectation(&arm.body, expected)\n-            };\n+\n+            let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n             let opt_suggest_box_span =\n                 self.opt_suggest_box_span(arm.body.span, arm_ty, orig_expected);\n \n-            if source_if {\n-                let then_expr = &arms[0].body;\n-                match (i, if_no_else) {\n-                    (0, _) => coercion.coerce(self, &self.misc(expr.span), &arm.body, arm_ty),\n-                    (_, true) => {} // Handled above to avoid duplicated type errors (#60254).\n-                    (_, _) => {\n-                        let then_ty = prior_arm_ty.unwrap();\n-                        let cause = self.if_cause(\n+            let (arm_span, semi_span) =\n+                self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n+            let (span, code) = match i {\n+                // The reason for the first arm to fail is not that the match arms diverge,\n+                // but rather that there's a prior obligation that doesn't hold.\n+                0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n+                _ => (\n+                    expr.span,\n+                    ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                        arm_span,\n+                        scrut_span: scrut.span,\n+                        semi_span,\n+                        source: match_src,\n+                        prior_arms: other_arms.clone(),\n+                        last_ty: prior_arm_ty.unwrap(),\n+                        scrut_hir_id: scrut.hir_id,\n+                        opt_suggest_box_span,\n+                    }),\n+                ),\n+            };\n+            let cause = self.cause(span, code);\n+\n+            // This is the moral equivalent of `coercion.coerce(self, cause, arm.body, arm_ty)`.\n+            // We use it this way to be able to expand on the potential error and detect when a\n+            // `match` tail statement could be a tail expression instead. If so, we suggest\n+            // removing the stray semicolon.\n+            coercion.coerce_inner(\n+                self,\n+                &cause,\n+                Some(&arm.body),\n+                arm_ty,\n+                Some(&mut |err: &mut DiagnosticBuilder<'_>| {\n+                    let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+                        Some(ret_coercion) if self.in_tail_expr => {\n+                            let ret_ty = ret_coercion.borrow().expected_ty();\n+                            let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                            self.can_coerce(arm_ty, ret_ty)\n+                                && prior_arm_ty.map_or(true, |t| self.can_coerce(t, ret_ty))\n+                                // The match arms need to unify for the case of `impl Trait`.\n+                                && !matches!(ret_ty.kind(), ty::Opaque(..))\n+                        }\n+                        _ => false,\n+                    };\n+                    if let (Expectation::IsLast(stmt), Some(ret), true) =\n+                        (orig_expected, self.ret_type_span, can_coerce_to_return_ty)\n+                    {\n+                        let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+                        let mut ret_span: MultiSpan = semi_span.into();\n+                        ret_span.push_span_label(\n                             expr.span,\n-                            then_expr,\n-                            &arm.body,\n-                            then_ty,\n-                            arm_ty,\n-                            opt_suggest_box_span,\n+                            \"this could be implicitly returned but it is a statement, not a \\\n+                                tail expression\"\n+                                .to_owned(),\n                         );\n-                        coercion.coerce(self, &cause, &arm.body, arm_ty);\n-                    }\n-                }\n-            } else {\n-                let (arm_span, semi_span) =\n-                    self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n-                let (span, code) = match i {\n-                    // The reason for the first arm to fail is not that the match arms diverge,\n-                    // but rather that there's a prior obligation that doesn't hold.\n-                    0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                    _ => (\n-                        expr.span,\n-                        ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                            arm_span,\n-                            scrut_span: scrut.span,\n+                        ret_span.push_span_label(\n+                            ret,\n+                            \"the `match` arms can conform to this return type\".to_owned(),\n+                        );\n+                        ret_span.push_span_label(\n                             semi_span,\n-                            source: match_src,\n-                            prior_arms: other_arms.clone(),\n-                            last_ty: prior_arm_ty.unwrap(),\n-                            scrut_hir_id: scrut.hir_id,\n-                            opt_suggest_box_span,\n-                        }),\n-                    ),\n-                };\n-                let cause = self.cause(span, code);\n-\n-                // This is the moral equivalent of `coercion.coerce(self, cause, arm.body, arm_ty)`.\n-                // We use it this way to be able to expand on the potential error and detect when a\n-                // `match` tail statement could be a tail expression instead. If so, we suggest\n-                // removing the stray semicolon.\n-                coercion.coerce_inner(\n-                    self,\n-                    &cause,\n-                    Some(&arm.body),\n-                    arm_ty,\n-                    Some(&mut |err: &mut DiagnosticBuilder<'_>| {\n-                        let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n-                            Some(ret_coercion) if self.in_tail_expr => {\n-                                let ret_ty = ret_coercion.borrow().expected_ty();\n-                                let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-                                self.can_coerce(arm_ty, ret_ty)\n-                                    && prior_arm_ty.map_or(true, |t| self.can_coerce(t, ret_ty))\n-                                    // The match arms need to unify for the case of `impl Trait`.\n-                                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n-                            }\n-                            _ => false,\n-                        };\n-                        if let (Expectation::IsLast(stmt), Some(ret), true) =\n-                            (orig_expected, self.ret_type_span, can_coerce_to_return_ty)\n-                        {\n-                            let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n-                            let mut ret_span: MultiSpan = semi_span.into();\n-                            ret_span.push_span_label(\n-                                expr.span,\n-                                \"this could be implicitly returned but it is a statement, not a \\\n-                                 tail expression\"\n-                                    .to_owned(),\n-                            );\n-                            ret_span.push_span_label(\n-                                ret,\n-                                \"the `match` arms can conform to this return type\".to_owned(),\n-                            );\n-                            ret_span.push_span_label(\n-                                semi_span,\n-                                \"the `match` is a statement because of this semicolon, consider \\\n-                                 removing it\"\n-                                    .to_owned(),\n-                            );\n-                            err.span_note(\n-                                ret_span,\n-                                \"you might have meant to return the `match` expression\",\n-                            );\n-                            err.tool_only_span_suggestion(\n-                                semi_span,\n-                                \"remove this semicolon\",\n-                                String::new(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }),\n-                    false,\n-                );\n+                            \"the `match` is a statement because of this semicolon, consider \\\n+                                removing it\"\n+                                .to_owned(),\n+                        );\n+                        err.span_note(\n+                            ret_span,\n+                            \"you might have meant to return the `match` expression\",\n+                        );\n+                        err.tool_only_span_suggestion(\n+                            semi_span,\n+                            \"remove this semicolon\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }),\n+                false,\n+            );\n \n-                other_arms.push(arm_span);\n-                if other_arms.len() > 5 {\n-                    other_arms.remove(0);\n-                }\n+            other_arms.push(arm_span);\n+            if other_arms.len() > 5 {\n+                other_arms.remove(0);\n             }\n             prior_arm_ty = Some(arm_ty);\n         }\n@@ -283,39 +231,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n-    fn warn_arms_when_scrutinee_diverges(\n-        &self,\n-        arms: &'tcx [hir::Arm<'tcx>],\n-        source: hir::MatchSource,\n-    ) {\n-        use hir::MatchSource::*;\n-        let msg = match source {\n-            IfLetDesugar { .. } => \"block in `if` expression\",\n-            WhileDesugar { .. } | WhileLetDesugar { .. } => \"block in `while` expression\",\n-            _ => \"arm\",\n-        };\n+    fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {\n         for arm in arms {\n-            self.warn_if_unreachable(arm.body.hir_id, arm.body.span, msg);\n+            self.warn_if_unreachable(arm.body.hir_id, arm.body.span, \"arm\");\n         }\n     }\n \n     /// Handle the fallback arm of a desugared if(-let) like a missing else.\n     ///\n     /// Returns `true` if there was an error forcing the coercion to the `()` type.\n-    pub(crate) fn if_fallback_coercion<F, T>(\n+    pub(super) fn if_fallback_coercion<T>(\n         &self,\n         span: Span,\n         then_expr: &'tcx hir::Expr<'tcx>,\n         coercion: &mut CoerceMany<'tcx, '_, T>,\n-        ret_reason: F,\n     ) -> bool\n     where\n-        F: Fn(hir::HirId, Span) -> Option<(Span, String)>,\n         T: AsCoercionSite,\n     {\n         // If this `if` expr is the parent's function return expr,\n         // the cause of the type coercion is the return type, point at it. (#25228)\n-        let ret_reason = ret_reason(then_expr.hir_id, span);\n+        let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, span);\n         let cause = self.cause(span, ObligationCauseCode::IfExpressionWithNoElse);\n         let mut error = false;\n         coercion.coerce_forced_unit(\n@@ -338,55 +274,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error\n     }\n \n-    pub(crate) fn coercion_reason_if(\n-        &self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-    ) -> Option<(Span, String)> {\n-        self.coercion_reason_inner(hir_id, span, 1)\n-    }\n-\n-    pub(crate) fn coercion_reason_match(\n-        &self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-    ) -> Option<(Span, String)> {\n-        self.coercion_reason_inner(hir_id, span, 2)\n-    }\n-\n-    fn coercion_reason_inner(\n-        &self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-        parent_index: usize,\n-    ) -> Option<(Span, String)> {\n-        let hir = self.tcx.hir();\n-        let mut parent_iter = hir.parent_iter(hir_id);\n-        let (_, node) = parent_iter.nth(parent_index)?;\n-        match node {\n-            hir::Node::Block(block) => {\n-                let expr = block.expr?;\n-                // check that the body's parent is an fn\n-                let (_, parent) = parent_iter.nth(1)?;\n-                if let hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. }) = parent {\n-                    // check that the `if` expr without `else` is the fn body's expr\n-                    if expr.span == span {\n-                        let (fn_decl, _) = self.get_fn_decl(hir_id)?;\n+    fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, sp: Span) -> Option<(Span, String)> {\n+        let node = {\n+            let rslt = self.tcx.hir().get_parent_node(self.tcx.hir().get_parent_node(hir_id));\n+            self.tcx.hir().get(rslt)\n+        };\n+        if let hir::Node::Block(block) = node {\n+            // check that the body's parent is an fn\n+            let parent = self\n+                .tcx\n+                .hir()\n+                .get(self.tcx.hir().get_parent_node(self.tcx.hir().get_parent_node(block.hir_id)));\n+            if let (Some(expr), hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })) =\n+                (&block.expr, parent)\n+            {\n+                // check that the `if` expr without `else` is the fn body's expr\n+                if expr.span == sp {\n+                    return self.get_fn_decl(hir_id).and_then(|(fn_decl, _)| {\n                         let span = fn_decl.output.span();\n                         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok()?;\n-                        return Some((\n-                            span,\n-                            format!(\"expected `{}` because of this return type\", snippet),\n-                        ));\n-                    }\n+                        Some((span, format!(\"expected `{}` because of this return type\", snippet)))\n+                    });\n                 }\n-                None\n             }\n-            hir::Node::Local(hir::Local { ty: Some(_), pat, .. }) => {\n-                Some((pat.span, \"expected because of this assignment\".to_string()))\n-            }\n-            _ => None,\n         }\n+        if let hir::Node::Local(hir::Local { ty: Some(_), pat, .. }) = node {\n+            return Some((pat.span, \"expected because of this assignment\".to_string()));\n+        }\n+        None\n     }\n \n     pub(crate) fn if_cause(\n@@ -492,7 +407,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn demand_scrutinee_type(\n+    pub(super) fn demand_scrutinee_type(\n         &self,\n         scrut: &'tcx hir::Expr<'tcx>,\n         contains_ref_bindings: Option<hir::Mutability>,"}, {"sha": "23ce4275d4009bb23b085f555f72e16e8a9c9c82", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -187,7 +187,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n-            ExprKind::Block(..) | ExprKind::If(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {}\n+            ExprKind::Block(..)\n+            | ExprKind::If(..)\n+            | ExprKind::Let(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Match(..) => {}\n             // If `expr` is a result of desugaring the try block and is an ok-wrapped\n             // diverging expression (e.g. it arose from desugaring of `try { return }`),\n             // we skip issuing a warning because it is autogenerated code.\n@@ -262,6 +266,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n+            ExprKind::Let(pat, let_expr, _) => self.check_expr_let(let_expr, pat),\n             ExprKind::Loop(body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n@@ -802,7 +807,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let cond_ty = self.check_expr_has_type_or_error(cond_expr, self.tcx.types.bool, |_| {});\n \n-        self.warn_if_unreachable(cond_expr.hir_id, then_expr.span, \"block in `if` expression\");\n+        self.warn_if_unreachable(\n+            cond_expr.hir_id,\n+            then_expr.span,\n+            \"block in `if` or `while` expression\",\n+        );\n \n         let cond_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n@@ -837,9 +846,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n         } else {\n-            self.if_fallback_coercion(sp, then_expr, &mut coerce, |hir_id, span| {\n-                self.coercion_reason_if(hir_id, span)\n-            });\n+            self.if_fallback_coercion(sp, then_expr, &mut coerce);\n \n             // If the condition is false we can't diverge.\n             self.diverges.set(cond_diverges);\n@@ -875,26 +882,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             if !lhs.is_syntactic_place_expr() {\n                 // Do not suggest `if let x = y` as `==` is way more likely to be the intention.\n-                let mut span_err = || {\n-                    // Likely `if let` intended.\n+                let hir = self.tcx.hir();\n+                if let hir::Node::Expr(hir::Expr { kind: ExprKind::If { .. }, .. }) =\n+                    hir.get(hir.get_parent_node(hir.get_parent_node(expr.hir_id)))\n+                {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_lo(),\n                         \"you might have meant to use pattern matching\",\n                         \"let \".to_string(),\n                         applicability,\n                     );\n-                };\n-                if let hir::Node::Expr(hir::Expr {\n-                    kind: ExprKind::Match(_, _, hir::MatchSource::WhileDesugar),\n-                    ..\n-                }) = self.tcx.hir().get(\n-                    self.tcx.hir().get_parent_node(self.tcx.hir().get_parent_node(expr.hir_id)),\n-                ) {\n-                    span_err();\n-                } else if let hir::Node::Expr(hir::Expr { kind: ExprKind::If { .. }, .. }) =\n-                    self.tcx.hir().get(self.tcx.hir().get_parent_node(expr.hir_id))\n-                {\n-                    span_err();\n                 }\n             }\n             if eq {\n@@ -929,6 +926,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn check_expr_let(&self, expr: &'tcx hir::Expr<'tcx>, pat: &'tcx hir::Pat<'tcx>) -> Ty<'tcx> {\n+        self.warn_if_unreachable(expr.hir_id, expr.span, \"block in `let` expression\");\n+        let expr_ty = self.demand_scrutinee_type(expr, pat.contains_explicit_ref_binding(), false);\n+        self.check_pat_top(pat, expr_ty, Some(expr.span), true);\n+        self.tcx.types.bool\n+    }\n+\n     fn check_expr_loop(\n         &self,\n         body: &'tcx hir::Block<'tcx>,\n@@ -943,7 +947,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(CoerceMany::new(coerce_to))\n             }\n \n-            hir::LoopSource::While | hir::LoopSource::WhileLet | hir::LoopSource::ForLoop => None,\n+            hir::LoopSource::While | hir::LoopSource::ForLoop => None,\n         };\n \n         let ctxt = BreakableCtxt {"}, {"sha": "3b241317aa3ef43d0deeca6ac2e9059cbc94117f", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -229,6 +229,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            hir::ExprKind::Let(ref pat, ref expr, _) => {\n+                self.walk_local(expr, pat, |t| t.borrow_expr(&expr, ty::ImmBorrow));\n+            }\n+\n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n \n@@ -428,10 +432,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt<'_>) {\n         match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n-                self.walk_local(&local);\n+            hir::StmtKind::Local(hir::Local { pat, init: Some(ref expr), .. }) => {\n+                self.walk_local(expr, pat, |_| {});\n             }\n \n+            hir::StmtKind::Local(_) => {}\n+\n             hir::StmtKind::Item(_) => {\n                 // We don't visit nested items in this visitor,\n                 // only the fn body we were given.\n@@ -443,16 +449,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: &hir::Local<'_>) {\n-        if let Some(ref expr) = local.init {\n-            // Variable declarations with\n-            // initializers are considered\n-            // \"assigns\", which is handled by\n-            // `walk_pat`:\n-            self.walk_expr(&expr);\n-            let init_place = return_if_err!(self.mc.cat_expr(&expr));\n-            self.walk_irrefutable_pat(&init_place, &local.pat);\n-        }\n+    fn walk_local<F>(&mut self, expr: &hir::Expr<'_>, pat: &hir::Pat<'_>, mut f: F)\n+    where\n+        F: FnMut(&mut Self),\n+    {\n+        self.walk_expr(&expr);\n+        let expr_place = return_if_err!(self.mc.cat_expr(&expr));\n+        f(self);\n+        self.walk_irrefutable_pat(&expr_place, &pat);\n     }\n \n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved"}, {"sha": "f876d0f2513679275ad6199572c5f5d35b25d015", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -368,6 +368,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Tup(..)\n             | hir::ExprKind::Binary(..)\n             | hir::ExprKind::Block(..)\n+            | hir::ExprKind::Let(..)\n             | hir::ExprKind::Loop(..)\n             | hir::ExprKind::Match(..)\n             | hir::ExprKind::Lit(..)"}, {"sha": "ddae9c9f03256473dc1860c578336276f7e9a02c", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -191,7 +191,7 @@ pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n     let mut ret = 1;"}, {"sha": "d385974893ca3e2f625e0b94c738983fd38df119", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -141,7 +141,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -153,8 +153,6 @@ pub fn change_break_label() {\n     }\n }\n \n-\n-\n // Add loop label to continue\n #[cfg(cfail1)]\n pub fn add_loop_label_to_continue() {\n@@ -191,7 +189,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "299622e45c67b179ecdeba760a6d0032663a3205", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -141,7 +141,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -191,7 +191,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "a7e4a131bfb729224c59522a8d216b7ee24c1a2b", "filename": "src/test/mir-opt/funky_arms.float_to_exponential_common.ConstProp.diff", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -94,35 +94,34 @@\n       bb7: {\n           StorageLive(_10);                // scope 2 at $DIR/funky_arms.rs:24:17: 24:26\n           _10 = ((_7 as Some).0: usize);   // scope 2 at $DIR/funky_arms.rs:24:17: 24:26\n-          StorageLive(_11);                // scope 3 at $DIR/funky_arms.rs:26:43: 26:46\n-          _11 = &mut (*_1);                // scope 3 at $DIR/funky_arms.rs:26:43: 26:46\n-          StorageLive(_12);                // scope 3 at $DIR/funky_arms.rs:26:48: 26:51\n-          _12 = _2;                        // scope 3 at $DIR/funky_arms.rs:26:48: 26:51\n-          StorageLive(_13);                // scope 3 at $DIR/funky_arms.rs:26:53: 26:57\n-          _13 = _6;                        // scope 3 at $DIR/funky_arms.rs:26:53: 26:57\n-          StorageLive(_14);                // scope 3 at $DIR/funky_arms.rs:26:59: 26:79\n-          StorageLive(_15);                // scope 3 at $DIR/funky_arms.rs:26:59: 26:75\n-          StorageLive(_16);                // scope 3 at $DIR/funky_arms.rs:26:59: 26:68\n-          _16 = _10;                       // scope 3 at $DIR/funky_arms.rs:26:59: 26:68\n-          _15 = move _16 as u32 (Misc);    // scope 3 at $DIR/funky_arms.rs:26:59: 26:75\n-          StorageDead(_16);                // scope 3 at $DIR/funky_arms.rs:26:74: 26:75\n-          _14 = Add(move _15, const 1_u32); // scope 3 at $DIR/funky_arms.rs:26:59: 26:79\n-          StorageDead(_15);                // scope 3 at $DIR/funky_arms.rs:26:78: 26:79\n-          StorageLive(_17);                // scope 3 at $DIR/funky_arms.rs:26:81: 26:86\n-          _17 = _3;                        // scope 3 at $DIR/funky_arms.rs:26:81: 26:86\n-          _0 = float_to_exponential_common_exact::<T>(move _11, move _12, move _13, move _14, move _17) -> bb8; // scope 3 at $DIR/funky_arms.rs:26:9: 26:87\n+          StorageLive(_11);                // scope 2 at $DIR/funky_arms.rs:26:43: 26:46\n+          _11 = &mut (*_1);                // scope 2 at $DIR/funky_arms.rs:26:43: 26:46\n+          StorageLive(_12);                // scope 2 at $DIR/funky_arms.rs:26:48: 26:51\n+          _12 = _2;                        // scope 2 at $DIR/funky_arms.rs:26:48: 26:51\n+          StorageLive(_13);                // scope 2 at $DIR/funky_arms.rs:26:53: 26:57\n+          _13 = _6;                        // scope 2 at $DIR/funky_arms.rs:26:53: 26:57\n+          StorageLive(_14);                // scope 2 at $DIR/funky_arms.rs:26:59: 26:79\n+          StorageLive(_15);                // scope 2 at $DIR/funky_arms.rs:26:59: 26:75\n+          StorageLive(_16);                // scope 2 at $DIR/funky_arms.rs:26:59: 26:68\n+          _16 = _10;                       // scope 2 at $DIR/funky_arms.rs:26:59: 26:68\n+          _15 = move _16 as u32 (Misc);    // scope 2 at $DIR/funky_arms.rs:26:59: 26:75\n+          StorageDead(_16);                // scope 2 at $DIR/funky_arms.rs:26:74: 26:75\n+          _14 = Add(move _15, const 1_u32); // scope 2 at $DIR/funky_arms.rs:26:59: 26:79\n+          StorageDead(_15);                // scope 2 at $DIR/funky_arms.rs:26:78: 26:79\n+          StorageLive(_17);                // scope 2 at $DIR/funky_arms.rs:26:81: 26:86\n+          _17 = _3;                        // scope 2 at $DIR/funky_arms.rs:26:81: 26:86\n+          _0 = float_to_exponential_common_exact::<T>(move _11, move _12, move _13, move _14, move _17) -> bb8; // scope 2 at $DIR/funky_arms.rs:26:9: 26:87\n                                            // mir::Constant\n                                            // + span: $DIR/funky_arms.rs:26:9: 26:42\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r mut std::fmt::Formatter<'s>, &'t0 T, core::num::flt2dec::Sign, u32, bool) -> std::result::Result<(), std::fmt::Error> {float_to_exponential_common_exact::<T>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb8: {\n-          StorageDead(_17);                // scope 3 at $DIR/funky_arms.rs:26:86: 26:87\n-          StorageDead(_14);                // scope 3 at $DIR/funky_arms.rs:26:86: 26:87\n-          StorageDead(_13);                // scope 3 at $DIR/funky_arms.rs:26:86: 26:87\n-          StorageDead(_12);                // scope 3 at $DIR/funky_arms.rs:26:86: 26:87\n-          StorageDead(_11);                // scope 3 at $DIR/funky_arms.rs:26:86: 26:87\n-          StorageDead(_10);                // scope 2 at $DIR/funky_arms.rs:27:5: 27:6\n+          StorageDead(_17);                // scope 2 at $DIR/funky_arms.rs:26:86: 26:87\n+          StorageDead(_14);                // scope 2 at $DIR/funky_arms.rs:26:86: 26:87\n+          StorageDead(_13);                // scope 2 at $DIR/funky_arms.rs:26:86: 26:87\n+          StorageDead(_12);                // scope 2 at $DIR/funky_arms.rs:26:86: 26:87\n+          StorageDead(_11);                // scope 2 at $DIR/funky_arms.rs:26:86: 26:87\n           goto -> bb10;                    // scope 2 at $DIR/funky_arms.rs:24:5: 29:6\n       }\n   \n@@ -135,6 +134,7 @@\n       }\n   \n       bb10: {\n+          StorageDead(_10);                // scope 2 at $DIR/funky_arms.rs:29:5: 29:6\n           StorageDead(_6);                 // scope 1 at $DIR/funky_arms.rs:30:1: 30:2\n           StorageDead(_4);                 // scope 0 at $DIR/funky_arms.rs:30:1: 30:2\n           StorageDead(_7);                 // scope 0 at $DIR/funky_arms.rs:30:1: 30:2"}, {"sha": "0417ed8c88b137a396a5aaef26d23426c77ab58f", "filename": "src/test/mir-opt/issue_41888.main.ElaborateDrops.after.mir", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -26,7 +26,7 @@ fn main() -> () {\n         _8 = const false;                // scope 0 at $DIR/issue-41888.rs:7:9: 7:10\n         StorageLive(_1);                 // scope 0 at $DIR/issue-41888.rs:7:9: 7:10\n         StorageLive(_2);                 // scope 1 at $DIR/issue-41888.rs:8:8: 8:14\n-        _2 = cond() -> [return: bb1, unwind: bb11]; // scope 1 at $DIR/issue-41888.rs:8:8: 8:14\n+        _2 = cond() -> [return: bb1, unwind: bb12]; // scope 1 at $DIR/issue-41888.rs:8:8: 8:14\n                                          // mir::Constant\n                                          // + span: $DIR/issue-41888.rs:8:8: 8:12\n                                          // + literal: Const { ty: fn() -> bool {cond}, val: Value(Scalar(<ZST>)) }\n@@ -42,12 +42,12 @@ fn main() -> () {\n         _4 = K;                          // scope 1 at $DIR/issue-41888.rs:9:18: 9:19\n         _3 = E::F(move _4);              // scope 1 at $DIR/issue-41888.rs:9:13: 9:20\n         StorageDead(_4);                 // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n-        goto -> bb14;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n+        goto -> bb15;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n     }\n \n     bb3: {\n         _0 = const ();                   // scope 1 at $DIR/issue-41888.rs:14:6: 14:6\n-        goto -> bb8;                     // scope 1 at $DIR/issue-41888.rs:8:5: 14:6\n+        goto -> bb9;                     // scope 1 at $DIR/issue-41888.rs:8:5: 14:6\n     }\n \n     bb4: {\n@@ -69,84 +69,88 @@ fn main() -> () {\n         StorageLive(_6);                 // scope 1 at $DIR/issue-41888.rs:10:21: 10:23\n         _9 = const false;                // scope 1 at $DIR/issue-41888.rs:10:21: 10:23\n         _6 = move ((_1 as F).0: K);      // scope 1 at $DIR/issue-41888.rs:10:21: 10:23\n-        _0 = const ();                   // scope 2 at $DIR/issue-41888.rs:10:29: 13:10\n-        StorageDead(_6);                 // scope 1 at $DIR/issue-41888.rs:13:9: 13:10\n+        _0 = const ();                   // scope 1 at $DIR/issue-41888.rs:10:29: 13:10\n         goto -> bb8;                     // scope 1 at $DIR/issue-41888.rs:10:9: 13:10\n     }\n \n     bb8: {\n-        StorageDead(_2);                 // scope 1 at $DIR/issue-41888.rs:14:5: 14:6\n-        goto -> bb20;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        StorageDead(_6);                 // scope 1 at $DIR/issue-41888.rs:13:9: 13:10\n+        goto -> bb9;                     // scope 1 at $DIR/issue-41888.rs:8:5: 14:6\n     }\n \n     bb9: {\n+        StorageDead(_2);                 // scope 1 at $DIR/issue-41888.rs:14:5: 14:6\n+        goto -> bb21;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    }\n+\n+    bb10: {\n         _7 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         _8 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         _9 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         StorageDead(_1);                 // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n         return;                          // scope 0 at $DIR/issue-41888.rs:15:2: 15:2\n     }\n \n-    bb10 (cleanup): {\n-        goto -> bb11;                    // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n-    }\n-\n     bb11 (cleanup): {\n-        goto -> bb12;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        goto -> bb12;                    // scope 1 at $DIR/issue-41888.rs:9:19: 9:20\n     }\n \n     bb12 (cleanup): {\n-        resume;                          // scope 0 at $DIR/issue-41888.rs:6:1: 15:2\n+        goto -> bb13;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n     bb13 (cleanup): {\n+        resume;                          // scope 0 at $DIR/issue-41888.rs:6:1: 15:2\n+    }\n+\n+    bb14 (cleanup): {\n         _7 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _8 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _9 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _1 = move _3;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n-        goto -> bb10;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n+        goto -> bb11;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n     }\n \n-    bb14: {\n+    bb15: {\n         _7 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _8 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _9 = const true;                 // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         _1 = move _3;                    // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n         goto -> bb4;                     // scope 1 at $DIR/issue-41888.rs:9:9: 9:10\n     }\n \n-    bb15: {\n+    bb16: {\n         _7 = const false;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n-        goto -> bb9;                     // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        goto -> bb10;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb16 (cleanup): {\n-        goto -> bb12;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb17 (cleanup): {\n+        goto -> bb13;                    // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb17: {\n-        drop(_1) -> [return: bb15, unwind: bb12]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb18: {\n+        drop(_1) -> [return: bb16, unwind: bb13]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb18 (cleanup): {\n-        drop(_1) -> bb12;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb19 (cleanup): {\n+        drop(_1) -> bb13;                // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb19: {\n+    bb20: {\n         _10 = discriminant(_1);          // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n-        switchInt(move _10) -> [0_isize: bb15, otherwise: bb17]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        switchInt(move _10) -> [0_isize: bb16, otherwise: bb18]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb20: {\n-        switchInt(_7) -> [false: bb15, otherwise: bb19]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb21: {\n+        switchInt(_7) -> [false: bb16, otherwise: bb20]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb21 (cleanup): {\n+    bb22 (cleanup): {\n         _11 = discriminant(_1);          // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n-        switchInt(move _11) -> [0_isize: bb16, otherwise: bb18]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+        switchInt(move _11) -> [0_isize: bb17, otherwise: bb19]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n \n-    bb22 (cleanup): {\n-        switchInt(_7) -> [false: bb12, otherwise: bb21]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n+    bb23 (cleanup): {\n+        switchInt(_7) -> [false: bb13, otherwise: bb22]; // scope 0 at $DIR/issue-41888.rs:15:1: 15:2\n     }\n }"}, {"sha": "89ba5eeeef4e666557559f730388cd436a025200", "filename": "src/test/mir-opt/issues/issue_75439.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -13,8 +13,8 @@\n           let _4: u32;                     // in scope 1 at $DIR/issue-75439.rs:9:27: 9:29\n           scope 3 {\n               debug ip => _4;              // in scope 3 at $DIR/issue-75439.rs:9:27: 9:29\n-              scope 4 {\n-              }\n+          }\n+          scope 4 {\n           }\n       }\n       scope 2 {\n@@ -49,7 +49,7 @@\n       }\n   \n       bb5: {\n-          StorageLive(_5);                 // scope 3 at $DIR/issue-75439.rs:10:14: 10:38\n+          StorageLive(_5);                 // scope 1 at $DIR/issue-75439.rs:10:14: 10:38\n           StorageLive(_6);                 // scope 4 at $DIR/issue-75439.rs:10:33: 10:35\n           _6 = _4;                         // scope 4 at $DIR/issue-75439.rs:10:33: 10:35\n           _5 = transmute::<u32, [u8; 4]>(move _6) -> bb8; // scope 4 at $DIR/issue-75439.rs:10:23: 10:36\n@@ -61,25 +61,25 @@\n       bb6: {\n           StorageLive(_4);                 // scope 1 at $DIR/issue-75439.rs:9:27: 9:29\n           _4 = _2[3 of 4];                 // scope 1 at $DIR/issue-75439.rs:9:27: 9:29\n-          goto -> bb5;                     // scope 1 at $DIR/issue-75439.rs:9:5: 13:6\n+          goto -> bb5;                     // scope 1 at $DIR/issue-75439.rs:9:12: 9:30\n       }\n   \n       bb7: {\n           StorageLive(_4);                 // scope 1 at $DIR/issue-75439.rs:9:27: 9:29\n           _4 = _2[3 of 4];                 // scope 1 at $DIR/issue-75439.rs:9:27: 9:29\n-          goto -> bb5;                     // scope 1 at $DIR/issue-75439.rs:9:5: 13:6\n+          goto -> bb5;                     // scope 1 at $DIR/issue-75439.rs:9:12: 9:30\n       }\n   \n       bb8: {\n           StorageDead(_6);                 // scope 4 at $DIR/issue-75439.rs:10:35: 10:36\n-          ((_0 as Some).0: [u8; 4]) = move _5; // scope 3 at $DIR/issue-75439.rs:10:9: 10:39\n-          discriminant(_0) = 1;            // scope 3 at $DIR/issue-75439.rs:10:9: 10:39\n-          StorageDead(_5);                 // scope 3 at $DIR/issue-75439.rs:10:38: 10:39\n-          StorageDead(_4);                 // scope 1 at $DIR/issue-75439.rs:11:5: 11:6\n+          ((_0 as Some).0: [u8; 4]) = move _5; // scope 1 at $DIR/issue-75439.rs:10:9: 10:39\n+          discriminant(_0) = 1;            // scope 1 at $DIR/issue-75439.rs:10:9: 10:39\n+          StorageDead(_5);                 // scope 1 at $DIR/issue-75439.rs:10:38: 10:39\n           goto -> bb9;                     // scope 1 at $DIR/issue-75439.rs:9:5: 13:6\n       }\n   \n       bb9: {\n+          StorageDead(_4);                 // scope 1 at $DIR/issue-75439.rs:13:5: 13:6\n           StorageDead(_2);                 // scope 0 at $DIR/issue-75439.rs:14:1: 14:2\n           return;                          // scope 0 at $DIR/issue-75439.rs:14:2: 14:2\n       }"}, {"sha": "41a6fe30412d028e2ef6c2efdf0ebd3e9ad66f1a", "filename": "src/test/mir-opt/simplify_locals_fixedpoint.foo.SimplifyLocals.diff", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -37,17 +37,17 @@\n       bb2: {\n           StorageLive(_6);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:4:18: 4:19\n           _6 = (((_1.0: std::option::Option<u8>) as Some).0: u8); // scope 0 at $DIR/simplify-locals-fixedpoint.rs:4:18: 4:19\n--         StorageLive(_7);                 // scope 1 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:20\n--         StorageLive(_8);                 // scope 1 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:13\n--         _8 = _6;                         // scope 1 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:13\n--         _7 = Gt(move _8, const 42_u8);   // scope 1 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:20\n--         StorageDead(_8);                 // scope 1 at $DIR/simplify-locals-fixedpoint.rs:5:19: 5:20\n--         StorageDead(_7);                 // scope 1 at $DIR/simplify-locals-fixedpoint.rs:7:9: 7:10\n-          StorageDead(_6);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:8:5: 8:6\n+-         StorageLive(_7);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:20\n+-         StorageLive(_8);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:13\n+-         _8 = _6;                         // scope 0 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:13\n+-         _7 = Gt(move _8, const 42_u8);   // scope 0 at $DIR/simplify-locals-fixedpoint.rs:5:12: 5:20\n+-         StorageDead(_8);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:5:19: 5:20\n+-         StorageDead(_7);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:7:9: 7:10\n           goto -> bb3;                     // scope 0 at $DIR/simplify-locals-fixedpoint.rs:4:5: 8:6\n       }\n   \n       bb3: {\n+          StorageDead(_6);                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:8:5: 8:6\n           drop(_1) -> bb4;                 // scope 0 at $DIR/simplify-locals-fixedpoint.rs:9:1: 9:2\n       }\n   "}, {"sha": "ff05951a99b6343e3a38636a08365d312a594d7d", "filename": "src/test/mir-opt/unreachable.main.UnreachablePropagation.diff", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable.main.UnreachablePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable.main.UnreachablePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funreachable.main.UnreachablePropagation.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -6,15 +6,15 @@\n       let mut _1: std::option::Option<Empty>; // in scope 0 at $DIR/unreachable.rs:9:23: 9:30\n       let mut _2: isize;                   // in scope 0 at $DIR/unreachable.rs:9:12: 9:20\n       let _3: Empty;                       // in scope 0 at $DIR/unreachable.rs:9:17: 9:19\n+      let mut _4: i32;                     // in scope 0 at $DIR/unreachable.rs:10:13: 10:19\n       let _5: ();                          // in scope 0 at $DIR/unreachable.rs:12:9: 16:10\n       let mut _6: bool;                    // in scope 0 at $DIR/unreachable.rs:12:12: 12:16\n       let mut _7: !;                       // in scope 0 at $DIR/unreachable.rs:18:9: 18:21\n       scope 1 {\n           debug _x => _3;                  // in scope 1 at $DIR/unreachable.rs:9:17: 9:19\n-          let mut _4: i32;                 // in scope 1 at $DIR/unreachable.rs:10:13: 10:19\n-          scope 2 {\n-              debug _y => _4;              // in scope 2 at $DIR/unreachable.rs:10:13: 10:19\n-          }\n+      }\n+      scope 2 {\n+          debug _y => _4;                  // in scope 2 at $DIR/unreachable.rs:10:13: 10:19\n       }\n   \n       bb0: {\n@@ -33,14 +33,15 @@\n   \n       bb2: {\n           _0 = const ();                   // scope 0 at $DIR/unreachable.rs:19:6: 19:6\n+          StorageDead(_3);                 // scope 0 at $DIR/unreachable.rs:19:5: 19:6\n           StorageDead(_1);                 // scope 0 at $DIR/unreachable.rs:20:1: 20:2\n           return;                          // scope 0 at $DIR/unreachable.rs:20:2: 20:2\n -     }\n - \n -     bb3: {\n -         StorageLive(_3);                 // scope 0 at $DIR/unreachable.rs:9:17: 9:19\n -         _3 = move ((_1 as Some).0: Empty); // scope 0 at $DIR/unreachable.rs:9:17: 9:19\n--         StorageLive(_4);                 // scope 1 at $DIR/unreachable.rs:10:13: 10:19\n+-         StorageLive(_4);                 // scope 0 at $DIR/unreachable.rs:10:13: 10:19\n -         StorageLive(_5);                 // scope 2 at $DIR/unreachable.rs:12:9: 16:10\n -         StorageLive(_6);                 // scope 2 at $DIR/unreachable.rs:12:12: 12:16\n -         _6 = const true;                 // scope 2 at $DIR/unreachable.rs:12:12: 12:16"}, {"sha": "b94441d59195de902e71b5c7c52ef8ba4c8b39c1", "filename": "src/test/mir-opt/unreachable_asm.main.UnreachablePropagation.diff", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable_asm.main.UnreachablePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable_asm.main.UnreachablePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funreachable_asm.main.UnreachablePropagation.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -6,17 +6,17 @@\n       let mut _1: std::option::Option<Empty>; // in scope 0 at $DIR/unreachable_asm.rs:11:23: 11:30\n       let mut _2: isize;                   // in scope 0 at $DIR/unreachable_asm.rs:11:12: 11:20\n       let _3: Empty;                       // in scope 0 at $DIR/unreachable_asm.rs:11:17: 11:19\n+      let mut _4: i32;                     // in scope 0 at $DIR/unreachable_asm.rs:12:13: 12:19\n       let _5: ();                          // in scope 0 at $DIR/unreachable_asm.rs:14:9: 18:10\n       let mut _6: bool;                    // in scope 0 at $DIR/unreachable_asm.rs:14:12: 14:16\n       let _7: ();                          // in scope 0 at $DIR/unreachable_asm.rs:21:9: 21:37\n       let mut _8: !;                       // in scope 0 at $DIR/unreachable_asm.rs:22:9: 22:21\n       scope 1 {\n           debug _x => _3;                  // in scope 1 at $DIR/unreachable_asm.rs:11:17: 11:19\n-          let mut _4: i32;                 // in scope 1 at $DIR/unreachable_asm.rs:12:13: 12:19\n-          scope 2 {\n-              debug _y => _4;              // in scope 2 at $DIR/unreachable_asm.rs:12:13: 12:19\n-              scope 3 {\n-              }\n+      }\n+      scope 2 {\n+          debug _y => _4;                  // in scope 2 at $DIR/unreachable_asm.rs:12:13: 12:19\n+          scope 3 {\n           }\n       }\n   \n@@ -35,14 +35,15 @@\n   \n       bb2: {\n           _0 = const ();                   // scope 0 at $DIR/unreachable_asm.rs:23:6: 23:6\n+          StorageDead(_3);                 // scope 0 at $DIR/unreachable_asm.rs:23:5: 23:6\n           StorageDead(_1);                 // scope 0 at $DIR/unreachable_asm.rs:24:1: 24:2\n           return;                          // scope 0 at $DIR/unreachable_asm.rs:24:2: 24:2\n       }\n   \n       bb3: {\n           StorageLive(_3);                 // scope 0 at $DIR/unreachable_asm.rs:11:17: 11:19\n           _3 = move ((_1 as Some).0: Empty); // scope 0 at $DIR/unreachable_asm.rs:11:17: 11:19\n-          StorageLive(_4);                 // scope 1 at $DIR/unreachable_asm.rs:12:13: 12:19\n+          StorageLive(_4);                 // scope 0 at $DIR/unreachable_asm.rs:12:13: 12:19\n           StorageLive(_5);                 // scope 2 at $DIR/unreachable_asm.rs:14:9: 18:10\n           StorageLive(_6);                 // scope 2 at $DIR/unreachable_asm.rs:14:12: 14:16\n           _6 = const true;                 // scope 2 at $DIR/unreachable_asm.rs:14:12: 14:16"}, {"sha": "666843eab3d09ae074f6074124dd6854468cc6e6", "filename": "src/test/mir-opt/unreachable_asm_2.main.UnreachablePropagation.diff", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable_asm_2.main.UnreachablePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable_asm_2.main.UnreachablePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funreachable_asm_2.main.UnreachablePropagation.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -6,20 +6,20 @@\n       let mut _1: std::option::Option<Empty>; // in scope 0 at $DIR/unreachable_asm_2.rs:11:23: 11:30\n       let mut _2: isize;                   // in scope 0 at $DIR/unreachable_asm_2.rs:11:12: 11:20\n       let _3: Empty;                       // in scope 0 at $DIR/unreachable_asm_2.rs:11:17: 11:19\n+      let mut _4: i32;                     // in scope 0 at $DIR/unreachable_asm_2.rs:12:13: 12:19\n       let _5: ();                          // in scope 0 at $DIR/unreachable_asm_2.rs:14:9: 22:10\n       let mut _6: bool;                    // in scope 0 at $DIR/unreachable_asm_2.rs:14:12: 14:16\n       let _7: ();                          // in scope 0 at $DIR/unreachable_asm_2.rs:16:13: 16:41\n       let _8: ();                          // in scope 0 at $DIR/unreachable_asm_2.rs:20:13: 20:41\n       let mut _9: !;                       // in scope 0 at $DIR/unreachable_asm_2.rs:24:9: 24:21\n       scope 1 {\n           debug _x => _3;                  // in scope 1 at $DIR/unreachable_asm_2.rs:11:17: 11:19\n-          let mut _4: i32;                 // in scope 1 at $DIR/unreachable_asm_2.rs:12:13: 12:19\n-          scope 2 {\n-              debug _y => _4;              // in scope 2 at $DIR/unreachable_asm_2.rs:12:13: 12:19\n-              scope 3 {\n-              }\n-              scope 4 {\n-              }\n+      }\n+      scope 2 {\n+          debug _y => _4;                  // in scope 2 at $DIR/unreachable_asm_2.rs:12:13: 12:19\n+          scope 3 {\n+          }\n+          scope 4 {\n           }\n       }\n   \n@@ -38,14 +38,15 @@\n   \n       bb2: {\n           _0 = const ();                   // scope 0 at $DIR/unreachable_asm_2.rs:25:6: 25:6\n+          StorageDead(_3);                 // scope 0 at $DIR/unreachable_asm_2.rs:25:5: 25:6\n           StorageDead(_1);                 // scope 0 at $DIR/unreachable_asm_2.rs:26:1: 26:2\n           return;                          // scope 0 at $DIR/unreachable_asm_2.rs:26:2: 26:2\n       }\n   \n       bb3: {\n           StorageLive(_3);                 // scope 0 at $DIR/unreachable_asm_2.rs:11:17: 11:19\n           _3 = move ((_1 as Some).0: Empty); // scope 0 at $DIR/unreachable_asm_2.rs:11:17: 11:19\n-          StorageLive(_4);                 // scope 1 at $DIR/unreachable_asm_2.rs:12:13: 12:19\n+          StorageLive(_4);                 // scope 0 at $DIR/unreachable_asm_2.rs:12:13: 12:19\n           StorageLive(_5);                 // scope 2 at $DIR/unreachable_asm_2.rs:14:9: 22:10\n           StorageLive(_6);                 // scope 2 at $DIR/unreachable_asm_2.rs:14:12: 14:16\n           _6 = const true;                 // scope 2 at $DIR/unreachable_asm_2.rs:14:12: 14:16"}, {"sha": "32a067f22453d00a7b316cc7265539400d8af52e", "filename": "src/test/mir-opt/unreachable_diverging.main.UnreachablePropagation.diff", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable_diverging.main.UnreachablePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Funreachable_diverging.main.UnreachablePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funreachable_diverging.main.UnreachablePropagation.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -34,6 +34,7 @@\n   \n       bb2: {\n           _0 = const ();                   // scope 1 at $DIR/unreachable_diverging.rs:19:6: 19:6\n+          StorageDead(_4);                 // scope 1 at $DIR/unreachable_diverging.rs:19:5: 19:6\n           StorageDead(_1);                 // scope 0 at $DIR/unreachable_diverging.rs:20:1: 20:2\n           StorageDead(_2);                 // scope 0 at $DIR/unreachable_diverging.rs:20:1: 20:2\n           return;                          // scope 0 at $DIR/unreachable_diverging.rs:20:2: 20:2\n@@ -42,31 +43,31 @@\n       bb3: {\n           StorageLive(_4);                 // scope 1 at $DIR/unreachable_diverging.rs:14:17: 14:21\n           _4 = move ((_2 as Some).0: Empty); // scope 1 at $DIR/unreachable_diverging.rs:14:17: 14:21\n-          StorageLive(_5);                 // scope 2 at $DIR/unreachable_diverging.rs:15:9: 17:10\n-          StorageLive(_6);                 // scope 2 at $DIR/unreachable_diverging.rs:15:12: 15:13\n-          _6 = _1;                         // scope 2 at $DIR/unreachable_diverging.rs:15:12: 15:13\n--         switchInt(move _6) -> [false: bb5, otherwise: bb4]; // scope 2 at $DIR/unreachable_diverging.rs:15:9: 17:10\n-+         goto -> bb4;                     // scope 2 at $DIR/unreachable_diverging.rs:15:9: 17:10\n+          StorageLive(_5);                 // scope 1 at $DIR/unreachable_diverging.rs:15:9: 17:10\n+          StorageLive(_6);                 // scope 1 at $DIR/unreachable_diverging.rs:15:12: 15:13\n+          _6 = _1;                         // scope 1 at $DIR/unreachable_diverging.rs:15:12: 15:13\n+-         switchInt(move _6) -> [false: bb5, otherwise: bb4]; // scope 1 at $DIR/unreachable_diverging.rs:15:9: 17:10\n++         goto -> bb4;                     // scope 1 at $DIR/unreachable_diverging.rs:15:9: 17:10\n       }\n   \n       bb4: {\n--         _5 = loop_forever() -> bb6;      // scope 2 at $DIR/unreachable_diverging.rs:16:13: 16:27\n-+         _5 = loop_forever() -> bb5;      // scope 2 at $DIR/unreachable_diverging.rs:16:13: 16:27\n+-         _5 = loop_forever() -> bb6;      // scope 1 at $DIR/unreachable_diverging.rs:16:13: 16:27\n++         _5 = loop_forever() -> bb5;      // scope 1 at $DIR/unreachable_diverging.rs:16:13: 16:27\n                                            // mir::Constant\n                                            // + span: $DIR/unreachable_diverging.rs:16:13: 16:25\n                                            // + literal: Const { ty: fn() {loop_forever}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb5: {\n--         _5 = const ();                   // scope 2 at $DIR/unreachable_diverging.rs:17:10: 17:10\n--         goto -> bb6;                     // scope 2 at $DIR/unreachable_diverging.rs:15:9: 17:10\n+-         _5 = const ();                   // scope 1 at $DIR/unreachable_diverging.rs:17:10: 17:10\n+-         goto -> bb6;                     // scope 1 at $DIR/unreachable_diverging.rs:15:9: 17:10\n -     }\n - \n -     bb6: {\n-          StorageDead(_6);                 // scope 2 at $DIR/unreachable_diverging.rs:17:9: 17:10\n-          StorageDead(_5);                 // scope 2 at $DIR/unreachable_diverging.rs:17:9: 17:10\n-          StorageLive(_7);                 // scope 2 at $DIR/unreachable_diverging.rs:18:9: 18:22\n-          unreachable;                     // scope 2 at $DIR/unreachable_diverging.rs:18:15: 18:19\n+          StorageDead(_6);                 // scope 1 at $DIR/unreachable_diverging.rs:17:9: 17:10\n+          StorageDead(_5);                 // scope 1 at $DIR/unreachable_diverging.rs:17:9: 17:10\n+          StorageLive(_7);                 // scope 1 at $DIR/unreachable_diverging.rs:18:9: 18:22\n+          unreachable;                     // scope 1 at $DIR/unreachable_diverging.rs:18:15: 18:19\n       }\n   }\n   "}, {"sha": "91927dc7f1676e6944fec1ecd24a3f58c0d35c7c", "filename": "src/test/mir-opt/while_let_loops.change_loop_body.ConstProp.32bit.diff", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.32bit.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -9,6 +9,8 @@\n       let mut _4: isize;                   // in scope 0 at $DIR/while_let_loops.rs:7:15: 7:25\n       let mut _5: !;                       // in scope 0 at $DIR/while_let_loops.rs:7:33: 10:6\n       let mut _6: !;                       // in scope 0 at $DIR/while_let_loops.rs:7:5: 10:6\n+      let _7: ();                          // in scope 0 at $DIR/while_let_loops.rs:7:5: 10:6\n+      let mut _8: !;                       // in scope 0 at $DIR/while_let_loops.rs:7:5: 10:6\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/while_let_loops.rs:6:9: 6:15\n       }\n@@ -25,8 +27,10 @@\n       }\n   \n       bb1: {\n+          StorageLive(_7);                 // scope 1 at $DIR/while_let_loops.rs:7:5: 10:6\n           nop;                             // scope 1 at $DIR/while_let_loops.rs:7:5: 10:6\n-          goto -> bb4;                     // scope 1 at $DIR/while_let_loops.rs:7:5: 10:6\n+          StorageDead(_7);                 // scope 1 at $DIR/while_let_loops.rs:10:5: 10:6\n+          goto -> bb4;                     // scope 1 at no-location\n       }\n   \n       bb2: {"}, {"sha": "91927dc7f1676e6944fec1ecd24a3f58c0d35c7c", "filename": "src/test/mir-opt/while_let_loops.change_loop_body.ConstProp.64bit.diff", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.64bit.diff?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -9,6 +9,8 @@\n       let mut _4: isize;                   // in scope 0 at $DIR/while_let_loops.rs:7:15: 7:25\n       let mut _5: !;                       // in scope 0 at $DIR/while_let_loops.rs:7:33: 10:6\n       let mut _6: !;                       // in scope 0 at $DIR/while_let_loops.rs:7:5: 10:6\n+      let _7: ();                          // in scope 0 at $DIR/while_let_loops.rs:7:5: 10:6\n+      let mut _8: !;                       // in scope 0 at $DIR/while_let_loops.rs:7:5: 10:6\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/while_let_loops.rs:6:9: 6:15\n       }\n@@ -25,8 +27,10 @@\n       }\n   \n       bb1: {\n+          StorageLive(_7);                 // scope 1 at $DIR/while_let_loops.rs:7:5: 10:6\n           nop;                             // scope 1 at $DIR/while_let_loops.rs:7:5: 10:6\n-          goto -> bb4;                     // scope 1 at $DIR/while_let_loops.rs:7:5: 10:6\n+          StorageDead(_7);                 // scope 1 at $DIR/while_let_loops.rs:10:5: 10:6\n+          goto -> bb4;                     // scope 1 at no-location\n       }\n   \n       bb2: {"}, {"sha": "325b8591c73388ba0339ebb29ad6171d338bab07", "filename": "src/test/mir-opt/while_storage.while_loop.PreCodegen.after.mir", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -20,36 +20,40 @@ fn while_loop(_1: bool) -> () {\n \n     bb1: {\n         StorageDead(_3);                 // scope 0 at $DIR/while-storage.rs:10:21: 10:22\n-        switchInt(_2) -> [false: bb6, otherwise: bb2]; // scope 0 at $DIR/while-storage.rs:10:5: 14:6\n+        switchInt(move _2) -> [false: bb3, otherwise: bb2]; // scope 0 at $DIR/while-storage.rs:10:5: 14:6\n     }\n \n     bb2: {\n         StorageLive(_4);                 // scope 0 at $DIR/while-storage.rs:11:12: 11:23\n         StorageLive(_5);                 // scope 0 at $DIR/while-storage.rs:11:21: 11:22\n         _5 = _1;                         // scope 0 at $DIR/while-storage.rs:11:21: 11:22\n-        _4 = get_bool(move _5) -> bb3;   // scope 0 at $DIR/while-storage.rs:11:12: 11:23\n+        _4 = get_bool(move _5) -> bb4;   // scope 0 at $DIR/while-storage.rs:11:12: 11:23\n                                          // mir::Constant\n                                          // + span: $DIR/while-storage.rs:11:12: 11:20\n                                          // + literal: Const { ty: fn(bool) -> bool {get_bool}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb3: {\n-        StorageDead(_5);                 // scope 0 at $DIR/while-storage.rs:11:22: 11:23\n-        switchInt(move _4) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/while-storage.rs:11:9: 13:10\n+        goto -> bb7;                     // scope 0 at no-location\n     }\n \n     bb4: {\n-        StorageDead(_4);                 // scope 0 at $DIR/while-storage.rs:13:9: 13:10\n-        goto -> bb6;                     // scope 0 at no-location\n+        StorageDead(_5);                 // scope 0 at $DIR/while-storage.rs:11:22: 11:23\n+        switchInt(move _4) -> [false: bb6, otherwise: bb5]; // scope 0 at $DIR/while-storage.rs:11:9: 13:10\n     }\n \n     bb5: {\n+        StorageDead(_4);                 // scope 0 at $DIR/while-storage.rs:13:9: 13:10\n+        goto -> bb7;                     // scope 0 at no-location\n+    }\n+\n+    bb6: {\n         StorageDead(_4);                 // scope 0 at $DIR/while-storage.rs:13:9: 13:10\n         StorageDead(_2);                 // scope 0 at $DIR/while-storage.rs:14:5: 14:6\n         goto -> bb0;                     // scope 0 at $DIR/while-storage.rs:10:5: 14:6\n     }\n \n-    bb6: {\n+    bb7: {\n         StorageDead(_2);                 // scope 0 at $DIR/while-storage.rs:14:5: 14:6\n         return;                          // scope 0 at $DIR/while-storage.rs:15:2: 15:2\n     }"}, {"sha": "ed8e498b6b746ae0a1d813ea4b0f368e1952d4ab", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -161,7 +161,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             19 => {\n                 let pat =\n                     P(Pat { id: DUMMY_NODE_ID, kind: PatKind::Wild, span: DUMMY_SP, tokens: None });\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e)))\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e, DUMMY_SP)))\n             }\n             _ => panic!(\"bad counter value in iter_exprs\"),\n         }"}, {"sha": "41b675f7960c55415dab35aacc08981e32d2b482", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/issue-78720.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-78720.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-78720.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-78720.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,11 +1,8 @@\n warning: irrefutable `if let` pattern\n-  --> $DIR/issue-78720.rs:6:5\n+  --> $DIR/issue-78720.rs:6:8\n    |\n-LL | /     if let a = \"\" {\n-LL | |\n-LL | |         drop(|_: ()| drop(a));\n-LL | |     }\n-   | |_____^\n+LL |     if let a = \"\" {\n+   |        ^^^^^^^^^^\n    |\n    = note: `#[warn(irrefutable_let_patterns)]` on by default\n    = note: this pattern will always match, so the `if let` is useless"}, {"sha": "7fdd2be955b9854a02151c139abf2167c7a76315", "filename": "src/test/ui/expr/if/if-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,7 +1,7 @@\n // check-pass\n \n fn macros() {\n-    macro_rules! foo{\n+    macro_rules! foo {\n         ($p:pat, $e:expr, $b:block) => {{\n             if let $p = $e $b\n             //~^ WARN irrefutable `if let`"}, {"sha": "7975a9dca0dc008d69c159c995b95716ca07bc2a", "filename": "src/test/ui/expr/if/if-let.stderr", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,8 +1,8 @@\n warning: irrefutable `if let` pattern\n-  --> $DIR/if-let.rs:6:13\n+  --> $DIR/if-let.rs:6:16\n    |\n LL |               if let $p = $e $b\n-   |               ^^^^^^^^^^^^^^^^^\n+   |                  ^^^\n ...\n LL | /     foo!(a, 1, {\n LL | |         println!(\"irrefutable pattern\");\n@@ -15,10 +15,10 @@ LL | |     });\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `if let` pattern\n-  --> $DIR/if-let.rs:6:13\n+  --> $DIR/if-let.rs:6:16\n    |\n LL |               if let $p = $e $b\n-   |               ^^^^^^^^^^^^^^^^^\n+   |                  ^^^\n ...\n LL | /     bar!(a, 1, {\n LL | |         println!(\"irrefutable pattern\");\n@@ -30,51 +30,37 @@ LL | |     });\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `if let` pattern\n-  --> $DIR/if-let.rs:26:5\n+  --> $DIR/if-let.rs:26:8\n    |\n-LL | /     if let a = 1 {\n-LL | |         println!(\"irrefutable pattern\");\n-LL | |     }\n-   | |_____^\n+LL |     if let a = 1 {\n+   |        ^^^^^^^^^\n    |\n    = note: this pattern will always match, so the `if let` is useless\n    = help: consider replacing the `if let` with a `let`\n \n warning: irrefutable `if let` pattern\n-  --> $DIR/if-let.rs:30:5\n+  --> $DIR/if-let.rs:30:8\n    |\n-LL | /     if let a = 1 {\n-LL | |         println!(\"irrefutable pattern\");\n-LL | |     } else if true {\n-LL | |         println!(\"else-if in irrefutable `if let`\");\n-LL | |     } else {\n-LL | |         println!(\"else in irrefutable `if let`\");\n-LL | |     }\n-   | |_____^\n+LL |     if let a = 1 {\n+   |        ^^^^^^^^^\n    |\n    = note: this pattern will always match, so the `if let` is useless\n    = help: consider replacing the `if let` with a `let`\n \n warning: irrefutable `if let` pattern\n-  --> $DIR/if-let.rs:40:12\n+  --> $DIR/if-let.rs:40:15\n    |\n-LL |       } else if let a = 1 {\n-   |  ____________^\n-LL | |         println!(\"irrefutable pattern\");\n-LL | |     }\n-   | |_____^\n+LL |     } else if let a = 1 {\n+   |               ^^^^^^^^^\n    |\n    = note: this pattern will always match, so the `if let` is useless\n    = help: consider replacing the `if let` with a `let`\n \n warning: irrefutable `if let` pattern\n-  --> $DIR/if-let.rs:46:12\n+  --> $DIR/if-let.rs:46:15\n    |\n-LL |       } else if let a = 1 {\n-   |  ____________^\n-LL | |         println!(\"irrefutable pattern\");\n-LL | |     }\n-   | |_____^\n+LL |     } else if let a = 1 {\n+   |               ^^^^^^^^^\n    |\n    = note: this pattern will always match, so the `if let` is useless\n    = help: consider replacing the `if let` with a `let`"}, {"sha": "896072ce728eb18e98218f88241ef3a9c38f4270", "filename": "src/test/ui/expr/if/if-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-ret.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -3,6 +3,6 @@\n #![allow(unused_parens)]\n // pretty-expanded FIXME #23616\n \n-fn foo() { if (return) { } } //~ WARNING unreachable block in `if` expression\n+fn foo() { if (return) { } } //~ WARNING unreachable block in `if`\n \n pub fn main() { foo(); }"}, {"sha": "8ced271aabc2b909e09302a2dcab3758c437586c", "filename": "src/test/ui/expr/if/if-ret.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-ret.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,8 +1,8 @@\n-warning: unreachable block in `if` expression\n+warning: unreachable block in `if` or `while` expression\n   --> $DIR/if-ret.rs:6:24\n    |\n LL | fn foo() { if (return) { } }\n-   |               -------- ^^^ unreachable block in `if` expression\n+   |               -------- ^^^ unreachable block in `if` or `while` expression\n    |               |\n    |               any code following this expression is unreachable\n    |"}, {"sha": "7db4734780817e19e428973e95ed322bd7fe3895", "filename": "src/test/ui/issues/issue-14091.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fissues%2Fissue-14091.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fissues%2Fissue-14091.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14091.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -3,8 +3,6 @@ error[E0308]: mismatched types\n    |\n LL |     assert!(1,1);\n    |     ^^^^^^^^^^^^^ expected `bool`, found integer\n-   |\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "4f46e32dc3070396209c709a8f9f934106059814", "filename": "src/test/ui/match/issue-82392.stdout", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fmatch%2Fissue-82392.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fmatch%2Fissue-82392.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-82392.stdout?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -9,12 +9,11 @@ extern crate std;\n pub fn main() ({\n                    (if (true as bool)\n                        ({ } as\n-                           ()) else {match ((Some as\n+                           ()) else if (let Some(a) =\n+                                           ((Some as\n                                                 fn(i32) -> Option<i32> {Option::<i32>::Some})((3\n                                                                                                   as\n                                                                                                   i32))\n-                                               as Option<i32>) {\n-                                         Some(a) => { }\n-                                         _ => { }\n-                                     }} as ())\n-                    } as ())\n+                                               as Option<i32>) as bool)\n+                              ({ } as ()) as ())\n+                             } as ())"}, {"sha": "d8da0ac8aa6c5cb8c426540ef28a7e65cc3d88f4", "filename": "src/test/ui/pattern/issue-82290.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,7 +1,9 @@\n+// check-pass\n+\n #![feature(let_chains)] //~ WARN the feature `let_chains` is incomplete\n \n fn main() {\n-    if true && let x = 1 { //~ ERROR `let` expressions are not supported here\n+    if true && let x = 1 { //~ WARN irrefutable `let` pattern\n         let _ = x;\n     }\n }"}, {"sha": "0a3cf2c794f47baa7e85c4029876768cef79a33a", "filename": "src/test/ui/pattern/issue-82290.stderr", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,19 +1,21 @@\n-error: `let` expressions are not supported here\n-  --> $DIR/issue-82290.rs:4:16\n-   |\n-LL |     if true && let x = 1 {\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n warning: the feature `let_chains` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-82290.rs:1:12\n+  --> $DIR/issue-82290.rs:3:12\n    |\n LL | #![feature(let_chains)]\n    |            ^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n \n-error: aborting due to previous error; 1 warning emitted\n+warning: irrefutable `let` pattern\n+  --> $DIR/issue-82290.rs:6:16\n+   |\n+LL |     if true && let x = 1 {\n+   |                ^^^^^^^^^\n+   |\n+   = note: `#[warn(irrefutable_let_patterns)]` on by default\n+   = note: this pattern will always match, so the `let` is useless\n+   = help: consider removing `let`\n+\n+warning: 2 warnings emitted\n "}, {"sha": "0caa79a91529d14d7deacd340a92b8d0e1ef1d81", "filename": "src/test/ui/pattern/usefulness/deny-irrefutable-let-patterns.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,8 +1,8 @@\n error: irrefutable `if let` pattern\n-  --> $DIR/deny-irrefutable-let-patterns.rs:7:5\n+  --> $DIR/deny-irrefutable-let-patterns.rs:7:8\n    |\n LL |     if let _ = 5 {}\n-   |     ^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/deny-irrefutable-let-patterns.rs:4:9\n@@ -13,12 +13,10 @@ LL | #![deny(irrefutable_let_patterns)]\n    = help: consider replacing the `if let` with a `let`\n \n error: irrefutable `while let` pattern\n-  --> $DIR/deny-irrefutable-let-patterns.rs:9:5\n+  --> $DIR/deny-irrefutable-let-patterns.rs:9:11\n    |\n-LL | /     while let _ = 5 {\n-LL | |         break;\n-LL | |     }\n-   | |_____^\n+LL |     while let _ = 5 {\n+   |           ^^^^^^^^^\n    |\n    = note: this pattern will always match, so the loop will never exit\n    = help: consider instead using a `loop { ... }` with a `let` inside it"}, {"sha": "3c04eaf480a2cab7a946fac7ffc694d71f581ba3", "filename": "src/test/ui/reachable/expr_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_if.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -4,7 +4,7 @@\n #![deny(unreachable_code)]\n \n fn foo() {\n-    if {return} { //~ ERROR unreachable block in `if` expression\n+    if {return} { //~ ERROR unreachable block in `if`\n         println!(\"Hello, world!\");\n     }\n }"}, {"sha": "1112273f441c66c9d671bab080d0f672631ef72c", "filename": "src/test/ui/reachable/expr_if.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_if.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,4 +1,4 @@\n-error: unreachable block in `if` expression\n+error: unreachable block in `if` or `while` expression\n   --> $DIR/expr_if.rs:7:17\n    |\n LL |       if {return} {\n@@ -7,7 +7,7 @@ LL |       if {return} {\n    | |         any code following this expression is unreachable\n LL | |         println!(\"Hello, world!\");\n LL | |     }\n-   | |_____^ unreachable block in `if` expression\n+   | |_____^ unreachable block in `if` or `while` expression\n    |\n note: the lint level is defined here\n   --> $DIR/expr_if.rs:4:9"}, {"sha": "5005f3833a0b36219ca342103671e2913aab4a8f", "filename": "src/test/ui/reachable/expr_while.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -5,7 +5,7 @@\n \n fn foo() {\n     while {return} {\n-        //~^ ERROR unreachable block in `while` expression\n+        //~^ ERROR unreachable block in `if`\n         println!(\"Hello, world!\");\n     }\n }\n@@ -20,7 +20,7 @@ fn bar() {\n fn baz() {\n     // Here, we cite the `while` loop as dead.\n     while {return} {\n-        //~^ ERROR unreachable block in `while` expression\n+        //~^ ERROR unreachable block in `if`\n         println!(\"I am dead.\");\n     }\n     println!(\"I am, too.\");"}, {"sha": "b1859f619342338b48bf1072a5f0ac6d1b7ddcbd", "filename": "src/test/ui/reachable/expr_while.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,4 +1,4 @@\n-error: unreachable block in `while` expression\n+error: unreachable block in `if` or `while` expression\n   --> $DIR/expr_while.rs:7:20\n    |\n LL |       while {return} {\n@@ -8,15 +8,15 @@ LL |       while {return} {\n LL | |\n LL | |         println!(\"Hello, world!\");\n LL | |     }\n-   | |_____^ unreachable block in `while` expression\n+   | |_____^ unreachable block in `if` or `while` expression\n    |\n note: the lint level is defined here\n   --> $DIR/expr_while.rs:4:9\n    |\n LL | #![deny(unreachable_code)]\n    |         ^^^^^^^^^^^^^^^^\n \n-error: unreachable block in `while` expression\n+error: unreachable block in `if` or `while` expression\n   --> $DIR/expr_while.rs:22:20\n    |\n LL |       while {return} {\n@@ -26,7 +26,7 @@ LL |       while {return} {\n LL | |\n LL | |         println!(\"I am dead.\");\n LL | |     }\n-   | |_____^ unreachable block in `while` expression\n+   | |_____^ unreachable block in `if` or `while` expression\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2a2c0be52630b7002c83a1ea0830f190ef21e7ae", "filename": "src/test/ui/rfc-2294-if-let-guard/feature-gate.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -9,49 +9,35 @@ fn _if_let_guard() {\n \n         () if (let 0 = 1) => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n \n         () if (((let 0 = 1))) => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n \n         () if true && let 0 = 1 => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n \n         () if let 0 = 1 && true => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n \n         () if (let 0 = 1) && true => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n \n         () if true && (let 0 = 1) => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n \n         () if (let 0 = 1) && (let 0 = 1) => {}\n         //~^ ERROR `let` expressions in this position are experimental\n         //~| ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n-        //~| ERROR `let` expressions are not supported here\n \n         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n         //~^ ERROR `let` expressions in this position are experimental\n         //~| ERROR `let` expressions in this position are experimental\n         //~| ERROR `let` expressions in this position are experimental\n         //~| ERROR `let` expressions in this position are experimental\n         //~| ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n-        //~| ERROR `let` expressions are not supported here\n-        //~| ERROR `let` expressions are not supported here\n-        //~| ERROR `let` expressions are not supported here\n-        //~| ERROR `let` expressions are not supported here\n \n         () if let Range { start: _, end: _ } = (true..true) && false => {}\n         //~^ ERROR `let` expressions in this position are experimental\n-        //~| ERROR `let` expressions are not supported here\n         _ => {}\n     }\n }\n@@ -67,10 +53,8 @@ fn _macros() {\n     }\n     use_expr!((let 0 = 1 && 0 == 0));\n     //~^ ERROR `let` expressions in this position are experimental\n-    //~| ERROR `let` expressions are not supported here\n     use_expr!((let 0 = 1));\n     //~^ ERROR `let` expressions in this position are experimental\n-    //~| ERROR `let` expressions are not supported here\n     match () {\n         #[cfg(FALSE)]\n         () if let 0 = 1 => {}"}, {"sha": "bedcdcb019ba9272d96dab525018a6fc8542f5d6", "filename": "src/test/ui/rfc-2294-if-let-guard/feature-gate.stderr", "status": "modified", "additions": 18, "deletions": 146, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,5 +1,5 @@\n error: no rules expected the token `let`\n-  --> $DIR/feature-gate.rs:80:15\n+  --> $DIR/feature-gate.rs:64:15\n    |\n LL |     macro_rules! use_expr {\n    |     --------------------- when calling this macro\n@@ -18,7 +18,7 @@ LL |         () if let 0 = 1 => {}\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:76:12\n+  --> $DIR/feature-gate.rs:60:12\n    |\n LL |         () if let 0 = 1 => {}\n    |            ^^^^^^^^^^^^\n@@ -38,7 +38,7 @@ LL |         () if (let 0 = 1) => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:14:18\n+  --> $DIR/feature-gate.rs:13:18\n    |\n LL |         () if (((let 0 = 1))) => {}\n    |                  ^^^^^^^^^\n@@ -48,7 +48,7 @@ LL |         () if (((let 0 = 1))) => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:18:23\n+  --> $DIR/feature-gate.rs:16:23\n    |\n LL |         () if true && let 0 = 1 => {}\n    |                       ^^^^^^^^^\n@@ -58,7 +58,7 @@ LL |         () if true && let 0 = 1 => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:22:15\n+  --> $DIR/feature-gate.rs:19:15\n    |\n LL |         () if let 0 = 1 && true => {}\n    |               ^^^^^^^^^\n@@ -68,7 +68,7 @@ LL |         () if let 0 = 1 && true => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:26:16\n+  --> $DIR/feature-gate.rs:22:16\n    |\n LL |         () if (let 0 = 1) && true => {}\n    |                ^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         () if (let 0 = 1) && true => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:30:24\n+  --> $DIR/feature-gate.rs:25:24\n    |\n LL |         () if true && (let 0 = 1) => {}\n    |                        ^^^^^^^^^\n@@ -88,7 +88,7 @@ LL |         () if true && (let 0 = 1) => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:34:16\n+  --> $DIR/feature-gate.rs:28:16\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                ^^^^^^^^^\n@@ -98,7 +98,7 @@ LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:34:31\n+  --> $DIR/feature-gate.rs:28:31\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                               ^^^^^^^^^\n@@ -108,7 +108,7 @@ LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:40:15\n+  --> $DIR/feature-gate.rs:32:15\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |               ^^^^^^^^^\n@@ -118,7 +118,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:40:28\n+  --> $DIR/feature-gate.rs:32:28\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                            ^^^^^^^^^\n@@ -128,7 +128,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:40:42\n+  --> $DIR/feature-gate.rs:32:42\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                          ^^^^^^^^^\n@@ -138,7 +138,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:40:55\n+  --> $DIR/feature-gate.rs:32:55\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                       ^^^^^^^^^\n@@ -148,7 +148,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:40:68\n+  --> $DIR/feature-gate.rs:32:68\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                                    ^^^^^^^^^\n@@ -158,7 +158,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:52:15\n+  --> $DIR/feature-gate.rs:39:15\n    |\n LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -168,7 +168,7 @@ LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:68:16\n+  --> $DIR/feature-gate.rs:54:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^^^^^^^\n@@ -178,7 +178,7 @@ LL |     use_expr!((let 0 = 1 && 0 == 0));\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:71:16\n+  --> $DIR/feature-gate.rs:56:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^^^^^^^\n@@ -187,134 +187,6 @@ LL |     use_expr!((let 0 = 1));\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:10:16\n-   |\n-LL |         () if (let 0 = 1) => {}\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:14:18\n-   |\n-LL |         () if (((let 0 = 1))) => {}\n-   |                  ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:18:23\n-   |\n-LL |         () if true && let 0 = 1 => {}\n-   |                       ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:22:15\n-   |\n-LL |         () if let 0 = 1 && true => {}\n-   |               ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:26:16\n-   |\n-LL |         () if (let 0 = 1) && true => {}\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:30:24\n-   |\n-LL |         () if true && (let 0 = 1) => {}\n-   |                        ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:34:16\n-   |\n-LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:34:31\n-   |\n-LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n-   |                               ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:40:15\n-   |\n-LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-   |               ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:40:28\n-   |\n-LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-   |                            ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:40:42\n-   |\n-LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-   |                                          ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:40:55\n-   |\n-LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-   |                                                       ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:40:68\n-   |\n-LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-   |                                                                    ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:52:15\n-   |\n-LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:68:16\n-   |\n-LL |     use_expr!((let 0 = 1 && 0 == 0));\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:71:16\n-   |\n-LL |     use_expr!((let 0 = 1));\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: aborting due to 35 previous errors\n+error: aborting due to 19 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "b3c9246486ebb375f1aa3c98674d03b8319febd9", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -201,7 +201,6 @@ fn outside_if_and_while_expr() {\n \n     (let true = let true = true);\n     //~^ ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n \n     // Check function tail position.\n     &let 0 = 0"}, {"sha": "b48915adc683bddef124a38e552b17a9378e5ecb", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 118, "deletions": 71, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,5 +1,5 @@\n error: expressions must be enclosed in braces to be used as const generic arguments\n-  --> $DIR/disallowed-positions.rs:236:9\n+  --> $DIR/disallowed-positions.rs:235:9\n    |\n LL |         true && let 1 = 1\n    |         ^^^^^^^^^^^^^^^^^\n@@ -15,447 +15,494 @@ error: `let` expressions are not supported here\n LL |     if &let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:35:9\n    |\n LL |     if !let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:36:9\n    |\n LL |     if *let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:38:9\n    |\n LL |     if -let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:46:9\n    |\n LL |     if (let 0 = 0)? {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:50:16\n    |\n LL |     if true || let 0 = 0 {}\n    |                ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:51:17\n    |\n LL |     if (true || let 0 = 0) {}\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:52:25\n    |\n LL |     if true && (true || let 0 = 0) {}\n    |                         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:53:25\n    |\n LL |     if true || (true && let 0 = 0) {}\n    |                         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:56:12\n    |\n LL |     if x = let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:59:15\n    |\n LL |     if true..(let 0 = 0) {}\n    |               ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:61:11\n    |\n LL |     if ..(let 0 = 0) {}\n    |           ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:63:9\n    |\n LL |     if (let 0 = 0).. {}\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:67:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:71:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:78:8\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:86:8\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:92:19\n    |\n LL |     if let true = let true = true {}\n    |                   ^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:96:12\n    |\n LL |     while &let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:99:12\n    |\n LL |     while !let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:100:12\n    |\n LL |     while *let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:102:12\n    |\n LL |     while -let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:110:12\n    |\n LL |     while (let 0 = 0)? {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:114:19\n    |\n LL |     while true || let 0 = 0 {}\n    |                   ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:115:20\n    |\n LL |     while (true || let 0 = 0) {}\n    |                    ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:116:28\n    |\n LL |     while true && (true || let 0 = 0) {}\n    |                            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:117:28\n    |\n LL |     while true || (true && let 0 = 0) {}\n    |                            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:120:15\n    |\n LL |     while x = let 0 = 0 {}\n    |               ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:123:18\n    |\n LL |     while true..(let 0 = 0) {}\n    |                  ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:125:14\n    |\n LL |     while ..(let 0 = 0) {}\n    |              ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:127:12\n    |\n LL |     while (let 0 = 0).. {}\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:131:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:135:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:142:11\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:150:11\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:156:22\n    |\n LL |     while let true = let true = true {}\n    |                      ^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:170:6\n    |\n LL |     &let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:172:6\n    |\n LL |     !let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:173:6\n    |\n LL |     *let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:175:6\n    |\n LL |     -let 0 = 0;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:183:6\n    |\n LL |     (let 0 = 0)?;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:187:13\n    |\n LL |     true || let 0 = 0;\n    |             ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:188:14\n    |\n LL |     (true || let 0 = 0);\n    |              ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:189:22\n    |\n LL |     true && (true || let 0 = 0);\n    |                      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:192:9\n    |\n LL |     x = let 0 = 0;\n    |         ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:194:12\n    |\n LL |     true..(let 0 = 0);\n    |            ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:195:8\n    |\n LL |     ..(let 0 = 0);\n    |        ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:196:6\n    |\n LL |     (let 0 = 0)..;\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:198:6\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:202:6\n    |\n LL |     (let true = let true = true);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:202:17\n-   |\n-LL |     (let true = let true = true);\n-   |                 ^^^^^^^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:207:6\n+  --> $DIR/disallowed-positions.rs:206:6\n    |\n LL |     &let 0 = 0\n    |      ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:218:17\n+  --> $DIR/disallowed-positions.rs:217:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:222:17\n+  --> $DIR/disallowed-positions.rs:221:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:226:17\n+  --> $DIR/disallowed-positions.rs:225:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:236:17\n+  --> $DIR/disallowed-positions.rs:235:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n \n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/disallowed-positions.rs:20:12\n@@ -939,7 +986,7 @@ LL |     (let Range { start: _, end: _ } = true..true || false);\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:207:5\n+  --> $DIR/disallowed-positions.rs:206:5\n    |\n LL | fn outside_if_and_while_expr() {\n    |                                - help: try adding a return type: `-> &bool`\n@@ -960,7 +1007,7 @@ note: required by `branch`\n LL |     fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 104 previous errors; 2 warnings emitted\n+error: aborting due to 103 previous errors; 2 warnings emitted\n \n Some errors have detailed explanations: E0277, E0308, E0600, E0614.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "2b4259e9dc1506479fc6af5204b85c80b0d87e91", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -13,99 +13,71 @@ fn _if() {\n \n     if (let 0 = 1) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR invalid parentheses around `let` expression in `if let`\n \n     if (((let 0 = 1))) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR invalid parentheses around `let` expression in `if let`\n \n     if true && let 0 = 1 {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     if let 0 = 1 && true {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     if (let 0 = 1) && true {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     if true && (let 0 = 1) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     if (let 0 = 1) && (let 0 = 1) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n \n     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n \n     if let Range { start: _, end: _ } = (true..true) && false {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n }\n \n fn _while() {\n     while let 0 = 1 {} // Stable!\n \n     while (let 0 = 1) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     while (((let 0 = 1))) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     while true && let 0 = 1 {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     while let 0 = 1 && true {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     while (let 0 = 1) && true {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     while true && (let 0 = 1) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n \n     while (let 0 = 1) && (let 0 = 1) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n \n     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n     //~| ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n \n     while let Range { start: _, end: _ } = (true..true) && false {}\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n }\n \n fn _macros() {\n@@ -122,12 +94,8 @@ fn _macros() {\n     }\n     use_expr!((let 0 = 1 && 0 == 0));\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR `let` expressions are not supported here\n-    //~| ERROR `let` expressions are not supported here\n     use_expr!((let 0 = 1));\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n-    //~| ERROR invalid parentheses around `let` expression in `if let`\n-    //~| ERROR `let` expressions are not supported here\n     #[cfg(FALSE)] (let 0 = 1);\n     //~^ ERROR `let` expressions in this position are experimental [E0658]\n     use_expr!(let 0 = 1);"}, {"sha": "180eee0cadfe62baaef644988341054e485e0259", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.stderr", "status": "modified", "additions": 33, "deletions": 301, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,5 +1,5 @@\n error: no rules expected the token `let`\n-  --> $DIR/feature-gate.rs:133:15\n+  --> $DIR/feature-gate.rs:101:15\n    |\n LL |     macro_rules! use_expr {\n    |     --------------------- when calling this macro\n@@ -18,7 +18,7 @@ LL |     if (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:18:11\n+  --> $DIR/feature-gate.rs:17:11\n    |\n LL |     if (((let 0 = 1))) {}\n    |           ^^^^^^^^^\n@@ -28,7 +28,7 @@ LL |     if (((let 0 = 1))) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:22:16\n+  --> $DIR/feature-gate.rs:20:16\n    |\n LL |     if true && let 0 = 1 {}\n    |                ^^^^^^^^^\n@@ -38,7 +38,7 @@ LL |     if true && let 0 = 1 {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:26:8\n+  --> $DIR/feature-gate.rs:23:8\n    |\n LL |     if let 0 = 1 && true {}\n    |        ^^^^^^^^^\n@@ -48,7 +48,7 @@ LL |     if let 0 = 1 && true {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:30:9\n+  --> $DIR/feature-gate.rs:26:9\n    |\n LL |     if (let 0 = 1) && true {}\n    |         ^^^^^^^^^\n@@ -58,7 +58,7 @@ LL |     if (let 0 = 1) && true {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:34:17\n+  --> $DIR/feature-gate.rs:29:17\n    |\n LL |     if true && (let 0 = 1) {}\n    |                 ^^^^^^^^^\n@@ -68,7 +68,7 @@ LL |     if true && (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:38:9\n+  --> $DIR/feature-gate.rs:32:9\n    |\n LL |     if (let 0 = 1) && (let 0 = 1) {}\n    |         ^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |     if (let 0 = 1) && (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:38:24\n+  --> $DIR/feature-gate.rs:32:24\n    |\n LL |     if (let 0 = 1) && (let 0 = 1) {}\n    |                        ^^^^^^^^^\n@@ -88,7 +88,7 @@ LL |     if (let 0 = 1) && (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:44:8\n+  --> $DIR/feature-gate.rs:36:8\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |        ^^^^^^^^^\n@@ -98,7 +98,7 @@ LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:44:21\n+  --> $DIR/feature-gate.rs:36:21\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                     ^^^^^^^^^\n@@ -108,7 +108,7 @@ LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:44:35\n+  --> $DIR/feature-gate.rs:36:35\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                   ^^^^^^^^^\n@@ -118,7 +118,7 @@ LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:44:48\n+  --> $DIR/feature-gate.rs:36:48\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                ^^^^^^^^^\n@@ -128,7 +128,7 @@ LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:44:61\n+  --> $DIR/feature-gate.rs:36:61\n    |\n LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                             ^^^^^^^^^\n@@ -138,7 +138,7 @@ LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:56:8\n+  --> $DIR/feature-gate.rs:43:8\n    |\n LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -148,7 +148,7 @@ LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:64:12\n+  --> $DIR/feature-gate.rs:50:12\n    |\n LL |     while (let 0 = 1) {}\n    |            ^^^^^^^^^\n@@ -158,7 +158,7 @@ LL |     while (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:68:14\n+  --> $DIR/feature-gate.rs:53:14\n    |\n LL |     while (((let 0 = 1))) {}\n    |              ^^^^^^^^^\n@@ -168,7 +168,7 @@ LL |     while (((let 0 = 1))) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:72:19\n+  --> $DIR/feature-gate.rs:56:19\n    |\n LL |     while true && let 0 = 1 {}\n    |                   ^^^^^^^^^\n@@ -178,7 +178,7 @@ LL |     while true && let 0 = 1 {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:76:11\n+  --> $DIR/feature-gate.rs:59:11\n    |\n LL |     while let 0 = 1 && true {}\n    |           ^^^^^^^^^\n@@ -188,7 +188,7 @@ LL |     while let 0 = 1 && true {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:80:12\n+  --> $DIR/feature-gate.rs:62:12\n    |\n LL |     while (let 0 = 1) && true {}\n    |            ^^^^^^^^^\n@@ -198,7 +198,7 @@ LL |     while (let 0 = 1) && true {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:84:20\n+  --> $DIR/feature-gate.rs:65:20\n    |\n LL |     while true && (let 0 = 1) {}\n    |                    ^^^^^^^^^\n@@ -208,7 +208,7 @@ LL |     while true && (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:88:12\n+  --> $DIR/feature-gate.rs:68:12\n    |\n LL |     while (let 0 = 1) && (let 0 = 1) {}\n    |            ^^^^^^^^^\n@@ -218,7 +218,7 @@ LL |     while (let 0 = 1) && (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:88:27\n+  --> $DIR/feature-gate.rs:68:27\n    |\n LL |     while (let 0 = 1) && (let 0 = 1) {}\n    |                           ^^^^^^^^^\n@@ -228,7 +228,7 @@ LL |     while (let 0 = 1) && (let 0 = 1) {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:94:11\n+  --> $DIR/feature-gate.rs:72:11\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |           ^^^^^^^^^\n@@ -238,7 +238,7 @@ LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:94:24\n+  --> $DIR/feature-gate.rs:72:24\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                        ^^^^^^^^^\n@@ -248,7 +248,7 @@ LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:94:38\n+  --> $DIR/feature-gate.rs:72:38\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                      ^^^^^^^^^\n@@ -258,7 +258,7 @@ LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:94:51\n+  --> $DIR/feature-gate.rs:72:51\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                   ^^^^^^^^^\n@@ -268,7 +268,7 @@ LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:94:64\n+  --> $DIR/feature-gate.rs:72:64\n    |\n LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n    |                                                                ^^^^^^^^^\n@@ -278,7 +278,7 @@ LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:106:11\n+  --> $DIR/feature-gate.rs:79:11\n    |\n LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -288,7 +288,7 @@ LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:131:20\n+  --> $DIR/feature-gate.rs:99:20\n    |\n LL |     #[cfg(FALSE)] (let 0 = 1);\n    |                    ^^^^^^^^^\n@@ -298,7 +298,7 @@ LL |     #[cfg(FALSE)] (let 0 = 1);\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:114:17\n+  --> $DIR/feature-gate.rs:86:17\n    |\n LL |     noop_expr!((let 0 = 1));\n    |                 ^^^^^^^^^\n@@ -308,7 +308,7 @@ LL |     noop_expr!((let 0 = 1));\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:123:16\n+  --> $DIR/feature-gate.rs:95:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^^^^^^^\n@@ -318,7 +318,7 @@ LL |     use_expr!((let 0 = 1 && 0 == 0));\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n error[E0658]: `let` expressions in this position are experimental\n-  --> $DIR/feature-gate.rs:127:16\n+  --> $DIR/feature-gate.rs:97:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^^^^^^^\n@@ -327,274 +327,6 @@ LL |     use_expr!((let 0 = 1));\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n    = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\n \n-error: invalid parentheses around `let` expression in `if let`\n-  --> $DIR/feature-gate.rs:14:8\n-   |\n-LL |     if (let 0 = 1) {}\n-   |        ^         ^\n-   |\n-help: `if let` needs to be written without parentheses\n-   |\n-LL -     if (let 0 = 1) {}\n-LL +     if let 0 = 1 {}\n-   | \n-\n-error: invalid parentheses around `let` expression in `if let`\n-  --> $DIR/feature-gate.rs:18:8\n-   |\n-LL |     if (((let 0 = 1))) {}\n-   |        ^^^         ^^^\n-   |\n-help: `if let` needs to be written without parentheses\n-   |\n-LL -     if (((let 0 = 1))) {}\n-LL +     if let 0 = 1 {}\n-   | \n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:22:16\n-   |\n-LL |     if true && let 0 = 1 {}\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:26:8\n-   |\n-LL |     if let 0 = 1 && true {}\n-   |        ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:30:9\n-   |\n-LL |     if (let 0 = 1) && true {}\n-   |         ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:34:17\n-   |\n-LL |     if true && (let 0 = 1) {}\n-   |                 ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:38:9\n-   |\n-LL |     if (let 0 = 1) && (let 0 = 1) {}\n-   |         ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:38:24\n-   |\n-LL |     if (let 0 = 1) && (let 0 = 1) {}\n-   |                        ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:44:8\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |        ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:44:21\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                     ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:44:35\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                   ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:44:48\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:44:61\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                             ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:56:8\n-   |\n-LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:64:12\n-   |\n-LL |     while (let 0 = 1) {}\n-   |            ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:68:14\n-   |\n-LL |     while (((let 0 = 1))) {}\n-   |              ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:72:19\n-   |\n-LL |     while true && let 0 = 1 {}\n-   |                   ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:76:11\n-   |\n-LL |     while let 0 = 1 && true {}\n-   |           ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:80:12\n-   |\n-LL |     while (let 0 = 1) && true {}\n-   |            ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:84:20\n-   |\n-LL |     while true && (let 0 = 1) {}\n-   |                    ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:88:12\n-   |\n-LL |     while (let 0 = 1) && (let 0 = 1) {}\n-   |            ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:88:27\n-   |\n-LL |     while (let 0 = 1) && (let 0 = 1) {}\n-   |                           ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:94:11\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |           ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:94:24\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                        ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:94:38\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                      ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:94:51\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                   ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:94:64\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:106:11\n-   |\n-LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:123:16\n-   |\n-LL |     use_expr!((let 0 = 1 && 0 == 0));\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:123:16\n-   |\n-LL |     use_expr!((let 0 = 1 && 0 == 0));\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: invalid parentheses around `let` expression in `if let`\n-  --> $DIR/feature-gate.rs:127:15\n-   |\n-LL |     use_expr!((let 0 = 1));\n-   |               ^         ^\n-   |\n-help: `if let` needs to be written without parentheses\n-   |\n-LL -     use_expr!((let 0 = 1));\n-LL +     use_expr!(let 0 = 1);\n-   | \n-\n-error: `let` expressions are not supported here\n-  --> $DIR/feature-gate.rs:127:16\n-   |\n-LL |     use_expr!((let 0 = 1));\n-   |                ^^^^^^^^^\n-   |\n-   = note: only supported directly without parentheses in conditions of `if`- and `while`-expressions, as well as in `let` chains within parentheses\n-\n-error: aborting due to 65 previous errors\n+error: aborting due to 33 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "fcc09b159ec23a255e1fd5de548ebc5a3c966552", "filename": "src/test/ui/rfc-2497-if-let-chains/protect-precedences.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -10,7 +10,8 @@ fn main() {\n \n     fn _f1() -> bool {\n         // Should associate as `(let _ = (return (true && false)))`.\n-        if let _ = return true && false {}; //~ WARNING unreachable_code\n+        if let _ = return true && false {};\n+        //~^ WARNING unreachable block in `if`\n     }\n     assert!(!_f1());\n }"}, {"sha": "24b35a2ab31672426a4ea1fddb2a2c3cd122a5ba", "filename": "src/test/ui/rfc-2497-if-let-chains/protect-precedences.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fprotect-precedences.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,8 +1,8 @@\n-warning: unreachable block in `if` expression\n+warning: unreachable block in `if` or `while` expression\n   --> $DIR/protect-precedences.rs:13:41\n    |\n LL |         if let _ = return true && false {};\n-   |                    -------------------- ^^ unreachable block in `if` expression\n+   |                    -------------------- ^^ unreachable block in `if` or `while` expression\n    |                    |\n    |                    any code following this expression is unreachable\n    |"}, {"sha": "a8c3886657f43c14d466618e7df94601fc6bcf8f", "filename": "src/test/ui/union/union-unsafe.thir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Funion%2Funion-unsafe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Funion%2Funion-unsafe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.thir.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -55,10 +55,10 @@ LL |     let U1 { a } = u1;\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:65:20\n+  --> $DIR/union-unsafe.rs:65:8\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n-   |                    ^^ access to union field\n+   |        ^^^^^^^^^^^^^^^^^^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n "}, {"sha": "17e8830f630926d6f73e2e5966804be8010f49b1", "filename": "src/test/ui/while-let.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fwhile-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftest%2Fui%2Fwhile-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhile-let.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,8 +1,8 @@\n warning: irrefutable `while let` pattern\n-  --> $DIR/while-let.rs:7:13\n+  --> $DIR/while-let.rs:7:19\n    |\n LL |               while let $p = $e $b\n-   |               ^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^\n ...\n LL | /     foo!(_a, 1, {\n LL | |         println!(\"irrefutable pattern\");\n@@ -15,10 +15,10 @@ LL | |     });\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `while let` pattern\n-  --> $DIR/while-let.rs:7:13\n+  --> $DIR/while-let.rs:7:19\n    |\n LL |               while let $p = $e $b\n-   |               ^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^\n ...\n LL | /     bar!(_a, 1, {\n LL | |         println!(\"irrefutable pattern\");\n@@ -30,13 +30,10 @@ LL | |     });\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: irrefutable `while let` pattern\n-  --> $DIR/while-let.rs:27:5\n+  --> $DIR/while-let.rs:27:11\n    |\n-LL | /     while let _a = 1 {\n-LL | |         println!(\"irrefutable pattern\");\n-LL | |         break;\n-LL | |     }\n-   | |_____^\n+LL |     while let _a = 1 {\n+   |           ^^^^^^^^^^\n    |\n    = note: this pattern will always match, so the loop will never exit\n    = help: consider instead using a `loop { ... }` with a `let` inside it"}, {"sha": "891e865b245dda516c07987e4a5ce3827d0a094a", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n use if_chain::if_chain;\n@@ -116,8 +117,8 @@ enum AssertKind {\n /// where `message` is any expression and `c` is a constant bool.\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n-        if let ExprKind::If(cond, then, _) = expr.kind;\n-        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n+        if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n+        if let ExprKind::Unary(UnOp::Not, ref expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // block"}, {"sha": "51d95cc6f0b10b485c2f94e3fd10b200e9bb8442", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{differing_macro_contexts, get_parent_expr};\n@@ -92,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let ExprKind::If(cond, _, _) = &expr.kind {\n+        if let Some(higher::If { cond, .. }) = higher::If::hir(expr) {\n             if let ExprKind::Block(block, _) = &cond.kind {\n                 if block.rules == BlockCheckMode::DefaultBlock {\n                     if block.stmts.is_empty() {"}, {"sha": "6b63c2cf157ac8a8c819431005d56027022daab9", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{higher, is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -49,22 +49,44 @@ declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n \n impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            if_then,\n+            if_else,\n+            ..\n+        }) = higher::IfLet::hir(expr)\n+        {\n+            check_arm(cx, if_then, None, let_pat, if_else);\n+\n+            check_if_let(cx, if_then, let_pat);\n+        }\n+\n         if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n-            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| is_wild_like(cx, &arm.pat.kind, &arm.guard)) {\n                 for arm in arms {\n-                    check_arm(arm, wild_arm, cx);\n+                    check_arm(cx, arm.body, arm.guard.as_ref(), arm.pat, Some(wild_arm.body));\n                 }\n             }\n+\n+            if let Some(first_arm) = arms.get(0) {\n+                check_if_let(cx, &first_arm.body, &first_arm.pat);\n+            }\n         }\n     }\n }\n \n-fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext<'tcx>) {\n-    let expr = strip_singleton_blocks(arm.body);\n+fn check_arm<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    outer_block: &'tcx Expr<'tcx>,\n+    outer_guard: Option<&Guard<'tcx>>,\n+    outer_pat: &'tcx Pat<'tcx>,\n+    wild_outer_block: Option<&'tcx Expr<'tcx>>,\n+) {\n+    let expr = strip_singleton_blocks(outer_block);\n     if_chain! {\n         if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n         // the outer arm pattern and the inner match\n-        if expr_in.span.ctxt() == arm.pat.span.ctxt();\n+        if expr_in.span.ctxt() == outer_pat.span.ctxt();\n         // there must be no more than two arms in the inner match for this lint\n         if arms_inner.len() == 2;\n         // no if guards on the inner match\n@@ -73,18 +95,18 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         // match <local> { .. }\n         if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n         // one of the branches must be \"wild-like\"\n-        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| is_wild_like(cx, &arm_inner.pat.kind, &arm_inner.guard));\n         let (wild_inner_arm, non_wild_inner_arm) =\n             (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n         if !pat_contains_or(non_wild_inner_arm.pat);\n         // the binding must come from the pattern of the containing match arm\n         // ..<local>.. => match <local> { .. }\n-        if let Some(binding_span) = find_pat_binding(arm.pat, binding_id);\n+        if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n         // the \"wild-like\" branches must be equal\n-        if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n+        if wild_outer_block.map(|el| SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, el)).unwrap_or(true);\n         // the binding must not be used in the if guard\n         let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n-        if match arm.guard {\n+        if match outer_guard {\n             None => true,\n             Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !used_visitor.check_expr(expr),\n         };\n@@ -107,6 +129,31 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n     }\n }\n \n+fn check_if_let<'tcx>(cx: &LateContext<'tcx>, outer_expr: &'tcx Expr<'tcx>, outer_pat: &'tcx Pat<'tcx>) {\n+    let block_inner = strip_singleton_blocks(outer_expr);\n+    if_chain! {\n+        if let Some(higher::IfLet { if_then: inner_if_then, let_expr: inner_let_expr, let_pat: inner_let_pat, .. }) = higher::IfLet::hir(block_inner);\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, inner_let_expr));\n+        if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n+        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n+        if !used_visitor.check_expr(inner_if_then);\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                COLLAPSIBLE_MATCH,\n+                block_inner.span,\n+                \"unnecessary nested `if let` or `match`\",\n+                |diag| {\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_let_pat.span]);\n+                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n+                    help_span.push_span_label(inner_let_pat.span, \"with this pattern\".into());\n+                    diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n     while let ExprKind::Block(block, _) = expr.kind {\n         match (block.stmts, block.expr) {\n@@ -122,13 +169,13 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n }\n \n /// A \"wild-like\" pattern is wild (\"_\") or `None`.\n-/// For this lint to apply, both the outer and inner match expressions\n+/// For this lint to apply, both the outer and inner patterns\n /// must have \"wild-like\" branches that can be combined.\n-fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    if arm.guard.is_some() {\n+fn is_wild_like(cx: &LateContext<'_>, pat_kind: &PatKind<'_>, arm_guard: &Option<Guard<'_>>) -> bool {\n+    if arm_guard.is_some() {\n         return false;\n     }\n-    match arm.pat.kind {\n+    match pat_kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n         PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         _ => false,"}, {"sha": "5eb99cfe24f49dbae264ea7e6d48b02c7febab4f", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -316,9 +316,10 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n     let mut expr_eq = true;\n-    for win in blocks.windows(2) {\n-        let l_stmts = win[0].stmts;\n-        let r_stmts = win[1].stmts;\n+    let mut iter = blocks.windows(2);\n+    while let Some(&[win0, win1]) = iter.next() {\n+        let l_stmts = win0.stmts;\n+        let r_stmts = win1.stmts;\n \n         // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n         // The comparison therefore needs to be done in a way that builds the correct context.\n@@ -335,22 +336,22 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n             it1.zip(it2)\n                 .fold(0, |acc, (l, r)| if evaluator.eq_stmt(l, r) { acc + 1 } else { 0 })\n         };\n-        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n+        let block_expr_eq = both(&win0.expr, &win1.expr, |l, r| evaluator.eq_expr(l, r));\n \n         // IF_SAME_THEN_ELSE\n         if_chain! {\n             if block_expr_eq;\n             if l_stmts.len() == r_stmts.len();\n             if l_stmts.len() == current_start_eq;\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[0].hir_id);\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[1].hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win0.hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win1.hir_id);\n             then {\n                 span_lint_and_note(\n                     cx,\n                     IF_SAME_THEN_ELSE,\n-                    win[0].span,\n+                    win0.span,\n                     \"this `if` has identical blocks\",\n-                    Some(win[1].span),\n+                    Some(win1.span),\n                     \"same as this\",\n                 );\n "}, {"sha": "7825e5f6ed52e45f9f715c0cb2b93fd55a4fc9ca", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -232,6 +232,7 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n         | ExprKind::If(..)\n         | ExprKind::Loop(..)\n         | ExprKind::Match(..)\n+        | ExprKind::Let(..)\n         | ExprKind::Closure(..)\n         | ExprKind::Block(..)\n         | ExprKind::Assign(..)"}, {"sha": "627f746ec99716fd6510ba61cbd7b0912c327e53", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,10 +1,12 @@\n+use clippy_utils::higher;\n use clippy_utils::{\n     can_move_expr_to_closure_no_visit,\n     diagnostics::span_lint_and_sugg,\n     is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n     source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n     SpanlessEq,\n };\n+use core::fmt::Write;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n@@ -13,7 +15,6 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n-use std::fmt::Write;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -62,10 +63,11 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (cond_expr, then_expr, else_expr) = match expr.kind {\n-            ExprKind::If(c, t, e) => (c, t, e),\n+        let (cond_expr, then_expr, else_expr) = match higher::If::hir(expr) {\n+            Some(higher::If { cond, then, r#else }) => (cond, then, r#else),\n             _ => return,\n         };\n+\n         let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n             Some(x) => x,\n             None => return,"}, {"sha": "f6a64a8ca6031f7a352595ed48d0f283ba8ea8da", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -100,7 +100,7 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n \n         if ex.span.ctxt() != expr.span.ctxt() {\n             if decl.inputs.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::vec_macro(cx, ex) {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, ex) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "d12482e7b7bb9531bb4fe569e29321b1976d121c", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::consts::{\n     Constant::{Int, F32, F64},\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::{eq_expr_value, get_parent_expr, numeric_literal, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -545,11 +546,11 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::If(cond, body, else_body) = expr.kind;\n-        if let ExprKind::Block(block, _) = body.kind;\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+        if let ExprKind::Block(block, _) = then.kind;\n         if block.stmts.is_empty();\n         if let Some(if_body_expr) = block.expr;\n-        if let Some(ExprKind::Block(else_block, _)) = else_body.map(|el| &el.kind);\n+        if let Some(ExprKind::Block(else_block, _)) = r#else.map(|el| &el.kind);\n         if else_block.stmts.is_empty();\n         if let Some(else_body_expr) = else_block.expr;\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);"}, {"sha": "e2d3905eacb504106cbe27b58fe633c9174dfc86", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -42,7 +43,7 @@ declare_clippy_lint! {\n declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         let mut arm_visit = ArmVisitor {\n             mutex_lock_called: false,\n             found_mutex: None,\n@@ -53,25 +54,23 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n             found_mutex: None,\n             cx,\n         };\n-        if let ExprKind::Match(\n-            op,\n-            arms,\n-            MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            },\n-        ) = ex.kind\n+        if let Some(higher::IfLet {\n+            let_expr,\n+            if_then,\n+            if_else: Some(if_else),\n+            ..\n+        }) = higher::IfLet::hir(expr)\n         {\n-            op_visit.visit_expr(op);\n+            op_visit.visit_expr(let_expr);\n             if op_visit.mutex_lock_called {\n-                for arm in arms {\n-                    arm_visit.visit_arm(arm);\n-                }\n+                arm_visit.visit_expr(if_then);\n+                arm_visit.visit_expr(if_else);\n \n                 if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n                     span_lint_and_help(\n                         cx,\n                         IF_LET_MUTEX,\n-                        ex.span,\n+                        expr.span,\n                         \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n                         None,\n                         \"move the lock call outside of the `if let ...` expression\","}, {"sha": "cd813c639dbbf2391c2bac32b1262e90926ff851", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::method_chain_args;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n+use rustc_hir::{Expr, ExprKind, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -44,17 +45,17 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(op, body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n-            if let ExprKind::MethodCall(_, ok_span, result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = body[0].pat.kind; //get operation\n-            if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(expr);\n+            if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = let_pat.kind; //get operation\n+            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n-                let trimmed_ok = snippet_with_applicability(cx, op.span.until(ok_span), \"\", &mut applicability);\n+                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_span), \"\", &mut applicability);\n                 let sugg = format!(\n                     \"if let Ok({}) = {}\",\n                     some_expr_string,\n@@ -63,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n                 span_lint_and_sugg(\n                     cx,\n                     IF_LET_SOME_RESULT,\n-                    expr.span.with_hi(op.span.hi()),\n+                    expr.span.with_hi(let_expr.span.hi()),\n                     \"matching on `Some` with `ok()` is redundant\",\n                     &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n                     sugg,"}, {"sha": "a2dac57454f2d3b7430d4127c70dec75b1952e64", "filename": "src/tools/clippy/clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind};\n@@ -70,7 +70,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(cond, then, Some(els)) = expr.kind;\n+            if let Some(higher::If { cond, then, r#else: Some(els) }) = higher::If::hir(expr);\n             if let ExprKind::Block(then_block, _) = then.kind;\n             if let Some(then_expr) = then_block.expr;\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;"}, {"sha": "79d4d7ddcbcedfe8e0ad85116a98a76068dc6c46", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::{in_macro, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -42,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             return;\n         }\n         if_chain! {\n-            if let ExprKind::If(cond, then, None) = &expr.kind;\n+            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n \n             // Check if the conditional expression is a binary operation\n             if let ExprKind::Binary(ref cond_op, cond_left, cond_right) = cond.kind;"}, {"sha": "f52f090d3872e11ab873ada16b9a0621620d299e", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(array, index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array).peel_refs();\n-            if let Some(range) = higher::range(index) {\n+            if let Some(range) = higher::Range::hir(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind() {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {"}, {"sha": "58646385def52412fad1a43941fd2df562029da7", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -172,7 +172,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 Finite\n             }\n         },\n-        ExprKind::Struct(..) => higher::range(expr).map_or(false, |r| r.end.is_none()).into(),\n+        ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n }"}, {"sha": "0594b73dd38378dd17f4821f639fb76ea8e4815a", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::StmtKind::Local(local) = stmt.kind;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n-                if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n+                if let hir::ExprKind::If(hir::Expr { kind: hir::ExprKind::DropTemps(cond), ..}, then, else_) = if_.kind;\n                 let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n                 if !used_visitor.check_expr(cond);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n@@ -79,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     );\n                     if has_interior_mutability { return; }\n \n-                    let (default_multi_stmts, default) = if let Some(else_) = *else_ {\n+                    let (default_multi_stmts, default) = if let Some(else_) = else_ {\n                         if let hir::ExprKind::Block(else_, _) = else_.kind {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)"}, {"sha": "9f2bc3c7ebae7787c1b89a4a236b7c50b74deae5", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,11 +1,12 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, ExprKind, Pat, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -36,14 +37,12 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n-            if let ExprKind::Match(\n-                match_expr, match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n-            ) = inner_expr.kind;\n+            if let Some(higher::IfLet { let_pat, let_expr, if_else: None, .. }) = higher::IfLet::hir(inner_expr);\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(match_expr, pat_hir_id);\n+            if path_to_local_id(let_expr, pat_hir_id);\n             // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(ref qpath, _, _) = match_arms[0].pat.kind;\n+            if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n             let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n@@ -55,7 +54,7 @@ pub(super) fn check<'tcx>(\n                 // Prepare the help message\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-                let copied = match cx.typeck_results().expr_ty(match_expr).kind() {\n+                let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n                     ty::Ref(_, inner, _) => match inner.kind() {\n                         ty::Ref(..) => \".copied()\",\n                         _ => \"\""}, {"sha": "2525b14e1c5c3dbb8a8d461ba2a1e2a4877f0260", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check<'tcx>(\n         start: Some(start),\n         end: Some(end),\n         limits,\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {"}, {"sha": "bd9de5e08d736e877f013b15bcf878afe8666877", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -551,7 +551,7 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n+        if let Some(higher::ForLoop { pat, arg, body, span }) = higher::ForLoop::hir(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n@@ -580,8 +580,8 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some((cond, body)) = higher::while_loop(expr) {\n-            while_immutable_condition::check(cx, cond, body);\n+        if let Some(higher::While { if_cond, if_then, .. }) = higher::While::hir(&expr) {\n+            while_immutable_condition::check(cx, if_cond, if_then);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "344dc5074d369ff5e47e2751fbb46c79019963aa", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n         start: Some(start),\n         end: Some(end),\n         ..\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {"}, {"sha": "3f77e7af927ad67c79dcf3ec92dda54335a048b9", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n         start: Some(start),\n         ref end,\n         limits,\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {"}, {"sha": "2c46971d5f741358eba4646be0997efb601c0aa5", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::NEVER_LOOP;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher;\n+use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n                     if_chain! {\n                         if let LoopSource::ForLoop = source;\n                         if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-                        if let Some((pat, iterator, _, for_span)) = higher::for_loop(parent_match);\n+                        if let Some(ForLoop { arg: iterator, pat, span: for_span, .. }) = ForLoop::hir(parent_match);\n                         then {\n                             // Suggests using an `if let` instead. This is `Unspecified` because the\n                             // loop may (probably) contain `break` statements which would be invalid\n@@ -111,6 +111,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Unary(_, e)\n         | ExprKind::Cast(e, _)\n         | ExprKind::Type(e, _)\n+        | ExprKind::Let(_, e, _)\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Struct(_, _, Some(e))\n@@ -128,7 +129,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprKind::If(e, e2, ref e3) => {\n+        ExprKind::If(e, e2, e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3\n@@ -156,7 +157,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+        ExprKind::Break(_, e) | ExprKind::Ret(e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n             combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n         }),\n         ExprKind::InlineAsm(asm) => asm"}, {"sha": "6be410ca8e3cbafd5489cbb962f4eb0b73e37b82", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,8 +1,9 @@\n use super::WHILE_LET_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n \n@@ -11,41 +12,25 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n     let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n     // or extract the first expression (if any) from the block\n     if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let ExprKind::Match(matchexpr, arms, ref source) = inner.kind {\n-            // ensure \"if let\" compatible match structure\n-            match *source {\n-                MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n-                    if arms.len() == 2\n-                        && arms[0].guard.is_none()\n-                        && arms[1].guard.is_none()\n-                        && is_simple_break_expr(arms[1].body)\n-                    {\n-                        if in_external_macro(cx.sess(), expr.span) {\n-                            return;\n-                        }\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            let_expr,\n+            if_else: Some(if_else),\n+            ..\n+        }) = higher::IfLet::hir(inner)\n+        {\n+            if is_simple_break_expr(if_else) {\n+                could_be_while_let(cx, expr, let_pat, let_expr);\n+            }\n+        }\n \n-                        // NOTE: we used to build a body here instead of using\n-                        // ellipsis, this was removed because:\n-                        // 1) it was ugly with big bodies;\n-                        // 2) it was not indented properly;\n-                        // 3) it wasn\u2019t very smart (see #675).\n-                        let mut applicability = Applicability::HasPlaceholders;\n-                        span_lint_and_sugg(\n-                            cx,\n-                            WHILE_LET_LOOP,\n-                            expr.span,\n-                            \"this loop could be written as a `while let` loop\",\n-                            \"try\",\n-                            format!(\n-                                \"while let {} = {} {{ .. }}\",\n-                                snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n-                            ),\n-                            applicability,\n-                        );\n-                    }\n-                },\n-                _ => (),\n+        if let ExprKind::Match(ref matchexpr, ref arms, MatchSource::Normal) = inner.kind {\n+            if arms.len() == 2\n+                && arms[0].guard.is_none()\n+                && arms[1].guard.is_none()\n+                && is_simple_break_expr(&arms[1].body)\n+            {\n+                could_be_while_let(cx, expr, &arms[0].pat, matchexpr);\n             }\n         }\n     }\n@@ -54,14 +39,12 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n /// If a block begins with a statement (possibly a `let` binding) and has an\n /// expression, return it.\n fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if block.stmts.is_empty() {\n-        return None;\n-    }\n-    if let StmtKind::Local(local) = block.stmts[0].kind {\n-        local.init //.map(|expr| expr)\n-    } else {\n-        None\n+    if let Some(first_stmt) = block.stmts.get(0) {\n+        if let StmtKind::Local(local) = first_stmt.kind {\n+            return local.init;\n+        }\n     }\n+    None\n }\n \n /// If a block begins with an expression (with or without semicolon), return it.\n@@ -86,3 +69,34 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n         _ => false,\n     }\n }\n+\n+fn could_be_while_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+) {\n+    if in_external_macro(cx.sess(), expr.span) {\n+        return;\n+    }\n+\n+    // NOTE: we used to build a body here instead of using\n+    // ellipsis, this was removed because:\n+    // 1) it was ugly with big bodies;\n+    // 2) it was not indented properly;\n+    // 3) it wasn\u2019t very smart (see #675).\n+    let mut applicability = Applicability::HasPlaceholders;\n+    span_lint_and_sugg(\n+        cx,\n+        WHILE_LET_LOOP,\n+        expr.span,\n+        \"this loop could be written as a `while let` loop\",\n+        \"try\",\n+        format!(\n+            \"while let {} = {} {{ .. }}\",\n+            snippet_with_applicability(cx, let_pat.span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability),\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "0757d329125cb12a1680ad90feef70e29c64e9fb", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,33 +1,38 @@\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n     get_enclosing_loop_or_closure, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Mutability, Node, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n-        if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind;\n+        if let Some(higher::WhileLet {\n+            if_then,\n+            let_pat,\n+            let_expr,\n+            ..\n+        }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = arm.pat.kind;\n+        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = scrutinee_expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n-        if is_trait_method(cx, scrutinee_expr, sym::Iterator);\n-        if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr);\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);\n         // get the loop containing the match expression\n-        if let Some((_, Node::Expr(loop_expr))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-        if !uses_iter(cx, &iter_expr, arm.body);\n+        if !uses_iter(cx, &iter_expr_struct, if_then);\n         then {\n-            (scrutinee_expr, iter_expr, some_pat, loop_expr)\n+            (let_expr, iter_expr_struct, some_pat, expr)\n         } else {\n             return;\n         }\n@@ -81,6 +86,7 @@ struct IterExpr {\n     /// The path being used.\n     path: Res,\n }\n+\n /// Parses any expression to find out which field of which variable is used. Will return `None` if\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n@@ -285,6 +291,7 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n     }\n     impl Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n+\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n         }"}, {"sha": "53d97f775435a8dbb1c8e5920c28e8a55f3d2a6a", "filename": "src/tools/clippy/clippy_lints/src/manual_map.rs", "status": "modified", "additions": 161, "deletions": 140, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,5 +1,6 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n@@ -9,7 +10,7 @@ use clippy_utils::{\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -43,163 +44,176 @@ declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n impl LateLintPass<'_> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(\n-            scrutinee,\n-            [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n-            match_kind,\n-        ) = expr.kind\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            let_expr,\n+            if_then,\n+            if_else: Some(if_else),\n+        }) = higher::IfLet::hir(expr)\n         {\n-            if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-                return;\n-            }\n+            manage_lint(cx, expr, (&let_pat.kind, if_then), (&PatKind::Wild, if_else), let_expr);\n+        }\n \n-            let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-                peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-            if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-                && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n-            {\n-                return;\n-            }\n+        if let ExprKind::Match(scrutinee, [then @ Arm { guard: None, .. }, r#else @ Arm { guard: None, .. }], _) =\n+            expr.kind\n+        {\n+            manage_lint(\n+                cx,\n+                expr,\n+                (&then.pat.kind, then.body),\n+                (&r#else.pat.kind, r#else.body),\n+                scrutinee,\n+            );\n+        }\n+    }\n+}\n \n-            let expr_ctxt = expr.span.ctxt();\n-            let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-                try_parse_pattern(cx, arm1.pat, expr_ctxt),\n-                try_parse_pattern(cx, arm2.pat, expr_ctxt),\n-            ) {\n-                (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n-                    if is_none_expr(cx, arm1.body) =>\n-                {\n-                    (arm2.body, pattern, ref_count, true)\n-                },\n-                (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n-                    if is_none_expr(cx, arm1.body) =>\n-                {\n-                    (arm2.body, pattern, ref_count, false)\n-                },\n-                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n-                    if is_none_expr(cx, arm2.body) =>\n-                {\n-                    (arm1.body, pattern, ref_count, true)\n-                },\n-                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n-                    if is_none_expr(cx, arm2.body) =>\n-                {\n-                    (arm1.body, pattern, ref_count, false)\n-                },\n-                _ => return,\n-            };\n+fn manage_lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    then: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n+    r#else: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n+    scrut: &'tcx Expr<'_>,\n+) {\n+    if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n+        return;\n+    }\n \n-            // Top level or patterns aren't allowed in closures.\n-            if matches!(some_pat.kind, PatKind::Or(_)) {\n-                return;\n-            }\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) = peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrut));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n+    {\n+        return;\n+    }\n \n-            let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n-                Some(expr) => expr,\n-                None => return,\n-            };\n+    let (then_pat, then_expr) = then;\n+    let (else_pat, else_expr) = r#else;\n \n-            // These two lints will go back and forth with each other.\n-            if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n-                && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-            {\n-                return;\n-            }\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        try_parse_pattern(cx, else_pat, expr_ctxt),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n+            (else_expr, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n+            (else_expr, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_expr) => {\n+            (then_expr, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_expr) => {\n+            (then_expr, pattern, ref_count, false)\n+        },\n+        _ => return,\n+    };\n \n-            // `map` won't perform any adjustments.\n-            if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n-                return;\n-            }\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return;\n+    }\n \n-            if !can_move_expr_to_closure(cx, some_expr) {\n-                return;\n-            }\n+    let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+        Some(expr) => expr,\n+        None => return,\n+    };\n \n-            // Determine which binding mode to use.\n-            let explicit_ref = some_pat.contains_explicit_ref_binding();\n-            let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+    if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id) {\n+        return;\n+    }\n \n-            let as_ref_str = match binding_ref {\n-                Some(Mutability::Mut) => \".as_mut()\",\n-                Some(Mutability::Not) => \".as_ref()\",\n-                None => \"\",\n-            };\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+        return;\n+    }\n \n-            let mut app = Applicability::MachineApplicable;\n+    if !can_move_expr_to_closure(cx, some_expr) {\n+        return;\n+    }\n \n-            // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-            // it's being passed by value.\n-            let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-            let scrutinee_str =\n-                if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-                    format!(\"({})\", scrutinee_str)\n-                } else {\n-                    scrutinee_str.into()\n-                };\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n \n-            let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-                match can_pass_as_func(cx, id, some_expr) {\n-                    Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n-                        snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                    },\n-                    _ => {\n-                        if path_to_local_id(some_expr, id)\n-                            && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                            && binding_ref.is_some()\n-                        {\n-                            return;\n-                        }\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrut).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({})\", scrutinee_str)\n+    } else {\n+        scrutinee_str.into()\n+    };\n \n-                        // `ref` and `ref mut` annotations were handled earlier.\n-                        let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                            \"mut \"\n-                        } else {\n-                            \"\"\n-                        };\n-                        format!(\n-                            \"|{}{}| {}\",\n-                            annotation,\n-                            some_binding,\n-                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                        )\n-                    },\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        match can_pass_as_func(cx, id, some_expr) {\n+            Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            },\n+            _ => {\n+                if path_to_local_id(some_expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return;\n                 }\n-            } else if !is_wild_none && explicit_ref.is_none() {\n-                // TODO: handle explicit reference annotations.\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n                 format!(\n-                    \"|{}| {}\",\n-                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                    \"|{}{}| {}\",\n+                    annotation,\n+                    some_binding,\n                     snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n                 )\n-            } else {\n-                // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-                return;\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_MAP,\n-                expr.span,\n-                \"manual implementation of `Option::map`\",\n-                \"try this\",\n-                if matches!(match_kind, MatchSource::IfLetDesugar { .. }) && is_else_clause(cx.tcx, expr) {\n-                    format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n-                } else {\n-                    format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n-                },\n-                app,\n-            );\n+            },\n         }\n-    }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        format!(\n+            \"|{}| {}\",\n+            snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+        )\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return;\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MANUAL_MAP,\n+        expr.span,\n+        \"manual implementation of `Option::map`\",\n+        \"try this\",\n+        if is_else_clause(cx.tcx, expr) {\n+            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+        } else {\n+            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+        },\n+        app,\n+    );\n }\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id (arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },\n@@ -221,21 +235,28 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n+fn try_parse_pattern(\n+    cx: &LateContext<'tcx>,\n+    pat_kind: &'tcx PatKind<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<OptionPat<'tcx>> {\n+    fn f(\n+        cx: &LateContext<'tcx>,\n+        pat_kind: &'tcx PatKind<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat_kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Ref(ref_pat, _) => f(cx, &ref_pat.kind, ref_count + 1, ctxt),\n             PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n+            PatKind::TupleStruct(ref qpath, [pattern], _) if is_lang_ctor(cx, qpath, OptionSome) => {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat, 0, ctxt)\n+    f(cx, pat_kind, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression."}, {"sha": "4e040508b6bfbdc396c233c1df3222add7802ca1", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(cond, then, _) = &expr.kind;\n+            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n             if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n@@ -212,7 +212,7 @@ fn find_stripping<'tcx>(\n                 if is_ref_str(self.cx, ex);\n                 let unref = peel_ref(ex);\n                 if let ExprKind::Index(indexed, index) = &unref.kind;\n-                if let Some(higher::Range { start, end, .. }) = higher::range(index);\n+                if let Some(higher::Range { start, end, .. }) = higher::Range::hir(index);\n                 if let ExprKind::Path(path) = &indexed.kind;\n                 if self.cx.qpath_res(path, ex.hir_id) == self.target;\n                 then {"}, {"sha": "a183d0c66e8ced59d9da785a2e9b2d18ef4545b2", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 169, "deletions": 96, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -2,6 +2,7 @@ use clippy_utils::consts::{constant, miri_to_const, Constant};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n+use clippy_utils::higher;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n@@ -12,8 +13,10 @@ use clippy_utils::{\n     strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n+use core::array;\n+use core::iter::{once, ExactSizeIterator};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n+use rustc_ast::ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -628,8 +631,11 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 check_match_single_binding(cx, ex, arms, expr);\n             }\n         }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms, expr);\n+        if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n+            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n+        }\n+        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(expr) {\n+            check_match_ref_pats(cx, let_expr, once(let_pat), expr);\n         }\n     }\n \n@@ -1179,39 +1185,40 @@ fn is_panic_block(block: &Block<'_>) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if has_only_ref_pats(arms) {\n-        let mut suggs = Vec::with_capacity(arms.len() + 1);\n-        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-            let span = ex.span.source_callsite();\n-            suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-            (\n-                \"you don't need to add `&` to both the expression and the patterns\",\n-                \"try\",\n-            )\n-        } else {\n-            let span = ex.span.source_callsite();\n-            suggs.push((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-            (\n-                \"you don't need to add `&` to all patterns\",\n-                \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n-            )\n-        };\n-\n-        suggs.extend(arms.iter().filter_map(|a| {\n-            if let PatKind::Ref(refp, _) = a.pat.kind {\n-                Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-            } else {\n-                None\n-            }\n-        }));\n+fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_only_ref_pats(pats.clone()) {\n+        return;\n+    }\n \n-        span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-            if !expr.span.from_expansion() {\n-                multispan_sugg(diag, msg, suggs);\n-            }\n-        });\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n     }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(ref refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n }\n \n fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n@@ -1286,46 +1293,99 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n-        match match_source {\n-            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n-            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n-            _ => false,\n-        }\n-    } else {\n-        false\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(expr)\n+    {\n+        return find_matches_sugg(\n+            cx,\n+            let_expr,\n+            array::IntoIter::new([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n     }\n+\n+    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n+        return find_matches_sugg(\n+            cx,\n+            scrut,\n+            arms.iter().map(|arm| {\n+                (\n+                    cx.tcx.hir().attrs(arm.hir_id),\n+                    Some(arm.pat),\n+                    arm.body,\n+                    arm.guard.as_ref(),\n+                )\n+            }),\n+            expr,\n+            false,\n+        );\n+    }\n+\n+    false\n }\n \n-/// Lint a `match` or desugared `if let` for replacement by `matches!`\n-fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) -> bool {\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n     if_chain! {\n-        if arms.len() >= 2;\n+        if iter.len() >= 2;\n         if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((b1_arm, b0_arms)) = arms.split_last();\n-        if let Some(b0) = find_bool_lit(&b0_arms[0].body.kind, desugared);\n-        if let Some(b1) = find_bool_lit(&b1_arm.body.kind, desugared);\n-        if is_wild(b1_arm.pat);\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n         if b0 != b1;\n-        let if_guard = &b0_arms[0].guard;\n-        if if_guard.is_none() || b0_arms.len() == 1;\n-        if cx.tcx.hir().attrs(b0_arms[0].hir_id).is_empty();\n-        if b0_arms[1..].iter()\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n             .all(|arm| {\n-                find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n-                arm.guard.is_none() && cx.tcx.hir().attrs(arm.hir_id).is_empty()\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n             });\n         then {\n+            if let Some(ref last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n             // The suggestion may be incorrect, because some arms can have `cfg` attributes\n             // evaluated into `false` and so such arms will be stripped before.\n             let mut applicability = Applicability::MaybeIncorrect;\n             let pat = {\n                 use itertools::Itertools as _;\n-                b0_arms.iter()\n-                    .map(|arm| snippet_with_applicability(cx, arm.pat.span, \"..\", &mut applicability))\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n                     .join(\" | \")\n             };\n-            let pat_and_guard = if let Some(Guard::If(g)) = if_guard {\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n                 format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n             } else {\n                 pat\n@@ -1342,7 +1402,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n                 cx,\n                 MATCH_LIKE_MATCHES_MACRO,\n                 expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n                 \"try this\",\n                 format!(\n                     \"{}matches!({}, {})\",\n@@ -1360,7 +1420,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n }\n \n /// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n     match ex {\n         ExprKind::Lit(Spanned {\n             node: LitKind::Bool(b), ..\n@@ -1372,7 +1432,7 @@ fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n                 ..\n             },\n             _,\n-        ) if desugared => {\n+        ) if is_if_let => {\n             if let ExprKind::Lit(Spanned {\n                 node: LitKind::Bool(b), ..\n             }) = exp.kind\n@@ -1644,19 +1704,26 @@ fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotat\n     None\n }\n \n-fn has_only_ref_pats(arms: &[Arm<'_>]) -> bool {\n-    let mapped = arms\n-        .iter()\n-        .map(|a| {\n-            match a.pat.kind {\n-                PatKind::Ref(..) => Some(true), // &-patterns\n-                PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-                _ => None,                      // any other pattern is not fine\n+fn has_only_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut at_least_one_is_true = false;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                at_least_one_is_true = true;\n             }\n-        })\n-        .collect::<Option<Vec<bool>>>();\n-    // look for Some(v) where there's at least one true element\n-    mapped.map_or(false, |v| v.iter().any(|el| *el))\n+        } else {\n+            return false;\n+        }\n+    }\n+    at_least_one_is_true\n }\n \n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n@@ -1745,6 +1812,7 @@ where\n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n+    use clippy_utils::higher;\n     use clippy_utils::source::{snippet, snippet_with_applicability};\n     use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n     use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n@@ -1755,22 +1823,27 @@ mod redundant_pattern_match {\n     use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n     use rustc_hir::{\n         intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, PatKind, QPath,\n+        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath,\n     };\n     use rustc_lint::LateContext;\n     use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n     use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { contains_else_clause } => {\n-                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause);\n-                },\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, &arms[0], \"while\", false),\n-                _ => {},\n-            }\n+        if let Some(higher::IfLet {\n+            if_else,\n+            let_pat,\n+            let_expr,\n+            ..\n+        }) = higher::IfLet::ast(cx, expr)\n+        {\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some())\n+        }\n+        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n+            find_sugg_for_match(cx, expr, op, arms)\n+        }\n+        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false)\n         }\n     }\n \n@@ -1924,18 +1997,18 @@ mod redundant_pattern_match {\n     fn find_sugg_for_if_let<'tcx>(\n         cx: &LateContext<'tcx>,\n         expr: &'tcx Expr<'_>,\n-        op: &'tcx Expr<'tcx>,\n-        arm: &Arm<'_>,\n+        let_pat: &Pat<'_>,\n+        let_expr: &'tcx Expr<'_>,\n         keyword: &'static str,\n         has_else: bool,\n     ) {\n         // also look inside refs\n-        let mut kind = &arm.pat.kind;\n+        let mut kind = &let_pat.kind;\n         // if we have &None for example, peel it so we can detect \"if let None = x\"\n         if let PatKind::Ref(inner, _mutability) = kind {\n             kind = &inner.kind;\n         }\n-        let op_ty = cx.typeck_results().expr_ty(op);\n+        let op_ty = cx.typeck_results().expr_ty(let_expr);\n         // Determine which function should be used, and the type contained by the corresponding\n         // variant.\n         let (good_method, inner_ty) = match kind {\n@@ -1989,38 +2062,38 @@ mod redundant_pattern_match {\n         // scrutinee would be, so they have to be considered as well.\n         // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n         // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, op);\n+        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n \n         // check that `while_let_on_iterator` lint does not trigger\n         if_chain! {\n             if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if let ExprKind::MethodCall(method_path, _, _, _) = let_expr.kind;\n             if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, op, sym::Iterator);\n+            if is_trait_method(cx, let_expr, sym::Iterator);\n             then {\n                 return;\n             }\n         }\n \n-        let result_expr = match &op.kind {\n+        let result_expr = match &let_expr.kind {\n             ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            _ => op,\n+            _ => let_expr,\n         };\n         span_lint_and_then(\n             cx,\n             REDUNDANT_PATTERN_MATCHING,\n-            arm.pat.span,\n+            let_pat.span,\n             &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n             |diag| {\n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                 let expr_span = expr.span;\n \n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 //                 ^^^\n                 let op_span = result_expr.span.source_callsite();\n \n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^\n                 let span = expr_span.until(op_span.shrink_to_hi());\n "}, {"sha": "6954da67e32c0fe3ae940abcaedd1b93c14005af", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n     // since it is already covered by `&loops::ITER_NEXT_LOOP`\n     let mut parent_expr_opt = get_parent_expr(cx, expr);\n     while let Some(parent_expr) = parent_expr_opt {\n-        if higher::for_loop(parent_expr).is_some() {\n+        if higher::ForLoop::hir(parent_expr).is_some() {\n             return;\n         }\n         parent_expr_opt = get_parent_expr(cx, parent_expr);\n@@ -29,7 +29,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n         if_chain! {\n             if let hir::ExprKind::Index(caller_var, index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n-                = higher::range(index_expr);\n+                = higher::Range::hir(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {"}, {"sha": "610152a217f1e3dac93028b9b41a945f37b92468", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some((_, arg, body, _)) = higher::for_loop(expr) {\n+        if let Some(higher::ForLoop { arg, body, .. }) = higher::ForLoop::hir(expr) {\n             // A `for` loop lowers to:\n             // ```rust\n             // match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "c9dd94400efb96163f0d01028cc92cb91eef4ecc", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{is_else_clause, is_expn_of};\n@@ -77,10 +78,15 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n+        if let Some(higher::If {\n+            cond,\n+            then,\n+            r#else: Some(r#else),\n+        }) = higher::If::hir(e)\n+        {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n+                let snip = Sugg::hir_with_applicability(cx, cond, \"<predicate>\", &mut applicability);\n                 let mut snip = if not { !snip } else { snip };\n \n                 if ret {\n@@ -101,8 +107,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(then_block, _) = then_block.kind {\n-                match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n+            if let ExprKind::Block(then, _) = then.kind {\n+                match (fetch_bool_block(then), fetch_bool_expr(r#else)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n                             cx,"}, {"sha": "ac21eb5275f0f8bc443e0a88a903d0ac70e7e089", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n-    PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "d0b0bad5eb1cce187a4de039284ac924ea5ce067", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -84,20 +85,20 @@ struct OptionIfLetElseOccurence {\n \n /// Extracts the body of a given arm. If the arm contains only an expression,\n /// then it returns the expression. Otherwise, it returns the entire block\n-fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n     if let ExprKind::Block(\n         Block {\n-            stmts: statements,\n-            expr: Some(expr),\n+            stmts: block_stmts,\n+            expr: Some(block_expr),\n             ..\n         },\n         _,\n-    ) = &arm.body.kind\n+    ) = expr.kind\n     {\n-        if let [] = statements {\n-            Some(expr)\n+        if let [] = block_stmts {\n+            Some(block_expr)\n         } else {\n-            Some(arm.body)\n+            Some(expr)\n         }\n     } else {\n         None\n@@ -121,37 +122,33 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n /// If this expression is the option if let/else construct we're detecting, then\n /// this function returns an `OptionIfLetElseOccurence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(\n-    cx: &'_ LateContext<'tcx>,\n-    expr: &'_ Expr<'tcx>,\n-) -> Option<OptionIfLetElseOccurence> {\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(expr);\n         if !is_else_clause(cx.tcx, expr);\n-        if arms.len() == 2;\n-        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &arms[0].pat.kind;\n+        if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(arms[0].body);\n-        if !contains_return_break_continue_macro(arms[1].body);\n+        if !contains_return_break_continue_macro(if_then);\n+        if !contains_return_break_continue_macro(if_else);\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_arm(&arms[0])?;\n-            let none_body = extract_body_from_arm(&arms[1])?;\n+            let some_body = extract_body_from_expr(if_then)?;\n+            let none_body = extract_body_from_expr(if_else)?;\n             let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n-            let (as_ref, as_mut) = match &cond_expr.kind {\n+            let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n                 _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n             };\n-            let cond_expr = match &cond_expr.kind {\n+            let cond_expr = match let_expr.kind {\n                 // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n-                _ => cond_expr,\n+                _ => let_expr,\n             };\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),"}, {"sha": "35cff4141a903b40cdf58c3f176a9a599aeca3dc", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -104,22 +104,25 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(expr, arms, source) = expr.kind {\n-            match source {\n-                MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n-                    if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n-                        'pattern_checks: for arm in arms {\n-                            let pat = &arm.pat;\n-                            if in_external_macro(cx.sess(), pat.span) {\n-                                continue 'pattern_checks;\n-                            }\n-                            if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n-                                break 'pattern_checks;\n-                            }\n-                        }\n+        if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = expr.kind {\n+            if let Some(expr_ty) = cx.typeck_results().node_type_opt(scrutinee.hir_id) {\n+                'pattern_checks: for arm in arms {\n+                    let pat = &arm.pat;\n+                    if in_external_macro(cx.sess(), pat.span) {\n+                        continue 'pattern_checks;\n                     }\n-                },\n-                _ => (),\n+                    if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n+                        break 'pattern_checks;\n+                    }\n+                }\n+            }\n+        }\n+        if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n+            if let Some(ref expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n+                if in_external_macro(cx.sess(), let_pat.span) {\n+                    return;\n+                }\n+                apply_lint(cx, let_pat, expr_ty, DerefPossible::Possible);\n             }\n         }\n     }"}, {"sha": "91085c13ac4a4f76faf4f1255af42987e231c4c4", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n@@ -7,7 +8,7 @@ use clippy_utils::{eq_expr_value, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -50,20 +51,20 @@ impl QuestionMark {\n     /// If it matches, it will suggest to use the question mark operator instead\n     fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::If(if_expr, body, else_) = &expr.kind;\n-            if let ExprKind::MethodCall(segment, _, args, _) = &if_expr.kind;\n+            if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+            if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n             if segment.ident.name == sym!(is_none);\n-            if Self::expression_returns_none(cx, body);\n+            if Self::expression_returns_none(cx, then);\n             if let Some(subject) = args.get(0);\n             if Self::is_option(cx, subject);\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n-                if let Some(else_) = else_ {\n+                if let Some(else_inner) = r#else {\n                     if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_.kind;\n+                        if let ExprKind::Block(block, None) = &else_inner.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n                         if eq_expr_value(cx, subject, block_expr);\n@@ -96,25 +97,23 @@ impl QuestionMark {\n \n     fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Match(subject, arms, source) = &expr.kind;\n-            if *source == MatchSource::IfLetDesugar { contains_else_clause: true };\n-            if Self::is_option(cx, subject);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(expr);\n+            if Self::is_option(cx, let_expr);\n \n-            if let PatKind::TupleStruct(path1, fields, None) = &arms[0].pat.kind;\n+            if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n             if is_lang_ctor(cx, path1, OptionSome);\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n \n-            if let ExprKind::Block(block, None) = &arms[0].body.kind;\n+            if let ExprKind::Block(ref block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);\n \n-            if let PatKind::Wild = arms[1].pat.kind;\n-            if Self::expression_returns_none(cx, arms[1].body);\n+            if Self::expression_returns_none(cx, if_else);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let receiver_str = snippet_with_applicability(cx, subject.span, \"..\", &mut applicability);\n+                let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n                 let replacement = format!(\n                     \"{}{}?\",\n                     receiver_str,"}, {"sha": "0114a2f97a2287d84a82269d9f5dd19f08e81dfa", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -329,15 +329,15 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if let ExprKind::MethodCall(iter_path, _, iter_args, _) = iter.kind;\n         if iter_path.ident.name == sym::iter;\n         // range expression in `.zip()` call: `0..x.len()`\n-        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n         if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n         if len_path.ident.name == sym::len && len_args.len() == 1;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n+        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,\n@@ -356,7 +356,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             start,\n             end: Some(end),\n             limits: RangeLimits::HalfOpen\n-        }) = higher::range(expr);\n+        }) = higher::Range::hir(expr);\n         if let Some(y) = y_plus_one(cx, end);\n         then {\n             let span = if expr.span.from_expansion() {\n@@ -401,7 +401,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n // inclusive range minus one: `x..=(y-1)`\n fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr);\n+        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::Range::hir(expr);\n         if let Some(y) = y_minus_one(cx, end);\n         then {\n             span_lint_and_then(\n@@ -438,8 +438,8 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     fn is_for_loop_arg(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         let mut cur_expr = expr;\n         while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n-            match higher::for_loop(parent_expr) {\n-                Some((_, args, _, _)) if args.hir_id == expr.hir_id => return true,\n+            match higher::ForLoop::hir(parent_expr) {\n+                Some(higher::ForLoop { arg, .. }) if arg.hir_id == expr.hir_id => return true,\n                 _ => cur_expr = parent_expr,\n             }\n         }\n@@ -455,7 +455,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n \n     if_chain! {\n-        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::Range::hir(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind();\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);"}, {"sha": "530b3396abef698fd0c16baee09116f18c35f28b", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -725,7 +725,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n         BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n             visit_op(lhs);\n             visit_op(rhs);\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "e153288aa58df6dce17331634af31b7bf75a36e1", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -212,14 +212,6 @@ fn check_final_expr<'tcx>(\n                     check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n                 }\n             },\n-            MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            } => {\n-                if let ExprKind::Block(ifblock, _) = arms[0].body.kind {\n-                    check_block_return(cx, ifblock);\n-                }\n-                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n-            },\n             _ => (),\n         },\n         ExprKind::DropTemps(expr) => check_final_expr(cx, expr, None, RetReplacement::Empty),"}, {"sha": "44d5ff0b63ad51a5fd2c014f44969d2858644df8", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -588,7 +588,7 @@ fn ident_difference_expr_with_base_location(\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n         | (While(_, _, _), While(_, _, _))\n         | (If(_, _, _), If(_, _, _))\n-        | (Let(_, _), Let(_, _))\n+        | (Let(_, _, _), Let(_, _, _))\n         | (Type(_, _), Type(_, _))\n         | (Cast(_, _), Cast(_, _))\n         | (Lit(_), Lit(_))"}, {"sha": "d6cf7190abb04959099378856509d1ad4cbe0ea0", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -67,7 +67,7 @@ impl EarlyLintPass for UnnestedOrPatterns {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if meets_msrv(self.msrv.as_ref(), &msrvs::OR_PATTERNS) {\n-            if let ast::ExprKind::Let(pat, _) = &e.kind {\n+            if let ast::ExprKind::Let(pat, _, _) = &e.kind {\n                 lint_unnested_or_patterns(cx, pat);\n             }\n         }"}, {"sha": "bffd9f3612b0a978ffb6426b9fc3932bfb728f87", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{differing_macro_contexts, usage::is_potentially_mutated};\n use if_chain::if_chain;\n@@ -160,11 +161,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         if in_external_macro(self.cx.tcx.sess, expr.span) {\n             return;\n         }\n-        if let ExprKind::If(cond, then, els) = &expr.kind {\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n-            if let Some(els) = els {\n-                self.visit_branch(cond, els, true);\n+            if let Some(else_inner) = r#else {\n+                self.visit_branch(cond, else_inner, true);\n             }\n         } else {\n             // find `unwrap[_err]()` calls:"}, {"sha": "f93d7782e2511bd0ad666ca1e2e6a08440c1dac7", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -208,6 +208,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match expr.kind {\n+            ExprKind::Let(pat, expr, _) => {\n+                let let_pat = self.next(\"pat\");\n+                let let_expr = self.next(\"expr\");\n+                println!(\"    Let(ref {}, ref {}, _) = {};\", let_pat, let_expr, current);\n+                self.current = let_expr;\n+                self.visit_expr(expr);\n+                self.current = let_pat;\n+                self.visit_pat(pat);\n+            },\n             ExprKind::Box(inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);"}, {"sha": "6bf216cec1670f1011e1806d653dfd48cd5af4ca", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -66,28 +66,6 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n         }\n     }\n-    // fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n-    // hir::TraitItem) {\n-    // if !has_attr(&item.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n-    // fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx\n-    // hir::Variant, _:\n-    // &hir::Generics) {\n-    // if !has_attr(&var.node.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n-    // fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx\n-    // hir::FieldDef) {\n-    // if !has_attr(&field.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(expr.hir_id)) {\n@@ -127,13 +105,6 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n         }\n     }\n-    // fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n-    // hir::ForeignItem) {\n-    // if !has_attr(&item.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n }\n \n fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n@@ -171,6 +142,10 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n+        hir::ExprKind::Let(ref pat, ref expr, _) => {\n+            print_pat(cx, pat, indent + 1);\n+            print_expr(cx, expr, indent + 1);\n+        },\n         hir::ExprKind::MethodCall(path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);"}, {"sha": "95a45fa937f11ab8d9a7f79fa4eae96016bad9d8", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -49,17 +49,17 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n             if let ty::Slice(..) = ty.kind();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n-            if let Some(vec_args) = higher::vec_macro(cx, addressee);\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, ref addressee) = expr.kind;\n+            if let Some(vec_args) = higher::VecArgs::hir(cx, addressee);\n             then {\n                 self.check_vec_macro(cx, &vec_args, mutability, expr.span);\n             }\n         }\n \n         // search for `for _ in vec![\u2026]`\n         if_chain! {\n-            if let Some((_, arg, _, _)) = higher::for_loop(expr);\n-            if let Some(vec_args) = higher::vec_macro(cx, arg);\n+            if let Some(higher::ForLoop { arg, .. }) = higher::ForLoop::hir(expr);\n+            if let Some(vec_args) = higher::VecArgs::hir(cx, arg);\n             if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`"}, {"sha": "7ea07a15aea51874457cee13b0319f4a8c9452db", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -158,7 +158,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n         (Lit(l), Lit(r)) => l.kind == r.kind,\n         (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n-        (Let(lp, le), Let(rp, re)) => eq_pat(lp, rp) && eq_expr(le, re),\n+        (Let(lp, le, _), Let(rp, re, _)) => eq_pat(lp, rp) && eq_expr(le, re),\n         (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),\n         (While(lc, lt, ll), While(rc, rt, rl)) => eq_label(ll, rl) && eq_expr(lc, rc) && eq_block(lt, rt),\n         (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {"}, {"sha": "29e2559fc6d603d45a05b8d0e91b142095f23f57", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -60,6 +60,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n         | ExprKind::MethodCall(..)\n         | ExprKind::Binary(..)\n         | ExprKind::Unary(..)\n+        | ExprKind::Let(..)\n         | ExprKind::Cast(..)\n         | ExprKind::Type(..)\n         | ExprKind::DropTemps(..)"}, {"sha": "29b698e56e3c0f9e9cfb2dd49444c8769e90ad31", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 363, "deletions": 144, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,148 +1,219 @@\n-//! This module contains functions for retrieve the original AST from lowered\n-//! `hir`.\n+//! This module contains functions that retrieves specifiec elements.\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_hir::{Block, BorrowKind, Expr, ExprKind, LoopSource, Node, Pat, StmtKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n-/// Represent a range akin to `ast::ExprKind::Range`.\n-#[derive(Debug, Copy, Clone)]\n-pub struct Range<'a> {\n-    /// The lower bound of the range, or `None` for ranges such as `..X`.\n-    pub start: Option<&'a hir::Expr<'a>>,\n-    /// The upper bound of the range, or `None` for ranges such as `X..`.\n-    pub end: Option<&'a hir::Expr<'a>>,\n-    /// Whether the interval is open or closed.\n-    pub limits: ast::RangeLimits,\n+/// The essential nodes of a desugared for loop as well as the entire span:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n+pub struct ForLoop<'tcx> {\n+    pub pat: &'tcx hir::Pat<'tcx>,\n+    pub arg: &'tcx hir::Expr<'tcx>,\n+    pub body: &'tcx hir::Expr<'tcx>,\n+    pub span: Span,\n }\n \n-/// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n-    /// Finds the field named `name` in the field. Always return `Some` for\n-    /// convenience.\n-    fn get_field<'c>(name: &str, fields: &'c [hir::ExprField<'_>]) -> Option<&'c hir::Expr<'c>> {\n-        let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n-\n-        Some(expr)\n+impl<'tcx> ForLoop<'tcx> {\n+    #[inline]\n+    pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+            if let Some(first_arm) = arms.get(0);\n+            if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n+            if let Some(first_arg) = iterargs.get(0);\n+            if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n+            if let hir::ExprKind::Loop(ref block, ..) = first_arm.body.kind;\n+            if block.expr.is_none();\n+            if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n+            if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n+            if let hir::StmtKind::Expr(ref body_expr) = body.kind;\n+            then {\n+                return Some(Self {\n+                    pat: &*local.pat,\n+                    arg: first_arg,\n+                    body: body_expr,\n+                    span: first_arm.span\n+                });\n+            }\n+        }\n+        None\n     }\n+}\n+\n+pub struct If<'hir> {\n+    pub cond: &'hir Expr<'hir>,\n+    pub r#else: Option<&'hir Expr<'hir>>,\n+    pub then: &'hir Expr<'hir>,\n+}\n \n-    match expr.kind {\n-        hir::ExprKind::Call(path, args)\n-            if matches!(\n-                path.kind,\n-                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n-            ) =>\n+impl<'hir> If<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(\n+            Expr {\n+                kind: ExprKind::DropTemps(cond),\n+                ..\n+            },\n+            then,\n+            r#else,\n+        ) = expr.kind\n         {\n-            Some(Range {\n-                start: Some(&args[0]),\n-                end: Some(&args[1]),\n-                limits: ast::RangeLimits::Closed,\n-            })\n-        },\n-        hir::ExprKind::Struct(path, fields, None) => match path {\n-            hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n-                start: None,\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::Closed,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            _ => None,\n-        },\n-        _ => None,\n+            Some(Self { cond, r#else, then })\n+        } else {\n+            None\n+        }\n     }\n }\n \n-/// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n-    // This will detect plain for-loops without an actual variable binding:\n-    //\n-    // ```\n-    // for x in some_vec {\n-    //     // do stuff\n-    // }\n-    // ```\n-    if_chain! {\n-        if let Some(expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        then {\n-            return true;\n+pub struct IfLet<'hir> {\n+    pub let_pat: &'hir Pat<'hir>,\n+    pub let_expr: &'hir Expr<'hir>,\n+    pub if_then: &'hir Expr<'hir>,\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> IfLet<'hir> {\n+    #[inline]\n+    pub fn ast(cx: &LateContext<'tcx>, expr: &Expr<'hir>) -> Option<Self> {\n+        let rslt = Self::hir(expr)?;\n+        Self::is_not_within_while_context(cx, expr)?;\n+        Some(rslt)\n+    }\n+\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(\n+            Expr {\n+                kind: ExprKind::Let(let_pat, let_expr, _),\n+                ..\n+            },\n+            if_then,\n+            if_else,\n+        ) = expr.kind\n+        {\n+            return Some(Self {\n+                let_pat,\n+                let_expr,\n+                if_then,\n+                if_else,\n+            });\n         }\n+        None\n     }\n \n-    // This detects a variable binding in for loop to avoid `let_unit_value`\n-    // lint (see issue #1964).\n-    //\n-    // ```\n-    // for _ in vec![()] {\n-    //     // anything\n-    // }\n-    // ```\n-    if let hir::LocalSource::ForLoopDesugar = local.source {\n-        return true;\n+    #[inline]\n+    fn is_not_within_while_context(cx: &LateContext<'tcx>, expr: &Expr<'hir>) -> Option<()> {\n+        let hir = cx.tcx.hir();\n+        let parent = hir.get_parent_node(expr.hir_id);\n+        let parent_parent = hir.get_parent_node(parent);\n+        let parent_parent_node = hir.get(parent_parent);\n+        if let Node::Expr(Expr {\n+            kind: ExprKind::Loop(_, _, LoopSource::While, _),\n+            ..\n+        }) = parent_parent_node\n+        {\n+            return None;\n+        }\n+        Some(())\n     }\n+}\n \n-    false\n+pub struct IfOrIfLet<'hir> {\n+    pub cond: &'hir Expr<'hir>,\n+    pub r#else: Option<&'hir Expr<'hir>>,\n+    pub then: &'hir Expr<'hir>,\n }\n \n-/// Recover the essential nodes of a desugared for loop as well as the entire span:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n-pub fn for_loop<'tcx>(\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n-    if_chain! {\n-        if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n-        if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(block, ..) = arms[0].body.kind;\n-        if block.expr.is_none();\n-        if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtKind::Local(local) = let_stmt.kind;\n-        if let hir::StmtKind::Expr(expr) = body.kind;\n-        then {\n-            return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n+impl<'hir> IfOrIfLet<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(cond, then, r#else) = expr.kind {\n+            if let ExprKind::DropTemps(new_cond) = cond.kind {\n+                return Some(Self {\n+                    cond: new_cond,\n+                    r#else,\n+                    then,\n+                });\n+            }\n+            if let ExprKind::Let(..) = cond.kind {\n+                return Some(Self { cond, r#else, then });\n+            }\n         }\n+        None\n     }\n-    None\n }\n \n-/// Recover the essential nodes of a desugared while loop:\n-/// `while cond { body }` becomes `(cond, body)`.\n-pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n-    if_chain! {\n-        if let hir::ExprKind::Loop(hir::Block { expr: Some(expr), .. }, _, hir::LoopSource::While, _) = &expr.kind;\n-        if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n-        if let hir::ExprKind::DropTemps(cond) = &cond.kind;\n-        if let [hir::Arm { body, .. }, ..] = &arms[..];\n-        then {\n-            return Some((cond, body));\n+/// Represent a range akin to `ast::ExprKind::Range`.\n+#[derive(Debug, Copy, Clone)]\n+pub struct Range<'a> {\n+    /// The lower bound of the range, or `None` for ranges such as `..X`.\n+    pub start: Option<&'a hir::Expr<'a>>,\n+    /// The upper bound of the range, or `None` for ranges such as `X..`.\n+    pub end: Option<&'a hir::Expr<'a>>,\n+    /// Whether the interval is open or closed.\n+    pub limits: ast::RangeLimits,\n+}\n+\n+impl<'a> Range<'a> {\n+    /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n+    pub fn hir(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n+        /// Finds the field named `name` in the field. Always return `Some` for\n+        /// convenience.\n+        fn get_field<'c>(name: &str, fields: &'c [hir::ExprField<'_>]) -> Option<&'c hir::Expr<'c>> {\n+            let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n+            Some(expr)\n+        }\n+\n+        match expr.kind {\n+            hir::ExprKind::Call(ref path, ref args)\n+                if matches!(\n+                    path.kind,\n+                    hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+                ) =>\n+            {\n+                Some(Range {\n+                    start: Some(&args[0]),\n+                    end: Some(&args[1]),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            },\n+            hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n+                    start: None,\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::Closed,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                _ => None,\n+            },\n+            _ => None,\n         }\n     }\n-    None\n }\n \n /// Represent the pre-expansion arguments of a `vec!` invocation.\n@@ -153,41 +224,157 @@ pub enum VecArgs<'a> {\n     Vec(&'a [hir::Expr<'a>]),\n }\n \n-/// Returns the arguments of the `vec!` macro if this expression was expanded\n-/// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n-    if_chain! {\n-        if let hir::ExprKind::Call(fun, args) = expr.kind;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n-        then {\n-            return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n-                // `vec![elem; size]` case\n-                Some(VecArgs::Repeat(&args[0], &args[1]))\n-            }\n-            else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n-                // `vec![a, b, c]` case\n-                if_chain! {\n-                    if let hir::ExprKind::Box(boxed) = args[0].kind;\n-                    if let hir::ExprKind::Array(args) = boxed.kind;\n-                    then {\n-                        return Some(VecArgs::Vec(&*args));\n-                    }\n+impl<'a> VecArgs<'a> {\n+    /// Returns the arguments of the `vec!` macro if this expression was expanded\n+    /// from `vec!`.\n+    pub fn hir(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) -> Option<VecArgs<'a>> {\n+        if_chain! {\n+            if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+            if is_expn_of(fun.span, \"vec\").is_some();\n+            if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+            then {\n+                return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+                    // `vec![elem; size]` case\n+                    Some(VecArgs::Repeat(&args[0], &args[1]))\n                 }\n+                else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+                    // `vec![a, b, c]` case\n+                    if_chain! {\n+                        if let hir::ExprKind::Box(ref boxed) = args[0].kind;\n+                        if let hir::ExprKind::Array(ref args) = boxed.kind;\n+                        then {\n+                            return Some(VecArgs::Vec(&*args));\n+                        }\n+                    }\n \n-                None\n+                    None\n+                }\n+                else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n+                    Some(VecArgs::Vec(&[]))\n+                }\n+                else {\n+                    None\n+                };\n             }\n-            else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n-                Some(VecArgs::Vec(&[]))\n+        }\n+\n+        None\n+    }\n+}\n+\n+pub struct While<'hir> {\n+    pub if_cond: &'hir Expr<'hir>,\n+    pub if_then: &'hir Expr<'hir>,\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> While<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::Loop(\n+            Block {\n+                expr:\n+                    Some(Expr {\n+                        kind:\n+                            ExprKind::If(\n+                                Expr {\n+                                    kind: ExprKind::DropTemps(if_cond),\n+                                    ..\n+                                },\n+                                if_then,\n+                                if_else_ref,\n+                            ),\n+                        ..\n+                    }),\n+                ..\n+            },\n+            _,\n+            LoopSource::While,\n+            _,\n+        ) = expr.kind\n+        {\n+            let if_else = *if_else_ref;\n+            return Some(Self {\n+                if_cond,\n+                if_then,\n+                if_else,\n+            });\n+        }\n+        None\n+    }\n+}\n+\n+pub struct WhileLet<'hir> {\n+    pub if_expr: &'hir Expr<'hir>,\n+    pub let_pat: &'hir Pat<'hir>,\n+    pub let_expr: &'hir Expr<'hir>,\n+    pub if_then: &'hir Expr<'hir>,\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> WhileLet<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::Loop(\n+            Block {\n+                expr: Some(if_expr), ..\n+            },\n+            _,\n+            LoopSource::While,\n+            _,\n+        ) = expr.kind\n+        {\n+            if let Expr {\n+                kind:\n+                    ExprKind::If(\n+                        Expr {\n+                            kind: ExprKind::Let(let_pat, let_expr, _),\n+                            ..\n+                        },\n+                        if_then,\n+                        if_else_ref,\n+                    ),\n+                ..\n+            } = if_expr\n+            {\n+                let if_else = *if_else_ref;\n+                return Some(Self {\n+                    if_expr,\n+                    let_pat,\n+                    let_expr,\n+                    if_then,\n+                    if_else,\n+                });\n             }\n-            else {\n-                None\n-            };\n         }\n+        None\n     }\n+}\n \n-    None\n+/// Converts a hir binary operator to the corresponding `ast` type.\n+#[must_use]\n+pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n+    match op {\n+        hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n+        hir::BinOpKind::Ge => ast::BinOpKind::Ge,\n+        hir::BinOpKind::Gt => ast::BinOpKind::Gt,\n+        hir::BinOpKind::Le => ast::BinOpKind::Le,\n+        hir::BinOpKind::Lt => ast::BinOpKind::Lt,\n+        hir::BinOpKind::Ne => ast::BinOpKind::Ne,\n+        hir::BinOpKind::Or => ast::BinOpKind::Or,\n+        hir::BinOpKind::Add => ast::BinOpKind::Add,\n+        hir::BinOpKind::And => ast::BinOpKind::And,\n+        hir::BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+        hir::BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+        hir::BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+        hir::BinOpKind::Div => ast::BinOpKind::Div,\n+        hir::BinOpKind::Mul => ast::BinOpKind::Mul,\n+        hir::BinOpKind::Rem => ast::BinOpKind::Rem,\n+        hir::BinOpKind::Shl => ast::BinOpKind::Shl,\n+        hir::BinOpKind::Shr => ast::BinOpKind::Shr,\n+        hir::BinOpKind::Sub => ast::BinOpKind::Sub,\n+    }\n }\n \n /// Extract args from an assert-like macro.\n@@ -218,8 +405,8 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n             if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n-                    if let ExprKind::If(clause, _, _)  = matchexpr.kind;\n-                    if let ExprKind::Unary(UnOp::Not, condition) = clause.kind;\n+                    if let Some(If { cond, .. }) = If::hir(matchexpr);\n+                    if let ExprKind::Unary(UnOp::Not, condition) = cond.kind;\n                     then {\n                         return Some(vec![condition]);\n                     }\n@@ -345,3 +532,35 @@ impl FormatArgsExpn<'tcx> {\n         }\n     }\n }\n+\n+/// Checks if a `let` statement is from a `for` loop desugaring.\n+pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n+    // This will detect plain for-loops without an actual variable binding:\n+    //\n+    // ```\n+    // for x in some_vec {\n+    //     // do stuff\n+    // }\n+    // ```\n+    if_chain! {\n+        if let Some(ref expr) = local.init;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    // This detects a variable binding in for loop to avoid `let_unit_value`\n+    // lint (see issue #1964).\n+    //\n+    // ```\n+    // for _ in vec![()] {\n+    //     // anything\n+    // }\n+    // ```\n+    if let hir::LocalSource::ForLoopDesugar = local.source {\n+        return true;\n+    }\n+\n+    false\n+}"}, {"sha": "a44f2df2fd631e9793dd022cc50517a48caa7e07", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -232,6 +232,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n+            (&ExprKind::Let(ref lp, ref le, _), &ExprKind::Let(ref rp, ref re, _)) => {\n+                self.eq_pat(lp, rp) && self.eq_expr(le, re)\n+            },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n@@ -665,6 +668,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                 }\n             },\n+            ExprKind::Let(ref pat, ref expr, _) => {\n+                self.hash_expr(expr);\n+                self.hash_pat(pat);\n+            },\n             ExprKind::LlvmInlineAsm(..) | ExprKind::Err => {},\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);"}, {"sha": "82bfce8fe789ed454ed5dadcc6828967d5443d35", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -961,17 +961,6 @@ pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     let map = tcx.hir();\n     let mut iter = map.parent_iter(expr.hir_id);\n     match iter.next() {\n-        Some((arm_id, Node::Arm(..))) => matches!(\n-            iter.next(),\n-            Some((\n-                _,\n-                Node::Expr(Expr {\n-                    kind: ExprKind::Match(_, [_, else_arm], MatchSource::IfLetDesugar { .. }),\n-                    ..\n-                })\n-            ))\n-            if else_arm.hir_id == arm_id\n-        ),\n         Some((\n             _,\n             Node::Expr(Expr {\n@@ -1370,15 +1359,15 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     let mut conds = Vec::new();\n     let mut blocks: Vec<&Block<'_>> = Vec::new();\n \n-    while let ExprKind::If(cond, then_expr, ref else_expr) = expr.kind {\n-        conds.push(cond);\n-        if let ExprKind::Block(block, _) = then_expr.kind {\n+    while let Some(higher::IfOrIfLet { cond, then, r#else }) = higher::IfOrIfLet::hir(expr) {\n+        conds.push(&*cond);\n+        if let ExprKind::Block(ref block, _) = then.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n-        if let Some(else_expr) = *else_expr {\n+        if let Some(ref else_expr) = r#else {\n             expr = else_expr;\n         } else {\n             break;"}, {"sha": "3b494e1fc8535b3430c0c69fdf88b843c9b015af", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -116,7 +116,7 @@ impl<'a> Sugg<'a> {\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n-        if let Some(range) = higher::range(expr) {\n+        if let Some(range) = higher::Range::hir(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,\n@@ -128,6 +128,7 @@ impl<'a> Sugg<'a> {\n             hir::ExprKind::AddrOf(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::If(..)\n+            | hir::ExprKind::Let(..)\n             | hir::ExprKind::Closure(..)\n             | hir::ExprKind::Unary(..)\n             | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),"}, {"sha": "1653de9a6f26d132e449cb48bcbff58f9fdd19d6", "filename": "src/tools/clippy/tests/ui/author/if.stdout", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fif.stdout?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -12,7 +12,8 @@ if_chain! {\n     if let ExprKind::Lit(ref lit1) = right.kind;\n     if let LitKind::Int(2, _) = lit1.node;\n     if block.expr.is_none();\n-    if let ExprKind::Lit(ref lit2) = cond.kind;\n+    if let ExprKind::DropTemps(ref expr) = cond.kind;\n+    if let ExprKind::Lit(ref lit2) = expr.kind;\n     if let LitKind::Bool(true) = lit2.node;\n     if let ExprKind::Block(ref block1) = then.kind;\n     if block1.stmts.len() == 1;"}, {"sha": "f96917f58334429d4da29db842201b2f97a86bf7", "filename": "src/tools/clippy/tests/ui/collapsible_match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -35,7 +35,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:25:9\n    |\n LL | /         if let Some(n) = val {\n@@ -51,7 +51,7 @@ LL |     if let Ok(val) = res_opt {\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:32:9\n    |\n LL | /         if let Some(n) = val {\n@@ -87,7 +87,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:52:13\n    |\n LL | /             if let Some(n) = val {\n@@ -121,7 +121,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:72:13\n    |\n LL | /             if let Some(n) = val {"}, {"sha": "85fa421032191505e9d76edd1cb2111d9c4bbce9", "filename": "src/tools/clippy/tests/ui/crashes/ice-7410.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-7410.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-7410.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-7410.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -4,6 +4,7 @@\n \n #![feature(lang_items, start, libc)]\n #![no_std]\n+#![allow(clippy::if_same_then_else)]\n #![allow(clippy::redundant_pattern_matching)]\n \n use core::panic::PanicInfo;"}, {"sha": "553c840f9b081420197e772d72f0bff2fd15dc4c", "filename": "src/tools/clippy/tests/ui/crashes/issues_loop_mut_cond.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,3 +1,4 @@\n+#![allow(clippy::blocks_in_if_conditions)]\n #![allow(dead_code)]\n \n /// Issue: https://github.com/rust-lang/rust-clippy/issues/2596"}, {"sha": "e518b2677b7bf351d73e6941e236641433177d0a", "filename": "src/tools/clippy/tests/ui/infinite_loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finfinite_loop.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,3 +1,5 @@\n+#![allow(clippy::blocks_in_if_conditions)]\n+\n fn fn_val(i: i32) -> i32 {\n     unimplemented!()\n }"}, {"sha": "2736753c14b6eccfc33acd4575f63efca21f89e5", "filename": "src/tools/clippy/tests/ui/infinite_loop.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finfinite_loop.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,5 +1,5 @@\n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:21:11\n+  --> $DIR/infinite_loop.rs:23:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -8,71 +8,71 @@ LL |     while y < 10 {\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:26:11\n+  --> $DIR/infinite_loop.rs:28:11\n    |\n LL |     while y < 10 && x < 3 {\n    |           ^^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:33:11\n+  --> $DIR/infinite_loop.rs:35:11\n    |\n LL |     while !cond {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:77:11\n+  --> $DIR/infinite_loop.rs:79:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:82:11\n+  --> $DIR/infinite_loop.rs:84:11\n    |\n LL |     while i < 3 && j > 0 {\n    |           ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:86:11\n+  --> $DIR/infinite_loop.rs:88:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:101:11\n+  --> $DIR/infinite_loop.rs:103:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:106:11\n+  --> $DIR/infinite_loop.rs:108:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:172:15\n+  --> $DIR/infinite_loop.rs:174:15\n    |\n LL |         while self.count < n {\n    |               ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:180:11\n+  --> $DIR/infinite_loop.rs:182:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -82,7 +82,7 @@ LL |     while y < 10 {\n    = help: rewrite it as `if cond { loop { } }`\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:187:11\n+  --> $DIR/infinite_loop.rs:189:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^"}, {"sha": "c84e31ea482a48e8fefc32c8d43912acb2e3b874", "filename": "src/tools/clippy/tests/ui/match_overlapping_arm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -2,6 +2,7 @@\n #![feature(half_open_range_patterns)]\n #![warn(clippy::match_overlapping_arm)]\n #![allow(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n \n /// Tests for match_overlapping_arm\n "}, {"sha": "359fa49f51be73735e65231454cc6bda7fbbbe89", "filename": "src/tools/clippy/tests/ui/match_overlapping_arm.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.stderr?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -1,60 +1,60 @@\n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:12:9\n+  --> $DIR/match_overlapping_arm.rs:13:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^\n    |\n    = note: `-D clippy::match-overlapping-arm` implied by `-D warnings`\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:13:9\n+  --> $DIR/match_overlapping_arm.rs:14:9\n    |\n LL |         0..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:18:9\n+  --> $DIR/match_overlapping_arm.rs:19:9\n    |\n LL |         0..=5 => println!(\"0 ... 5\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:20:9\n+  --> $DIR/match_overlapping_arm.rs:21:9\n    |\n LL |         FOO..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:55:9\n+  --> $DIR/match_overlapping_arm.rs:56:9\n    |\n LL |         0..11 => println!(\"0 .. 11\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:56:9\n+  --> $DIR/match_overlapping_arm.rs:57:9\n    |\n LL |         0..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:80:9\n+  --> $DIR/match_overlapping_arm.rs:81:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:79:9\n+  --> $DIR/match_overlapping_arm.rs:80:9\n    |\n LL |         5..14 => println!(\"5 .. 14\"),\n    |         ^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:85:9\n+  --> $DIR/match_overlapping_arm.rs:86:9\n    |\n LL |         0..7 => println!(\"0 .. 7\"),\n    |         ^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:86:9\n+  --> $DIR/match_overlapping_arm.rs:87:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^"}, {"sha": "975af6c02947af48b9308f7d72908e7b79f8402b", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa9937a768bf13e5f7bd0ee6dd8579403b39058/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=6aa9937a768bf13e5f7bd0ee6dd8579403b39058", "patch": "@@ -616,7 +616,7 @@ struct ControlFlow<'a> {\n \n fn extract_pats_and_cond(expr: &ast::Expr) -> (Option<&ast::Pat>, &ast::Expr) {\n     match expr.kind {\n-        ast::ExprKind::Let(ref pat, ref cond) => (Some(pat), cond),\n+        ast::ExprKind::Let(ref pat, ref cond, _) => (Some(pat), cond),\n         _ => (None, expr),\n     }\n }"}]}