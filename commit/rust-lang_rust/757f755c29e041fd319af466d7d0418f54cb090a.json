{"sha": "757f755c29e041fd319af466d7d0418f54cb090a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1N2Y3NTVjMjllMDQxZmQzMTlhZjQ2NmQ3ZDA0MThmNTRjYjA5MGE=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-22T06:46:29Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "SSR: Match paths based on what they resolve to\n\nAlso render template paths appropriately for their context.", "tree": {"sha": "30d94206c5009730855a2ceaebdf364963358928", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30d94206c5009730855a2ceaebdf364963358928"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/757f755c29e041fd319af466d7d0418f54cb090a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/757f755c29e041fd319af466d7d0418f54cb090a", "html_url": "https://github.com/rust-lang/rust/commit/757f755c29e041fd319af466d7d0418f54cb090a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/757f755c29e041fd319af466d7d0418f54cb090a/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3975952601888d9f77e466c12e8e389748984b33", "url": "https://api.github.com/repos/rust-lang/rust/commits/3975952601888d9f77e466c12e8e389748984b33", "html_url": "https://github.com/rust-lang/rust/commit/3975952601888d9f77e466c12e8e389748984b33"}], "stats": {"total": 543, "additions": 482, "deletions": 61}, "files": [{"sha": "2f40bac08b1c64d0330ed30f80cb93700c78062c", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -11,6 +11,16 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // A `$<name>` placeholder in the search pattern will match any AST node and `$<name>` will reference it in the replacement.\n // Within a macro call, a placeholder will match up until whatever token follows the placeholder.\n //\n+// All paths in both the search pattern and the replacement template must resolve in the context\n+// in which this command is invoked. Paths in the search pattern will then match the code if they\n+// resolve to the same item, even if they're written differently. For example if we invoke the\n+// command in the module `foo` with a pattern of `Bar`, then code in the parent module that refers\n+// to `foo::Bar` will match.\n+//\n+// Paths in the replacement template will be rendered appropriately for the context in which the\n+// replacement occurs. For example if our replacement template is `foo::Bar` and we match some\n+// code in the `foo` module, we'll insert just `Bar`.\n+//\n // Placeholders may be given constraints by writing them as `${<name>:<constraint1>:<constraint2>...}`.\n //\n // Supported constraints:\n@@ -47,7 +57,7 @@ pub fn parse_search_replace(\n ) -> Result<Vec<SourceFileEdit>, SsrError> {\n     let rule: SsrRule = rule.parse()?;\n     let mut match_finder = MatchFinder::in_context(db, position);\n-    match_finder.add_rule(rule);\n+    match_finder.add_rule(rule)?;\n     if parse_only {\n         return Ok(Vec::new());\n     }"}, {"sha": "286619f59a622de08f8433d74518d2289ef147ef", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -7,6 +7,7 @@ mod matching;\n mod nester;\n mod parsing;\n mod replacing;\n+mod resolving;\n mod search;\n #[macro_use]\n mod errors;\n@@ -21,6 +22,7 @@ use hir::Semantics;\n use ra_db::{FileId, FilePosition, FileRange};\n use ra_ide_db::source_change::SourceFileEdit;\n use ra_syntax::{ast, AstNode, SyntaxNode, TextRange};\n+use resolving::ResolvedRule;\n use rustc_hash::FxHashMap;\n \n // A structured search replace rule. Create by calling `parse` on a str.\n@@ -48,18 +50,34 @@ pub struct SsrMatches {\n pub struct MatchFinder<'db> {\n     /// Our source of information about the user's code.\n     sema: Semantics<'db, ra_ide_db::RootDatabase>,\n-    rules: Vec<parsing::ParsedRule>,\n+    rules: Vec<ResolvedRule>,\n+    scope: hir::SemanticsScope<'db>,\n+    hygiene: hir::Hygiene,\n }\n \n impl<'db> MatchFinder<'db> {\n     /// Constructs a new instance where names will be looked up as if they appeared at\n     /// `lookup_context`.\n     pub fn in_context(\n         db: &'db ra_ide_db::RootDatabase,\n-        _lookup_context: FilePosition,\n+        lookup_context: FilePosition,\n     ) -> MatchFinder<'db> {\n-        // FIXME: Use lookup_context\n-        MatchFinder { sema: Semantics::new(db), rules: Vec::new() }\n+        let sema = Semantics::new(db);\n+        let file = sema.parse(lookup_context.file_id);\n+        // Find a node at the requested position, falling back to the whole file.\n+        let node = file\n+            .syntax()\n+            .token_at_offset(lookup_context.offset)\n+            .left_biased()\n+            .map(|token| token.parent())\n+            .unwrap_or_else(|| file.syntax().clone());\n+        let scope = sema.scope(&node);\n+        MatchFinder {\n+            sema: Semantics::new(db),\n+            rules: Vec::new(),\n+            scope,\n+            hygiene: hir::Hygiene::new(db, lookup_context.file_id.into()),\n+        }\n     }\n \n     /// Constructs an instance using the start of the first file in `db` as the lookup context.\n@@ -84,8 +102,16 @@ impl<'db> MatchFinder<'db> {\n     /// Adds a rule to be applied. The order in which rules are added matters. Earlier rules take\n     /// precedence. If a node is matched by an earlier rule, then later rules won't be permitted to\n     /// match to it.\n-    pub fn add_rule(&mut self, rule: SsrRule) {\n-        self.add_parsed_rules(rule.parsed_rules);\n+    pub fn add_rule(&mut self, rule: SsrRule) -> Result<(), SsrError> {\n+        for parsed_rule in rule.parsed_rules {\n+            self.rules.push(ResolvedRule::new(\n+                parsed_rule,\n+                &self.scope,\n+                &self.hygiene,\n+                self.rules.len(),\n+            )?);\n+        }\n+        Ok(())\n     }\n \n     /// Finds matches for all added rules and returns edits for all found matches.\n@@ -110,8 +136,16 @@ impl<'db> MatchFinder<'db> {\n \n     /// Adds a search pattern. For use if you intend to only call `find_matches_in_file`. If you\n     /// intend to do replacement, use `add_rule` instead.\n-    pub fn add_search_pattern(&mut self, pattern: SsrPattern) {\n-        self.add_parsed_rules(pattern.parsed_rules);\n+    pub fn add_search_pattern(&mut self, pattern: SsrPattern) -> Result<(), SsrError> {\n+        for parsed_rule in pattern.parsed_rules {\n+            self.rules.push(ResolvedRule::new(\n+                parsed_rule,\n+                &self.scope,\n+                &self.hygiene,\n+                self.rules.len(),\n+            )?);\n+        }\n+        Ok(())\n     }\n \n     /// Returns matches for all added rules.\n@@ -149,13 +183,6 @@ impl<'db> MatchFinder<'db> {\n         res\n     }\n \n-    fn add_parsed_rules(&mut self, parsed_rules: Vec<parsing::ParsedRule>) {\n-        for mut parsed_rule in parsed_rules {\n-            parsed_rule.index = self.rules.len();\n-            self.rules.push(parsed_rule);\n-        }\n-    }\n-\n     fn output_debug_for_nodes_at_range(\n         &self,\n         node: &SyntaxNode,\n@@ -175,7 +202,7 @@ impl<'db> MatchFinder<'db> {\n                     // we get lots of noise. If at some point we add support for restricting rules\n                     // to a particular kind of thing (e.g. only match type references), then we can\n                     // relax this.\n-                    if rule.pattern.kind() != node.kind() {\n+                    if rule.pattern.node.kind() != node.kind() {\n                         continue;\n                     }\n                     out.push(MatchDebugInfo {\n@@ -185,7 +212,7 @@ impl<'db> MatchFinder<'db> {\n                                     \"Match failed, but no reason was given\".to_owned()\n                                 }),\n                             }),\n-                        pattern: rule.pattern.clone(),\n+                        pattern: rule.pattern.node.clone(),\n                         node: node.clone(),\n                     });\n                 }"}, {"sha": "f3cc60c29d2fcfd83cc6453258e66343cdf7af8d", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 99, "deletions": 7, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -2,7 +2,8 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Constraint, NodeKind, ParsedRule, Placeholder},\n+    parsing::{Constraint, NodeKind, Placeholder},\n+    resolving::{ResolvedPattern, ResolvedRule},\n     SsrMatches,\n };\n use hir::Semantics;\n@@ -51,6 +52,8 @@ pub struct Match {\n     pub(crate) rule_index: usize,\n     /// The depth of matched_node.\n     pub(crate) depth: usize,\n+    // Each path in the template rendered for the module in which the match was found.\n+    pub(crate) rendered_template_paths: FxHashMap<SyntaxNode, hir::ModPath>,\n }\n \n /// Represents a `$var` in an SSR query.\n@@ -86,7 +89,7 @@ pub(crate) struct MatchFailed {\n /// parent module, we don't populate nested matches.\n pub(crate) fn get_match(\n     debug_active: bool,\n-    rule: &ParsedRule,\n+    rule: &ResolvedRule,\n     code: &SyntaxNode,\n     restrict_range: &Option<FileRange>,\n     sema: &Semantics<ra_ide_db::RootDatabase>,\n@@ -102,7 +105,7 @@ struct Matcher<'db, 'sema> {\n     /// If any placeholders come from anywhere outside of this range, then the match will be\n     /// rejected.\n     restrict_range: Option<FileRange>,\n-    rule: &'sema ParsedRule,\n+    rule: &'sema ResolvedRule,\n }\n \n /// Which phase of matching we're currently performing. We do two phases because most attempted\n@@ -117,14 +120,14 @@ enum Phase<'a> {\n \n impl<'db, 'sema> Matcher<'db, 'sema> {\n     fn try_match(\n-        rule: &ParsedRule,\n+        rule: &ResolvedRule,\n         code: &SyntaxNode,\n         restrict_range: &Option<FileRange>,\n         sema: &'sema Semantics<'db, ra_ide_db::RootDatabase>,\n     ) -> Result<Match, MatchFailed> {\n         let match_state = Matcher { sema, restrict_range: restrict_range.clone(), rule };\n         // First pass at matching, where we check that node types and idents match.\n-        match_state.attempt_match_node(&mut Phase::First, &rule.pattern, code)?;\n+        match_state.attempt_match_node(&mut Phase::First, &rule.pattern.node, code)?;\n         match_state.validate_range(&sema.original_range(code))?;\n         let mut the_match = Match {\n             range: sema.original_range(code),\n@@ -133,11 +136,19 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n             ignored_comments: Vec::new(),\n             rule_index: rule.index,\n             depth: 0,\n+            rendered_template_paths: FxHashMap::default(),\n         };\n         // Second matching pass, where we record placeholder matches, ignored comments and maybe do\n         // any other more expensive checks that we didn't want to do on the first pass.\n-        match_state.attempt_match_node(&mut Phase::Second(&mut the_match), &rule.pattern, code)?;\n+        match_state.attempt_match_node(\n+            &mut Phase::Second(&mut the_match),\n+            &rule.pattern.node,\n+            code,\n+        )?;\n         the_match.depth = sema.ancestors_with_macros(the_match.matched_node.clone()).count();\n+        if let Some(template) = &rule.template {\n+            the_match.render_template_paths(template, sema)?;\n+        }\n         Ok(the_match)\n     }\n \n@@ -195,6 +206,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 self.attempt_match_record_field_list(phase, pattern, code)\n             }\n             SyntaxKind::TOKEN_TREE => self.attempt_match_token_tree(phase, pattern, code),\n+            SyntaxKind::PATH => self.attempt_match_path(phase, pattern, code),\n             _ => self.attempt_match_node_children(phase, pattern, code),\n         }\n     }\n@@ -311,6 +323,64 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         Ok(())\n     }\n \n+    /// Paths are matched based on whether they refer to the same thing, even if they're written\n+    /// differently.\n+    fn attempt_match_path(\n+        &self,\n+        phase: &mut Phase,\n+        pattern: &SyntaxNode,\n+        code: &SyntaxNode,\n+    ) -> Result<(), MatchFailed> {\n+        if let Some(pattern_resolved) = self.rule.pattern.resolved_paths.get(pattern) {\n+            let pattern_path = ast::Path::cast(pattern.clone()).unwrap();\n+            let code_path = ast::Path::cast(code.clone()).unwrap();\n+            if let (Some(pattern_segment), Some(code_segment)) =\n+                (pattern_path.segment(), code_path.segment())\n+            {\n+                // Match everything within the segment except for the name-ref, which is handled\n+                // separately via comparing what the path resolves to below.\n+                self.attempt_match_opt(\n+                    phase,\n+                    pattern_segment.type_arg_list(),\n+                    code_segment.type_arg_list(),\n+                )?;\n+                self.attempt_match_opt(\n+                    phase,\n+                    pattern_segment.param_list(),\n+                    code_segment.param_list(),\n+                )?;\n+            }\n+            if matches!(phase, Phase::Second(_)) {\n+                let resolution = self\n+                    .sema\n+                    .resolve_path(&code_path)\n+                    .ok_or_else(|| match_error!(\"Failed to resolve path `{}`\", code.text()))?;\n+                if pattern_resolved.resolution != resolution {\n+                    fail_match!(\"Pattern had path `{}` code had `{}`\", pattern.text(), code.text());\n+                }\n+            }\n+        } else {\n+            return self.attempt_match_node_children(phase, pattern, code);\n+        }\n+        Ok(())\n+    }\n+\n+    fn attempt_match_opt<T: AstNode>(\n+        &self,\n+        phase: &mut Phase,\n+        pattern: Option<T>,\n+        code: Option<T>,\n+    ) -> Result<(), MatchFailed> {\n+        match (pattern, code) {\n+            (Some(p), Some(c)) => self.attempt_match_node(phase, &p.syntax(), &c.syntax()),\n+            (None, None) => Ok(()),\n+            (Some(p), None) => fail_match!(\"Pattern `{}` had nothing to match\", p.syntax().text()),\n+            (None, Some(c)) => {\n+                fail_match!(\"Nothing in pattern to match code `{}`\", c.syntax().text())\n+            }\n+        }\n+    }\n+\n     /// We want to allow the records to match in any order, so we have special matching logic for\n     /// them.\n     fn attempt_match_record_field_list(\n@@ -449,6 +519,28 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n     }\n }\n \n+impl Match {\n+    fn render_template_paths(\n+        &mut self,\n+        template: &ResolvedPattern,\n+        sema: &Semantics<ra_ide_db::RootDatabase>,\n+    ) -> Result<(), MatchFailed> {\n+        let module = sema\n+            .scope(&self.matched_node)\n+            .module()\n+            .ok_or_else(|| match_error!(\"Matched node isn't in a module\"))?;\n+        for (path, resolved_path) in &template.resolved_paths {\n+            if let hir::PathResolution::Def(module_def) = resolved_path.resolution {\n+                let mod_path = module.find_use_path(sema.db, module_def).ok_or_else(|| {\n+                    match_error!(\"Failed to render template path `{}` at match location\")\n+                })?;\n+                self.rendered_template_paths.insert(path.clone(), mod_path);\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl Phase<'_> {\n     fn next_non_trivial(&mut self, code_it: &mut SyntaxElementChildren) -> Option<SyntaxElement> {\n         loop {\n@@ -578,7 +670,7 @@ mod tests {\n \n         let (db, position) = crate::tests::single_file(input);\n         let mut match_finder = MatchFinder::in_context(&db, position);\n-        match_finder.add_rule(rule);\n+        match_finder.add_rule(rule).unwrap();\n         let matches = match_finder.matches();\n         assert_eq!(matches.matches.len(), 1);\n         assert_eq!(matches.matches[0].matched_node.text(), \"foo(1+2)\");"}, {"sha": "2d6f4e514f0d5039b360892a19d414dcc9d6bca5", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -7,7 +7,7 @@\n \n use crate::errors::bail;\n use crate::{SsrError, SsrPattern, SsrRule};\n-use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken, T};\n+use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, T};\n use rustc_hash::{FxHashMap, FxHashSet};\n use std::str::FromStr;\n \n@@ -16,7 +16,6 @@ pub(crate) struct ParsedRule {\n     pub(crate) placeholders_by_stand_in: FxHashMap<SmolStr, Placeholder>,\n     pub(crate) pattern: SyntaxNode,\n     pub(crate) template: Option<SyntaxNode>,\n-    pub(crate) index: usize,\n }\n \n #[derive(Debug)]\n@@ -93,16 +92,11 @@ impl RuleBuilder {\n                 placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n                 pattern: pattern.syntax().clone(),\n                 template: Some(template.syntax().clone()),\n-                // For now we give the rule an index of 0. It's given a proper index when the rule\n-                // is added to the SsrMatcher. Using an Option<usize>, instead would be slightly\n-                // more correct, but we delete this field from ParsedRule in a subsequent commit.\n-                index: 0,\n             }),\n             (Ok(pattern), None) => self.rules.push(ParsedRule {\n                 placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n                 pattern: pattern.syntax().clone(),\n                 template: None,\n-                index: 0,\n             }),\n             _ => {}\n         }\n@@ -171,15 +165,6 @@ impl RawPattern {\n     }\n }\n \n-impl ParsedRule {\n-    pub(crate) fn get_placeholder(&self, token: &SyntaxToken) -> Option<&Placeholder> {\n-        if token.kind() != SyntaxKind::IDENT {\n-            return None;\n-        }\n-        self.placeholders_by_stand_in.get(token.text())\n-    }\n-}\n-\n impl FromStr for SsrPattern {\n     type Err = SsrError;\n "}, {"sha": "4b3f5509c3bdd1461f568e32f453629f30593d26", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -1,9 +1,9 @@\n //! Code for applying replacement templates for matches that have previously been found.\n \n use crate::matching::Var;\n-use crate::{parsing::ParsedRule, Match, SsrMatches};\n-use ra_syntax::ast::AstToken;\n-use ra_syntax::{SyntaxElement, SyntaxNode, SyntaxToken, TextSize};\n+use crate::{resolving::ResolvedRule, Match, SsrMatches};\n+use ra_syntax::ast::{self, AstToken};\n+use ra_syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextSize};\n use ra_text_edit::TextEdit;\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n@@ -12,7 +12,7 @@ use ra_text_edit::TextEdit;\n pub(crate) fn matches_to_edit(\n     matches: &SsrMatches,\n     file_src: &str,\n-    rules: &[ParsedRule],\n+    rules: &[ResolvedRule],\n ) -> TextEdit {\n     matches_to_edit_at_offset(matches, file_src, 0.into(), rules)\n }\n@@ -21,7 +21,7 @@ fn matches_to_edit_at_offset(\n     matches: &SsrMatches,\n     file_src: &str,\n     relative_start: TextSize,\n-    rules: &[ParsedRule],\n+    rules: &[ResolvedRule],\n ) -> TextEdit {\n     let mut edit_builder = ra_text_edit::TextEditBuilder::default();\n     for m in &matches.matches {\n@@ -36,19 +36,19 @@ fn matches_to_edit_at_offset(\n struct ReplacementRenderer<'a> {\n     match_info: &'a Match,\n     file_src: &'a str,\n-    rules: &'a [ParsedRule],\n-    rule: &'a ParsedRule,\n+    rules: &'a [ResolvedRule],\n+    rule: &'a ResolvedRule,\n }\n \n-fn render_replace(match_info: &Match, file_src: &str, rules: &[ParsedRule]) -> String {\n+fn render_replace(match_info: &Match, file_src: &str, rules: &[ResolvedRule]) -> String {\n     let mut out = String::new();\n     let rule = &rules[match_info.rule_index];\n     let template = rule\n         .template\n         .as_ref()\n         .expect(\"You called MatchFinder::edits after calling MatchFinder::add_search_pattern\");\n     let renderer = ReplacementRenderer { match_info, file_src, rules, rule };\n-    renderer.render_node_children(&template, &mut out);\n+    renderer.render_node(&template.node, &mut out);\n     for comment in &match_info.ignored_comments {\n         out.push_str(&comment.syntax().to_string());\n     }\n@@ -68,11 +68,31 @@ impl ReplacementRenderer<'_> {\n                 self.render_token(&token, out);\n             }\n             SyntaxElement::Node(child_node) => {\n-                self.render_node_children(&child_node, out);\n+                self.render_node(&child_node, out);\n             }\n         }\n     }\n \n+    fn render_node(&self, node: &SyntaxNode, out: &mut String) {\n+        use ra_syntax::ast::AstNode;\n+        if let Some(mod_path) = self.match_info.rendered_template_paths.get(&node) {\n+            out.push_str(&mod_path.to_string());\n+            // Emit everything except for the segment's name-ref, since we already effectively\n+            // emitted that as part of `mod_path`.\n+            if let Some(path) = ast::Path::cast(node.clone()) {\n+                if let Some(segment) = path.segment() {\n+                    for node_or_token in segment.syntax().children_with_tokens() {\n+                        if node_or_token.kind() != SyntaxKind::NAME_REF {\n+                            self.render_node_or_token(&node_or_token, out);\n+                        }\n+                    }\n+                }\n+            }\n+        } else {\n+            self.render_node_children(&node, out);\n+        }\n+    }\n+\n     fn render_token(&self, token: &SyntaxToken, out: &mut String) {\n         if let Some(placeholder) = self.rule.get_placeholder(&token) {\n             if let Some(placeholder_value) ="}, {"sha": "e9d05211176bde66d36126acac75955785dccd77", "filename": "crates/ra_ssr/src/resolving.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -0,0 +1,153 @@\n+//! This module is responsible for resolving paths within rules.\n+\n+use crate::errors::error;\n+use crate::{parsing, SsrError};\n+use parsing::Placeholder;\n+use ra_syntax::{ast, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken};\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use test_utils::mark;\n+\n+pub(crate) struct ResolvedRule {\n+    pub(crate) pattern: ResolvedPattern,\n+    pub(crate) template: Option<ResolvedPattern>,\n+    pub(crate) index: usize,\n+}\n+\n+pub(crate) struct ResolvedPattern {\n+    pub(crate) placeholders_by_stand_in: FxHashMap<SmolStr, parsing::Placeholder>,\n+    pub(crate) node: SyntaxNode,\n+    // Paths in `node` that we've resolved.\n+    pub(crate) resolved_paths: FxHashMap<SyntaxNode, ResolvedPath>,\n+}\n+\n+pub(crate) struct ResolvedPath {\n+    pub(crate) resolution: hir::PathResolution,\n+}\n+\n+impl ResolvedRule {\n+    pub(crate) fn new(\n+        rule: parsing::ParsedRule,\n+        scope: &hir::SemanticsScope,\n+        hygiene: &hir::Hygiene,\n+        index: usize,\n+    ) -> Result<ResolvedRule, SsrError> {\n+        let resolver =\n+            Resolver { scope, hygiene, placeholders_by_stand_in: rule.placeholders_by_stand_in };\n+        let resolved_template = if let Some(template) = rule.template {\n+            Some(resolver.resolve_pattern_tree(template)?)\n+        } else {\n+            None\n+        };\n+        Ok(ResolvedRule {\n+            pattern: resolver.resolve_pattern_tree(rule.pattern)?,\n+            template: resolved_template,\n+            index,\n+        })\n+    }\n+\n+    pub(crate) fn get_placeholder(&self, token: &SyntaxToken) -> Option<&Placeholder> {\n+        if token.kind() != SyntaxKind::IDENT {\n+            return None;\n+        }\n+        self.pattern.placeholders_by_stand_in.get(token.text())\n+    }\n+}\n+\n+struct Resolver<'a, 'db> {\n+    scope: &'a hir::SemanticsScope<'db>,\n+    hygiene: &'a hir::Hygiene,\n+    placeholders_by_stand_in: FxHashMap<SmolStr, parsing::Placeholder>,\n+}\n+\n+impl Resolver<'_, '_> {\n+    fn resolve_pattern_tree(&self, pattern: SyntaxNode) -> Result<ResolvedPattern, SsrError> {\n+        let mut resolved_paths = FxHashMap::default();\n+        self.resolve(pattern.clone(), &mut resolved_paths)?;\n+        Ok(ResolvedPattern {\n+            node: pattern,\n+            resolved_paths,\n+            placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n+        })\n+    }\n+\n+    fn resolve(\n+        &self,\n+        node: SyntaxNode,\n+        resolved_paths: &mut FxHashMap<SyntaxNode, ResolvedPath>,\n+    ) -> Result<(), SsrError> {\n+        use ra_syntax::ast::AstNode;\n+        if let Some(path) = ast::Path::cast(node.clone()) {\n+            // Check if this is an appropriate place in the path to resolve. If the path is\n+            // something like `a::B::<i32>::c` then we want to resolve `a::B`. If the path contains\n+            // a placeholder. e.g. `a::$b::c` then we want to resolve `a`.\n+            if !path_contains_type_arguments(path.qualifier())\n+                && !self.path_contains_placeholder(&path)\n+            {\n+                let resolution = self\n+                    .resolve_path(&path)\n+                    .ok_or_else(|| error!(\"Failed to resolve path `{}`\", node.text()))?;\n+                resolved_paths.insert(node, ResolvedPath { resolution });\n+                return Ok(());\n+            }\n+        }\n+        for node in node.children() {\n+            self.resolve(node, resolved_paths)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Returns whether `path` contains a placeholder, but ignores any placeholders within type\n+    /// arguments.\n+    fn path_contains_placeholder(&self, path: &ast::Path) -> bool {\n+        if let Some(segment) = path.segment() {\n+            if let Some(name_ref) = segment.name_ref() {\n+                if self.placeholders_by_stand_in.contains_key(name_ref.text()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        if let Some(qualifier) = path.qualifier() {\n+            return self.path_contains_placeholder(&qualifier);\n+        }\n+        false\n+    }\n+\n+    fn resolve_path(&self, path: &ast::Path) -> Option<hir::PathResolution> {\n+        let hir_path = hir::Path::from_src(path.clone(), self.hygiene)?;\n+        // First try resolving the whole path. This will work for things like\n+        // `std::collections::HashMap`, but will fail for things like\n+        // `std::collections::HashMap::new`.\n+        if let Some(resolution) = self.scope.resolve_hir_path(&hir_path) {\n+            return Some(resolution);\n+        }\n+        // Resolution failed, try resolving the qualifier (e.g. `std::collections::HashMap` and if\n+        // that succeeds, then iterate through the candidates on the resolved type with the provided\n+        // name.\n+        let resolved_qualifier = self.scope.resolve_hir_path_qualifier(&hir_path.qualifier()?)?;\n+        if let hir::PathResolution::Def(hir::ModuleDef::Adt(adt)) = resolved_qualifier {\n+            adt.ty(self.scope.db).iterate_path_candidates(\n+                self.scope.db,\n+                self.scope.module()?.krate(),\n+                &FxHashSet::default(),\n+                Some(hir_path.segments().last()?.name),\n+                |_ty, assoc_item| Some(hir::PathResolution::AssocItem(assoc_item)),\n+            )\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Returns whether `path` or any of its qualifiers contains type arguments.\n+fn path_contains_type_arguments(path: Option<ast::Path>) -> bool {\n+    if let Some(path) = path {\n+        if let Some(segment) = path.segment() {\n+            if segment.type_arg_list().is_some() {\n+                mark::hit!(type_arguments_within_path);\n+                return true;\n+            }\n+        }\n+        return path_contains_type_arguments(path.qualifier());\n+    }\n+    false\n+}"}, {"sha": "ccc2d544ab8e6cfafcf333b451199aa8e117cbd1", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -1,20 +1,20 @@\n //! Searching for matches.\n \n-use crate::{matching, parsing::ParsedRule, Match, MatchFinder};\n+use crate::{matching, resolving::ResolvedRule, Match, MatchFinder};\n use ra_db::FileRange;\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n impl<'db> MatchFinder<'db> {\n     /// Adds all matches for `rule` to `matches_out`. Matches may overlap in ways that make\n     /// replacement impossible, so further processing is required in order to properly nest matches\n     /// and remove overlapping matches. This is done in the `nesting` module.\n-    pub(crate) fn find_matches_for_rule(&self, rule: &ParsedRule, matches_out: &mut Vec<Match>) {\n+    pub(crate) fn find_matches_for_rule(&self, rule: &ResolvedRule, matches_out: &mut Vec<Match>) {\n         // FIXME: Use resolved paths in the pattern to find places to search instead of always\n         // scanning every node.\n         self.slow_scan(rule, matches_out);\n     }\n \n-    fn slow_scan(&self, rule: &ParsedRule, matches_out: &mut Vec<Match>) {\n+    fn slow_scan(&self, rule: &ResolvedRule, matches_out: &mut Vec<Match>) {\n         use ra_db::SourceDatabaseExt;\n         use ra_ide_db::symbol_index::SymbolsDatabase;\n         for &root in self.sema.db.local_roots().iter() {\n@@ -30,7 +30,7 @@ impl<'db> MatchFinder<'db> {\n     fn slow_scan_node(\n         &self,\n         code: &SyntaxNode,\n-        rule: &ParsedRule,\n+        rule: &ResolvedRule,\n         restrict_range: &Option<FileRange>,\n         matches_out: &mut Vec<Match>,\n     ) {"}, {"sha": "33742dc8e10d0be95cb944084861578eae984d35", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 138, "deletions": 4, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -85,7 +85,7 @@ fn assert_ssr_transforms(rules: &[&str], input: &str, expected: Expect) {\n     let mut match_finder = MatchFinder::in_context(&db, position);\n     for rule in rules {\n         let rule: SsrRule = rule.parse().unwrap();\n-        match_finder.add_rule(rule);\n+        match_finder.add_rule(rule).unwrap();\n     }\n     let edits = match_finder.edits();\n     if edits.is_empty() {\n@@ -114,7 +114,7 @@ fn print_match_debug_info(match_finder: &MatchFinder, file_id: FileId, snippet:\n fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n     let (db, position) = single_file(code);\n     let mut match_finder = MatchFinder::in_context(&db, position);\n-    match_finder.add_search_pattern(pattern.parse().unwrap());\n+    match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let matched_strings: Vec<String> =\n         match_finder.matches().flattened().matches.iter().map(|m| m.matched_text()).collect();\n     if matched_strings != expected && !expected.is_empty() {\n@@ -126,7 +126,7 @@ fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n fn assert_no_match(pattern: &str, code: &str) {\n     let (db, position) = single_file(code);\n     let mut match_finder = MatchFinder::in_context(&db, position);\n-    match_finder.add_search_pattern(pattern.parse().unwrap());\n+    match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let matches = match_finder.matches().flattened().matches;\n     if !matches.is_empty() {\n         print_match_debug_info(&match_finder, position.file_id, &matches[0].matched_text());\n@@ -137,7 +137,7 @@ fn assert_no_match(pattern: &str, code: &str) {\n fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expected_reason: &str) {\n     let (db, position) = single_file(code);\n     let mut match_finder = MatchFinder::in_context(&db, position);\n-    match_finder.add_search_pattern(pattern.parse().unwrap());\n+    match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let mut reasons = Vec::new();\n     for d in match_finder.debug_where_text_equal(position.file_id, snippet) {\n         if let Some(reason) = d.match_failure_reason() {\n@@ -350,6 +350,60 @@ fn match_pattern() {\n     assert_matches(\"Some($a)\", \"struct Some(); fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n }\n \n+// If our pattern has a full path, e.g. a::b::c() and the code has c(), but c resolves to\n+// a::b::c, then we should match.\n+#[test]\n+fn match_fully_qualified_fn_path() {\n+    let code = r#\"\n+        mod a {\n+            pub mod b {\n+                pub fn c(_: i32) {}\n+            }\n+        }\n+        use a::b::c;\n+        fn f1() {\n+            c(42);\n+        }\n+        \"#;\n+    assert_matches(\"a::b::c($a)\", code, &[\"c(42)\"]);\n+}\n+\n+#[test]\n+fn match_resolved_type_name() {\n+    let code = r#\"\n+        mod m1 {\n+            pub mod m2 {\n+                pub trait Foo<T> {}\n+            }\n+        }\n+        mod m3 {\n+            trait Foo<T> {}\n+            fn f1(f: Option<&dyn Foo<bool>>) {}\n+        }\n+        mod m4 {\n+            use crate::m1::m2::Foo;\n+            fn f1(f: Option<&dyn Foo<i32>>) {}\n+        }\n+        \"#;\n+    assert_matches(\"m1::m2::Foo<$t>\", code, &[\"Foo<i32>\"]);\n+}\n+\n+#[test]\n+fn type_arguments_within_path() {\n+    mark::check!(type_arguments_within_path);\n+    let code = r#\"\n+        mod foo {\n+            pub struct Bar<T> {t: T}\n+            impl<T> Bar<T> {\n+                pub fn baz() {}\n+            }\n+        }\n+        fn f1() {foo::Bar::<i32>::baz();}\n+        \"#;\n+    assert_no_match(\"foo::Bar::<i64>::baz()\", code);\n+    assert_matches(\"foo::Bar::<i32>::baz()\", code, &[\"foo::Bar::<i32>::baz()\"]);\n+}\n+\n #[test]\n fn literal_constraint() {\n     mark::check!(literal_constraint);\n@@ -482,6 +536,86 @@ fn replace_associated_function_call() {\n     );\n }\n \n+#[test]\n+fn replace_path_in_different_contexts() {\n+    // Note the <|> inside module a::b which marks the point where the rule is interpreted. We\n+    // replace foo with bar, but both need different path qualifiers in different contexts. In f4,\n+    // foo is unqualified because of a use statement, however the replacement needs to be fully\n+    // qualified.\n+    assert_ssr_transform(\n+        \"c::foo() ==>> c::bar()\",\n+        r#\"\n+            mod a {\n+                pub mod b {<|>\n+                    pub mod c {\n+                        pub fn foo() {}\n+                        pub fn bar() {}\n+                        fn f1() { foo() }\n+                    }\n+                    fn f2() { c::foo() }\n+                }\n+                fn f3() { b::c::foo() }\n+            }\n+            use a::b::c::foo;\n+            fn f4() { foo() }\n+            \"#,\n+        expect![[r#\"\n+            mod a {\n+                pub mod b {\n+                    pub mod c {\n+                        pub fn foo() {}\n+                        pub fn bar() {}\n+                        fn f1() { bar() }\n+                    }\n+                    fn f2() { c::bar() }\n+                }\n+                fn f3() { b::c::bar() }\n+            }\n+            use a::b::c::foo;\n+            fn f4() { a::b::c::bar() }\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_associated_function_with_generics() {\n+    assert_ssr_transform(\n+        \"c::Foo::<$a>::new() ==>> d::Bar::<$a>::default()\",\n+        r#\"\n+            mod c {\n+                pub struct Foo<T> {v: T}\n+                impl<T> Foo<T> { pub fn new() {} }\n+                fn f1() {\n+                    Foo::<i32>::new();\n+                }\n+            }\n+            mod d {\n+                pub struct Bar<T> {v: T}\n+                impl<T> Bar<T> { pub fn default() {} }\n+                fn f1() {\n+                    super::c::Foo::<i32>::new();\n+                }\n+            }\n+            \"#,\n+        expect![[r#\"\n+            mod c {\n+                pub struct Foo<T> {v: T}\n+                impl<T> Foo<T> { pub fn new() {} }\n+                fn f1() {\n+                    crate::d::Bar::<i32>::default();\n+                }\n+            }\n+            mod d {\n+                pub struct Bar<T> {v: T}\n+                impl<T> Bar<T> { pub fn default() {} }\n+                fn f1() {\n+                    Bar::<i32>::default();\n+                }\n+            }\n+            \"#]],\n+    );\n+}\n+\n #[test]\n fn replace_type() {\n     assert_ssr_transform("}, {"sha": "194bec008d362273d373cd9cccd2ccde220de29b", "filename": "crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f755c29e041fd319af466d7d0418f54cb090a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=757f755c29e041fd319af466d7d0418f54cb090a", "patch": "@@ -9,7 +9,7 @@ pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n     let db = host.raw_database();\n     let mut match_finder = MatchFinder::at_first_file(db)?;\n     for rule in rules {\n-        match_finder.add_rule(rule);\n+        match_finder.add_rule(rule)?;\n     }\n     let edits = match_finder.edits();\n     for edit in edits {\n@@ -32,7 +32,7 @@ pub fn search_for_patterns(patterns: Vec<SsrPattern>, debug_snippet: Option<Stri\n     let db = host.raw_database();\n     let mut match_finder = MatchFinder::at_first_file(db)?;\n     for pattern in patterns {\n-        match_finder.add_search_pattern(pattern);\n+        match_finder.add_search_pattern(pattern)?;\n     }\n     if let Some(debug_snippet) = &debug_snippet {\n         for &root in db.local_roots().iter() {"}]}