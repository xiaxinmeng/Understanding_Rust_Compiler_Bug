{"sha": "d975060de6c944ca12ce5205fbc9fc7726948ae1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NzUwNjBkZTZjOTQ0Y2ExMmNlNTIwNWZiYzlmYzc3MjY5NDhhZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-26T05:46:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-26T05:46:41Z"}, "message": "auto merge of #11146 : sfackler/rust/cleanup, r=alexcrichton\n\nI also deleted a test which has apparently not been needed for a very long time.", "tree": {"sha": "e59749e123abfb6249de88c74f23200b4e80d8cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e59749e123abfb6249de88c74f23200b4e80d8cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d975060de6c944ca12ce5205fbc9fc7726948ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d975060de6c944ca12ce5205fbc9fc7726948ae1", "html_url": "https://github.com/rust-lang/rust/commit/d975060de6c944ca12ce5205fbc9fc7726948ae1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d975060de6c944ca12ce5205fbc9fc7726948ae1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cab6af55ff64148de1cda707f7d4c85f062f1ff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab6af55ff64148de1cda707f7d4c85f062f1ff4", "html_url": "https://github.com/rust-lang/rust/commit/cab6af55ff64148de1cda707f7d4c85f062f1ff4"}, {"sha": "c7cf5dc270ff8636199345fcff457f1443e839b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7cf5dc270ff8636199345fcff457f1443e839b5", "html_url": "https://github.com/rust-lang/rust/commit/c7cf5dc270ff8636199345fcff457f1443e839b5"}], "stats": {"total": 431, "additions": 176, "deletions": 255}, "files": [{"sha": "37114660826dc619c8171a8406fe3a6b0ba9847f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -838,7 +838,7 @@ fn link_rlib(sess: Session,\n              out_filename: &Path) -> Archive {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n \n-    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n+    for &(ref l, kind) in sess.cstore.get_used_libraries().iter() {\n         match kind {\n             cstore::NativeStatic => {\n                 a.add_native_library(l.as_slice());\n@@ -912,9 +912,9 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n     let mut a = link_rlib(sess, None, obj_filename, out_filename);\n     a.add_native_library(\"morestack\");\n \n-    let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n+    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n-        let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+        let name = sess.cstore.get_crate_data(cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\", name));\n@@ -1072,7 +1072,7 @@ fn link_args(sess: Session,\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     args.push_all(sess.opts.linker_args);\n-    for arg in cstore::get_used_link_args(sess.cstore).iter() {\n+    for arg in sess.cstore.get_used_link_args().iter() {\n         args.push(arg.clone());\n     }\n     return args;\n@@ -1101,7 +1101,7 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n         args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n \n-    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n+    for &(ref l, kind) in sess.cstore.get_used_libraries().iter() {\n         match kind {\n             cstore::NativeUnknown | cstore::NativeStatic => {\n                 args.push(\"-l\" + *l);\n@@ -1143,7 +1143,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n         // all dynamic libaries require dynamic dependencies (see above), so\n         // it's satisfactory to include either all static libraries or all\n         // dynamic libraries.\n-        let crates = cstore::get_used_crates(cstore, cstore::RequireStatic);\n+        let crates = cstore.get_used_crates(cstore::RequireStatic);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n             for (cnum, path) in crates.move_iter() {\n                 let cratepath = path.unwrap();\n@@ -1163,7 +1163,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                 // If we're not doing LTO, then our job is simply to just link\n                 // against the archive.\n                 if sess.lto() {\n-                    let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+                    let name = sess.cstore.get_crate_data(cnum).name;\n                     time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n                          (), |()| {\n                         let dst = tmpdir.join(cratepath.filename().unwrap());\n@@ -1196,13 +1196,13 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     //   this case is the fallback\n     // * If an executable is being created, and one of the inputs is missing as\n     //   a static library, then this is the fallback case.\n-    let crates = cstore::get_used_crates(cstore, cstore::RequireDynamic);\n+    let crates = cstore.get_used_crates(cstore::RequireDynamic);\n     for &(cnum, ref path) in crates.iter() {\n         let cratepath = match *path {\n             Some(ref p) => p.clone(),\n             None => {\n                 sess.err(format!(\"could not find dynamic library for: `{}`\",\n-                                 cstore::get_crate_data(sess.cstore, cnum).name));\n+                                 sess.cstore.get_crate_data(cnum).name));\n                 return\n             }\n         };\n@@ -1235,7 +1235,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n // also be resolved in the target crate.\n fn add_upstream_native_libraries(args: &mut ~[~str], sess: Session) {\n     let cstore = sess.cstore;\n-    cstore::iter_crate_data(cstore, |cnum, _| {\n+    cstore.iter_crate_data(|cnum, _| {\n         let libs = csearch::get_native_libraries(cstore, cnum);\n         for &(kind, ref lib) in libs.iter() {\n             match kind {"}, {"sha": "697b2a6686b6541b53f7dfcebcd84bb5479e4b93", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -33,9 +33,9 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n-    let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n+    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for (cnum, path) in crates.move_iter() {\n-        let name = cstore::get_crate_data(sess.cstore, cnum).name;\n+        let name = sess.cstore.get_crate_data(cnum).name;\n         let path = match path {\n             Some(p) => p,\n             None => {"}, {"sha": "43267a08a1440139b0b170605fff964ace746ee2", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -41,7 +41,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n \n     let sysroot = sess.filesearch.sysroot();\n     let output = out_filename;\n-    let libs = cstore::get_used_crates(sess.cstore, cstore::RequireDynamic);\n+    let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n     let libs = libs.move_iter().filter_map(|(_, l)| l.map(|p| p.clone())).collect();\n     // We don't currently rpath extern libraries, but we know\n     // where rustrt is and we know every rust program needs it"}, {"sha": "530f90c6bfb86174031e01f932921e78d018f713", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -18,7 +18,8 @@ use front;\n use lib::llvm::llvm;\n use lib::llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n-use metadata::{creader, cstore, filesearch};\n+use metadata::{creader, filesearch};\n+use metadata::cstore::CStore;\n use metadata;\n use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n@@ -853,7 +854,7 @@ pub fn build_session_(sopts: @session::options,\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n-    let cstore = @mut cstore::mk_cstore(token::get_ident_interner());\n+    let cstore = @mut CStore::new(token::get_ident_interner());\n     let filesearch = filesearch::mk_filesearch(\n         &sopts.maybe_sysroot,\n         sopts.target_triple,"}, {"sha": "efa28b9b6bdd65d6f71eaa84797f0bf8227b7920", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -114,7 +114,7 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n     for a in c.attrs.iter().filter(|m| \"link_args\" == m.name()) {\n         match a.value_str() {\n           Some(ref linkarg) => {\n-            cstore::add_used_link_args(cstore, *linkarg);\n+            cstore.add_used_link_args(*linkarg);\n           }\n           None => {/* fallthrough */ }\n         }\n@@ -149,7 +149,7 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n                                    version,\n                                    @\"\",\n                                    i.span);\n-          cstore::add_extern_mod_stmt_cnum(e.sess.cstore, id, cnum);\n+          e.sess.cstore.add_extern_mod_stmt_cnum(id, cnum);\n       }\n       _ => ()\n   }\n@@ -170,7 +170,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n             for m in link_args.iter() {\n                 match m.value_str() {\n                     Some(linkarg) => {\n-                        cstore::add_used_link_args(cstore, linkarg);\n+                        cstore.add_used_link_args(linkarg);\n                     }\n                     None => { /* fallthrough */ }\n                 }\n@@ -222,7 +222,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n                         if n.is_empty() {\n                             e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n                         } else {\n-                            cstore::add_used_library(cstore, n.to_owned(), kind);\n+                            cstore.add_used_library(n.to_owned(), kind);\n                         }\n                     }\n                     None => {}\n@@ -296,8 +296,8 @@ fn resolve_crate(e: @mut Env,\n         };\n \n         let cstore = e.sess.cstore;\n-        cstore::set_crate_data(cstore, cnum, cmeta);\n-        cstore::add_used_crate_source(cstore, cstore::CrateSource {\n+        cstore.set_crate_data(cnum, cmeta);\n+        cstore.add_used_crate_source(cstore::CrateSource {\n             dylib: dylib,\n             rlib: rlib,\n             cnum: cnum,"}, {"sha": "ea8ad1d73d23f6c084c6cee852df9870275dab72", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -31,13 +31,13 @@ pub struct StaticMethodInfo {\n }\n \n pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::DefId) -> ~str {\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data();\n+    let cdata = cstore.get_crate_data(def.crate).data();\n     return decoder::get_symbol(cdata, def.node);\n }\n \n pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::DefId)\n                          -> uint {\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data();\n+    let cdata = cstore.get_crate_data(def.crate).data();\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n@@ -46,7 +46,7 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::CrateNum,\n                       f: |ast::NodeId, uint| -> bool)\n                       -> bool {\n-    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n \n@@ -56,9 +56,9 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n                           callback: |decoder::DefLike,\n                                      ast::Ident,\n                                      ast::visibility|) {\n-    let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n+    let crate_data = cstore.get_crate_data(def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n+        cstore.get_crate_data(cnum)\n     };\n     decoder::each_child_of_item(cstore.intr,\n                                 crate_data,\n@@ -73,9 +73,9 @@ pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                     callback: |decoder::DefLike,\n                                                ast::Ident,\n                                                ast::visibility|) {\n-    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    let crate_data = cstore.get_crate_data(cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n+        cstore.get_crate_data(cnum)\n     };\n     decoder::each_top_level_item_of_crate(cstore.intr,\n                                           crate_data,\n@@ -85,7 +85,7 @@ pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n \n pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ast_map::path {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n@@ -107,109 +107,109 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n                           decode_inlined_item: decoder::decode_inlined_item)\n                        -> found_ast {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n                       -> ~[@ty::VariantInfo] {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n-    let cdata = cstore::get_crate_data(tcx.cstore, impl_def_id.crate);\n+    let cdata = tcx.cstore.get_crate_data(impl_def_id.crate);\n     decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n-    let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n+    let cdata = tcx.cstore.get_crate_data(def.crate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n \n pub fn get_method_name_and_explicit_self(cstore: @mut cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::explicit_self_)\n {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n                                 def: ast::DefId) -> ~[ast::DefId] {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n pub fn get_item_variances(cstore: @mut cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_item_variances(cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::DefId)\n                                -> ~[@ty::Method] {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<~[StaticMethodInfo]> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |~[@ast::MetaItem]|) {\n-    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: @mut cstore::CStore,\n                          def: ast::DefId)\n                       -> ~[ty::field_ty] {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n pub fn get_type(tcx: ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, class_id.crate);\n+    let cdata = cstore.get_crate_data(class_id.crate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     debug!(\"Looking up {:?}\", class_id);\n     let class_doc = expect(tcx.diag,\n@@ -235,58 +235,58 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n pub fn get_impl_trait(tcx: ty::ctxt,\n                       def: ast::DefId) -> Option<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n     let cstore = tcx.cstore;\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n pub fn get_impl_method(cstore: @mut cstore::CStore,\n                        def: ast::DefId,\n                        mname: ast::Ident)\n                     -> Option<ast::DefId> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n pub fn get_item_visibility(cstore: @mut cstore::CStore,\n                            def_id: ast::DefId)\n                         -> ast::visibility {\n-    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::get_item_visibility(cdata, def_id.node)\n }\n \n pub fn get_native_libraries(cstore: @mut cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> ~[(cstore::NativeLibaryKind, ~str)] {\n-    let cdata = cstore::get_crate_data(cstore, crate_num);\n+    let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(cdata)\n }\n \n pub fn each_impl(cstore: @mut cstore::CStore,\n                  crate_num: ast::CrateNum,\n                  callback: |ast::DefId|) {\n-    let cdata = cstore::get_crate_data(cstore, crate_num);\n+    let cdata = cstore.get_crate_data(crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n-    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n-    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n }\n \n@@ -297,7 +297,7 @@ pub fn get_trait_of_method(cstore: @mut cstore::CStore,\n                            def_id: ast::DefId,\n                            tcx: ty::ctxt)\n                            -> Option<ast::DefId> {\n-    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)\n }\n "}, {"sha": "5972555d69c996f1185232d9beb3c0c13cfcbba2", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 101, "deletions": 108, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -12,8 +12,6 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-\n-use metadata::cstore;\n use metadata::decoder;\n use metadata::loader;\n \n@@ -73,104 +71,126 @@ pub struct CStore {\n // Map from NodeId's of local extern mod statements to crate numbers\n type extern_mod_crate_map = HashMap<ast::NodeId, ast::CrateNum>;\n \n-pub fn mk_cstore(intr: @ident_interner) -> CStore {\n-    return CStore {\n-        metas: HashMap::new(),\n-        extern_mod_crate_map: HashMap::new(),\n-        used_crate_sources: ~[],\n-        used_libraries: ~[],\n-        used_link_args: ~[],\n-        intr: intr\n-    };\n-}\n+impl CStore {\n+    pub fn new(intr: @ident_interner) -> CStore {\n+        CStore {\n+            metas: HashMap::new(),\n+            extern_mod_crate_map: HashMap::new(),\n+            used_crate_sources: ~[],\n+            used_libraries: ~[],\n+            used_link_args: ~[],\n+            intr: intr\n+        }\n+    }\n \n-pub fn get_crate_data(cstore: &CStore, cnum: ast::CrateNum)\n-                   -> @crate_metadata {\n-    return *cstore.metas.get(&cnum);\n-}\n+    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n+        *self.metas.get(&cnum)\n+    }\n \n-pub fn get_crate_hash(cstore: &CStore, cnum: ast::CrateNum) -> @str {\n-    let cdata = get_crate_data(cstore, cnum);\n-    decoder::get_crate_hash(cdata.data())\n-}\n+    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> @str {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_crate_hash(cdata.data())\n+    }\n \n-pub fn get_crate_vers(cstore: &CStore, cnum: ast::CrateNum) -> @str {\n-    let cdata = get_crate_data(cstore, cnum);\n-    decoder::get_crate_vers(cdata.data())\n-}\n+    pub fn get_crate_vers(&self, cnum: ast::CrateNum) -> @str {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_crate_vers(cdata.data())\n+    }\n \n-pub fn set_crate_data(cstore: &mut CStore,\n-                      cnum: ast::CrateNum,\n-                      data: @crate_metadata) {\n-    cstore.metas.insert(cnum, data);\n-}\n+    pub fn set_crate_data(&mut self, cnum: ast::CrateNum, data: @crate_metadata) {\n+        self.metas.insert(cnum, data);\n+    }\n \n-pub fn have_crate_data(cstore: &CStore, cnum: ast::CrateNum) -> bool {\n-    cstore.metas.contains_key(&cnum)\n-}\n+    pub fn have_crate_data(&self, cnum: ast::CrateNum) -> bool {\n+        self.metas.contains_key(&cnum)\n+    }\n \n-pub fn iter_crate_data(cstore: &CStore, i: |ast::CrateNum, @crate_metadata|) {\n-    for (&k, &v) in cstore.metas.iter() {\n-        i(k, v);\n+    pub fn iter_crate_data(&self, i: |ast::CrateNum, @crate_metadata|) {\n+        for (&k, &v) in self.metas.iter() {\n+            i(k, v);\n+        }\n     }\n-}\n \n-pub fn add_used_crate_source(cstore: &mut CStore, src: CrateSource) {\n-    if !cstore.used_crate_sources.contains(&src) {\n-        cstore.used_crate_sources.push(src);\n+    pub fn add_used_crate_source(&mut self, src: CrateSource) {\n+        if !self.used_crate_sources.contains(&src) {\n+            self.used_crate_sources.push(src);\n+        }\n     }\n-}\n \n-pub fn get_used_crate_sources<'a>(cstore: &'a CStore) -> &'a [CrateSource] {\n-    cstore.used_crate_sources.as_slice()\n-}\n+    pub fn get_used_crate_sources<'a>(&'a self) -> &'a [CrateSource] {\n+        self.used_crate_sources.as_slice()\n+    }\n \n-pub fn get_used_crates(cstore: &CStore, prefer: LinkagePreference)\n-    -> ~[(ast::CrateNum, Option<Path>)]\n-{\n-    let mut ret = ~[];\n-    for src in cstore.used_crate_sources.iter() {\n-        ret.push((src.cnum, match prefer {\n-            RequireDynamic => src.dylib.clone(),\n-            RequireStatic => src.rlib.clone(),\n-        }));\n-    }\n-    return ret;\n-}\n+    pub fn get_used_crates(&self, prefer: LinkagePreference)\n+                           -> ~[(ast::CrateNum, Option<Path>)] {\n+        self.used_crate_sources.iter()\n+            .map(|src| (src.cnum, match prefer {\n+                RequireDynamic => src.dylib.clone(),\n+                RequireStatic => src.rlib.clone(),\n+            }))\n+            .collect()\n+    }\n+\n+    pub fn add_used_library(&mut self, lib: ~str, kind: NativeLibaryKind) -> bool {\n+        assert!(!lib.is_empty());\n+        if self.used_libraries.iter().any(|&(ref x, _)| x == &lib) {\n+            return false;\n+        }\n+        self.used_libraries.push((lib, kind));\n+        true\n+    }\n \n-pub fn add_used_library(cstore: &mut CStore,\n-                        lib: ~str, kind: NativeLibaryKind) -> bool {\n-    assert!(!lib.is_empty());\n+    pub fn get_used_libraries<'a>(&'a self) -> &'a [(~str, NativeLibaryKind)] {\n+        self.used_libraries.as_slice()\n+    }\n \n-    if cstore.used_libraries.iter().any(|&(ref x, _)| x == &lib) { return false; }\n-    cstore.used_libraries.push((lib, kind));\n-    true\n-}\n+    pub fn add_used_link_args(&mut self, args: &str) {\n+        for s in args.split(' ') {\n+            self.used_link_args.push(s.to_owned());\n+        }\n+    }\n \n-pub fn get_used_libraries<'a>(cstore: &'a CStore) -> &'a [(~str, NativeLibaryKind)] {\n-    cstore.used_libraries.as_slice()\n-}\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a [~str] {\n+        self.used_link_args.as_slice()\n+    }\n \n-pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    for s in args.split(' ') {\n-        cstore.used_link_args.push(s.to_owned());\n+    pub fn add_extern_mod_stmt_cnum(&mut self,\n+                                    emod_id: ast::NodeId,\n+                                    cnum: ast::CrateNum) {\n+        self.extern_mod_crate_map.insert(emod_id, cnum);\n     }\n-}\n \n-pub fn get_used_link_args<'a>(cstore: &'a CStore) -> &'a [~str] {\n-    cstore.used_link_args.as_slice()\n-}\n+    pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n+                                     -> Option<ast::CrateNum> {\n+        self.extern_mod_crate_map.find(&emod_id).map(|x| *x)\n+    }\n \n-pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n-                                emod_id: ast::NodeId,\n-                                cnum: ast::CrateNum) {\n-    cstore.extern_mod_crate_map.insert(emod_id, cnum);\n-}\n+    // returns hashes of crates directly used by this crate. Hashes are sorted by\n+    // (crate name, crate version, crate hash) in lexicographic order (not semver)\n+    pub fn get_dep_hashes(&self) -> ~[@str] {\n+        let mut result = ~[];\n+\n+        for (_, &cnum) in self.extern_mod_crate_map.iter() {\n+            let cdata = self.get_crate_data(cnum);\n+            let hash = decoder::get_crate_hash(cdata.data());\n+            let vers = decoder::get_crate_vers(cdata.data());\n+            debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n+            result.push(crate_hash {\n+                name: cdata.name,\n+                vers: vers,\n+                hash: hash\n+            });\n+        }\n \n-pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n-                                 emod_id: ast::NodeId)\n-                       -> Option<ast::CrateNum> {\n-    cstore.extern_mod_crate_map.find(&emod_id).map(|x| *x)\n+        result.sort();\n+\n+        debug!(\"sorted:\");\n+        for x in result.iter() {\n+            debug!(\"  hash[{}]: {}\", x.name, x.hash);\n+        }\n+\n+        result.map(|ch| ch.hash)\n+    }\n }\n \n #[deriving(Clone, TotalEq, TotalOrd)]\n@@ -180,33 +200,6 @@ struct crate_hash {\n     hash: @str,\n }\n \n-// returns hashes of crates directly used by this crate. Hashes are sorted by\n-// (crate name, crate version, crate hash) in lexicographic order (not semver)\n-pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n-    let mut result = ~[];\n-\n-    for (_, &cnum) in cstore.extern_mod_crate_map.iter() {\n-        let cdata = cstore::get_crate_data(cstore, cnum);\n-        let hash = decoder::get_crate_hash(cdata.data());\n-        let vers = decoder::get_crate_vers(cdata.data());\n-        debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n-        result.push(crate_hash {\n-            name: cdata.name,\n-            vers: vers,\n-            hash: hash\n-        });\n-    }\n-\n-    result.sort();\n-\n-    debug!(\"sorted:\");\n-    for x in result.iter() {\n-        debug!(\"  hash[{}]: {}\", x.name, x.hash);\n-    }\n-\n-    result.map(|ch| ch.hash)\n-}\n-\n impl crate_metadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n }"}, {"sha": "c331c71ac9ee168b206fe36931fcc5cc35a87bfc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1522,7 +1522,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n-        cstore::iter_crate_data(cstore, |key, val| {\n+        cstore.iter_crate_data(|key, val| {\n             let dep = decoder::CrateDep {cnum: key,\n                        name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data()),\n@@ -1588,7 +1588,7 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_native_libraries);\n \n-    for &(ref lib, kind) in cstore::get_used_libraries(ecx.cstore).iter() {\n+    for &(ref lib, kind) in ecx.cstore.get_used_libraries().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {"}, {"sha": "87ae74321a17387347dd535c73e48d6fbe840e13", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -22,7 +22,6 @@\n \n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n-use metadata::cstore::iter_crate_data;\n use middle::ty::{BuiltinBound, BoundFreeze, BoundPod, BoundSend, BoundSized};\n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -165,7 +164,7 @@ impl LanguageItemCollector {\n \n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n-        iter_crate_data(crate_store, |crate_number, _crate_metadata| {\n+        crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n                 let def_id = ast::DefId { crate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);"}, {"sha": "1fb6e53d925e48413b9731361d571fee32b2d830", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -10,12 +10,7 @@\n \n \n use driver::session::Session;\n-use metadata::csearch::get_trait_method_def_ids;\n-use metadata::csearch::get_method_name_and_explicit_self;\n-use metadata::csearch::get_static_methods_if_impl;\n-use metadata::csearch::{get_type_name_if_impl, get_struct_fields};\n use metadata::csearch;\n-use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::lang_items::LanguageItems;\n use middle::lint::{unnecessary_qualification, unused_imports};\n@@ -1498,8 +1493,7 @@ impl Resolver {\n \n             view_item_extern_mod(name, _, _, node_id) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                match find_extern_mod_stmt_cnum(self.session.cstore,\n-                                                        node_id) {\n+                match self.session.cstore.find_extern_mod_stmt_cnum(node_id) {\n                     Some(crate_id) => {\n                         let def_id = DefId { crate: crate_id, node: 0 };\n                         self.external_exports.insert(def_id);\n@@ -1662,12 +1656,12 @@ impl Resolver {\n               // to the trait info.\n \n               let method_def_ids =\n-                get_trait_method_def_ids(self.session.cstore, def_id);\n+                csearch::get_trait_method_def_ids(self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n               for &method_def_id in method_def_ids.iter() {\n                   let (method_name, explicit_self) =\n-                      get_method_name_and_explicit_self(self.session.cstore,\n-                                                        method_def_id);\n+                      csearch::get_method_name_and_explicit_self(self.session.cstore,\n+                                                                 method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n@@ -1714,7 +1708,7 @@ impl Resolver {\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, dummy_sp(), is_public);\n-            if get_struct_fields(self.session.cstore, def_id).len() == 0 {\n+            if csearch::get_struct_fields(self.session.cstore, def_id).len() == 0 {\n                 child_name_bindings.define_value(def, dummy_sp(), is_public);\n             }\n             self.structs.insert(def_id);\n@@ -1776,12 +1770,11 @@ impl Resolver {\n             }\n             DlImpl(def) => {\n                 // We only process static methods of impls here.\n-                match get_type_name_if_impl(self.session.cstore, def) {\n+                match csearch::get_type_name_if_impl(self.session.cstore, def) {\n                     None => {}\n                     Some(final_ident) => {\n                         let static_methods_opt =\n-                            get_static_methods_if_impl(self.session.cstore,\n-                                                       def);\n+                            csearch::get_static_methods_if_impl(self.session.cstore, def);\n                         match static_methods_opt {\n                             Some(ref static_methods) if\n                                 static_methods.len() >= 1 => {"}, {"sha": "9076b0a37557d419a40151e4e23e31d1dde76fe8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -33,7 +33,7 @@ use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, True};\n use lib;\n use metadata::common::LinkMeta;\n-use metadata::{csearch, cstore, encoder};\n+use metadata::{csearch, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::lang_items::{MallocFnLangItem, ClosureExchangeMallocFnLangItem};\n@@ -2945,7 +2945,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n-    while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n+    while cstore.have_crate_data(n_subcrates) { n_subcrates += 1; }\n     let is_top = !*sess.building_library || sess.gen_crate_map();\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n@@ -2981,11 +2981,11 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n-    while cstore::have_crate_data(cstore, i) {\n-        let cdata = cstore::get_crate_data(cstore, i);\n+    while cstore.have_crate_data(i) {\n+        let cdata = cstore.get_crate_data(i);\n         let nm = symname(ccx.sess, format!(\"_rust_crate_map_{}\", cdata.name),\n-                         cstore::get_crate_hash(cstore, i),\n-                         cstore::get_crate_vers(cstore, i));\n+                         cstore.get_crate_hash(i),\n+                         cstore.get_crate_vers(i));\n         let cr = nm.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)"}, {"sha": "be07fbde9ffec5aa4bf212987e04a2d90e5c8ced", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -119,7 +119,6 @@ use back::link;\n use lib::llvm::{ValueRef, llvm, SetLinkage, False};\n use lib;\n use metadata::csearch;\n-use metadata::cstore;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -1796,7 +1795,7 @@ pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n     let (modpath, modname) = {\n         let srccrate = match ccx.external_srcs.find(&bcx.fcx.id) {\n             Some(&src) => {\n-                cstore::get_crate_data(ccx.sess.cstore, src.crate).name\n+                ccx.sess.cstore.get_crate_data(src.crate).name\n             }\n             None => ccx.link_meta.pkgid.name.to_managed(),\n         };"}, {"sha": "a8f4a27b75844a499db114bdb91a948a886a2501", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -4607,7 +4607,6 @@ pub fn trait_method_of_method(tcx: ctxt,\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n     use std::hash::{SipState, Streaming};\n-    use metadata::cstore;\n \n     let mut hash = SipState::new(0, 0);\n     let region = |_hash: &mut SipState, r: Region| {\n@@ -4639,7 +4638,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n         let h = if ast_util::is_local(did) {\n             local_hash\n         } else {\n-            cstore::get_crate_hash(tcx.sess.cstore, did.crate)\n+            tcx.sess.cstore.get_crate_hash(did.crate)\n         };\n         hash.input(h.as_bytes());\n         iter(hash, &did.node);"}, {"sha": "dac5e2e40e6a42fad4534d44311e33d3b76e197e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -17,7 +17,6 @@\n \n use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n-use metadata::cstore::iter_crate_data;\n use middle::ty::get;\n use middle::ty::{ImplContainer, lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n@@ -665,7 +664,7 @@ impl CoherenceChecker {\n         let mut impls_seen = HashSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n-        iter_crate_data(crate_store, |crate_number, _crate_metadata| {\n+        crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_impl(crate_store, crate_number, |def_id| {\n                 assert_eq!(crate_number, def_id.crate);\n                 self.add_external_impl(&mut impls_seen, def_id)"}, {"sha": "3500018820bb68eceb8fa8ee936a0facaea5c059", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -77,7 +77,7 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n         let mut externs = HashMap::new();\n-        cstore::iter_crate_data(cx.sess.cstore, |n, meta| {\n+        cx.sess.cstore.iter_crate_data(|n, meta| {\n             externs.insert(n, meta.clean());\n         });\n "}, {"sha": "8951eff2fb9bd684636d316ed9672ec7fafe5225", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cab6af55ff64148de1cda707f7d4c85f062f1ff4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab6af55ff64148de1cda707f7d4c85f062f1ff4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=cab6af55ff64148de1cda707f7d4c85f062f1ff4", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-// fails pretty printing for some reason\n-use syntax;\n-use syntax::diagnostic;\n-use syntax::ast;\n-use syntax::codemap;\n-use syntax::print::pprust;\n-use syntax::parse::parser;\n-\n-fn new_parse_sess() -> parser::parse_sess {\n-    let cm = codemap::new_codemap();\n-    let handler = diagnostic::mk_handler(option::none);\n-    let sess = @mut {\n-        cm: cm,\n-        next_id: 1,\n-        span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        chpos: 0u,\n-        byte_pos: 0u\n-    };\n-    return sess;\n-}\n-\n-trait fake_ext_ctxt {\n-    fn session() -> fake_session;\n-    fn cfg() -> ast::CrateConfig;\n-    fn parse_sess() -> parser::parse_sess;\n-}\n-\n-type fake_options = {cfg: ast::CrateConfig};\n-\n-type fake_session = {opts: @fake_options,\n-                     parse_sess: parser::parse_sess};\n-\n-impl of fake_ext_ctxt for fake_session {\n-    fn session() -> fake_session {self}\n-    fn cfg() -> ast::CrateConfig { self.opts.cfg }\n-    fn parse_sess() -> parser::parse_sess { self.parse_sess }\n-}\n-\n-fn mk_ctxt() -> fake_ext_ctxt {\n-    let opts : fake_options = {cfg: ~[]};\n-    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n-}\n-\n-\n-fn main() {\n-    let cx = mk_ctxt();\n-    let s = quote_expr!(cx, __s);\n-    let e = quote_expr!(cx, __e);\n-    let f = quote_expr!(cx, $s.foo {|__e| $e});\n-    log(error, pprust::expr_to_str(f));\n-}"}]}