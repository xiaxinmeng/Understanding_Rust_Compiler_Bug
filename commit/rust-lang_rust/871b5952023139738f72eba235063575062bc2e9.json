{"sha": "871b5952023139738f72eba235063575062bc2e9", "node_id": "C_kwDOAAsO6NoAKDg3MWI1OTUyMDIzMTM5NzM4ZjcyZWJhMjM1MDYzNTc1MDYyYmMyZTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T16:36:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T16:36:51Z"}, "message": "Auto merge of #111913 - oli-obk:valtrees2, r=lcnr\n\nOnly rewrite valtree-constants to patterns and keep other constants opaque\n\nNow that we can reliably fall back to comparing constants with `PartialEq::eq` to the match scrutinee, we can\n\n1. eagerly try to convert constants to valtrees\n2. then deeply convert the valtree to a pattern\n3. if the to-valtree conversion failed, create an \"opaque constant\" pattern.\n\nThis PR specifically avoids any behavioral changes or major cleanups. What we can now do as follow ups is\n\n* move the two remaining call sites to `destructure_mir_constant` off that query\n* make valtree to pattern conversion infallible\n    * this needs to be done after careful analysis of the effects. There may be user visible changes from that.\n\nbased on https://github.com/rust-lang/rust/pull/111768", "tree": {"sha": "b86f5fd3b7adb32b6048316468024d25c5f86851", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b86f5fd3b7adb32b6048316468024d25c5f86851"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/871b5952023139738f72eba235063575062bc2e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/871b5952023139738f72eba235063575062bc2e9", "html_url": "https://github.com/rust-lang/rust/commit/871b5952023139738f72eba235063575062bc2e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/871b5952023139738f72eba235063575062bc2e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad8304a0d5280de30856b39c19df7b306957e878", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8304a0d5280de30856b39c19df7b306957e878", "html_url": "https://github.com/rust-lang/rust/commit/ad8304a0d5280de30856b39c19df7b306957e878"}, {"sha": "3c02cfc3e7e52ce023b565180c63c72bd7ab675d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c02cfc3e7e52ce023b565180c63c72bd7ab675d", "html_url": "https://github.com/rust-lang/rust/commit/3c02cfc3e7e52ce023b565180c63c72bd7ab675d"}], "stats": {"total": 627, "additions": 302, "deletions": 325}, "files": [{"sha": "b59ca8e20702677d5a6b5a293373e67f10645882", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -2,10 +2,8 @@\n \n use crate::errors::MaxNumNodesInConstErr;\n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n-    Scalar,\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, Scalar,\n };\n-use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -131,38 +129,3 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n \n     Ok(mir::DestructuredConstant { variant, fields })\n }\n-\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(crate) fn deref_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: mir::ConstantKind<'tcx>,\n-) -> mir::ConstantKind<'tcx> {\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.eval_mir_constant(&val, None, None).unwrap();\n-    let mplace = ecx.deref_operand(&op).unwrap();\n-    if let Some(alloc_id) = mplace.ptr.provenance {\n-        assert_eq!(\n-            tcx.global_alloc(alloc_id).unwrap_memory().0.0.mutability,\n-            Mutability::Not,\n-            \"deref_mir_constant cannot be used with mutable allocations as \\\n-            that could allow pattern matching to observe mutable statics\",\n-        );\n-    }\n-\n-    let ty = match mplace.meta {\n-        MemPlaceMeta::None => mplace.layout.ty,\n-        // In case of unsized types, figure out the real type behind.\n-        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n-            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_target_usize(&tcx).unwrap()),\n-            _ => bug!(\n-                \"type {} should not have metadata, but had {:?}\",\n-                mplace.layout.ty,\n-                mplace.meta\n-            ),\n-        },\n-    };\n-\n-    mir::ConstantKind::Val(op_to_const(&ecx, &mplace.into()), ty)\n-}"}, {"sha": "0c48d99915ac93c1bc467b03207761a23a116870", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -56,10 +56,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.valtree_to_const_val = |tcx, (ty, valtree)| {\n         const_eval::valtree_to_const_value(tcx, ty::ParamEnv::empty().and(ty), valtree)\n     };\n-    providers.deref_mir_constant = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::deref_mir_constant(tcx, param_env, value)\n-    };\n     providers.check_validity_requirement = |tcx, (init_kind, param_env_and_ty)| {\n         util::check_validity_requirement(tcx, init_kind, param_env_and_ty)\n     };"}, {"sha": "f002d7f97b933b4ffedc7d05b9b0a9690843aa02", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -439,7 +439,7 @@ where\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n     pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(&self, metadata: M, i: I) -> T::Value<'tcx> {\n-        debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n+        trace!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n \n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];"}, {"sha": "5c27bdec575915a83c111abc224fad9e13be1d6e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::interpret::{\n-    AllocRange, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, LitToConstInput, Scalar,\n+    AllocRange, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -2461,51 +2461,6 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::Val(val, ty)\n     }\n \n-    #[instrument(skip(tcx), level = \"debug\", ret)]\n-    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let body_id = match tcx.hir().get(hir_id) {\n-            hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def_id.to_def_id()),\n-                \"from_inline_const can only process anonymous constants\"\n-            ),\n-        };\n-        let expr = &tcx.hir().body(body_id).value;\n-        let ty = tcx.typeck(def_id).node_type(hir_id);\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            match tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-                Ok(c) => return c,\n-                Err(_) => {}\n-            }\n-        }\n-\n-        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n-        let parent_substs =\n-            tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n-        let substs =\n-            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n-                .substs;\n-\n-        let uneval = UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n-        debug_assert!(!uneval.has_free_regions());\n-\n-        Self::Unevaluated(uneval, ty)\n-    }\n-\n     /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n     /// converted to a constant, everything else becomes `Unevaluated`.\n     #[instrument(skip(tcx), level = \"debug\", ret)]"}, {"sha": "0b31c9bbf8149f799efdb3514aa8f948bd997e45", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1081,14 +1081,6 @@ rustc_queries! {\n         desc { \"destructuring MIR constant\"}\n     }\n \n-    /// Dereference a constant reference or raw pointer and turn the result into a constant\n-    /// again.\n-    query deref_mir_constant(\n-        key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n-    ) -> mir::ConstantKind<'tcx> {\n-        desc { \"dereferencing MIR constant\" }\n-    }\n-\n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n         desc { \"getting a &core::panic::Location referring to a span\" }\n     }\n@@ -1100,10 +1092,6 @@ rustc_queries! {\n         desc { \"converting literal to const\" }\n     }\n \n-    query lit_to_mir_constant(key: LitToConstInput<'tcx>) -> Result<mir::ConstantKind<'tcx>, LitToConstError> {\n-        desc { \"converting literal to mir constant\" }\n-    }\n-\n     query check_match(key: LocalDefId) -> Result<(), rustc_errors::ErrorGuaranteed> {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { true }"}, {"sha": "73d5eb62750828bc23df6cfd8da9f316bdcdb6be", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -106,7 +106,7 @@ pub fn as_constant_inner<'tcx>(\n }\n \n #[instrument(skip(tcx, lit_input))]\n-pub(crate) fn lit_to_mir_constant<'tcx>(\n+fn lit_to_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n ) -> Result<ConstantKind<'tcx>, LitToConstError> {"}, {"sha": "8f6a069a7db54e365c4f9d6f82ba9d16f6a92877", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1,4 +1,3 @@\n-pub(crate) use crate::build::expr::as_constant::lit_to_mir_constant;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use rustc_apfloat::ieee::{Double, Single};"}, {"sha": "0eaab9b57036cfee0b507b46378bd3b584593b18", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -32,7 +32,6 @@ fluent_messages! { \"../messages.ftl\" }\n pub fn provide(providers: &mut Providers) {\n     providers.check_match = thir::pattern::check_match;\n     providers.lit_to_const = thir::constant::lit_to_const;\n-    providers.lit_to_mir_constant = build::lit_to_mir_constant;\n     providers.mir_built = build::mir_built;\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n     providers.thir_body = thir::cx::thir_body;"}, {"sha": "a7be8e3c9033b06aaccf20adbee7c1700fe6bd25", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -3,6 +3,8 @@ use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::ty::{self, ParamEnv, ScalarInt, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n+use crate::build::parse_float_into_scalar;\n+\n pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n@@ -46,12 +48,28 @@ pub(crate) fn lit_to_const<'tcx>(\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ty::ValTree::from_scalar_int((*n).into())\n         }\n+        (ast::LitKind::CStr(data, _), ty::Ref(_, inner_ty, _)) if matches!(inner_ty.kind(), ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().c_str()) =>\n+        {\n+            let bytes = data as &[u8];\n+            ty::ValTree::from_raw_bytes(tcx, bytes)\n+        }\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n             let scalar_int =\n                 trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?;\n             ty::ValTree::from_scalar_int(scalar_int)\n         }\n         (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            let bits = parse_float_into_scalar(*n, *fty, neg)\n+                .ok_or_else(|| {\n+                    LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        format!(\"couldn't parse float literal: {:?}\", lit_input.lit),\n+                    ))\n+                })?\n+                .assert_int();\n+            ty::ValTree::from_scalar_int(bits)\n+        }\n         (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n         (ast::LitKind::Err, _) => {\n             return Err(LitToConstError::Reported("}, {"sha": "7976b148f75e27ed7c1f9a23df05b15a72d5e5a2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 165, "deletions": 146, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1,13 +1,14 @@\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_index::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, ValTree};\n use rustc_session::lint;\n use rustc_span::Span;\n-use rustc_target::abi::FieldIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n \n@@ -29,11 +30,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         cv: mir::ConstantKind<'tcx>,\n         id: hir::HirId,\n         span: Span,\n-        mir_structural_match_violation: bool,\n+        check_body_for_struct_match_violation: Option<DefId>,\n     ) -> Box<Pat<'tcx>> {\n         let infcx = self.tcx.infer_ctxt().build();\n         let mut convert = ConstToPat::new(self, id, span, infcx);\n-        convert.to_pat(cv, mir_structural_match_violation)\n+        convert.to_pat(cv, check_body_for_struct_match_violation)\n     }\n }\n \n@@ -104,7 +105,7 @@ impl<'tcx> ConstToPat<'tcx> {\n     fn to_pat(\n         &mut self,\n         cv: mir::ConstantKind<'tcx>,\n-        mir_structural_match_violation: bool,\n+        check_body_for_struct_match_violation: Option<DefId>,\n     ) -> Box<Pat<'tcx>> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n@@ -114,14 +115,44 @@ impl<'tcx> ConstToPat<'tcx> {\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        let inlined_const_as_pat =\n-            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| {\n-                Box::new(Pat {\n-                    span: self.span,\n-                    ty: cv.ty(),\n-                    kind: PatKind::Constant { value: cv },\n-                })\n-            });\n+        let mir_structural_match_violation = check_body_for_struct_match_violation.map(|def_id| {\n+            // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n+            // defined, not where it is declared. The difference is significant for associated\n+            // constants.\n+            self.tcx().mir_const_qualif(def_id).custom_eq\n+        });\n+        debug!(?check_body_for_struct_match_violation, ?mir_structural_match_violation);\n+\n+        let inlined_const_as_pat = match cv {\n+            mir::ConstantKind::Ty(c) => match c.kind() {\n+                ty::ConstKind::Param(_)\n+                | ty::ConstKind::Infer(_)\n+                | ty::ConstKind::Bound(_, _)\n+                | ty::ConstKind::Placeholder(_)\n+                | ty::ConstKind::Unevaluated(_)\n+                | ty::ConstKind::Error(_)\n+                | ty::ConstKind::Expr(_) => {\n+                    span_bug!(self.span, \"unexpected const in `to_pat`: {:?}\", c.kind())\n+                }\n+                ty::ConstKind::Value(valtree) => self\n+                    .recur(valtree, cv.ty(), mir_structural_match_violation.unwrap_or(false))\n+                    .unwrap_or_else(|_| {\n+                        Box::new(Pat {\n+                            span: self.span,\n+                            ty: cv.ty(),\n+                            kind: PatKind::Constant { value: cv },\n+                        })\n+                    }),\n+            },\n+            mir::ConstantKind::Unevaluated(_, _) => {\n+                span_bug!(self.span, \"unevaluated const in `to_pat`: {cv:?}\")\n+            }\n+            mir::ConstantKind::Val(_, _) => Box::new(Pat {\n+                span: self.span,\n+                ty: cv.ty(),\n+                kind: PatKind::Constant { value: cv },\n+            }),\n+        };\n \n         if !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n@@ -141,36 +172,78 @@ impl<'tcx> ConstToPat<'tcx> {\n             //\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation`.\n-            if structural.is_none() && mir_structural_match_violation {\n+            if structural.is_none() && mir_structural_match_violation.unwrap_or(false) {\n                 warn!(\"MIR const-checker found novel structural match violation. See #73448.\");\n                 return inlined_const_as_pat;\n             }\n \n             if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // fatal avoids ICE from resolution of nonexistent method (rare case).\n-                    self.tcx()\n-                        .sess\n-                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n-                } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().emit_spanned_lint(\n-                        lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n-                        self.id,\n-                        self.span,\n-                        IndirectStructuralMatch { non_sm_ty },\n-                    );\n-                } else {\n-                    debug!(\n-                        \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n-                          not in the qualifs for that `const`\"\n-                    );\n+                    if let ty::Adt(def, ..) = non_sm_ty.kind() {\n+                        if def.is_union() {\n+                            let err = UnionPattern { span: self.span };\n+                            self.tcx().sess.emit_err(err);\n+                        } else {\n+                            // fatal avoids ICE from resolution of nonexistent method (rare case).\n+                            self.tcx()\n+                                .sess\n+                                .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty });\n+                        }\n+                    } else {\n+                        let err = InvalidPattern { span: self.span, non_sm_ty };\n+                        self.tcx().sess.emit_err(err);\n+                        return Box::new(Pat { span: self.span, ty: cv.ty(), kind: PatKind::Wild });\n+                    }\n+                } else if !self.saw_const_match_lint.get() {\n+                    if let Some(mir_structural_match_violation) = mir_structural_match_violation {\n+                        match non_sm_ty.kind() {\n+                            ty::RawPtr(pointee)\n+                                if pointee.ty.is_sized(self.tcx(), self.param_env) => {}\n+                            ty::FnPtr(..) | ty::RawPtr(..) => {\n+                                self.tcx().emit_spanned_lint(\n+                                    lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                                    self.id,\n+                                    self.span,\n+                                    PointerPattern,\n+                                );\n+                            }\n+                            ty::Adt(..) if mir_structural_match_violation => {\n+                                self.tcx().emit_spanned_lint(\n+                                    lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                                    self.id,\n+                                    self.span,\n+                                    IndirectStructuralMatch { non_sm_ty },\n+                                );\n+                            }\n+                            _ => {\n+                                debug!(\n+                                    \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n+                                  not in the qualifs for that `const`\"\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            } else if !self.saw_const_match_lint.get() {\n+                match cv.ty().kind() {\n+                    ty::RawPtr(pointee) if pointee.ty.is_sized(self.tcx(), self.param_env) => {}\n+                    ty::FnPtr(..) | ty::RawPtr(..) => {\n+                        self.tcx().emit_spanned_lint(\n+                            lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                            self.id,\n+                            self.span,\n+                            PointerPattern,\n+                        );\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n \n         inlined_const_as_pat\n     }\n \n+    #[instrument(level = \"trace\", skip(self), ret)]\n     fn type_may_have_partial_eq_impl(&self, ty: Ty<'tcx>) -> bool {\n         // double-check there even *is* a semantic `PartialEq` to dispatch to.\n         //\n@@ -187,29 +260,19 @@ impl<'tcx> ConstToPat<'tcx> {\n         );\n \n         // FIXME: should this call a `predicate_must_hold` variant instead?\n-        let has_impl = self.infcx.predicate_may_hold(&partial_eq_obligation);\n-\n-        // Note: To fix rust-lang/rust#65466, we could just remove this type\n-        // walk hack for function pointers, and unconditionally error\n-        // if `PartialEq` is not implemented. However, that breaks stable\n-        // code at the moment, because types like `for <'a> fn(&'a ())` do\n-        // not *yet* implement `PartialEq`. So for now we leave this here.\n-        has_impl\n-            || ty.walk().any(|t| match t.unpack() {\n-                ty::subst::GenericArgKind::Lifetime(_) => false,\n-                ty::subst::GenericArgKind::Type(t) => t.is_fn_ptr(),\n-                ty::subst::GenericArgKind::Const(_) => false,\n-            })\n+        self.infcx.predicate_may_hold(&partial_eq_obligation)\n     }\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = mir::ConstantKind<'tcx>>,\n+        vals: impl Iterator<Item = (ValTree<'tcx>, Ty<'tcx>)>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n-            .map(|(idx, val)| {\n+            .map(|(idx, (val, ty))| {\n                 let field = FieldIdx::new(idx);\n-                Ok(FieldPat { field, pattern: self.recur(val, false)? })\n+                // Patterns can only use monomorphic types.\n+                let ty = self.tcx().normalize_erasing_regions(self.param_env, ty);\n+                Ok(FieldPat { field, pattern: self.recur(val, ty, false)? })\n             })\n             .collect()\n     }\n@@ -218,16 +281,18 @@ impl<'tcx> ConstToPat<'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn recur(\n         &self,\n-        cv: mir::ConstantKind<'tcx>,\n+        cv: ValTree<'tcx>,\n+        ty: Ty<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Box<Pat<'tcx>>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let kind = match cv.ty().kind() {\n+        let kind = match ty.kind() {\n             ty::Float(_) => {\n+                self.saw_const_match_lint.set(true);\n                 tcx.emit_spanned_lint(\n                     lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n@@ -236,27 +301,6 @@ impl<'tcx> ConstToPat<'tcx> {\n                 );\n                 return Err(FallbackToConstRef);\n             }\n-            ty::Adt(adt_def, _) if adt_def.is_union() => {\n-                // Matching on union fields is unsafe, we can't hide it in constants\n-                self.saw_const_match_error.set(true);\n-                let err = UnionPattern { span };\n-                tcx.sess.emit_err(err);\n-                PatKind::Wild\n-            }\n-            ty::Adt(..)\n-                if !self.type_may_have_partial_eq_impl(cv.ty())\n-                    // FIXME(#73448): Find a way to bring const qualification into parity with\n-                    // `search_for_structural_match_violation` and then remove this condition.\n-\n-                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n-            {\n-                self.saw_const_match_error.set(true);\n-                let err = TypeNotStructural { span, non_sm_ty };\n-                tcx.sess.emit_err(err);\n-                PatKind::Wild\n-            }\n             // If the type is not structurally comparable, just emit the constant directly,\n             // causing the pattern match code to treat it opaquely.\n             // FIXME: This code doesn't emit errors itself, the caller emits the errors.\n@@ -266,94 +310,90 @@ impl<'tcx> ConstToPat<'tcx> {\n             // details.\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n-            ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n-                if !self.saw_const_match_error.get()\n-                    && !self.saw_const_match_lint.get()\n-                {\n+            ty::Adt(..) if !self.type_marked_structural(ty) && self.behind_reference.get() => {\n+                if !self.saw_const_match_error.get() && !self.saw_const_match_lint.get() {\n                     self.saw_const_match_lint.set(true);\n                     tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n+                        IndirectStructuralMatch { non_sm_ty: ty },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n                 // constant at reference type, making it easy to let the fallback call\n                 // `PartialEq::eq` on it.\n                 return Err(FallbackToConstRef);\n             }\n-            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty()) => {\n-                debug!(\n-                    \"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\",\n-                    adt_def,\n-                    cv.ty()\n-                );\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(ty) => {\n+                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, ty,);\n                 self.saw_const_match_error.set(true);\n-                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                let err = TypeNotStructural { span, non_sm_ty: ty };\n                 tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let destructured = tcx.destructure_mir_constant(param_env, cv);\n-\n+                let (&variant_index, fields) = cv.unwrap_branch().split_first().unwrap();\n+                let variant_index =\n+                    VariantIdx::from_u32(variant_index.unwrap_leaf().try_to_u32().ok().unwrap());\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n-                    variant_index: destructured\n-                        .variant\n-                        .expect(\"destructed const of adt without variant id\"),\n-                    subpatterns: self.field_pats(destructured.fields.iter().copied())?,\n+                    variant_index,\n+                    subpatterns: self.field_pats(\n+                        fields.iter().copied().zip(\n+                            adt_def.variants()[variant_index]\n+                                .fields\n+                                .iter()\n+                                .map(|field| field.ty(self.tcx(), substs)),\n+                        ),\n+                    )?,\n                 }\n             }\n-            ty::Tuple(_) | ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_mir_constant(param_env, cv);\n-                PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n-            }\n-            ty::Array(..) => PatKind::Array {\n-                prefix: tcx\n-                    .destructure_mir_constant(param_env, cv)\n-                    .fields\n+            ty::Tuple(fields) => PatKind::Leaf {\n+                subpatterns: self\n+                    .field_pats(cv.unwrap_branch().iter().copied().zip(fields.iter()))?,\n+            },\n+            ty::Adt(def, substs) => PatKind::Leaf {\n+                subpatterns: self.field_pats(cv.unwrap_branch().iter().copied().zip(\n+                    def.non_enum_variant().fields.iter().map(|field| field.ty(self.tcx(), substs)),\n+                ))?,\n+            },\n+            ty::Array(elem_ty, _) => PatKind::Array {\n+                prefix: cv\n+                    .unwrap_branch()\n                     .iter()\n-                    .map(|val| self.recur(*val, false))\n+                    .map(|val| self.recur(*val, *elem_ty, false))\n                     .collect::<Result<_, _>>()?,\n                 slice: None,\n                 suffix: Box::new([]),\n             },\n             ty::Ref(_, pointee_ty, ..) => match *pointee_ty.kind() {\n-                // These are not allowed and will error elsewhere anyway.\n-                ty::Dynamic(..) => {\n-                    self.saw_const_match_error.set(true);\n-                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.emit_err(err);\n-                    PatKind::Wild\n-                }\n-                // `&str` is represented as `ConstValue::Slice`, let's keep using this\n+                // `&str` is represented as a valtree, let's keep using this\n                 // optimization for now.\n-                ty::Str => PatKind::Constant { value: cv },\n+                ty::Str => PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n                 // The typechecker has a special case for byte string literals, by treating them\n                 // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n                 // has no negative effects on pattern matching, even if we're actually matching on\n                 // arrays.\n-                ty::Array(..) if !self.treat_byte_string_as_slice => {\n+                ty::Array(elem_ty, _) if !self.treat_byte_string_as_slice => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    // References have the same valtree representation as their pointee.\n+                    let array = cv;\n                     let val = PatKind::Deref {\n                         subpattern: Box::new(Pat {\n                             kind: PatKind::Array {\n-                                prefix: tcx\n-                                    .destructure_mir_constant(param_env, array)\n-                                    .fields\n+                                prefix: array.unwrap_branch()\n                                     .iter()\n-                                    .map(|val| self.recur(*val, false))\n+                                    .map(|val| self.recur(*val, elem_ty, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: Box::new([]),\n                             },\n                             span,\n-                            ty: *pointee_ty,\n+                            ty: tcx.mk_slice(elem_ty),\n                         }),\n                     };\n                     self.behind_reference.set(old);\n@@ -365,15 +405,14 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // pattern.\n                 ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    // References have the same valtree representation as their pointee.\n+                    let array = cv;\n                     let val = PatKind::Deref {\n                         subpattern: Box::new(Pat {\n                             kind: PatKind::Slice {\n-                                prefix: tcx\n-                                    .destructure_mir_constant(param_env, array)\n-                                    .fields\n+                                prefix: array.unwrap_branch()\n                                     .iter()\n-                                    .map(|val| self.recur(*val, false))\n+                                    .map(|val| self.recur(*val, elem_ty, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: Box::new([]),\n@@ -418,48 +457,28 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // deref pattern.\n                 _ => {\n                     if !pointee_ty.is_sized(tcx, param_env) {\n-                        // `tcx.deref_mir_constant()` below will ICE with an unsized type\n-                        // (except slices, which are handled in a separate arm above).\n-\n                         let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n                         tcx.sess.emit_err(err);\n \n+                        // FIXME: introduce PatKind::Error to silence follow up diagnostics due to unreachable patterns.\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n-                        let subpattern = self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false)?;\n+                        // References have the same valtree representation as their pointee.\n+                        let subpattern = self.recur(cv, *pointee_ty, false)?;\n                         self.behind_reference.set(old);\n                         PatKind::Deref { subpattern }\n                     }\n                 }\n             },\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n-                PatKind::Constant { value: cv }\n-            }\n-            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n-                return Err(FallbackToConstRef);\n-            }\n-            // FIXME: these can have very surprising behaviour where optimization levels or other\n-            // compilation choices change the runtime behaviour of the match.\n-            // See https://github.com/rust-lang/rust/issues/70861 for examples.\n-            ty::FnPtr(..) | ty::RawPtr(..) => {\n-                if !self.saw_const_match_error.get()\n-                    && !self.saw_const_match_lint.get()\n-                {\n-                    self.saw_const_match_lint.set(true);\n-                    tcx.emit_spanned_lint(\n-                        lint::builtin::POINTER_STRUCTURAL_MATCH,\n-                        id,\n-                        span,\n-                        PointerPattern\n-                    );\n-                }\n-                return Err(FallbackToConstRef);\n+                PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) }\n             }\n+            ty::FnPtr(..) | ty::RawPtr(..) => unreachable!(),\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.emit_err(err);\n+                let err = InvalidPattern { span, non_sm_ty: ty };\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n         };\n@@ -472,7 +491,7 @@ impl<'tcx> ConstToPat<'tcx> {\n \n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, ty)\n         {\n             self.saw_const_match_lint.set(true);\n             tcx.emit_spanned_lint(\n@@ -483,6 +502,6 @@ impl<'tcx> ConstToPat<'tcx> {\n             );\n         }\n \n-        Ok(Box::new(Pat { span, ty: cv.ty(), kind }))\n+        Ok(Box::new(Pat { span, ty, kind }))\n     }\n }"}, {"sha": "9df6d2f43ad57b8493fc700c8081031853831a83", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -53,11 +53,11 @@ use smallvec::{smallvec, SmallVec};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::{HirId, RangeEnd};\n use rustc_index::Idx;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n-use rustc_middle::{middle::stability::EvalResult, mir::interpret::ConstValue};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{FieldIdx, Integer, Size, VariantIdx, FIRST_VARIANT};\n@@ -140,28 +140,17 @@ impl IntRange {\n         value: mir::ConstantKind<'tcx>,\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n-        if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n-            let val = if let mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) = value {\n-                // For this specific pattern we can skip a lot of effort and go\n-                // straight to the result, after doing a bit of checking. (We\n-                // could remove this branch and just fall through, which\n-                // is more general but much slower.)\n-                scalar.to_bits_or_ptr_internal(target_size).unwrap().left()?\n-            } else {\n-                if let mir::ConstantKind::Ty(c) = value\n-                    && let ty::ConstKind::Value(_) = c.kind()\n-                {\n-                    bug!(\"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\");\n-                }\n+        let (target_size, bias) = Self::integral_size_and_signed_bias(tcx, ty)?;\n+        let val = match value {\n+            mir::ConstantKind::Ty(c) if let ty::ConstKind::Value(valtree) = c.kind() => {\n+                valtree.unwrap_leaf().to_bits(target_size).ok()\n+            },\n+            // This is a more general form of the previous case.\n+            _ => value.try_eval_bits(tcx, param_env, ty),\n+        }?;\n \n-                // This is a more general form of the previous case.\n-                value.try_eval_bits(tcx, param_env, ty)?\n-            };\n-            let val = val ^ bias;\n-            Some(IntRange { range: val..=val, bias })\n-        } else {\n-            None\n-        }\n+        let val = val ^ bias;\n+        Some(IntRange { range: val..=val, bias })\n     }\n \n     #[inline]"}, {"sha": "1bbe7b45c1ed2bc7144c352c25126e434fbb6126", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 90, "deletions": 34, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -18,14 +18,15 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::Idx;\n use rustc_middle::mir::interpret::{\n-    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n+    ConstValue, ErrorHandled, GlobalId, LitToConstError, LitToConstInput, Scalar,\n };\n-use rustc_middle::mir::{self, UserTypeProjection};\n+use rustc_middle::mir::{self, ConstantKind, UserTypeProjection};\n use rustc_middle::mir::{BorrowKind, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, LocalVarId, Pat, PatKind, PatRange};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n-use rustc_middle::ty::{self, AdtDef, ConstKind, Region, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::TypeVisitableExt;\n+use rustc_middle::ty::{self, AdtDef, Region, Ty, TyCtxt, UserType};\n use rustc_span::{Span, Symbol};\n use rustc_target::abi::FieldIdx;\n \n@@ -518,16 +519,24 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n         };\n \n-        // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n-        // defined, not where it is declared. The difference is significant for associated\n-        // constants.\n-        let mir_structural_match_violation = self.tcx.mir_const_qualif(instance.def_id()).custom_eq;\n-        debug!(\"mir_structural_match_violation({:?}) -> {}\", qpath, mir_structural_match_violation);\n-\n-        match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n-            Ok(literal) => {\n-                let const_ = mir::ConstantKind::Val(literal, ty);\n-                let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n+        let cid = GlobalId { instance, promoted: None };\n+        // Prefer valtrees over opaque constants.\n+        let const_value = self\n+            .tcx\n+            .const_eval_global_id_for_typeck(param_env_reveal_all, cid, Some(span))\n+            .map(|val| match val {\n+                Some(valtree) => mir::ConstantKind::Ty(self.tcx.mk_const(valtree, ty)),\n+                None => mir::ConstantKind::Val(\n+                    self.tcx\n+                        .const_eval_global_id(param_env_reveal_all, cid, Some(span))\n+                        .expect(\"const_eval_global_id_for_typeck should have already failed\"),\n+                    ty,\n+                ),\n+            });\n+\n+        match const_value {\n+            Ok(const_) => {\n+                let pattern = self.const_to_pat(const_, id, span, Some(instance.def_id()));\n \n                 if !is_associated_const {\n                     return pattern;\n@@ -577,27 +586,69 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n     ) -> PatKind<'tcx> {\n-        let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const.def_id);\n-\n-        // Evaluate early like we do in `lower_path`.\n-        let value = value.eval(self.tcx, self.param_env);\n-\n-        match value {\n-            mir::ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) => {\n-                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n-                    return PatKind::Wild;\n-                }\n-                ConstKind::Error(_) => {\n-                    return PatKind::Wild;\n+        let tcx = self.tcx;\n+        let def_id = anon_const.def_id;\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_inline_const can only process anonymous constants\"\n+            ),\n+        };\n+        let expr = &tcx.hir().body(body_id).value;\n+        let ty = tcx.typeck(def_id).node_type(hir_id);\n+\n+        // Special case inline consts that are just literals. This is solely\n+        // a performance optimization, as we could also just go through the regular\n+        // const eval path below.\n+        // FIXME: investigate the performance impact of removing this.\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n                 }\n-                _ => bug!(\"Expected ConstKind::Param\"),\n+                _ => None,\n             },\n-            mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n-            mir::ConstantKind::Unevaluated(..) => {\n-                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n-                return PatKind::Wild;\n+            _ => None,\n+        };\n+        if let Some(lit_input) = lit_input {\n+            match tcx.at(expr.span).lit_to_const(lit_input) {\n+                Ok(c) => return self.const_to_pat(ConstantKind::Ty(c), id, span, None).kind,\n+                // If an error occurred, ignore that it's a literal\n+                // and leave reporting the error up to const eval of\n+                // the unevaluated constant below.\n+                Err(_) => {}\n+            }\n+        }\n+\n+        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n+        let parent_substs =\n+            tcx.erase_regions(ty::InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n+        let substs =\n+            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n+                .substs;\n+\n+        let uneval = mir::UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n+        debug_assert!(!substs.has_free_regions());\n+\n+        let ct = ty::UnevaluatedConst { def: def_id.to_def_id(), substs: substs };\n+        // First try using a valtree in order to destructure the constant into a pattern.\n+        if let Ok(Some(valtree)) =\n+            self.tcx.const_eval_resolve_for_typeck(self.param_env, ct, Some(span))\n+        {\n+            self.const_to_pat(ConstantKind::Ty(self.tcx.mk_const(valtree, ty)), id, span, None).kind\n+        } else {\n+            // If that fails, convert it to an opaque constant pattern.\n+            match tcx.const_eval_resolve(self.param_env, uneval, None) {\n+                Ok(val) => self.const_to_pat(mir::ConstantKind::Val(val, ty), id, span, None).kind,\n+                Err(ErrorHandled::TooGeneric) => {\n+                    // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                    self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n+                    PatKind::Wild\n+                }\n+                Err(ErrorHandled::Reported(_)) => PatKind::Wild,\n             }\n         }\n     }\n@@ -626,8 +677,10 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-        match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-            Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n+        match self.tcx.at(expr.span).lit_to_const(lit_input) {\n+            Ok(constant) => {\n+                self.const_to_pat(ConstantKind::Ty(constant), expr.hir_id, lit.span, None).kind\n+            }\n             Err(LitToConstError::Reported(_)) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n@@ -806,6 +859,9 @@ pub(crate) fn compare_const_vals<'tcx>(\n                 mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(a)), _a_ty),\n                 mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(b)), _b_ty),\n             ) => return Some(a.cmp(&b)),\n+            (mir::ConstantKind::Ty(a), mir::ConstantKind::Ty(b)) => {\n+                return Some(a.kind().cmp(&b.kind()));\n+            }\n             _ => {}\n         },\n     }"}, {"sha": "243cb463560e4e32246e08db42ff25373976b9e1", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -17,8 +17,8 @@ impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n         let literal = constant.literal;\n         match literal {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) | ConstKind::Error(_) => {}\n-                _ => bug!(\"only ConstKind::Param should be encountered here, got {:#?}\", c),\n+                ConstKind::Param(_) | ConstKind::Error(_) | ConstKind::Value(_) => {}\n+                _ => bug!(\"only ConstKind::Param/Value should be encountered here, got {:#?}\", c),\n             },\n             ConstantKind::Unevaluated(..) => self.required_consts.push(*constant),\n             ConstantKind::Val(..) => {}"}, {"sha": "0c7e36b3bef740052d5cdf05e8971365cc84f6e1", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1288,7 +1288,7 @@ pub fn decode_expn_id(\n     decode_data: impl FnOnce(ExpnId) -> (ExpnData, ExpnHash),\n ) -> ExpnId {\n     if index == 0 {\n-        debug!(\"decode_expn_id: deserialized root\");\n+        trace!(\"decode_expn_id: deserialized root\");\n         return ExpnId::root();\n     }\n \n@@ -1321,7 +1321,7 @@ pub fn decode_syntax_context<D: Decoder, F: FnOnce(&mut D, u32) -> SyntaxContext\n ) -> SyntaxContext {\n     let raw_id: u32 = Decodable::decode(d);\n     if raw_id == 0 {\n-        debug!(\"decode_syntax_context: deserialized root\");\n+        trace!(\"decode_syntax_context: deserialized root\");\n         // The root is special\n         return SyntaxContext::root();\n     }"}, {"sha": "aa4cf7a64d5ca07f84babf9e9cce77b11ea7c0fd", "filename": "tests/codegen/const_scalar_pair.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fcodegen%2Fconst_scalar_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fcodegen%2Fconst_scalar_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fconst_scalar_pair.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -2,6 +2,8 @@\n \n #![feature(inline_const)]\n \n+// Test that we don't generate a memory allocation for the constant\n+// and read the fields from that, but instead just create the value pair directly.\n pub fn foo() -> (i32, i32) {\n     // CHECK: ret { i32, i32 } { i32 1, i32 2 }\n     const { (1, 2) }"}, {"sha": "39373da6a9f605ae7a52f85d7d9306f1d6b7b43e", "filename": "tests/incremental/issue-101518.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fincremental%2Fissue-101518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fincremental%2Fissue-101518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fissue-101518.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1,27 +1,20 @@\n-// revisions: cfail1\n-// should-ice\n-// error-pattern: forcing query\n-// known-bug: #101518\n+// revisions: cpass\n \n #[derive(PartialEq, Eq)]\n struct Id<'a> {\n     ns: &'a str,\n }\n fn visit_struct() {\n     let id = Id { ns: \"random1\" };\n-    const FLAG: Id<'static> = Id {\n-        ns: \"needs_to_be_the_same\",\n-    };\n+    const FLAG: Id<'static> = Id { ns: \"needs_to_be_the_same\" };\n     match id {\n         FLAG => {}\n         _ => {}\n     }\n }\n fn visit_struct2() {\n     let id = Id { ns: \"random2\" };\n-    const FLAG: Id<'static> = Id {\n-        ns: \"needs_to_be_the_same\",\n-    };\n+    const FLAG: Id<'static> = Id { ns: \"needs_to_be_the_same\" };\n     match id {\n         FLAG => {}\n         _ => {}"}, {"sha": "61ce5e54fdc1af550914715deb88b9e8d3447aff", "filename": "tests/mir-opt/deref-patterns/string.foo.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -35,7 +35,7 @@ fn foo(_1: Option<String>) -> i32 {\n                                          // + literal: Const { ty: for<'a, 'b> fn(&'a str, &'b str) -> bool {<str as PartialEq>::eq}, val: Value(<ZST>) }\n                                          // mir::Constant\n                                          // + span: $DIR/string.rs:9:14: 9:17\n-                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }\n+                                         // + literal: Const { ty: &str, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb3: {"}, {"sha": "df28c474ab0a2012c95ae24fce475dfcdbedc1d2", "filename": "tests/ui/match/issue-70972-dyn-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let a: &dyn Send = &7u32;\n     match a {\n         F => panic!(),\n-        //~^ ERROR `&dyn Send` cannot be used in patterns\n+        //~^ ERROR `dyn Send` cannot be used in patterns\n         _ => {}\n     }\n }"}, {"sha": "f4dc910c34a6596eb3bc659705897c3425b51a58", "filename": "tests/ui/match/issue-70972-dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1,4 +1,4 @@\n-error: `&dyn Send` cannot be used in patterns\n+error: `dyn Send` cannot be used in patterns\n   --> $DIR/issue-70972-dyn-trait.rs:6:9\n    |\n LL |         F => panic!(),"}, {"sha": "21edb26de082eb4d0c7d43519db3751e7453b055", "filename": "tests/ui/pattern/issue-72565.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fpattern%2Fissue-72565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fpattern%2Fissue-72565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-72565.rs?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -3,6 +3,6 @@ const F: &'static dyn PartialEq<u32> = &7u32;\n fn main() {\n     let a: &dyn PartialEq<u32> = &7u32;\n     match a {\n-        F => panic!(), //~ ERROR: `&dyn PartialEq<u32>` cannot be used in patterns\n+        F => panic!(), //~ ERROR: `dyn PartialEq<u32>` cannot be used in patterns\n     }\n }"}, {"sha": "0519720694d70b25aead81d4d840976def03f898", "filename": "tests/ui/pattern/issue-72565.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fpattern%2Fissue-72565.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/871b5952023139738f72eba235063575062bc2e9/tests%2Fui%2Fpattern%2Fissue-72565.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-72565.stderr?ref=871b5952023139738f72eba235063575062bc2e9", "patch": "@@ -1,4 +1,4 @@\n-error: `&dyn PartialEq<u32>` cannot be used in patterns\n+error: `dyn PartialEq<u32>` cannot be used in patterns\n   --> $DIR/issue-72565.rs:6:9\n    |\n LL |         F => panic!(),"}]}