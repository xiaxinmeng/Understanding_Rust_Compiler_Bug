{"sha": "b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZDU4MTdkZDE4YjdiNWZjMTAyYTYzYjA4NGIxZWU3ZmY0Zjk5OTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-24T21:40:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T09:59:18Z"}, "message": "Convert code to text-size", "tree": {"sha": "e5d136c5ba4a6ba96aeeb423e6e3f64ca7cea3f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5d136c5ba4a6ba96aeeb423e6e3f64ca7cea3f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "html_url": "https://github.com/rust-lang/rust/commit/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27a7718880d93f55f905da606d108d3b3c682ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/27a7718880d93f55f905da606d108d3b3c682ab4", "html_url": "https://github.com/rust-lang/rust/commit/27a7718880d93f55f905da606d108d3b3c682ab4"}], "stats": {"total": 894, "additions": 438, "deletions": 456}, "files": [{"sha": "70dfa019d24a1c899c0e1f986d6dfe4059e20efa", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1180,7 +1180,7 @@ dependencies = [\n name = \"ra_text_edit\"\n version = \"0.1.0\"\n dependencies = [\n- \"text_unit\",\n+ \"text-size\",\n ]\n \n [[package]]\n@@ -1322,13 +1322,11 @@ dependencies = [\n \n [[package]]\n name = \"rowan\"\n-version = \"0.9.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ea7cadf87a9d8432e85cb4eb86bd2e765ace60c24ef86e79084dcae5d1c5a19\"\n+version = \"0.10.0-pre.1\"\n dependencies = [\n  \"rustc-hash\",\n  \"smol_str\",\n- \"text_unit\",\n+ \"text-size\",\n  \"thin-dst\",\n ]\n \n@@ -1620,14 +1618,12 @@ version = \"0.1.0\"\n dependencies = [\n  \"difference\",\n  \"serde_json\",\n- \"text_unit\",\n+ \"text-size\",\n ]\n \n [[package]]\n-name = \"text_unit\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"20431e104bfecc1a40872578dbc390e10290a0e9c35fffe3ce6f73c15a9dbfc2\"\n+name = \"text-size\"\n+version = \"1.0.0-pre.1\"\n \n [[package]]\n name = \"thin-dst\""}, {"sha": "2fe7c3de3d1424ae5fe927d4b7efde645fe2ea2c", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -5,7 +5,7 @@ use ra_fmt::{leading_indent, reindent};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{self, find_covering_element, find_node_at_offset},\n-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n     TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n@@ -178,7 +178,7 @@ impl<'a> AssistGroup<'a> {\n #[derive(Default)]\n pub(crate) struct ActionBuilder {\n     edit: TextEditBuilder,\n-    cursor_position: Option<TextUnit>,\n+    cursor_position: Option<TextSize>,\n     target: Option<TextRange>,\n     file: AssistFile,\n }\n@@ -211,12 +211,12 @@ impl ActionBuilder {\n     }\n \n     /// Append specified `text` at the given `offset`\n-    pub(crate) fn insert(&mut self, offset: TextUnit, text: impl Into<String>) {\n+    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n         self.edit.insert(offset, text.into())\n     }\n \n     /// Specify desired position of the cursor after the assist is applied.\n-    pub(crate) fn set_cursor(&mut self, offset: TextUnit) {\n+    pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n         self.cursor_position = Some(offset)\n     }\n "}, {"sha": "7bb90dba351171d6c81b39e6ead83a1b2dd45519", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@ use ra_syntax::{\n     ast::{self, AstNode},\n     Direction, SmolStr,\n     SyntaxKind::{IDENT, WHITESPACE},\n-    TextRange, TextUnit,\n+    TextRange, TextSize,\n };\n use stdx::SepBy;\n \n@@ -71,7 +71,7 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n \n         let cursor_delta = if has_more_derives {\n             edit.replace(input.syntax().text_range(), new_attr_input);\n-            input.syntax().text_range().len() - TextUnit::from_usize(new_attr_input_len)\n+            input.syntax().text_range().len() - TextSize::from_usize(new_attr_input_len)\n         } else {\n             let attr_range = attr.syntax().text_range();\n             edit.delete(attr_range);\n@@ -81,13 +81,13 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n                 .next_sibling_or_token()\n                 .filter(|t| t.kind() == WHITESPACE)\n                 .map(|t| t.text_range())\n-                .unwrap_or_else(|| TextRange::from_to(TextUnit::from(0), TextUnit::from(0)));\n+                .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n             edit.delete(line_break_range);\n \n             attr_range.len() + line_break_range.len()\n         };\n \n-        edit.set_cursor(start_offset + TextUnit::of_str(&buf) - cursor_delta);\n+        edit.set_cursor(start_offset + TextSize::of(&buf) - cursor_delta);\n         buf.push_str(\"\\n}\");\n         edit.insert(start_offset, buf);\n     })"}, {"sha": "6254eb7c41eb487da9b76e587ac52241f9b8daf0", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,7 +1,7 @@\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SyntaxKind::{COMMENT, WHITESPACE},\n-    TextUnit,\n+    TextSize,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -37,17 +37,17 @@ pub(crate) fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n         let offset = match derive_attr {\n             None => {\n                 edit.insert(node_start, \"#[derive()]\\n\");\n-                node_start + TextUnit::of_str(\"#[derive(\")\n+                node_start + TextSize::of(\"#[derive(\")\n             }\n-            Some(tt) => tt.syntax().text_range().end() - TextUnit::of_char(')'),\n+            Some(tt) => tt.syntax().text_range().end() - TextSize::of(')'),\n         };\n         edit.target(nominal.syntax().text_range());\n         edit.set_cursor(offset)\n     })\n }\n \n // Insert `derive` after doc comments.\n-fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextUnit> {\n+fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextSize> {\n     let non_ws_child = nominal\n         .syntax()\n         .children_with_tokens()"}, {"sha": "bc313782be9c91576d6bd70d73f9896f0d519288", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -37,8 +37,8 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n     let stmt_range = stmt.syntax().text_range();\n     let eq_range = stmt.eq_token()?.text_range();\n     // Assist should only be applicable if cursor is between 'let' and '='\n-    let let_range = TextRange::from_to(stmt_range.start(), eq_range.start());\n-    let cursor_in_range = ctx.frange.range.is_subrange(&let_range);\n+    let let_range = TextRange::new(stmt_range.start(), eq_range.start());\n+    let cursor_in_range = let_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {\n         return None;\n     }"}, {"sha": "03806724a3ace8b32bfe16af0090cc50db3e56ed", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    TextUnit,\n+    TextSize,\n };\n use stdx::format_to;\n \n@@ -65,7 +65,7 @@ impl From<{0}> for {1} {{\n                 variant_name\n             );\n             edit.insert(start_offset, buf);\n-            edit.set_cursor(start_offset + TextUnit::of_str(\"\\n\\n\"));\n+            edit.set_cursor(start_offset + TextSize::of(\"\\n\\n\"));\n         },\n     )\n }"}, {"sha": "7a8f5705f42008254439b1b2d688dee062976256", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxKind, SyntaxNode, TextUnit,\n+    SyntaxKind, SyntaxNode, TextSize,\n };\n \n use crate::{Assist, AssistCtx, AssistFile, AssistId};\n@@ -69,8 +69,8 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n }\n \n struct FunctionTemplate {\n-    insert_offset: TextUnit,\n-    cursor_offset: TextUnit,\n+    insert_offset: TextSize,\n+    cursor_offset: TextSize,\n     fn_def: ast::SourceFile,\n     file: AssistFile,\n }\n@@ -129,7 +129,7 @@ impl FunctionBuilder {\n                 let fn_def = indent_once.increase_indent(fn_def);\n                 let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n                 let fn_def = indent.increase_indent(fn_def);\n-                (fn_def, it.syntax().text_range().start() + TextUnit::from_usize(1))\n+                (fn_def, it.syntax().text_range().start() + TextSize::from_usize(1))\n             }\n         };\n "}, {"sha": "d26f8b93da005f4d1ff090a157b43e9d30c088c9", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner, TypeParamsOwner},\n-    TextUnit,\n+    TextSize,\n };\n use stdx::{format_to, SepBy};\n \n@@ -51,7 +51,7 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n             format_to!(buf, \"<{}>\", generic_params)\n         }\n         buf.push_str(\" {\\n\");\n-        edit.set_cursor(start_offset + TextUnit::of_str(&buf));\n+        edit.set_cursor(start_offset + TextSize::of(&buf));\n         buf.push_str(\"\\n}\");\n         edit.insert(start_offset, buf);\n     })"}, {"sha": "0698cce88a878ce6c8627a3a626860a13bdafbd9", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     ast::{\n         self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n     },\n-    TextUnit, T,\n+    TextSize, T,\n };\n use stdx::{format_to, SepBy};\n \n@@ -77,16 +77,16 @@ pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n                     .text_range()\n                     .end();\n \n-                Some((start, TextUnit::from_usize(1)))\n+                Some((start, TextSize::from_usize(1)))\n             })\n             .unwrap_or_else(|| {\n                 buf = generate_impl_text(&strukt, &buf);\n                 let start = strukt.syntax().text_range().end();\n \n-                (start, TextUnit::from_usize(3))\n+                (start, TextSize::from_usize(3))\n             });\n \n-        edit.set_cursor(start_offset + TextUnit::of_str(&buf) - end_offset);\n+        edit.set_cursor(start_offset + TextSize::of(&buf) - end_offset);\n         edit.insert(start_offset, buf);\n     })\n }"}, {"sha": "260b9e0732055a60ba71964fd43dc2a579325ba3", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n     let opposite_op = opposite_logic_op(op)?;\n-    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n+    let cursor_in_range = op_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {\n         return None;\n     }"}, {"sha": "44f6a1dae02cd714e92d102c8835fcf388ff7784", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n         ATTR, COMMENT, CONST_DEF, ENUM_DEF, FN_DEF, MODULE, STRUCT_DEF, TRAIT_DEF, VISIBILITY,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextUnit, T,\n+    SyntaxNode, TextSize, T,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -67,7 +67,7 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n     })\n }\n \n-fn vis_offset(node: &SyntaxNode) -> TextUnit {\n+fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .skip_while(|it| match it.kind() {\n             WHITESPACE | COMMENT | ATTR => true,"}, {"sha": "8030efb3585454f2dfb2830ee9ce1d0b0e3e0434", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n     let rhs = expr.rhs()?.syntax().clone();\n     let op_range = expr.op_token()?.text_range();\n     // The assist should be applied only if the cursor is on the operator\n-    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n+    let cursor_in_range = op_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {\n         return None;\n     }"}, {"sha": "f5702f6e0c22b60fc7cb738edcaec5423955bd29", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n         .next_sibling_or_token()\n         .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n     {\n-        TextRange::from_to(\n+        TextRange::new(\n             let_stmt.syntax().text_range().start(),\n             whitespace.syntax().text_range().end(),\n         )"}, {"sha": "eda9ac296304c522e1a3e590c5f4fcb7945f0cdb", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n         BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextUnit,\n+    SyntaxNode, TextSize,\n };\n use stdx::format_to;\n use test_utils::tested_by;\n@@ -47,10 +47,10 @@ pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n \n         let cursor_offset = if wrap_in_block {\n             buf.push_str(\"{ let var_name = \");\n-            TextUnit::of_str(\"{ let \")\n+            TextSize::of(\"{ let \")\n         } else {\n             buf.push_str(\"let var_name = \");\n-            TextUnit::of_str(\"let \")\n+            TextSize::of(\"let \")\n         };\n         format_to!(buf, \"{}\", expr.syntax());\n         let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());"}, {"sha": "682e085120a3c0ea8134bd2ac2ccf8f74cc7e2aa", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n     let if_keyword = ctx.find_token_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent())?;\n     let if_range = if_keyword.text_range();\n-    let cursor_in_range = ctx.frange.range.is_subrange(&if_range);\n+    let cursor_in_range = if_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {\n         return None;\n     }"}, {"sha": "cd0416f0187a7c3e6c81c7911e50f0fa0162f565", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -3,7 +3,7 @@ use std::iter::successors;\n use ra_syntax::{\n     algo::neighbor,\n     ast::{self, AstNode},\n-    Direction, TextUnit,\n+    Direction, TextSize,\n };\n \n use crate::{Assist, AssistCtx, AssistId, TextRange};\n@@ -42,8 +42,8 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let current_text_range = current_arm.syntax().text_range();\n \n     enum CursorPos {\n-        InExpr(TextUnit),\n-        InPat(TextUnit),\n+        InExpr(TextSize),\n+        InPat(TextSize),\n     }\n     let cursor_pos = ctx.frange.range.start();\n     let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n@@ -89,10 +89,10 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n \n         edit.target(current_text_range);\n         edit.set_cursor(match cursor_pos {\n-            CursorPos::InExpr(back_offset) => start + TextUnit::from_usize(arm.len()) - back_offset,\n+            CursorPos::InExpr(back_offset) => start + TextSize::from_usize(arm.len()) - back_offset,\n             CursorPos::InPat(offset) => offset,\n         });\n-        edit.replace(TextRange::from_to(start, end), arm);\n+        edit.replace(TextRange::new(start, end), arm);\n     })\n }\n "}, {"sha": "d5ccdd91cefaf6c321edef410a070d3a184fac4d", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,7 +1,7 @@\n use ra_syntax::{\n     ast,\n     ast::{AstNode, AstToken, IfExpr, MatchArm},\n-    TextUnit,\n+    TextSize,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -49,16 +49,16 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n                     edit.delete(ele);\n                     ele.len()\n                 } else {\n-                    TextUnit::from(0)\n+                    TextSize::from(0)\n                 }\n             }\n-            _ => TextUnit::from(0),\n+            _ => TextSize::from(0),\n         };\n \n         edit.delete(guard.syntax().text_range());\n         edit.replace_node_and_indent(arm_expr.syntax(), buf);\n         edit.set_cursor(\n-            arm_expr.syntax().text_range().start() + TextUnit::from(3) - offseting_amount,\n+            arm_expr.syntax().text_range().start() + TextSize::from(3) - offseting_amount,\n         );\n     })\n }\n@@ -123,7 +123,7 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n             }\n \n             edit.insert(match_pat.syntax().text_range().end(), buf);\n-            edit.set_cursor(match_pat.syntax().text_range().end() + TextUnit::from(1));\n+            edit.set_cursor(match_pat.syntax().text_range().end() + TextSize::from(1));\n         },\n     )\n }"}, {"sha": "567400b9c274bc90216ad01d04201901705e6359", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@ use ra_syntax::{\n     ast::{self, HasStringValue},\n     AstToken,\n     SyntaxKind::{RAW_STRING, STRING},\n-    TextUnit,\n+    TextSize,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -81,7 +81,7 @@ pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     ctx.add_assist(AssistId(\"add_hash\"), \"Add # to raw string\", |edit| {\n         edit.target(token.text_range());\n-        edit.insert(token.text_range().start() + TextUnit::of_char('r'), \"#\");\n+        edit.insert(token.text_range().start() + TextSize::of('r'), \"#\");\n         edit.insert(token.text_range().end(), \"#\");\n     })\n }"}, {"sha": "4e5eb435052667284bbd54e55cec7514b04f95a0", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    TextUnit, T,\n+    TextSize, T,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -38,9 +38,9 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n         let offset_start = file_range\n             .start()\n             .checked_sub(macro_range.start())\n-            .unwrap_or_else(|| TextUnit::from(0));\n+            .unwrap_or_else(|| TextSize::from(0));\n \n-        let dbg_size = TextUnit::of_str(\"dbg!(\");\n+        let dbg_size = TextSize::of(\"dbg!(\");\n \n         if offset_start > dbg_size {\n             file_range.start() - dbg_size\n@@ -53,7 +53,7 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n         let macro_args = macro_call.token_tree()?.syntax().clone();\n \n         let text = macro_args.text();\n-        let without_parens = TextUnit::of_char('(')..text.len() - TextUnit::of_char(')');\n+        let without_parens = TextSize::of('(')..text.len() - TextSize::of(')');\n         text.slice(without_parens).to_string()\n     };\n "}, {"sha": "e598023b255751be0372b275273bfd6af12adda1", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -27,6 +27,6 @@ pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n \n     ctx.add_assist(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", |edit| {\n         edit.set_cursor(delete_from);\n-        edit.delete(TextRange::from_to(delete_from, delete_to));\n+        edit.delete(TextRange::new(delete_from, delete_to));\n     })\n }"}, {"sha": "2f02df3038c399695dca2fff30eb476973480e11", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -43,7 +43,7 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n             if let Some(last) = path.segment() {\n                 // Here we are assuming the assist will provide a correct use statement\n                 // so we can delete the path qualifier\n-                edit.delete(TextRange::from_to(\n+                edit.delete(TextRange::new(\n                     path.syntax().text_range().start(),\n                     last.syntax().text_range().start(),\n                 ));"}, {"sha": "3ffbe4c516acbf055c7013b0da7a1feedff56120", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -19,7 +19,7 @@ pub mod ast_transform;\n \n use ra_db::{FileId, FileRange};\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{TextRange, TextUnit};\n+use ra_syntax::{TextRange, TextSize};\n use ra_text_edit::TextEdit;\n \n pub(crate) use crate::assist_ctx::{Assist, AssistCtx, AssistHandler};\n@@ -51,7 +51,7 @@ impl AssistLabel {\n #[derive(Debug, Clone)]\n pub struct AssistAction {\n     pub edit: TextEdit,\n-    pub cursor_position: Option<TextUnit>,\n+    pub cursor_position: Option<TextSize>,\n     // FIXME: This belongs to `AssistLabel`\n     pub target: Option<TextRange>,\n     pub file: AssistFile,\n@@ -104,7 +104,7 @@ pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssi\n         .flat_map(|it| it.0)\n         .map(|it| it.into_resolved().unwrap())\n         .collect::<Vec<_>>();\n-    a.sort_by_key(|it| it.action.target.map_or(TextUnit::from(!0u32), |it| it.len()));\n+    a.sort_by_key(|it| it.action.target.map_or(TextSize::from(!0u32), |it| it.len()));\n     a\n }\n "}, {"sha": "fd4280de2df48c054176ef29443d762e55b92e0b", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -6,7 +6,7 @@ pub mod fixture;\n use std::{panic, sync::Arc};\n \n use ra_prof::profile;\n-use ra_syntax::{ast, Parse, SourceFile, TextRange, TextUnit};\n+use ra_syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n \n pub use crate::{\n     cancellation::Canceled,\n@@ -75,7 +75,7 @@ impl<T: salsa::Database> CheckCanceled for T {\n #[derive(Clone, Copy, Debug)]\n pub struct FilePosition {\n     pub file_id: FileId,\n-    pub offset: TextUnit,\n+    pub offset: TextSize,\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "e09cf3185686fc0933dd229b4ccf00da311b8b73", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -14,7 +14,7 @@ use ra_db::{FileId, FileRange};\n use ra_prof::profile;\n use ra_syntax::{\n     algo::{find_node_at_offset, skip_trivia_token},\n-    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -95,7 +95,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         let token = successors(Some(parent.with_value(token)), |token| {\n             let macro_call = token.value.ancestors().find_map(ast::MacroCall::cast)?;\n             let tt = macro_call.token_tree()?;\n-            if !token.value.text_range().is_subrange(&tt.syntax().text_range()) {\n+            if !tt.syntax().text_range().contains_range(token.value.text_range()) {\n                 return None;\n             }\n             let file_id = sa.expand(self.db, token.with_value(&macro_call))?;\n@@ -114,7 +114,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn descend_node_at_offset<N: ast::AstNode>(\n         &self,\n         node: &SyntaxNode,\n-        offset: TextUnit,\n+        offset: TextSize,\n     ) -> Option<N> {\n         // Handle macro token cases\n         node.token_at_offset(offset)\n@@ -142,7 +142,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn ancestors_at_offset_with_macros(\n         &self,\n         node: &SyntaxNode,\n-        offset: TextUnit,\n+        offset: TextSize,\n     ) -> impl Iterator<Item = SyntaxNode> + '_ {\n         node.token_at_offset(offset)\n             .map(|token| self.ancestors_with_macros(token.parent()))\n@@ -154,7 +154,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn find_node_at_offset_with_macros<N: AstNode>(\n         &self,\n         node: &SyntaxNode,\n-        offset: TextUnit,\n+        offset: TextSize,\n     ) -> Option<N> {\n         self.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n     }\n@@ -164,7 +164,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn find_node_at_offset_with_descend<N: AstNode>(\n         &self,\n         node: &SyntaxNode,\n-        offset: TextUnit,\n+        offset: TextSize,\n     ) -> Option<N> {\n         if let Some(it) = find_node_at_offset(&node, offset) {\n             return Some(it);\n@@ -255,7 +255,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         SemanticsScope { db: self.db, resolver }\n     }\n \n-    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextUnit) -> SemanticsScope<'db, DB> {\n+    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db, DB> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), Some(offset)).resolver;\n         SemanticsScope { db: self.db, resolver }\n@@ -271,7 +271,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.analyze2(src.as_ref(), None)\n     }\n \n-    fn analyze2(&self, src: InFile<&SyntaxNode>, offset: Option<TextUnit>) -> SourceAnalyzer {\n+    fn analyze2(&self, src: InFile<&SyntaxNode>, offset: Option<TextSize>) -> SourceAnalyzer {\n         let _p = profile(\"Semantics::analyze2\");\n \n         let container = match self.with_ctx(|ctx| ctx.find_container(src)) {\n@@ -463,7 +463,7 @@ fn original_range_opt(\n             return None;\n         }\n \n-        Some(first.with_value(first.value.text_range().extend_to(&last.value.text_range())))\n+        Some(first.with_value(first.value.text_range().cover(last.value.text_range())))\n     })?)\n }\n "}, {"sha": "59a3a17d28f8450ca606838a63502a3b270ead25", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -23,7 +23,7 @@ use hir_ty::{\n };\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode, TextRange, TextUnit,\n+    SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{\n@@ -50,7 +50,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         def: DefWithBodyId,\n         node: InFile<&SyntaxNode>,\n-        offset: Option<TextUnit>,\n+        offset: Option<TextSize>,\n     ) -> SourceAnalyzer {\n         let (body, source_map) = db.body_with_source_map(def);\n         let scopes = db.expr_scopes(def);\n@@ -318,7 +318,7 @@ fn scope_for_offset(\n     db: &dyn HirDatabase,\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    offset: InFile<TextUnit>,\n+    offset: InFile<TextSize>,\n ) -> Option<ScopeId> {\n     scopes\n         .scope_by_expr()\n@@ -354,7 +354,7 @@ fn adjust(\n     source_map: &BodySourceMap,\n     expr_range: TextRange,\n     file_id: HirFileId,\n-    offset: TextUnit,\n+    offset: TextSize,\n ) -> Option<ScopeId> {\n     let child_scopes = scopes\n         .scope_by_expr()\n@@ -369,15 +369,15 @@ fn adjust(\n             let node = source.value.to_node(&root);\n             Some((node.syntax().text_range(), scope))\n         })\n-        .filter(|(range, _)| {\n-            range.start() <= offset && range.is_subrange(&expr_range) && *range != expr_range\n+        .filter(|&(range, _)| {\n+            range.start() <= offset && expr_range.contains_range(range) && range != expr_range\n         });\n \n     child_scopes\n-        .max_by(|(r1, _), (r2, _)| {\n-            if r2.is_subrange(&r1) {\n+        .max_by(|&(r1, _), &(r2, _)| {\n+            if r1.contains_range(r2) {\n                 std::cmp::Ordering::Greater\n-            } else if r1.is_subrange(&r2) {\n+            } else if r2.contains_range(r1) {\n                 std::cmp::Ordering::Less\n             } else {\n                 r1.start().cmp(&r2.start())"}, {"sha": "2ccebda282070575389a203ddf94cb5094994224", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@\n use crate::db::AstDatabase;\n use crate::{\n     ast::{self, AstToken, HasStringValue},\n-    name, AstId, CrateId, MacroDefId, MacroDefKind, TextUnit,\n+    name, AstId, CrateId, MacroDefId, MacroDefKind, TextSize,\n };\n \n use crate::{quote, EagerMacroId, LazyMacroId, MacroCallId};\n@@ -127,7 +127,7 @@ fn stringify_expand(\n         let arg = loc.kind.arg(db).ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n         let macro_args = arg;\n         let text = macro_args.text();\n-        let without_parens = TextUnit::of_char('(')..text.len() - TextUnit::of_char(')');\n+        let without_parens = TextSize::of('(')..text.len() - TextSize::of(')');\n         text.slice(without_parens).to_string()\n     };\n "}, {"sha": "754a0f005bae26f766929fc4e8645a89a83c0037", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -22,7 +22,7 @@ use ra_db::{impl_intern_key, salsa, CrateId, FileId};\n use ra_syntax::{\n     algo,\n     ast::{self, AstNode},\n-    SyntaxNode, SyntaxToken, TextUnit,\n+    SyntaxNode, SyntaxToken, TextSize,\n };\n \n use crate::ast_id_map::FileAstId;\n@@ -348,7 +348,7 @@ impl<N: AstNode> AstId<N> {\n ///\n /// * `InFile<SyntaxNode>` -- syntax node in a file\n /// * `InFile<ast::FnDef>` -- ast node in a file\n-/// * `InFile<TextUnit>` -- offset in a file\n+/// * `InFile<TextSize>` -- offset in a file\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n pub struct InFile<T> {\n     pub file_id: HirFileId,"}, {"sha": "b6a96bb5ca5b512ae8dc31b545649f5768198d5b", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -117,7 +117,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let macro_prefix = if node.file_id != file_id.into() { \"!\" } else { \"\" };\n             format_to!(\n                 buf,\n-                \"{}{} '{}': {}\\n\",\n+                \"{}{:?} '{}': {}\\n\",\n                 macro_prefix,\n                 range,\n                 ellipsize(text, 15),\n@@ -134,7 +134,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n                 let macro_prefix = if src_ptr.file_id != file_id.into() { \"!\" } else { \"\" };\n                 format_to!(\n                     buf,\n-                    \"{}{}: expected {}, got {}\\n\",\n+                    \"{}{:?}: expected {}, got {}\\n\",\n                     macro_prefix,\n                     range,\n                     mismatch.expected.display(&db),"}, {"sha": "780a03c1380e5cbf6fca89996b78eee1d614c489", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -126,7 +126,7 @@ impl FnCallNode {\n                     ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n                     ast::MethodCallExpr(it) => {\n                         let arg_list = it.arg_list()?;\n-                        if !syntax.text_range().is_subrange(&arg_list.syntax().text_range()) {\n+                        if !arg_list.syntax().text_range().contains_range(syntax.text_range()) {\n                             return None;\n                         }\n                         Some(FnCallNode::MethodCallExpr(it))"}, {"sha": "306ce96dc83e38d991964ba23d2c85fb57a06a61", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -97,7 +97,7 @@ fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n             }\n         };\n         if let Some(body) = loop_body {\n-            if leaf.text_range().is_subrange(&body.syntax().text_range()) {\n+            if body.syntax().text_range().contains_range(leaf.text_range()) {\n                 return true;\n             }\n         }"}, {"sha": "d6a37d720e9cd5aff6be2ae7fdfa89097101621d", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@\n \n use ra_syntax::{\n     ast::{self, AstNode},\n-    TextRange, TextUnit,\n+    TextRange, TextSize,\n };\n use ra_text_edit::TextEdit;\n \n@@ -115,7 +115,7 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n fn get_receiver_text(receiver: &ast::Expr, receiver_is_ambiguous_float_literal: bool) -> String {\n     if receiver_is_ambiguous_float_literal {\n         let text = receiver.syntax().text();\n-        let without_dot = ..text.len() - TextUnit::of_char('.');\n+        let without_dot = ..text.len() - TextSize::of('.');\n         text.slice(without_dot).to_string()\n     } else {\n         receiver.to_string()\n@@ -143,7 +143,7 @@ fn postfix_snippet(\n     let edit = {\n         let receiver_syntax = receiver.syntax();\n         let receiver_range = ctx.sema.original_range(receiver_syntax).range;\n-        let delete_range = TextRange::from_to(receiver_range.start(), ctx.source_range().end());\n+        let delete_range = TextRange::new(receiver_range.start(), ctx.source_range().end());\n         TextEdit::replace(delete_range, snippet.to_string())\n     };\n     CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label)"}, {"sha": "e2a8c59cdeec621844b9fa4185bbb9015a50b7f4", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -141,7 +141,7 @@ fn add_function_impl(\n     } else {\n         CompletionItemKind::Function\n     };\n-    let range = TextRange::from_to(fn_def_node.text_range().start(), ctx.source_range().end());\n+    let range = TextRange::new(fn_def_node.text_range().start(), ctx.source_range().end());\n \n     match ctx.config.snippet_cap {\n         Some(cap) => {\n@@ -167,7 +167,7 @@ fn add_type_alias_impl(\n \n     let snippet = format!(\"type {} = \", alias_name);\n \n-    let range = TextRange::from_to(type_def_node.text_range().start(), ctx.source_range().end());\n+    let range = TextRange::new(type_def_node.text_range().start(), ctx.source_range().end());\n \n     CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n         .text_edit(TextEdit::replace(range, snippet))\n@@ -189,7 +189,7 @@ fn add_const_impl(\n         let snippet = make_const_compl_syntax(&const_.source(ctx.db).value);\n \n         let range =\n-            TextRange::from_to(const_def_node.text_range().start(), ctx.source_range().end());\n+            TextRange::new(const_def_node.text_range().start(), ctx.source_range().end());\n \n         CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n             .text_edit(TextEdit::replace(range, snippet))\n@@ -216,7 +216,7 @@ fn make_const_compl_syntax(const_: &ast::ConstDef) -> String {\n         .map_or(const_end, |f| f.text_range().start());\n \n     let len = end - start;\n-    let range = TextRange::from_to(0.into(), len);\n+    let range = TextRange::new(0.into(), len);\n \n     let syntax = const_.syntax().text().slice(range).to_string();\n "}, {"sha": "5f2797e4188fa077455ac173da514fcf9455c6aa", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n     ast, AstNode,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n use ra_text_edit::AtomTextEdit;\n \n@@ -20,7 +20,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) sema: Semantics<'a, RootDatabase>,\n     pub(super) db: &'a RootDatabase,\n     pub(super) config: &'a CompletionConfig,\n-    pub(super) offset: TextUnit,\n+    pub(super) offset: TextSize,\n     /// The token before the cursor, in the original file.\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n@@ -167,7 +167,7 @@ impl<'a> CompletionContext<'a> {\n         match self.token.kind() {\n             // workaroud when completion is triggered by trigger characters.\n             IDENT => self.original_token.text_range(),\n-            _ => TextRange::offset_len(self.offset, 0.into()),\n+            _ => TextRange::empty(self.offset),\n         }\n     }\n \n@@ -190,7 +190,7 @@ impl<'a> CompletionContext<'a> {\n         &mut self,\n         original_file: &SyntaxNode,\n         file_with_fake_ident: SyntaxNode,\n-        offset: TextUnit,\n+        offset: TextSize,\n     ) {\n         // First, let's try to complete a reference to some declaration.\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n@@ -224,7 +224,8 @@ impl<'a> CompletionContext<'a> {\n                 }\n                 if let Some(let_stmt) = bind_pat.syntax().ancestors().find_map(ast::LetStmt::cast) {\n                     if let Some(pat) = let_stmt.pat() {\n-                        if bind_pat.syntax().text_range().is_subrange(&pat.syntax().text_range()) {\n+                        if pat.syntax().text_range().contains_range(bind_pat.syntax().text_range())\n+                        {\n                             self.is_pat_binding_or_const = false;\n                         }\n                     }\n@@ -246,7 +247,7 @@ impl<'a> CompletionContext<'a> {\n         &mut self,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n-        offset: TextUnit,\n+        offset: TextSize,\n     ) {\n         self.name_ref_syntax =\n             find_node_at_offset(&original_file, name_ref.syntax().text_range().start());"}, {"sha": "adfb1b9b2d6d7f42670e870fd37ac52948e0f40e", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -171,7 +171,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     if single_use_tree.path()?.segment()?.syntax().first_child_or_token()?.kind() == T![self] {\n         let start = use_tree_list_node.prev_sibling_or_token()?.text_range().start();\n         let end = use_tree_list_node.text_range().end();\n-        let range = TextRange::from_to(start, end);\n+        let range = TextRange::new(start, end);\n         return Some(TextEdit::delete(range));\n     }\n     None"}, {"sha": "9f329b5d37d84297fab7cf47bd980209f607fa18", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     Direction, NodeOrToken,\n     SyntaxKind::{self, *},\n-    SyntaxNode, SyntaxToken, TextRange, TextUnit, TokenAtOffset, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, T,\n };\n \n use crate::FileRange;\n@@ -121,10 +121,10 @@ fn extend_tokens_from_range(\n     let mut first_token = skip_trivia_token(first_token, Direction::Next)?;\n     let mut last_token = skip_trivia_token(last_token, Direction::Prev)?;\n \n-    while !first_token.text_range().is_subrange(&original_range) {\n+    while !original_range.contains_range(first_token.text_range()) {\n         first_token = skip_trivia_token(first_token.next_token()?, Direction::Next)?;\n     }\n-    while !last_token.text_range().is_subrange(&original_range) {\n+    while !original_range.contains_range(last_token.text_range()) {\n         last_token = skip_trivia_token(last_token.prev_token()?, Direction::Prev)?;\n     }\n \n@@ -161,8 +161,8 @@ fn extend_tokens_from_range(\n     .take_while(validate)\n     .last()?;\n \n-    let range = first.text_range().extend_to(&last.text_range());\n-    if original_range.is_subrange(&range) && original_range != range {\n+    let range = first.text_range().cover(last.text_range());\n+    if range.contains_range(original_range) && original_range != range {\n         Some(range)\n     } else {\n         None\n@@ -176,7 +176,7 @@ fn shallowest_node(node: &SyntaxNode) -> SyntaxNode {\n \n fn extend_single_word_in_comment_or_string(\n     leaf: &SyntaxToken,\n-    offset: TextUnit,\n+    offset: TextSize,\n ) -> Option<TextRange> {\n     let text: &str = leaf.text();\n     let cursor_position: u32 = (offset - leaf.text_range().start()).into();\n@@ -190,35 +190,35 @@ fn extend_single_word_in_comment_or_string(\n     let start_idx = before.rfind(non_word_char)? as u32;\n     let end_idx = after.find(non_word_char).unwrap_or_else(|| after.len()) as u32;\n \n-    let from: TextUnit = (start_idx + 1).into();\n-    let to: TextUnit = (cursor_position + end_idx).into();\n+    let from: TextSize = (start_idx + 1).into();\n+    let to: TextSize = (cursor_position + end_idx).into();\n \n-    let range = TextRange::from_to(from, to);\n+    let range = TextRange::new(from, to);\n     if range.is_empty() {\n         None\n     } else {\n         Some(range + leaf.text_range().start())\n     }\n }\n \n-fn extend_ws(root: &SyntaxNode, ws: SyntaxToken, offset: TextUnit) -> TextRange {\n+fn extend_ws(root: &SyntaxNode, ws: SyntaxToken, offset: TextSize) -> TextRange {\n     let ws_text = ws.text();\n-    let suffix = TextRange::from_to(offset, ws.text_range().end()) - ws.text_range().start();\n-    let prefix = TextRange::from_to(ws.text_range().start(), offset) - ws.text_range().start();\n+    let suffix = TextRange::new(offset, ws.text_range().end()) - ws.text_range().start();\n+    let prefix = TextRange::new(ws.text_range().start(), offset) - ws.text_range().start();\n     let ws_suffix = &ws_text.as_str()[suffix];\n     let ws_prefix = &ws_text.as_str()[prefix];\n     if ws_text.contains('\\n') && !ws_suffix.contains('\\n') {\n         if let Some(node) = ws.next_sibling_or_token() {\n             let start = match ws_prefix.rfind('\\n') {\n-                Some(idx) => ws.text_range().start() + TextUnit::from((idx + 1) as u32),\n+                Some(idx) => ws.text_range().start() + TextSize::from((idx + 1) as u32),\n                 None => node.text_range().start(),\n             };\n             let end = if root.text().char_at(node.text_range().end()) == Some('\\n') {\n-                node.text_range().end() + TextUnit::of_char('\\n')\n+                node.text_range().end() + TextSize::of('\\n')\n             } else {\n                 node.text_range().end()\n             };\n-            return TextRange::from_to(start, end);\n+            return TextRange::new(start, end);\n         }\n     }\n     ws.text_range()\n@@ -270,13 +270,10 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n             .filter(|node| is_single_line_ws(node))\n             .unwrap_or(delimiter_node);\n \n-        return Some(TextRange::from_to(node.text_range().start(), final_node.text_range().end()));\n+        return Some(TextRange::new(node.text_range().start(), final_node.text_range().end()));\n     }\n     if let Some(delimiter_node) = nearby_delimiter(delimiter, node, Direction::Prev) {\n-        return Some(TextRange::from_to(\n-            delimiter_node.text_range().start(),\n-            node.text_range().end(),\n-        ));\n+        return Some(TextRange::new(delimiter_node.text_range().start(), node.text_range().end()));\n     }\n \n     None\n@@ -286,10 +283,7 @@ fn extend_comments(comment: ast::Comment) -> Option<TextRange> {\n     let prev = adj_comments(&comment, Direction::Prev);\n     let next = adj_comments(&comment, Direction::Next);\n     if prev != next {\n-        Some(TextRange::from_to(\n-            prev.syntax().text_range().start(),\n-            next.syntax().text_range().end(),\n-        ))\n+        Some(TextRange::new(prev.syntax().text_range().start(), next.syntax().text_range().end()))\n     } else {\n         None\n     }"}, {"sha": "034c4c7d476a479ecef4b91057282882944dcde6", "filename": "crates/ra_ide/src/folding_ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -141,7 +141,7 @@ fn contiguous_range_for_group_unless(\n     }\n \n     if first != &last {\n-        Some(TextRange::from_to(first.text_range().start(), last.text_range().end()))\n+        Some(TextRange::new(first.text_range().start(), last.text_range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n@@ -187,7 +187,7 @@ fn contiguous_range_for_comment(\n     }\n \n     if first != last {\n-        Some(TextRange::from_to(\n+        Some(TextRange::new(\n             first.syntax().text_range().start(),\n             last.syntax().text_range().end(),\n         ))"}, {"sha": "fcc2ab7fba6e439f6fba5fc7d6fee5109690a0ab", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -275,7 +275,7 @@ mod tests {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(hover.range, TextRange::from_to(95.into(), 100.into()));\n+        assert_eq!(hover.range, TextRange::new(95.into(), 100.into()));\n         assert_eq!(trim_markup_opt(hover.info.first()), Some(\"u32\"));\n     }\n "}, {"sha": "040846ec37b4ab421d7e92d8ef527997a5b33160", "filename": "crates/ra_ide/src/join_lines.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, WHITESPACE},\n-    SyntaxNode, SyntaxToken, TextRange, TextUnit, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n@@ -19,7 +19,7 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n             None => return TextEditBuilder::default().finish(),\n             Some(pos) => pos,\n         };\n-        TextRange::offset_len(range.start() + pos, TextUnit::of_char('\\n'))\n+        TextRange::at(range.start() + pos, TextSize::of('\\n'))\n     } else {\n         range\n     };\n@@ -30,13 +30,13 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n     };\n     let mut edit = TextEditBuilder::default();\n     for token in node.descendants_with_tokens().filter_map(|it| it.into_token()) {\n-        let range = match range.intersection(&token.text_range()) {\n+        let range = match range.intersect(token.text_range()) {\n             Some(range) => range,\n             None => continue,\n         } - token.text_range().start();\n         let text = token.text();\n         for (pos, _) in text[range].bytes().enumerate().filter(|&(_, b)| b == b'\\n') {\n-            let pos: TextUnit = (pos as u32).into();\n+            let pos: TextSize = (pos as u32).into();\n             let off = token.text_range().start() + range.start() + pos;\n             if !edit.invalidates_offset(off) {\n                 remove_newline(&mut edit, &token, off);\n@@ -47,16 +47,16 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n     edit.finish()\n }\n \n-fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextUnit) {\n+fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextSize) {\n     if token.kind() != WHITESPACE || token.text().bytes().filter(|&b| b == b'\\n').count() != 1 {\n         // The node is either the first or the last in the file\n-        let suff = &token.text()[TextRange::from_to(\n-            offset - token.text_range().start() + TextUnit::of_char('\\n'),\n-            TextUnit::of_str(token.text()),\n+        let suff = &token.text()[TextRange::new(\n+            offset - token.text_range().start() + TextSize::of('\\n'),\n+            TextSize::of(token.text().as_str()),\n         )];\n         let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n \n-        edit.replace(TextRange::offset_len(offset, ((spaces + 1) as u32).into()), \" \".to_string());\n+        edit.replace(TextRange::at(offset, ((spaces + 1) as u32).into()), \" \".to_string());\n         return;\n     }\n \n@@ -65,7 +65,7 @@ fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextU\n     let next = token.next_sibling_or_token().unwrap();\n     if is_trailing_comma(prev.kind(), next.kind()) {\n         // Removes: trailing comma, newline (incl. surrounding whitespace)\n-        edit.delete(TextRange::from_to(prev.text_range().start(), token.text_range().end()));\n+        edit.delete(TextRange::new(prev.text_range().start(), token.text_range().end()));\n         return;\n     }\n     if prev.kind() == T![,] && next.kind() == T!['}'] {\n@@ -76,7 +76,7 @@ fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextU\n             \" \"\n         };\n         edit.replace(\n-            TextRange::from_to(prev.text_range().start(), token.text_range().end()),\n+            TextRange::new(prev.text_range().start(), token.text_range().end()),\n             space.to_string(),\n         );\n         return;\n@@ -87,9 +87,9 @@ fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextU\n         next.as_token().cloned().and_then(ast::Comment::cast),\n     ) {\n         // Removes: newline (incl. surrounding whitespace), start of the next comment\n-        edit.delete(TextRange::from_to(\n+        edit.delete(TextRange::new(\n             token.text_range().start(),\n-            next.syntax().text_range().start() + TextUnit::of_str(next.prefix()),\n+            next.syntax().text_range().start() + TextSize::of(next.prefix()),\n         ));\n         return;\n     }\n@@ -420,10 +420,10 @@ fn foo() {\n         check_join_lines(\n             r\"\n <|>use ra_syntax::{\n-    TextUnit, TextRange,\n+    TextSize, TextRange,\n };\",\n             r\"\n-<|>use ra_syntax::{TextUnit, TextRange,\n+<|>use ra_syntax::{TextSize, TextRange,\n };\",\n         );\n     }\n@@ -434,11 +434,11 @@ fn foo() {\n         check_join_lines(\n             r\"\n use ra_syntax::{\n-<|>    TextUnit, TextRange\n+<|>    TextSize, TextRange\n };\",\n             r\"\n use ra_syntax::{\n-<|>    TextUnit, TextRange};\",\n+<|>    TextSize, TextRange};\",\n         );\n     }\n \n@@ -448,11 +448,11 @@ use ra_syntax::{\n         check_join_lines(\n             r\"\n use ra_syntax::{\n-<|>    TextUnit, TextRange,\n+<|>    TextSize, TextRange,\n };\",\n             r\"\n use ra_syntax::{\n-<|>    TextUnit, TextRange};\",\n+<|>    TextSize, TextRange};\",\n         );\n     }\n "}, {"sha": "09f602fe1b2266495dd0926120be39639097344b", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -60,7 +60,7 @@ use ra_ide_db::{\n     symbol_index::{self, FileSymbol},\n     LineIndexDatabase,\n };\n-use ra_syntax::{SourceFile, TextRange, TextUnit};\n+use ra_syntax::{SourceFile, TextRange, TextSize};\n \n use crate::display::ToNav;\n \n@@ -265,7 +265,7 @@ impl Analysis {\n \n     /// Returns position of the matching brace (all types of braces are\n     /// supported).\n-    pub fn matching_brace(&self, position: FilePosition) -> Cancelable<Option<TextUnit>> {\n+    pub fn matching_brace(&self, position: FilePosition) -> Cancelable<Option<TextSize>> {\n         self.with_db(|db| {\n             let parse = db.parse(position.file_id);\n             let file = parse.tree();"}, {"sha": "b8534870604fa7cf7884b861b081a220db6f8e6f", "filename": "crates/ra_ide/src/matching_brace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,8 +1,8 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{ast::AstNode, SourceFile, SyntaxKind, TextUnit, T};\n+use ra_syntax::{ast::AstNode, SourceFile, SyntaxKind, TextSize, T};\n \n-pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n+pub fn matching_brace(file: &SourceFile, offset: TextSize) -> Option<TextSize> {\n     const BRACES: &[SyntaxKind] =\n         &[T!['{'], T!['}'], T!['['], T![']'], T!['('], T![')'], T![<], T![>]];\n     let (brace_node, brace_idx) = file"}, {"sha": "1c64b3eb965211585665a8e2c8b1e53897266fdf", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -54,15 +54,15 @@ fn source_edit_from_reference(reference: Reference, new_name: &str) -> SourceFil\n         ReferenceKind::StructFieldShorthandForField => {\n             replacement_text.push_str(new_name);\n             replacement_text.push_str(\": \");\n-            TextRange::from_to(\n+            TextRange::new(\n                 reference.file_range.range.start(),\n                 reference.file_range.range.start(),\n             )\n         }\n         ReferenceKind::StructFieldShorthandForLocal => {\n             replacement_text.push_str(\": \");\n             replacement_text.push_str(new_name);\n-            TextRange::from_to(reference.file_range.range.end(), reference.file_range.range.end())\n+            TextRange::new(reference.file_range.range.end(), reference.file_range.range.end())\n         }\n         _ => {\n             replacement_text.push_str(new_name);"}, {"sha": "71b0e8f757eda73f41c5bc92efcf599f6c8bbef0", "filename": "crates/ra_ide/src/source_change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsource_change.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -6,7 +6,7 @@\n use ra_db::RelativePathBuf;\n use ra_text_edit::TextEdit;\n \n-use crate::{FileId, FilePosition, SourceRootId, TextUnit};\n+use crate::{FileId, FilePosition, SourceRootId, TextSize};\n \n #[derive(Debug)]\n pub struct SourceChange {\n@@ -104,7 +104,7 @@ pub enum FileSystemEdit {\n pub(crate) struct SingleFileChange {\n     pub label: String,\n     pub edit: TextEdit,\n-    pub cursor_position: Option<TextUnit>,\n+    pub cursor_position: Option<TextSize>,\n }\n \n impl SingleFileChange {"}, {"sha": "6f02614a602d4b7fd17a1c03ec1592328400c385", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -61,16 +61,16 @@ impl HighlightedRangeStack {\n         let prev = self.stack.last_mut().unwrap();\n         let needs_flattening = !children.is_empty()\n             && !prev.is_empty()\n-            && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n+            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n         if !needs_flattening {\n             prev.extend(children);\n         } else {\n             let mut parent = prev.pop().unwrap();\n             for ele in children {\n-                assert!(ele.range.is_subrange(&parent.range));\n+                assert!(parent.range.contains_range(ele.range));\n                 let mut cloned = parent.clone();\n-                parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n-                cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n+                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n+                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n                 if !parent.range.is_empty() {\n                     prev.push(parent);\n                 }\n@@ -152,7 +152,7 @@ pub(crate) fn highlight(\n         };\n \n         // Element outside of the viewport, no need to highlight\n-        if range_to_highlight.intersection(&event_range).is_none() {\n+        if range_to_highlight.intersect(event_range).is_none() {\n             continue;\n         }\n \n@@ -309,7 +309,7 @@ fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n         }\n     }\n \n-    Some(TextRange::from_to(range_start, range_end))\n+    Some(TextRange::new(range_start, range_end))\n }\n \n fn highlight_element("}, {"sha": "4f17d1040273eaf81182ae8003de789be72a8c2e", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,7 +1,7 @@\n //! Renders a bit of code as HTML.\n \n use ra_db::SourceDatabase;\n-use ra_syntax::{AstNode, TextUnit};\n+use ra_syntax::{AstNode, TextSize};\n \n use crate::{FileId, RootDatabase};\n \n@@ -23,17 +23,18 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n \n     let ranges = highlight(db, file_id, None);\n     let text = parse.tree().syntax().to_string();\n-    let mut prev_pos = TextUnit::from(0);\n+    let mut prev_pos = TextSize::from(0);\n     let mut buf = String::new();\n     buf.push_str(&STYLE);\n     buf.push_str(\"<pre><code>\");\n+    // TODO: unusize\n     for range in &ranges {\n         if range.range.start() > prev_pos {\n-            let curr = &text[prev_pos.to_usize()..range.range.start().to_usize()];\n+            let curr = &text[usize::from(prev_pos)..usize::from(range.range.start())];\n             let text = html_escape(curr);\n             buf.push_str(&text);\n         }\n-        let curr = &text[range.range.start().to_usize()..range.range.end().to_usize()];\n+        let curr = &text[usize::from(range.range.start())..usize::from(range.range.end())];\n \n         let class = range.highlight.to_string().replace('.', \" \");\n         let color = match (rainbow, range.binding_hash) {\n@@ -47,7 +48,7 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         prev_pos = range.range.end();\n     }\n     // Add the remaining (non-highlighted) text\n-    let curr = &text[prev_pos.to_usize()..];\n+    let curr = &text[usize::from(prev_pos)..];\n     let text = html_escape(curr);\n     buf.push_str(&text);\n     buf.push_str(\"</code></pre>\");"}, {"sha": "a8a97a69f523f3dbe3f19f6b28b0bf55f2e3bd95", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -5,7 +5,7 @@ use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo, AstNode, NodeOrToken, SourceFile,\n     SyntaxKind::{RAW_STRING, STRING},\n-    SyntaxToken, TextRange, TextUnit,\n+    SyntaxToken, TextRange, TextSize,\n };\n \n pub use ra_db::FileId;\n@@ -66,13 +66,13 @@ fn syntax_tree_for_token(node: &SyntaxToken, text_range: TextRange) -> Option<St\n     let len = len.min(node_len);\n \n     // Ensure our slice is inside the actual string\n-    let end = if start + len < TextUnit::of_str(&text) {\n+    let end = if start + len < TextSize::of(&text) {\n         start + len\n     } else {\n-        TextUnit::of_str(&text) - start\n+        TextSize::of(&text) - start\n     };\n \n-    let text = &text[TextRange::from_to(start, end)];\n+    let text = &text[TextRange::new(start, end)];\n \n     // Remove possible extra string quotes from the start\n     // and the end of the string"}, {"sha": "f14533e14bb7295d74f2dfba982e78ef349b5dd3", "filename": "crates/ra_ide/src/test_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,11 +1,11 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{SourceFile, TextUnit};\n+use ra_syntax::{SourceFile, TextSize};\n use ra_text_edit::TextEdit;\n \n pub use test_utils::*;\n \n-pub fn check_action<F: Fn(&SourceFile, TextUnit) -> Option<TextEdit>>(\n+pub fn check_action<F: Fn(&SourceFile, TextSize) -> Option<TextEdit>>(\n     before: &str,\n     after: &str,\n     f: F,"}, {"sha": "98af79dff9696c522215c27813aa29a54b9a68e4", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -21,7 +21,7 @@ use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstToken},\n-    AstNode, SourceFile, TextRange, TextUnit,\n+    AstNode, SourceFile, TextRange, TextSize,\n };\n use ra_text_edit::TextEdit;\n \n@@ -45,7 +45,7 @@ pub(crate) fn on_char_typed(\n \n fn on_char_typed_inner(\n     file: &SourceFile,\n-    offset: TextUnit,\n+    offset: TextSize,\n     char_typed: char,\n ) -> Option<SingleFileChange> {\n     assert!(TRIGGER_CHARS.contains(char_typed));\n@@ -60,7 +60,7 @@ fn on_char_typed_inner(\n /// Returns an edit which should be applied after `=` was typed. Primarily,\n /// this works when adding `let =`.\n // FIXME: use a snippet completion instead of this hack here.\n-fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<SingleFileChange> {\n     assert_eq!(file.syntax().text().char_at(offset), Some('='));\n     let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.semicolon_token().is_some() {\n@@ -86,7 +86,7 @@ fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange>\n }\n \n /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n-fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<SingleFileChange> {\n     assert_eq!(file.syntax().text().char_at(offset), Some('.'));\n     let whitespace =\n         file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;\n@@ -96,34 +96,34 @@ fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange>\n         let newline = text.rfind('\\n')?;\n         &text[newline + 1..]\n     };\n-    let current_indent_len = TextUnit::of_str(current_indent);\n+    let current_indent_len = TextSize::of(current_indent);\n \n     // Make sure dot is a part of call chain\n     let field_expr = ast::FieldExpr::cast(whitespace.syntax().parent())?;\n     let prev_indent = leading_indent(field_expr.syntax())?;\n     let target_indent = format!(\"    {}\", prev_indent);\n-    let target_indent_len = TextUnit::of_str(&target_indent);\n+    let target_indent_len = TextSize::of(&target_indent);\n     if current_indent_len == target_indent_len {\n         return None;\n     }\n \n     Some(SingleFileChange {\n         label: \"reindent dot\".to_string(),\n         edit: TextEdit::replace(\n-            TextRange::from_to(offset - current_indent_len, offset),\n+            TextRange::new(offset - current_indent_len, offset),\n             target_indent,\n         ),\n         cursor_position: Some(\n-            offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n+            offset + target_indent_len - current_indent_len + TextSize::of('.'),\n         ),\n     })\n }\n \n /// Adds a space after an arrow when `fn foo() { ... }` is turned into `fn foo() -> { ... }`\n-fn on_arrow_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+fn on_arrow_typed(file: &SourceFile, offset: TextSize) -> Option<SingleFileChange> {\n     let file_text = file.syntax().text();\n     assert_eq!(file_text.char_at(offset), Some('>'));\n-    let after_arrow = offset + TextUnit::of_char('>');\n+    let after_arrow = offset + TextSize::of('>');\n     if file_text.char_at(after_arrow) != Some('{') {\n         return None;\n     }"}, {"sha": "30c8c557201ea6c0a353bc6ea10d118d8cde59f0", "filename": "crates/ra_ide/src/typing/on_enter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n     ast::{self, AstToken},\n     AstNode, SmolStr, SourceFile,\n     SyntaxKind::*,\n-    SyntaxToken, TextUnit, TokenAtOffset,\n+    SyntaxToken, TextSize, TokenAtOffset,\n };\n use ra_text_edit::TextEdit;\n \n@@ -28,7 +28,7 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Sour\n \n     let prefix = comment.prefix();\n     let comment_range = comment.syntax().text_range();\n-    if position.offset < comment_range.start() + TextUnit::of_str(prefix) {\n+    if position.offset < comment_range.start() + TextSize::of(prefix) {\n         return None;\n     }\n \n@@ -39,7 +39,7 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Sour\n \n     let indent = node_indent(&file, comment.syntax())?;\n     let inserted = format!(\"\\n{}{} \", indent, prefix);\n-    let cursor_position = position.offset + TextUnit::of_str(&inserted);\n+    let cursor_position = position.offset + TextSize::of(&inserted);\n     let edit = TextEdit::insert(position.offset, inserted);\n \n     Some("}, {"sha": "7794dc9fd76c5c46b60c19322b3473b09ed554a0", "filename": "crates/ra_ide_db/src/line_index.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,14 +1,14 @@\n-//! `LineIndex` maps flat `TextUnit` offsets into `(Line, Column)`\n+//! `LineIndex` maps flat `TextSize` offsets into `(Line, Column)`\n //! representation.\n use std::iter;\n-\n-use ra_syntax::{TextRange, TextUnit};\n+// TODO: un TextSize\n+use ra_syntax::{TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use superslice::Ext;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n-    pub(crate) newlines: Vec<TextUnit>,\n+    pub(crate) newlines: Vec<TextSize>,\n     pub(crate) utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n }\n \n@@ -22,12 +22,12 @@ pub struct LineCol {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub(crate) struct Utf16Char {\n-    pub(crate) start: TextUnit,\n-    pub(crate) end: TextUnit,\n+    pub(crate) start: TextSize,\n+    pub(crate) end: TextSize,\n }\n \n impl Utf16Char {\n-    fn len(&self) -> TextUnit {\n+    fn len(&self) -> TextSize {\n         self.end - self.start\n     }\n }\n@@ -42,7 +42,7 @@ impl LineIndex {\n         let mut curr_col = 0.into();\n         let mut line = 0;\n         for c in text.chars() {\n-            curr_row += TextUnit::of_char(c);\n+            curr_row += TextSize::of(c);\n             if c == '\\n' {\n                 newlines.push(curr_row);\n \n@@ -58,8 +58,8 @@ impl LineIndex {\n                 continue;\n             }\n \n-            let char_len = TextUnit::of_char(c);\n-            if char_len > TextUnit::from_usize(1) {\n+            let char_len = TextSize::of(c);\n+            if char_len > TextSize::from_usize(1) {\n                 utf16_chars.push(Utf16Char { start: curr_col, end: curr_col + char_len });\n             }\n \n@@ -74,15 +74,15 @@ impl LineIndex {\n         LineIndex { newlines, utf16_lines }\n     }\n \n-    pub fn line_col(&self, offset: TextUnit) -> LineCol {\n+    pub fn line_col(&self, offset: TextSize) -> LineCol {\n         let line = self.newlines.upper_bound(&offset) - 1;\n         let line_start_offset = self.newlines[line];\n         let col = offset - line_start_offset;\n \n         LineCol { line: line as u32, col_utf16: self.utf8_to_utf16_col(line as u32, col) as u32 }\n     }\n \n-    pub fn offset(&self, line_col: LineCol) -> TextUnit {\n+    pub fn offset(&self, line_col: LineCol) -> TextSize {\n         //FIXME: return Result\n         let col = self.utf16_to_utf8_col(line_col.line, line_col.col_utf16);\n         self.newlines[line_col.line as usize] + col\n@@ -97,35 +97,35 @@ impl LineIndex {\n \n         all.clone()\n             .zip(all.skip(1))\n-            .map(|(lo, hi)| TextRange::from_to(lo, hi))\n+            .map(|(lo, hi)| TextRange::new(lo, hi))\n             .filter(|it| !it.is_empty())\n     }\n \n-    fn utf8_to_utf16_col(&self, line: u32, col: TextUnit) -> usize {\n+    fn utf8_to_utf16_col(&self, line: u32, col: TextSize) -> usize {\n         if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n             let mut correction = 0;\n             for c in utf16_chars {\n                 if col >= c.end {\n-                    correction += c.len().to_usize() - 1;\n+                    correction += usize::from(c.len()) - 1;\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n                     break;\n                 }\n             }\n \n-            col.to_usize() - correction\n+            usize::from(col) - correction\n         } else {\n-            col.to_usize()\n+            usize::from(col)\n         }\n     }\n \n-    fn utf16_to_utf8_col(&self, line: u32, col: u32) -> TextUnit {\n-        let mut col: TextUnit = col.into();\n+    fn utf16_to_utf8_col(&self, line: u32, col: u32) -> TextSize {\n+        let mut col: TextSize = col.into();\n         if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n             for c in utf16_chars {\n                 if col >= c.start {\n-                    col += c.len() - TextUnit::from_usize(1);\n+                    col += c.len() - TextSize::from_usize(1);\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -200,10 +200,10 @@ const C: char = '\u30e1';\n         assert_eq!(col_index.utf8_to_utf16_col(1, 22.into()), 20);\n \n         // UTF-16 to UTF-8, no changes\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextUnit::from(15));\n+        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n \n         // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextUnit::from(21));\n+        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21));\n     }\n \n     #[test]\n@@ -228,18 +228,18 @@ const C: char = \\\"\u30e1 \u30e1\\\";\n         assert!(col_index.utf8_to_utf16_col(2, 15.into()) == 15);\n \n         // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextUnit::from_usize(15));\n+        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from_usize(15));\n \n-        assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextUnit::from_usize(20));\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextUnit::from_usize(23));\n+        assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextSize::from_usize(20));\n+        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from_usize(23));\n \n-        assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextUnit::from_usize(15));\n+        assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextSize::from_usize(15));\n     }\n \n     #[test]\n     fn test_splitlines() {\n         fn r(lo: u32, hi: u32) -> TextRange {\n-            TextRange::from_to(lo.into(), hi.into())\n+            TextRange::new(lo.into(), hi.into())\n         }\n \n         let text = \"a\\nbb\\nccc\\n\";"}, {"sha": "f050fe77ffbb52ed7ae6307ff648ba51868794d3", "filename": "crates/ra_ide_db/src/line_index_utils.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,20 +1,20 @@\n //! Code actions can specify desirable final position of the cursor.\n //!\n-//! The position is specified as a `TextUnit` in the final file. We need to send\n+//! The position is specified as a `TextSize` in the final file. We need to send\n //! it in `(Line, Column)` coordinate though. However, we only have a LineIndex\n //! for a file pre-edit!\n //!\n //! Code in this module applies this \"to (Line, Column) after edit\"\n //! transformation.\n \n-use ra_syntax::{TextRange, TextUnit};\n+use ra_syntax::{TextRange, TextSize};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n \n use crate::line_index::{LineCol, LineIndex, Utf16Char};\n \n pub fn translate_offset_with_edit(\n     line_index: &LineIndex,\n-    offset: TextUnit,\n+    offset: TextSize,\n     text_edit: &TextEdit,\n ) -> LineCol {\n     let mut state = Edits::from_text_edit(&text_edit);\n@@ -84,15 +84,15 @@ pub fn translate_offset_with_edit(\n \n #[derive(Debug, Clone)]\n enum Step {\n-    Newline(TextUnit),\n+    Newline(TextSize),\n     Utf16Char(TextRange),\n }\n \n #[derive(Debug)]\n struct LineIndexStepIter<'a> {\n     line_index: &'a LineIndex,\n     next_newline_idx: usize,\n-    utf16_chars: Option<(TextUnit, std::slice::Iter<'a, Utf16Char>)>,\n+    utf16_chars: Option<(TextSize, std::slice::Iter<'a, Utf16Char>)>,\n }\n \n impl LineIndexStepIter<'_> {\n@@ -111,7 +111,7 @@ impl Iterator for LineIndexStepIter<'_> {\n             .as_mut()\n             .and_then(|(newline, x)| {\n                 let x = x.next()?;\n-                Some(Step::Utf16Char(TextRange::from_to(*newline + x.start, *newline + x.end)))\n+                Some(Step::Utf16Char(TextRange::new(*newline + x.start, *newline + x.end)))\n             })\n             .or_else(|| {\n                 let next_newline = *self.line_index.newlines.get(self.next_newline_idx)?;\n@@ -129,7 +129,7 @@ impl Iterator for LineIndexStepIter<'_> {\n #[derive(Debug)]\n struct OffsetStepIter<'a> {\n     text: &'a str,\n-    offset: TextUnit,\n+    offset: TextSize,\n }\n \n impl Iterator for OffsetStepIter<'_> {\n@@ -140,15 +140,15 @@ impl Iterator for OffsetStepIter<'_> {\n             .char_indices()\n             .filter_map(|(i, c)| {\n                 if c == '\\n' {\n-                    let next_offset = self.offset + TextUnit::from_usize(i + 1);\n+                    let next_offset = self.offset + TextSize::from_usize(i + 1);\n                     let next = Step::Newline(next_offset);\n                     Some((next, next_offset))\n                 } else {\n-                    let char_len = TextUnit::of_char(c);\n-                    if char_len > TextUnit::from_usize(1) {\n-                        let start = self.offset + TextUnit::from_usize(i);\n+                    let char_len = TextSize::of(c);\n+                    if char_len > TextSize::from_usize(1) {\n+                        let start = self.offset + TextSize::from_usize(i);\n                         let end = start + char_len;\n-                        let next = Step::Utf16Char(TextRange::from_to(start, end));\n+                        let next = Step::Utf16Char(TextRange::new(start, end));\n                         let next_offset = end;\n                         Some((next, next_offset))\n                     } else {\n@@ -157,7 +157,7 @@ impl Iterator for OffsetStepIter<'_> {\n                 }\n             })\n             .next()?;\n-        let next_idx = (next_offset - self.offset).to_usize();\n+        let next_idx: usize = (next_offset - self.offset).into();\n         self.text = &self.text[next_idx..];\n         self.offset = next_offset;\n         Some(next)\n@@ -195,7 +195,7 @@ impl<'a> Edits<'a> {\n         match self.edits.split_first() {\n             Some((next, rest)) => {\n                 let delete = self.translate_range(next.delete);\n-                let diff = next.insert.len() as i64 - next.delete.len().to_usize() as i64;\n+                let diff = next.insert.len() as i64 - usize::from(next.delete.len()) as i64;\n                 self.current = Some(TranslatedEdit { delete, insert: &next.insert, diff });\n                 self.edits = rest;\n             }\n@@ -244,15 +244,15 @@ impl<'a> Edits<'a> {\n         } else {\n             let start = self.translate(range.start());\n             let end = self.translate(range.end());\n-            TextRange::from_to(start, end)\n+            TextRange::new(start, end)\n         }\n     }\n \n-    fn translate(&self, x: TextUnit) -> TextUnit {\n+    fn translate(&self, x: TextSize) -> TextSize {\n         if self.acc_diff == 0 {\n             x\n         } else {\n-            TextUnit::from((x.to_usize() as i64 + self.acc_diff) as u32)\n+            TextSize::from((usize::from(x) as i64 + self.acc_diff) as u32)\n         }\n     }\n \n@@ -271,29 +271,29 @@ impl<'a> Edits<'a> {\n #[derive(Debug)]\n struct RunningLineCol {\n     line: u32,\n-    last_newline: TextUnit,\n-    col_adjust: TextUnit,\n+    last_newline: TextSize,\n+    col_adjust: TextSize,\n }\n \n impl RunningLineCol {\n     fn new() -> RunningLineCol {\n-        RunningLineCol { line: 0, last_newline: TextUnit::from(0), col_adjust: TextUnit::from(0) }\n+        RunningLineCol { line: 0, last_newline: TextSize::from(0), col_adjust: TextSize::from(0) }\n     }\n \n-    fn to_line_col(&self, offset: TextUnit) -> LineCol {\n+    fn to_line_col(&self, offset: TextSize) -> LineCol {\n         LineCol {\n             line: self.line,\n             col_utf16: ((offset - self.last_newline) - self.col_adjust).into(),\n         }\n     }\n \n-    fn add_line(&mut self, newline: TextUnit) {\n+    fn add_line(&mut self, newline: TextSize) {\n         self.line += 1;\n         self.last_newline = newline;\n-        self.col_adjust = TextUnit::from(0);\n+        self.col_adjust = TextSize::from(0);\n     }\n \n     fn adjust_col(&mut self, range: TextRange) {\n-        self.col_adjust += range.len() - TextUnit::from(1);\n+        self.col_adjust += range.len() - TextSize::from(1);\n     }\n }"}, {"sha": "c66de4f422ab17aeed4c27237f067be4ff274175", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -10,7 +10,7 @@ use hir::{DefWithBody, HasSource, Module, ModuleSource, Semantics, Visibility};\n use once_cell::unsync::Lazy;\n use ra_db::{FileId, FileRange, SourceDatabaseExt};\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode, TextRange, TextUnit};\n+use ra_syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n@@ -85,7 +85,7 @@ impl SearchScope {\n             match (r1, r2) {\n                 (None, r) | (r, None) => Some(r),\n                 (Some(r1), Some(r2)) => {\n-                    let r = r1.intersection(&r2)?;\n+                    let r = r1.intersect(r2)?;\n                     Some(Some(r))\n                 }\n             }\n@@ -200,14 +200,13 @@ impl Definition {\n \n         for (file_id, search_range) in search_scope {\n             let text = db.file_text(file_id);\n-            let search_range =\n-                search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n+            let search_range = search_range.unwrap_or(TextRange::up_to(TextSize::of(&text)));\n \n             let sema = Semantics::new(db);\n             let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n             for (idx, _) in text.match_indices(pat) {\n-                let offset = TextUnit::from_usize(idx);\n+                let offset = TextSize::from_usize(idx);\n                 if !search_range.contains_inclusive(offset) {\n                     tested_by!(search_filters_by_range; force);\n                     continue;"}, {"sha": "fa9787266ba9b8c5c8de40493fc660a54f3eb1c0", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     ast::{self, make::tokens::doc_comment},\n     tokenize, AstToken, Parse, SmolStr, SyntaxKind,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, SyntaxTreeBuilder, TextRange, TextUnit, Token as RawToken, T,\n+    SyntaxNode, SyntaxToken, SyntaxTreeBuilder, TextRange, TextSize, Token as RawToken, T,\n };\n use rustc_hash::FxHashMap;\n use tt::buffer::{Cursor, TokenBuffer};\n@@ -99,11 +99,11 @@ pub fn parse_to_token_tree(text: &str) -> Option<(tt::Subtree, TokenMap)> {\n \n     let mut conv = RawConvertor {\n         text,\n-        offset: TextUnit::default(),\n+        offset: TextSize::default(),\n         inner: tokens.iter(),\n         id_alloc: TokenIdAlloc {\n             map: Default::default(),\n-            global_offset: TextUnit::default(),\n+            global_offset: TextSize::default(),\n             next_id: 0,\n         },\n     };\n@@ -227,7 +227,7 @@ fn convert_doc_comment(token: &ra_syntax::SyntaxToken) -> Option<Vec<tt::TokenTr\n \n struct TokenIdAlloc {\n     map: TokenMap,\n-    global_offset: TextUnit,\n+    global_offset: TextSize,\n     next_id: u32,\n }\n \n@@ -266,7 +266,7 @@ impl TokenIdAlloc {\n /// A Raw Token (straightly from lexer) convertor\n struct RawConvertor<'a> {\n     text: &'a str,\n-    offset: TextUnit,\n+    offset: TextSize,\n     id_alloc: TokenIdAlloc,\n     inner: std::slice::Iter<'a, RawToken>,\n }\n@@ -314,7 +314,7 @@ trait TokenConvertor {\n         }\n \n         result.push(if k.is_punct() {\n-            assert_eq!(range.len().to_usize(), 1);\n+            assert_eq!(range.len(), TextSize::of('.'));\n             let delim = match k {\n                 T!['('] => Some((tt::DelimiterKind::Parenthesis, T![')'])),\n                 T!['{'] => Some((tt::DelimiterKind::Brace, T!['}'])),\n@@ -381,17 +381,16 @@ trait TokenConvertor {\n                 k if k.is_keyword() => make_leaf!(Ident),\n                 k if k.is_literal() => make_leaf!(Literal),\n                 LIFETIME => {\n-                    let char_unit = TextUnit::from_usize(1);\n-                    let r = TextRange::offset_len(range.start(), char_unit);\n+                    let char_unit = TextSize::of('\\'');\n+                    let r = TextRange::at(range.start(), char_unit);\n                     let apostrophe = tt::Leaf::from(tt::Punct {\n                         char: '\\'',\n                         spacing: tt::Spacing::Joint,\n                         id: self.id_alloc().alloc(r),\n                     });\n                     result.push(apostrophe.into());\n \n-                    let r =\n-                        TextRange::offset_len(range.start() + char_unit, range.len() - char_unit);\n+                    let r = TextRange::at(range.start() + char_unit, range.len() - char_unit);\n                     let ident = tt::Leaf::from(tt::Ident {\n                         text: SmolStr::new(&token.to_text()[1..]),\n                         id: self.id_alloc().alloc(r),\n@@ -440,7 +439,7 @@ impl<'a> TokenConvertor for RawConvertor<'a> {\n \n     fn bump(&mut self) -> Option<(Self::Token, TextRange)> {\n         let token = self.inner.next()?;\n-        let range = TextRange::offset_len(self.offset, token.len);\n+        let range = TextRange::at(self.offset, token.len);\n         self.offset += token.len;\n \n         Some(((*token, &self.text[range]), range))\n@@ -450,7 +449,7 @@ impl<'a> TokenConvertor for RawConvertor<'a> {\n         let token = self.inner.as_slice().get(0).cloned();\n \n         token.map(|it| {\n-            let range = TextRange::offset_len(self.offset, it.len);\n+            let range = TextRange::at(self.offset, it.len);\n             (it, &self.text[range])\n         })\n     }\n@@ -464,11 +463,11 @@ struct Convertor {\n     id_alloc: TokenIdAlloc,\n     current: Option<SyntaxToken>,\n     range: TextRange,\n-    punct_offset: Option<(SyntaxToken, TextUnit)>,\n+    punct_offset: Option<(SyntaxToken, TextSize)>,\n }\n \n impl Convertor {\n-    fn new(node: &SyntaxNode, global_offset: TextUnit) -> Convertor {\n+    fn new(node: &SyntaxNode, global_offset: TextSize) -> Convertor {\n         Convertor {\n             id_alloc: { TokenIdAlloc { map: TokenMap::default(), global_offset, next_id: 0 } },\n             current: node.first_token(),\n@@ -481,7 +480,7 @@ impl Convertor {\n #[derive(Debug)]\n enum SynToken {\n     Ordiniary(SyntaxToken),\n-    Punch(SyntaxToken, TextUnit),\n+    Punch(SyntaxToken, TextSize),\n }\n \n impl SynToken {\n@@ -500,7 +499,7 @@ impl SrcToken for SynToken {\n     fn to_char(&self) -> Option<char> {\n         match self {\n             SynToken::Ordiniary(_) => None,\n-            SynToken::Punch(it, i) => it.text().chars().nth(i.to_usize()),\n+            SynToken::Punch(it, i) => it.text().chars().nth((*i).into()),\n         }\n     }\n     fn to_text(&self) -> SmolStr {\n@@ -516,26 +515,26 @@ impl TokenConvertor for Convertor {\n \n     fn bump(&mut self) -> Option<(Self::Token, TextRange)> {\n         if let Some((punct, offset)) = self.punct_offset.clone() {\n-            if offset.to_usize() + 1 < punct.text().len() {\n-                let offset = offset + TextUnit::from_usize(1);\n+            if usize::from(offset) + 1 < punct.text().len() {\n+                let offset = offset + TextSize::from_usize(1);\n                 let range = punct.text_range();\n                 self.punct_offset = Some((punct.clone(), offset));\n-                let range = TextRange::offset_len(range.start() + offset, TextUnit::from_usize(1));\n+                let range = TextRange::at(range.start() + offset, TextSize::of('.'));\n                 return Some((SynToken::Punch(punct, offset), range));\n             }\n         }\n \n         let curr = self.current.clone()?;\n-        if !curr.text_range().is_subrange(&self.range) {\n+        if !&self.range.contains_range(curr.text_range()) {\n             return None;\n         }\n         self.current = curr.next_token();\n \n         let token = if curr.kind().is_punct() {\n             let range = curr.text_range();\n-            let range = TextRange::offset_len(range.start(), TextUnit::from_usize(1));\n-            self.punct_offset = Some((curr.clone(), TextUnit::from_usize(0)));\n-            (SynToken::Punch(curr, TextUnit::from_usize(0)), range)\n+            let range = TextRange::at(range.start(), TextSize::from_usize(1));\n+            self.punct_offset = Some((curr.clone(), TextSize::from_usize(0)));\n+            (SynToken::Punch(curr, TextSize::from_usize(0)), range)\n         } else {\n             self.punct_offset = None;\n             let range = curr.text_range();\n@@ -547,19 +546,19 @@ impl TokenConvertor for Convertor {\n \n     fn peek(&self) -> Option<Self::Token> {\n         if let Some((punct, mut offset)) = self.punct_offset.clone() {\n-            offset = offset + TextUnit::from_usize(1);\n-            if offset.to_usize() < punct.text().len() {\n+            offset = offset + TextSize::from_usize(1);\n+            if usize::from(offset) < punct.text().len() {\n                 return Some(SynToken::Punch(punct, offset));\n             }\n         }\n \n         let curr = self.current.clone()?;\n-        if !curr.text_range().is_subrange(&self.range) {\n+        if !self.range.contains_range(curr.text_range()) {\n             return None;\n         }\n \n         let token = if curr.kind().is_punct() {\n-            SynToken::Punch(curr, TextUnit::from_usize(0))\n+            SynToken::Punch(curr, TextSize::from_usize(0))\n         } else {\n             SynToken::Ordiniary(curr)\n         };\n@@ -574,8 +573,8 @@ impl TokenConvertor for Convertor {\n struct TtTreeSink<'a> {\n     buf: String,\n     cursor: Cursor<'a>,\n-    open_delims: FxHashMap<tt::TokenId, TextUnit>,\n-    text_pos: TextUnit,\n+    open_delims: FxHashMap<tt::TokenId, TextSize>,\n+    text_pos: TextSize,\n     inner: SyntaxTreeBuilder,\n     token_map: TokenMap,\n \n@@ -641,7 +640,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n                         }\n                         tt::Leaf::Literal(lit) => (lit.text.clone(), lit.id),\n                     };\n-                    let range = TextRange::offset_len(self.text_pos, TextUnit::of_str(&text));\n+                    let range = TextRange::at(self.text_pos, TextSize::of(text.as_str()));\n                     self.token_map.insert(id, range);\n                     self.cursor = self.cursor.bump();\n                     text\n@@ -658,10 +657,8 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n                         self.cursor = self.cursor.bump();\n                         if let Some(id) = parent.delimiter.map(|it| it.id) {\n                             if let Some(open_delim) = self.open_delims.get(&id) {\n-                                let open_range =\n-                                    TextRange::offset_len(*open_delim, TextUnit::from_usize(1));\n-                                let close_range =\n-                                    TextRange::offset_len(self.text_pos, TextUnit::from_usize(1));\n+                                let open_range = TextRange::at(*open_delim, TextSize::of('('));\n+                                let close_range = TextRange::at(self.text_pos, TextSize::of('('));\n                                 self.token_map.insert_delim(id, open_range, close_range);\n                             }\n                         }\n@@ -672,7 +669,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n                 }\n             };\n             self.buf += &text;\n-            self.text_pos += TextUnit::of_str(&text);\n+            self.text_pos += TextSize::of(text.as_str());\n         }\n \n         let text = SmolStr::new(self.buf.as_str());\n@@ -690,7 +687,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n             // other parts of RA such that we don't add whitespace here.\n             if curr.spacing == tt::Spacing::Alone && curr.char != ';' {\n                 self.inner.token(WHITESPACE, \" \".into());\n-                self.text_pos += TextUnit::of_char(' ');\n+                self.text_pos += TextSize::of(' ');\n             }\n         }\n     }"}, {"sha": "dda396582f23c79d10a9466d41c2d71f94ef7aab", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -12,7 +12,7 @@ doctest = false\n \n [dependencies]\n itertools = \"0.9.0\"\n-rowan = \"0.9.1\"\n+rowan = { path = \"../../../rowan\" }\n rustc_lexer = { version = \"652.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.5.1\""}, {"sha": "2a8dac757b617259b5e6fac77ce014aeb8f08525", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -11,7 +11,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxNodePtr,\n-    SyntaxToken, TextRange, TextUnit,\n+    SyntaxToken, TextRange, TextSize,\n };\n \n /// Returns ancestors of the node at the offset, sorted by length. This should\n@@ -21,7 +21,7 @@ use crate::{\n /// t.parent().ancestors())`.\n pub fn ancestors_at_offset(\n     node: &SyntaxNode,\n-    offset: TextUnit,\n+    offset: TextSize,\n ) -> impl Iterator<Item = SyntaxNode> {\n     node.token_at_offset(offset)\n         .map(|token| token.parent().ancestors())\n@@ -37,7 +37,7 @@ pub fn ancestors_at_offset(\n /// ```\n ///\n /// then the shorter node will be silently preferred.\n-pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<N> {\n+pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextSize) -> Option<N> {\n     ancestors_at_offset(syntax, offset).find_map(N::cast)\n }\n \n@@ -180,7 +180,7 @@ fn _insert_children(\n     position: InsertPosition<SyntaxElement>,\n     to_insert: &mut dyn Iterator<Item = SyntaxElement>,\n ) -> SyntaxNode {\n-    let mut delta = TextUnit::default();\n+    let mut delta = TextSize::default();\n     let to_insert = to_insert.map(|element| {\n         delta += element.text_range().len();\n         to_green_element(element)\n@@ -347,15 +347,15 @@ fn with_children(\n     parent: &SyntaxNode,\n     new_children: Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,\n ) -> SyntaxNode {\n-    let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n+    let len = new_children.iter().map(|it| it.text_len()).sum::<TextSize>();\n     let new_node = rowan::GreenNode::new(rowan::SyntaxKind(parent.kind() as u16), new_children);\n     let new_root_node = parent.replace_with(new_node);\n     let new_root_node = SyntaxNode::new_root(new_root_node);\n \n     // FIXME: use a more elegant way to re-fetch the node (#1185), make\n     // `range` private afterwards\n     let mut ptr = SyntaxNodePtr::new(parent);\n-    ptr.range = TextRange::offset_len(ptr.range.start(), len);\n+    ptr.range = TextRange::at(ptr.range.start(), len);\n     ptr.to_node(&new_root_node)\n }\n "}, {"sha": "26b8f9c364fa22a1b07180c42df68ca88afe6209", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@\n \n use crate::{\n     ast::{AstToken, Comment, RawString, String, Whitespace},\n-    TextRange, TextUnit,\n+    TextRange, TextSize,\n };\n \n impl Comment {\n@@ -94,14 +94,14 @@ impl QuoteOffsets {\n             return None;\n         }\n \n-        let start = TextUnit::from(0);\n-        let left_quote = TextUnit::from_usize(left_quote) + TextUnit::of_char('\"');\n-        let right_quote = TextUnit::from_usize(right_quote);\n-        let end = TextUnit::of_str(literal);\n+        let start = TextSize::from(0);\n+        let left_quote = TextSize::from_usize(left_quote) + TextSize::of('\"');\n+        let right_quote = TextSize::from_usize(right_quote);\n+        let end = TextSize::of(literal);\n \n         let res = QuoteOffsets {\n-            quotes: [TextRange::from_to(start, left_quote), TextRange::from_to(right_quote, end)],\n-            contents: TextRange::from_to(left_quote, right_quote),\n+            quotes: [TextRange::new(start, left_quote), TextRange::new(right_quote, end)],\n+            contents: TextRange::new(left_quote, right_quote),\n         };\n         Some(res)\n     }\n@@ -168,7 +168,7 @@ impl HasStringValue for RawString {\n impl RawString {\n     pub fn map_range_up(&self, range: TextRange) -> Option<TextRange> {\n         let contents_range = self.text_range_between_quotes()?;\n-        assert!(range.is_subrange(&TextRange::offset_len(0.into(), contents_range.len())));\n+        assert!(TextRange::up_to(contents_range.len()).contains_range(range));\n         Some(range + contents_range.start())\n     }\n }\n@@ -459,7 +459,7 @@ pub trait HasFormatSpecifier: AstToken {\n             while let Some((r, Ok(next_char))) = chars.peek() {\n                 if next_char.is_ascii_digit() {\n                     chars.next();\n-                    range = range.extend_to(r);\n+                    range = range.cover(*r);\n                 } else {\n                     break;\n                 }\n@@ -477,7 +477,7 @@ pub trait HasFormatSpecifier: AstToken {\n             while let Some((r, Ok(next_char))) = chars.peek() {\n                 if *next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n                     chars.next();\n-                    range = range.extend_to(r);\n+                    range = range.cover(*r);\n                 } else {\n                     break;\n                 }\n@@ -498,10 +498,8 @@ impl HasFormatSpecifier for String {\n         let mut res = Vec::with_capacity(text.len());\n         rustc_lexer::unescape::unescape_str(text, &mut |range, unescaped_char| {\n             res.push((\n-                TextRange::from_to(\n-                    TextUnit::from_usize(range.start),\n-                    TextUnit::from_usize(range.end),\n-                ) + offset,\n+                TextRange::new(TextSize::from_usize(range.start), TextSize::from_usize(range.end))\n+                    + offset,\n                 unescaped_char,\n             ))\n         });\n@@ -521,10 +519,8 @@ impl HasFormatSpecifier for RawString {\n         let mut res = Vec::with_capacity(text.len());\n         for (idx, c) in text.char_indices() {\n             res.push((\n-                TextRange::from_to(\n-                    TextUnit::from_usize(idx),\n-                    TextUnit::from_usize(idx + c.len_utf8()),\n-                ) + offset,\n+                TextRange::new(TextSize::from_usize(idx), TextSize::from_usize(idx + c.len_utf8()))\n+                    + offset,\n                 Ok(c),\n             ));\n         }"}, {"sha": "15aad22056d5b4f1e8d419148588c2afa0a9e756", "filename": "crates/ra_syntax/src/fuzz.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use crate::{validation, AstNode, SourceFile, TextRange, TextUnit};\n+use crate::{validation, AstNode, SourceFile, TextRange, TextSize};\n use ra_text_edit::AtomTextEdit;\n use std::str::{self, FromStr};\n \n@@ -34,10 +34,8 @@ impl CheckReparse {\n         let text = lines.collect::<Vec<_>>().join(\"\\n\");\n         let text = format!(\"{}{}{}\", PREFIX, text, SUFFIX);\n         text.get(delete_start..delete_start.checked_add(delete_len)?)?; // make sure delete is a valid range\n-        let delete = TextRange::offset_len(\n-            TextUnit::from_usize(delete_start),\n-            TextUnit::from_usize(delete_len),\n-        );\n+        let delete =\n+            TextRange::at(TextSize::from_usize(delete_start), TextSize::from_usize(delete_len));\n         let edited_text =\n             format!(\"{}{}{}\", &text[..delete_start], &insert, &text[delete_start + delete_len..]);\n         let edit = AtomTextEdit { delete, insert };"}, {"sha": "ceeb2bde9f3026800fffbfd6b05bb113f6098544", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -55,7 +55,7 @@ pub use crate::{\n     },\n };\n pub use ra_parser::{SyntaxKind, T};\n-pub use rowan::{SmolStr, SyntaxText, TextRange, TextUnit, TokenAtOffset, WalkEvent};\n+pub use rowan::{SmolStr, SyntaxText, TextRange, TextSize, TokenAtOffset, WalkEvent};\n \n /// `Parse` is the result of the parsing: a syntax tree and a collection of\n /// errors.\n@@ -266,7 +266,7 @@ fn api_walkthrough() {\n     assert_eq!(expr_syntax.kind(), SyntaxKind::BIN_EXPR);\n \n     // And text range:\n-    assert_eq!(expr_syntax.text_range(), TextRange::from_to(32.into(), 37.into()));\n+    assert_eq!(expr_syntax.text_range(), TextRange::new(32.into(), 37.into()));\n \n     // You can get node's text as a `SyntaxText` object, which will traverse the\n     // tree collecting token's text:"}, {"sha": "1fdc76d9869fda51143ee4a415bf3f0bc9ff13a4", "filename": "crates/ra_syntax/src/parsing/lexer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -4,7 +4,7 @@\n use crate::{\n     SyntaxError,\n     SyntaxKind::{self, *},\n-    TextRange, TextUnit, T,\n+    TextRange, TextSize, T,\n };\n \n /// A token of Rust source.\n@@ -13,7 +13,7 @@ pub struct Token {\n     /// The kind of token.\n     pub kind: SyntaxKind,\n     /// The length of the token.\n-    pub len: TextUnit,\n+    pub len: TextSize,\n }\n \n /// Break a string up into its component tokens.\n@@ -30,16 +30,16 @@ pub fn tokenize(text: &str) -> (Vec<Token>, Vec<SyntaxError>) {\n \n     let mut offset: usize = rustc_lexer::strip_shebang(text)\n         .map(|shebang_len| {\n-            tokens.push(Token { kind: SHEBANG, len: TextUnit::from_usize(shebang_len) });\n+            tokens.push(Token { kind: SHEBANG, len: TextSize::from_usize(shebang_len) });\n             shebang_len\n         })\n         .unwrap_or(0);\n \n     let text_without_shebang = &text[offset..];\n \n     for rustc_token in rustc_lexer::tokenize(text_without_shebang) {\n-        let token_len = TextUnit::from_usize(rustc_token.len);\n-        let token_range = TextRange::offset_len(TextUnit::from_usize(offset), token_len);\n+        let token_len = TextSize::from_usize(rustc_token.len);\n+        let token_range = TextRange::at(TextSize::from_usize(offset), token_len);\n \n         let (syntax_kind, err_message) =\n             rustc_token_kind_to_syntax_kind(&rustc_token.kind, &text[token_range]);\n@@ -65,7 +65,7 @@ pub fn tokenize(text: &str) -> (Vec<Token>, Vec<SyntaxError>) {\n /// Beware that unescape errors are not checked at tokenization time.\n pub fn lex_single_syntax_kind(text: &str) -> Option<(SyntaxKind, Option<SyntaxError>)> {\n     lex_first_token(text)\n-        .filter(|(token, _)| token.len == TextUnit::of_str(text))\n+        .filter(|(token, _)| token.len == TextSize::of(text))\n         .map(|(token, error)| (token.kind, error))\n }\n \n@@ -75,7 +75,7 @@ pub fn lex_single_syntax_kind(text: &str) -> Option<(SyntaxKind, Option<SyntaxEr\n /// Beware that unescape errors are not checked at tokenization time.\n pub fn lex_single_valid_syntax_kind(text: &str) -> Option<SyntaxKind> {\n     lex_first_token(text)\n-        .filter(|(token, error)| !error.is_some() && token.len == TextUnit::of_str(text))\n+        .filter(|(token, error)| !error.is_some() && token.len == TextSize::of(text))\n         .map(|(token, _error)| token.kind)\n }\n \n@@ -96,9 +96,9 @@ fn lex_first_token(text: &str) -> Option<(Token, Option<SyntaxError>)> {\n     let rustc_token = rustc_lexer::first_token(text);\n     let (syntax_kind, err_message) = rustc_token_kind_to_syntax_kind(&rustc_token.kind, text);\n \n-    let token = Token { kind: syntax_kind, len: TextUnit::from_usize(rustc_token.len) };\n+    let token = Token { kind: syntax_kind, len: TextSize::from_usize(rustc_token.len) };\n     let optional_error = err_message.map(|err_message| {\n-        SyntaxError::new(err_message, TextRange::from_to(0.into(), TextUnit::of_str(text)))\n+        SyntaxError::new(err_message, TextRange::new(0.into(), TextSize::of(text)))\n     });\n \n     Some((token, optional_error))"}, {"sha": "ffff0a7b2026a42a5c17492f49a8e2a10e99b5ee", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     syntax_node::{GreenNode, GreenToken, NodeOrToken, SyntaxElement, SyntaxNode},\n     SyntaxError,\n     SyntaxKind::*,\n-    TextRange, TextUnit, T,\n+    TextRange, TextSize, T,\n };\n \n pub(crate) fn incremental_reparse(\n@@ -176,7 +176,7 @@ fn merge_errors(\n         if old_err_range.end() <= range_before_reparse.start() {\n             res.push(old_err);\n         } else if old_err_range.start() >= range_before_reparse.end() {\n-            let inserted_len = TextUnit::of_str(&edit.insert);\n+            let inserted_len = TextSize::of(&edit.insert);\n             res.push(old_err.with_range((old_err_range + inserted_len) - edit.delete.len()));\n             // Note: extra parens are intentional to prevent uint underflow, HWAB (here was a bug)\n         }"}, {"sha": "7ddc2c2c39dd78f3b6ac609b4265dd2f1b2c8656", "filename": "crates/ra_syntax/src/parsing/text_token_source.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_token_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_token_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_token_source.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -3,7 +3,7 @@\n use ra_parser::Token as PToken;\n use ra_parser::TokenSource;\n \n-use crate::{parsing::lexer::Token, SyntaxKind::EOF, TextRange, TextUnit};\n+use crate::{parsing::lexer::Token, SyntaxKind::EOF, TextRange, TextSize};\n \n pub(crate) struct TextTokenSource<'t> {\n     text: &'t str,\n@@ -15,7 +15,7 @@ pub(crate) struct TextTokenSource<'t> {\n     /// 0      7  10\n     /// ```\n     /// (token, start_offset): `[(struct, 0), (Foo, 7), (;, 10)]`\n-    start_offsets: Vec<TextUnit>,\n+    start_offsets: Vec<TextSize>,\n     /// non-whitespace/comment tokens\n     /// ```non-rust\n     /// struct Foo {}\n@@ -51,12 +51,12 @@ impl<'t> TokenSource for TextTokenSource<'t> {\n         if pos >= self.tokens.len() {\n             return false;\n         }\n-        let range = TextRange::offset_len(self.start_offsets[pos], self.tokens[pos].len);\n+        let range = TextRange::at(self.start_offsets[pos], self.tokens[pos].len);\n         self.text[range] == *kw\n     }\n }\n \n-fn mk_token(pos: usize, start_offsets: &[TextUnit], tokens: &[Token]) -> PToken {\n+fn mk_token(pos: usize, start_offsets: &[TextSize], tokens: &[Token]) -> PToken {\n     let kind = tokens.get(pos).map(|t| t.kind).unwrap_or(EOF);\n     let is_jointed_to_next = if pos + 1 < start_offsets.len() {\n         start_offsets[pos] + tokens[pos].len == start_offsets[pos + 1]"}, {"sha": "22aed1db16d6fd53b23e1738e52b87cc649d0265", "filename": "crates/ra_syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     syntax_node::GreenNode,\n     SmolStr, SyntaxError,\n     SyntaxKind::{self, *},\n-    SyntaxTreeBuilder, TextRange, TextUnit,\n+    SyntaxTreeBuilder, TextRange, TextSize,\n };\n \n /// Bridges the parser with our specific syntax tree representation.\n@@ -18,7 +18,7 @@ use crate::{\n pub(crate) struct TextTreeSink<'a> {\n     text: &'a str,\n     tokens: &'a [Token],\n-    text_pos: TextUnit,\n+    text_pos: TextSize,\n     token_pos: usize,\n     state: State,\n     inner: SyntaxTreeBuilder,\n@@ -42,7 +42,7 @@ impl<'a> TreeSink for TextTreeSink<'a> {\n         let len = self.tokens[self.token_pos..self.token_pos + n_tokens]\n             .iter()\n             .map(|it| it.len)\n-            .sum::<TextUnit>();\n+            .sum::<TextSize>();\n         self.do_token(kind, len, n_tokens);\n     }\n \n@@ -62,12 +62,12 @@ impl<'a> TreeSink for TextTreeSink<'a> {\n             self.tokens[self.token_pos..].iter().take_while(|it| it.kind.is_trivia()).count();\n         let leading_trivias = &self.tokens[self.token_pos..self.token_pos + n_trivias];\n         let mut trivia_end =\n-            self.text_pos + leading_trivias.iter().map(|it| it.len).sum::<TextUnit>();\n+            self.text_pos + leading_trivias.iter().map(|it| it.len).sum::<TextSize>();\n \n         let n_attached_trivias = {\n             let leading_trivias = leading_trivias.iter().rev().map(|it| {\n                 let next_end = trivia_end - it.len;\n-                let range = TextRange::from_to(next_end, trivia_end);\n+                let range = TextRange::new(next_end, trivia_end);\n                 trivia_end = next_end;\n                 (it.kind, &self.text[range])\n             });\n@@ -132,8 +132,8 @@ impl<'a> TextTreeSink<'a> {\n         }\n     }\n \n-    fn do_token(&mut self, kind: SyntaxKind, len: TextUnit, n_tokens: usize) {\n-        let range = TextRange::offset_len(self.text_pos, len);\n+    fn do_token(&mut self, kind: SyntaxKind, len: TextSize, n_tokens: usize) {\n+        let range = TextRange::at(self.text_pos, len);\n         let text: SmolStr = self.text[range].into();\n         self.text_pos += len;\n         self.token_pos += n_tokens;"}, {"sha": "62f03e93d0b8cc61aefde4f1fa93d671fb739a87", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -24,7 +24,7 @@ impl SyntaxNodePtr {\n     pub fn to_node(&self, root: &SyntaxNode) -> SyntaxNode {\n         assert!(root.parent().is_none());\n         successors(Some(root.clone()), |node| {\n-            node.children().find(|it| self.range.is_subrange(&it.text_range()))\n+            node.children().find(|it| it.text_range().contains_range(self.range))\n         })\n         .find(|it| it.text_range() == self.range && it.kind() == self.kind)\n         .unwrap_or_else(|| panic!(\"can't resolve local ptr to SyntaxNode: {:?}\", self))"}, {"sha": "7c4511fece06091ddc60ba427a7c6c52ece63fb8", "filename": "crates/ra_syntax/src/syntax_error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt;\n \n-use crate::{TextRange, TextUnit};\n+use crate::{TextRange, TextSize};\n \n /// Represents the result of unsuccessful tokenization, parsing\n /// or tree validation.\n@@ -23,8 +23,8 @@ impl SyntaxError {\n     pub fn new(message: impl Into<String>, range: TextRange) -> Self {\n         Self(message.into(), range)\n     }\n-    pub fn new_at_offset(message: impl Into<String>, offset: TextUnit) -> Self {\n-        Self(message.into(), TextRange::offset_len(offset, 0.into()))\n+    pub fn new_at_offset(message: impl Into<String>, offset: TextSize) -> Self {\n+        Self(message.into(), TextRange::empty(offset))\n     }\n \n     pub fn range(&self) -> TextRange {"}, {"sha": "f9d379abf3c1eddab868a5912f08c065538734b9", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -8,7 +8,7 @@\n \n use rowan::{GreenNodeBuilder, Language};\n \n-use crate::{Parse, SmolStr, SyntaxError, SyntaxKind, TextUnit};\n+use crate::{Parse, SmolStr, SyntaxError, SyntaxKind, TextSize};\n \n pub(crate) use rowan::{GreenNode, GreenToken};\n \n@@ -69,7 +69,7 @@ impl SyntaxTreeBuilder {\n         self.inner.finish_node()\n     }\n \n-    pub fn error(&mut self, error: ra_parser::ParseError, text_pos: TextUnit) {\n+    pub fn error(&mut self, error: ra_parser::ParseError, text_pos: TextSize) {\n         self.errors.push(SyntaxError::new_at_offset(error.0, text_pos))\n     }\n }"}, {"sha": "4f2b67febdcf6cef14293cc07a8a0af22331bec0", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -5,7 +5,7 @@ use std::{\n \n use test_utils::{collect_rust_files, dir_tests, project_dir, read_text};\n \n-use crate::{fuzz, tokenize, SourceFile, SyntaxError, TextRange, TextUnit, Token};\n+use crate::{fuzz, tokenize, SourceFile, SyntaxError, TextRange, TextSize, Token};\n \n #[test]\n fn lexer_tests() {\n@@ -121,12 +121,12 @@ fn assert_errors_are_absent(errors: &[SyntaxError], path: &Path) {\n \n fn dump_tokens_and_errors(tokens: &[Token], errors: &[SyntaxError], text: &str) -> String {\n     let mut acc = String::new();\n-    let mut offset = TextUnit::from_usize(0);\n+    let mut offset = TextSize::from_usize(0);\n     for token in tokens {\n         let token_len = token.len;\n-        let token_text = &text[TextRange::offset_len(offset, token.len)];\n+        let token_text = &text[TextRange::at(offset, token.len)];\n         offset += token.len;\n-        writeln!(acc, \"{:?} {} {:?}\", token.kind, token_len, token_text).unwrap();\n+        writeln!(acc, \"{:?} {:?} {:?}\", token.kind, token_len, token_text).unwrap();\n     }\n     for err in errors {\n         writeln!(acc, \"> error{:?} token({:?}) msg({})\", err.range(), &text[err.range()], err)"}, {"sha": "77d7e132d8b1d21fbe74a08f632a3cd8a0925940", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -7,7 +7,7 @@ use rustc_lexer::unescape;\n use crate::{\n     ast, match_ast, AstNode, SyntaxError,\n     SyntaxKind::{BYTE, BYTE_STRING, CHAR, CONST_DEF, FN_DEF, INT_NUMBER, STRING, TYPE_ALIAS_DEF},\n-    SyntaxNode, SyntaxToken, TextUnit, T,\n+    SyntaxNode, SyntaxToken, TextSize, T,\n };\n \n fn rustc_unescape_error_to_string(err: unescape::EscapeError) -> &'static str {\n@@ -112,7 +112,7 @@ fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n \n     // FIXME: lift this lambda refactor to `fn` (https://github.com/rust-analyzer/rust-analyzer/pull/2834#discussion_r366199205)\n     let mut push_err = |prefix_len, (off, err): (usize, unescape::EscapeError)| {\n-        let off = token.text_range().start() + TextUnit::from_usize(off + prefix_len);\n+        let off = token.text_range().start() + TextSize::from_usize(off + prefix_len);\n         acc.push(SyntaxError::new_at_offset(rustc_unescape_error_to_string(err), off));\n     };\n "}, {"sha": "9b0567c9815128db7bb4fb9a1a3ff6676928b6e6", "filename": "crates/ra_text_edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_text_edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_text_edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2FCargo.toml?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -9,5 +9,4 @@ publish = false\n doctest = false\n \n [dependencies]\n-text_unit = \"0.1.10\"\n-\n+text-size = { path = \"../../../text-size\" }"}, {"sha": "e656260c73d587eeb4bf07108cceb05c9089f699", "filename": "crates/ra_text_edit/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -2,7 +2,7 @@\n \n mod text_edit;\n \n-use text_unit::{TextRange, TextUnit};\n+use text_size::{TextRange, TextSize};\n \n pub use crate::text_edit::{TextEdit, TextEditBuilder};\n \n@@ -23,13 +23,13 @@ impl AtomTextEdit {\n         AtomTextEdit::replace(range, String::new())\n     }\n \n-    pub fn insert(offset: TextUnit, text: String) -> AtomTextEdit {\n-        AtomTextEdit::replace(TextRange::offset_len(offset, 0.into()), text)\n+    pub fn insert(offset: TextSize, text: String) -> AtomTextEdit {\n+        AtomTextEdit::replace(TextRange::empty(offset), text)\n     }\n \n     pub fn apply(&self, mut text: String) -> String {\n-        let start = self.delete.start().to_usize();\n-        let end = self.delete.end().to_usize();\n+        let start: usize = self.delete.start().into();\n+        let end: usize = self.delete.end().into();\n         text.replace_range(start..end, &self.insert);\n         text\n     }"}, {"sha": "db69a7e7b61b8362927b94cf230f02289fa515e0", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -1,7 +1,8 @@\n //! FIXME: write short doc here\n \n use crate::AtomTextEdit;\n-use text_unit::{TextRange, TextUnit};\n+// TODO: fix Cargo.toml\n+use text_size::{TextRange, TextSize};\n \n #[derive(Debug, Clone)]\n pub struct TextEdit {\n@@ -20,19 +21,19 @@ impl TextEditBuilder {\n     pub fn delete(&mut self, range: TextRange) {\n         self.atoms.push(AtomTextEdit::delete(range))\n     }\n-    pub fn insert(&mut self, offset: TextUnit, text: String) {\n+    pub fn insert(&mut self, offset: TextSize, text: String) {\n         self.atoms.push(AtomTextEdit::insert(offset, text))\n     }\n     pub fn finish(self) -> TextEdit {\n         TextEdit::from_atoms(self.atoms)\n     }\n-    pub fn invalidates_offset(&self, offset: TextUnit) -> bool {\n+    pub fn invalidates_offset(&self, offset: TextSize) -> bool {\n         self.atoms.iter().any(|atom| atom.delete.contains_inclusive(offset))\n     }\n }\n \n impl TextEdit {\n-    pub fn insert(offset: TextUnit, text: String) -> TextEdit {\n+    pub fn insert(offset: TextSize, text: String) -> TextEdit {\n         let mut builder = TextEditBuilder::default();\n         builder.insert(offset, text);\n         builder.finish()\n@@ -63,28 +64,28 @@ impl TextEdit {\n     }\n \n     pub fn apply(&self, text: &str) -> String {\n-        let mut total_len = TextUnit::of_str(text);\n+        let mut total_len = TextSize::of(text);\n         for atom in self.atoms.iter() {\n-            total_len += TextUnit::of_str(&atom.insert);\n+            total_len += TextSize::of(&atom.insert);\n             total_len -= atom.delete.end() - atom.delete.start();\n         }\n-        let mut buf = String::with_capacity(total_len.to_usize());\n+        let mut buf = String::with_capacity(total_len.into());\n         let mut prev = 0;\n         for atom in self.atoms.iter() {\n-            let start = atom.delete.start().to_usize();\n-            let end = atom.delete.end().to_usize();\n+            let start: usize = atom.delete.start().into();\n+            let end: usize = atom.delete.end().into();\n             if start > prev {\n                 buf.push_str(&text[prev..start]);\n             }\n             buf.push_str(&atom.insert);\n             prev = end;\n         }\n         buf.push_str(&text[prev..text.len()]);\n-        assert_eq!(TextUnit::of_str(&buf), total_len);\n+        assert_eq!(TextSize::of(&buf), total_len);\n         buf\n     }\n \n-    pub fn apply_to_offset(&self, offset: TextUnit) -> Option<TextUnit> {\n+    pub fn apply_to_offset(&self, offset: TextSize) -> Option<TextSize> {\n         let mut res = offset;\n         for atom in self.atoms.iter() {\n             if atom.delete.start() >= offset {\n@@ -93,7 +94,7 @@ impl TextEdit {\n             if offset < atom.delete.end() {\n                 return None;\n             }\n-            res += TextUnit::of_str(&atom.insert);\n+            res += TextSize::of(&atom.insert);\n             res -= atom.delete.len();\n         }\n         Some(res)"}, {"sha": "72183da15160b516e09d7d1cf6a3190ff2c07be5", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -130,7 +130,7 @@ pub fn analysis_stats(\n             let original_file = src.file_id.original_file(db);\n             let path = db.file_relative_path(original_file);\n             let syntax_range = src.value.syntax().text_range();\n-            format_to!(msg, \" ({:?} {})\", path, syntax_range);\n+            format_to!(msg, \" ({:?} {:?})\", path, syntax_range);\n         }\n         if verbosity.is_spammy() {\n             bar.println(msg.to_string());"}, {"sha": "b0f911f713f114063f5f14809b8011087a01308c", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -14,7 +14,7 @@ use ra_ide::{\n     InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo,\n     ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n };\n-use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n+use ra_syntax::{SyntaxKind, TextRange, TextSize};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n use ra_vfs::LineEndings;\n \n@@ -124,21 +124,21 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n         // LSP does not allow arbitrary edits in completion, so we have to do a\n         // non-trivial mapping here.\n         for atom_edit in self.text_edit().as_atoms() {\n-            if self.source_range().is_subrange(&atom_edit.delete) {\n+            if atom_edit.delete.contains_range(self.source_range()) {\n                 text_edit = Some(if atom_edit.delete == self.source_range() {\n                     atom_edit.conv_with((ctx.0, ctx.1))\n                 } else {\n                     assert!(self.source_range().end() == atom_edit.delete.end());\n                     let range1 =\n-                        TextRange::from_to(atom_edit.delete.start(), self.source_range().start());\n+                        TextRange::new(atom_edit.delete.start(), self.source_range().start());\n                     let range2 = self.source_range();\n                     let edit1 = AtomTextEdit::replace(range1, String::new());\n                     let edit2 = AtomTextEdit::replace(range2, atom_edit.insert.clone());\n                     additional_text_edits.push(edit1.conv_with((ctx.0, ctx.1)));\n                     edit2.conv_with((ctx.0, ctx.1))\n                 })\n             } else {\n-                assert!(self.source_range().intersection(&atom_edit.delete).is_none());\n+                assert!(self.source_range().intersect(atom_edit.delete).is_none());\n                 additional_text_edits.push(atom_edit.conv_with((ctx.0, ctx.1)));\n             }\n         }\n@@ -184,15 +184,15 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n }\n \n impl ConvWith<&LineIndex> for Position {\n-    type Output = TextUnit;\n+    type Output = TextSize;\n \n-    fn conv_with(self, line_index: &LineIndex) -> TextUnit {\n+    fn conv_with(self, line_index: &LineIndex) -> TextSize {\n         let line_col = LineCol { line: self.line as u32, col_utf16: self.character as u32 };\n         line_index.offset(line_col)\n     }\n }\n \n-impl ConvWith<&LineIndex> for TextUnit {\n+impl ConvWith<&LineIndex> for TextSize {\n     type Output = Position;\n \n     fn conv_with(self, line_index: &LineIndex) -> Position {\n@@ -213,7 +213,7 @@ impl ConvWith<&LineIndex> for Range {\n     type Output = TextRange;\n \n     fn conv_with(self, line_index: &LineIndex) -> TextRange {\n-        TextRange::from_to(self.start.conv_with(line_index), self.end.conv_with(line_index))\n+        TextRange::new(self.start.conv_with(line_index), self.end.conv_with(line_index))\n     }\n }\n \n@@ -300,7 +300,7 @@ impl ConvWith<&FoldConvCtx<'_>> for Fold {\n             // range.end.line from the folding region if there is more text after range.end\n             // on the same line.\n             let has_more_text_on_end_line = ctx.text\n-                [TextRange::from_to(self.range.end(), TextUnit::of_str(ctx.text))]\n+                [TextRange::new(self.range.end(), TextSize::of(ctx.text))]\n             .chars()\n             .take_while(|it| *it != '\\n')\n             .any(|it| !it.is_whitespace());"}, {"sha": "381f37f169f838e6d1f0aac71da024e53758220a", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -23,7 +23,7 @@ use ra_ide::{\n     SearchScope,\n };\n use ra_prof::profile;\n-use ra_syntax::{AstNode, SyntaxKind, TextRange, TextUnit};\n+use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n@@ -97,7 +97,7 @@ pub fn handle_selection_range(\n         .map(|position| {\n             let mut ranges = Vec::new();\n             {\n-                let mut range = TextRange::from_to(position, position);\n+                let mut range = TextRange::new(position, position);\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n@@ -184,11 +184,11 @@ pub fn handle_on_type_formatting(\n \n     // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n-    position.offset -= TextUnit::of_char('.');\n+    position.offset -= TextSize::of('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n     assert!({\n         let text = world.analysis().file_text(position.file_id)?;\n-        text[position.offset.to_usize()..].starts_with(char_typed)\n+        text[usize::from(position.offset)..].starts_with(char_typed)\n     });\n \n     // We have an assist that inserts ` ` after typing `->` in `fn foo() ->{`,\n@@ -403,7 +403,7 @@ pub fn handle_completion(\n                 let syntax = source_file.syntax();\n                 let text = syntax.text();\n                 if let Some(next_char) = text.char_at(position.offset) {\n-                    let diff = TextUnit::of_char(next_char) + TextUnit::of_char(':');\n+                    let diff = TextSize::of(next_char) + TextSize::of(':');\n                     let prev_char = position.offset - diff;\n                     if text.char_at(prev_char) != Some(':') {\n                         res = true;\n@@ -592,7 +592,7 @@ pub fn handle_formatting(\n     let crate_ids = world.analysis().crate_for(file_id)?;\n \n     let file_line_index = world.analysis().file_line_index(file_id)?;\n-    let end_position = TextUnit::of_str(&file).conv_with(&file_line_index);\n+    let end_position = TextSize::of(&file).conv_with(&file_line_index);\n \n     let mut rustfmt = match &world.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n@@ -698,7 +698,7 @@ pub fn handle_code_action(\n     let fixes_from_diagnostics = diagnostics\n         .into_iter()\n         .filter_map(|d| Some((d.range, d.fix?)))\n-        .filter(|(diag_range, _fix)| diag_range.intersection(&range).is_some())\n+        .filter(|(diag_range, _fix)| diag_range.intersect(range).is_some())\n         .map(|(_range, fix)| fix);\n \n     for source_edit in fixes_from_diagnostics {\n@@ -723,7 +723,7 @@ pub fn handle_code_action(\n \n     for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n         let fix_range = fix.range.conv_with(&line_index);\n-        if fix_range.intersection(&range).is_none() {\n+        if fix_range.intersect(range).is_none() {\n             continue;\n         }\n         res.push(fix.action.clone());\n@@ -1107,7 +1107,7 @@ pub fn handle_semantic_tokens(\n         let (token_index, modifier_bitset) = highlight_range.highlight.conv();\n         for mut range in line_index.lines(highlight_range.range) {\n             if text[range].ends_with('\\n') {\n-                range = TextRange::from_to(range.start(), range.end() - TextUnit::of_char('\\n'));\n+                range = TextRange::new(range.start(), range.end() - TextSize::of('\\n'));\n             }\n             let range = range.conv_with(&line_index);\n             builder.push(range, token_index, modifier_bitset);"}, {"sha": "652ab453719049c17e897ef6ceee10780b0b8580", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -9,5 +9,5 @@ doctest = false\n \n [dependencies]\n difference = \"2.0.0\"\n-text_unit = \"0.1.10\"\n+text-size = { path = \"../../../text-size\" }\n serde_json = \"1.0.48\""}, {"sha": "b1365444a8fd666766b286028bf1aacda9ec0776", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -15,7 +15,7 @@ use std::{\n };\n \n use serde_json::Value;\n-use text_unit::{TextRange, TextUnit};\n+use text_size::{TextRange, TextSize};\n \n pub use difference::Changeset as __Changeset;\n \n@@ -49,7 +49,7 @@ macro_rules! assert_eq_text {\n }\n \n /// Infallible version of `try_extract_offset()`.\n-pub fn extract_offset(text: &str) -> (TextUnit, String) {\n+pub fn extract_offset(text: &str) -> (TextSize, String) {\n     match try_extract_offset(text) {\n         None => panic!(\"text should contain cursor marker\"),\n         Some(result) => result,\n@@ -58,12 +58,12 @@ pub fn extract_offset(text: &str) -> (TextUnit, String) {\n \n /// Returns the offset of the first occurence of `<|>` marker and the copy of `text`\n /// without the marker.\n-fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n+fn try_extract_offset(text: &str) -> Option<(TextSize, String)> {\n     let cursor_pos = text.find(CURSOR_MARKER)?;\n     let mut new_text = String::with_capacity(text.len() - CURSOR_MARKER.len());\n     new_text.push_str(&text[..cursor_pos]);\n     new_text.push_str(&text[cursor_pos + CURSOR_MARKER.len()..]);\n-    let cursor_pos = TextUnit::from(cursor_pos as u32);\n+    let cursor_pos = TextSize::from(cursor_pos as u32);\n     Some((cursor_pos, new_text))\n }\n \n@@ -80,25 +80,25 @@ pub fn extract_range(text: &str) -> (TextRange, String) {\n fn try_extract_range(text: &str) -> Option<(TextRange, String)> {\n     let (start, text) = try_extract_offset(text)?;\n     let (end, text) = try_extract_offset(&text)?;\n-    Some((TextRange::from_to(start, end), text))\n+    Some((TextRange::new(start, end), text))\n }\n \n #[derive(Clone, Copy)]\n pub enum RangeOrOffset {\n     Range(TextRange),\n-    Offset(TextUnit),\n+    Offset(TextSize),\n }\n \n impl From<RangeOrOffset> for TextRange {\n     fn from(selection: RangeOrOffset) -> Self {\n         match selection {\n             RangeOrOffset::Range(it) => it,\n-            RangeOrOffset::Offset(it) => TextRange::from_to(it, it),\n+            RangeOrOffset::Offset(it) => TextRange::new(it, it),\n         }\n     }\n }\n \n-/// Extracts `TextRange` or `TextUnit` depending on the amount of `<|>` markers\n+/// Extracts `TextRange` or `TextSize` depending on the amount of `<|>` markers\n /// found in `text`.\n ///\n /// # Panics\n@@ -129,13 +129,13 @@ pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n                 text = &text[i..];\n                 if text.starts_with(&open) {\n                     text = &text[open.len()..];\n-                    let from = TextUnit::of_str(&res);\n+                    let from = TextSize::of(&res);\n                     stack.push(from);\n                 } else if text.starts_with(&close) {\n                     text = &text[close.len()..];\n                     let from = stack.pop().unwrap_or_else(|| panic!(\"unmatched </{}>\", tag));\n-                    let to = TextUnit::of_str(&res);\n-                    ranges.push(TextRange::from_to(from, to));\n+                    let to = TextSize::of(&res);\n+                    ranges.push(TextRange::new(from, to));\n                 }\n             }\n         }\n@@ -146,8 +146,8 @@ pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n }\n \n /// Inserts `<|>` marker into the `text` at `offset`.\n-pub fn add_cursor(text: &str, offset: TextUnit) -> String {\n-    let offset: usize = offset.to_usize();\n+pub fn add_cursor(text: &str, offset: TextSize) -> String {\n+    let offset: usize = offset.into();\n     let mut res = String::new();\n     res.push_str(&text[..offset]);\n     res.push_str(\"<|>\");"}, {"sha": "e138c656a72c5266060445f363b66ab25258c7cc", "filename": "docs/dev/syntax.md", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/docs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996/docs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fsyntax.md?ref=b1d5817dd18b7b5fc102a63b084b1ee7ff4f9996", "patch": "@@ -17,7 +17,7 @@ The things described are implemented in two places\n \n * Syntax trees are lossless, or full fidelity. All comments and whitespace are preserved.\n * Syntax trees are semantic-less. They describe *strictly* the structure of a sequence of characters, they don't have hygiene, name resolution or type information attached.\n-* Syntax trees are simple value type. It is possible to create trees for a syntax without any external context. \n+* Syntax trees are simple value type. It is possible to create trees for a syntax without any external context.\n * Syntax trees have intuitive traversal API (parent, children, siblings, etc).\n * Parsing is lossless (even if the input is invalid, the tree produced by the parser represents it exactly).\n * Parsing is resilient (even if the input is invalid, parser tries to see as much syntax tree fragments in the input as it can).\n@@ -34,12 +34,12 @@ The syntax tree consists of three layers:\n * SyntaxNodes (aka RedNode)\n * AST\n \n-Of these, only GreenNodes store the actual data, the other two layers are (non-trivial) views into green tree. \n+Of these, only GreenNodes store the actual data, the other two layers are (non-trivial) views into green tree.\n Red-green terminology comes from Roslyn ([link](https://docs.microsoft.com/en-ie/archive/blogs/ericlippert/persistence-facades-and-roslyns-red-green-trees)) and gives the name to the `rowan` library. Green and syntax nodes are defined in rowan, ast is defined in rust-analyzer.\n \n Syntax trees are a semi-transient data structure.\n In general, frontend does not keep syntax trees for all files in memory.\n-Instead, it *lowers* syntax trees to more compact and rigid representation, which is not full-fidelity, but which can be mapped back to a syntax tree if so desired. \n+Instead, it *lowers* syntax trees to more compact and rigid representation, which is not full-fidelity, but which can be mapped back to a syntax tree if so desired.\n \n \n ### GreenNode\n@@ -64,7 +64,7 @@ struct Token {\n }\n ```\n \n-All the difference bettwen the above sketch and the real implementation are strictly due to optimizations. \n+All the difference bettwen the above sketch and the real implementation are strictly due to optimizations.\n \n Points of note:\n * The tree is untyped. Each node has a \"type tag\", `SyntaxKind`.\n@@ -73,7 +73,7 @@ Points of note:\n * Each token carries its full text.\n * The original text can be recovered by concatenating the texts of all tokens in order.\n * Accessing a child of particular type (for example, parameter list of a function) generarly involves linerary traversing the children, looking for a specific `kind`.\n-* Modifying the tree is roughly `O(depth)`. \n+* Modifying the tree is roughly `O(depth)`.\n   We don't make special efforts to guarantree that the depth is not liner, but, in practice, syntax trees are branchy and shallow.\n * If mandatory (grammar wise) node is missing from the input, it's just missing from the tree.\n * If an extra erroneous input is present, it is wrapped into a node with `ERROR` kind, and treated just like any other node.\n@@ -122,20 +122,20 @@ To reduce the amount of allocations, the GreenNode is a DST, which uses a single\n To more compactly store the children, we box *both* interior nodes and tokens, and represent\n `Either<Arc<Node>, Arc<Token>>` as a single pointer with a tag in the last bit.\n \n-To avoid allocating EVERY SINGLE TOKEN on the heap, syntax trees use interning. \n+To avoid allocating EVERY SINGLE TOKEN on the heap, syntax trees use interning.\n Because the tree is fully imutable, it's valid to structuraly share subtrees.\n-For example, in `1 + 1`, there will be a *single* token for `1` with ref count 2; the same goes for the ` ` whitespace token. \n-Interior nodes are shared as well (for example in `(1 + 1) * (1 + 1)`). \n+For example, in `1 + 1`, there will be a *single* token for `1` with ref count 2; the same goes for the ` ` whitespace token.\n+Interior nodes are shared as well (for example in `(1 + 1) * (1 + 1)`).\n \n-Note that, the result of the interning is an `Arc<Node>`. \n+Note that, the result of the interning is an `Arc<Node>`.\n That is, it's not an index into interning table, so you don't have to have the table around to do anything with the tree.\n Each tree is fully self-contained (although different trees might share parts).\n-Currently, the interner is created per-file, but it will be easy to use a per-thread or per-some-contex one. \n+Currently, the interner is created per-file, but it will be easy to use a per-thread or per-some-contex one.\n \n-We use a `TextUnit`, a newtyped `u32`, to store the length of the text.\n+We use a `TextSize`, a newtyped `u32`, to store the length of the text.\n \n-We currently use `SmolStr`, an small object optimized string to store text. \n-This was mostly relevant *before* we implmented tree interning, to avoid allocating common keywords and identifiers. We should switch to storing text data alongside the interned tokens. \n+We currently use `SmolStr`, an small object optimized string to store text.\n+This was mostly relevant *before* we implmented tree interning, to avoid allocating common keywords and identifiers. We should switch to storing text data alongside the interned tokens.\n \n #### Alternative designs\n \n@@ -153,9 +153,9 @@ struct Token {\n }\n ```\n \n-The tree then contains only non-trivia tokens. \n+The tree then contains only non-trivia tokens.\n \n-Another approach (from Dart) is to, in addition to a syntax tree, link all the tokens into a bidirectional link list. \n+Another approach (from Dart) is to, in addition to a syntax tree, link all the tokens into a bidirectional link list.\n That way, the tree again contains only non-trivia tokens.\n \n Explicit trivia nodes, like in `rowan`, are used by IntelliJ.\n@@ -165,26 +165,26 @@ Explicit trivia nodes, like in `rowan`, are used by IntelliJ.\n As noted before, accesing a specific child in the node requires a linear traversal of the children (though we can skip tokens, beacuse the tag is encoded in the pointer itself).\n It is possible to recover O(1) access with another representation.\n We explicitly store optional and missing (required by the grammar, but not present) nodes.\n-That is, we use `Option<Node>` for children. \n+That is, we use `Option<Node>` for children.\n We also remove trivia tokens from the tree.\n-This way, each child kind genrerally occupies a fixed position in a parent, and we can use index access to fetch it. \n+This way, each child kind genrerally occupies a fixed position in a parent, and we can use index access to fetch it.\n The cost is that we now need to allocate space for all not-present optional nodes.\n-So, `fn foo() {}` will have slots for visibility, unsafeness, attributes, abi and return type. \n+So, `fn foo() {}` will have slots for visibility, unsafeness, attributes, abi and return type.\n \n IntelliJ uses linear traversal.\n Roslyn and Swift do `O(1)` access.\n \n ##### Mutable Trees\n \n-IntelliJ uses mutable trees. \n+IntelliJ uses mutable trees.\n Overall, it creates a lot of additional complexity.\n However, the API for *editing* syntax trees is nice.\n \n For example the assist to move generic bounds to where clause has this code:\n \n ```kotlin\n- for typeBound in typeBounds { \n-     typeBound.typeParamBounds?.delete() \n+ for typeBound in typeBounds {\n+     typeBound.typeParamBounds?.delete()\n }\n ```\n \n@@ -195,7 +195,7 @@ Modeling this with immutable trees is possible, but annoying.\n A function green tree is not super-convenient to use.\n The biggest problem is acessing parents (there are no parent pointers!).\n But there are also \"identify\" issues.\n-Let's say you want to write a code which builds a list of expressions in a file: `fn collect_exrepssions(file: GreenNode) -> HashSet<GreenNode>`. \n+Let's say you want to write a code which builds a list of expressions in a file: `fn collect_exrepssions(file: GreenNode) -> HashSet<GreenNode>`.\n For the input like\n \n ```rust\n@@ -233,7 +233,7 @@ impl SyntaxNode {\n         })\n     }\n     fn parent(&self) -> Option<SyntaxNode> {\n-        self.parent.clone()    \n+        self.parent.clone()\n     }\n     fn children(&self) -> impl Iterator<Item = SyntaxNode> {\n         let mut offset = self.offset\n@@ -251,8 +251,8 @@ impl SyntaxNode {\n \n impl PartialEq for SyntaxNode {\n     fn eq(&self, other: &SyntaxNode) {\n-        self.offset == other.offset \n-            && Arc::ptr_eq(&self.green, &other.green)        \n+        self.offset == other.offset\n+            && Arc::ptr_eq(&self.green, &other.green)\n     }\n }\n ```\n@@ -261,35 +261,35 @@ Points of note:\n \n * SyntaxNode remembers its parent node (and, transitively, the path to the root of the tree)\n * SyntaxNode knows its *absolute* text offset in the whole file\n-* Equality is based on identity. Comparing nodes from different trees does not make sense. \n+* Equality is based on identity. Comparing nodes from different trees does not make sense.\n \n #### Optimization\n \n-The reality is different though :-) \n+The reality is different though :-)\n Traversal of trees is a common operation, and it makes sense to optimize it.\n In particular, the above code allocates and does atomic operations during a traversal.\n \n To get rid of atomics, `rowan` uses non thread-safe `Rc`.\n-This is OK because trees traversals mostly (always, in case of rust-analyzer) run on a single thread. If you need to send a `SyntaxNode` to another thread, you can send a pair of **root**`GreenNode` (which is thread safe) and a `Range<usize>`. \n-The other thread can restore the `SyntaxNode` by traversing from the root green node and looking for a node with specified range. \n+This is OK because trees traversals mostly (always, in case of rust-analyzer) run on a single thread. If you need to send a `SyntaxNode` to another thread, you can send a pair of **root**`GreenNode` (which is thread safe) and a `Range<usize>`.\n+The other thread can restore the `SyntaxNode` by traversing from the root green node and looking for a node with specified range.\n You can also use the similar trick to store a `SyntaxNode`.\n That is, a data structure that holds a `(GreenNode, Range<usize>)` will be `Sync`.\n-However rust-analyzer goes even further. \n+However rust-analyzer goes even further.\n It treats trees as semi-transient and instead of storing a `GreenNode`, it generally stores just the id of the file from which the tree originated: `(FileId, Range<usize>)`.\n The `SyntaxNode` is the restored by reparsing the file and traversing it from root.\n With this trick, rust-analyzer holds only a small amount of trees in memory at the same time, which reduces memory usage.\n \n Additionally, only the root `SyntaxNode` owns an `Arc` to the (root) `GreenNode`.\n-All other `SyntaxNode`s point to corresponding `GreenNode`s with a raw pointer. \n-They also point to the parent (and, consequently, to the root) with an owning `Rc`, so this is sound. \n+All other `SyntaxNode`s point to corresponding `GreenNode`s with a raw pointer.\n+They also point to the parent (and, consequently, to the root) with an owning `Rc`, so this is sound.\n In other words, one needs *one* arc bump when initiating a traversal.\n \n-To get rid of allocations, `rowan` takes advantage of `SyntaxNode: !Sync` and uses a thread-local free list of `SyntaxNode`s. \n-In a typical traversal, you only directly hold a few `SyntaxNode`s at a time (and their ancesstors indirectly), so a free list proportional to the depth of the tree removes all allocations in a typical case. \n+To get rid of allocations, `rowan` takes advantage of `SyntaxNode: !Sync` and uses a thread-local free list of `SyntaxNode`s.\n+In a typical traversal, you only directly hold a few `SyntaxNode`s at a time (and their ancesstors indirectly), so a free list proportional to the depth of the tree removes all allocations in a typical case.\n \n So, while traversal is not exactly incrementing a pointer, it's still prety cheep: tls + rc bump!\n \n-Traversal also yields (cheap) owned nodes, which improves ergonomics quite a bit. \n+Traversal also yields (cheap) owned nodes, which improves ergonomics quite a bit.\n \n #### Alternative Designs\n \n@@ -309,14 +309,14 @@ struct SyntaxData {\n ```\n \n This allows using true pointer equality for comparision of identities of `SyntaxNodes`.\n-rust-analyzer used to have this design as well, but since we've switch to cursors. \n-The main problem with memoizing the red nodes is that it more than doubles the memory requirenments for fully realized syntax trees. \n+rust-analyzer used to have this design as well, but since we've switch to cursors.\n+The main problem with memoizing the red nodes is that it more than doubles the memory requirenments for fully realized syntax trees.\n In contrast, cursors generally retain only a path to the root.\n-C# combats increased memory usage by using weak references. \n+C# combats increased memory usage by using weak references.\n \n ### AST\n \n-`GreenTree`s are untyped and homogeneous, because it makes accomodating error nodes, arbitrary whitespace and comments natural, and because it makes possible to write generic tree traversals. \n+`GreenTree`s are untyped and homogeneous, because it makes accomodating error nodes, arbitrary whitespace and comments natural, and because it makes possible to write generic tree traversals.\n However, when working with a specific node, like a function definition, one would want a strongly typed API.\n \n This is what is provided by the AST layer. AST nodes are transparent wrappers over untyped syntax nodes:\n@@ -352,13 +352,13 @@ impl AstNode for FnDef {\n }\n \n impl FnDef {\n-    pub fn param_list(&self) -> Option<ParamList> { \n+    pub fn param_list(&self) -> Option<ParamList> {\n         self.syntax.children().find_map(ParamList::cast)\n     }\n-    pub fn ret_type(&self) -> Option<RetType> { \n+    pub fn ret_type(&self) -> Option<RetType> {\n         self.syntax.children().find_map(RetType::cast)\n     }\n-    pub fn body(&self) -> Option<BlockExpr> { \n+    pub fn body(&self) -> Option<BlockExpr> {\n         self.syntax.children().find_map(BlockExpr::cast)\n     }\n     // ...\n@@ -409,14 +409,14 @@ Points of note:\n \n ##### Semantic Full AST\n \n-In IntelliJ the AST layer (dubbed **P**rogram **S**tructure **I**nterface) can have semantics attached, and is usually backed by either syntax tree, indices, or metadata from compiled libraries. \n+In IntelliJ the AST layer (dubbed **P**rogram **S**tructure **I**nterface) can have semantics attached, and is usually backed by either syntax tree, indices, or metadata from compiled libraries.\n The backend for PSI can change dynamically.\n \n ### Syntax Tree Recap\n \n-At its core, the syntax tree is a purely functional n-ary tree, which stores text at the leaf nodes and node \"kinds\" at all nodes. \n+At its core, the syntax tree is a purely functional n-ary tree, which stores text at the leaf nodes and node \"kinds\" at all nodes.\n A cursor layer is added on top, which gives owned, cheap to clone nodes with identity semantics, parent links and absolute offsets.\n-An AST layer is added on top, which reifies each node `Kind` as a separate Rust type with the corresponding API. \n+An AST layer is added on top, which reifies each node `Kind` as a separate Rust type with the corresponding API.\n \n ## Parsing\n \n@@ -432,17 +432,17 @@ impl GreenNodeBuilder {\n \n     pub fn start_node(&mut self, kind: SyntaxKind) { ... }\n     pub fn finish_node(&mut self) { ... }\n-    \n+\n     pub fn finish(self) -> GreenNode { ... }\n }\n ```\n \n-The parser, ultimatelly, needs to invoke the `GreenNodeBuilder`. \n+The parser, ultimatelly, needs to invoke the `GreenNodeBuilder`.\n There are two principal sources of inputs for the parser:\n   * source text, which contains trivia tokens (whitespace and comments)\n   * token trees from macros, which lack trivia\n \n-Additionaly, input tokens do not correspond 1-to-1 with output tokens. \n+Additionaly, input tokens do not correspond 1-to-1 with output tokens.\n For example, two consequtive `>` tokens might be glued, by the parser, into a single `>>`.\n \n For these reasons, the parser crate defines a callback interfaces for both input tokens and output trees.\n@@ -474,7 +474,7 @@ pub trait TreeSink {\n }\n \n pub fn parse(\n-    token_source: &mut dyn TokenSource, \n+    token_source: &mut dyn TokenSource,\n     tree_sink: &mut dyn TreeSink,\n ) { ... }\n ```\n@@ -491,21 +491,21 @@ Syntax errors are not stored directly in the tree.\n The primary motivation for this is that syntax tree is not necessary produced by the parser, it may also be assembled manually from pieces (which happens all the time in refactorings).\n Instead, parser reports errors to an error sink, which stores them in a `Vec`.\n If possible, errors are not reported during parsing and are postponed for a separate validation step.\n-For example, parser accepts visibility modifiers on trait methods, but then a separate tree traversal flags all such visibilites as erroneous. \n+For example, parser accepts visibility modifiers on trait methods, but then a separate tree traversal flags all such visibilites as erroneous.\n \n ### Macros\n \n-The primary difficulty with macros is that individual tokens have identities, which need to be preserved in the syntax tree for hygiene purposes. \n+The primary difficulty with macros is that individual tokens have identities, which need to be preserved in the syntax tree for hygiene purposes.\n This is handled by the `TreeSink` layer.\n Specifically, `TreeSink` constructs the tree in lockstep with draining the original token stream.\n-In the process, it records which tokens of the tree correspond to which tokens of the input, by using text ranges to identify syntax tokens. \n+In the process, it records which tokens of the tree correspond to which tokens of the input, by using text ranges to identify syntax tokens.\n The end result is that parsing an expanded code yields a syntax tree and a mapping of text-ranges of the tree to original tokens.\n \n To deal with precedence in cases like `$expr * 1`, we use special invisible parenthesis, which are explicitelly handled by the parser\n \n ### Whitespace & Comments\n \n-Parser does not see whitespace nodes. \n+Parser does not see whitespace nodes.\n Instead, they are attached to the tree in the `TreeSink` layer.\n \n For example, in\n@@ -521,7 +521,7 @@ the comment will be (heuristically) made a child of function node.\n \n Green trees are cheap to modify, so incremental reparse works by patching a previous tree, without maintaining any additional state.\n The reparse is based on heuristic: we try to contain a change to a single `{}` block, and reparse only this block.\n-To do this, we maintain the invariant that, even for invalid code, curly braces are always paired correctly. \n+To do this, we maintain the invariant that, even for invalid code, curly braces are always paired correctly.\n \n In practice, incremental reparsing doesn't actually matter much for IDE use-cases, parsing from scratch seems to be fast enough.\n "}]}