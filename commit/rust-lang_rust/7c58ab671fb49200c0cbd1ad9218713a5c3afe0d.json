{"sha": "7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNThhYjY3MWZiNDkyMDBjMGNiZDFhZDkyMTg3MTNhNWMzYWZlMGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-08-02T19:30:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-08-07T15:42:38Z"}, "message": "rustc: Tweak visibility of some lang items\n\nThis commit tweaks the linker-level visibility of some lang items that rustc\nuses and defines. Notably this means that `#[panic_implementation]` and\n`#[alloc_error_handler]` functions are never marked as `internal`. It's up to\nthe linker to eliminate these, not rustc.\n\nAdditionally `#[global_allocator]` generated symbols are no longer forced to\n`Default` visibility (fully exported), but rather they're relaxed to `Hidden`\nvisibility). This symbols are *not* needed across DLL boundaries, only as a\nlocal implementation detail of the compiler-injected allocator symbols, so\n`Hidden` should suffice.\n\nCloses #51342\nCloses #52795", "tree": {"sha": "98ffced29d28fd7353586a2663fcc8cbfae47b44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98ffced29d28fd7353586a2663fcc8cbfae47b44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "html_url": "https://github.com/rust-lang/rust/commit/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38eeebdfed97af43354ed924e498764e8f9cdae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/38eeebdfed97af43354ed924e498764e8f9cdae5", "html_url": "https://github.com/rust-lang/rust/commit/38eeebdfed97af43354ed924e498764e8f9cdae5"}], "stats": {"total": 294, "additions": 238, "deletions": 56}, "files": [{"sha": "a09942258e22d9b2aba6d54b974b75b9b4544bf9", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -15,7 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use hir::CodegenFnAttrs;\n+use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n@@ -28,7 +28,6 @@ use util::nodemap::{NodeSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::attr;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -359,8 +358,12 @@ struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // Anything which has custom linkage gets thrown on the worklist no\n-        // matter where it is in the crate.\n-        if attr::contains_name(&item.attrs, \"linkage\") {\n+        // matter where it is in the crate, along with \"special std symbols\"\n+        // which are currently akin to allocator symbols.\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+        if codegen_attrs.linkage.is_some() ||\n+            codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n             self.worklist.push(item.id);\n         }\n "}, {"sha": "05843852ee0de713c0a25a4b51ecc152bbce6bbb", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -13,7 +13,7 @@ use rustc_errors;\n use syntax::{\n     ast::{\n         self, Arg, Attribute, Crate, Expr, FnHeader, Generics, Ident, Item, ItemKind,\n-        LitKind, Mac, Mod, Mutability, StrStyle, Ty, TyKind, Unsafety, VisibilityKind,\n+        Mac, Mod, Mutability, Ty, TyKind, Unsafety, VisibilityKind,\n     },\n     attr,\n     codemap::{\n@@ -236,17 +236,12 @@ impl<'a> AllocFnFactory<'a> {\n     }\n \n     fn attrs(&self) -> Vec<Attribute> {\n-        let key = Symbol::intern(\"linkage\");\n-        let value = LitKind::Str(Symbol::intern(\"external\"), StrStyle::Cooked);\n-        let linkage = self.cx.meta_name_value(self.span, key, value);\n-\n         let no_mangle = Symbol::intern(\"no_mangle\");\n         let no_mangle = self.cx.meta_word(self.span, no_mangle);\n \n         let special = Symbol::intern(\"rustc_std_internal_symbol\");\n         let special = self.cx.meta_word(self.span, special);\n         vec![\n-            self.cx.attribute(self.span, linkage),\n             self.cx.attribute(self.span, no_mangle),\n             self.cx.attribute(self.span, special),\n         ]"}, {"sha": "0beb8a8844c958f281f98f9e902c4b8dcb9a3fb3", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -67,14 +67,15 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind\n         if tcx.sess.target.target.options.default_hidden_visibility {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n-       if tcx.sess.target.target.options.requires_uwtable {\n-           attributes::emit_uwtable(llfn, true);\n-       }\n+        if tcx.sess.target.target.options.requires_uwtable {\n+            attributes::emit_uwtable(llfn, true);\n+        }\n \n         let callee = CString::new(kind.fn_name(method.name)).unwrap();\n         let callee = llvm::LLVMRustGetOrInsertFunction(llmod,\n                                                        callee.as_ptr(),\n                                                        ty);\n+        llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n \n         let llbb = llvm::LLVMAppendBasicBlockInContext(llcx,\n                                                        llfn,"}, {"sha": "0a8bc03d8d41cf38edc31116bba2055d39793ba2", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -809,8 +809,28 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx,\n         codegen_units.len());\n \n-    // Codegen an allocator shim, if any\n-    let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n+    // Codegen an allocator shim, if necessary.\n+    //\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+        .iter()\n+        .any(|(_, list)| {\n+            use rustc::middle::dependency_format::Linkage;\n+            list.iter().any(|linkage| {\n+                match linkage {\n+                    Linkage::Dynamic => true,\n+                    _ => false,\n+                }\n+            })\n+        });\n+    let allocator_module = if any_dynamic_crate {\n+        None\n+    } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         unsafe {\n             let llmod_id = \"allocator\";\n             let modules = ModuleLlvm::new(tcx.sess, llmod_id);"}, {"sha": "4e32ca483a1253e9dffee63e63aedcdc8d52adfc", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 95, "deletions": 41, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -104,6 +104,7 @@\n \n use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility};\n@@ -300,6 +301,13 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n     let mut internalization_candidates = FxHashSet();\n \n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics = tcx.sess.opts.share_generics() &&\n+                          tcx.local_crate_exports_generics();\n+\n     for mono_item in mono_items {\n         match mono_item.instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n@@ -323,29 +331,7 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx,\n             &mono_item,\n             &mut can_be_internalized,\n-            &|id, is_generic| {\n-                if !tcx.sess.target.target.options.default_hidden_visibility {\n-                    return Visibility::Default\n-                }\n-\n-                // Generic functions never have export level C\n-                if is_generic {\n-                    return Visibility::Hidden\n-                }\n-\n-                // Things with export level C don't get instantiated in\n-                // downstream crates\n-                if !id.is_local() {\n-                    return Visibility::Hidden\n-                }\n-\n-                // C-export level items remain at `Default`, all other internal\n-                // items become `Hidden`\n-                match tcx.reachable_non_generics(id.krate).get(&id) {\n-                    Some(SymbolExportLevel::C) => Visibility::Default,\n-                    _ => Visibility::Hidden,\n-                }\n-            },\n+            export_generics,\n         );\n         if visibility == Visibility::Hidden && can_be_internalized {\n             internalization_candidates.insert(mono_item);\n@@ -376,20 +362,25 @@ fn mono_item_linkage_and_visibility(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n-    default: &dyn Fn(DefId, bool) -> Visibility,\n+    export_generics: bool,\n ) -> (Linkage, Visibility) {\n     if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n         return (explicit_linkage, Visibility::Default)\n     }\n-    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, default);\n+    let vis = mono_item_visibility(\n+        tcx,\n+        mono_item,\n+        can_be_internalized,\n+        export_generics,\n+    );\n     (Linkage::External, vis)\n }\n \n fn mono_item_visibility(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n-    default_visibility: &dyn Fn(DefId, bool) -> Visibility,\n+    export_generics: bool,\n ) -> Visibility {\n     let instance = match mono_item {\n         // This is pretty complicated, go below\n@@ -399,7 +390,7 @@ fn mono_item_visibility(\n         MonoItem::Static(def_id) => {\n             return if tcx.is_reachable_non_generic(*def_id) {\n                 *can_be_internalized = false;\n-                default_visibility(*def_id, false)\n+                default_visibility(tcx, *def_id, false)\n             } else {\n                 Visibility::Hidden\n             };\n@@ -408,7 +399,7 @@ fn mono_item_visibility(\n             let def_id = tcx.hir.local_def_id(*node_id);\n             return if tcx.is_reachable_non_generic(def_id) {\n                 *can_be_internalized = false;\n-                default_visibility(def_id, false)\n+                default_visibility(tcx, def_id, false)\n             } else {\n                 Visibility::Hidden\n             };\n@@ -440,18 +431,13 @@ fn mono_item_visibility(\n     //        hidden visibility, it should indeed be a candidate for\n     //        internalization, but we have to understand that it's referenced\n     //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n     if tcx.lang_items().start_fn() == Some(def_id) {\n         *can_be_internalized = false;\n         return Visibility::Hidden\n     }\n \n-    // Determine if monomorphizations instantiated in this crate will be made\n-    // available to downstream crates. This depends on whether we are in\n-    // share-generics mode and whether the current crate can even have\n-    // downstream crates.\n-    let export_generics = tcx.sess.opts.share_generics() &&\n-                          tcx.local_crate_exports_generics();\n-\n     let is_generic = instance.substs.types().next().is_some();\n \n     // Upstream `DefId` instances get different handling than local ones\n@@ -461,7 +447,7 @@ fn mono_item_visibility(\n             // and we export generics, we must make\n             // it available to downstream crates.\n             *can_be_internalized = false;\n-            default_visibility(def_id, true)\n+            default_visibility(tcx, def_id, true)\n         } else {\n             Visibility::Hidden\n         }\n@@ -477,7 +463,7 @@ fn mono_item_visibility(\n                 // This instance might be useful in\n                 // a downstream crate.\n                 *can_be_internalized = false;\n-                default_visibility(def_id, true)\n+                default_visibility(tcx, def_id, true)\n             }\n         } else {\n             // We are not exporting generics or\n@@ -487,14 +473,82 @@ fn mono_item_visibility(\n             Visibility::Hidden\n         }\n     } else {\n-        // This isn't a generic function.\n+\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n         if tcx.is_reachable_non_generic(def_id) {\n             *can_be_internalized = false;\n             debug_assert!(!is_generic);\n-            default_visibility(def_id, false)\n-        } else {\n-            Visibility::Hidden\n+            return default_visibility(tcx, def_id, false)\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_implementation]` definitions. The\n+        //   definition of these weak lang items needs to be referenceable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(def_id);\n+        let std_internal_symbol = codegen_fn_attrs.flags\n+            .contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n+        if tcx.is_weak_lang_item(def_id) || std_internal_symbol {\n+            *can_be_internalized = false;\n         }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.target.options.default_hidden_visibility {\n+        return Visibility::Default\n+    }\n+\n+    // Generic functions never have export level C\n+    if is_generic {\n+        return Visibility::Hidden\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates\n+    if !id.is_local() {\n+        return Visibility::Hidden\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportLevel::C) => Visibility::Default,\n+        _ => Visibility::Hidden,\n     }\n }\n "}, {"sha": "872825113a84538863f015e3be738d27f96d53d3", "filename": "src/test/run-make/wasm-symbols-not-exported/Makefile", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2FMakefile?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -0,0 +1,16 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),wasm32-unknown-unknown)\n+all:\n+\t$(RUSTC) foo.rs --target wasm32-unknown-unknown\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/foo.wasm\n+\t$(RUSTC) foo.rs --target wasm32-unknown-unknown -O\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/foo.wasm\n+\t$(RUSTC) bar.rs --target wasm32-unknown-unknown\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/bar.wasm\n+\t$(RUSTC) bar.rs --target wasm32-unknown-unknown -O\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/bar.wasm\n+else\n+all:\n+endif\n+"}, {"sha": "979ec44b040776407dd955a1b5a5cf4ade1e057c", "filename": "src/test/run-make/wasm-symbols-not-exported/bar.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(panic_implementation, alloc_error_handler)]\n+#![crate_type = \"cdylib\"]\n+#![no_std]\n+\n+use core::alloc::*;\n+\n+struct B;\n+\n+unsafe impl GlobalAlloc for B {\n+    unsafe fn alloc(&self, x: Layout) -> *mut u8 {\n+        1 as *mut u8\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, x: Layout) {\n+    }\n+}\n+\n+#[global_allocator]\n+static A: B = B;\n+\n+#[no_mangle]\n+pub extern fn foo(a: u32) -> u32 {\n+    assert_eq!(a, 3);\n+    a * 2\n+}\n+\n+#[alloc_error_handler]\n+fn a(_: core::alloc::Layout) -> ! {\n+    loop {}\n+}\n+\n+#[panic_implementation]\n+fn b(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "cd8c7cb205d96b2b31c82059e9e7e4beefbf5333", "filename": "src/test/run-make/wasm-symbols-not-exported/foo.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Ffoo.rs?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"cdylib\"]\n+\n+#[no_mangle]\n+pub extern fn foo() {\n+    println!(\"foo\");\n+    panic!(\"test\");\n+}"}, {"sha": "060830eb01a7191183743f4eae91d1ef3fbbcaf3", "filename": "src/test/run-make/wasm-symbols-not-exported/verify-exported-symbols.js", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fverify-exported-symbols.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fverify-exported-symbols.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fverify-exported-symbols.js?ref=7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const fs = require('fs');\n+const process = require('process');\n+const assert = require('assert');\n+const buffer = fs.readFileSync(process.argv[2]);\n+\n+let m = new WebAssembly.Module(buffer);\n+let list = WebAssembly.Module.exports(m);\n+console.log('exports', list);\n+\n+let bad = false;\n+for (let i = 0; i < list.length; i++) {\n+  const e = list[i];\n+  if (e.name == \"foo\" || e.kind != \"function\")\n+    continue;\n+\n+  console.log('unexpected exported symbol:', e.name);\n+  bad = true;\n+}\n+\n+if (bad)\n+  process.exit(1);"}]}