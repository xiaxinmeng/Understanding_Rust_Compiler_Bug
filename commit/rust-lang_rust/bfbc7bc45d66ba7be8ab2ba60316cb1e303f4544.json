{"sha": "bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYmM3YmM0NWQ2NmJhN2JlOGFiMmJhNjAzMTZjYjFlMzAzZjQ1NDQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-23T22:38:42Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-07-24T20:46:17Z"}, "message": "handle all type variants correctly in dropck\n\nThis fixes a few soundness bugs in dropck, so to anyone who relied on them,\nthis is a\n[breaking-change]\n\nFixes #24086.\nFixes #25389.\nFixes #25598.\nFixes #25750.\nFixes #26641.\nFixes #26657.\nFixes #27240.\nFixes #27241.", "tree": {"sha": "c04fad182d83a901e71e045df0ccd7c03efc5182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c04fad182d83a901e71e045df0ccd7c03efc5182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "html_url": "https://github.com/rust-lang/rust/commit/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6b534362de257603f8fc318eba78deb83206e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6b534362de257603f8fc318eba78deb83206e3", "html_url": "https://github.com/rust-lang/rust/commit/5e6b534362de257603f8fc318eba78deb83206e3"}], "stats": {"total": 501, "additions": 309, "deletions": 192}, "files": [{"sha": "7cb9b6c22b92f78aa1dbf432534ae8df0e4f18e0", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 184, "deletions": 191, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "patch": "@@ -268,7 +268,6 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n         typ,\n         span,\n         scope,\n-        0,\n         0);\n     match result {\n         Ok(()) => {}\n@@ -311,6 +310,7 @@ enum Error<'tcx> {\n     Overflow(TypeContext, ty::Ty<'tcx>),\n }\n \n+#[derive(Copy, Clone)]\n enum TypeContext {\n     Root,\n     EnumVariant {\n@@ -331,217 +331,209 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n     rcx: &mut Rcx<'a, 'tcx>,\n     breadcrumbs: &mut Vec<Ty<'tcx>>,\n     context: TypeContext,\n-    ty_root: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     span: Span,\n     scope: region::CodeExtent,\n-    depth: usize,\n-    xref_depth: usize) -> Result<(), Error<'tcx>>\n+    depth: usize) -> Result<(), Error<'tcx>>\n {\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n     let recursion_limit = rcx.tcx().sess.recursion_limit.get();\n-    if xref_depth >= recursion_limit {\n-        return Err(Error::Overflow(context, ty_root))\n+    if depth / 4 >= recursion_limit {\n+        return Err(Error::Overflow(context, ty))\n     }\n \n-    let origin = || infer::SubregionOrigin::SafeDestructor(span);\n-    let mut walker = ty_root.walk();\n     let opt_phantom_data_def_id = rcx.tcx().lang_items.phantom_data();\n \n-    let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n+    // FIXME(arielb1): don't be O(n^2)\n+    if breadcrumbs.contains(&ty) {\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+               {}ty: {} scope: {:?} - cached\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               ty, scope);\n+        return Ok(()); // we already visited this type\n+    }\n+    breadcrumbs.push(ty);\n+    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+           {}ty: {} scope: {:?}\",\n+           (0..depth).map(|_| ' ').collect::<String>(),\n+           ty, scope);\n+\n+    // FIXME(arielb1): move into has_dtor_of_interest\n+    let dtor_kind = match ty.sty {\n+        ty::TyEnum(def_id, _) |\n+        ty::TyStruct(def_id, _) => {\n+            let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n+            match destructor_for_type.get(&def_id) {\n+                Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n+                None => DtorKind::PureRecur,\n+            }\n+        }\n+        ty::TyTrait(..) | ty::TyProjection(..) => DtorKind::Unknown,\n+        _ => DtorKind::PureRecur,\n+    };\n+\n \n-    let xref_depth_orig = xref_depth;\n+    // If `typ` has a destructor, then we must ensure that all\n+    // borrowed data reachable via `typ` must outlive the parent\n+    // of `scope`. This is handled below.\n+    //\n+    // However, there is an important special case: by\n+    // parametricity, any generic type parameters have *no* trait\n+    // bounds in the Drop impl can not be used in any way (apart\n+    // from being dropped), and thus we can treat data borrowed\n+    // via such type parameters remains unreachable.\n+    //\n+    // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n+    // which does have to be able to drop instances of `T`, but\n+    // otherwise cannot read data from `T`.\n+    //\n+    // Of course, for the type expression passed in for any such\n+    // unbounded type parameter `T`, we must resume the recursive\n+    // analysis on `T` (since it would be ignored by\n+    // type_must_outlive).\n+    //\n+    // FIXME (pnkfelix): Long term, we could be smart and actually\n+    // feed which generic parameters can be ignored *into* `fn\n+    // type_must_outlive` (or some generalization thereof). But\n+    // for the short term, it probably covers most cases of\n+    // interest to just special case Drop impls where: (1.) there\n+    // are no generic lifetime parameters and (2.)  *all* generic\n+    // type parameters are unbounded.  If both conditions hold, we\n+    // simply skip the `type_must_outlive` call entirely (but\n+    // resume the recursive checking of the type-substructure).\n+    if has_dtor_of_interest(rcx.tcx(), dtor_kind, ty, span) {\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+                {}ty: {} - is a dtorck type!\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               ty);\n+\n+        // If `ty` is a dtorck type, then we must ensure that all\n+        // borrowed data reachable via `ty` must outlive the\n+        // parent of `scope`. (It does not suffice for it to\n+        // outlive `scope` because that could imply that the\n+        // borrowed data is torn down in between the end of\n+        // `scope` and when the destructor itself actually runs.)\n+        let parent_region =\n+            match rcx.tcx().region_maps.opt_encl_scope(scope) {\n+                Some(parent_scope) => ty::ReScope(parent_scope),\n+                None => rcx.tcx().sess.span_bug(\n+                    span, &format!(\"no enclosing scope found for scope: {:?}\",\n+                                   scope)),\n+            };\n \n-    while let Some(typ) = walker.next() {\n-        // Avoid recursing forever.\n-        if breadcrumbs.contains(&typ) {\n-            continue;\n+        regionck::type_must_outlive(rcx,\n+                                    infer::SubregionOrigin::SafeDestructor(span),\n+                                    ty,\n+                                    parent_region);\n+\n+        return Ok(());\n+    }\n+\n+    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+           {}ty: {} scope: {:?} - checking interior\",\n+           (0..depth).map(|_| ' ').collect::<String>(),\n+           ty, scope);\n+\n+    // We still need to ensure all referenced data is safe.\n+    match ty.sty {\n+        ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n+        ty::TyFloat(_) | ty::TyStr => {\n+            // primitive - definitely safe\n+            Ok(())\n         }\n-        breadcrumbs.push(typ);\n-\n-        // If we encounter `PhantomData<T>`, then we should replace it\n-        // with `T`, the type it represents as owned by the\n-        // surrounding context, before doing further analysis.\n-        let (typ, xref_depth) = match typ.sty {\n-            ty::TyStruct(struct_did, substs) => {\n-                if opt_phantom_data_def_id == Some(struct_did) {\n-                    let item_type = rcx.tcx().lookup_item_type(struct_did);\n-                    let tp_def = item_type.generics.types\n-                        .opt_get(subst::TypeSpace, 0).unwrap();\n-                    let new_typ = substs.type_for_def(tp_def);\n-                    debug!(\"replacing phantom {:?} with {:?}\",\n-                           typ, new_typ);\n-                    (new_typ, xref_depth_orig + 1)\n-                } else {\n-                    (typ, xref_depth_orig)\n-                }\n-            }\n \n-            // Note: When TyBox is removed from compiler, the\n-            // definition of `Box<T>` must carry a PhantomData that\n-            // puts us into the previous case.\n-            ty::TyBox(new_typ) => {\n-                debug!(\"replacing TyBox {:?} with {:?}\",\n-                       typ, new_typ);\n-                (new_typ, xref_depth_orig + 1)\n-            }\n+        ty::TyBox(ity) | ty::TyArray(ity, _) | ty::TySlice(ity) => {\n+            // single-element containers, behave like their element\n+            iterate_over_potentially_unsafe_regions_in_type(\n+                rcx, breadcrumbs, context, ity, span, scope, depth+1)\n+        }\n+\n+        ty::TyStruct(did, substs) if Some(did) == opt_phantom_data_def_id => {\n+            // PhantomData<T> - behaves identically to T\n+            let ity = *substs.types.get(subst::TypeSpace, 0);\n+            iterate_over_potentially_unsafe_regions_in_type(\n+                rcx, breadcrumbs, context, ity, span, scope, depth+1)\n+        }\n \n-            _ => {\n-                (typ, xref_depth_orig)\n+        ty::TyStruct(did, substs) => {\n+            let fields = rcx.tcx().lookup_struct_fields(did);\n+            for field in &fields {\n+                let field_type = rcx.tcx().lookup_field_type(did,\n+                                                             field.id,\n+                                                             substs);\n+                try!(iterate_over_potentially_unsafe_regions_in_type(\n+                    rcx,\n+                    breadcrumbs,\n+                    TypeContext::Struct {\n+                        def_id: did,\n+                        field: field.name,\n+                    },\n+                    rcx.fcx.resolve_type_vars_if_possible(\n+                        rcx.fcx.normalize_associated_types_in(span, &field_type)),\n+                    span,\n+                    scope,\n+                    depth+1))\n             }\n-        };\n-\n-        let dtor_kind = match typ.sty {\n-            ty::TyEnum(def_id, _) |\n-            ty::TyStruct(def_id, _) => {\n-                match destructor_for_type.get(&def_id) {\n-                    Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n-                    None => DtorKind::PureRecur,\n+            Ok(())\n+        }\n+\n+        ty::TyEnum(did, substs) => {\n+            let all_variant_info =\n+                rcx.tcx().substd_enum_variants(did, substs);\n+            for variant_info in &all_variant_info {\n+                for (i, arg_type) in variant_info.args.iter().enumerate() {\n+                    try!(iterate_over_potentially_unsafe_regions_in_type(\n+                        rcx,\n+                        breadcrumbs,\n+                        TypeContext::EnumVariant {\n+                            def_id: did,\n+                            variant: variant_info.name,\n+                            arg_index: i,\n+                        },\n+                        rcx.fcx.resolve_type_vars_if_possible(\n+                            rcx.fcx.normalize_associated_types_in(span, arg_type)),\n+                        span,\n+                        scope,\n+                        depth+1));\n                 }\n             }\n-            ty::TyTrait(ref ty_trait) => {\n-                DtorKind::Unknown(ty_trait.bounds.clone())\n-            }\n-            _ => DtorKind::PureRecur,\n-        };\n-\n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} xref: {}\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               typ, scope, xref_depth);\n+            Ok(())\n+        }\n \n-        // If `typ` has a destructor, then we must ensure that all\n-        // borrowed data reachable via `typ` must outlive the parent\n-        // of `scope`. This is handled below.\n-        //\n-        // However, there is an important special case: by\n-        // parametricity, any generic type parameters have *no* trait\n-        // bounds in the Drop impl can not be used in any way (apart\n-        // from being dropped), and thus we can treat data borrowed\n-        // via such type parameters remains unreachable.\n-        //\n-        // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n-        // which does have to be able to drop instances of `T`, but\n-        // otherwise cannot read data from `T`.\n-        //\n-        // Of course, for the type expression passed in for any such\n-        // unbounded type parameter `T`, we must resume the recursive\n-        // analysis on `T` (since it would be ignored by\n-        // type_must_outlive).\n-        //\n-        // FIXME (pnkfelix): Long term, we could be smart and actually\n-        // feed which generic parameters can be ignored *into* `fn\n-        // type_must_outlive` (or some generalization thereof). But\n-        // for the short term, it probably covers most cases of\n-        // interest to just special case Drop impls where: (1.) there\n-        // are no generic lifetime parameters and (2.)  *all* generic\n-        // type parameters are unbounded.  If both conditions hold, we\n-        // simply skip the `type_must_outlive` call entirely (but\n-        // resume the recursive checking of the type-substructure).\n-\n-        if has_dtor_of_interest(rcx.tcx(), dtor_kind, typ, span) {\n-            // If `typ` has a destructor, then we must ensure that all\n-            // borrowed data reachable via `typ` must outlive the\n-            // parent of `scope`. (It does not suffice for it to\n-            // outlive `scope` because that could imply that the\n-            // borrowed data is torn down in between the end of\n-            // `scope` and when the destructor itself actually runs.)\n-\n-            let parent_region =\n-                match rcx.tcx().region_maps.opt_encl_scope(scope) {\n-                    Some(parent_scope) => ty::ReScope(parent_scope),\n-                    None => rcx.tcx().sess.span_bug(\n-                        span, &format!(\"no enclosing scope found for scope: {:?}\",\n-                                       scope)),\n-                };\n-\n-            regionck::type_must_outlive(rcx, origin(), typ, parent_region);\n-\n-        } else {\n-            // Okay, `typ` itself is itself not reachable by a\n-            // destructor; but it may contain substructure that has a\n-            // destructor.\n-\n-            match typ.sty {\n-                ty::TyStruct(struct_did, substs) => {\n-                    debug!(\"typ: {:?} is struct; traverse structure and not type-expression\",\n-                           typ);\n-                    // Don't recurse; we extract type's substructure,\n-                    // so do not process subparts of type expression.\n-                    walker.skip_current_subtree();\n-\n-                    let fields =\n-                        rcx.tcx().lookup_struct_fields(struct_did);\n-                    for field in &fields {\n-                        let field_type = rcx.tcx().lookup_field_type(struct_did,\n-                                                                     field.id,\n-                                                                     substs);\n-                        try!(iterate_over_potentially_unsafe_regions_in_type(\n-                            rcx,\n-                            breadcrumbs,\n-                            TypeContext::Struct {\n-                                def_id: struct_did,\n-                                field: field.name,\n-                            },\n-                            field_type,\n-                            span,\n-                            scope,\n-                            depth+1,\n-                            xref_depth))\n-                    }\n-                }\n+        ty::TyTuple(ref tys) |\n+        ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) => {\n+            for ty in tys {\n+                try!(iterate_over_potentially_unsafe_regions_in_type(\n+                    rcx, breadcrumbs, context, ty, span, scope, depth+1))\n+            }\n+            Ok(())\n+        }\n \n-                ty::TyEnum(enum_did, substs) => {\n-                    debug!(\"typ: {:?} is enum; traverse structure and not type-expression\",\n-                           typ);\n-                    // Don't recurse; we extract type's substructure,\n-                    // so do not process subparts of type expression.\n-                    walker.skip_current_subtree();\n-\n-                    let all_variant_info =\n-                        rcx.tcx().substd_enum_variants(enum_did, substs);\n-                    for variant_info in &all_variant_info {\n-                        for (i, arg_type) in variant_info.args.iter().enumerate() {\n-                            try!(iterate_over_potentially_unsafe_regions_in_type(\n-                                rcx,\n-                                breadcrumbs,\n-                                TypeContext::EnumVariant {\n-                                    def_id: enum_did,\n-                                    variant: variant_info.name,\n-                                    arg_index: i,\n-                                },\n-                                *arg_type,\n-                                span,\n-                                scope,\n-                                depth+1,\n-                                xref_depth));\n-                        }\n-                    }\n-                }\n+        ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyParam(..) => {\n+            // these always come with a witness of liveness (references\n+            // explicitly, pointers implicitly, parameters by the\n+            // caller).\n+            Ok(())\n+        }\n \n-                ty::TyRef(..) | ty::TyRawPtr(_) | ty::TyBareFn(..) => {\n-                    // Don't recurse, since references, pointers,\n-                    // and bare functions don't own instances\n-                    // of the types appearing within them.\n-                    walker.skip_current_subtree();\n-                }\n-                _ => {}\n-            };\n+        ty::TyBareFn(..) => {\n+            // FIXME(#26656): this type is always destruction-safe, but\n+            // it implicitly witnesses Self: Fn, which can be false.\n+            Ok(())\n+        }\n \n-            // You might be tempted to pop breadcrumbs here after\n-            // processing type's internals above, but then you hit\n-            // exponential time blowup e.g. on\n-            // compile-fail/huge-struct.rs. Instead, we do not remove\n-            // anything from the breadcrumbs vector during any particular\n-            // traversal, and instead clear it after the whole traversal\n-            // is done.\n+        ty::TyInfer(..) | ty::TyError => {\n+            rcx.tcx().sess.delay_span_bug(span, \"unresolved type in regionck\");\n+            Ok(())\n         }\n-    }\n \n-    return Ok(());\n+        // these are always dtorck\n+        ty::TyTrait(..) | ty::TyProjection(_) => unreachable!(),\n+    }\n }\n \n-enum DtorKind<'tcx> {\n+enum DtorKind {\n     // Type has an associated drop method with this def id\n     KnownDropMethod(ast::DefId),\n \n@@ -552,7 +544,7 @@ enum DtorKind<'tcx> {\n \n     // Type may have impure destructor that is unknown;\n     // e.g. `Box<Trait+'a>`\n-    Unknown(ty::ExistentialBounds<'tcx>),\n+    Unknown,\n }\n \n fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n@@ -567,7 +559,10 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n             debug!(\"typ: {:?} has no dtor, and thus is uninteresting\",\n                    typ);\n         }\n-        DtorKind::Unknown(bounds) => {\n+        DtorKind::Unknown => {\n+            debug!(\"trait: {:?} is interesting\", typ);\n+            has_dtor_of_interest = true;\n+/*\n             match bounds.region_bound {\n                 ty::ReStatic => {\n                     debug!(\"trait: {:?} has 'static bound, and thus is uninteresting\",\n@@ -580,11 +575,9 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     has_dtor_of_interest = false;\n                 }\n                 r => {\n-                    debug!(\"trait: {:?} has non-static bound: {:?}; assumed interesting\",\n-                           typ, r);\n-                    has_dtor_of_interest = true;\n                 }\n             }\n+*/\n         }\n         DtorKind::KnownDropMethod(dtor_method_did) => {\n             let impl_did = tcx.impl_of_method(dtor_method_did)"}, {"sha": "aeac38dab9047dbcc53b65f1b42911fb847ac96c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "patch": "@@ -174,7 +174,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // INTERNALS\n \n pub struct Rcx<'a, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n+    pub fcx: &'a FnCtxt<'a, 'tcx>,\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n "}, {"sha": "ee957f20d005bed5d88fb55c88173d636a44ac4c", "filename": "src/test/compile-fail/dropck_misc_variants.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Fcompile-fail%2Fdropck_misc_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Fcompile-fail%2Fdropck_misc_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_misc_variants.rs?ref=bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that dropck does the right thing with misc. Ty variants\n+\n+use std::fmt;\n+struct NoisyDrop<T: fmt::Debug>(T);\n+impl<T: fmt::Debug> Drop for NoisyDrop<T> {\n+    fn drop(&mut self) {\n+        let _ = vec![\"0wned\"];\n+        println!(\"dropping {:?}\", self.0)\n+    }\n+}\n+\n+trait Associator {\n+    type As;\n+}\n+impl<T: fmt::Debug> Associator for T {\n+    type As = NoisyDrop<T>;\n+}\n+struct Wrap<A: Associator>(<A as Associator>::As);\n+\n+fn projection() {\n+    let (_w, bomb);\n+    bomb = vec![\"\"];\n+    _w = Wrap::<&[&str]>(NoisyDrop(&bomb));\n+    //~^ ERROR `bomb` does not live long enough\n+}\n+\n+fn closure() {\n+    let (_w,v);\n+    v = vec![\"\"];\n+    _w = {\n+        let u = NoisyDrop(&v);\n+        //~^ ERROR `v` does not live long enough\n+        move || u.0.len()\n+    };\n+}\n+\n+fn main() { closure(); projection() }"}, {"sha": "0a8324eafe295b6b63454d97ed28e2ac5f050c9f", "filename": "src/test/run-pass/issue-24086.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Frun-pass%2Fissue-24086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Frun-pass%2Fissue-24086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24086.rs?ref=bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Registry<'a> {\n+    listener: &'a mut (),\n+}\n+\n+pub struct Listener<'a> {\n+    pub announce: Option<Box<FnMut(&mut Registry) + 'a>>,\n+    pub remove: Option<Box<FnMut(&mut Registry) + 'a>>,\n+}\n+\n+impl<'a> Drop for Registry<'a> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    let mut registry_listener = Listener {\n+        announce: None,\n+        remove: None,\n+    };\n+}"}, {"sha": "16f1d4626fbaf3af88fe04b6b041548a20893ab5", "filename": "src/test/run-pass/issue-26641.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Frun-pass%2Fissue-26641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Frun-pass%2Fissue-26641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-26641.rs?ref=bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Parser<'a>(Box<FnMut(Parser) + 'a>);\n+\n+fn main() {\n+    let _x = Parser(Box::new(|_|{}));\n+}"}, {"sha": "4e341d311729d5f34ff7d064047d98a9f84e868d", "filename": "src/test/run-pass/issue-27240.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Frun-pass%2Fissue-27240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544/src%2Ftest%2Frun-pass%2Fissue-27240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27240.rs?ref=bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+struct NoisyDrop<T: fmt::Debug>(T);\n+impl<T: fmt::Debug> Drop for NoisyDrop<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Bar<T: fmt::Debug>([*const NoisyDrop<T>; 2]);\n+\n+fn fine() {\n+    let (u,b);\n+    u = vec![43];\n+    b = Bar([&NoisyDrop(&u), &NoisyDrop(&u)]);\n+}\n+\n+struct Bar2<T: fmt::Debug>(*const NoisyDrop<T>, *const NoisyDrop<T>);\n+\n+fn lolwut() {\n+    let (u,v);\n+    u = vec![43];\n+    v = Bar2(&NoisyDrop(&u), &NoisyDrop(&u));\n+}\n+\n+fn main() { fine(); lolwut() }"}]}