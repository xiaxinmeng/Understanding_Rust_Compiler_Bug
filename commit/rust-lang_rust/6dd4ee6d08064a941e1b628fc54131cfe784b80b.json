{"sha": "6dd4ee6d08064a941e1b628fc54131cfe784b80b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZDRlZTZkMDgwNjRhOTQxZTFiNjI4ZmM1NDEzMWNmZTc4NGI4MGI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:41Z"}, "message": "Rollup merge of #37688 - eddyb:lazy-8, r=petrochenkov\n\n[8/n] rustc: clean up lookup_item_type and remove TypeScheme.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/37676) | [next]()) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\n* `tcx.tcache` -> `tcx.item_types`\n* `TypeScheme` (grouping `Ty` and `ty::Generics`) is removed\n* `tcx.item_types` entries no longer duplicated in `tcx.tables.node_types`\n* `tcx.lookup_item_type(def_id).ty` -> `tcx.item_type(def_id)`\n* `tcx.lookup_item_type(def_id).generics` -> `tcx.item_generics(def_id)`\n* `tcx.lookup_generics(def_id)` -> `tcx.item_generics(def_id)`\n* `tcx.lookup_{super_,}predicates(def_id)` -> `tcx.item_{super_,}predicates(def_id)`", "tree": {"sha": "d37d83e8662d32b0afe448aa84f4b423f489df55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37d83e8662d32b0afe448aa84f4b423f489df55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dd4ee6d08064a941e1b628fc54131cfe784b80b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd4ee6d08064a941e1b628fc54131cfe784b80b", "html_url": "https://github.com/rust-lang/rust/commit/6dd4ee6d08064a941e1b628fc54131cfe784b80b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dd4ee6d08064a941e1b628fc54131cfe784b80b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f80affac4471263e0b5c642b5c9b3cf57358683a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f80affac4471263e0b5c642b5c9b3cf57358683a", "html_url": "https://github.com/rust-lang/rust/commit/f80affac4471263e0b5c642b5c9b3cf57358683a"}, {"sha": "3f9eba1c7c31edd58b65d22bfad07c5e269e3af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f9eba1c7c31edd58b65d22bfad07c5e269e3af6", "html_url": "https://github.com/rust-lang/rust/commit/3f9eba1c7c31edd58b65d22bfad07c5e269e3af6"}], "stats": {"total": 892, "additions": 400, "deletions": 492}, "files": [{"sha": "50dfe9d22f12fa110f3a22d5056016e1960e3913", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -112,15 +112,15 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// switched to `Map(key)`. Therefore, if `op` makes use of any\n     /// HIR nodes or shared state accessed through its closure\n     /// environment, it must explicitly register a read of that\n-    /// state. As an example, see `type_scheme_of_item` in `collect`,\n+    /// state. As an example, see `type_of_item` in `collect`,\n     /// which looks something like this:\n     ///\n     /// ```\n-    /// fn type_scheme_of_item(..., item: &hir::Item) -> ty::TypeScheme<'tcx> {\n+    /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n     ///     let item_def_id = ccx.tcx.map.local_def_id(it.id);\n-    ///     ccx.tcx.tcache.memoized(item_def_id, || {\n+    ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n-    ///         compute_type_scheme_of_item(ccx, item)\n+    ///         compute_type_of_item(ccx, item)\n     ///     });\n     /// }\n     /// ```"}, {"sha": "d8a7ce72f50d2f2b5eb353f62ebc1424bc6ffe1c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -1443,7 +1443,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n-                            let generics = self.tcx.lookup_generics(did);\n+                            let generics = self.tcx.item_generics(did);\n \n                             let expected =\n                                 generics.regions.len() as u32;"}, {"sha": "94667b398b08068c7be5afaad0cd83a3e7440cef", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -433,7 +433,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.tables().node_id_to_type(field.id);\n+        let field_type = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false"}, {"sha": "0f9748a16f46ca5f95561da08e2639b469fc3140", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -51,7 +51,7 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n+        let intrinsic = match self.infcx.tcx.item_type(def_id).sty {\n             ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };"}, {"sha": "f472205b732d45a7b6609b4d68a24c5eb3c5ddca", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -112,7 +112,7 @@ use self::VarKind::*;\n use dep_graph::DepNode;\n use hir::def::*;\n use hir::pat_util;\n-use ty::{self, Ty, TyCtxt, ParameterEnvironment};\n+use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n use lint;\n@@ -1440,28 +1440,30 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n-        match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) =>\n-                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ => fn_ty.fn_ret()\n-        }\n-    }\n-\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,\n-                 _fk: FnKind,\n+                 fk: FnKind,\n                  entry_ln: LiveNode,\n                  body: &hir::Expr)\n     {\n+        let fn_ty = if let FnKind::Closure(_) = fk {\n+            self.ir.tcx.tables().node_id_to_type(id)\n+        } else {\n+            self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id))\n+        };\n+        let fn_ret = match fn_ty.sty {\n+            ty::TyClosure(closure_def_id, substs) =>\n+                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n+            _ => fn_ty.fn_ret()\n+        };\n+\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n-                &self.fn_ret(id));\n+                &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);"}, {"sha": "73ea84e94aec50c323428cc63e07da23daa08603", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> Lvalue<'tcx> {\n             Lvalue::Local(index) =>\n                 LvalueTy::Ty { ty: mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n+                LvalueTy::Ty { ty: tcx.item_type(def_id) },\n             Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }\n@@ -188,7 +188,7 @@ impl<'tcx> Rvalue<'tcx> {\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {\n-                        Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n+                        Some(tcx.item_type(def.did).subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {\n                         Some(tcx.mk_closure_from_closure_substs(did, substs))"}, {"sha": "b4592a03bcd1f3c3b730a761d5ed6f045a4535ad", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -154,9 +154,13 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n     pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                       -> Option<Vec<PredicateObligation<'tcx>>> {\n         if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n+            let ty = if def_id.is_local() {\n+                tcx.item_types.borrow().get(&def_id).cloned()\n+            } else {\n+                Some(tcx.item_type(def_id))\n+            };\n             // We can resolve the `impl Trait` to its concrete type.\n-            if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n-                let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n+            if let Some(concrete_ty) = ty.subst(tcx, substs) {\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n                     substs: tcx.mk_substs_trait(concrete_ty, &[])"}, {"sha": "eba24bfd2c9e2ddad1848bb97edd3dac5a0ed4b9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -603,7 +603,7 @@ pub fn get_vtable_methods<'a, 'tcx>(\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = tcx.lookup_predicates(def_id).instantiate_own(tcx, substs);\n+            let predicates = tcx.item_predicates(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;"}, {"sha": "0681be129b67e9cbd3983ad8202065c2365fa566", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let trait_def = self.lookup_trait_def(trait_def_id);\n         let trait_ref = trait_def.trait_ref.clone();\n         let trait_ref = trait_ref.to_poly_trait_ref();\n-        let predicates = self.lookup_super_predicates(trait_def_id);\n+        let predicates = self.item_super_predicates(trait_def_id);\n         predicates\n             .predicates\n             .into_iter()\n@@ -166,7 +166,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n         let free_substs = self.construct_free_substs(def_id,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = self.lookup_predicates(def_id);\n+        let predicates = self.item_predicates(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.lookup_item_type(method.def_id).ty.fn_sig();\n+        let ref sig = self.item_type(method.def_id).fn_sig();\n         for &input_ty in &sig.0.inputs[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !self.lookup_generics(method.def_id).types.is_empty() {\n+        if !self.item_generics(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "f1b69feb545efd8e0b6111d56a56f421e6f7e8bc", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in trans.\n                 if self.selcx.projection_mode() == Reveal::All {\n-                    let generic_ty = self.tcx().lookup_item_type(def_id).ty;\n+                    let generic_ty = self.tcx().item_type(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                     self.fold_ty(concrete_ty)\n                 } else {\n@@ -809,7 +809,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n+    let trait_predicates = selcx.tcx().item_predicates(def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n@@ -1313,7 +1313,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n             } else {\n-                tcx.lookup_item_type(node_item.item.def_id).ty\n+                tcx.item_type(node_item.item.def_id)\n             };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {"}, {"sha": "3944c7e09c0b89a303e73a622c531c7ee5e59b54", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -1200,7 +1200,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id={:?}, substs={:?}\",\n                def_id, substs);\n \n-        let item_predicates = self.tcx().lookup_predicates(def_id);\n+        let item_predicates = self.tcx().item_predicates(def_id);\n         let bounds = item_predicates.instantiate(self.tcx(), substs);\n         debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 bounds={:?}\",\n@@ -2884,7 +2884,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.lookup_predicates(def_id);\n+        let predicates = tcx.item_predicates(def_id);\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.predicates.iter().flat_map(|predicate| {\n             let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,"}, {"sha": "b94597d475927e61bc36adca97d867fea11da994", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -128,7 +128,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = tcx.lookup_super_predicates(data.def_id());\n+                let predicates = tcx.item_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n@@ -295,7 +295,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n             None => { return None; }\n         };\n \n-        let predicates = self.tcx.lookup_super_predicates(def_id);\n+        let predicates = self.tcx.item_super_predicates(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates.predicates\n@@ -362,7 +362,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n         super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n \n-    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n+    let predicates = selcx.tcx().item_predicates(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         super::normalize(selcx, ObligationCause::dummy(), &predicates);"}, {"sha": "ac1c4fc6a1911428e2f212348b3d49e4c7a86eea", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -444,7 +444,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub maybe_unused_trait_imports: NodeSet,\n \n     // Records the type of every item.\n-    pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n+    pub item_types: RefCell<DepTrackingMap<maps::Types<'tcx>>>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -665,10 +665,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n-        self.tables.borrow_mut().node_types.insert(id, ty);\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n                           -> &'gcx ty::Generics<'gcx> {\n         self.global_interners.arenas.generics.alloc(generics)\n@@ -815,7 +811,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n-            tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n             associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "8222583d9a7da8162e232ac5e269d05033fe3ce5", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let self_ty = self.lookup_item_type(impl_def_id).ty;\n+        let self_ty = self.item_type(impl_def_id);\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),"}, {"sha": "bf0445858794e3ec2f4fd0a09d3afc805d484af1", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -33,7 +33,7 @@ macro_rules! dep_map_ty {\n }\n \n dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n-dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n+dep_map_ty! { Types: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }"}, {"sha": "3db705140411aa2fd40439875f9f663c8ecb82f4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 72, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -169,9 +169,9 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n-            self_ty: tcx.lookup_item_type(impl_def_id).ty,\n+            self_ty: tcx.item_type(impl_def_id),\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.lookup_predicates(impl_def_id).predicates\n+            predicates: tcx.item_predicates(impl_def_id).predicates\n         }.subst(tcx, impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n@@ -708,7 +708,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n                         instantiated: &mut InstantiatedPredicates<'tcx>,\n                         substs: &Substs<'tcx>) {\n         if let Some(def_id) = self.parent {\n-            tcx.lookup_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n+            tcx.item_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n@@ -1301,31 +1301,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n-/// A \"type scheme\", in ML terminology, is a type combined with some\n-/// set of generic types that the type is, well, generic over. In Rust\n-/// terms, it is the \"type\" of a fn item or struct -- this type will\n-/// include various generic parameters that must be substituted when\n-/// the item/struct is referenced. That is called converting the type\n-/// scheme to a monotype.\n-///\n-/// - `generics`: the set of type parameters and their bounds\n-/// - `ty`: the base types, which may reference the parameters defined\n-///   in `generics`\n-///\n-/// Note that TypeSchemes are also sometimes called \"polytypes\" (and\n-/// in fact this struct used to carry that name, so you may find some\n-/// stray references in a comment or something). We try to reserve the\n-/// \"poly\" prefix to refer to higher-ranked things, as in\n-/// `PolyTraitRef`.\n-///\n-/// Note that each item also comes with predicates, see\n-/// `lookup_predicates`.\n-#[derive(Clone, Debug)]\n-pub struct TypeScheme<'tcx> {\n-    pub generics: &'tcx Generics<'tcx>,\n-    pub ty: Ty<'tcx>,\n-}\n-\n bitflags! {\n     flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n@@ -1359,8 +1334,6 @@ pub struct VariantDefData<'tcx, 'container: 'tcx> {\n }\n \n pub struct FieldDefData<'tcx, 'container: 'tcx> {\n-    /// The field's DefId. NOTE: the fields of tuple-like enum variants\n-    /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n     pub name: Name,\n     pub vis: Visibility,\n@@ -1541,14 +1514,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         &self.variants[0]\n     }\n \n-    #[inline]\n-    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeScheme<'gcx> {\n-        tcx.lookup_item_type(self.did)\n-    }\n-\n     #[inline]\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n-        tcx.lookup_predicates(self.did)\n+        tcx.item_predicates(self.did)\n     }\n \n     /// Returns an iterator over all fields contained\n@@ -1784,7 +1752,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n-                let predicates = tcx.lookup_predicates(self.did).predicates;\n+                let predicates = tcx.item_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n                     vec![]\n                 } else {\n@@ -1963,7 +1931,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.associated_items`, `tcx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.associated_items`, `tcx.types`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2351,38 +2319,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Register a given item type\n-    pub fn register_item_type(self, did: DefId, scheme: TypeScheme<'gcx>) {\n-        self.tcache.borrow_mut().insert(did, scheme.ty);\n-        self.generics.borrow_mut().insert(did, scheme.generics);\n-    }\n-\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n-        let ty = lookup_locally_or_in_crate_store(\n-            \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self.global_tcx(), did));\n-\n-        TypeScheme {\n-            ty: ty,\n-            generics: self.lookup_generics(did)\n-        }\n-    }\n-\n-    pub fn opt_lookup_item_type(self, did: DefId) -> Option<TypeScheme<'gcx>> {\n-        if did.krate != LOCAL_CRATE {\n-            return Some(self.lookup_item_type(did));\n-        }\n-\n-        if let Some(ty) = self.tcache.borrow().get(&did).cloned() {\n-            Some(TypeScheme {\n-                ty: ty,\n-                generics: self.lookup_generics(did)\n-            })\n-        } else {\n-            None\n-        }\n+    pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"item_types\", did, &self.item_types,\n+            || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n@@ -2411,21 +2353,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given the did of an item, returns its generics.\n-    pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n+    pub fn item_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"generics\", did, &self.generics,\n             || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n+    pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n             || self.sess.cstore.item_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n+    pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n             || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n@@ -2718,7 +2660,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let tcx = self.global_tcx();\n-        let generic_predicates = tcx.lookup_predicates(def_id);\n+        let generic_predicates = tcx.item_predicates(def_id);\n         let bounds = generic_predicates.instantiate(tcx, free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates;"}, {"sha": "7d209093ec77662700b54242be90340d5ba7cf86", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -164,7 +164,7 @@ pub enum TypeVariants<'tcx> {\n     /// Anonymized (`impl Trait`) type found in a return type.\n     /// The DefId comes from the `impl Trait` ast::Ty node, and the\n     /// substitutions are for the generics of the function in question.\n-    /// After typeck, the concrete type can be found in the `tcache` map.\n+    /// After typeck, the concrete type can be found in the `types` map.\n     TyAnon(DefId, &'tcx Substs<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n@@ -556,7 +556,7 @@ pub struct DebruijnIndex {\n ///\n /// These are regions that are stored behind a binder and must be substituted\n /// with some concrete region before being used. There are 2 kind of\n-/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// bound regions: early-bound, which are bound in an item's Generics,\n /// and are substituted by a Substs,  and late-bound, which are part of\n /// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists"}, {"sha": "15f4437ed0aaf431cea713a03c353504bec5d7f1", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n-        let defs = tcx.lookup_generics(def_id);\n+        let defs = tcx.item_generics(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n         Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n         tcx.intern_substs(&substs)\n@@ -192,7 +192,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n-            let parent_defs = tcx.lookup_generics(def_id);\n+            let parent_defs = tcx.item_generics(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n \n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        source_ancestor: DefId,\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n-        let defs = tcx.lookup_generics(source_ancestor);\n+        let defs = tcx.item_generics(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n }\n@@ -519,7 +519,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        trait_id: DefId,\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n-        let defs = tcx.lookup_generics(trait_id);\n+        let defs = tcx.item_generics(trait_id);\n \n         ty::TraitRef {\n             def_id: trait_id,"}, {"sha": "fd81065e61d499f3590272c152ac8f5ad7dbec44", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -18,7 +18,7 @@ use std::cell::{Cell, RefCell};\n use hir;\n use util::nodemap::FxHashMap;\n \n-/// As `TypeScheme` but for a trait ref.\n+/// A trait's definition with type information.\n pub struct TraitDef<'tcx> {\n     pub unsafety: hir::Unsafety,\n "}, {"sha": "74c6d7d334c357747c062e027a135683fc1b46d5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -446,7 +446,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                            -> Vec<traits::PredicateObligation<'tcx>>\n     {\n         let predicates =\n-            self.infcx.tcx.lookup_predicates(def_id)\n+            self.infcx.tcx.item_predicates(def_id)\n                           .instantiate(self.infcx.tcx, substs);\n         let cause = self.cause(traits::ItemObligation(def_id));\n         predicates.predicates"}, {"sha": "3ed4580336aac0ad0970ed4fa29369268b14d229", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -105,7 +105,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n                 }\n             }\n         }\n-        let mut generics = tcx.lookup_generics(item_def_id);\n+        let mut generics = tcx.item_generics(item_def_id);\n         let mut path_def_id = did;\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n@@ -115,7 +115,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             // Methods.\n             assert!(is_value_path);\n             child_types = generics.types.len();\n-            generics = tcx.lookup_generics(def_id);\n+            generics = tcx.item_generics(def_id);\n             num_regions = generics.regions.len();\n             num_types = generics.types.len();\n \n@@ -865,7 +865,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n-                          !tcx.tcache.borrow().contains_key(&def.did) {\n+                          !tcx.item_types.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n                         parameterized(f, substs, def.did, &[])\n@@ -878,7 +878,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 ty::tls::with(|tcx| {\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let item_predicates = tcx.lookup_predicates(def_id);\n+                    let item_predicates = tcx.item_predicates(def_id);\n                     let substs = tcx.lift(&substs).unwrap_or_else(|| {\n                         tcx.intern_substs(&[])\n                     });"}, {"sha": "eced5d1eb1b8060e060c7028a5ac4a06ae621d93", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -858,7 +858,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n+        let fty = tcx.item_type(free_func).subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {\n             statements: statements,"}, {"sha": "f6b6c89b7cc21152625811cc6486338537c74940", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -118,19 +118,20 @@ impl LateLintPass for BoxPointers {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+                let def_id = cx.tcx.map.local_def_id(it.id);\n+                self.check_heap_type(cx, it.span, cx.tcx.item_type(def_id))\n             }\n-            _ => (),\n+            _ => ()\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) |\n             hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    self.check_heap_type(cx,\n-                                         struct_field.span,\n-                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n+                    let def_id = cx.tcx.map.local_def_id(struct_field.id);\n+                    self.check_heap_type(cx, struct_field.span,\n+                                         cx.tcx.item_type(def_id));\n                 }\n             }\n             _ => (),\n@@ -585,11 +586,9 @@ impl LateLintPass for MissingDebugImplementations {\n             let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n-                        if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n-                            impls.insert(node_id);\n-                        }\n+                if let Some(ty_def) = cx.tcx.item_type(d).ty_to_def_id() {\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n+                        impls.insert(node_id);\n                     }\n                 }\n             });\n@@ -1225,7 +1224,7 @@ impl LateLintPass for MutableTransmutes {\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.lookup_item_type(def_id).ty.sty {\n+            match cx.tcx.item_type(def_id).sty {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false,\n             }\n@@ -1282,7 +1281,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.item_type(ctx.tcx.map.local_def_id(field.id));\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "4155d3e67a26deef03b823810001c13df12d81d4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -675,8 +675,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.map.local_def_id(id);\n-        let scheme = self.cx.tcx.lookup_item_type(def_id);\n-        let sig = scheme.ty.fn_sig();\n+        let sig = self.cx.tcx.item_type(def_id).fn_sig();\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (&input_ty, input_hir) in sig.inputs.iter().zip(&decl.inputs) {\n@@ -693,8 +692,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n         let def_id = self.cx.tcx.map.local_def_id(id);\n-        let scheme = self.cx.tcx.lookup_item_type(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, scheme.ty);\n+        let ty = self.cx.tcx.item_type(def_id);\n+        self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n }\n \n@@ -740,11 +739,12 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.tables().node_id_to_type(it.id);\n+                let t = cx.tcx.item_type(cx.tcx.map.local_def_id(it.id));\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx)\n-                        .unwrap_or_else(|e| bug!(\"failed to get layout for `{}`: {}\", t, e))\n+                    ty.layout(&infcx).unwrap_or_else(|e| {\n+                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n+                    })\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {"}, {"sha": "e2fa535bb44a0162d120def300be20e038f3c822", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -133,15 +133,18 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n         &InlinedItem::ImplItem(_, ref ii) => ii.id,\n     };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n-    tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n+    let ty = tcx.item_type(orig_did);\n+    let generics = tcx.item_generics(orig_did);\n+    tcx.item_types.borrow_mut().insert(inlined_did, ty);\n+    tcx.generics.borrow_mut().insert(inlined_did, generics);\n \n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::Def(def) => {\n                 tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n             TableEntry::NodeType(ty) => {\n-                tcx.node_type_insert(id, ty);\n+                tcx.tables.borrow_mut().node_types.insert(id, ty);\n             }\n             TableEntry::ItemSubsts(item_substs) => {\n                 tcx.tables.borrow_mut().item_substs.insert(id, item_substs);"}, {"sha": "ba85544326f8f547f7c3712e7ece07724ecde05a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::TraitDef::new(data.unsafety,\n                           data.paren_sugar,\n-                          tcx.lookup_generics(self.local_def_id(item_id)),\n+                          tcx.item_generics(self.local_def_id(item_id)),\n                           data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }"}, {"sha": "f169ad6648086febb38c37ce37aa9f0672be6606", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lookup_item_type(def_id).ty)\n+        self.lazy(&tcx.item_type(def_id))\n     }\n \n     /// Encode data for the given variant of the given ADT. The\n@@ -444,12 +444,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(tcx.lookup_generics(def_id))\n+        self.lazy(tcx.item_generics(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lookup_predicates(def_id))\n+        self.lazy(&tcx.item_predicates(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n             (true, true)\n         } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n-            let generics = self.tcx.lookup_generics(def_id);\n+            let generics = self.tcx.item_generics(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n             let is_const_fn = sig.constness == hir::Constness::Const;\n@@ -717,7 +717,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n                     trait_ref: self.lazy(&trait_def.trait_ref),\n-                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id)),\n+                    super_predicates: self.lazy(&tcx.item_super_predicates(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(&data))"}, {"sha": "f43181d8a610f8c069411a325c8552e47f1e9429", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -155,6 +155,7 @@ macro_rules! unpack {\n pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n+                                       abi: Abi,\n                                        return_ty: Ty<'gcx>,\n                                        ast_body: &'gcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n@@ -191,12 +192,9 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.tables().node_id_to_type(fn_id).sty {\n-        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n-            // RustCall pseudo-ABI untuples the last argument.\n-            spread_arg = Some(Local::new(arguments.len()));\n-        }\n-        _ => {}\n+    if abi == Abi::RustCall {\n+        // RustCall pseudo-ABI untuples the last argument.\n+        spread_arg = Some(Local::new(arguments.len()));\n     }\n \n     // Gather the upvars of a closure, if any."}, {"sha": "4af87381c7042bb84ce464a0492cc6fa81f58838", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -806,7 +806,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,\n-            ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n+            ty: tcx.item_type(free_func).subst(tcx, substs),\n             literal: Literal::Item {\n                 def_id: free_func,\n                 substs: substs"}, {"sha": "038300068fce1c6d402362f0da189d992e2083f1", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -149,8 +149,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n-                let method_ty = self.tcx.lookup_item_type(item.def_id);\n-                let method_ty = method_ty.ty.subst(self.tcx, substs);\n+                let method_ty = self.tcx.item_type(item.def_id);\n+                let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty, Literal::Item {\n                     def_id: item.def_id,\n                     substs: substs,"}, {"sha": "f22a2a7ac9c77445df5a631248394b5bbc008714", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -31,6 +31,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -221,10 +222,11 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             }\n         };\n \n-        let implicit_argument = if let FnKind::Closure(..) = fk {\n-            Some((closure_self_ty(self.tcx, id, body.id), None))\n+        let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n+            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body.id), None)))\n         } else {\n-            None\n+            let def_id = self.tcx.map.local_def_id(id);\n+            (self.tcx.item_type(def_id).fn_abi(), None)\n         };\n \n         let explicit_arguments =\n@@ -237,7 +239,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, fn_sig.output, body)\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output, body)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body, span, id);"}, {"sha": "ad525d210694776f2ed846b46615848dfd34c123", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         match *lvalue {\n             Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n+                LvalueTy::Ty { ty: self.tcx().item_type(def_id) },\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {"}, {"sha": "4fb11509a1c137da408d94309459bfb024466a39", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -286,7 +286,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n+            let def_id = self.tcx.map.local_def_id(field.id);\n+            let typ = self.tcx.item_type(def_id).to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {"}, {"sha": "0ad663f05b48b12c577810baff255a011bebeaf0", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n             match key.disambiguated_data.data {\n                 DefPathData::TypeNs(_) |\n                 DefPathData::ValueNs(_) => {\n-                    instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n+                    instance_ty = scx.tcx().item_type(ty_def_id);\n                     break;\n                 }\n                 _ => {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n \n         // Erase regions because they may not be deterministic when hashed\n         // and should not matter anyhow.\n-        let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n+        let instance_ty = scx.tcx().erase_regions(&instance_ty);\n \n         let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n "}, {"sha": "a990a7c507fd0ca2baa0bc22b852e349dd0d2afa", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -1045,7 +1045,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     debug!(\"trans_instance(instance={:?})\", instance);\n     let _icx = push_ctxt(\"trans_instance\");\n \n-    let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+    let fn_ty = ccx.tcx().item_type(instance.def);\n     let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n \n@@ -1068,7 +1068,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n     attributes::set_frame_pointer_elimination(ccx, llfndecl);\n \n-    let ctor_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ctor_ty = ccx.tcx().item_type(def_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n@@ -1514,7 +1514,7 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let generics = tcx.lookup_generics(def_id);\n+                let generics = tcx.item_generics(def_id);\n                 let attributes = tcx.get_attrs(def_id);\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n                 // Functions marked with #[inline] are only ever translated\n@@ -1719,7 +1719,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let applicable = match sess.cstore.describe_def(def_id) {\n                 Some(Def::Static(..)) => true,\n                 Some(Def::Fn(_)) => {\n-                    shared_ccx.tcx().lookup_generics(def_id).types.is_empty()\n+                    shared_ccx.tcx().item_generics(def_id).types.is_empty()\n                 }\n                 _ => false\n             };"}, {"sha": "f49d63b83764347acd52fc74b1237d33a12d3e0b", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -246,7 +246,7 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                     def_id: DefId,\n                     substs: &'tcx Substs<'tcx>)\n                     -> Ty<'tcx> {\n-    let ty = shared.tcx().lookup_item_type(def_id).ty;\n+    let ty = shared.tcx().item_type(def_id);\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n \n@@ -400,7 +400,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);\n-    let item_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let item_ty = ccx.tcx().item_type(def_id);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &item_ty);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {"}, {"sha": "41071057274f12fb51f09c3de0dbc26629fa7f36", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -337,7 +337,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n-            let ty = scx.tcx().lookup_item_type(def_id).ty;\n+            let ty = scx.tcx().item_type(def_id);\n             let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n@@ -618,7 +618,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n-            match tcx.lookup_item_type(def_id).ty.sty {\n+            match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n@@ -1077,13 +1077,12 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = self.scx.tcx().tables().node_types[&item.id];\n-\n                     if self.mode == TransItemCollectionMode::Eager {\n+                        let def_id = self.scx.tcx().map.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.scx.tcx(),\n-                                                self.scx.tcx().map.local_def_id(item.id)));\n+                               def_id_to_string(self.scx.tcx(), def_id));\n \n+                        let ty = self.scx.tcx().item_type(def_id);\n                         let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n@@ -1182,7 +1181,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if !tcx.lookup_generics(method.def_id).types.is_empty() {\n+                    if !tcx.item_generics(method.def_id).types.is_empty() {\n                         continue;\n                     }\n \n@@ -1201,7 +1200,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                                                                callee_substs,\n                                                                &impl_data);\n \n-                    let predicates = tcx.lookup_predicates(def_id).predicates\n+                    let predicates = tcx.item_predicates(def_id).predicates\n                                         .subst(tcx, substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;"}, {"sha": "670a84565fafbc31f442a58a28ef17ef5b8c3bcb", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -84,7 +84,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ty = ccx.tcx().item_type(def_id);\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -226,7 +226,7 @@ pub fn trans_static(ccx: &CrateContext,\n             v\n         };\n \n-        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "679e308c34542c151b2bfff741f9b43ba6538684", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -1765,7 +1765,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.item_type(node_def_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "45b8ec1dc80bb8cdc2ac30d89b1426573a04d15b", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -259,7 +259,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().lookup_generics(fn_def_id);\n+    let generics = cx.tcx().item_generics(fn_def_id);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n                                                       instance.substs,\n@@ -397,7 +397,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                           generics: &ty::Generics<'tcx>)\n                                           -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx().lookup_generics(def_id))\n+            get_type_parameter_names(cx, cx.tcx().item_generics(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names\n@@ -412,7 +412,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let self_type = cx.tcx().impl_of_method(instance.def).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx().lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = cx.tcx().item_type(impl_def_id);\n                 let impl_self_ty = cx.tcx().erase_regions(&impl_self_ty);\n                 let impl_self_ty = monomorphize::apply_param_substs(cx.shared(),\n                                                                     instance.substs,"}, {"sha": "09a1cbd319ac454455f037f6d99c95ecac6b31ed", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -495,7 +495,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = tcx.lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = tcx.item_type(impl_def_id);\n                 let impl_self_ty = tcx.erase_regions(&impl_self_ty);\n                 let impl_self_ty = monomorphize::apply_param_substs(scx,\n                                                                     instance.substs,"}, {"sha": "93790cc27bcafad14d8d0b36191fc222aac9a235", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().map.local_def_id(node_id);\n-        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+        let item_ty = ccx.tcx().item_type(instance.def);\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n         let mono_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &item_ty);\n "}, {"sha": "9bde6b0c4d9953b85263998507ca9e3709217266", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -16,12 +16,12 @@\n //! somewhat differently during the collect and check phases,\n //! particularly with respect to looking up the types of top-level\n //! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_type_scheme()`\n-//! function triggers a recursive call to `type_scheme_of_item()`\n+//! `AstConv` instance; in this phase, the `get_item_type()`\n+//! function triggers a recursive call to `type_of_item()`\n //! (note that `ast_ty_to_ty()` will detect recursive types and report\n //! an error).  In the check phase, when the FnCtxt is used as the\n-//! `AstConv`, `get_item_type_scheme()` just looks up the item type in\n-//! `tcx.tcache` (using `ty::lookup_item_type`).\n+//! `AstConv`, `get_item_type()` just looks up the item type in\n+//! `tcx.types` (using `TyCtxt::item_type`).\n //!\n //! The `RegionScope` trait controls what happens when the user does\n //! not specify a region in some location where a region is required\n@@ -85,11 +85,8 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_generics(&self, span: Span, id: DefId)\n                     -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>;\n \n-    /// Identify the type scheme for an item with a type, like a type\n-    /// alias, fn, or struct. This allows you to figure out the set of\n-    /// type parameters defined on the item.\n-    fn get_item_type_scheme(&self, span: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n+    /// Identify the type for an item, like a type alias, fn, or struct.\n+    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>;\n \n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n@@ -938,8 +935,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let decl_ty = match self.get_item_type_scheme(span, did) {\n-            Ok(type_scheme) => type_scheme.ty,\n+        let decl_ty = match self.get_item_type(span, did) {\n+            Ok(ty) => ty,\n             Err(ErrorReported) => {\n                 return tcx.types.err;\n             }\n@@ -1521,8 +1518,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 tcx.prohibit_type_params(base_segments);\n-                let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let ty = tcx.tables().node_id_to_type(impl_id);\n+                let ty = tcx.item_type(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "54a0ef071ce4b778323f2c7c949139771308eac1", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -174,10 +174,10 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n-    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n-    let impl_m_predicates = tcx.lookup_predicates(impl_m.def_id);\n-    let trait_m_predicates = tcx.lookup_predicates(trait_m.def_id);\n+    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n+    let impl_m_predicates = tcx.item_predicates(impl_m.def_id);\n+    let trait_m_predicates = tcx.item_predicates(trait_m.def_id);\n \n     // Check region bounds.\n     check_region_bounds_on_impl_method(ccx,\n@@ -193,7 +193,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n-    let impl_predicates = tcx.lookup_predicates(impl_m_predicates.parent.unwrap());\n+    let impl_predicates = tcx.item_predicates(impl_m_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n@@ -269,7 +269,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n         let m_fty = |method: &ty::AssociatedItem| {\n-            match tcx.lookup_item_type(method.def_id).ty.sty {\n+            match tcx.item_type(method.def_id).sty {\n                 ty::TyFnDef(_, _, f) => f,\n                 _ => bug!()\n             }\n@@ -542,7 +542,7 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.lookup_item_type(method.def_id).ty;\n+        let method_ty = tcx.item_type(method.def_id);\n         let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n@@ -601,8 +601,8 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n-    let impl_m_generics = tcx.lookup_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.lookup_generics(trait_m.def_id);\n+    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n+    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.types.len();\n     let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n@@ -672,7 +672,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 -> Result<(), ErrorReported> {\n     let tcx = ccx.tcx;\n     let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.lookup_item_type(method.def_id).ty.sty {\n+        match tcx.item_type(method.def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         }\n@@ -785,8 +785,8 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = tcx.lookup_item_type(impl_c.def_id).ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = tcx.lookup_item_type(trait_c.def_id).ty.subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.item_type(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n+        let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n         let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {"}, {"sha": "8657b30bf8ee1eceedfee8b50ce4bd2872ca5f05", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -41,8 +41,8 @@ use syntax_pos::{self, Span};\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let dtor_self_type = ccx.tcx.lookup_item_type(drop_impl_did).ty;\n-    let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n+    let dtor_self_type = ccx.tcx.item_type(drop_impl_did);\n+    let dtor_predicates = ccx.tcx.item_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyAdt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n@@ -85,7 +85,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-        let named_type = tcx.lookup_item_type(self_type_did).ty;\n+        let named_type = tcx.item_type(self_type_did);\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n         let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n@@ -177,7 +177,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n-    let generic_assumptions = tcx.lookup_predicates(self_type_did);\n+    let generic_assumptions = tcx.item_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n@@ -570,30 +570,30 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n // Constructs new Ty just like the type defined by `adt_def` coupled\n // with `substs`, except each type and lifetime parameter marked as\n-// `#[may_dangle]` in the Drop impl (identified by `impl_id`) is\n+// `#[may_dangle]` in the Drop impl (identified by `impl_def_id`) is\n // respectively mapped to `()` or `'static`.\n //\n // For example: If the `adt_def` maps to:\n //\n //   enum Foo<'a, X, Y> { ... }\n //\n-// and the `impl_id` maps to:\n+// and the `impl_def_id` maps to:\n //\n //   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n //\n // then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   adt_def: ty::AdtDef<'tcx>,\n-                                  impl_id: DefId,\n+                                  impl_def_id: DefId,\n                                   substs: &Substs<'tcx>)\n                                   -> Ty<'tcx> {\n     // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n-    let impl_bindings = tcx.lookup_generics(impl_id);\n+    let impl_bindings = tcx.item_generics(impl_def_id);\n \n     // Get Substs attached to Self on `impl Drop`; process in parallel\n     // with `substs`, replacing dangling entries as appropriate.\n     let self_substs = {\n-        let impl_self_ty: Ty<'tcx> = tcx.lookup_item_type(impl_id).ty;\n+        let impl_self_ty: Ty<'tcx> = tcx.item_type(impl_def_id);\n         if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n             assert_eq!(adt_def, self_adt_def);\n             self_substs\n@@ -648,5 +648,5 @@ fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             t\n         });\n \n-    return tcx.mk_adt(adt_def, &substs);\n+    tcx.mk_adt(adt_def, &substs)\n }"}, {"sha": "ac6343cae1c8ef7d2bc5ddc03a9e87175e172359", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -34,7 +34,6 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    output: Ty<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(it.id);\n-    let i_ty = tcx.lookup_item_type(def_id);\n \n     let substs = Substs::for_item(tcx, def_id,\n                                   |_, _| tcx.mk_region(ty::ReErased),\n@@ -49,7 +48,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             variadic: false,\n         }),\n     }));\n-    let i_n_tps = i_ty.generics.types.len();\n+    let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, ref generics) => generics.span,\n@@ -65,7 +64,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     } else {\n         require_same_types(ccx,\n                            TypeOrigin::IntrinsicType(it.span),\n-                           i_ty.ty,\n+                           tcx.item_type(def_id),\n                            fty);\n     }\n }\n@@ -330,8 +329,8 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n-    let i_n_tps = i_ty.generics.types.len();\n+    let def_id = tcx.map.local_def_id(it.id);\n+    let i_n_tps = tcx.item_generics(def_id).types.len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n@@ -374,7 +373,8 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+                    let sig = tcx.item_type(def_id).fn_sig();\n+                    let sig = tcx.no_late_bound_regions(sig).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "0b6f7794e9fe14bbc8df949544180e0bdd28537e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let method_generics = self.tcx.lookup_generics(pick.item.def_id);\n+        let method_generics = self.tcx.item_generics(pick.item.def_id);\n         let num_method_types = method_generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n@@ -359,14 +359,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let def_id = pick.item.def_id;\n-        let method_predicates = self.tcx.lookup_predicates(def_id)\n+        let method_predicates = self.tcx.item_predicates(def_id)\n                                     .instantiate(self.tcx, all_substs);\n         let method_predicates = self.normalize_associated_types_in(self.span,\n                                                                    &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let fty = match self.tcx.lookup_item_type(def_id).ty.sty {\n+        let fty = match self.tcx.item_type(def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         };"}, {"sha": "66a532fd76acff445794decf6c7f29441e58e102", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n         let def_id = method_item.def_id;\n-        let generics = tcx.lookup_generics(def_id);\n+        let generics = tcx.item_generics(def_id);\n         assert_eq!(generics.types.len(), 0);\n         assert_eq!(generics.regions.len(), 0);\n \n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let original_method_ty = tcx.lookup_item_type(def_id).ty;\n+        let original_method_ty = tcx.item_type(def_id);\n         let fty = match original_method_ty.sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()"}, {"sha": "481923c25978701900f437ff33338692293679b9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -672,9 +672,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let impl_type = self.tcx.lookup_item_type(impl_def_id);\n+        let impl_type = self.tcx.item_type(impl_def_id);\n         let impl_simplified_type =\n-            match ty::fast_reject::simplify_type(self.tcx, impl_type.ty, false) {\n+            match ty::fast_reject::simplify_type(self.tcx, impl_type, false) {\n                 Some(simplified_type) => simplified_type,\n                 None => {\n                     return true;\n@@ -771,7 +771,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                    def_id,\n                    substs);\n \n-            let trait_predicates = self.tcx.lookup_predicates(def_id);\n+            let trait_predicates = self.tcx.item_predicates(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n@@ -1070,7 +1070,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx.lookup_predicates(impl_def_id);\n+            let impl_bounds = self.tcx.item_predicates(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n                 traits::normalize(selcx, cause.clone(), &impl_bounds);\n@@ -1171,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.lookup_item_type(method).ty.fn_sig().input(0);\n+        let self_ty = self.tcx.item_type(method).fn_sig().input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,\n@@ -1184,7 +1184,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        let generics = self.tcx.lookup_generics(method);\n+        let generics = self.tcx.item_generics(method);\n         assert_eq!(substs.types().count(), generics.parent_types as usize);\n         assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n \n@@ -1218,7 +1218,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n-        let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+        let impl_ty = self.tcx.item_type(impl_def_id);\n \n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,"}, {"sha": "a95b3f4a973bb316d59e6a5b13a58a080634a92c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -598,7 +598,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &'tcx hir::Expr,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n+    let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n@@ -781,15 +781,16 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, id);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    check_representable(ccx.tcx, span, def_id);\n \n-    if ccx.tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n-        check_simd(ccx.tcx, span, id);\n+    if ccx.tcx.lookup_simd(def_id) {\n+        check_simd(ccx.tcx, span, def_id);\n     }\n }\n \n fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, id);\n+    check_representable(ccx.tcx, span, ccx.tcx.map.local_def_id(id));\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n@@ -832,7 +833,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let pty_ty = ccx.tcx.tables().node_id_to_type(it.id);\n+        let def_id = ccx.tcx.map.local_def_id(it.id);\n+        let pty_ty = ccx.tcx.item_type(def_id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -848,8 +850,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(item.id));\n-                if !pty.generics.types.is_empty() {\n+                let generics = ccx.tcx.item_generics(ccx.tcx.map.local_def_id(item.id));\n+                if !generics.types.is_empty() {\n                     let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     span_help!(&mut err, item.span,\n@@ -918,7 +920,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = ccx.tcx.lookup_generics(def_id);\n+    let generics = ccx.tcx.item_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -1144,12 +1146,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let signature = |item: &ty::AssociatedItem| {\n         match item.kind {\n             ty::AssociatedKind::Method => {\n-                format!(\"{}\", tcx.lookup_item_type(item.def_id).ty.fn_sig().0)\n+                format!(\"{}\", tcx.item_type(item.def_id).fn_sig().0)\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", item.name.to_string()),\n             ty::AssociatedKind::Const => {\n-                format!(\"const {}: {:?};\", item.name.to_string(),\n-                        tcx.lookup_item_type(item.def_id).ty)\n+                format!(\"const {}: {:?};\", item.name.to_string(), tcx.item_type(item.def_id))\n             }\n         }\n     };\n@@ -1219,7 +1220,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                          expr: &'tcx hir::Expr,\n                          id: ast::NodeId) {\n-    let decl_ty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+    let decl_ty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(id));\n     check_const_with_type(ccx, expr, decl_ty, id);\n }\n \n@@ -1228,9 +1229,9 @@ fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// pointer, which would mean their size is unbounded.\n fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n-                                 item_id: ast::NodeId)\n+                                 item_def_id: DefId)\n                                  -> bool {\n-    let rty = tcx.tables().node_id_to_type(item_id);\n+    let rty = tcx.item_type(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1239,7 +1240,6 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n-            let item_def_id = tcx.map.local_def_id(item_id);\n             tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n             return false\n         }\n@@ -1248,8 +1248,8 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return true\n }\n \n-pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n-    let t = tcx.tables().node_id_to_type(id);\n+pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    let t = tcx.item_type(def_id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n@@ -1329,7 +1329,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         disr_vals.push(current_disr_val);\n     }\n \n-    check_representable(ccx.tcx, sp, id);\n+    check_representable(ccx.tcx, sp, def_id);\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n@@ -1342,13 +1342,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn get_generics(&self, _: Span, id: DefId)\n                     -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n     {\n-        Ok(self.tcx().lookup_generics(id))\n+        Ok(self.tcx().item_generics(id))\n     }\n \n-    fn get_item_type_scheme(&self, _: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    fn get_item_type(&self, _: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>\n     {\n-        Ok(self.tcx().lookup_item_type(id))\n+        Ok(self.tcx().item_type(id))\n     }\n \n     fn get_trait_def(&self, _: Span, id: DefId)\n@@ -1663,7 +1662,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// generic type scheme.\n     fn instantiate_bounds(&self, span: Span, def_id: DefId, substs: &Substs<'tcx>)\n                           -> ty::InstantiatedPredicates<'tcx> {\n-        let bounds = self.tcx.lookup_predicates(def_id);\n+        let bounds = self.tcx.item_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &result.predicates);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n@@ -1688,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty_var = self.next_ty_var();\n                 self.anon_types.borrow_mut().insert(def_id, ty_var);\n \n-                let item_predicates = self.tcx.lookup_predicates(def_id);\n+                let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n                 let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n@@ -2743,11 +2742,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span, // (potential) receiver for this impl\n                         did: DefId)\n                         -> TypeAndSubsts<'tcx> {\n-        let ity = self.tcx.lookup_item_type(did);\n+        let ity = self.tcx.item_type(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n         let substs = self.fresh_substs_for_item(span, did);\n-        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity.ty);\n+        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n@@ -4185,11 +4184,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                let mut generics = self.tcx.lookup_generics(def_id);\n+                let mut generics = self.tcx.item_generics(def_id);\n                 if let Some(def_id) = generics.parent {\n                     // Variant and struct constructors use the\n                     // generics of their parent type definition.\n-                    generics = self.tcx.lookup_generics(def_id);\n+                    generics = self.tcx.item_generics(def_id);\n                 }\n                 type_segment = Some((segments.last().unwrap(), generics));\n             }\n@@ -4199,7 +4198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n                 fn_segment = Some((segments.last().unwrap(),\n-                                   self.tcx.lookup_generics(def_id)));\n+                                   self.tcx.item_generics(def_id)));\n             }\n \n             // Case 3. Reference to a method or associated const.\n@@ -4213,9 +4212,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::ImplContainer(_) => {}\n                 }\n \n-                let generics = self.tcx.lookup_generics(def_id);\n+                let generics = self.tcx.item_generics(def_id);\n                 if segments.len() >= 2 {\n-                    let parent_generics = self.tcx.lookup_generics(generics.parent.unwrap());\n+                    let parent_generics = self.tcx.item_generics(generics.parent.unwrap());\n                     type_segment = Some((&segments[segments.len() - 2], parent_generics));\n                 } else {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n@@ -4345,9 +4344,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let scheme = self.tcx.lookup_item_type(def.def_id());\n+        let ty = self.tcx.item_type(def.def_id());\n         assert!(!substs.has_escaping_regions());\n-        assert!(!scheme.ty.has_escaping_regions());\n+        assert!(!ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n@@ -4358,16 +4357,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, &ty);\n \n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter, instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n-            let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n+            let ty = self.tcx.item_type(impl_def_id);\n \n-            let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n+            let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n             match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations"}, {"sha": "e019c4c761483d05adeed06f1b5a8d8a405420de", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -1729,7 +1729,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // ```\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n+        let trait_predicates = self.tcx.item_predicates(projection_ty.trait_ref.def_id);\n         assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)"}, {"sha": "066b3d4be0881ce58e5f2f8d9ada1542ca8900ba", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -179,18 +179,18 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx.lookup_item_type(def_id).ty)\n+                                              fcx.tcx.item_type(def_id))\n             };\n \n             match item.kind {\n                 ty::AssociatedKind::Const => {\n-                    let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let ty = fcx.tcx.item_type(item.def_id);\n                     let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n-                    let method_ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                    let method_ty = fcx.tcx.item_type(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n                     let fty = match method_ty.sty {\n@@ -205,7 +205,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n                 ty::AssociatedKind::Type => {\n                     if item.has_value {\n-                        let ty = fcx.tcx.lookup_item_type(item.def_id).ty;\n+                        let ty = fcx.tcx.item_type(item.def_id);\n                         let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n@@ -276,7 +276,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         //\n         // 3) that the trait definition does not have any type parameters\n \n-        let predicates = self.tcx().lookup_predicates(trait_def_id);\n+        let predicates = self.tcx().item_predicates(trait_def_id);\n \n         // We must exclude the Self : Trait predicate contained by all\n         // traits.\n@@ -353,8 +353,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.map.local_def_id(item.id);\n-            let type_scheme = fcx.tcx.lookup_item_type(def_id);\n-            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n+            let ty = fcx.tcx.item_type(def_id);\n+            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(.., ref bare_fn_ty) => bare_fn_ty,\n                 _ => {\n@@ -378,11 +378,11 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n+            let ty = fcx.tcx.item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.parameter_environment\n                                                           .free_substs,\n-                                                      &type_scheme.ty);\n+                                                      &ty);\n \n             fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n \n@@ -417,7 +417,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.tables().node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.item_type(item_def_id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -426,7 +426,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            fcx.impl_implied_bounds(fcx.tcx.map.local_def_id(item.id), item.span)\n+            fcx.impl_implied_bounds(item_def_id, item.span)\n         });\n     }\n \n@@ -492,7 +492,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let span = method_sig.decl.inputs[0].pat.span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let method_ty = fcx.tcx.lookup_item_type(method.def_id).ty;\n+        let method_ty = fcx.tcx.item_type(method.def_id);\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n         let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n \n@@ -523,13 +523,13 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let ty = self.tcx().tables().node_id_to_type(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n+        let ty = self.tcx().item_type(item_def_id);\n         if self.tcx().has_error_field(ty) {\n             return;\n         }\n \n-        let item_def_id = self.tcx().map.local_def_id(item.id);\n-        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let ty_predicates = self.tcx().item_predicates(item_def_id);\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -583,8 +583,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n-    let generics = tcx.lookup_generics(def_id);\n-    let parent = tcx.lookup_generics(generics.parent.unwrap());\n+    let generics = tcx.item_generics(def_id);\n+    let parent = tcx.item_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n                                        .iter()\n                                        .map(|tp| (tp.name, tp.def_id))\n@@ -654,7 +654,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.tables().node_id_to_type(field.id);\n+                let field_ty = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,\n@@ -683,7 +683,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             None => {\n                 // Inherent impl: take implied bounds from the self type.\n-                let self_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+                let self_ty = self.tcx.item_type(impl_def_id);\n                 let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n                 vec![self_ty]\n             }"}, {"sha": "979ce82ff4ecd27524f9a3ed8a3801aabe994bf7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -20,8 +20,6 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::DefIdMap;\n-use write_substs_to_tcx;\n-use write_ty_to_tcx;\n \n use std::cell::Cell;\n \n@@ -67,7 +65,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types(item_id);\n+        wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n     }\n }\n@@ -133,6 +131,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n+    fn write_ty_to_tcx(&self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n+        assert!(!ty.needs_infer());\n+        self.tcx().tables.borrow_mut().node_types.insert(node_id, ty);\n+    }\n+\n     // Hacky hack: During type-checking, we treat *all* operators\n     // as potentially overloaded. But then, during writeback, if\n     // we observe that something like `a+b` is (known to be)\n@@ -241,15 +245,15 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        write_ty_to_tcx(self.fcx.ccx, l.id, var_ty);\n+        self.write_ty_to_tcx(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n         match t.node {\n             hir::TyArray(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);\n-                write_ty_to_tcx(self.fcx.ccx, count_expr.id, self.tcx().types.usize);\n+                self.write_ty_to_tcx(count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -302,13 +306,11 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&self, item_id: ast::NodeId) {\n+    fn visit_anon_types(&self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n-        let item_def_id = self.fcx.tcx.map.local_def_id(item_id);\n-\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n             let reason = ResolvingAnonTy(def_id);\n@@ -349,10 +351,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.register_item_type(def_id, ty::TypeScheme {\n-                ty: outside_ty,\n-                generics: gcx.lookup_generics(item_def_id)\n-            });\n+            gcx.item_types.borrow_mut().insert(def_id, outside_ty);\n         }\n     }\n \n@@ -363,13 +362,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        write_ty_to_tcx(self.fcx.ccx, id, n_ty);\n+        self.write_ty_to_tcx(id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n-            write_substs_to_tcx(self.fcx.ccx, id,\n-                                self.resolve(item_substs, reason));\n+            let item_substs = self.resolve(item_substs, reason);\n+            if !item_substs.is_noop() {\n+                debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n+                assert!(!item_substs.substs.needs_infer());\n+                self.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+            }\n         });\n     }\n "}, {"sha": "58633058264621549aa8ef41285b82f23a399184", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = tcx.map.local_def_id(item.id);\n-        let self_type = tcx.lookup_item_type(impl_did);\n+        let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -129,14 +129,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         } else {\n             // Skip inherent impls where the self type is an error\n             // type. This occurs with e.g. resolve failures (#30589).\n-            if self_type.ty.references_error() {\n+            if self_type.references_error() {\n                 return;\n             }\n \n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type.ty) {\n+            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type) {\n                 self.add_inherent_impl(base_def_id, impl_did);\n             }\n         }\n@@ -175,8 +175,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = tcx.lookup_item_type(impl_did);\n-            match self_type.ty.sty {\n+            let self_type = tcx.item_type(impl_did);\n+            match self_type.sty {\n                 ty::TyAdt(type_def, _) => {\n                     type_def.set_destructor(method_def_id);\n                 }\n@@ -232,13 +232,13 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             };\n \n-            let self_type = tcx.lookup_item_type(impl_did);\n+            let self_type = tcx.item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n             let span = tcx.map.span(impl_node_id);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n+            let self_type = self_type.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n             debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n@@ -326,7 +326,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             };\n \n-            let source = tcx.lookup_item_type(impl_did).ty;\n+            let source = tcx.item_type(impl_did);\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\","}, {"sha": "371c182030e244c684514996d1b0f4207b0b741f", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -81,7 +81,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n-                let self_ty = self.tcx.lookup_item_type(def_id).ty;\n+                let self_ty = self.tcx.item_type(def_id);\n                 match self_ty.sty {\n                     ty::TyAdt(def, _) => {\n                         self.check_def_id(item, def.did);"}, {"sha": "968d5d73e7a8b892f07b10d93d224f2f3da189d9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 84, "deletions": 93, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -13,7 +13,7 @@\n # Collect phase\n \n The collect phase of type check has the job of visiting all items,\n-determining their type, and writing that type into the `tcx.tcache`\n+determining their type, and writing that type into the `tcx.types`\n table.  Despite its name, this table does not really operate as a\n *cache*, at least not for the types of items defined within the\n current crate: we assume that after the collect phase, the types of\n@@ -22,8 +22,7 @@ all local items will be present in the table.\n Unlike most of the types that are present in Rust, the types computed\n for each item are in fact type schemes. This means that they are\n generic types that may have type parameters. TypeSchemes are\n-represented by an instance of `ty::TypeScheme`.  This combines the\n-core type along with a list of the bounds for each parameter. Type\n+represented by a pair of `Generics` and `Ty`.  Type\n parameters themselves are represented as `ty_param()` instances.\n \n The phasing of type conversion is somewhat complicated. There is no\n@@ -51,8 +50,8 @@ There are some shortcomings in this design:\n \n - Before walking the set of supertraits for a given trait, you must\n   call `ensure_super_predicates` on that trait def-id. Otherwise,\n-  `lookup_super_predicates` will result in ICEs.\n-- Because the type scheme includes defaults, cycles through type\n+  `item_super_predicates` will result in ICEs.\n+- Because the item generics include defaults, cycles through type\n   parameter defaults are illegal even if those defaults are never\n   employed. This is not necessarily a bug.\n \n@@ -67,13 +66,13 @@ use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n-use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n+use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n-use {CrateCtxt, write_ty_to_tcx};\n+use CrateCtxt;\n \n use rustc_const_math::ConstInt;\n \n@@ -132,6 +131,15 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         convert_item(self.ccx, item);\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyImplTrait(..) = ty.node {\n+            let def_id = self.ccx.tcx.map.local_def_id(ty.id);\n+            generics_of_def_id(self.ccx, def_id);\n+        }\n+        intravisit::walk_ty(self, ty);\n     }\n }\n \n@@ -308,11 +316,9 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn get_item_type_scheme(&self, span: Span, id: DefId)\n-                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n-    {\n+    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported> {\n         self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n-            Ok(type_scheme_of_def_id(self.ccx, id))\n+            Ok(type_of_def_id(self.ccx, id))\n         })\n     }\n \n@@ -447,7 +453,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n         let mut results = self.parent.map_or(vec![], |def_id| {\n-            let parent = astconv.tcx().lookup_predicates(def_id);\n+            let parent = astconv.tcx().item_predicates(def_id);\n             parent.get_type_parameter_bounds(astconv, span, node_id)\n         });\n \n@@ -546,16 +552,11 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n     ty_f.fulfill_ty(tt);\n-    write_ty_to_tcx(ccx, field.id, tt);\n-\n-    /* add the field to the tcache */\n-    ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(field.id),\n-                               ty::TypeScheme {\n-                                   generics: struct_generics,\n-                                   ty: tt\n-                               });\n-    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(field.id),\n-                                           struct_predicates.clone());\n+\n+    let def_id = ccx.tcx.map.local_def_id(field.id);\n+    ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n+    ccx.tcx.generics.borrow_mut().insert(def_id, struct_generics);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n \n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -580,8 +581,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.map.span(id), def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n-    write_ty_to_tcx(ccx, id, fty);\n+    ccx.tcx.item_types.borrow_mut().insert(def_id, fty);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, ty_generic_predicates);\n }\n \n@@ -596,9 +596,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n     let def_id = ccx.tcx.map.local_def_id(id);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n-    ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n-\n-    write_ty_to_tcx(ccx, id, ty);\n+    ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -614,8 +612,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n \n     if let Some(ty) = ty {\n-        ccx.tcx.tcache.borrow_mut().insert(def_id, ty);\n-        write_ty_to_tcx(ccx, id, ty);\n+        ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n     }\n }\n \n@@ -662,11 +659,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let ty = type_of_def_id(ccx, def_id);\n+            let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n                                        tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n-                                       scheme,\n+                                       ty,\n+                                       generics,\n                                        predicates,\n                                        &enum_definition.variants);\n         },\n@@ -690,18 +689,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let ty_generics = generics_of_def_id(ccx, def_id);\n+            generics_of_def_id(ccx, def_id);\n             let mut ty_predicates =\n                 ty_generic_predicates(ccx, generics, None, vec![], false);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n-            write_ty_to_tcx(ccx, it.id, selfty);\n+            tcx.item_types.borrow_mut().insert(def_id, selfty);\n \n-            tcx.register_item_type(def_id,\n-                                   TypeScheme { generics: ty_generics,\n-                                                ty: selfty });\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                     &ExplicitRscope,\n@@ -742,14 +738,10 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n                     let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n-                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n+                    generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &ty);\n-                    tcx.register_item_type(const_def_id,\n-                                           TypeScheme {\n-                                               generics: ty_generics,\n-                                               ty: ty,\n-                                           });\n+                    tcx.item_types.borrow_mut().insert(const_def_id, ty);\n                     convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.id, ty);\n                 }\n@@ -788,7 +780,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, def_id);\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.lookup_predicates(def_id);\n+            let trait_predicates = tcx.item_predicates(def_id);\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -799,14 +791,10 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             for trait_item in trait_items {\n                 if let hir::ConstTraitItem(ref ty, _) = trait_item.node {\n                     let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n-                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n+                    generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&trait_predicates)\n                         .to_ty(&ExplicitRscope, ty);\n-                    tcx.register_item_type(const_def_id,\n-                                           TypeScheme {\n-                                               generics: ty_generics,\n-                                               ty: ty,\n-                                           });\n+                    tcx.item_types.borrow_mut().insert(const_def_id, ty);\n                     convert_associated_const(ccx, container, trait_item.id, ty)\n                 }\n             }\n@@ -840,28 +828,31 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let ty = type_of_def_id(ccx, def_id);\n+            let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n \n             let variant = tcx.lookup_adt_def_master(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n-                convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+                convert_field(ccx, generics, &predicates, f, ty_f)\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(ccx, struct_def.id(), variant, scheme, predicates);\n+                convert_variant_ctor(ccx, struct_def.id(), variant, ty, predicates);\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            type_scheme_of_def_id(ccx, def_id);\n+            type_of_def_id(ccx, def_id);\n+            generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n         },\n         _ => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            type_scheme_of_def_id(ccx, def_id);\n+            type_of_def_id(ccx, def_id);\n+            generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n         },\n     }\n@@ -870,13 +861,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n                                   variant: ty::VariantDef<'tcx>,\n-                                  scheme: ty::TypeScheme<'tcx>,\n+                                  ty: Ty<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(ctor_id);\n     generics_of_def_id(ccx, def_id);\n     let ctor_ty = match variant.ctor_kind {\n-        CtorKind::Fictive | CtorKind::Const => scheme.ty,\n+        CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n             let inputs: Vec<_> =\n                 variant.fields\n@@ -890,26 +881,26 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 abi: abi::Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: inputs,\n-                    output: scheme.ty,\n+                    output: ty,\n                     variadic: false\n                 })\n             }))\n         }\n     };\n-    write_ty_to_tcx(ccx, ctor_id, ctor_ty);\n-    tcx.tcache.borrow_mut().insert(def_id, ctor_ty);\n+    tcx.item_types.borrow_mut().insert(def_id, ctor_ty);\n     tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         def: ty::AdtDefMaster<'tcx>,\n-                                        scheme: ty::TypeScheme<'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        generics: &'tcx ty::Generics<'tcx>,\n                                         predicates: ty::GenericPredicates<'tcx>,\n                                         variants: &[hir::Variant]) {\n     // fill the field types\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n         for (f, ty_f) in variant.node.data.fields().iter().zip(ty_variant.fields.iter()) {\n-            convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+            convert_field(ccx, generics, &predicates, f, ty_f)\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n@@ -918,7 +909,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ccx,\n             variant.node.data.id(),\n             ty_variant,\n-            scheme.clone(),\n+            ty,\n             predicates.clone()\n         );\n     }\n@@ -1216,7 +1207,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n         }\n     };\n \n-    let super_predicates = ccx.tcx.lookup_super_predicates(def_id);\n+    let super_predicates = ccx.tcx.item_super_predicates(def_id);\n \n     // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n@@ -1283,7 +1274,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let node_id = if let Some(id) = tcx.map.as_local_node_id(def_id) {\n         id\n     } else {\n-        return tcx.lookup_generics(def_id);\n+        return tcx.item_generics(def_id);\n     };\n     tcx.generics.memoize(def_id, || {\n         use rustc::hir::map::*;\n@@ -1298,6 +1289,18 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let parent_id = tcx.map.get_parent(node_id);\n                 Some(tcx.map.local_def_id(parent_id))\n             }\n+            NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n+                let mut parent_id = node_id;\n+                loop {\n+                    match tcx.map.get(parent_id) {\n+                        NodeItem(_) | NodeImplItem(_) | NodeTraitItem(_) => break,\n+                        _ => {\n+                            parent_id = tcx.map.get_parent_node(parent_id);\n+                        }\n+                    }\n+                }\n+                Some(tcx.map.local_def_id(parent_id))\n+            }\n             _ => None\n         };\n \n@@ -1377,13 +1380,11 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let mut own_start = has_self as u32;\n         let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n             let generics = generics_of_def_id(ccx, def_id);\n-            assert_eq!(generics.parent, None);\n-            assert_eq!(generics.parent_regions, 0);\n-            assert_eq!(generics.parent_types, 0);\n             assert_eq!(has_self, false);\n             parent_has_self = generics.has_self;\n             own_start = generics.count() as u32;\n-            (generics.regions.len() as u32, generics.types.len() as u32)\n+            (generics.parent_regions + generics.regions.len() as u32,\n+             generics.parent_types + generics.types.len() as u32)\n         });\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n@@ -1436,12 +1437,15 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let node_id = if let Some(id) = ccx.tcx.map.as_local_node_id(def_id) {\n         id\n     } else {\n-        return ccx.tcx.lookup_item_type(def_id).ty;\n+        return ccx.tcx.item_type(def_id);\n     };\n-    ccx.tcx.tcache.memoize(def_id, || {\n+    ccx.tcx.item_types.memoize(def_id, || {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n+        // Alway bring in generics, as computing the type needs them.\n+        generics_of_def_id(ccx, def_id);\n+\n         let ty = match ccx.tcx.map.get(node_id) {\n             NodeItem(item) => {\n                 match item.node {\n@@ -1505,24 +1509,10 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n         };\n \n-        write_ty_to_tcx(ccx, node_id, ty);\n         ty\n     })\n }\n \n-fn type_scheme_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                   def_id: DefId)\n-                                   -> ty::TypeScheme<'tcx> {\n-    if def_id.is_local() {\n-        ty::TypeScheme {\n-            generics: generics_of_def_id(ccx, def_id),\n-            ty: type_of_def_id(ccx, def_id)\n-        }\n-    } else {\n-        ccx.tcx.lookup_item_type(def_id)\n-    }\n-}\n-\n fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item)\n                                 -> ty::GenericPredicates<'tcx> {\n@@ -1554,7 +1544,8 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n-    type_scheme_of_def_id(ccx, def_id);\n+    type_of_def_id(ccx, def_id);\n+    generics_of_def_id(ccx, def_id);\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n@@ -1648,7 +1639,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let ref base_predicates = match parent {\n         Some(def_id) => {\n             assert_eq!(super_predicates, vec![]);\n-            tcx.lookup_predicates(def_id)\n+            tcx.item_predicates(def_id)\n         }\n         None => {\n             ty::GenericPredicates {\n@@ -2035,14 +2026,14 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_predicates: &mut ty::GenericPredicates<'tcx>,\n                                                  impl_def_id: DefId)\n {\n-    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n+    let impl_ty = ccx.tcx.item_type(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n     let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n+        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n@@ -2066,12 +2057,12 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     impl_items: &[hir::ImplItem])\n {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n-    let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n+    let impl_ty = ccx.tcx.item_type(impl_def_id);\n+    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n+        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n@@ -2085,10 +2076,10 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             item.kind == ty::AssociatedKind::Type && item.has_value\n         })\n         .flat_map(|def_id| {\n-            ctp::parameters_for(&ccx.tcx.lookup_item_type(def_id).ty, true)\n+            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n         }).collect();\n \n-    for (ty_lifetime, lifetime) in impl_scheme.generics.regions.iter()\n+    for (ty_lifetime, lifetime) in ccx.tcx.item_generics(impl_def_id).regions.iter()\n         .zip(&ast_generics.lifetimes)\n     {\n         let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());"}, {"sha": "2c12959dbdde25b4d34df273e6fbdc31ee66e072", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -44,7 +44,7 @@ independently:\n   into the `ty` representation\n \n - collect: computes the types of each top-level item and enters them into\n-  the `cx.tcache` table for later use\n+  the `tcx.types` table for later use\n \n - coherence: enforces coherence rules, builds some tables\n \n@@ -108,7 +108,7 @@ use dep_graph::DepNode;\n use hir::map as hir_map;\n use rustc::infer::{InferOk, TypeOrigin};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use session::{config, CompileResult};\n use util::common::time;\n@@ -159,27 +159,6 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n     pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n }\n \n-// Functions that write types into the node type table\n-fn write_ty_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-    debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n-    assert!(!ty.needs_infer());\n-    ccx.tcx.node_type_insert(node_id, ty);\n-}\n-\n-fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 node_id: ast::NodeId,\n-                                 item_substs: ty::ItemSubsts<'tcx>) {\n-    if !item_substs.is_noop() {\n-        debug!(\"write_substs_to_tcx({}, {:?})\",\n-               node_id,\n-               item_substs);\n-\n-        assert!(!item_substs.substs.needs_infer());\n-\n-        ccx.tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n-    }\n-}\n-\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n@@ -216,7 +195,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = tcx.tables().node_id_to_type(main_id);\n+    let main_def_id = tcx.map.local_def_id(main_id);\n+    let main_t = tcx.item_type(main_def_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(main_id) {\n@@ -237,7 +217,6 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let main_def_id = tcx.map.local_def_id(main_id);\n             let substs = tcx.intern_substs(&[]);\n             let se_ty = tcx.mk_fn_def(main_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n@@ -268,7 +247,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = tcx.tables().node_id_to_type(start_id);\n+    let start_def_id = ccx.tcx.map.local_def_id(start_id);\n+    let start_t = tcx.item_type(start_def_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(start_id) {\n@@ -289,7 +269,6 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let start_def_id = ccx.tcx.map.local_def_id(start_id);\n             let substs = tcx.intern_substs(&[]);\n             let se_ty = tcx.mk_fn_def(start_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "10fca644ec16e37b71c5fb43dcbf00b88790f7c3", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -82,16 +82,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let scheme = tcx.lookup_item_type(did);\n+                let generics = tcx.item_generics(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n-                // self.add_constraints_from_generics(&scheme.generics);\n+                // self.add_constraints_from_generics(generics);\n \n                 for field in tcx.lookup_adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(&scheme.generics,\n+                    self.add_constraints_from_ty(generics,\n                                                  field.unsubst_ty(),\n                                                  self.covariant);\n                 }\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let item_type = self.tcx().lookup_item_type(def.did);\n+                let adt_generics = self.tcx().item_generics(def.did);\n \n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n@@ -345,8 +345,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 self.add_constraints_from_substs(generics,\n                                                  def.did,\n-                                                 &item_type.generics.types,\n-                                                 &item_type.generics.regions,\n+                                                 &adt_generics.types,\n+                                                 &adt_generics.regions,\n                                                  substs,\n                                                  variance);\n             }"}, {"sha": "e8367bca2ef211e617d047e9f3a0f0fb7364e935", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -164,7 +164,7 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n                                       did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n@@ -178,8 +178,8 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n \n fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      did: DefId) -> clean::Function {\n-    let t = tcx.lookup_item_type(did);\n-    let (decl, style, abi) = match t.ty.sty {\n+    let ty = tcx.item_type(did);\n+    let (decl, style, abi) = match ty.sty {\n         ty::TyFnDef(.., ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n@@ -190,10 +190,10 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n         hir::Constness::NotConst\n     };\n \n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n@@ -202,20 +202,18 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n \n fn build_enum<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         did: DefId) -> clean::Enum {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n \n     clean::Enum {\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         variants_stripped: false,\n         variants: tcx.lookup_adt_def(did).variants.clean(cx),\n     }\n }\n \n fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId) -> clean::Struct {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n@@ -224,34 +222,32 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             CtorKind::Fn => doctree::Tuple,\n             CtorKind::Const => doctree::Unit,\n         },\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId) -> clean::Union {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Union {\n         struct_type: doctree::Plain,\n-        generics: (t.generics, &predicates).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_type_alias<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               did: DefId) -> clean::Typedef {\n-    let t = tcx.lookup_item_type(did);\n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n \n     clean::Typedef {\n-        type_: t.ty.clean(cx),\n-        generics: (t.generics, &predicates).clean(cx),\n+        type_: tcx.item_type(did).clean(cx),\n+        generics: (tcx.item_generics(did), &predicates).clean(cx),\n     }\n }\n \n@@ -354,8 +350,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n         });\n     }\n \n-    let ty = tcx.lookup_item_type(did);\n-    let for_ = ty.ty.clean(cx);\n+    let for_ = tcx.item_type(did).clean(cx);\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n@@ -365,11 +360,10 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n         }\n     }\n \n-    let predicates = tcx.lookup_predicates(did);\n+    let predicates = tcx.item_predicates(did);\n     let trait_items = tcx.associated_items(did).filter_map(|item| {\n         match item.kind {\n             ty::AssociatedKind::Const => {\n-                let type_scheme = tcx.lookup_item_type(item.def_id);\n                 let default = if item.has_value {\n                     Some(pprust::expr_to_string(\n                         lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n@@ -379,7 +373,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 Some(clean::Item {\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::AssociatedConstItem(\n-                        type_scheme.ty.clean(cx),\n+                        tcx.item_type(item.def_id).clean(cx),\n                         default,\n                     ),\n                     source: clean::Span::empty(),\n@@ -419,7 +413,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             }\n             ty::AssociatedKind::Type => {\n                 let typedef = clean::Typedef {\n-                    type_: tcx.lookup_item_type(item.def_id).ty.clean(cx),\n+                    type_: tcx.item_type(item.def_id).clean(cx),\n                     generics: clean::Generics {\n                         lifetimes: vec![],\n                         type_params: vec![],\n@@ -463,7 +457,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             provided_trait_methods: provided,\n             trait_: trait_,\n             for_: for_,\n-            generics: (ty.generics, &predicates).clean(cx),\n+            generics: (tcx.item_generics(did), &predicates).clean(cx),\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n         }),\n@@ -514,7 +508,7 @@ fn build_const<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.lookup_item_type(did).ty.clean(cx)),\n+        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.item_type(did).clean(cx)),\n         expr: sn\n     }\n }\n@@ -523,7 +517,7 @@ fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId,\n                           mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: tcx.lookup_item_type(did).ty.clean(cx),\n+        type_: tcx.item_type(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "f4df28a147630be8a320b31644204266c3732648", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -1342,13 +1342,13 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n-                let ty = cx.tcx().lookup_item_type(self.def_id).ty;\n+                let ty = cx.tcx().item_type(self.def_id);\n                 AssociatedConstItem(ty.clean(cx), None)\n             }\n             ty::AssociatedKind::Method => {\n-                let generics = (cx.tcx().lookup_generics(self.def_id),\n-                                &cx.tcx().lookup_predicates(self.def_id)).clean(cx);\n-                let fty = match cx.tcx().lookup_item_type(self.def_id).ty.sty {\n+                let generics = (cx.tcx().item_generics(self.def_id),\n+                                &cx.tcx().item_predicates(self.def_id)).clean(cx);\n+                let fty = match cx.tcx().item_type(self.def_id).sty {\n                     ty::TyFnDef(_, _, f) => f,\n                     _ => unreachable!()\n                 };\n@@ -1357,7 +1357,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 if self.method_has_self_argument {\n                     let self_ty = match self.container {\n                         ty::ImplContainer(def_id) => {\n-                            cx.tcx().lookup_item_type(def_id).ty\n+                            cx.tcx().item_type(def_id)\n                         }\n                         ty::TraitContainer(_) => cx.tcx().mk_self_type()\n                     };\n@@ -1405,7 +1405,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n                     let def = cx.tcx().lookup_trait_def(did);\n-                    let predicates = cx.tcx().lookup_predicates(did);\n+                    let predicates = cx.tcx().item_predicates(did);\n                     let generics = (def.generics, &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n@@ -1441,7 +1441,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n \n                 let ty = if self.has_value {\n-                    Some(cx.tcx().lookup_item_type(self.def_id).ty)\n+                    Some(cx.tcx().item_type(self.def_id))\n                 } else {\n                     None\n                 };\n@@ -1901,7 +1901,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyAnon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let item_predicates = cx.tcx().lookup_predicates(def_id);\n+                let item_predicates = cx.tcx().item_predicates(def_id);\n                 let substs = cx.tcx().lift(&substs).unwrap();\n                 let bounds = item_predicates.instantiate(cx.tcx(), substs);\n                 ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {"}, {"sha": "19e084905aa92a03f0804fc93a6a7b0aac1238e3", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd4ee6d08064a941e1b628fc54131cfe784b80b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=6dd4ee6d08064a941e1b628fc54131cfe784b80b", "patch": "@@ -153,7 +153,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let predicates = cx.tcx().lookup_super_predicates(child).predicates;\n+    let predicates = cx.tcx().item_super_predicates(child).predicates;\n     predicates.iter().filter_map(|pred| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.0.trait_ref.self_ty().is_self() {"}]}