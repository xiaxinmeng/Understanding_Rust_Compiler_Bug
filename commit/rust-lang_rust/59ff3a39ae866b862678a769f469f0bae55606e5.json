{"sha": "59ff3a39ae866b862678a769f469f0bae55606e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZmYzYTM5YWU4NjZiODYyNjc4YTc2OWY0NjlmMGJhZTU1NjA2ZTU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-07T03:25:14Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-07T03:25:14Z"}, "message": "expand on ctors", "tree": {"sha": "14bc881e0f7a90308dc3e0ab2d3be213b726100a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14bc881e0f7a90308dc3e0ab2d3be213b726100a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59ff3a39ae866b862678a769f469f0bae55606e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59ff3a39ae866b862678a769f469f0bae55606e5", "html_url": "https://github.com/rust-lang/rust/commit/59ff3a39ae866b862678a769f469f0bae55606e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59ff3a39ae866b862678a769f469f0bae55606e5/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31adad6aad5b0fbff85a6effcfc5e11ba611493d", "url": "https://api.github.com/repos/rust-lang/rust/commits/31adad6aad5b0fbff85a6effcfc5e11ba611493d", "html_url": "https://github.com/rust-lang/rust/commit/31adad6aad5b0fbff85a6effcfc5e11ba611493d"}], "stats": {"total": 77, "additions": 53, "deletions": 24}, "files": [{"sha": "99bcf5e283ee38a3667e482fd9eb498c454ffc6f", "filename": "constructors.md", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/59ff3a39ae866b862678a769f469f0bae55606e5/constructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/59ff3a39ae866b862678a769f469f0bae55606e5/constructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/constructors.md?ref=59ff3a39ae866b862678a769f469f0bae55606e5", "patch": "@@ -1,26 +1,55 @@\n % Constructors\n \n-Unlike C++, Rust does not come with a slew of builtin\n-kinds of constructor. There are no Copy, Default, Assignment, Move, or whatever constructors.\n-This largely has to do with Rust's philosophy of being explicit.\n-\n-Move constructors are meaningless in Rust because we don't enable types to \"care\" about their\n-location in memory. Every type must be ready for it to be blindly memcopied to somewhere else\n-in memory. This means pure on-the-stack-but-still-movable intrusive linked lists are simply\n-not happening in Rust (safely).\n-\n-Assignment and copy constructors similarly don't exist because move semantics are the *default*\n-in rust. At most `x = y` just moves the bits of y into the x variable. Rust does provide two\n-facilities for going back to C++'s copy-oriented semantics: `Copy` and `Clone`. Clone is our\n-moral equivalent of a copy constructor, but it's never implicitly invoked. You have to explicitly\n-call `clone` on an element you want to be cloned. Copy is a special case of Clone where the\n-implementation is just \"copy the bits\". Copy types *are* implicitly\n-cloned whenever they're moved, but because of the definition of Copy this just means *not*\n-treating the old copy as uninitialized -- a no-op.\n-\n-While Rust provides a `Default` trait for specifying the moral equivalent of a default\n-constructor, it's incredibly rare for this trait to be used. This is because variables\n-[aren't implicitly initialized][uninit]. Default is basically only useful for generic\n-programming. In concrete contexts, a type will provide a static `new` method for any\n-kind of \"default\" constructor. This has no relation to `new` in other\n-languages and has no special meaning. It's just a naming convention.\n\\ No newline at end of file\n+There is exactly one way to create an instance of a user-defined type: name it,\n+and initialize all its fields at once:\n+\n+```rust\n+struct Foo {\n+\ta: u8,\n+\tb: u32,\n+\tc: bool,\n+}\n+\n+enum Bar {\n+\tX(u32),\n+\tY(bool),\n+}\n+\n+struct Empty;\n+\n+let foo = Foo { a: 0, b: 1, c: false };\n+let bar = Bar::X(0);\n+let empty = Empty;\n+```\n+\n+That's it. Every other way you make an instance of a type is just calling a\n+totally vanilla function that does some stuff and eventually bottoms out to The\n+One True Constructor.\n+\n+Unlike C++, Rust does not come with a slew of built in kinds of constructor.\n+There are no Copy, Default, Assignment, Move, or whatever constructors. The\n+reasons for this are varied, but it largely boils down to Rust's philosophy\n+of *being explicit*.\n+\n+Move constructors are meaningless in Rust because we don't enable types to\n+\"care\" about their location in memory. Every type must be ready for it to be\n+blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\n+still-movable intrusive linked lists are simply not happening in Rust (safely).\n+\n+Assignment and copy constructors similarly don't exist because move semantics\n+are the *only* semantics in Rust. At most `x = y` just moves the bits of y into the x\n+variable. Rust *does* provide two facilities for providing C++'s copy-oriented\n+semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n+constructor, but it's never implicitly invoked. You have to explicitly call\n+`clone` on an element you want to be cloned. Copy is a special case of Clone\n+where the implementation is just \"copy the bits\". Copy types *are* implicitly\n+cloned whenever they're moved, but because of the definition of Copy this just\n+means *not* treating the old copy as uninitialized -- a no-op.\n+\n+While Rust provides a `Default` trait for specifying the moral equivalent of a\n+default constructor, it's incredibly rare for this trait to be used. This is\n+because variables [aren't implicitly initialized][uninit]. Default is basically\n+only useful for generic programming. In concrete contexts, a type will provide a\n+static `new` method for any kind of \"default\" constructor. This has no relation\n+to `new` in other languages and has no special meaning. It's just a naming\n+convention."}]}