{"sha": "0ff8200671c38e0068ba40267d02f99737e77cab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZjgyMDA2NzFjMzhlMDA2OGJhNDAyNjdkMDJmOTk3MzdlNzdjYWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-04T02:07:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-04T02:07:33Z"}, "message": "factor code for write guards into its own module; add neglected resolve_stage0", "tree": {"sha": "4f7c6896cdc8945651cc865b7ec120ef146dcb8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7c6896cdc8945651cc865b7ec120ef146dcb8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ff8200671c38e0068ba40267d02f99737e77cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff8200671c38e0068ba40267d02f99737e77cab", "html_url": "https://github.com/rust-lang/rust/commit/0ff8200671c38e0068ba40267d02f99737e77cab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ff8200671c38e0068ba40267d02f99737e77cab/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be08c3e5146953619ff777aaa422152dfee4ad28", "url": "https://api.github.com/repos/rust-lang/rust/commits/be08c3e5146953619ff777aaa422152dfee4ad28", "html_url": "https://github.com/rust-lang/rust/commit/be08c3e5146953619ff777aaa422152dfee4ad28"}], "stats": {"total": 5514, "additions": 5514, "deletions": 0}, "files": [{"sha": "ff46abaf7128c181758349ed4208f7e3dad34a59", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "added", "additions": 5313, "deletions": 0, "changes": 5313, "blob_url": "https://github.com/rust-lang/rust/blob/0ff8200671c38e0068ba40267d02f99737e77cab/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff8200671c38e0068ba40267d02f99737e77cab/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=0ff8200671c38e0068ba40267d02f99737e77cab"}, {"sha": "18f21b489b0b80ac7e437d546071e11879d02d24", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/0ff8200671c38e0068ba40267d02f99737e77cab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff8200671c38e0068ba40267d02f99737e77cab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=0ff8200671c38e0068ba40267d02f99737e77cab", "patch": "@@ -0,0 +1,201 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Logic relating to rooting and write guards for managed values\n+//! (`@` and `@mut`). This code is primarily for use by datum;\n+//! it exists in its own module both to keep datum.rs bite-sized\n+//! and for each in debugging (e.g., so you can use\n+//! `RUST_LOG=rustc::middle::trans::write_guard`).\n+\n+use lib::llvm::ValueRef;\n+use middle::borrowck::{RootInfo, root_map_key, DynaImm, DynaMut};\n+use middle::trans::base::*;\n+use middle::trans::build::*;\n+use middle::trans::callee;\n+use middle::trans::common::*;\n+use middle::trans::datum::*;\n+use middle::trans::expr;\n+use middle::ty;\n+use driver::session;\n+use syntax::codemap::span;\n+use syntax::ast;\n+\n+pub fn root_and_write_guard(datum: &Datum,\n+                            mut bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id,\n+                            derefs: uint) -> block {\n+    let key = root_map_key { id: expr_id, derefs: derefs };\n+    debug!(\"write_guard::root_and_write_guard(key=%?)\", key);\n+\n+    // root the autoderef'd value, if necessary:\n+    //\n+    // (Note: root'd values are always boxes)\n+    let ccx = bcx.ccx();\n+    bcx = match ccx.maps.root_map.find(&key) {\n+        None => bcx,\n+        Some(&root_info) => root(datum, bcx, span, key, root_info)\n+    };\n+\n+    // Perform the write guard, if necessary.\n+    //\n+    // (Note: write-guarded values are always boxes)\n+    if ccx.maps.write_guard_map.contains(&key) {\n+        perform_write_guard(datum, bcx, span)\n+    } else {\n+        bcx\n+    }\n+}\n+\n+pub fn return_to_mut(mut bcx: block,\n+                     root_key: root_map_key,\n+                     frozen_val_ref: ValueRef,\n+                     bits_val_ref: ValueRef,\n+                     filename_val: ValueRef,\n+                     line_val: ValueRef) -> block {\n+    debug!(\"write_guard::return_to_mut(root_key=%?, %s, %s, %s)\",\n+           root_key,\n+           bcx.to_str(),\n+           val_str(bcx.ccx().tn, frozen_val_ref),\n+           val_str(bcx.ccx().tn, bits_val_ref));\n+\n+    let box_ptr =\n+        Load(bcx, PointerCast(bcx,\n+                              frozen_val_ref,\n+                              T_ptr(T_ptr(T_i8()))));\n+\n+    let bits_val =\n+        Load(bcx, bits_val_ref);\n+\n+    if bcx.tcx().sess.opts.optimize == session::No {\n+        bcx = callee::trans_lang_call(\n+            bcx,\n+            bcx.tcx().lang_items.unrecord_borrow_fn(),\n+            ~[\n+                box_ptr,\n+                bits_val,\n+                filename_val,\n+                line_val\n+            ],\n+            expr::Ignore);\n+    }\n+\n+    callee::trans_lang_call(\n+        bcx,\n+        bcx.tcx().lang_items.return_to_mut_fn(),\n+        ~[\n+            box_ptr,\n+            bits_val,\n+            filename_val,\n+            line_val\n+        ],\n+        expr::Ignore\n+    )\n+}\n+\n+fn root(datum: &Datum,\n+        mut bcx: block,\n+        span: span,\n+        root_key: root_map_key,\n+        root_info: RootInfo) -> block {\n+    //! In some cases, borrowck will decide that an @T/@[]/@str\n+    //! value must be rooted for the program to be safe.  In that\n+    //! case, we will call this function, which will stash a copy\n+    //! away until we exit the scope `scope_id`.\n+\n+    debug!(\"write_guard::root(root_key=%?, root_info=%?, datum=%?)\",\n+           root_key, root_info, datum.to_str(bcx.ccx()));\n+\n+    if bcx.sess().trace() {\n+        trans_trace(\n+            bcx, None,\n+            @fmt!(\"preserving until end of scope %d\",\n+                  root_info.scope));\n+    }\n+\n+    // First, root the datum. Note that we must zero this value,\n+    // because sometimes we root on one path but not another.\n+    // See e.g. #4904.\n+    let scratch = scratch_datum(bcx, datum.ty, true);\n+    datum.copy_to_datum(bcx, INIT, scratch);\n+    let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n+    add_clean_temp_mem(cleanup_bcx, scratch.val, scratch.ty);\n+\n+    // Now, consider also freezing it.\n+    match root_info.freeze {\n+        None => {}\n+        Some(freeze_kind) => {\n+            let (filename, line) = filename_and_line_num_from_span(bcx, span);\n+\n+            // in this case, we don't have to zero, because\n+            // scratch.val will be NULL should the cleanup get\n+            // called without the freezing actually occurring, and\n+            // return_to_mut checks for this condition.\n+            let scratch_bits = scratch_datum(bcx, ty::mk_uint(), false);\n+\n+            let freeze_did = match freeze_kind {\n+                DynaImm => bcx.tcx().lang_items.borrow_as_imm_fn(),\n+                DynaMut => bcx.tcx().lang_items.borrow_as_mut_fn(),\n+            };\n+\n+            let box_ptr = Load(bcx,\n+                               PointerCast(bcx,\n+                                           scratch.val,\n+                                           T_ptr(T_ptr(T_i8()))));\n+\n+            bcx = callee::trans_lang_call(\n+                bcx,\n+                freeze_did,\n+                ~[\n+                    box_ptr,\n+                    filename,\n+                    line\n+                ],\n+                expr::SaveIn(scratch_bits.val));\n+\n+            if bcx.tcx().sess.opts.optimize == session::No {\n+                bcx = callee::trans_lang_call(\n+                    bcx,\n+                    bcx.tcx().lang_items.record_borrow_fn(),\n+                    ~[\n+                        box_ptr,\n+                        Load(bcx, scratch_bits.val),\n+                        filename,\n+                        line\n+                    ],\n+                    expr::Ignore);\n+            }\n+\n+            add_clean_return_to_mut(\n+                cleanup_bcx, root_key, scratch.val, scratch_bits.val,\n+                filename, line);\n+        }\n+    }\n+\n+    bcx\n+}\n+\n+fn perform_write_guard(datum: &Datum,\n+                       bcx: block,\n+                       span: span) -> block {\n+    debug!(\"perform_write_guard\");\n+\n+    let llval = datum.to_value_llval(bcx);\n+    let (filename, line) = filename_and_line_num_from_span(bcx, span);\n+\n+    callee::trans_lang_call(\n+        bcx,\n+        bcx.tcx().lang_items.check_not_borrowed_fn(),\n+        ~[PointerCast(bcx, llval, T_ptr(T_i8())),\n+          filename,\n+          line],\n+        expr::Ignore)\n+}\n+"}]}