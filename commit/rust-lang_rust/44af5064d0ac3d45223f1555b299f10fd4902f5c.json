{"sha": "44af5064d0ac3d45223f1555b299f10fd4902f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0YWY1MDY0ZDBhYzNkNDUyMjNmMTU1NWIyOTlmMTBmZDQ5MDJmNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-01T16:37:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-01T16:37:39Z"}, "message": "auto merge of #6871 : pcwalton/rust/de-pub-impl, r=pcwalton", "tree": {"sha": "33a4db59bd936a73594ca144e809b6074d6ccef3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33a4db59bd936a73594ca144e809b6074d6ccef3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44af5064d0ac3d45223f1555b299f10fd4902f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44af5064d0ac3d45223f1555b299f10fd4902f5c", "html_url": "https://github.com/rust-lang/rust/commit/44af5064d0ac3d45223f1555b299f10fd4902f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44af5064d0ac3d45223f1555b299f10fd4902f5c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8391ccea0b2e2718a4d4ef999e9f03583c7ddea", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8391ccea0b2e2718a4d4ef999e9f03583c7ddea", "html_url": "https://github.com/rust-lang/rust/commit/b8391ccea0b2e2718a4d4ef999e9f03583c7ddea"}, {"sha": "5fb254695b4db9af3d8e33577fae28ae9f7006c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb254695b4db9af3d8e33577fae28ae9f7006c5", "html_url": "https://github.com/rust-lang/rust/commit/5fb254695b4db9af3d8e33577fae28ae9f7006c5"}], "stats": {"total": 5690, "additions": 2905, "deletions": 2785}, "files": [{"sha": "f4259afcaa3c17888a1e89c70dd0102fbc588fef", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -56,10 +56,10 @@ pub struct Condvar<'self> {\n     cond: &'self sync::Condvar<'self>\n }\n \n-pub impl<'self> Condvar<'self> {\n+impl<'self> Condvar<'self> {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n     #[inline(always)]\n-    fn wait(&self) { self.wait_on(0) }\n+    pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n      * Atomically exit the associated ARC and block on a specified condvar\n@@ -68,7 +68,7 @@ pub impl<'self> Condvar<'self> {\n      * wait() is equivalent to wait_on(0).\n      */\n     #[inline(always)]\n-    fn wait_on(&self, condvar_id: uint) {\n+    pub fn wait_on(&self, condvar_id: uint) {\n         assert!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n         // This is why we need to wrap sync::condvar.\n@@ -77,28 +77,28 @@ pub impl<'self> Condvar<'self> {\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n     #[inline(always)]\n-    fn signal(&self) -> bool { self.signal_on(0) }\n+    pub fn signal(&self) -> bool { self.signal_on(0) }\n \n     /**\n      * Wake up a blocked task on a specified condvar (as\n      * sync::cond.signal_on). Returns false if there was no blocked task.\n      */\n     #[inline(always)]\n-    fn signal_on(&self, condvar_id: uint) -> bool {\n+    pub fn signal_on(&self, condvar_id: uint) -> bool {\n         assert!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n     #[inline(always)]\n-    fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n \n     /**\n      * Wake up all blocked tasks on a specified condvar (as\n      * sync::cond.broadcast_on). Returns Returns the number of tasks woken.\n      */\n     #[inline(always)]\n-    fn broadcast_on(&self, condvar_id: uint) -> uint {\n+    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n         assert!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n     }\n@@ -120,8 +120,8 @@ pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-pub impl<T:Const+Owned> ARC<T> {\n-    fn get<'a>(&'a self) -> &'a T {\n+impl<T:Const+Owned> ARC<T> {\n+    pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n }\n@@ -173,7 +173,7 @@ impl<T:Owned> Clone for MutexARC<T> {\n     }\n }\n \n-pub impl<T:Owned> MutexARC<T> {\n+impl<T:Owned> MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -199,7 +199,7 @@ pub impl<T:Owned> MutexARC<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline(always)]\n-    unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             // Borrowck would complain about this if the function were\n@@ -214,10 +214,10 @@ pub impl<T:Owned> MutexARC<T> {\n \n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline(always)]\n-    unsafe fn access_cond<'x, 'c, U>(\n-        &self,\n-        blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n-    {\n+    pub unsafe fn access_cond<'x, 'c, U>(&self,\n+                                         blk: &fn(x: &'x mut T,\n+                                                  c: &'c Condvar) -> U)\n+                                         -> U {\n         let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n             check_poison(true, (*state).failed);\n@@ -302,16 +302,18 @@ pub fn rw_arc_with_condvars<T:Const + Owned>(\n     RWARC { x: UnsafeAtomicRcBox::new(data), cant_nest: () }\n }\n \n-pub impl<T:Const + Owned> RWARC<T> {\n+impl<T:Const + Owned> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n-    fn clone(&self) -> RWARC<T> {\n-        RWARC { x: self.x.clone(),\n-                cant_nest: () }\n+    pub fn clone(&self) -> RWARC<T> {\n+        RWARC {\n+            x: self.x.clone(),\n+            cant_nest: (),\n+        }\n     }\n \n }\n \n-pub impl<T:Const + Owned> RWARC<T> {\n+impl<T:Const + Owned> RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -323,7 +325,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n     #[inline(always)]\n-    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write {\n@@ -333,11 +335,12 @@ pub impl<T:Const + Owned> RWARC<T> {\n             }\n         }\n     }\n+\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<'x, 'c, U>(&self,\n-                             blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n-                          -> U {\n+    pub fn write_cond<'x, 'c, U>(&self,\n+                                 blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n+                                 -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -350,6 +353,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n             }\n         }\n     }\n+\n     /**\n      * Access the underlying data immutably. May run concurrently with other\n      * reading tasks.\n@@ -359,7 +363,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * Failing will unlock the ARC while unwinding. However, unlike all other\n      * access modes, this will not poison the ARC.\n      */\n-    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*state).lock.read {\n@@ -389,7 +393,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n@@ -404,7 +408,8 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade<'a>(&self, token: RWWriteMode<'a, T>) -> RWReadMode<'a, T> {\n+    pub fn downgrade<'a>(&self, token: RWWriteMode<'a, T>)\n+                         -> RWReadMode<'a, T> {\n         unsafe {\n             // The rwlock should assert that the token belongs to us for us.\n             let state = self.x.get();\n@@ -451,9 +456,9 @@ pub struct RWReadMode<'self, T> {\n     token: sync::RWlockReadMode<'self>,\n }\n \n-pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n+impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,\n@@ -466,10 +471,11 @@ pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n             }\n         }\n     }\n+\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<'x, 'c, U>(&mut self,\n-                             blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n-                          -> U {\n+    pub fn write_cond<'x, 'c, U>(&mut self,\n+                                 blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n+                                 -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,\n@@ -491,9 +497,9 @@ pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     }\n }\n \n-pub impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n+impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {\n             RWReadMode {\n                 data: data,"}, {"sha": "57c2152490fb601265f348b0780bc2a073bee70d", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -166,9 +166,9 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (transmute(p & !1), p & 1 == 1)\n }\n \n-pub impl Arena {\n+impl Arena {\n     // Functions for the POD part of the arena\n-    priv fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -180,7 +180,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             // XXX: Borrow check\n             let head = transmute_mut_region(&mut self.pod_head);\n@@ -200,7 +200,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -211,8 +211,8 @@ pub impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    priv fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n-                             -> (*u8, *u8) {\n+    fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n+                         -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -224,8 +224,8 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n-                               -> (*u8, *u8) {\n+    fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n+                          -> (*u8, *u8) {\n         unsafe {\n             let head = transmute_mut_region(&mut self.head);\n \n@@ -247,7 +247,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -269,7 +269,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    pub fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check\n             let this = transmute_mut_region(self);"}, {"sha": "e3a15f76c786bed62621675aed22869fb152e47d", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::cmp;\n@@ -26,14 +28,17 @@ fn small_mask(nbits: uint) -> uint {\n     (1 << nbits) - 1\n }\n \n-pub impl SmallBitv {\n-    fn new(bits: uint) -> SmallBitv {\n+impl SmallBitv {\n+    pub fn new(bits: uint) -> SmallBitv {\n         SmallBitv {bits: bits}\n     }\n \n     #[inline(always)]\n-    fn bits_op(&mut self, right_bits: uint, nbits: uint,\n-               f: &fn(uint, uint) -> uint) -> bool {\n+    pub fn bits_op(&mut self,\n+                   right_bits: uint,\n+                   nbits: uint,\n+                   f: &fn(uint, uint) -> uint)\n+                   -> bool {\n         let mask = small_mask(nbits);\n         let old_b: uint = self.bits;\n         let new_b = f(old_b, right_bits);\n@@ -42,32 +47,32 @@ pub impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n     #[inline(always)]\n-    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n     #[inline(always)]\n-    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n     #[inline(always)]\n-    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n     #[inline(always)]\n-    fn get(&self, i: uint) -> bool {\n+    pub fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n     #[inline(always)]\n-    fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n         }\n@@ -77,30 +82,29 @@ pub impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n+    pub fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n     #[inline(always)]\n-    fn clear(&mut self) { self.bits = 0; }\n+    pub fn clear(&mut self) { self.bits = 0; }\n \n     #[inline(always)]\n-    fn set_all(&mut self) { self.bits = !0; }\n+    pub fn set_all(&mut self) { self.bits = !0; }\n \n     #[inline(always)]\n-    fn is_true(&self, nbits: uint) -> bool {\n+    pub fn is_true(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn is_false(&self, nbits: uint) -> bool {\n+    pub fn is_false(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn invert(&mut self) { self.bits = !self.bits; }\n-\n+    pub fn invert(&mut self) { self.bits = !self.bits; }\n }\n \n struct BigBitv {\n@@ -123,14 +127,17 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n     }\n }\n \n-pub impl BigBitv {\n-    fn new(storage: ~[uint]) -> BigBitv {\n+impl BigBitv {\n+    pub fn new(storage: ~[uint]) -> BigBitv {\n         BigBitv {storage: storage}\n     }\n \n     #[inline(always)]\n-    fn process(&mut self, b: &BigBitv, nbits: uint,\n-               op: &fn(uint, uint) -> uint) -> bool {\n+    pub fn process(&mut self,\n+                   b: &BigBitv,\n+                   nbits: uint,\n+                   op: &fn(uint, uint) -> uint)\n+                   -> bool {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n@@ -148,43 +155,43 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n+    pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n         uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n     }\n \n     #[inline(always)]\n-    fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n+    pub fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n     #[inline(always)]\n-    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 | w2)\n     }\n \n     #[inline(always)]\n-    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & w2)\n     }\n \n     #[inline(always)]\n-    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |_, w| w)\n     }\n \n     #[inline(always)]\n-    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & !w2)\n     }\n \n     #[inline(always)]\n-    fn get(&self, i: uint) -> bool {\n+    pub fn get(&self, i: uint) -> bool {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n     #[inline(always)]\n-    fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: uint, x: bool) {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let flag = 1 << b;\n@@ -193,7 +200,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -203,7 +210,6 @@ pub impl BigBitv {\n         }\n         return true;\n     }\n-\n }\n \n enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n@@ -222,8 +228,7 @@ fn die() -> ! {\n     fail!(\"Tried to do operation on bit vectors with different sizes\");\n }\n \n-priv impl Bitv {\n-\n+impl Bitv {\n     #[inline(always)]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n@@ -253,8 +258,8 @@ priv impl Bitv {\n \n }\n \n-pub impl Bitv {\n-    fn new(nbits: uint, init: bool) -> Bitv {\n+impl Bitv {\n+    pub fn new(nbits: uint, init: bool) -> Bitv {\n         let rep = if nbits <= uint::bits {\n             Small(~SmallBitv::new(if init {!0} else {0}))\n         }\n@@ -275,7 +280,7 @@ pub impl Bitv {\n      * the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n+    pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n     /**\n      * Calculates the intersection of two bitvectors\n@@ -284,7 +289,9 @@ pub impl Bitv {\n      * must be the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn intersect(&mut self, v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n+    pub fn intersect(&mut self, v1: &Bitv) -> bool {\n+        self.do_op(Intersect, v1)\n+    }\n \n     /**\n      * Assigns the value of `v1` to `self`\n@@ -293,16 +300,16 @@ pub impl Bitv {\n      * changed\n      */\n     #[inline(always)]\n-    fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n+    pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Retrieve the value at index `i`\n     #[inline(always)]\n-    fn get(&self, i: uint) -> bool {\n-       assert!((i < self.nbits));\n-       match self.rep {\n-         Big(ref b)   => b.get(i),\n-         Small(ref s) => s.get(i)\n-       }\n+    pub fn get(&self, i: uint) -> bool {\n+        assert!((i < self.nbits));\n+        match self.rep {\n+            Big(ref b)   => b.get(i),\n+            Small(ref s) => s.get(i)\n+        }\n     }\n \n     /**\n@@ -311,7 +318,7 @@ pub impl Bitv {\n      * `i` must be less than the length of the bitvector.\n      */\n     #[inline(always)]\n-    fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: uint, x: bool) {\n       assert!((i < self.nbits));\n       match self.rep {\n         Big(ref mut b)   => b.set(i, x),\n@@ -326,7 +333,7 @@ pub impl Bitv {\n      * bitvectors contain identical elements.\n      */\n     #[inline(always)]\n-    fn equal(&self, v1: &Bitv) -> bool {\n+    pub fn equal(&self, v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         Small(ref b) => match v1.rep {\n@@ -342,7 +349,7 @@ pub impl Bitv {\n \n     /// Set all bits to 0\n     #[inline(always)]\n-    fn clear(&mut self) {\n+    pub fn clear(&mut self) {\n         match self.rep {\n           Small(ref mut b) => b.clear(),\n           Big(ref mut s) => for s.each_storage() |w| { *w = 0u }\n@@ -351,15 +358,15 @@ pub impl Bitv {\n \n     /// Set all bits to 1\n     #[inline(always)]\n-    fn set_all(&mut self) {\n+    pub fn set_all(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.set_all(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n-    fn invert(&mut self) {\n+    pub fn invert(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.invert(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !*w } }\n@@ -375,11 +382,13 @@ pub impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline(always)]\n-    fn difference(&mut self, v: &Bitv) -> bool { self.do_op(Difference, v) }\n+    pub fn difference(&mut self, v: &Bitv) -> bool {\n+        self.do_op(Difference, v)\n+    }\n \n     /// Returns true if all bits are 1\n     #[inline(always)]\n-    fn is_true(&self) -> bool {\n+    pub fn is_true(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n@@ -390,7 +399,7 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n-    fn each(&self, f: &fn(bool) -> bool) -> bool {\n+    pub fn each(&self, f: &fn(bool) -> bool) -> bool {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { return false; }\n@@ -400,7 +409,7 @@ pub impl Bitv {\n     }\n \n     /// Returns true if all bits are 0\n-    fn is_false(&self) -> bool {\n+    pub fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n@@ -410,7 +419,7 @@ pub impl Bitv {\n       }\n     }\n \n-    fn init_to_vec(&self, i: uint) -> uint {\n+    pub fn init_to_vec(&self, i: uint) -> uint {\n       return if self.get(i) { 1 } else { 0 };\n     }\n \n@@ -419,7 +428,7 @@ pub impl Bitv {\n      *\n      * Each uint in the resulting vector has either value 0u or 1u.\n      */\n-    fn to_vec(&self) -> ~[uint] {\n+    pub fn to_vec(&self) -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n@@ -429,8 +438,7 @@ pub impl Bitv {\n      * size of the bitv is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n-    fn to_bytes(&self) -> ~[u8] {\n-\n+    pub fn to_bytes(&self) -> ~[u8] {\n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n@@ -457,7 +465,7 @@ pub impl Bitv {\n     /**\n      * Transform self into a [bool] by turning each bit into a bool\n      */\n-    fn to_bools(&self) -> ~[bool] {\n+    pub fn to_bools(&self) -> ~[bool] {\n         vec::from_fn(self.nbits, |i| self[i])\n     }\n \n@@ -467,7 +475,7 @@ pub impl Bitv {\n      * The resulting string has the same length as `self`, and each\n      * character is either '0' or '1'.\n      */\n-     fn to_str(&self) -> ~str {\n+     pub fn to_str(&self) -> ~str {\n        let mut rs = ~\"\";\n        for self.each() |i| { if i { rs += \"1\"; } else { rs += \"0\"; } };\n        rs\n@@ -480,7 +488,7 @@ pub impl Bitv {\n      * The uint vector is expected to only contain the values 0u and 1u. Both\n      * the bitvector and vector must have the same length\n      */\n-    fn eq_vec(&self, v: ~[uint]) -> bool {\n+    pub fn eq_vec(&self, v: ~[uint]) -> bool {\n         assert_eq!(self.nbits, v.len());\n         let mut i = 0;\n         while i < self.nbits {\n@@ -492,7 +500,7 @@ pub impl Bitv {\n         true\n     }\n \n-    fn ones(&self, f: &fn(uint) -> bool) -> bool {\n+    pub fn ones(&self, f: &fn(uint) -> bool) -> bool {\n         uint::range(0, self.nbits, |i| !self.get(i) || f(i))\n     }\n \n@@ -514,7 +522,6 @@ impl Clone for Bitv {\n           }\n         }\n     }\n-\n }\n \n /**\n@@ -585,14 +592,14 @@ pub struct BitvSet {\n     priv bitv: BigBitv\n }\n \n-pub impl BitvSet {\n+impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n-    fn new() -> BitvSet {\n+    pub fn new() -> BitvSet {\n         BitvSet{ size: 0, bitv: BigBitv::new(~[0]) }\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n-    fn from_bitv(bitv: Bitv) -> BitvSet {\n+    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         let mut size = 0;\n         for bitv.ones |_| {\n             size += 1;\n@@ -607,17 +614,17 @@ pub impl BitvSet {\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n \n     /// Consumes this set to return the underlying bit vector\n-    fn unwrap(self) -> Bitv {\n+    pub fn unwrap(self) -> Bitv {\n         let cap = self.capacity();\n         let BitvSet{bitv, _} = self;\n         return Bitv{ nbits:cap, rep: Big(~bitv) };\n     }\n \n     #[inline(always)]\n-    priv fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n+    fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n             for uint::bits.times {\n@@ -641,22 +648,22 @@ pub impl BitvSet {\n     }\n \n     /// Union in-place with the specified other bit vector\n-    fn union_with(&mut self, other: &BitvSet) {\n+    pub fn union_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n     /// Intersect in-place with the specified other bit vector\n-    fn intersect_with(&mut self, other: &BitvSet) {\n+    pub fn intersect_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n     /// Difference in-place with the specified other bit vector\n-    fn difference_with(&mut self, other: &BitvSet) {\n+    pub fn difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n     /// Symmetric difference in-place with the specified other bit vector\n-    fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n }\n@@ -810,7 +817,7 @@ impl Set<uint> for BitvSet {\n     }\n }\n \n-priv impl BitvSet {\n+impl BitvSet {\n     /// Visits each of the words that the two bit vectors (self and other)\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,"}, {"sha": "1001d4f6ac9ed26ef484a37637f42c0624589a09", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,6 +14,8 @@ Higher level communication abstractions.\n \n */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::comm::{GenericChan, GenericSmartChan, GenericPort};\n@@ -28,20 +30,20 @@ pub struct DuplexStream<T, U> {\n }\n \n // Allow these methods to be used without import:\n-pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n-    fn send(&self, x: T) {\n+impl<T:Owned,U:Owned> DuplexStream<T, U> {\n+    pub fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n-    fn try_send(&self, x: T) -> bool {\n+    pub fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n-    fn recv(&self, ) -> U {\n+    pub fn recv(&self, ) -> U {\n         self.port.recv()\n     }\n-    fn try_recv(&self) -> Option<U> {\n+    pub fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    fn peek(&self) -> bool {\n+    pub fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }"}, {"sha": "a8accc50eab01969fc9cbee95fd8675450b85ee3", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -44,45 +44,45 @@ impl<T> Mutable for Deque<T> {\n     }\n }\n \n-pub impl<T> Deque<T> {\n+impl<T> Deque<T> {\n     /// Create an empty Deque\n-    fn new() -> Deque<T> {\n+    pub fn new() -> Deque<T> {\n         Deque{nelts: 0, lo: 0, hi: 0,\n               elts: vec::from_fn(initial_capacity, |_| None)}\n     }\n \n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n \n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+    pub fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n \n     /// Retrieve an element in the deque by index\n     ///\n     /// Fails if there is no element with the given index\n-    fn get<'a>(&'a self, i: int) -> &'a T {\n+    pub fn get<'a>(&'a self, i: int) -> &'a T {\n         let idx = (self.lo + (i as uint)) % self.elts.len();\n         get(self.elts, idx)\n     }\n \n     /// Iterate over the elements in the deque\n-    fn each(&self, f: &fn(&T) -> bool) -> bool {\n+    pub fn each(&self, f: &fn(&T) -> bool) -> bool {\n         self.eachi(|_i, e| f(e))\n     }\n \n     /// Iterate over the elements in the deque by index\n-    fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n+    pub fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n         uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n     }\n \n     /// Remove and return the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn pop_front(&mut self) -> T {\n+    pub fn pop_front(&mut self) -> T {\n         let result = self.elts[self.lo].swap_unwrap();\n         self.lo = (self.lo + 1u) % self.elts.len();\n         self.nelts -= 1u;\n@@ -92,7 +92,7 @@ pub impl<T> Deque<T> {\n     /// Remove and return the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn pop_back(&mut self) -> T {\n+    pub fn pop_back(&mut self) -> T {\n         if self.hi == 0u {\n             self.hi = self.elts.len() - 1u;\n         } else { self.hi -= 1u; }\n@@ -103,7 +103,7 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Prepend an element to the deque\n-    fn add_front(&mut self, t: T) {\n+    pub fn add_front(&mut self, t: T) {\n         let oldlo = self.lo;\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n@@ -118,7 +118,7 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Append an element to the deque\n-    fn add_back(&mut self, t: T) {\n+    pub fn add_back(&mut self, t: T) {\n         if self.lo == self.hi && self.nelts != 0u {\n             self.elts = grow(self.nelts, self.lo, self.elts);\n             self.lo = 0u;\n@@ -136,7 +136,7 @@ pub impl<T> Deque<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    fn reserve(&mut self, n: uint) {\n+    pub fn reserve(&mut self, n: uint) {\n         vec::reserve(&mut self.elts, n);\n     }\n \n@@ -150,7 +150,7 @@ pub impl<T> Deque<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve_at_least(&mut self, n: uint) {\n         vec::reserve_at_least(&mut self.elts, n);\n     }\n }"}, {"sha": "52e2b75d6b6d33cb63eba8efd8445028605bfee7", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -41,7 +41,7 @@ pub struct DList<T> {\n     tl: DListLink<T>,\n }\n \n-priv impl<T> DListNode<T> {\n+impl<T> DListNode<T> {\n     fn assert_links(@mut self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n@@ -64,26 +64,26 @@ priv impl<T> DListNode<T> {\n     }\n }\n \n-pub impl<T> DListNode<T> {\n+impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    fn next_link(@mut self) -> DListLink<T> {\n+    pub fn next_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    fn next_node(@mut self) -> @mut DListNode<T> {\n+    pub fn next_node(@mut self) -> @mut DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => fail!(\"This dlist node has no next neighbour.\")\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    fn prev_link(@mut self) -> DListLink<T> {\n+    pub fn prev_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    fn prev_node(@mut self) -> @mut DListNode<T> {\n+    pub fn prev_node(@mut self) -> @mut DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => fail!(\"This dlist node has no previous neighbour.\")\n@@ -126,7 +126,7 @@ pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n     result\n }\n \n-priv impl<T> DList<T> {\n+impl<T> DList<T> {\n     fn new_link(data: T) -> DListLink<T> {\n         Some(@mut DListNode {\n             data: data,\n@@ -211,34 +211,34 @@ priv impl<T> DList<T> {\n     }\n }\n \n-pub impl<T> DList<T> {\n+impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    fn len(@mut self) -> uint { self.size }\n+    pub fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    fn is_empty(@mut self) -> bool { self.len() == 0 }\n+    pub fn is_empty(@mut self) -> bool { self.len() == 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(@mut self, data: T) {\n+    pub fn push_head(@mut self, data: T) {\n         self.add_head(DList::new_link(data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n+    pub fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.add_head(nobe);\n         nobe.get()\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(@mut self, data: T) {\n+    pub fn push(@mut self, data: T) {\n         self.add_tail(DList::new_link(data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n+    pub fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.add_tail(nobe);\n         nobe.get()\n@@ -247,28 +247,27 @@ pub impl<T> DList<T> {\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n+    pub fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n         self.insert_left(DList::new_link(data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n      * given node. O(1).\n      */\n-    fn insert_n_before(@mut self,\n-                       nobe: @mut DListNode<T>,\n-                       neighbour: @mut DListNode<T>) {\n+    pub fn insert_n_before(@mut self,\n+                           nobe: @mut DListNode<T>,\n+                           neighbour: @mut DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_left(Some(nobe), neighbour);\n     }\n     /**\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(\n-        @mut self,\n-        data: T,\n-        neighbour: @mut DListNode<T>\n-    ) -> @mut DListNode<T> {\n+    pub fn insert_before_n(@mut self,\n+                           data: T,\n+                           neighbour: @mut DListNode<T>)\n+                           -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.insert_left(nobe, neighbour);\n         nobe.get()\n@@ -277,73 +276,72 @@ pub impl<T> DList<T> {\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n+    pub fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n         self.insert_right(neighbour, DList::new_link(data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n      * given node. O(1).\n      */\n-    fn insert_n_after(@mut self,\n-                      nobe: @mut DListNode<T>,\n-                      neighbour: @mut DListNode<T>) {\n+    pub fn insert_n_after(@mut self,\n+                          nobe: @mut DListNode<T>,\n+                          neighbour: @mut DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, Some(nobe));\n     }\n     /**\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(\n-        @mut self,\n-        data: T,\n-        neighbour: @mut DListNode<T>\n-    ) -> @mut DListNode<T> {\n+    pub fn insert_after_n(@mut self,\n+                          data: T,\n+                          neighbour: @mut DListNode<T>)\n+                          -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.insert_right(neighbour, nobe);\n         nobe.get()\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n(@mut self) -> DListLink<T> {\n+    pub fn pop_n(@mut self) -> DListLink<T> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n(@mut self) -> DListLink<T> {\n+    pub fn pop_tail_n(@mut self) -> DListLink<T> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    fn peek_n(@mut self) -> DListLink<T> { self.hd }\n+    pub fn peek_n(@mut self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n+    pub fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    fn head_n(@mut self) -> @mut DListNode<T> {\n+    pub fn head_n(@mut self) -> @mut DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => fail!(\"Attempted to get the head of an empty dlist.\")\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    fn tail_n(@mut self) -> @mut DListNode<T> {\n+    pub fn tail_n(@mut self) -> @mut DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => fail!(\"Attempted to get the tail of an empty dlist.\")\n         }\n     }\n \n     /// Remove a node from anywhere in the list. O(1).\n-    fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n+    pub fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n \n     /**\n      * Empty another list onto the end of this list, joining this list's tail\n      * to the other list's head. O(1).\n      */\n-    fn append(@mut self, them: @mut DList<T>) {\n+    pub fn append(@mut self, them: @mut DList<T>) {\n         if managed::mut_ptr_eq(self, them) {\n             fail!(\"Cannot append a dlist to itself!\")\n         }\n@@ -360,7 +358,7 @@ pub impl<T> DList<T> {\n      * Empty another list onto the start of this list, joining the other\n      * list's tail to this list's head. O(1).\n      */\n-    fn prepend(@mut self, them: @mut DList<T>) {\n+    pub fn prepend(@mut self, them: @mut DList<T>) {\n         if managed::mut_ptr_eq(self, them) {\n             fail!(\"Cannot prepend a dlist to itself!\")\n         }\n@@ -375,7 +373,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Reverse the list's elements in place. O(n).\n-    fn reverse(@mut self) {\n+    pub fn reverse(@mut self) {\n         do self.hd.while_some |nobe| {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n@@ -389,7 +387,7 @@ pub impl<T> DList<T> {\n      * Remove everything from the list. This is important because the cyclic\n      * links won't otherwise be automatically refcounted-collected. O(n).\n      */\n-    fn clear(@mut self) {\n+    pub fn clear(@mut self) {\n         // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n         // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n@@ -398,7 +396,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n+    pub fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -409,7 +407,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Check data structure integrity. O(n).\n-    fn assert_consistent(@mut self) {\n+    pub fn assert_consistent(@mut self) {\n         if self.hd.is_none() || self.tl.is_none() {\n             assert!(self.hd.is_none() && self.tl.is_none());\n         }\n@@ -459,35 +457,35 @@ pub impl<T> DList<T> {\n     }\n }\n \n-pub impl<T:Copy> DList<T> {\n+impl<T:Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n-    fn pop(@mut self) -> Option<T> {\n+    pub fn pop(@mut self) -> Option<T> {\n         self.pop_n().map(|nobe| nobe.data)\n     }\n \n     /// Remove data from the tail of the list. O(1).\n-    fn pop_tail(@mut self) -> Option<T> {\n+    pub fn pop_tail(@mut self) -> Option<T> {\n         self.pop_tail_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head. O(1).\n-    fn peek(@mut self) -> Option<T> {\n+    pub fn peek(@mut self) -> Option<T> {\n         self.peek_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n-    fn peek_tail(@mut self) -> Option<T> {\n+    pub fn peek_tail(@mut self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    fn head(@mut self) -> T { self.head_n().data }\n+    pub fn head(@mut self) -> T { self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    fn tail(@mut self) -> T { self.tail_n().data }\n+    pub fn tail(@mut self) -> T { self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n-    fn to_vec(@mut self) -> ~[T] {\n+    pub fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         for old_iter::eachi(&self) |index,data| {\n             v[index] = *data;"}, {"sha": "47b0b4f6c974b5199193e8cf6faa3084b70d3478", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -89,8 +89,8 @@ pub mod reader {\n \n     // ebml reading\n \n-    pub impl Doc {\n-        fn get(&self, tag: uint) -> Doc {\n+    impl Doc {\n+        pub fn get(&self, tag: uint) -> Doc {\n             get_doc(*self, tag)\n         }\n     }\n@@ -286,7 +286,7 @@ pub mod reader {\n         }\n     }\n \n-    priv impl Decoder {\n+    impl Decoder {\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n@@ -343,8 +343,9 @@ pub mod reader {\n         }\n     }\n \n-    pub impl Decoder {\n-        fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R) -> R {\n+    impl Decoder {\n+        pub fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R)\n+                              -> R {\n             let doc = self.next_doc(EsOpaque);\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -638,8 +639,8 @@ pub mod writer {\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    pub impl Encoder {\n-        fn start_tag(&mut self, tag_id: uint) {\n+    impl Encoder {\n+        pub fn start_tag(&mut self, tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n \n             // Write the enum ID:\n@@ -651,7 +652,7 @@ pub mod writer {\n             self.writer.write(zeroes);\n         }\n \n-        fn end_tag(&mut self) {\n+        pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop();\n             let cur_pos = self.writer.tell();\n             self.writer.seek(last_size_pos as int, io::SeekSet);\n@@ -662,72 +663,72 @@ pub mod writer {\n             debug!(\"End tag (size = %u)\", size);\n         }\n \n-        fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n+        pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n         }\n \n-        fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n+        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n             write_vuint(self.writer, b.len());\n             self.writer.write(b);\n         }\n \n-        fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n+        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n             do io::u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n+        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n+        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n+        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n             self.wr_tagged_bytes(tag_id, &[v]);\n         }\n \n-        fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n+        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n             do io::u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n+        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n+        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n+        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n             self.wr_tagged_bytes(tag_id, &[v as u8]);\n         }\n \n-        fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n+        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n             str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n         }\n \n-        fn wr_bytes(&mut self, b: &[u8]) {\n+        pub fn wr_bytes(&mut self, b: &[u8]) {\n             debug!(\"Write %u bytes\", b.len());\n             self.writer.write(b);\n         }\n \n-        fn wr_str(&mut self, s: &str) {\n+        pub fn wr_str(&mut self, s: &str) {\n             debug!(\"Write str: %?\", s);\n             self.writer.write(str::to_bytes(s));\n         }\n@@ -740,7 +741,7 @@ pub mod writer {\n     // Totally lame approach.\n     static debug: bool = true;\n \n-    priv impl Encoder {\n+    impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n             assert!(v <= 0xFFFF_FFFF_u);\n@@ -758,8 +759,8 @@ pub mod writer {\n         }\n     }\n \n-    pub impl Encoder {\n-        fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n+    impl Encoder {\n+        pub fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n             self.start_tag(EsOpaque as uint);\n             f(self);\n             self.end_tag();"}, {"sha": "31218ca9a0a54086fd55f597e0686de58d04e6e0", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -317,17 +317,17 @@ impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n     }\n }\n \n-pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n-    fn new(u: U, p: P) -> FlatPort<T, U, P> {\n+impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n+    pub fn new(u: U, p: P) -> FlatPort<T, U, P> {\n         FlatPort {\n             unflattener: u,\n             byte_port: p\n         }\n     }\n }\n \n-pub impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n-    fn new(f: F, c: C) -> FlatChan<T, F, C> {\n+impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n+    pub fn new(f: F, c: C) -> FlatChan<T, F, C> {\n         FlatChan {\n             flattener: f,\n             byte_chan: c\n@@ -380,16 +380,16 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<T:Copy + Owned> PodUnflattener<T> {\n-        fn new() -> PodUnflattener<T> {\n+    impl<T:Copy + Owned> PodUnflattener<T> {\n+        pub fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n-    pub impl<T:Copy + Owned> PodFlattener<T> {\n-        fn new() -> PodFlattener<T> {\n+    impl<T:Copy + Owned> PodFlattener<T> {\n+        pub fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()\n             }\n@@ -423,17 +423,17 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n-        fn new(deserialize_buffer: DeserializeBuffer<T>)\n+    impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n+        pub fn new(deserialize_buffer: DeserializeBuffer<T>)\n                    -> DeserializingUnflattener<D, T> {\n             DeserializingUnflattener {\n                 deserialize_buffer: deserialize_buffer\n             }\n         }\n     }\n \n-    pub impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n-        fn new(serialize_value: SerializeValue<T>)\n+    impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n+        pub fn new(serialize_value: SerializeValue<T>)\n                    -> SerializingFlattener<S, T> {\n             SerializingFlattener {\n                 serialize_value: serialize_value\n@@ -554,16 +554,16 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl<R:Reader> ReaderBytePort<R> {\n-        fn new(r: R) -> ReaderBytePort<R> {\n+    impl<R:Reader> ReaderBytePort<R> {\n+        pub fn new(r: R) -> ReaderBytePort<R> {\n             ReaderBytePort {\n                 reader: r\n             }\n         }\n     }\n \n-    pub impl<W:Writer> WriterByteChan<W> {\n-        fn new(w: W) -> WriterByteChan<W> {\n+    impl<W:Writer> WriterByteChan<W> {\n+        pub fn new(w: W) -> WriterByteChan<W> {\n             WriterByteChan {\n                 writer: w\n             }\n@@ -619,17 +619,17 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl PipeBytePort {\n-        fn new(p: Port<~[u8]>) -> PipeBytePort {\n+    impl PipeBytePort {\n+        pub fn new(p: Port<~[u8]>) -> PipeBytePort {\n             PipeBytePort {\n                 port: p,\n                 buf: @mut ~[]\n             }\n         }\n     }\n \n-    pub impl PipeByteChan {\n-        fn new(c: Chan<~[u8]>) -> PipeByteChan {\n+    impl PipeByteChan {\n+        pub fn new(c: Chan<~[u8]>) -> PipeByteChan {\n             PipeByteChan {\n                 chan: c\n             }"}, {"sha": "25a3259c69654eaec7e5f65d903f37bb272652f9", "filename": "src/libextra/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -54,15 +54,15 @@ priv enum FutureState<A> {\n }\n \n /// Methods on the `future` type\n-pub impl<A:Copy> Future<A> {\n-    fn get(&mut self) -> A {\n+impl<A:Copy> Future<A> {\n+    pub fn get(&mut self) -> A {\n         //! Get the value of the future.\n         *(self.get_ref())\n     }\n }\n \n-pub impl<A> Future<A> {\n-    fn get_ref<'a>(&'a mut self) -> &'a A {\n+impl<A> Future<A> {\n+    pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as"}, {"sha": "22abe0edbb94eaa018637720e8c5793d9aa4ac33", "filename": "src/libextra/json.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,7 +10,9 @@\n \n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n+\n #[forbid(non_camel_case_types)];\n+#[allow(missing_doc)];\n \n //! json serialization\n \n@@ -497,8 +499,8 @@ pub fn Parser(rdr: @io::Reader) -> Parser {\n     }\n }\n \n-pub impl Parser {\n-    fn parse(&mut self) -> Result<Json, Error> {\n+impl Parser {\n+    pub fn parse(&mut self) -> Result<Json, Error> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -515,7 +517,7 @@ pub impl Parser {\n     }\n }\n \n-priv impl Parser {\n+impl Parser {\n     fn eof(&self) -> bool { self.ch == -1 as char }\n \n     fn bump(&mut self) {"}, {"sha": "960319b9c3f99ab68b347729723a458d4eb977d6", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -826,7 +826,7 @@ pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n }\n \n /// Convenience methods extending `net::tcp::TcpSocket`\n-pub impl TcpSocket {\n+impl TcpSocket {\n     pub fn read_start(&self) -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(self)\n@@ -835,11 +835,11 @@ pub impl TcpSocket {\n         result::Result<(), TcpErrData> {\n         read_stop(self)\n     }\n-    fn read(&self, timeout_msecs: uint) ->\n+    pub fn read(&self, timeout_msecs: uint) ->\n         result::Result<~[u8], TcpErrData> {\n         read(self, timeout_msecs)\n     }\n-    fn read_future(&self, timeout_msecs: uint) ->\n+    pub fn read_future(&self, timeout_msecs: uint) ->\n         future::Future<result::Result<~[u8], TcpErrData>> {\n         read_future(self, timeout_msecs)\n     }"}, {"sha": "58930692965dd6145a9a5323c6aad3c444c1fc62", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -41,16 +41,15 @@ struct UserInfo {\n \n pub type Query = ~[(~str, ~str)];\n \n-pub impl Url {\n-    fn new(\n-        scheme: ~str,\n-        user: Option<UserInfo>,\n-        host: ~str,\n-        port: Option<~str>,\n-        path: ~str,\n-        query: Query,\n-        fragment: Option<~str>\n-    ) -> Url {\n+impl Url {\n+    pub fn new(scheme: ~str,\n+               user: Option<UserInfo>,\n+               host: ~str,\n+               port: Option<~str>,\n+               path: ~str,\n+               query: Query,\n+               fragment: Option<~str>)\n+               -> Url {\n         Url {\n             scheme: scheme,\n             user: user,\n@@ -63,8 +62,8 @@ pub impl Url {\n     }\n }\n \n-pub impl UserInfo {\n-    fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+impl UserInfo {\n+    pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }"}, {"sha": "82f706e8f3f384e77a4aff7fd84fba7b68e76b30", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,6 +16,8 @@ A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n@@ -1095,9 +1097,8 @@ impl FromStrRadix for BigInt {\n     }\n }\n \n-pub impl BigInt {\n+impl BigInt {\n     /// Creates and initializes an BigInt.\n-\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n@@ -1139,8 +1140,7 @@ pub impl BigInt {\n             .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-\n-    fn to_uint(&self) -> uint {\n+    pub fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n             Zero  => 0,"}, {"sha": "b58f90beb3122c8dc3bff2a8028e899969a6770b", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,6 +10,8 @@\n \n //! A priority queue implemented with a binary heap\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::old_iter::BaseIter;\n@@ -44,26 +46,26 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-pub impl <T:Ord> PriorityQueue<T> {\n+impl<T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n+    pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n+    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    pub fn capacity(&self) -> uint { vec::capacity(&self.data) }\n \n-    fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n+    pub fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n \n-    fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve_at_least(&mut self, n: uint) {\n         vec::reserve_at_least(&mut self.data, n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty\n-    fn pop(&mut self) -> T {\n+    pub fn pop(&mut self) -> T {\n         let mut item = self.data.pop();\n         if !self.is_empty() {\n             swap(&mut item, &mut self.data[0]);\n@@ -73,19 +75,19 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Pop the greatest item from the queue - None if empty\n-    fn maybe_pop(&mut self) -> Option<T> {\n+    pub fn maybe_pop(&mut self) -> Option<T> {\n         if self.is_empty() { None } else { Some(self.pop()) }\n     }\n \n     /// Push an item onto the queue\n-    fn push(&mut self, item: T) {\n+    pub fn push(&mut self, item: T) {\n         self.data.push(item);\n         let new_len = self.len() - 1;\n         self.siftup(0, new_len);\n     }\n \n     /// Optimized version of a push followed by a pop\n-    fn push_pop(&mut self, mut item: T) -> T {\n+    pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && self.data[0] > item {\n             swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n@@ -94,18 +96,18 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Optimized version of a pop followed by a push - fails if empty\n-    fn replace(&mut self, mut item: T) -> T {\n+    pub fn replace(&mut self, mut item: T) -> T {\n         swap(&mut item, &mut self.data[0]);\n         self.siftdown(0);\n         item\n     }\n \n     /// Consume the PriorityQueue and return the underlying vector\n-    fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n+    pub fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n     /// (ascending) order\n-    fn to_sorted_vec(self) -> ~[T] {\n+    pub fn to_sorted_vec(self) -> ~[T] {\n         let mut q = self;\n         let mut end = q.len();\n         while end > 1 {\n@@ -117,10 +119,10 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Create an empty PriorityQueue\n-    fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n+    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n \n     /// Create a PriorityQueue from a vector (heapify)\n-    fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n+    pub fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n         let mut q = PriorityQueue{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {\n@@ -135,8 +137,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n     // zeroed element), shift along the others and move it back into the\n     // vector over the junk element.  This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n-\n-    priv fn siftup(&mut self, start: uint, mut pos: uint) {\n+    fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n             let new = replace(&mut self.data[pos], init());\n \n@@ -154,7 +155,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n         }\n     }\n \n-    priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n+    fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n             let new = replace(&mut self.data[pos], init());\n@@ -176,7 +177,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n         }\n     }\n \n-    priv fn siftdown(&mut self, pos: uint) {\n+    fn siftdown(&mut self, pos: uint) {\n         let len = self.len();\n         self.siftdown_range(pos, len);\n     }"}, {"sha": "1ec72f2ea9f6595f0eb830e8ece3ce34893c6cad", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -40,7 +40,7 @@ pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n }\n \n-priv impl<T> Rc<T> {\n+impl<T> Rc<T> {\n     unsafe fn new(value: T) -> Rc<T> {\n         let ptr = malloc(sys::size_of::<RcBox<T>>() as size_t) as *mut RcBox<T>;\n         assert!(!ptr::is_null(ptr));\n@@ -59,9 +59,9 @@ pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n     unsafe { Rc::new(value) }\n }\n \n-pub impl<T> Rc<T> {\n+impl<T> Rc<T> {\n     #[inline(always)]\n-    fn borrow<'r>(&'r self) -> &'r T {\n+    pub fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }\n     }\n }\n@@ -170,7 +170,7 @@ pub struct RcMut<T> {\n     priv ptr: *mut RcMutBox<T>,\n }\n \n-priv impl<T> RcMut<T> {\n+impl<T> RcMut<T> {\n     unsafe fn new(value: T) -> RcMut<T> {\n         let ptr = malloc(sys::size_of::<RcMutBox<T>>() as size_t) as *mut RcMutBox<T>;\n         assert!(!ptr::is_null(ptr));\n@@ -189,10 +189,10 @@ pub fn rc_mut_from_const<T: Const>(value: T) -> RcMut<T> {\n     unsafe { RcMut::new(value) }\n }\n \n-pub impl<T> RcMut<T> {\n+impl<T> RcMut<T> {\n     /// Fails if there is already a mutable borrow of the box\n     #[inline]\n-    fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n+    pub fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n         unsafe {\n             assert!((*self.ptr).borrow != Mutable);\n             let previous = (*self.ptr).borrow;\n@@ -205,7 +205,7 @@ pub impl<T> RcMut<T> {\n \n     /// Fails if there is already a mutable or immutable borrow of the box\n     #[inline]\n-    fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n+    pub fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n         unsafe {\n             assert_eq!((*self.ptr).borrow, Nothing);\n             (*self.ptr).borrow = Mutable;"}, {"sha": "7f566bc16e7321614a2f6930ed6cea5c57ad6b86", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,6 +13,8 @@\n  * are O(highest integer key).\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::cmp;\n@@ -152,12 +154,12 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n }\n \n-pub impl<V> SmallIntMap<V> {\n+impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n-    fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n-    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(i - 1, elt) { return false; },\n@@ -167,22 +169,23 @@ pub impl<V> SmallIntMap<V> {\n         return true;\n     }\n \n-    fn get<'a>(&'a self, key: &uint) -> &'a V {\n+    pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n }\n \n-pub impl<V:Copy> SmallIntMap<V> {\n-    fn update_with_key(&mut self, key: uint, val: V,\n-                       ff: &fn(uint, V, V) -> V) -> bool {\n+impl<V:Copy> SmallIntMap<V> {\n+    pub fn update_with_key(&mut self, key: uint, val: V,\n+                           ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n             Some(orig) => ff(key, *orig, val)\n         };\n         self.insert(key, new_val)\n     }\n \n-    fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V) -> bool {\n+    pub fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V)\n+                  -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n }\n@@ -280,9 +283,9 @@ impl Set<uint> for SmallIntSet {\n     }\n }\n \n-pub impl SmallIntSet {\n+impl SmallIntSet {\n     /// Create an empty SmallIntSet\n-    fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n+    pub fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n }\n \n #[cfg(test)]"}, {"sha": "29a2dec38ab671d9dde15268523786848ffa7824", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -99,8 +99,8 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-pub impl<Q:Owned> Sem<Q> {\n-    fn acquire(&self) {\n+impl<Q:Owned> Sem<Q> {\n+    pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n             do (**self).with |state| {\n@@ -122,7 +122,8 @@ pub impl<Q:Owned> Sem<Q> {\n             }\n         }\n     }\n-    fn release(&self) {\n+\n+    pub fn release(&self) {\n         unsafe {\n             do (**self).with |state| {\n                 state.count += 1;\n@@ -135,8 +136,8 @@ pub impl<Q:Owned> Sem<Q> {\n }\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n-pub impl Sem<()> {\n-    fn access<U>(&self, blk: &fn() -> U) -> U {\n+impl Sem<()> {\n+    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -147,9 +148,10 @@ pub impl Sem<()> {\n         blk()\n     }\n }\n+\n #[doc(hidden)]\n-pub impl Sem<~[Waitqueue]> {\n-    fn access<U>(&self, blk: &fn() -> U) -> U {\n+impl Sem<~[Waitqueue]> {\n+    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -193,7 +195,7 @@ pub struct Condvar<'self> { priv sem: &'self Sem<~[Waitqueue]> }\n #[unsafe_destructor]\n impl<'self> Drop for Condvar<'self> { fn finalize(&self) {} }\n \n-pub impl<'self> Condvar<'self> {\n+impl<'self> Condvar<'self> {\n     /**\n      * Atomically drop the associated lock, and block until a signal is sent.\n      *\n@@ -202,7 +204,7 @@ pub impl<'self> Condvar<'self> {\n      * while waiting on a condition variable will wake up, fail, and unlock\n      * the associated lock as it unwinds.\n      */\n-    fn wait(&self) { self.wait_on(0) }\n+    pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n      * As wait(), but can specify which of multiple condition variables to\n@@ -215,7 +217,7 @@ pub impl<'self> Condvar<'self> {\n      *\n      * wait() is equivalent to wait_on(0).\n      */\n-    fn wait_on(&self, condvar_id: uint) {\n+    pub fn wait_on(&self, condvar_id: uint) {\n         // Create waiter nobe.\n         let (WaitEnd, SignalEnd) = comm::oneshot();\n         let mut WaitEnd   = Some(WaitEnd);\n@@ -284,10 +286,10 @@ pub impl<'self> Condvar<'self> {\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n-    fn signal(&self) -> bool { self.signal_on(0) }\n+    pub fn signal(&self) -> bool { self.signal_on(0) }\n \n     /// As signal, but with a specified condvar_id. See wait_on.\n-    fn signal_on(&self, condvar_id: uint) -> bool {\n+    pub fn signal_on(&self, condvar_id: uint) -> bool {\n         unsafe {\n             let mut out_of_bounds = None;\n             let mut result = false;\n@@ -305,10 +307,10 @@ pub impl<'self> Condvar<'self> {\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n \n     /// As broadcast, but with a specified condvar_id. See wait_on.\n-    fn broadcast_on(&self, condvar_id: uint) -> uint {\n+    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         unsafe {\n@@ -347,9 +349,9 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-pub impl Sem<~[Waitqueue]> {\n+impl Sem<~[Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n-    fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         do self.access { blk(&Condvar { sem: self }) }\n     }\n }\n@@ -373,21 +375,21 @@ impl Clone for Semaphore {\n     }\n }\n \n-pub impl Semaphore {\n+impl Semaphore {\n     /**\n      * Acquire a resource represented by the semaphore. Blocks if necessary\n      * until resource(s) become available.\n      */\n-    fn acquire(&self) { (&self.sem).acquire() }\n+    pub fn acquire(&self) { (&self.sem).acquire() }\n \n     /**\n      * Release a held resource represented by the semaphore. Wakes a blocked\n      * contending task, if any exist. Won't block the caller.\n      */\n-    fn release(&self) { (&self.sem).release() }\n+    pub fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -421,12 +423,12 @@ impl Clone for Mutex {\n     fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n }\n \n-pub impl Mutex {\n+impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -470,9 +472,9 @@ pub fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n                                              read_count: 0 }) }\n }\n \n-pub impl RWlock {\n+impl RWlock {\n     /// Create a new handle to the rwlock.\n-    fn clone(&self) -> RWlock {\n+    pub fn clone(&self) -> RWlock {\n         RWlock { order_lock:  (&(self.order_lock)).clone(),\n                  access_lock: Sem((*self.access_lock).clone()),\n                  state:       self.state.clone() }\n@@ -482,7 +484,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    fn read<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn read<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -513,7 +515,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    fn write<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn write<U>(&self, blk: &fn() -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n@@ -531,7 +533,7 @@ pub impl RWlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         // NB: You might think I should thread the order_lock into the cond\n         // wait call, so that it gets waited on before access_lock gets\n         // reacquired upon being woken up. However, (a) this would be not\n@@ -569,7 +571,7 @@ pub impl RWlock {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -585,9 +587,8 @@ pub impl RWlock {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade<'a>(&self,\n-                     token: RWlockWriteMode<'a>)\n-                  -> RWlockReadMode<'a> {\n+    pub fn downgrade<'a>(&self, token: RWlockWriteMode<'a>)\n+                         -> RWlockReadMode<'a> {\n         if !ptr::ref_eq(self, token.lock) {\n             fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n@@ -703,18 +704,18 @@ pub struct RWlockReadMode<'self> { priv lock: &'self RWlock }\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReadMode<'self> { fn finalize(&self) {} }\n \n-pub impl<'self> RWlockWriteMode<'self> {\n+impl<'self> RWlockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n-    fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         blk(&Condvar { sem: &self.lock.access_lock })\n     }\n }\n \n-pub impl<'self> RWlockReadMode<'self> {\n+impl<'self> RWlockReadMode<'self> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n }\n \n /****************************************************************************"}, {"sha": "b88bbff2a6668fa127ac5d6efdfe91a1dbac8cb7", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -42,16 +42,16 @@ impl<T> Drop for TaskPool<T> {\n     }\n }\n \n-pub impl<T> TaskPool<T> {\n+impl<T> TaskPool<T> {\n     /// Spawns a new task pool with `n_tasks` tasks. If the `sched_mode`\n     /// is None, the tasks run on this scheduler; otherwise, they run on a\n     /// new scheduler with the given mode. The provided `init_fn_factory`\n     /// returns a function which, given the index of the task, should return\n     /// local data to be kept around in that task.\n-    fn new(n_tasks: uint,\n-           opt_sched_mode: Option<SchedMode>,\n-           init_fn_factory: ~fn() -> ~fn(uint) -> T)\n-        -> TaskPool<T> {\n+    pub fn new(n_tasks: uint,\n+               opt_sched_mode: Option<SchedMode>,\n+               init_fn_factory: ~fn() -> ~fn(uint) -> T)\n+               -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = do vec::from_fn(n_tasks) |i| {\n@@ -89,7 +89,7 @@ pub impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    fn execute(&mut self, f: ~fn(&T)) {\n+    pub fn execute(&mut self, f: ~fn(&T)) {\n         self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }"}, {"sha": "16743d27a17cccb66848c06e624192f0242d8859", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -617,8 +617,7 @@ pub mod bench {\n     use test::{BenchHarness, BenchSamples};\n     use time::precise_time_ns;\n \n-    pub impl BenchHarness {\n-\n+    impl BenchHarness {\n         /// Callback for benchmark functions to run in their body.\n         pub fn iter(&mut self, inner:&fn()) {\n             self.ns_start = precise_time_ns();\n@@ -629,23 +628,23 @@ pub mod bench {\n             self.ns_end = precise_time_ns();\n         }\n \n-        fn ns_elapsed(&mut self) -> u64 {\n+        pub fn ns_elapsed(&mut self) -> u64 {\n             if self.ns_start == 0 || self.ns_end == 0 {\n                 0\n             } else {\n                 self.ns_end - self.ns_start\n             }\n         }\n \n-        fn ns_per_iter(&mut self) -> u64 {\n+        pub fn ns_per_iter(&mut self) -> u64 {\n             if self.iterations == 0 {\n                 0\n             } else {\n                 self.ns_elapsed() / self.iterations\n             }\n         }\n \n-        fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+        pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n             self.iterations = n;\n             debug!(\"running benchmark for %u iterations\",\n                    n as uint);"}, {"sha": "758181980a832fef53f11af3cef81c65a1885394", "filename": "src/libextra/time.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -49,8 +49,8 @@ pub struct Timespec { sec: i64, nsec: i32 }\n  * -1.2 seconds before the epoch is represented by `Timespec { sec: -2_i64,\n  * nsec: 800_000_000_i32 }`.\n  */\n-pub impl Timespec {\n-    fn new(sec: i64, nsec: i32) -> Timespec {\n+impl Timespec {\n+    pub fn new(sec: i64, nsec: i32) -> Timespec {\n         assert!(nsec >= 0 && nsec < NSEC_PER_SEC);\n         Timespec { sec: sec, nsec: nsec }\n     }\n@@ -180,9 +180,9 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     do_strftime(format, tm)\n }\n \n-pub impl Tm {\n+impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n-    fn to_timespec(&self) -> Timespec {\n+    pub fn to_timespec(&self) -> Timespec {\n         unsafe {\n             let sec = match self.tm_gmtoff {\n                 0_i32 => rustrt::rust_timegm(self),\n@@ -194,23 +194,23 @@ pub impl Tm {\n     }\n \n     /// Convert time to the local timezone\n-    fn to_local(&self) -> Tm {\n+    pub fn to_local(&self) -> Tm {\n         at(self.to_timespec())\n     }\n \n     /// Convert time to the UTC\n-    fn to_utc(&self) -> Tm {\n+    pub fn to_utc(&self) -> Tm {\n         at_utc(self.to_timespec())\n     }\n \n     /**\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    fn ctime(&self) -> ~str { self.strftime(\"%c\") }\n+    pub fn ctime(&self) -> ~str { self.strftime(\"%c\") }\n \n     /// Formats the time according to the format string.\n-    fn strftime(&self, format: &str) -> ~str {\n+    pub fn strftime(&self, format: &str) -> ~str {\n         strftime(format, self)\n     }\n \n@@ -220,7 +220,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    fn rfc822(&self) -> ~str {\n+    pub fn rfc822(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -234,7 +234,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    fn rfc822z(&self) -> ~str {\n+    pub fn rfc822z(&self) -> ~str {\n         self.strftime(\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -244,7 +244,7 @@ pub impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    fn rfc3339(&self) -> ~str {\n+    pub fn rfc3339(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {"}, {"sha": "c39984791689c893e62ad5f68f6c48a9b1d0ebef", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -181,28 +181,28 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-pub impl<K: TotalOrd, V> TreeMap<K, V> {\n+impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n-    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+    pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all key-value pairs in reverse order\n-    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each_reverse(&self.root, f)\n     }\n \n     /// Visit all keys in reverse order\n-    fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n+    pub fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n+    pub fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+    pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n@@ -489,15 +489,15 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n }\n \n-pub impl <T: TotalOrd> TreeSet<T> {\n+impl<T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline(always)]\n-    fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n-    fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n+    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n }\n@@ -517,9 +517,10 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-pub impl<K: TotalOrd, V> TreeNode<K, V> {\n+impl<K: TotalOrd, V> TreeNode<K, V> {\n+    /// Creates a new tree node.\n     #[inline(always)]\n-    fn new(key: K, value: V) -> TreeNode<K, V> {\n+    pub fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }"}, {"sha": "5d494b1b9165b3a7986d7b707a2af2ec2b7bceab", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -127,9 +127,12 @@ impl cmp::Ord for WorkKey {\n     }\n }\n \n-pub impl WorkKey {\n-    fn new(kind: &str, name: &str) -> WorkKey {\n-    WorkKey { kind: kind.to_owned(), name: name.to_owned() }\n+impl WorkKey {\n+    pub fn new(kind: &str, name: &str) -> WorkKey {\n+        WorkKey {\n+            kind: kind.to_owned(),\n+            name: name.to_owned(),\n+        }\n     }\n }\n \n@@ -167,24 +170,24 @@ struct Database {\n     db_dirty: bool\n }\n \n-pub impl Database {\n-    fn prepare(&mut self,\n-               fn_name: &str,\n-               declared_inputs: &WorkMap)\n-               -> Option<(WorkMap, WorkMap, ~str)> {\n+impl Database {\n+    pub fn prepare(&mut self,\n+                   fn_name: &str,\n+                   declared_inputs: &WorkMap)\n+                   -> Option<(WorkMap, WorkMap, ~str)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n             Some(v) => Some(json_decode(*v))\n         }\n     }\n \n-    fn cache(&mut self,\n-             fn_name: &str,\n-             declared_inputs: &WorkMap,\n-             discovered_inputs: &WorkMap,\n-             discovered_outputs: &WorkMap,\n-             result: &str) {\n+    pub fn cache(&mut self,\n+                 fn_name: &str,\n+                 declared_inputs: &WorkMap,\n+                 discovered_inputs: &WorkMap,\n+                 discovered_outputs: &WorkMap,\n+                 result: &str) {\n         let k = json_encode(&(fn_name, declared_inputs));\n         let v = json_encode(&(discovered_inputs,\n                               discovered_outputs,\n@@ -199,8 +202,8 @@ struct Logger {\n     a: ()\n }\n \n-pub impl Logger {\n-    fn info(&self, i: &str) {\n+impl Logger {\n+    pub fn info(&self, i: &str) {\n         io::println(~\"workcache: \" + i);\n     }\n }\n@@ -257,11 +260,9 @@ fn digest_file(path: &Path) -> ~str {\n     sha.result_str()\n }\n \n-pub impl Context {\n-\n-    fn new(db: @mut Database,\n-                  lg: @mut Logger,\n-                  cfg: @json::Object) -> Context {\n+impl Context {\n+    pub fn new(db: @mut Database, lg: @mut Logger, cfg: @json::Object)\n+               -> Context {\n         Context {\n             db: db,\n             logger: lg,\n@@ -270,12 +271,12 @@ pub impl Context {\n         }\n     }\n \n-    fn prep<T:Owned +\n-              Encodable<json::Encoder> +\n-              Decodable<json::Decoder>>( // FIXME(#5121)\n-                  @self,\n-                  fn_name:&str,\n-                  blk: &fn(@mut Prep)->Work<T>) -> Work<T> {\n+    pub fn prep<T:Owned +\n+                  Encodable<json::Encoder> +\n+                  Decodable<json::Decoder>>(@self, // FIXME(#5121)\n+                                            fn_name:&str,\n+                                            blk: &fn(@mut Prep)->Work<T>)\n+                                            -> Work<T> {\n         let p = @mut Prep {\n             ctxt: self,\n             fn_name: fn_name.to_owned(),\n@@ -363,10 +364,10 @@ impl TPrep for Prep {\n     }\n }\n \n-pub impl<T:Owned +\n-         Encodable<json::Encoder> +\n-         Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n-    fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+impl<T:Owned +\n+       Encodable<json::Encoder> +\n+       Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n+    pub fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n }"}, {"sha": "ab895221de1337939bf7e3db31d43de3d065dcc9", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -188,112 +188,116 @@ pub struct Session_ {\n \n pub type Session = @Session_;\n \n-pub impl Session_ {\n-    fn span_fatal(@self, sp: span, msg: &str) -> ! {\n+impl Session_ {\n+    pub fn span_fatal(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    fn fatal(@self, msg: &str) -> ! {\n+    pub fn fatal(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    fn span_err(@self, sp: span, msg: &str) {\n+    pub fn span_err(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    fn err(@self, msg: &str) {\n+    pub fn err(@self, msg: &str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n-    fn err_count(@self) -> uint {\n+    pub fn err_count(@self) -> uint {\n         self.span_diagnostic.handler().err_count()\n     }\n-    fn has_errors(@self) -> bool {\n+    pub fn has_errors(@self) -> bool {\n         self.span_diagnostic.handler().has_errors()\n     }\n-    fn abort_if_errors(@self) {\n+    pub fn abort_if_errors(@self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    fn span_warn(@self, sp: span, msg: &str) {\n+    pub fn span_warn(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    fn warn(@self, msg: &str) {\n+    pub fn warn(@self, msg: &str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    fn span_note(@self, sp: span, msg: &str) {\n+    pub fn span_note(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    fn note(@self, msg: &str) {\n+    pub fn note(@self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    fn span_bug(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_bug(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    fn bug(@self, msg: &str) -> ! {\n+    pub fn bug(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    fn unimpl(@self, msg: &str) -> ! {\n+    pub fn unimpl(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn add_lint(@self, lint: lint::lint, id: ast::node_id, sp: span, msg: ~str) {\n+    pub fn add_lint(@self,\n+                    lint: lint::lint,\n+                    id: ast::node_id,\n+                    sp: span,\n+                    msg: ~str) {\n         match self.lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n             None => {}\n         }\n         self.lints.insert(id, ~[(lint, sp, msg)]);\n     }\n-    fn next_node_id(@self) -> ast::node_id {\n+    pub fn next_node_id(@self) -> ast::node_id {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n-    fn diagnostic(@self) -> @diagnostic::span_handler {\n+    pub fn diagnostic(@self) -> @diagnostic::span_handler {\n         self.span_diagnostic\n     }\n-    fn debugging_opt(@self, opt: uint) -> bool {\n+    pub fn debugging_opt(@self, opt: uint) -> bool {\n         (self.opts.debugging_opts & opt) != 0u\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    fn impossible_case(@self, sp: span, msg: &str) -> ! {\n+    pub fn impossible_case(@self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n     }\n-    fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n-    fn time_passes(@self) -> bool { self.debugging_opt(time_passes) }\n-    fn count_llvm_insns(@self) -> bool {\n+    pub fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n+    pub fn time_passes(@self) -> bool { self.debugging_opt(time_passes) }\n+    pub fn count_llvm_insns(@self) -> bool {\n         self.debugging_opt(count_llvm_insns)\n     }\n-    fn count_type_sizes(@self) -> bool {\n+    pub fn count_type_sizes(@self) -> bool {\n         self.debugging_opt(count_type_sizes)\n     }\n-    fn time_llvm_passes(@self) -> bool {\n+    pub fn time_llvm_passes(@self) -> bool {\n         self.debugging_opt(time_llvm_passes)\n     }\n-    fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n-    fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n-    fn asm_comments(@self) -> bool { self.debugging_opt(asm_comments) }\n-    fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n-    fn lint_llvm(@self) -> bool { self.debugging_opt(lint_llvm) }\n-    fn trace(@self) -> bool { self.debugging_opt(trace) }\n-    fn coherence(@self) -> bool { self.debugging_opt(coherence) }\n-    fn borrowck_stats(@self) -> bool { self.debugging_opt(borrowck_stats) }\n-    fn borrowck_note_pure(@self) -> bool {\n+    pub fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n+    pub fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n+    pub fn asm_comments(@self) -> bool { self.debugging_opt(asm_comments) }\n+    pub fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n+    pub fn lint_llvm(@self) -> bool { self.debugging_opt(lint_llvm) }\n+    pub fn trace(@self) -> bool { self.debugging_opt(trace) }\n+    pub fn coherence(@self) -> bool { self.debugging_opt(coherence) }\n+    pub fn borrowck_stats(@self) -> bool { self.debugging_opt(borrowck_stats) }\n+    pub fn borrowck_note_pure(@self) -> bool {\n         self.debugging_opt(borrowck_note_pure)\n     }\n-    fn borrowck_note_loan(@self) -> bool {\n+    pub fn borrowck_note_loan(@self) -> bool {\n         self.debugging_opt(borrowck_note_loan)\n     }\n-    fn no_monomorphic_collapse(@self) -> bool {\n+    pub fn no_monomorphic_collapse(@self) -> bool {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n-    fn debug_borrows(@self) -> bool {\n+    pub fn debug_borrows(@self) -> bool {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n \n-    fn str_of(@self, id: ast::ident) -> @~str {\n+    pub fn str_of(@self, id: ast::ident) -> @~str {\n         self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(@self, st: &str) -> ast::ident {\n+    pub fn ident_of(@self, st: &str) -> ast::ident {\n         self.parse_sess.interner.intern(st)\n     }\n-    fn intr(@self) -> @syntax::parse::token::ident_interner {\n+    pub fn intr(@self) -> @syntax::parse::token::ident_interner {\n         self.parse_sess.interner\n     }\n }"}, {"sha": "c26e91cc5ec8406e1f685bb17c578ca92a1a7b3f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -163,8 +163,8 @@ fn reserve_id_range(sess: Session,\n     ast_util::id_range { min: to_id_min, max: to_id_min }\n }\n \n-pub impl ExtendedDecodeContext {\n-    fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n+impl ExtendedDecodeContext {\n+    pub fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n          * to refer to some part of the item currently being inlined,\n@@ -179,7 +179,7 @@ pub impl ExtendedDecodeContext {\n         assert!(!self.from_id_range.empty());\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n-    fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n+    pub fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n          * Translates an EXTERNAL def-id, converting the crate number\n          * from the one used in the encoded data to the current crate\n@@ -203,7 +203,7 @@ pub impl ExtendedDecodeContext {\n \n         decoder::translate_def_id(self.dcx.cdata, did)\n     }\n-    fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n+    pub fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n          * Translates an INTERNAL def-id, meaning a def-id that is\n          * known to refer to some part of the item currently being\n@@ -214,7 +214,7 @@ pub impl ExtendedDecodeContext {\n         assert_eq!(did.crate, ast::local_crate);\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n-    fn tr_span(&self, _span: span) -> span {\n+    pub fn tr_span(&self, _span: span) -> span {\n         codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }"}, {"sha": "5d0def6f60a88bccbb526735721d4d2b4b6699d7", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -69,13 +69,13 @@ enum MoveError {\n     MoveWhileBorrowed(/*move*/@LoanPath, /*loan*/@LoanPath, /*loan*/span)\n }\n \n-pub impl<'self> CheckLoanCtxt<'self> {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+impl<'self> CheckLoanCtxt<'self> {\n+    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn each_issued_loan(&self,\n-                        scope_id: ast::node_id,\n-                        op: &fn(&Loan) -> bool) -> bool\n-    {\n+    pub fn each_issued_loan(&self,\n+                            scope_id: ast::node_id,\n+                            op: &fn(&Loan) -> bool)\n+                            -> bool {\n         //! Iterates over each loan that that has been issued\n         //! on entrance to `scope_id`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n@@ -91,10 +91,10 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    fn each_in_scope_loan(&self,\n-                          scope_id: ast::node_id,\n-                          op: &fn(&Loan) -> bool) -> bool\n-    {\n+    pub fn each_in_scope_loan(&self,\n+                              scope_id: ast::node_id,\n+                              op: &fn(&Loan) -> bool)\n+                              -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n@@ -109,11 +109,11 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    fn each_in_scope_restriction(&self,\n-                                 scope_id: ast::node_id,\n-                                 loan_path: @LoanPath,\n-                                 op: &fn(&Loan, &Restriction) -> bool) -> bool\n-    {\n+    pub fn each_in_scope_restriction(&self,\n+                                     scope_id: ast::node_id,\n+                                     loan_path: @LoanPath,\n+                                     op: &fn(&Loan, &Restriction) -> bool)\n+                                     -> bool {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`\n \n@@ -129,7 +129,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n+    pub fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n@@ -140,7 +140,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return result;\n     }\n \n-    fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n+    pub fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n         //! Checks to see whether any of the loans that are issued\n         //! by `scope_id` conflict with loans that have already been\n         //! issued when we enter `scope_id` (for example, we do not\n@@ -167,9 +167,9 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn report_error_if_loans_conflict(&self,\n-                                      old_loan: &Loan,\n-                                      new_loan: &Loan) {\n+    pub fn report_error_if_loans_conflict(&self,\n+                                          old_loan: &Loan,\n+                                          new_loan: &Loan) {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n@@ -188,11 +188,12 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             new_loan, old_loan, old_loan, new_loan);\n     }\n \n-    fn report_error_if_loan_conflicts_with_restriction(&self,\n-                                                       loan1: &Loan,\n-                                                       loan2: &Loan,\n-                                                       old_loan: &Loan,\n-                                                       new_loan: &Loan) -> bool {\n+    pub fn report_error_if_loan_conflicts_with_restriction(&self,\n+                                                           loan1: &Loan,\n+                                                           loan2: &Loan,\n+                                                           old_loan: &Loan,\n+                                                           new_loan: &Loan)\n+                                                           -> bool {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n@@ -247,18 +248,18 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         true\n     }\n \n-    fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n+    pub fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n           mc::cat_local(_) => true,\n           _ => false\n         }\n     }\n \n-    fn check_if_path_is_moved(&self,\n-                              id: ast::node_id,\n-                              span: span,\n-                              use_kind: MovedValueUseKind,\n-                              lp: @LoanPath) {\n+    pub fn check_if_path_is_moved(&self,\n+                                  id: ast::node_id,\n+                                  span: span,\n+                                  use_kind: MovedValueUseKind,\n+                                  lp: @LoanPath) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -277,7 +278,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn check_assignment(&self, expr: @ast::expr) {\n+    pub fn check_assignment(&self, expr: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n         let cmt = match self.bccx.tcx.adjustments.find(&expr.id) {\n@@ -533,10 +534,10 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn report_illegal_mutation(&self,\n-                               expr: @ast::expr,\n-                               loan_path: &LoanPath,\n-                               loan: &Loan) {\n+    pub fn report_illegal_mutation(&self,\n+                                   expr: @ast::expr,\n+                                   loan_path: &LoanPath,\n+                                   loan: &Loan) {\n         self.bccx.span_err(\n             expr.span,\n             fmt!(\"cannot assign to `%s` because it is borrowed\",\n@@ -547,7 +548,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n-    fn check_move_out_from_expr(&self, ex: @ast::expr) {\n+    pub fn check_move_out_from_expr(&self, ex: @ast::expr) {\n         match ex.node {\n             ast::expr_paren(*) => {\n                 /* In the case of an expr_paren(), the expression inside\n@@ -574,7 +575,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n+    pub fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n         debug!(\"analyze_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n@@ -590,13 +591,12 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return MoveOk;\n     }\n \n-    fn check_call(&mut self,\n-                  _expr: @ast::expr,\n-                  _callee: Option<@ast::expr>,\n-                  _callee_id: ast::node_id,\n-                  _callee_span: span,\n-                  _args: &[@ast::expr])\n-    {\n+    pub fn check_call(&mut self,\n+                      _expr: @ast::expr,\n+                      _callee: Option<@ast::expr>,\n+                      _callee_id: ast::node_id,\n+                      _callee_span: span,\n+                      _args: &[@ast::expr]) {\n         // NB: This call to check for conflicting loans is not truly\n         // necessary, because the callee_id never issues new loans.\n         // However, I added it for consistency and lest the system"}, {"sha": "83d039b75200f4014513583d677b0d1162183167", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -273,21 +273,21 @@ fn gather_loans_in_expr(ex: @ast::expr,\n     }\n }\n \n-pub impl GatherLoanCtxt {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+impl GatherLoanCtxt {\n+    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn push_repeating_id(&mut self, id: ast::node_id) {\n+    pub fn push_repeating_id(&mut self, id: ast::node_id) {\n         self.repeating_ids.push(id);\n     }\n \n-    fn pop_repeating_id(&mut self, id: ast::node_id) {\n+    pub fn pop_repeating_id(&mut self, id: ast::node_id) {\n         let popped = self.repeating_ids.pop();\n         assert_eq!(id, popped);\n     }\n \n-    fn guarantee_adjustments(&mut self,\n-                             expr: @ast::expr,\n-                             adjustment: &ty::AutoAdjustment) {\n+    pub fn guarantee_adjustments(&mut self,\n+                                 expr: @ast::expr,\n+                                 adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n                expr.repr(self.tcx()), adjustment);\n         let _i = indenter();\n@@ -350,13 +350,12 @@ pub impl GatherLoanCtxt {\n     // out loans, which will be added to the `req_loan_map`.  This can\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n-    fn guarantee_valid(&mut self,\n-                       borrow_id: ast::node_id,\n-                       borrow_span: span,\n-                       cmt: mc::cmt,\n-                       req_mutbl: ast::mutability,\n-                       loan_region: ty::Region)\n-    {\n+    pub fn guarantee_valid(&mut self,\n+                           borrow_id: ast::node_id,\n+                           borrow_span: span,\n+                           cmt: mc::cmt,\n+                           req_mutbl: ast::mutability,\n+                           loan_region: ty::Region) {\n         debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n                 req_mutbl=%?, loan_region=%?)\",\n                borrow_id,\n@@ -514,15 +513,16 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn restriction_set(&self, req_mutbl: ast::mutability) -> RestrictionSet {\n+    pub fn restriction_set(&self, req_mutbl: ast::mutability)\n+                           -> RestrictionSet {\n         match req_mutbl {\n             m_const => RESTR_EMPTY,\n             m_imm   => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n             m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n         }\n     }\n \n-    fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n+    pub fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n@@ -540,9 +540,10 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn compute_gen_scope(&self,\n-                         borrow_id: ast::node_id,\n-                         loan_scope: ast::node_id) -> ast::node_id {\n+    pub fn compute_gen_scope(&self,\n+                             borrow_id: ast::node_id,\n+                             loan_scope: ast::node_id)\n+                             -> ast::node_id {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n@@ -556,9 +557,8 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn compute_kill_scope(&self,\n-                          loan_scope: ast::node_id,\n-                          lp: @LoanPath) -> ast::node_id {\n+    pub fn compute_kill_scope(&self, loan_scope: ast::node_id, lp: @LoanPath)\n+                              -> ast::node_id {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,\n@@ -588,11 +588,11 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn gather_pat(&mut self,\n-                  discr_cmt: mc::cmt,\n-                  root_pat: @ast::pat,\n-                  arm_body_id: ast::node_id,\n-                  match_id: ast::node_id) {\n+    pub fn gather_pat(&mut self,\n+                      discr_cmt: mc::cmt,\n+                      root_pat: @ast::pat,\n+                      arm_body_id: ast::node_id,\n+                      match_id: ast::node_id) {\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n@@ -653,9 +653,8 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn vec_slice_info(&self,\n-                      pat: @ast::pat,\n-                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n+    pub fn vec_slice_info(&self, pat: @ast::pat, slice_ty: ty::t)\n+                          -> (ast::mutability, ty::Region) {\n         /*!\n          *\n          * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -681,11 +680,11 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+    pub fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n     }\n \n-    fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n+    pub fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }\n }"}, {"sha": "0834d0360832ae965c867ad0e0d840b02e09f8b2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -248,8 +248,8 @@ pub enum LoanPathElem {\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n-pub impl LoanPath {\n-    fn node_id(&self) -> ast::node_id {\n+impl LoanPath {\n+    pub fn node_id(&self) -> ast::node_id {\n         match *self {\n             LpVar(local_id) => local_id,\n             LpExtend(base, _, _) => base.node_id()\n@@ -327,12 +327,12 @@ pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b1000};\n \n-pub impl RestrictionSet {\n-    fn intersects(&self, restr: RestrictionSet) -> bool {\n+impl RestrictionSet {\n+    pub fn intersects(&self, restr: RestrictionSet) -> bool {\n         (self.bits & restr.bits) != 0\n     }\n \n-    fn contains_all(&self, restr: RestrictionSet) -> bool {\n+    pub fn contains_all(&self, restr: RestrictionSet) -> bool {\n         (self.bits & restr.bits) == restr.bits\n     }\n }\n@@ -427,29 +427,33 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-pub impl BorrowckCtxt {\n-    fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+impl BorrowckCtxt {\n+    pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n+                           -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id) -> bool {\n+    pub fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id)\n+                          -> bool {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    fn is_move(&self, id: ast::node_id) -> bool {\n+    pub fn is_move(&self, id: ast::node_id) -> bool {\n         self.moves_map.contains(&id)\n     }\n \n-    fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n+    pub fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n         mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n         mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_autoderefd(&self, expr: @ast::expr,\n-                           adj: @ty::AutoAdjustment) -> mc::cmt {\n+    pub fn cat_expr_autoderefd(&self,\n+                               expr: @ast::expr,\n+                               adj: @ty::AutoAdjustment)\n+                               -> mc::cmt {\n         match *adj {\n             ty::AutoAddEnv(*) => {\n                 // no autoderefs\n@@ -465,46 +469,47 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn cat_def(&self,\n-               id: ast::node_id,\n-               span: span,\n-               ty: ty::t,\n-               def: ast::def) -> mc::cmt {\n+    pub fn cat_def(&self,\n+                   id: ast::node_id,\n+                   span: span,\n+                   ty: ty::t,\n+                   def: ast::def)\n+                   -> mc::cmt {\n         mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n+    pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n         @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n                    mutbl:cmt.mutbl.inherit(),\n                    ..*cmt}\n     }\n \n-    fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n+    pub fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n         mc::mem_categorization_ctxt {tcx: self.tcx,\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(&self,\n-                   cmt: mc::cmt,\n-                   pat: @ast::pat,\n-                   op: &fn(mc::cmt, @ast::pat)) {\n+    pub fn cat_pattern(&self,\n+                       cmt: mc::cmt,\n+                       pat: @ast::pat,\n+                       op: &fn(mc::cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n \n-    fn report(&self, err: BckError) {\n+    pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,\n             self.bckerr_to_str(err));\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn report_use_of_moved_value(&self,\n-                                 use_span: span,\n-                                 use_kind: MovedValueUseKind,\n-                                 lp: @LoanPath,\n-                                 move: &move_data::Move,\n-                                 moved_lp: @LoanPath) {\n+    pub fn report_use_of_moved_value(&self,\n+                                     use_span: span,\n+                                     use_kind: MovedValueUseKind,\n+                                     lp: @LoanPath,\n+                                     move: &move_data::Move,\n+                                     moved_lp: @LoanPath) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -563,10 +568,11 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn report_reassigned_immutable_variable(&self,\n-                                            span: span,\n-                                            lp: @LoanPath,\n-                                            assign: &move_data::Assignment) {\n+    pub fn report_reassigned_immutable_variable(&self,\n+                                                span: span,\n+                                                lp: @LoanPath,\n+                                                assign:\n+                                                &move_data::Assignment) {\n         self.tcx.sess.span_err(\n             span,\n             fmt!(\"re-assignment of immutable variable `%s`\",\n@@ -576,15 +582,15 @@ pub impl BorrowckCtxt {\n             fmt!(\"prior assignment occurs here\"));\n     }\n \n-    fn span_err(&self, s: span, m: &str) {\n+    pub fn span_err(&self, s: span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(&self, s: span, m: &str) {\n+    pub fn span_note(&self, s: span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }\n \n-    fn bckerr_to_str(&self, err: BckError) -> ~str {\n+    pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {\n                 fmt!(\"cannot borrow %s %s as %s\",\n@@ -608,10 +614,10 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn report_aliasability_violation(&self,\n-                                     span: span,\n-                                     kind: AliasableViolationKind,\n-                                     cause: mc::AliasableReason) {\n+    pub fn report_aliasability_violation(&self,\n+                                         span: span,\n+                                         kind: AliasableViolationKind,\n+                                         cause: mc::AliasableReason) {\n         let prefix = match kind {\n             MutabilityViolation => \"cannot assign to an `&mut`\",\n             BorrowViolation => \"cannot borrow an `&mut`\"\n@@ -649,7 +655,7 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn note_and_explain_bckerr(&self, err: BckError) {\n+    pub fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n             err_mutbl(*) | err_freeze_aliasable_const(*) => {}\n@@ -682,9 +688,9 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn append_loan_path_to_str_from_interior(&self,\n-                                             loan_path: &LoanPath,\n-                                             out: &mut ~str) {\n+    pub fn append_loan_path_to_str_from_interior(&self,\n+                                                 loan_path: &LoanPath,\n+                                                 out: &mut ~str) {\n         match *loan_path {\n             LpExtend(_, _, LpDeref) => {\n                 str::push_char(out, '(');\n@@ -698,7 +704,9 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn append_loan_path_to_str(&self, loan_path: &LoanPath, out: &mut ~str) {\n+    pub fn append_loan_path_to_str(&self,\n+                                   loan_path: &LoanPath,\n+                                   out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n@@ -739,25 +747,25 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n+    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n         let mut result = ~\"\";\n         self.append_loan_path_to_str(loan_path, &mut result);\n         result\n     }\n \n-    fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n         let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n                                                method_map: self.method_map};\n         mc.cmt_to_str(cmt)\n     }\n \n-    fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n+    pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n                                                method_map: self.method_map};\n         mc.mut_to_str(mutbl)\n     }\n \n-    fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n+    pub fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n         match mutbl {\n             ast::m_imm => \"\",\n             ast::m_const => \"const\","}, {"sha": "798cba236297b60a762be0d9f9dda31dc3d87843", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -82,14 +82,14 @@ pub struct LanguageItems {\n     items: [Option<def_id>, ..38]\n }\n \n-pub impl LanguageItems {\n+impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n             items: [ None, ..38 ]\n         }\n     }\n \n-    fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n+    pub fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n         self.items.eachi(|i, &item| f(item.get(), i))\n     }\n \n@@ -331,9 +331,10 @@ struct LanguageItemCollector {\n     item_refs: HashMap<@~str, uint>,\n }\n \n-pub impl LanguageItemCollector {\n-    fn match_and_collect_meta_item(&mut self, item_def_id: def_id,\n-                                   meta_item: @meta_item) {\n+impl LanguageItemCollector {\n+    pub fn match_and_collect_meta_item(&mut self,\n+                                       item_def_id: def_id,\n+                                       meta_item: @meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n                 match literal.node {\n@@ -347,7 +348,7 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n+    pub fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -363,8 +364,10 @@ pub impl LanguageItemCollector {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    fn match_and_collect_item(&mut self,\n-                              item_def_id: def_id, key: @~str, value: @~str) {\n+    pub fn match_and_collect_item(&mut self,\n+                                  item_def_id: def_id,\n+                                  key: @~str,\n+                                  value: @~str) {\n         if *key != ~\"lang\" {\n             return;    // Didn't match.\n         }\n@@ -384,7 +387,7 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect_local_language_items(&mut self) {\n+    pub fn collect_local_language_items(&mut self) {\n         let this: *mut LanguageItemCollector = &mut *self;\n         visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n@@ -401,7 +404,7 @@ pub impl LanguageItemCollector {\n         }));\n     }\n \n-    fn collect_external_language_items(&mut self) {\n+    pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_lang_item(crate_store, crate_number)\n@@ -412,7 +415,7 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn check_completeness(&self) {\n+    pub fn check_completeness(&self) {\n         for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n@@ -425,7 +428,7 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect(&mut self) {\n+    pub fn collect(&mut self) {\n         self.collect_local_language_items();\n         self.collect_external_language_items();\n         self.check_completeness();"}, {"sha": "a9d9d55563a61c6bc679a4c12eefab9abb64464e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 131, "deletions": 104, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -197,8 +197,10 @@ impl to_str::ToStr for Variable {\n // variable must not be assigned if there is some successor\n // assignment.  And so forth.\n \n-pub impl LiveNode {\n-    fn is_valid(&self) -> bool { **self != uint::max_value }\n+impl LiveNode {\n+    pub fn is_valid(&self) -> bool {\n+        **self != uint::max_value\n+    }\n }\n \n fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n@@ -260,8 +262,8 @@ fn IrMaps(tcx: ty::ctxt,\n     }\n }\n \n-pub impl IrMaps {\n-    fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n+impl IrMaps {\n+    pub fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n         let ln = LiveNode(self.num_live_nodes);\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n@@ -272,16 +274,16 @@ pub impl IrMaps {\n         ln\n     }\n \n-    fn add_live_node_for_node(&mut self,\n-                              node_id: node_id,\n-                              lnk: LiveNodeKind) {\n+    pub fn add_live_node_for_node(&mut self,\n+                                  node_id: node_id,\n+                                  lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n         debug!(\"%s is node %d\", ln.to_str(), node_id);\n     }\n \n-    fn add_variable(&mut self, vk: VarKind) -> Variable {\n+    pub fn add_variable(&mut self, vk: VarKind) -> Variable {\n         let v = Variable(self.num_vars);\n         self.var_kinds.push(vk);\n         self.num_vars += 1;\n@@ -298,7 +300,7 @@ pub impl IrMaps {\n         v\n     }\n \n-    fn variable(&mut self, node_id: node_id, span: span) -> Variable {\n+    pub fn variable(&mut self, node_id: node_id, span: span) -> Variable {\n         match self.variable_map.find(&node_id) {\n           Some(&var) => var,\n           None => {\n@@ -308,7 +310,7 @@ pub impl IrMaps {\n         }\n     }\n \n-    fn variable_name(&mut self, var: Variable) -> @~str {\n+    pub fn variable_name(&mut self, var: Variable) -> @~str {\n         match self.var_kinds[*var] {\n             Local(LocalInfo { ident: nm, _ }) | Arg(_, nm) => {\n                 self.tcx.sess.str_of(nm)\n@@ -317,11 +319,11 @@ pub impl IrMaps {\n         }\n     }\n \n-    fn set_captures(&mut self, node_id: node_id, cs: ~[CaptureInfo]) {\n+    pub fn set_captures(&mut self, node_id: node_id, cs: ~[CaptureInfo]) {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n-    fn captures(&mut self, expr: @expr) -> @~[CaptureInfo] {\n+    pub fn captures(&mut self, expr: @expr) -> @~[CaptureInfo] {\n         match self.capture_info_map.find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n@@ -330,7 +332,7 @@ pub impl IrMaps {\n         }\n     }\n \n-    fn lnk(&mut self, ln: LiveNode) -> LiveNodeKind {\n+    pub fn lnk(&mut self, ln: LiveNode) -> LiveNodeKind {\n         self.lnks[*ln]\n     }\n }\n@@ -578,8 +580,8 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n     }\n }\n \n-pub impl Liveness {\n-    fn live_node(&self, node_id: node_id, span: span) -> LiveNode {\n+impl Liveness {\n+    pub fn live_node(&self, node_id: node_id, span: span) -> LiveNode {\n         let ir: &mut IrMaps = self.ir;\n         match ir.live_node_map.find(&node_id) {\n           Some(&ln) => ln,\n@@ -595,7 +597,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n+    pub fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n@@ -607,12 +609,12 @@ pub impl Liveness {\n         }\n     }\n \n-    fn variable(&self, node_id: node_id, span: span) -> Variable {\n+    pub fn variable(&self, node_id: node_id, span: span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    fn variable_from_def_map(&self, node_id: node_id,\n-                             span: span) -> Option<Variable> {\n+    pub fn variable_from_def_map(&self, node_id: node_id, span: span)\n+                                 -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n             moves::moved_variable_node_id_from_def(def).map(\n@@ -626,8 +628,9 @@ pub impl Liveness {\n         }\n     }\n \n-    fn pat_bindings(&self, pat: @pat,\n-                    f: &fn(LiveNode, Variable, span, node_id)) {\n+    pub fn pat_bindings(&self,\n+                        pat: @pat,\n+                        f: &fn(LiveNode, Variable, span, node_id)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -636,9 +639,9 @@ pub impl Liveness {\n         }\n     }\n \n-    fn arm_pats_bindings(&self,\n-                         pats: &[@pat],\n-                         f: &fn(LiveNode, Variable, span, node_id)) {\n+    pub fn arm_pats_bindings(&self,\n+                             pats: &[@pat],\n+                             f: &fn(LiveNode, Variable, span, node_id)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -647,12 +650,13 @@ pub impl Liveness {\n         }\n     }\n \n-    fn define_bindings_in_pat(&self, pat: @pat, succ: LiveNode) -> LiveNode {\n+    pub fn define_bindings_in_pat(&self, pat: @pat, succ: LiveNode)\n+                                  -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&self, pats: &[@pat],\n-                                   succ: LiveNode) -> LiveNode {\n+    pub fn define_bindings_in_arm_pats(&self, pats: &[@pat], succ: LiveNode)\n+                                       -> LiveNode {\n         let mut succ = succ;\n         do self.arm_pats_bindings(pats) |ln, var, _sp, _id| {\n             self.init_from_succ(ln, succ);\n@@ -662,13 +666,12 @@ pub impl Liveness {\n         succ\n     }\n \n-    fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n+    pub fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n         *ln * self.ir.num_vars + *var\n     }\n \n-    fn live_on_entry(&self, ln: LiveNode, var: Variable)\n-        -> Option<LiveNodeKind> {\n-\n+    pub fn live_on_entry(&self, ln: LiveNode, var: Variable)\n+                         -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n@@ -677,50 +680,50 @@ pub impl Liveness {\n     /*\n     Is this variable live on entry to any of its successor nodes?\n     */\n-    fn live_on_exit(&self, ln: LiveNode, var: Variable)\n-        -> Option<LiveNodeKind> {\n-\n+    pub fn live_on_exit(&self, ln: LiveNode, var: Variable)\n+                        -> Option<LiveNodeKind> {\n         self.live_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n+    pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n         self.users[self.idx(ln, var)].used\n     }\n \n-    fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n-        -> Option<LiveNodeKind> {\n-\n+    pub fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n+                             -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n-    fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n-        -> Option<LiveNodeKind> {\n-\n+    pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n+                            -> Option<LiveNodeKind> {\n         self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n+    pub fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n         }\n     }\n \n-    fn indices2(&self, ln: LiveNode, succ_ln: LiveNode, op: &fn(uint, uint)) {\n+    pub fn indices2(&self,\n+                    ln: LiveNode,\n+                    succ_ln: LiveNode,\n+                    op: &fn(uint, uint)) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for uint::range(0u, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n \n-    fn write_vars(&self,\n-                  wr: @io::Writer,\n-                  ln: LiveNode,\n-                  test: &fn(uint) -> LiveNode) {\n+    pub fn write_vars(&self,\n+                      wr: @io::Writer,\n+                      ln: LiveNode,\n+                      test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n@@ -731,8 +734,11 @@ pub impl Liveness {\n         }\n     }\n \n-    fn find_loop_scope(&self, opt_label: Option<ident>, id: node_id, sp: span)\n-        -> node_id {\n+    pub fn find_loop_scope(&self,\n+                           opt_label: Option<ident>,\n+                           id: node_id,\n+                           sp: span)\n+                           -> node_id {\n         match opt_label {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n                       // to find with one\n@@ -758,12 +764,12 @@ pub impl Liveness {\n         }\n     }\n \n-    fn last_loop_scope(&self) -> node_id {\n+    pub fn last_loop_scope(&self) -> node_id {\n         let loop_scope = &mut *self.loop_scope;\n         *loop_scope.last()\n     }\n \n-    fn ln_str(&self, ln: LiveNode) -> ~str {\n+    pub fn ln_str(&self, ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n@@ -780,7 +786,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n+    pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[*ln] = succ_ln;\n \n         // It is not necessary to initialize the\n@@ -793,7 +799,7 @@ pub impl Liveness {\n         // }\n     }\n \n-    fn init_from_succ(&self, ln: LiveNode, succ_ln: LiveNode) {\n+    pub fn init_from_succ(&self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[*ln] = succ_ln;\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n@@ -803,8 +809,11 @@ pub impl Liveness {\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n-    fn merge_from_succ(&self, ln: LiveNode, succ_ln: LiveNode,\n-                       first_merge: bool) -> bool {\n+    pub fn merge_from_succ(&self,\n+                           ln: LiveNode,\n+                           succ_ln: LiveNode,\n+                           first_merge: bool)\n+                           -> bool {\n         if ln == succ_ln { return false; }\n \n         let mut changed = false;\n@@ -838,7 +847,7 @@ pub impl Liveness {\n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n-    fn define(&self, writer: LiveNode, var: Variable) {\n+    pub fn define(&self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n@@ -848,7 +857,7 @@ pub impl Liveness {\n     }\n \n     // Either read, write, or both depending on the acc bitset\n-    fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n+    pub fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n         let users = &mut *self.users;\n         let user = &mut users[idx];\n@@ -874,7 +883,7 @@ pub impl Liveness {\n \n     // _______________________________________________________________________\n \n-    fn compute(&self, decl: &fn_decl, body: &blk) -> LiveNode {\n+    pub fn compute(&self, decl: &fn_decl, body: &blk) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -899,8 +908,8 @@ pub impl Liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&self, _: &fn_decl, blk: &blk)\n-                                  -> LiveNode {\n+    pub fn propagate_through_fn_block(&self, _: &fn_decl, blk: &blk)\n+                                      -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -911,15 +920,16 @@ pub impl Liveness {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(&self, blk: &blk, succ: LiveNode) -> LiveNode {\n+    pub fn propagate_through_block(&self, blk: &blk, succ: LiveNode)\n+                                   -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n         do blk.node.stmts.foldr(succ) |stmt, succ| {\n             self.propagate_through_stmt(*stmt, succ)\n         }\n     }\n \n-    fn propagate_through_stmt(&self, stmt: @stmt, succ: LiveNode)\n-                             -> LiveNode {\n+    pub fn propagate_through_stmt(&self, stmt: @stmt, succ: LiveNode)\n+                                  -> LiveNode {\n         match stmt.node {\n           stmt_decl(decl, _) => {\n             return self.propagate_through_decl(decl, succ);\n@@ -935,8 +945,8 @@ pub impl Liveness {\n         }\n     }\n \n-    fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n-                             -> LiveNode {\n+    pub fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n+                                  -> LiveNode {\n         match decl.node {\n           decl_local(ref locals) => {\n             do locals.foldr(succ) |local, succ| {\n@@ -949,8 +959,8 @@ pub impl Liveness {\n         }\n     }\n \n-    fn propagate_through_local(&self, local: @local, succ: LiveNode)\n-                              -> LiveNode {\n+    pub fn propagate_through_local(&self, local: @local, succ: LiveNode)\n+                                   -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n         // the live variable as defined if it was initialized, and then we\n@@ -969,22 +979,24 @@ pub impl Liveness {\n         self.define_bindings_in_pat(local.node.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&self, exprs: &[@expr],\n-                               succ: LiveNode) -> LiveNode {\n+    pub fn propagate_through_exprs(&self, exprs: &[@expr], succ: LiveNode)\n+                                   -> LiveNode {\n         do exprs.foldr(succ) |expr, succ| {\n             self.propagate_through_expr(*expr, succ)\n         }\n     }\n \n-    fn propagate_through_opt_expr(&self, opt_expr: Option<@expr>,\n-                                  succ: LiveNode) -> LiveNode {\n+    pub fn propagate_through_opt_expr(&self,\n+                                      opt_expr: Option<@expr>,\n+                                      succ: LiveNode)\n+                                      -> LiveNode {\n         do old_iter::foldl(&opt_expr, succ) |succ, expr| {\n             self.propagate_through_expr(*expr, *succ)\n         }\n     }\n \n-    fn propagate_through_expr(&self, expr: @expr, succ: LiveNode)\n-                             -> LiveNode {\n+    pub fn propagate_through_expr(&self, expr: @expr, succ: LiveNode)\n+                                  -> LiveNode {\n         debug!(\"propagate_through_expr: %s\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -1230,8 +1242,10 @@ pub impl Liveness {\n         }\n     }\n \n-    fn propagate_through_lvalue_components(&self, expr: @expr,\n-                                           succ: LiveNode) -> LiveNode {\n+    pub fn propagate_through_lvalue_components(&self,\n+                                               expr: @expr,\n+                                               succ: LiveNode)\n+                                               -> LiveNode {\n         // # Lvalues\n         //\n         // In general, the full flow graph structure for an\n@@ -1289,9 +1303,8 @@ pub impl Liveness {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    fn write_lvalue(&self, expr: @expr,\n-                    succ: LiveNode,\n-                    acc: uint) -> LiveNode {\n+    pub fn write_lvalue(&self, expr: @expr, succ: LiveNode, acc: uint)\n+                        -> LiveNode {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n \n@@ -1303,8 +1316,8 @@ pub impl Liveness {\n         }\n     }\n \n-    fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n-                  -> LiveNode {\n+    pub fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n+                       -> LiveNode {\n         let def = self.tcx.def_map.get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n@@ -1320,10 +1333,12 @@ pub impl Liveness {\n         }\n     }\n \n-    fn propagate_through_loop(&self, expr: @expr,\n-                              cond: Option<@expr>,\n-                              body: &blk,\n-                              succ: LiveNode) -> LiveNode {\n+    pub fn propagate_through_loop(&self,\n+                                  expr: @expr,\n+                                  cond: Option<@expr>,\n+                                  body: &blk,\n+                                  succ: LiveNode)\n+                                  -> LiveNode {\n \n         /*\n \n@@ -1377,10 +1392,12 @@ pub impl Liveness {\n         cond_ln\n     }\n \n-    fn with_loop_nodes<R>(&self, loop_node_id: node_id,\n-                          break_ln: LiveNode,\n-                          cont_ln: LiveNode,\n-                          f: &fn() -> R) -> R {\n+    pub fn with_loop_nodes<R>(&self,\n+                              loop_node_id: node_id,\n+                              break_ln: LiveNode,\n+                              cont_ln: LiveNode,\n+                              f: &fn() -> R)\n+                              -> R {\n       debug!(\"with_loop_nodes: %d %u\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);\n@@ -1491,9 +1508,12 @@ enum ReadKind {\n     PartiallyMovedValue\n }\n \n-pub impl Liveness {\n-    fn check_ret(&self, id: node_id, sp: span, _fk: &visit::fn_kind,\n-                 entry_ln: LiveNode) {\n+impl Liveness {\n+    pub fn check_ret(&self,\n+                     id: node_id,\n+                     sp: span,\n+                     _fk: &visit::fn_kind,\n+                     entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n             // function without any kind of return expression:\n@@ -1512,7 +1532,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n+    pub fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n@@ -1546,11 +1566,11 @@ pub impl Liveness {\n        }\n     }\n \n-    fn report_illegal_read(&self,\n-                           chk_span: span,\n-                           lnk: LiveNodeKind,\n-                           var: Variable,\n-                           rk: ReadKind) {\n+    pub fn report_illegal_read(&self,\n+                               chk_span: span,\n+                               lnk: LiveNodeKind,\n+                               var: Variable,\n+                               rk: ReadKind) {\n         let msg = match rk {\n             PossiblyUninitializedVariable => \"possibly uninitialized \\\n                                               variable\",\n@@ -1578,12 +1598,12 @@ pub impl Liveness {\n         }\n     }\n \n-    fn should_warn(&self, var: Variable) -> Option<@~str> {\n+    pub fn should_warn(&self, var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n+    pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n@@ -1593,16 +1613,20 @@ pub impl Liveness {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n+    pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp, id| {\n             if !self.warn_about_unused(sp, id, ln, var) {\n                 self.warn_about_dead_assign(sp, id, ln, var);\n             }\n         }\n     }\n \n-    fn warn_about_unused(&self, sp: span, id: node_id,\n-                         ln: LiveNode, var: Variable) -> bool {\n+    pub fn warn_about_unused(&self,\n+                             sp: span,\n+                             id: node_id,\n+                             ln: LiveNode,\n+                             var: Variable)\n+                             -> bool {\n         if !self.used_on_entry(ln, var) {\n             for self.should_warn(var).each |name| {\n \n@@ -1629,8 +1653,11 @@ pub impl Liveness {\n         return false;\n     }\n \n-    fn warn_about_dead_assign(&self, sp: span, id: node_id,\n-                              ln: LiveNode, var: Variable) {\n+    pub fn warn_about_dead_assign(&self,\n+                                  sp: span,\n+                                  id: node_id,\n+                                  ln: LiveNode,\n+                                  var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,"}, {"sha": "194ea9ac32d6fd30956bbc1ce3404bbc816e098c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 73, "deletions": 70, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -290,16 +290,16 @@ impl ToStr for MutabilityCategory {\n     }\n }\n \n-pub impl MutabilityCategory {\n-    fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n+impl MutabilityCategory {\n+    pub fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n         match m {\n             m_imm => McImmutable,\n             m_const => McReadOnly,\n             m_mutbl => McDeclared\n         }\n     }\n \n-    fn inherit(&self) -> MutabilityCategory {\n+    pub fn inherit(&self) -> MutabilityCategory {\n         match *self {\n             McImmutable => McImmutable,\n             McReadOnly => McReadOnly,\n@@ -308,21 +308,21 @@ pub impl MutabilityCategory {\n         }\n     }\n \n-    fn is_mutable(&self) -> bool {\n+    pub fn is_mutable(&self) -> bool {\n         match *self {\n             McImmutable | McReadOnly => false,\n             McDeclared | McInherited => true\n         }\n     }\n \n-    fn is_immutable(&self) -> bool {\n+    pub fn is_immutable(&self) -> bool {\n         match *self {\n             McImmutable => true,\n             McReadOnly | McDeclared | McInherited => false\n         }\n     }\n \n-    fn to_user_str(&self) -> &'static str {\n+    pub fn to_user_str(&self) -> &'static str {\n         match *self {\n             McDeclared | McInherited => \"mutable\",\n             McImmutable => \"immutable\",\n@@ -331,16 +331,16 @@ pub impl MutabilityCategory {\n     }\n }\n \n-pub impl mem_categorization_ctxt {\n-    fn expr_ty(&self, expr: @ast::expr) -> ty::t {\n+impl mem_categorization_ctxt {\n+    pub fn expr_ty(&self, expr: @ast::expr) -> ty::t {\n         ty::expr_ty(self.tcx, expr)\n     }\n \n-    fn pat_ty(&self, pat: @ast::pat) -> ty::t {\n+    pub fn pat_ty(&self, pat: @ast::pat) -> ty::t {\n         ty::node_id_to_type(self.tcx, pat.id)\n     }\n \n-    fn cat_expr(&self, expr: @ast::expr) -> cmt {\n+    pub fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -374,17 +374,16 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_expr_autoderefd(&self,\n-                           expr: @ast::expr,\n-                           autoderefs: uint) -> cmt {\n+    pub fn cat_expr_autoderefd(&self, expr: @ast::expr, autoderefs: uint)\n+                               -> cmt {\n         let mut cmt = self.cat_expr_unadjusted(expr);\n         for uint::range(1, autoderefs+1) |deref| {\n             cmt = self.cat_deref(expr, cmt, deref);\n         }\n         return cmt;\n     }\n \n-    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n         debug!(\"cat_expr: id=%d expr=%s\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -440,11 +439,12 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_def(&self,\n-               id: ast::node_id,\n-               span: span,\n-               expr_ty: ty::t,\n-               def: ast::def) -> cmt {\n+    pub fn cat_def(&self,\n+                   id: ast::node_id,\n+                   span: span,\n+                   expr_ty: ty::t,\n+                   def: ast::def)\n+                   -> cmt {\n         match def {\n           ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n@@ -557,7 +557,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n+    pub fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:elt.id(),\n             span:elt.span(),\n@@ -571,22 +571,23 @@ pub impl mem_categorization_ctxt {\n     /// component is inherited from the base it is a part of. For\n     /// example, a record field is mutable if it is declared mutable\n     /// or if the container is mutable.\n-    fn inherited_mutability(&self,\n-                            base_m: MutabilityCategory,\n-                            interior_m: ast::mutability) -> MutabilityCategory\n-    {\n+    pub fn inherited_mutability(&self,\n+                                base_m: MutabilityCategory,\n+                                interior_m: ast::mutability)\n+                                -> MutabilityCategory {\n         match interior_m {\n             m_imm => base_m.inherit(),\n             m_const => McReadOnly,\n             m_mutbl => McDeclared\n         }\n     }\n \n-    fn cat_field<N:ast_node>(&self,\n-                             node: N,\n-                             base_cmt: cmt,\n-                             f_name: ast::ident,\n-                             f_ty: ty::t) -> cmt {\n+    pub fn cat_field<N:ast_node>(&self,\n+                                 node: N,\n+                                 base_cmt: cmt,\n+                                 f_name: ast::ident,\n+                                 f_ty: ty::t)\n+                                 -> cmt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -596,11 +597,11 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_deref_fn<N:ast_node>(&self,\n-                                node: N,\n-                                base_cmt: cmt,\n-                                deref_cnt: uint) -> cmt\n-    {\n+    pub fn cat_deref_fn<N:ast_node>(&self,\n+                                    node: N,\n+                                    base_cmt: cmt,\n+                                    deref_cnt: uint)\n+                                    -> cmt {\n         // Bit of a hack: the \"dereference\" of a function pointer like\n         // `@fn()` is a mere logical concept. We interpret it as\n         // dereferencing the environment pointer; of course, we don't\n@@ -612,11 +613,11 @@ pub impl mem_categorization_ctxt {\n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n     }\n \n-    fn cat_deref<N:ast_node>(&self,\n-                             node: N,\n-                             base_cmt: cmt,\n-                             deref_cnt: uint) -> cmt\n-    {\n+    pub fn cat_deref<N:ast_node>(&self,\n+                                 node: N,\n+                                 base_cmt: cmt,\n+                                 deref_cnt: uint)\n+                                 -> cmt {\n         let mt = match ty::deref(self.tcx, base_cmt.ty, true) {\n             Some(mt) => mt,\n             None => {\n@@ -630,12 +631,12 @@ pub impl mem_categorization_ctxt {\n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n     }\n \n-    fn cat_deref_common<N:ast_node>(&self,\n-                                    node: N,\n-                                    base_cmt: cmt,\n-                                    deref_cnt: uint,\n-                                    mt: ty::mt) -> cmt\n-    {\n+    pub fn cat_deref_common<N:ast_node>(&self,\n+                                        node: N,\n+                                        base_cmt: cmt,\n+                                        deref_cnt: uint,\n+                                        mt: ty::mt)\n+                                        -> cmt {\n         match deref_kind(self.tcx, base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n@@ -671,10 +672,11 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_index<N:ast_node>(&self,\n-                             elt: N,\n-                             base_cmt: cmt,\n-                             derefs: uint) -> cmt {\n+    pub fn cat_index<N:ast_node>(&self,\n+                                 elt: N,\n+                                 base_cmt: cmt,\n+                                 derefs: uint)\n+                                 -> cmt {\n         //! Creates a cmt for an indexing operation (`[]`); this\n         //! indexing operation may occurs as part of an\n         //! AutoBorrowVec, which when converting a `~[]` to an `&[]`\n@@ -764,11 +766,12 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_imm_interior<N:ast_node>(&self,\n-                                    node: N,\n-                                    base_cmt: cmt,\n-                                    interior_ty: ty::t,\n-                                    interior: InteriorKind) -> cmt {\n+    pub fn cat_imm_interior<N:ast_node>(&self,\n+                                        node: N,\n+                                        base_cmt: cmt,\n+                                        interior_ty: ty::t,\n+                                        interior: InteriorKind)\n+                                        -> cmt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -778,10 +781,11 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_downcast<N:ast_node>(&self,\n-                                node: N,\n-                                base_cmt: cmt,\n-                                downcast_ty: ty::t) -> cmt {\n+    pub fn cat_downcast<N:ast_node>(&self,\n+                                    node: N,\n+                                    base_cmt: cmt,\n+                                    downcast_ty: ty::t)\n+                                    -> cmt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -791,11 +795,10 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_pattern(&self,\n-                   cmt: cmt,\n-                   pat: @ast::pat,\n-                   op: &fn(cmt, @ast::pat))\n-    {\n+    pub fn cat_pattern(&self,\n+                       cmt: cmt,\n+                       pat: @ast::pat,\n+                       op: &fn(cmt, @ast::pat)) {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -961,15 +964,15 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n+    pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         match mutbl {\n           m_mutbl => ~\"mutable\",\n           m_const => ~\"const\",\n           m_imm => ~\"immutable\"\n         }\n     }\n \n-    fn cmt_to_str(&self, cmt: cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: cmt) -> ~str {\n         match cmt.cat {\n           cat_static_item => {\n               ~\"static item\"\n@@ -1022,7 +1025,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn region_to_str(&self, r: ty::Region) -> ~str {\n+    pub fn region_to_str(&self, r: ty::Region) -> ~str {\n         region_to_str(self.tcx, r)\n     }\n }\n@@ -1068,8 +1071,8 @@ pub enum AliasableReason {\n     AliasableOther\n }\n \n-pub impl cmt_ {\n-    fn guarantor(@self) -> cmt {\n+impl cmt_ {\n+    pub fn guarantor(@self) -> cmt {\n         //! Returns `self` after stripping away any owned pointer derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1097,11 +1100,11 @@ pub impl cmt_ {\n         }\n     }\n \n-    fn is_freely_aliasable(&self) -> bool {\n+    pub fn is_freely_aliasable(&self) -> bool {\n         self.freely_aliasable().is_some()\n     }\n \n-    fn freely_aliasable(&self) -> Option<AliasableReason> {\n+    pub fn freely_aliasable(&self) -> Option<AliasableReason> {\n         //! True if this lvalue resides in an area that is\n         //! freely aliasable, meaning that rustc cannot track\n         //! the alias//es with precision."}, {"sha": "2e7ceba33663d38e55d92d3723ea02537407fe53", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -230,20 +230,14 @@ fn compute_modes_for_expr(expr: @expr,\n     cx.consume_expr(expr, v);\n }\n \n-pub impl VisitContext {\n-    fn consume_exprs(&self,\n-                     exprs: &[@expr],\n-                     visitor: vt<VisitContext>)\n-    {\n+impl VisitContext {\n+    pub fn consume_exprs(&self, exprs: &[@expr], visitor: vt<VisitContext>) {\n         for exprs.each |expr| {\n             self.consume_expr(*expr, visitor);\n         }\n     }\n \n-    fn consume_expr(&self,\n-                    expr: @expr,\n-                    visitor: vt<VisitContext>)\n-    {\n+    pub fn consume_expr(&self, expr: @expr, visitor: vt<VisitContext>) {\n         /*!\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -261,10 +255,7 @@ pub impl VisitContext {\n         };\n     }\n \n-    fn consume_block(&self,\n-                     blk: &blk,\n-                     visitor: vt<VisitContext>)\n-    {\n+    pub fn consume_block(&self, blk: &blk, visitor: vt<VisitContext>) {\n         /*!\n          * Indicates that the value of `blk` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -281,11 +272,10 @@ pub impl VisitContext {\n         }\n     }\n \n-    fn use_expr(&self,\n-                expr: @expr,\n-                expr_mode: UseMode,\n-                visitor: vt<VisitContext>)\n-    {\n+    pub fn use_expr(&self,\n+                    expr: @expr,\n+                    expr_mode: UseMode,\n+                    visitor: vt<VisitContext>) {\n         /*!\n          * Indicates that `expr` is used with a given mode.  This will\n          * in turn trigger calls to the subcomponents of `expr`.\n@@ -529,12 +519,12 @@ pub impl VisitContext {\n         }\n     }\n \n-    fn use_overloaded_operator(&self,\n-                               expr: @expr,\n-                               receiver_expr: @expr,\n-                               arg_exprs: &[@expr],\n-                               visitor: vt<VisitContext>) -> bool\n-    {\n+    pub fn use_overloaded_operator(&self,\n+                                   expr: @expr,\n+                                   receiver_expr: @expr,\n+                                   arg_exprs: &[@expr],\n+                                   visitor: vt<VisitContext>)\n+                                   -> bool {\n         if !self.method_map.contains_key(&expr.id) {\n             return false;\n         }\n@@ -550,10 +540,7 @@ pub impl VisitContext {\n         return true;\n     }\n \n-    fn consume_arm(&self,\n-                   arm: &arm,\n-                   visitor: vt<VisitContext>)\n-    {\n+    pub fn consume_arm(&self, arm: &arm, visitor: vt<VisitContext>) {\n         for arm.pats.each |pat| {\n             self.use_pat(*pat);\n         }\n@@ -565,9 +552,7 @@ pub impl VisitContext {\n         self.consume_block(&arm.body, visitor);\n     }\n \n-    fn use_pat(&self,\n-               pat: @pat)\n-    {\n+    pub fn use_pat(&self, pat: @pat) {\n         /*!\n          *\n          * Decides whether each binding in a pattern moves the value\n@@ -594,32 +579,31 @@ pub impl VisitContext {\n         }\n     }\n \n-    fn use_receiver(&self,\n-                    receiver_expr: @expr,\n-                    visitor: vt<VisitContext>)\n-    {\n+    pub fn use_receiver(&self,\n+                        receiver_expr: @expr,\n+                        visitor: vt<VisitContext>) {\n         self.use_fn_arg(receiver_expr, visitor);\n     }\n \n-    fn use_fn_args(&self,\n-                   _: node_id,\n-                   arg_exprs: &[@expr],\n-                   visitor: vt<VisitContext>) {\n+    pub fn use_fn_args(&self,\n+                       _: node_id,\n+                       arg_exprs: &[@expr],\n+                       visitor: vt<VisitContext>) {\n         //! Uses the argument expressions.\n         for arg_exprs.each |arg_expr| {\n             self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n \n-    fn use_fn_arg(&self, arg_expr: @expr, visitor: vt<VisitContext>) {\n+    pub fn use_fn_arg(&self, arg_expr: @expr, visitor: vt<VisitContext>) {\n         //! Uses the argument.\n         self.consume_expr(arg_expr, visitor)\n     }\n \n-    fn arms_have_by_move_bindings(&self,\n-                                  moves_map: MovesMap,\n-                                  arms: &[arm]) -> Option<@pat>\n-    {\n+    pub fn arms_have_by_move_bindings(&self,\n+                                      moves_map: MovesMap,\n+                                      arms: &[arm])\n+                                      -> Option<@pat> {\n         for arms.each |arm| {\n             for arm.pats.each |&pat| {\n                 for ast_util::walk_pat(pat) |p| {\n@@ -632,7 +616,7 @@ pub impl VisitContext {\n         return None;\n     }\n \n-    fn compute_captures(&self, fn_expr_id: node_id) -> @[CaptureVar] {\n+    pub fn compute_captures(&self, fn_expr_id: node_id) -> @[CaptureVar] {\n         debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n         let _indenter = indenter();\n "}, {"sha": "0f00e9d596e179cfc4584513500f9b2d4cb5363a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -200,7 +200,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         f = |item_id| {\n             match tcx.items.find(&item_id) {\n                 Some(&node_item(item, _)) => item.vis != public,\n-                Some(&node_foreign_item(_, _, vis, _)) => vis != public,\n+                Some(&node_foreign_item(*)) => false,\n                 Some(&node_method(method, impl_did, _)) => {\n                     match method.vis {\n                         private => true,"}, {"sha": "ce229092323307996f67be05b0ed8a1a60070481", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 38, "deletions": 56, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -73,11 +73,8 @@ pub struct Context {\n     parent: parent,\n }\n \n-pub impl RegionMaps {\n-    fn relate_free_regions(&mut self,\n-                           sub: FreeRegion,\n-                           sup: FreeRegion)\n-    {\n+impl RegionMaps {\n+    pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n         match self.free_region_map.find_mut(&sub) {\n             Some(sups) => {\n                 if !sups.contains(&sup) {\n@@ -93,19 +90,14 @@ pub impl RegionMaps {\n         self.free_region_map.insert(sub, ~[sup]);\n     }\n \n-    fn record_parent(&mut self,\n-                     sub: ast::node_id,\n-                     sup: ast::node_id)\n-    {\n+    pub fn record_parent(&mut self, sub: ast::node_id, sup: ast::node_id) {\n         debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n         assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n     }\n \n-    pub fn record_cleanup_scope(&mut self,\n-                                scope_id: ast::node_id)\n-    {\n+    pub fn record_cleanup_scope(&mut self, scope_id: ast::node_id) {\n         //! Records that a scope is a CLEANUP SCOPE.  This is invoked\n         //! from within regionck.  We wait until regionck because we do\n         //! not know which operators are overloaded until that point,\n@@ -114,17 +106,13 @@ pub impl RegionMaps {\n         self.cleanup_scopes.insert(scope_id);\n     }\n \n-    fn opt_encl_scope(&self,\n-                      id: ast::node_id) -> Option<ast::node_id>\n-    {\n+    pub fn opt_encl_scope(&self, id: ast::node_id) -> Option<ast::node_id> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n         self.scope_map.find(&id).map(|&x| *x)\n     }\n \n-    fn encl_scope(&self,\n-                  id: ast::node_id) -> ast::node_id\n-    {\n+    pub fn encl_scope(&self, id: ast::node_id) -> ast::node_id {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n         match self.scope_map.find(&id) {\n@@ -133,13 +121,11 @@ pub impl RegionMaps {\n         }\n     }\n \n-    fn is_cleanup_scope(&self, scope_id: ast::node_id) -> bool {\n+    pub fn is_cleanup_scope(&self, scope_id: ast::node_id) -> bool {\n         self.cleanup_scopes.contains(&scope_id)\n     }\n \n-    fn cleanup_scope(&self,\n-                     expr_id: ast::node_id) -> ast::node_id\n-    {\n+    pub fn cleanup_scope(&self, expr_id: ast::node_id) -> ast::node_id {\n         //! Returns the scope when temps in expr will be cleaned up\n \n         let mut id = self.encl_scope(expr_id);\n@@ -149,25 +135,22 @@ pub impl RegionMaps {\n         return id;\n     }\n \n-    fn encl_region(&self,\n-                   id: ast::node_id) -> ty::Region\n-    {\n+    pub fn encl_region(&self, id: ast::node_id) -> ty::Region {\n         //! Returns the narrowest scope region that encloses `id`, if any.\n \n         ty::re_scope(self.encl_scope(id))\n     }\n \n-    pub fn scopes_intersect(&self,\n-                            scope1: ast::node_id,\n-                            scope2: ast::node_id) -> bool\n-    {\n-        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n+    pub fn scopes_intersect(&self, scope1: ast::node_id, scope2: ast::node_id)\n+                            -> bool {\n+        self.is_subscope_of(scope1, scope2) ||\n+        self.is_subscope_of(scope2, scope1)\n     }\n \n-    fn is_subscope_of(&self,\n-                      subscope: ast::node_id,\n-                      superscope: ast::node_id) -> bool\n-    {\n+    pub fn is_subscope_of(&self,\n+                          subscope: ast::node_id,\n+                          superscope: ast::node_id)\n+                          -> bool {\n         /*!\n          * Returns true if `subscope` is equal to or is lexically\n          * nested inside `superscope` and false otherwise.\n@@ -192,10 +175,7 @@ pub impl RegionMaps {\n         return true;\n     }\n \n-    fn sub_free_region(&self,\n-                       sub: FreeRegion,\n-                       sup: FreeRegion) -> bool\n-    {\n+    pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n         /*!\n          * Determines whether two free regions have a subregion relationship\n          * by walking the graph encoded in `free_region_map`.  Note that\n@@ -233,10 +213,10 @@ pub impl RegionMaps {\n         return false;\n     }\n \n-    fn is_subregion_of(&self,\n-                       sub_region: ty::Region,\n-                       super_region: ty::Region) -> bool\n-    {\n+    pub fn is_subregion_of(&self,\n+                           sub_region: ty::Region,\n+                           super_region: ty::Region)\n+                           -> bool {\n         /*!\n          * Determines whether one region is a subregion of another.  This is\n          * intended to run *after inference* and sadly the logic is somewhat\n@@ -271,10 +251,10 @@ pub impl RegionMaps {\n         }\n     }\n \n-    fn nearest_common_ancestor(&self,\n-                               scope_a: ast::node_id,\n-                               scope_b: ast::node_id) -> Option<ast::node_id>\n-    {\n+    pub fn nearest_common_ancestor(&self,\n+                                   scope_a: ast::node_id,\n+                                   scope_b: ast::node_id)\n+                                   -> Option<ast::node_id> {\n         /*!\n          * Finds the nearest common ancestor (if any) of two scopes.  That\n          * is, finds the smallest scope which is greater than or equal to\n@@ -588,15 +568,15 @@ pub fn add_variance(ambient_variance: region_variance,\n     }\n }\n \n-pub impl DetermineRpCtxt {\n-    fn add_variance(&self, variance: region_variance) -> region_variance {\n+impl DetermineRpCtxt {\n+    pub fn add_variance(&self, variance: region_variance) -> region_variance {\n         add_variance(self.ambient_variance, variance)\n     }\n \n     /// Records that item `id` is region-parameterized with the\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n-    fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n+    pub fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n         assert!(id != 0);\n         let old_variance = self.region_paramd_items.find(&id).\n                                 map_consume(|x| *x);\n@@ -622,7 +602,7 @@ pub impl DetermineRpCtxt {\n     /// `from`.  Put another way, it indicates that the current item\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n-    fn add_dep(&mut self, from: ast::node_id) {\n+    pub fn add_dep(&mut self, from: ast::node_id) {\n         debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n@@ -682,7 +662,7 @@ pub impl DetermineRpCtxt {\n     // with &self type, &self is also bound.  We detect those last two\n     // cases via flags (anon_implies_rp and self_implies_rp) that are\n     // true when the anon or self region implies RP.\n-    fn region_is_relevant(&self, r: Option<@ast::Lifetime>) -> bool {\n+    pub fn region_is_relevant(&self, r: Option<@ast::Lifetime>) -> bool {\n         match r {\n             None => {\n                 self.anon_implies_rp\n@@ -699,10 +679,10 @@ pub impl DetermineRpCtxt {\n         }\n     }\n \n-    fn with(@mut self,\n-            item_id: ast::node_id,\n-            anon_implies_rp: bool,\n-            f: &fn()) {\n+    pub fn with(@mut self,\n+                item_id: ast::node_id,\n+                anon_implies_rp: bool,\n+                f: &fn()) {\n         let old_item_id = self.item_id;\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n@@ -716,7 +696,9 @@ pub impl DetermineRpCtxt {\n         self.anon_implies_rp = old_anon_implies_rp;\n     }\n \n-    fn with_ambient_variance(@mut self, variance: region_variance, f: &fn()) {\n+    pub fn with_ambient_variance(@mut self,\n+                                 variance: region_variance,\n+                                 f: &fn()) {\n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.add_variance(variance);\n         f();"}, {"sha": "b8faa0740b8ba27a5a56d282d1ea6e3d6c206ab3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 329, "deletions": 327, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -117,8 +117,8 @@ pub enum NamespaceResult {\n     BoundResult(@mut Module, @mut NameBindings)\n }\n \n-pub impl NamespaceResult {\n-    fn is_unknown(&self) -> bool {\n+impl NamespaceResult {\n+    pub fn is_unknown(&self) -> bool {\n         match *self {\n             UnknownResult => true,\n             _ => false\n@@ -162,11 +162,11 @@ pub enum ResolveResult<T> {\n     Success(T)      // Successfully resolved the import.\n }\n \n-pub impl<T> ResolveResult<T> {\n-    fn failed(&self) -> bool {\n+impl<T> ResolveResult<T> {\n+    pub fn failed(&self) -> bool {\n         match *self { Failed => true, _ => false }\n     }\n-    fn indeterminate(&self) -> bool {\n+    pub fn indeterminate(&self) -> bool {\n         match *self { Indeterminate => true, _ => false }\n     }\n }\n@@ -390,8 +390,9 @@ pub fn ImportResolution(privacy: Privacy,\n     }\n }\n \n-pub impl ImportResolution {\n-    fn target_for_namespace(&self, namespace: Namespace) -> Option<Target> {\n+impl ImportResolution {\n+    pub fn target_for_namespace(&self, namespace: Namespace)\n+                                -> Option<Target> {\n         match namespace {\n             TypeNS      => return copy self.type_target,\n             ValueNS     => return copy self.value_target\n@@ -472,8 +473,8 @@ pub fn Module(parent_link: ParentLink,\n     }\n }\n \n-pub impl Module {\n-    fn all_imports_resolved(&self) -> bool {\n+impl Module {\n+    pub fn all_imports_resolved(&self) -> bool {\n         let imports = &mut *self.imports;\n         return imports.len() == self.resolved_import_count;\n     }\n@@ -501,14 +502,14 @@ pub struct NameBindings {\n     value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n }\n \n-pub impl NameBindings {\n+impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n-    fn define_module(@mut self,\n-                     privacy: Privacy,\n-                     parent_link: ParentLink,\n-                     def_id: Option<def_id>,\n-                     kind: ModuleKind,\n-                     sp: span) {\n+    pub fn define_module(@mut self,\n+                         privacy: Privacy,\n+                         parent_link: ParentLink,\n+                         def_id: Option<def_id>,\n+                         kind: ModuleKind,\n+                         sp: span) {\n         // Merges the module with the existing type def or creates a new one.\n         let module_ = @mut Module(parent_link, def_id, kind);\n         match self.type_def {\n@@ -532,12 +533,12 @@ pub impl NameBindings {\n     }\n \n     /// Sets the kind of the module, creating a new one if necessary.\n-    fn set_module_kind(@mut self,\n-                       privacy: Privacy,\n-                       parent_link: ParentLink,\n-                       def_id: Option<def_id>,\n-                       kind: ModuleKind,\n-                       _sp: span) {\n+    pub fn set_module_kind(@mut self,\n+                           privacy: Privacy,\n+                           parent_link: ParentLink,\n+                           def_id: Option<def_id>,\n+                           kind: ModuleKind,\n+                           _sp: span) {\n         match self.type_def {\n             None => {\n                 let module = @mut Module(parent_link, def_id, kind);\n@@ -566,7 +567,7 @@ pub impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    fn define_type(@mut self, privacy: Privacy, def: def, sp: span) {\n+    pub fn define_type(@mut self, privacy: Privacy, def: def, sp: span) {\n         // Merges the type with the existing type def or creates a new one.\n         match self.type_def {\n             None => {\n@@ -589,12 +590,12 @@ pub impl NameBindings {\n     }\n \n     /// Records a value definition.\n-    fn define_value(@mut self, privacy: Privacy, def: def, sp: span) {\n+    pub fn define_value(@mut self, privacy: Privacy, def: def, sp: span) {\n         self.value_def = Some(ValueNsDef { privacy: privacy, def: def, value_span: Some(sp) });\n     }\n \n     /// Returns the module node if applicable.\n-    fn get_module_if_available(&self) -> Option<@mut Module> {\n+    pub fn get_module_if_available(&self) -> Option<@mut Module> {\n         match self.type_def {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n@@ -605,7 +606,7 @@ pub impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    fn get_module(@mut self) -> @mut Module {\n+    pub fn get_module(@mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n                 fail!(\"get_module called on a node with no module \\\n@@ -615,14 +616,14 @@ pub impl NameBindings {\n         }\n     }\n \n-    fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n+    pub fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n             TypeNS   => return self.type_def.is_some(),\n             ValueNS  => return self.value_def.is_some()\n         }\n     }\n \n-    fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n+    pub fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n             TypeNS => match self.type_def {\n                 Some(def) => def.privacy != Private,\n@@ -635,7 +636,7 @@ pub impl NameBindings {\n         }\n     }\n \n-    fn def_for_namespace(&self, namespace: Namespace) -> Option<def> {\n+    pub fn def_for_namespace(&self, namespace: Namespace) -> Option<def> {\n         match namespace {\n             TypeNS => {\n                 match self.type_def {\n@@ -669,7 +670,8 @@ pub impl NameBindings {\n         }\n     }\n \n-    fn privacy_for_namespace(&self, namespace: Namespace) -> Option<Privacy> {\n+    pub fn privacy_for_namespace(&self, namespace: Namespace)\n+                                 -> Option<Privacy> {\n         match namespace {\n             TypeNS => {\n                 match self.type_def {\n@@ -686,7 +688,7 @@ pub impl NameBindings {\n         }\n     }\n \n-    fn span_for_namespace(&self, namespace: Namespace) -> Option<span> {\n+    pub fn span_for_namespace(&self, namespace: Namespace) -> Option<span> {\n         if self.defined_in_namespace(namespace) {\n             match namespace {\n                 TypeNS  => {\n@@ -720,9 +722,11 @@ pub struct PrimitiveTypeTable {\n     primitive_types: HashMap<ident,prim_ty>,\n }\n \n-pub impl PrimitiveTypeTable {\n-    fn intern(&mut self, intr: @ident_interner, string: &str,\n-              primitive_type: prim_ty) {\n+impl PrimitiveTypeTable {\n+    pub fn intern(&mut self,\n+                  intr: @ident_interner,\n+                  string: &str,\n+                  primitive_type: prim_ty) {\n         let ident = intr.intern(string);\n         self.primitive_types.insert(ident, primitive_type);\n     }\n@@ -871,9 +875,9 @@ pub struct Resolver {\n     used_imports: HashSet<node_id>,\n }\n \n-pub impl Resolver {\n+impl Resolver {\n     /// The main name resolution procedure.\n-    fn resolve(@mut self) {\n+    pub fn resolve(@mut self) {\n         self.build_reduced_graph();\n         self.session.abort_if_errors();\n \n@@ -897,7 +901,7 @@ pub impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(@mut self) {\n+    pub fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n         visit_crate(self.crate, initial_parent, mk_vt(@Visitor {\n@@ -924,9 +928,9 @@ pub impl Resolver {\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n-    fn get_module_from_parent(@mut self,\n-                              reduced_graph_parent: ReducedGraphParent)\n-                           -> @mut Module {\n+    pub fn get_module_from_parent(@mut self,\n+                                  reduced_graph_parent: ReducedGraphParent)\n+                                  -> @mut Module {\n         match reduced_graph_parent {\n             ModuleReducedGraphParent(module_) => {\n                 return module_;\n@@ -944,14 +948,13 @@ pub impl Resolver {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    fn add_child(@mut self,\n-                 name: ident,\n-                 reduced_graph_parent: ReducedGraphParent,\n-                 duplicate_checking_mode: DuplicateCheckingMode,\n-                 // For printing errors\n-                 sp: span)\n-              -> (@mut NameBindings, ReducedGraphParent) {\n-\n+    pub fn add_child(@mut self,\n+                     name: ident,\n+                     reduced_graph_parent: ReducedGraphParent,\n+                     duplicate_checking_mode: DuplicateCheckingMode,\n+                     // For printing errors\n+                     sp: span)\n+                     -> (@mut NameBindings, ReducedGraphParent) {\n         // If this is the immediate descendant of a module, then we add the\n         // child name directly. Otherwise, we create or reuse an anonymous\n         // module and add the child to that.\n@@ -1038,7 +1041,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn block_needs_anonymous_module(@mut self, block: &blk) -> bool {\n+    pub fn block_needs_anonymous_module(@mut self, block: &blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.node.view_items.len() > 0 {\n             return true;\n@@ -1069,10 +1072,8 @@ pub impl Resolver {\n         return false;\n     }\n \n-    fn get_parent_link(@mut self,\n-                       parent: ReducedGraphParent,\n-                       name: ident)\n-                    -> ParentLink {\n+    pub fn get_parent_link(@mut self, parent: ReducedGraphParent, name: ident)\n+                           -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_, name);\n@@ -1081,10 +1082,10 @@ pub impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(@mut self,\n-                                    item: @item,\n-                                    parent: ReducedGraphParent,\n-                                    visitor: vt<ReducedGraphParent>) {\n+    pub fn build_reduced_graph_for_item(@mut self,\n+                                        item: @item,\n+                                        parent: ReducedGraphParent,\n+                                        visitor: vt<ReducedGraphParent>) {\n         let ident = item.ident;\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n@@ -1365,12 +1366,12 @@ pub impl Resolver {\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n-    fn build_reduced_graph_for_variant(@mut self,\n-                                       variant: &variant,\n-                                       item_id: def_id,\n-                                       parent_privacy: Privacy,\n-                                       parent: ReducedGraphParent,\n-                                       _visitor: vt<ReducedGraphParent>) {\n+    pub fn build_reduced_graph_for_variant(@mut self,\n+                                           variant: &variant,\n+                                           item_id: def_id,\n+                                           parent_privacy: Privacy,\n+                                           parent: ReducedGraphParent,\n+                                           _visitor: vt<ReducedGraphParent>) {\n         let ident = variant.node.name;\n         let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n@@ -1401,10 +1402,10 @@ pub impl Resolver {\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n     /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(@mut self,\n-                                         view_item: @view_item,\n-                                         parent: ReducedGraphParent,\n-                                         _visitor: vt<ReducedGraphParent>) {\n+    pub fn build_reduced_graph_for_view_item(@mut self,\n+                                             view_item: @view_item,\n+                                             parent: ReducedGraphParent,\n+                                             _: vt<ReducedGraphParent>) {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n@@ -1497,10 +1498,10 @@ pub impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(@mut self,\n-                                            foreign_item: @foreign_item,\n-                                            parent: ReducedGraphParent,\n-                                            visitor:\n+    pub fn build_reduced_graph_for_foreign_item(@mut self,\n+                                                foreign_item: @foreign_item,\n+                                                parent: ReducedGraphParent,\n+                                                visitor:\n                                                 vt<ReducedGraphParent>) {\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n@@ -1528,10 +1529,10 @@ pub impl Resolver {\n         }\n     }\n \n-    fn build_reduced_graph_for_block(@mut self,\n-                                     block: &blk,\n-                                     parent: ReducedGraphParent,\n-                                     visitor: vt<ReducedGraphParent>) {\n+    pub fn build_reduced_graph_for_block(@mut self,\n+                                         block: &blk,\n+                                         parent: ReducedGraphParent,\n+                                         visitor: vt<ReducedGraphParent>) {\n         let new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n@@ -1554,14 +1555,14 @@ pub impl Resolver {\n         visit_block(block, new_parent, visitor);\n     }\n \n-    fn handle_external_def(@mut self,\n-                           def: def,\n-                           visibility: ast::visibility,\n-                           modules: &mut HashMap<def_id, @mut Module>,\n-                           child_name_bindings: @mut NameBindings,\n-                           final_ident: &str,\n-                           ident: ident,\n-                           new_parent: ReducedGraphParent) {\n+    pub fn handle_external_def(@mut self,\n+                               def: def,\n+                               visibility: ast::visibility,\n+                               modules: &mut HashMap<def_id, @mut Module>,\n+                               child_name_bindings: @mut NameBindings,\n+                               final_ident: &str,\n+                               ident: ident,\n+                               new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n@@ -1702,7 +1703,8 @@ pub impl Resolver {\n      * Builds the reduced graph rooted at the 'use' directive for an external\n      * crate.\n      */\n-    fn build_reduced_graph_for_external_crate(@mut self, root: @mut Module) {\n+    pub fn build_reduced_graph_for_external_crate(@mut self,\n+                                                  root: @mut Module) {\n         let mut modules = HashMap::new();\n \n         // Create all the items reachable by paths.\n@@ -1879,13 +1881,13 @@ pub impl Resolver {\n     }\n \n     /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(@mut self,\n-                              privacy: Privacy,\n-                              module_: @mut Module,\n-                              module_path: ~[ident],\n-                              subclass: @ImportDirectiveSubclass,\n-                              span: span,\n-                              id: node_id) {\n+    pub fn build_import_directive(@mut self,\n+                                  privacy: Privacy,\n+                                  module_: @mut Module,\n+                                  module_path: ~[ident],\n+                                  subclass: @ImportDirectiveSubclass,\n+                                  span: span,\n+                                  id: node_id) {\n         let directive = @ImportDirective(privacy, module_path,\n                                          subclass, span, id);\n         module_.imports.push(directive);\n@@ -1940,7 +1942,7 @@ pub impl Resolver {\n \n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n-    fn resolve_imports(@mut self) {\n+    pub fn resolve_imports(@mut self) {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n@@ -1967,7 +1969,8 @@ pub impl Resolver {\n \n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n-    fn resolve_imports_for_module_subtree(@mut self, module_: @mut Module) {\n+    pub fn resolve_imports_for_module_subtree(@mut self,\n+                                              module_: @mut Module) {\n         debug!(\"(resolving imports for module subtree) resolving %s\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n@@ -1989,7 +1992,7 @@ pub impl Resolver {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(@mut self, module: @mut Module) {\n+    pub fn resolve_imports_for_module(@mut self, module: @mut Module) {\n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n@@ -2024,7 +2027,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n+    pub fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n         for idents.each |ident| {\n@@ -2034,19 +2037,19 @@ pub impl Resolver {\n         return result;\n     }\n \n-    fn import_directive_subclass_to_str(@mut self,\n-                                        subclass: ImportDirectiveSubclass)\n-                                     -> @~str {\n+    pub fn import_directive_subclass_to_str(@mut self,\n+                                            subclass: ImportDirectiveSubclass)\n+                                            -> @~str {\n         match subclass {\n             SingleImport(_target, source) => self.session.str_of(source),\n             GlobImport => @~\"*\"\n         }\n     }\n \n-    fn import_path_to_str(@mut self,\n-                          idents: &[ident],\n-                          subclass: ImportDirectiveSubclass)\n-                       -> @~str {\n+    pub fn import_path_to_str(@mut self,\n+                              idents: &[ident],\n+                              subclass: ImportDirectiveSubclass)\n+                              -> @~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n@@ -2061,10 +2064,10 @@ pub impl Resolver {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import_for_module(@mut self,\n-                                 module_: @mut Module,\n-                                 import_directive: @ImportDirective)\n-                                 -> ResolveResult<()> {\n+    pub fn resolve_import_for_module(@mut self,\n+                                     module_: @mut Module,\n+                                     import_directive: @ImportDirective)\n+                                     -> ResolveResult<()> {\n         let mut resolution_result = Failed;\n         let module_path = &import_directive.module_path;\n \n@@ -2151,7 +2154,8 @@ pub impl Resolver {\n         return resolution_result;\n     }\n \n-    fn create_name_bindings_from_module(module: @mut Module) -> NameBindings {\n+    pub fn create_name_bindings_from_module(module: @mut Module)\n+                                            -> NameBindings {\n         NameBindings {\n             type_def: Some(TypeNsDef {\n                 privacy: Public,\n@@ -2163,13 +2167,13 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_single_import(@mut self,\n-                             module_: @mut Module,\n-                             containing_module: @mut Module,\n-                             target: ident,\n-                             source: ident,\n-                             span: span)\n-                             -> ResolveResult<()> {\n+    pub fn resolve_single_import(@mut self,\n+                                 module_: @mut Module,\n+                                 containing_module: @mut Module,\n+                                 target: ident,\n+                                 source: ident,\n+                                 span: span)\n+                                 -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n                *self.session.str_of(target),\n@@ -2392,12 +2396,12 @@ pub impl Resolver {\n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid).\n-    fn resolve_glob_import(@mut self,\n-                           privacy: Privacy,\n-                           module_: @mut Module,\n-                           containing_module: @mut Module,\n-                           id: node_id)\n-                        -> ResolveResult<()> {\n+    pub fn resolve_glob_import(@mut self,\n+                               privacy: Privacy,\n+                               module_: @mut Module,\n+                               containing_module: @mut Module,\n+                               id: node_id)\n+                               -> ResolveResult<()> {\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n         // node.\n@@ -2516,13 +2520,13 @@ pub impl Resolver {\n     }\n \n     /// Resolves the given module path from the given root `module_`.\n-    fn resolve_module_path_from_root(@mut self,\n-                                     module_: @mut Module,\n-                                     module_path: &[ident],\n-                                     index: uint,\n-                                     span: span,\n-                                     mut name_search_type: NameSearchType)\n-                                  -> ResolveResult<@mut Module> {\n+    pub fn resolve_module_path_from_root(@mut self,\n+                                         module_: @mut Module,\n+                                         module_path: &[ident],\n+                                         index: uint,\n+                                         span: span,\n+                                         mut name_search_type: NameSearchType)\n+                                         -> ResolveResult<@mut Module> {\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n@@ -2625,13 +2629,13 @@ pub impl Resolver {\n \n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n-    fn resolve_module_path(@mut self,\n-                           module_: @mut Module,\n-                           module_path: &[ident],\n-                           use_lexical_scope: UseLexicalScopeFlag,\n-                           span: span,\n-                           name_search_type: NameSearchType)\n-                           -> ResolveResult<@mut Module> {\n+    pub fn resolve_module_path(@mut self,\n+                               module_: @mut Module,\n+                               module_path: &[ident],\n+                               use_lexical_scope: UseLexicalScopeFlag,\n+                               span: span,\n+                               name_search_type: NameSearchType)\n+                               -> ResolveResult<@mut Module> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -2719,13 +2723,13 @@ pub impl Resolver {\n \n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n-    fn resolve_item_in_lexical_scope(@mut self,\n-                                     module_: @mut Module,\n-                                     name: ident,\n-                                     namespace: Namespace,\n-                                     search_through_modules:\n-                                        SearchThroughModulesFlag)\n-                                  -> ResolveResult<Target> {\n+    pub fn resolve_item_in_lexical_scope(@mut self,\n+                                         module_: @mut Module,\n+                                         name: ident,\n+                                         namespace: Namespace,\n+                                         search_through_modules:\n+                                         SearchThroughModulesFlag)\n+                                         -> ResolveResult<Target> {\n         debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n                *self.session.str_of(name),\n@@ -2846,11 +2850,11 @@ pub impl Resolver {\n         }\n     }\n \n-    /** Resolves a module name in the current lexical scope. */\n-    fn resolve_module_in_lexical_scope(@mut self,\n-                                       module_: @mut Module,\n-                                       name: ident)\n-                                    -> ResolveResult<@mut Module> {\n+    /// Resolves a module name in the current lexical scope.\n+    pub fn resolve_module_in_lexical_scope(@mut self,\n+                                           module_: @mut Module,\n+                                           name: ident)\n+                                           -> ResolveResult<@mut Module> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n         let resolve_result = self.resolve_item_in_lexical_scope(\n@@ -2892,11 +2896,9 @@ pub impl Resolver {\n         }\n     }\n \n-    /**\n-     * Returns the nearest normal module parent of the given module.\n-     */\n-    fn get_nearest_normal_module_parent(@mut self, module_: @mut Module)\n-                                     -> Option<@mut Module> {\n+    /// Returns the nearest normal module parent of the given module.\n+    pub fn get_nearest_normal_module_parent(@mut self, module_: @mut Module)\n+                                            -> Option<@mut Module> {\n         let mut module_ = module_;\n         loop {\n             match module_.parent_link {\n@@ -2915,13 +2917,11 @@ pub impl Resolver {\n         }\n     }\n \n-    /**\n-     * Returns the nearest normal module parent of the given module, or the\n-     * module itself if it is a normal module.\n-     */\n-    fn get_nearest_normal_module_parent_or_self(@mut self,\n-                                                module_: @mut Module)\n-                                             -> @mut Module {\n+    /// Returns the nearest normal module parent of the given module, or the\n+    /// module itself if it is a normal module.\n+    pub fn get_nearest_normal_module_parent_or_self(@mut self,\n+                                                    module_: @mut Module)\n+                                                    -> @mut Module {\n         match module_.kind {\n             NormalModuleKind => return module_,\n             ExternModuleKind |\n@@ -2936,14 +2936,12 @@ pub impl Resolver {\n         }\n     }\n \n-    /**\n-     * Resolves a \"module prefix\". A module prefix is one of (a) `self::`;\n-     * (b) some chain of `super::`.\n-     */\n-    fn resolve_module_prefix(@mut self,\n-                             module_: @mut Module,\n-                             module_path: &[ident])\n-                          -> ResolveResult<ModulePrefixResult> {\n+    /// Resolves a \"module prefix\". A module prefix is one of (a) `self::`;\n+    /// (b) some chain of `super::`.\n+    pub fn resolve_module_prefix(@mut self,\n+                                 module_: @mut Module,\n+                                 module_path: &[ident])\n+                                 -> ResolveResult<ModulePrefixResult> {\n         let interner = self.session.parse_sess.interner;\n \n         // Start at the current module if we see `self` or `super`, or at the\n@@ -2985,12 +2983,12 @@ pub impl Resolver {\n     /// Attempts to resolve the supplied name in the given module for the\n     /// given namespace. If successful, returns the target corresponding to\n     /// the name.\n-    fn resolve_name_in_module(@mut self,\n-                              module_: @mut Module,\n-                              name: ident,\n-                              namespace: Namespace,\n-                              name_search_type: NameSearchType)\n-                           -> ResolveResult<Target> {\n+    pub fn resolve_name_in_module(@mut self,\n+                                  module_: @mut Module,\n+                                  name: ident,\n+                                  namespace: Namespace,\n+                                  name_search_type: NameSearchType)\n+                                  -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n                *self.session.str_of(name),\n                self.module_to_str(module_));\n@@ -3069,7 +3067,7 @@ pub impl Resolver {\n         return Failed;\n     }\n \n-    fn report_unresolved_imports(@mut self, module_: @mut Module) {\n+    pub fn report_unresolved_imports(@mut self, module_: @mut Module) {\n         let index = module_.resolved_import_count;\n         let imports: &mut ~[@ImportDirective] = &mut *module_.imports;\n         let import_count = imports.len();\n@@ -3110,12 +3108,13 @@ pub impl Resolver {\n     // Then this operation can simply be performed as part of item (or import)\n     // processing.\n \n-    fn record_exports(@mut self) {\n+    pub fn record_exports(@mut self) {\n         let root_module = self.graph_root.get_module();\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n-    fn record_exports_for_module_subtree(@mut self, module_: @mut Module) {\n+    pub fn record_exports_for_module_subtree(@mut self,\n+                                             module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n@@ -3157,7 +3156,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn record_exports_for_module(@mut self, module_: @mut Module) {\n+    pub fn record_exports_for_module(@mut self, module_: @mut Module) {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n@@ -3171,12 +3170,12 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_exports_of_namebindings(@mut self,\n-                                   exports2: &mut ~[Export2],\n-                                   ident: ident,\n-                                   namebindings: @mut NameBindings,\n-                                   ns: Namespace,\n-                                   reexport: bool) {\n+    pub fn add_exports_of_namebindings(@mut self,\n+                                       exports2: &mut ~[Export2],\n+                                       ident: ident,\n+                                       namebindings: @mut NameBindings,\n+                                       ns: Namespace,\n+                                       reexport: bool) {\n         match (namebindings.def_for_namespace(ns),\n                namebindings.privacy_for_namespace(ns)) {\n             (Some(d), Some(Public)) => {\n@@ -3199,9 +3198,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_exports_for_module(@mut self,\n-                              exports2: &mut ~[Export2],\n-                              module_: @mut Module) {\n+    pub fn add_exports_for_module(@mut self,\n+                                  exports2: &mut ~[Export2],\n+                                  module_: @mut Module) {\n         for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    *self.session.str_of(*ident));\n@@ -3258,7 +3257,7 @@ pub impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(@mut self, name: Option<ident>, f: &fn()) {\n+    pub fn with_scope(@mut self, name: Option<ident>, f: &fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3295,16 +3294,15 @@ pub impl Resolver {\n         self.current_module = orig_module;\n     }\n \n-    // Wraps the given definition in the appropriate number of `def_upvar`\n-    // wrappers.\n-\n-    fn upvarify(@mut self,\n-                ribs: &mut ~[@Rib],\n-                rib_index: uint,\n-                def_like: def_like,\n-                span: span,\n-                allow_capturing_self: AllowCapturingSelfFlag)\n-             -> Option<def_like> {\n+    /// Wraps the given definition in the appropriate number of `def_upvar`\n+    /// wrappers.\n+    pub fn upvarify(@mut self,\n+                    ribs: &mut ~[@Rib],\n+                    rib_index: uint,\n+                    def_like: def_like,\n+                    span: span,\n+                    allow_capturing_self: AllowCapturingSelfFlag)\n+                    -> Option<def_like> {\n         let mut def;\n         let is_ty_param;\n \n@@ -3408,12 +3406,12 @@ pub impl Resolver {\n         return Some(dl_def(def));\n     }\n \n-    fn search_ribs(@mut self,\n-                   ribs: &mut ~[@Rib],\n-                   name: ident,\n-                   span: span,\n-                   allow_capturing_self: AllowCapturingSelfFlag)\n-                -> Option<def_like> {\n+    pub fn search_ribs(@mut self,\n+                       ribs: &mut ~[@Rib],\n+                       name: ident,\n+                       span: span,\n+                       allow_capturing_self: AllowCapturingSelfFlag)\n+                       -> Option<def_like> {\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n@@ -3434,7 +3432,7 @@ pub impl Resolver {\n         return None;\n     }\n \n-    fn resolve_crate(@mut self) {\n+    pub fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n         visit_crate(self.crate, (), mk_vt(@Visitor {\n@@ -3454,7 +3452,7 @@ pub impl Resolver {\n         }));\n     }\n \n-    fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n+    pub fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n                *self.session.str_of(item.ident));\n \n@@ -3652,9 +3650,9 @@ pub impl Resolver {\n         self.xray_context = orig_xray_flag;\n     }\n \n-    fn with_type_parameter_rib(@mut self,\n-                               type_parameters: TypeParameters,\n-                               f: &fn()) {\n+    pub fn with_type_parameter_rib(@mut self,\n+                                   type_parameters: TypeParameters,\n+                                   f: &fn()) {\n         match type_parameters {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n@@ -3695,25 +3693,25 @@ pub impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(@mut self, f: &fn()) {\n+    pub fn with_label_rib(@mut self, f: &fn()) {\n         self.label_ribs.push(@Rib(NormalRibKind));\n         f();\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(@mut self, f: &fn()) {\n+    pub fn with_constant_rib(@mut self, f: &fn()) {\n         self.value_ribs.push(@Rib(ConstantItemRibKind));\n         f();\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_function(@mut self,\n-                        rib_kind: RibKind,\n-                        optional_declaration: Option<&fn_decl>,\n-                        type_parameters: TypeParameters,\n-                        block: &blk,\n-                        self_binding: SelfBinding,\n-                        visitor: ResolveVisitor) {\n+    pub fn resolve_function(@mut self,\n+                            rib_kind: RibKind,\n+                            optional_declaration: Option<&fn_decl>,\n+                            type_parameters: TypeParameters,\n+                            block: &blk,\n+                            self_binding: SelfBinding,\n+                            visitor: ResolveVisitor) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib(rib_kind);\n         self.value_ribs.push(function_value_rib);\n@@ -3782,19 +3780,19 @@ pub impl Resolver {\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_type_parameters(@mut self,\n-                               type_parameters: &OptVec<TyParam>,\n-                               visitor: ResolveVisitor) {\n+    pub fn resolve_type_parameters(@mut self,\n+                                   type_parameters: &OptVec<TyParam>,\n+                                   visitor: ResolveVisitor) {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |bound| {\n                 self.resolve_type_parameter_bound(bound, visitor);\n             }\n         }\n     }\n \n-    fn resolve_type_parameter_bound(@mut self,\n-                                    type_parameter_bound: &TyParamBound,\n-                                    visitor: ResolveVisitor) {\n+    pub fn resolve_type_parameter_bound(@mut self,\n+                                        type_parameter_bound: &TyParamBound,\n+                                        visitor: ResolveVisitor) {\n         match *type_parameter_bound {\n             TraitTyParamBound(tref) => {\n                 self.resolve_trait_reference(tref, visitor)\n@@ -3803,9 +3801,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_trait_reference(@mut self,\n-                               trait_reference: &trait_ref,\n-                               visitor: ResolveVisitor) {\n+    pub fn resolve_trait_reference(@mut self,\n+                                   trait_reference: &trait_ref,\n+                                   visitor: ResolveVisitor) {\n         match self.resolve_path(trait_reference.path, TypeNS, true, visitor) {\n             None => {\n                 self.session.span_err(trait_reference.path.span,\n@@ -3818,11 +3816,11 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_struct(@mut self,\n-                      id: node_id,\n-                      generics: &Generics,\n-                      fields: &[@struct_field],\n-                      visitor: ResolveVisitor) {\n+    pub fn resolve_struct(@mut self,\n+                          id: node_id,\n+                          generics: &Generics,\n+                          fields: &[@struct_field],\n+                          visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         do self.with_type_parameter_rib(HasTypeParameters\n                                         (generics, id, 0,\n@@ -3840,11 +3838,11 @@ pub impl Resolver {\n \n     // Does this really need to take a RibKind or is it always going\n     // to be NormalRibKind?\n-    fn resolve_method(@mut self,\n-                      rib_kind: RibKind,\n-                      method: @method,\n-                      outer_type_parameter_count: uint,\n-                      visitor: ResolveVisitor) {\n+    pub fn resolve_method(@mut self,\n+                          rib_kind: RibKind,\n+                          method: @method,\n+                          outer_type_parameter_count: uint,\n+                          visitor: ResolveVisitor) {\n         let method_generics = &method.generics;\n         let type_parameters =\n             HasTypeParameters(method_generics,\n@@ -3865,13 +3863,13 @@ pub impl Resolver {\n                               visitor);\n     }\n \n-    fn resolve_implementation(@mut self,\n-                              id: node_id,\n-                              generics: &Generics,\n-                              opt_trait_reference: Option<@trait_ref>,\n-                              self_type: @Ty,\n-                              methods: &[@method],\n-                              visitor: ResolveVisitor) {\n+    pub fn resolve_implementation(@mut self,\n+                                  id: node_id,\n+                                  generics: &Generics,\n+                                  opt_trait_reference: Option<@trait_ref>,\n+                                  self_type: @Ty,\n+                                  methods: &[@method],\n+                                  visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3938,18 +3936,18 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_module(@mut self,\n-                      module_: &_mod,\n-                      span: span,\n-                      _name: ident,\n-                      id: node_id,\n-                      visitor: ResolveVisitor) {\n+    pub fn resolve_module(@mut self,\n+                          module_: &_mod,\n+                          span: span,\n+                          _name: ident,\n+                          id: node_id,\n+                          visitor: ResolveVisitor) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n         visit_mod(module_, span, id, (), visitor);\n     }\n \n-    fn resolve_local(@mut self, local: @local, visitor: ResolveVisitor) {\n+    pub fn resolve_local(@mut self, local: @local, visitor: ResolveVisitor) {\n         let mutability = if local.node.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n@@ -3970,7 +3968,7 @@ pub impl Resolver {\n                              None, visitor);\n     }\n \n-    fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n+    pub fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n         let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n@@ -3981,7 +3979,7 @@ pub impl Resolver {\n         return result;\n     }\n \n-    fn check_consistent_bindings(@mut self, arm: &arm) {\n+    pub fn check_consistent_bindings(@mut self, arm: &arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for arm.pats.eachi() |i, p| {\n@@ -4020,7 +4018,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n+    pub fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n@@ -4039,7 +4037,7 @@ pub impl Resolver {\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_block(@mut self, block: &blk, visitor: ResolveVisitor) {\n+    pub fn resolve_block(@mut self, block: &blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n@@ -4064,7 +4062,7 @@ pub impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n+    pub fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4144,14 +4142,14 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_pattern(@mut self,\n-                       pattern: @pat,\n-                       mode: PatternBindingMode,\n-                       mutability: Mutability,\n-                       // Maps idents to the node ID for the (outermost)\n-                       // pattern that binds them\n-                       bindings_list: Option<@mut HashMap<ident,node_id>>,\n-                       visitor: ResolveVisitor) {\n+    pub fn resolve_pattern(@mut self,\n+                           pattern: @pat,\n+                           mode: PatternBindingMode,\n+                           mutability: Mutability,\n+                           // Maps idents to the node ID for the (outermost)\n+                           // pattern that binds them\n+                           bindings_list: Option<@mut HashMap<ident,node_id>>,\n+                           visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n         for walk_pat(pattern) |pattern| {\n             match pattern.node {\n@@ -4386,8 +4384,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_bare_identifier_pattern(@mut self, name: ident)\n-                                    -> BareIdentifierPatternResolution {\n+    pub fn resolve_bare_identifier_pattern(@mut self, name: ident)\n+                                           ->\n+                                           BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n                                                  name,\n                                                  ValueNS,\n@@ -4426,12 +4425,12 @@ pub impl Resolver {\n \n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n-    fn resolve_path(@mut self,\n-                    path: @Path,\n-                    namespace: Namespace,\n-                    check_ribs: bool,\n-                    visitor: ResolveVisitor)\n-                 -> Option<def> {\n+    pub fn resolve_path(@mut self,\n+                        path: @Path,\n+                        namespace: Namespace,\n+                        check_ribs: bool,\n+                        visitor: ResolveVisitor)\n+                        -> Option<def> {\n         // First, resolve the types.\n         for path.types.each |ty| {\n             self.resolve_type(*ty, visitor);\n@@ -4455,12 +4454,12 @@ pub impl Resolver {\n                                        path.span);\n     }\n \n-    fn resolve_identifier(@mut self,\n-                          identifier: ident,\n-                          namespace: Namespace,\n-                          check_ribs: bool,\n-                          span: span)\n-                       -> Option<def> {\n+    pub fn resolve_identifier(@mut self,\n+                              identifier: ident,\n+                              namespace: Namespace,\n+                              check_ribs: bool,\n+                              span: span)\n+                              -> Option<def> {\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n                                                       namespace,\n@@ -4479,12 +4478,12 @@ pub impl Resolver {\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n-    fn resolve_definition_of_name_in_module(@mut self,\n-                                            containing_module: @mut Module,\n-                                            name: ident,\n-                                            namespace: Namespace,\n-                                            xray: XrayFlag)\n-                                         -> NameDefinition {\n+    pub fn resolve_definition_of_name_in_module(@mut self,\n+                                                containing_module: @mut Module,\n+                                                name: ident,\n+                                                namespace: Namespace,\n+                                                xray: XrayFlag)\n+                                                -> NameDefinition {\n         // First, search children.\n         match containing_module.children.find(&name) {\n             Some(child_name_bindings) => {\n@@ -4552,7 +4551,7 @@ pub impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n+    pub fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1 {\n@@ -4565,11 +4564,11 @@ pub impl Resolver {\n         return module_path_idents;\n     }\n \n-    fn resolve_module_relative_path(@mut self,\n-                                    path: @Path,\n-                                    xray: XrayFlag,\n-                                    namespace: Namespace)\n-                                 -> Option<def> {\n+    pub fn resolve_module_relative_path(@mut self,\n+                                        path: @Path,\n+                                        xray: XrayFlag,\n+                                        namespace: Namespace)\n+                                        -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let containing_module;\n@@ -4612,11 +4611,11 @@ pub impl Resolver {\n \n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n-    fn resolve_crate_relative_path(@mut self,\n-                                   path: @Path,\n-                                   xray: XrayFlag,\n-                                   namespace: Namespace)\n-                                -> Option<def> {\n+    pub fn resolve_crate_relative_path(@mut self,\n+                                       path: @Path,\n+                                       xray: XrayFlag,\n+                                       namespace: Namespace)\n+                                       -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let root_module = self.graph_root.get_module();\n@@ -4659,11 +4658,11 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_identifier_in_local_ribs(@mut self,\n-                                        ident: ident,\n-                                        namespace: Namespace,\n-                                        span: span)\n-                                        -> Option<def> {\n+    pub fn resolve_identifier_in_local_ribs(@mut self,\n+                                            ident: ident,\n+                                            namespace: Namespace,\n+                                            span: span)\n+                                            -> Option<def> {\n         // Check the local set of ribs.\n         let search_result;\n         match namespace {\n@@ -4692,8 +4691,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_self_value_in_local_ribs(@mut self, span: span)\n-                                        -> Option<def> {\n+    pub fn resolve_self_value_in_local_ribs(@mut self, span: span)\n+                                            -> Option<def> {\n         // FIXME #4950: This should not use a while loop.\n         let ribs = &mut self.value_ribs;\n         let mut i = ribs.len();\n@@ -4721,10 +4720,10 @@ pub impl Resolver {\n         None\n     }\n \n-    fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n-                                                   ident: ident,\n-                                                   namespace: Namespace)\n-                                                -> Option<def> {\n+    pub fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n+                                                       ident: ident,\n+                                                       namespace: Namespace)\n+                                                       -> Option<def> {\n         // Check the items.\n         match self.resolve_item_in_lexical_scope(self.current_module,\n                                                  ident,\n@@ -4754,7 +4753,10 @@ pub impl Resolver {\n         }\n     }\n \n-    fn find_best_match_for_name(@mut self, name: &str, max_distance: uint) -> Option<~str> {\n+    pub fn find_best_match_for_name(@mut self,\n+                                    name: &str,\n+                                    max_distance: uint)\n+                                    -> Option<~str> {\n         let this = &mut *self;\n \n         let mut maybes: ~[~str] = ~[];\n@@ -4792,7 +4794,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n+    pub fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n         let this = &mut *self;\n \n         let mut i = this.type_ribs.len();\n@@ -4826,7 +4828,7 @@ pub impl Resolver {\n       return false;\n     }\n \n-    fn resolve_expr(@mut self, expr: @expr, visitor: ResolveVisitor) {\n+    pub fn resolve_expr(@mut self, expr: @expr, visitor: ResolveVisitor) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -4963,7 +4965,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn record_candidate_traits_for_expr_if_necessary(@mut self, expr: @expr) {\n+    pub fn record_candidate_traits_for_expr_if_necessary(@mut self,\n+                                                         expr: @expr) {\n         match expr.node {\n             expr_field(_, ident, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n@@ -5040,9 +5043,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(@mut self,\n-                                           name: ident)\n-                                        -> ~[def_id] {\n+    pub fn search_for_traits_containing_method(@mut self, name: ident)\n+                                               -> ~[def_id] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                *self.session.str_of(name));\n \n@@ -5142,32 +5144,32 @@ pub impl Resolver {\n         return found_traits;\n     }\n \n-    fn add_trait_info(&self,\n-                      found_traits: &mut ~[def_id],\n-                      trait_def_id: def_id,\n-                      name: ident) {\n+    pub fn add_trait_info(&self,\n+                          found_traits: &mut ~[def_id],\n+                          trait_def_id: def_id,\n+                          name: ident) {\n         debug!(\"(adding trait info) found trait %d:%d for method '%s'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n                *self.session.str_of(name));\n         found_traits.push(trait_def_id);\n     }\n \n-    fn add_fixed_trait_for_expr(@mut self,\n-                                expr_id: node_id,\n-                                trait_id: def_id) {\n+    pub fn add_fixed_trait_for_expr(@mut self,\n+                                    expr_id: node_id,\n+                                    trait_id: def_id) {\n         self.trait_map.insert(expr_id, @mut ~[trait_id]);\n     }\n \n-    fn record_def(@mut self, node_id: node_id, def: def) {\n+    pub fn record_def(@mut self, node_id: node_id, def: def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n     }\n \n-    fn enforce_default_binding_mode(@mut self,\n-                                    pat: @pat,\n-                                    pat_binding_mode: binding_mode,\n-                                    descr: &str) {\n+    pub fn enforce_default_binding_mode(@mut self,\n+                                        pat: @pat,\n+                                        pat_binding_mode: binding_mode,\n+                                        descr: &str) {\n         match pat_binding_mode {\n             bind_infer => {}\n             bind_by_ref(*) => {\n@@ -5186,15 +5188,15 @@ pub impl Resolver {\n     // resolve data structures.\n     //\n \n-    fn check_for_unused_imports(@mut self) {\n+    pub fn check_for_unused_imports(@mut self) {\n         let vt = mk_simple_visitor(@SimpleVisitor {\n             visit_view_item: |vi| self.check_for_item_unused_imports(vi),\n             .. *default_simple_visitor()\n         });\n         visit_crate(self.crate, (), vt);\n     }\n \n-    fn check_for_item_unused_imports(&mut self, vi: @view_item) {\n+    pub fn check_for_item_unused_imports(&mut self, vi: @view_item) {\n         // Ignore public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n@@ -5238,7 +5240,7 @@ pub impl Resolver {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n+    pub fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n         let mut idents = ~[];\n         let mut current_module = module_;\n         loop {\n@@ -5263,7 +5265,7 @@ pub impl Resolver {\n         return self.idents_to_str(vec::reversed(idents));\n     }\n \n-    fn dump_module(@mut self, module_: @mut Module) {\n+    pub fn dump_module(@mut self, module_: @mut Module) {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");"}, {"sha": "acc3293f2678302022936479e11c32b365d818e5", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -36,8 +36,8 @@ pub struct FnType {\n     sret: bool\n }\n \n-pub impl FnType {\n-    fn decl_fn(&self, decl: &fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+impl FnType {\n+    pub fn decl_fn(&self, decl: &fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n         let fnty = T_fn(atys, rty);\n@@ -57,9 +57,11 @@ pub impl FnType {\n         return llfn;\n     }\n \n-    fn build_shim_args(&self, bcx: block,\n-                       arg_tys: &[TypeRef],\n-                       llargbundle: ValueRef) -> ~[ValueRef] {\n+    pub fn build_shim_args(&self,\n+                           bcx: block,\n+                           arg_tys: &[TypeRef],\n+                           llargbundle: ValueRef)\n+                           -> ~[ValueRef] {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n \n@@ -92,12 +94,12 @@ pub impl FnType {\n         return llargvals;\n     }\n \n-    fn build_shim_ret(&self,\n-                      bcx: block,\n-                      arg_tys: &[TypeRef],\n-                      ret_def: bool,\n-                      llargbundle: ValueRef,\n-                      llretval: ValueRef) {\n+    pub fn build_shim_ret(&self,\n+                          bcx: block,\n+                          arg_tys: &[TypeRef],\n+                          ret_def: bool,\n+                          llargbundle: ValueRef,\n+                          llretval: ValueRef) {\n         for vec::eachi(self.attrs) |i, a| {\n             match *a {\n                 option::Some(attr) => {\n@@ -128,11 +130,11 @@ pub impl FnType {\n         };\n     }\n \n-    fn build_wrap_args(&self,\n-                       bcx: block,\n-                       ret_ty: TypeRef,\n-                       llwrapfn: ValueRef,\n-                       llargbundle: ValueRef) {\n+    pub fn build_wrap_args(&self,\n+                           bcx: block,\n+                           ret_ty: TypeRef,\n+                           llwrapfn: ValueRef,\n+                           llargbundle: ValueRef) {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n         let mut j = 0u;\n@@ -167,10 +169,10 @@ pub impl FnType {\n         store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n     }\n \n-    fn build_wrap_ret(&self,\n-                      bcx: block,\n-                      arg_tys: &[TypeRef],\n-                      llargbundle: ValueRef) {\n+    pub fn build_wrap_ret(&self,\n+                          bcx: block,\n+                          arg_tys: &[TypeRef],\n+                          llargbundle: ValueRef) {\n         unsafe {\n             if llvm::LLVMGetTypeKind(self.ret_ty.ty) == Void {\n                 return;"}, {"sha": "a5b44d1a43fc1068fb1b58aa18d9d5b175c62d49", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -118,8 +118,8 @@ pub struct EnvValue {\n     datum: Datum\n }\n \n-pub impl EnvAction {\n-    fn to_str(&self) -> ~str {\n+impl EnvAction {\n+    pub fn to_str(&self) -> ~str {\n         match *self {\n             EnvCopy => ~\"EnvCopy\",\n             EnvMove => ~\"EnvMove\",\n@@ -128,8 +128,8 @@ pub impl EnvAction {\n     }\n }\n \n-pub impl EnvValue {\n-    fn to_str(&self, ccx: @CrateContext) -> ~str {\n+impl EnvValue {\n+    pub fn to_str(&self, ccx: @CrateContext) -> ~str {\n         fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }"}, {"sha": "7080487e7f886799f080a7e58b8f2cac9c649a00", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -249,8 +249,8 @@ pub struct param_substs {\n     self_ty: Option<ty::t>\n }\n \n-pub impl param_substs {\n-    fn validate(&self) {\n+impl param_substs {\n+    pub fn validate(&self) {\n         for self.tys.each |t| { assert!(!ty::type_needs_infer(*t)); }\n         for self.self_ty.each |t| { assert!(!ty::type_needs_infer(*t)); }\n     }\n@@ -353,7 +353,7 @@ pub struct fn_ctxt_ {\n     ccx: @@CrateContext\n }\n \n-pub impl fn_ctxt_ {\n+impl fn_ctxt_ {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n         if self.has_immediate_return_value {\n             arg + 1u\n@@ -598,8 +598,8 @@ pub struct scope_info {\n     landing_pad: Option<BasicBlockRef>,\n }\n \n-pub impl scope_info {\n-    fn empty_cleanups(&mut self) -> bool {\n+impl scope_info {\n+    pub fn empty_cleanups(&mut self) -> bool {\n         self.cleanups.is_empty()\n     }\n }\n@@ -695,8 +695,8 @@ pub fn rslt(bcx: block, val: ValueRef) -> Result {\n     Result {bcx: bcx, val: val}\n }\n \n-pub impl Result {\n-    fn unpack(&self, bcx: &mut block) -> ValueRef {\n+impl Result {\n+    pub fn unpack(&self, bcx: &mut block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -742,28 +742,28 @@ pub fn block_parent(cx: block) -> block {\n \n // Accessors\n \n-pub impl block_ {\n-    fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n-    fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n-    fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n+impl block_ {\n+    pub fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n+    pub fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    pub fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n \n-    fn node_id_to_str(@mut self, id: ast::node_id) -> ~str {\n+    pub fn node_id_to_str(@mut self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n-    fn expr_to_str(@mut self, e: @ast::expr) -> ~str {\n+    pub fn expr_to_str(@mut self, e: @ast::expr) -> ~str {\n         e.repr(self.tcx())\n     }\n \n-    fn expr_is_lval(@mut self, e: @ast::expr) -> bool {\n+    pub fn expr_is_lval(@mut self, e: @ast::expr) -> bool {\n         ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    fn expr_kind(@mut self, e: @ast::expr) -> ty::ExprKind {\n+    pub fn expr_kind(@mut self, e: @ast::expr) -> ty::ExprKind {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    fn def(@mut self, nid: ast::node_id) -> ast::def {\n+    pub fn def(@mut self, nid: ast::node_id) -> ast::def {\n         match self.tcx().def_map.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -773,18 +773,19 @@ pub impl block_ {\n         }\n     }\n \n-    fn val_str(@mut self, val: ValueRef) -> @str {\n+    pub fn val_str(@mut self, val: ValueRef) -> @str {\n         val_str(self.ccx().tn, val)\n     }\n \n-    fn llty_str(@mut self, llty: TypeRef) -> @str {\n+    pub fn llty_str(@mut self, llty: TypeRef) -> @str {\n         ty_str(self.ccx().tn, llty)\n     }\n \n-    fn ty_to_str(@mut self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n         t.repr(self.tcx())\n     }\n-    fn to_str(@mut self) -> ~str {\n+\n+    pub fn to_str(@mut self) -> ~str {\n         unsafe {\n             match self.node_info {\n                 Some(node_info) => fmt!(\"[block %d]\", node_info.id),"}, {"sha": "1c94d16b1583479936bd8992bf71180e1aed1a4f", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 106, "deletions": 82, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -145,12 +145,12 @@ pub enum DatumMode {\n     ByValue,\n }\n \n-pub impl DatumMode {\n-    fn is_by_ref(&self) -> bool {\n+impl DatumMode {\n+    pub fn is_by_ref(&self) -> bool {\n         match *self { ByRef(_) => true, ByValue => false }\n     }\n \n-    fn is_by_value(&self) -> bool {\n+    pub fn is_by_value(&self) -> bool {\n         match *self { ByRef(_) => false, ByValue => true }\n     }\n }\n@@ -205,9 +205,13 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n     }\n }\n \n-pub impl Datum {\n-    fn store_to(&self, bcx: block, id: ast::node_id,\n-                action: CopyAction, dst: ValueRef) -> block {\n+impl Datum {\n+    pub fn store_to(&self,\n+                    bcx: block,\n+                    id: ast::node_id,\n+                    action: CopyAction,\n+                    dst: ValueRef)\n+                    -> block {\n         /*!\n          *\n          * Stores this value into its final home.  This moves if\n@@ -221,8 +225,11 @@ pub impl Datum {\n         }\n     }\n \n-    fn store_to_dest(&self, bcx: block, id: ast::node_id,\n-                     dest: expr::Dest) -> block {\n+    pub fn store_to_dest(&self,\n+                         bcx: block,\n+                         id: ast::node_id,\n+                         dest: expr::Dest)\n+                         -> block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n@@ -233,28 +240,32 @@ pub impl Datum {\n         }\n     }\n \n-    fn store_to_datum(&self, bcx: block, id: ast::node_id,\n-                      action: CopyAction, datum: Datum) -> block {\n+    pub fn store_to_datum(&self,\n+                          bcx: block,\n+                          id: ast::node_id,\n+                          action: CopyAction,\n+                          datum: Datum)\n+                          -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, id, action, datum.val)\n     }\n \n-    fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n-                    -> block {\n+    pub fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n+                         -> block {\n         assert!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n-    fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n-                    -> block {\n+    pub fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n+                         -> block {\n         assert!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n-    fn copy_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n-              -> block {\n+    pub fn copy_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n+                   -> block {\n         /*!\n          *\n          * Copies the value into `dst`, which should be a pointer to a\n@@ -296,9 +307,11 @@ pub impl Datum {\n         }\n     }\n \n-    fn copy_to_no_check(&self, bcx: block, action: CopyAction,\n-                        dst: ValueRef) -> block\n-    {\n+    pub fn copy_to_no_check(&self,\n+                            bcx: block,\n+                            action: CopyAction,\n+                            dst: ValueRef)\n+                            -> block {\n         /*!\n          *\n          * A helper for `copy_to()` which does not check to see if we\n@@ -326,8 +339,8 @@ pub impl Datum {\n     // This works like copy_val, except that it deinitializes the source.\n     // Since it needs to zero out the source, src also needs to be an lval.\n     //\n-    fn move_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n-              -> block {\n+    pub fn move_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n+                   -> block {\n         let _icx = bcx.insn_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n@@ -356,7 +369,7 @@ pub impl Datum {\n         return bcx;\n     }\n \n-    fn add_clean(&self, bcx: block) {\n+    pub fn add_clean(&self, bcx: block) {\n         /*!\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue.\n@@ -376,7 +389,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn cancel_clean(&self, bcx: block) {\n+    pub fn cancel_clean(&self, bcx: block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.mode {\n                 ByValue |\n@@ -394,14 +407,14 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_str(&self, ccx: &CrateContext) -> ~str {\n+    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         fmt!(\"Datum { val=%s, ty=%s, mode=%? }\",\n              val_str(ccx.tn, self.val),\n              ty_to_str(ccx.tcx, self.ty),\n              self.mode)\n     }\n \n-    fn to_value_datum(&self, bcx: block) -> Datum {\n+    pub fn to_value_datum(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * Yields a by-ref form of this datum.  This may involve\n@@ -418,7 +431,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_value_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_value_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          *\n          * Yields the value itself. */\n@@ -439,7 +452,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_ref_datum(&self, bcx: block) -> Datum {\n+    pub fn to_ref_datum(&self, bcx: block) -> Datum {\n         /*!\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n@@ -456,7 +469,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_ref_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_ref_llval(&self, bcx: block) -> ValueRef {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n@@ -471,7 +484,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_zeroable_ref_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_zeroable_ref_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          * Returns a by-ref llvalue that can be zeroed in order to\n          * cancel cleanup. This is a kind of hokey bridge used\n@@ -496,13 +509,13 @@ pub impl Datum {\n         }\n     }\n \n-    fn appropriate_mode(&self) -> DatumMode {\n+    pub fn appropriate_mode(&self) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n         appropriate_mode(self.ty)\n     }\n \n-    fn to_appropriate_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_appropriate_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n@@ -513,7 +526,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_appropriate_datum(&self, bcx: block) -> Datum {\n+    pub fn to_appropriate_datum(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n@@ -524,10 +537,12 @@ pub impl Datum {\n         }\n     }\n \n-    fn get_element(&self, bcx: block,\n-                   ty: ty::t,\n-                   source: DatumCleanup,\n-                   gep: &fn(ValueRef) -> ValueRef) -> Datum {\n+    pub fn get_element(&self,\n+                       bcx: block,\n+                       ty: ty::t,\n+                       source: DatumCleanup,\n+                       gep: &fn(ValueRef) -> ValueRef)\n+                       -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n             val: gep(base_val),\n@@ -536,7 +551,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn drop_val(&self, bcx: block) -> block {\n+    pub fn drop_val(&self, bcx: block) -> block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n         }\n@@ -547,7 +562,7 @@ pub impl Datum {\n         };\n     }\n \n-    fn box_body(&self, bcx: block) -> Datum {\n+    pub fn box_body(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * This datum must represent an @T or ~T box.  Returns a new\n@@ -567,7 +582,7 @@ pub impl Datum {\n         Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n     }\n \n-    fn to_rptr(&self, bcx: block) -> Datum {\n+    pub fn to_rptr(&self, bcx: block) -> Datum {\n         //! Returns a new datum of region-pointer type containing the\n         //! the same ptr as this datum (after converting to by-ref\n         //! using `to_ref_llval()`).\n@@ -582,14 +597,18 @@ pub impl Datum {\n         Datum {val: llval, ty: rptr_ty, mode: ByValue}\n     }\n \n-    fn try_deref(&self,\n-        bcx: block,            // block wherein to generate insn's\n-        span: span,            // location where deref occurs\n-        expr_id: ast::node_id, // id of deref expr\n-        derefs: uint,          // number of times deref'd already\n-        is_auto: bool)         // if true, only deref if auto-derefable\n-        -> (Option<Datum>, block)\n-    {\n+    /// bcx: Block wherein to generate insns.\n+    /// span: Location where deref occurs.\n+    /// expr_id: ID of deref expr.\n+    /// derefs: Number of times deref'd already.\n+    /// is_auto: If true, only deref if auto-derefable.\n+    pub fn try_deref(&self,\n+                     bcx: block,\n+                     span: span,\n+                     expr_id: ast::node_id,\n+                     derefs: uint,\n+                     is_auto: bool)\n+                     -> (Option<Datum>, block) {\n         let ccx = bcx.ccx();\n \n         debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n@@ -703,10 +722,9 @@ pub impl Datum {\n         }\n     }\n \n-    fn deref(&self, bcx: block,\n-             expr: @ast::expr,  // the deref expression\n-             derefs: uint)\n-          -> DatumBlock {\n+    /// expr: The deref expression.\n+    pub fn deref(&self, bcx: block, expr: @ast::expr, derefs: uint)\n+                 -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n             (None, _) => {\n@@ -716,11 +734,12 @@ pub impl Datum {\n         }\n     }\n \n-    fn autoderef(&self, bcx: block,\n-                 span: span,\n-                 expr_id: ast::node_id,\n-                 max: uint)\n-              -> DatumBlock {\n+    pub fn autoderef(&self,\n+                     bcx: block,\n+                     span: span,\n+                     expr_id: ast::node_id,\n+                     max: uint)\n+                     -> DatumBlock {\n         let _icx = bcx.insn_ctxt(\"autoderef\");\n \n         debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n@@ -748,12 +767,12 @@ pub impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n-    fn get_vec_base_and_len(&self,\n-                            mut bcx: block,\n-                            span: span,\n-                            expr_id: ast::node_id,\n-                            derefs: uint)\n-                            -> (block, ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len(&self,\n+                                mut bcx: block,\n+                                span: span,\n+                                expr_id: ast::node_id,\n+                                derefs: uint)\n+                                -> (block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -763,72 +782,77 @@ pub impl Datum {\n         (bcx, base, len)\n     }\n \n-    fn get_vec_base_and_len_no_root(&self, bcx: block) -> (ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len_no_root(&self, bcx: block)\n+                                        -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n \n         let llval = self.to_appropriate_llval(bcx);\n         tvec::get_base_and_len(bcx, llval, self.ty)\n     }\n \n-    fn root_and_write_guard(&self,\n-                            bcx: block,\n-                            span: span,\n-                            expr_id: ast::node_id,\n-                            derefs: uint) -> block {\n+    pub fn root_and_write_guard(&self,\n+                                bcx: block,\n+                                span: span,\n+                                expr_id: ast::node_id,\n+                                derefs: uint)\n+                                -> block {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n-    fn to_result(&self, bcx: block) -> common::Result {\n+    pub fn to_result(&self, bcx: block) -> common::Result {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }\n }\n \n-pub impl DatumBlock {\n-    fn unpack(&self, bcx: &mut block) -> Datum {\n+impl DatumBlock {\n+    pub fn unpack(&self, bcx: &mut block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }\n \n-    fn assert_by_ref(&self) -> DatumBlock {\n+    pub fn assert_by_ref(&self) -> DatumBlock {\n         assert!(self.datum.mode.is_by_ref());\n         *self\n     }\n \n-    fn drop_val(&self) -> block {\n+    pub fn drop_val(&self) -> block {\n         self.datum.drop_val(self.bcx)\n     }\n \n-    fn store_to(&self, id: ast::node_id, action: CopyAction,\n-                dst: ValueRef) -> block {\n+    pub fn store_to(&self,\n+                    id: ast::node_id,\n+                    action: CopyAction,\n+                    dst: ValueRef)\n+                    -> block {\n         self.datum.store_to(self.bcx, id, action, dst)\n     }\n \n-    fn copy_to(&self, action: CopyAction, dst: ValueRef) -> block {\n+    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> block {\n         self.datum.copy_to(self.bcx, action, dst)\n     }\n \n-    fn move_to(&self, action: CopyAction, dst: ValueRef) -> block {\n+    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> block {\n         self.datum.move_to(self.bcx, action, dst)\n     }\n \n-    fn to_value_llval(&self) -> ValueRef {\n+    pub fn to_value_llval(&self) -> ValueRef {\n         self.datum.to_value_llval(self.bcx)\n     }\n \n-    fn to_result(&self) -> common::Result {\n+    pub fn to_result(&self) -> common::Result {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n \n-    fn ccx(&self) -> @CrateContext {\n+    pub fn ccx(&self) -> @CrateContext {\n         self.bcx.ccx()\n     }\n \n-    fn tcx(&self) -> ty::ctxt {\n+    pub fn tcx(&self) -> ty::ctxt {\n         self.bcx.tcx()\n     }\n \n-    fn to_str(&self) -> ~str {\n+    pub fn to_str(&self) -> ~str {\n         self.datum.to_str(self.ccx())\n     }\n }"}, {"sha": "fa8c3cd8879a2fdef0458ead2b80184ccd3d7a84", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -170,8 +170,8 @@ pub enum Dest {\n     Ignore,\n }\n \n-pub impl Dest {\n-    fn to_str(&self, ccx: @CrateContext) -> ~str {\n+impl Dest {\n+    pub fn to_str(&self, ccx: @CrateContext) -> ~str {\n         match *self {\n             SaveIn(v) => fmt!(\"SaveIn(%s)\", val_str(ccx.tn, v)),\n             Ignore => ~\"Ignore\""}, {"sha": "38cc9ba69de92d969d861dbce0ed502c05d6b6ff", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -41,16 +41,16 @@ pub struct Reflector {\n     bcx: block\n }\n \n-pub impl Reflector {\n-    fn c_uint(&mut self, u: uint) -> ValueRef {\n+impl Reflector {\n+    pub fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n \n-    fn c_int(&mut self, i: int) -> ValueRef {\n+    pub fn c_int(&mut self, i: int) -> ValueRef {\n         C_int(self.bcx.ccx(), i)\n     }\n \n-    fn c_slice(&mut self, s: @~str) -> ValueRef {\n+    pub fn c_slice(&mut self, s: @~str) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n@@ -64,27 +64,27 @@ pub impl Reflector {\n         scratch.val\n     }\n \n-    fn c_size_and_align(&mut self, t: ty::t) -> ~[ValueRef] {\n+    pub fn c_size_and_align(&mut self, t: ty::t) -> ~[ValueRef] {\n         let tr = type_of(self.bcx.ccx(), t);\n         let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n         let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n         return ~[self.c_uint(s),\n              self.c_uint(a)];\n     }\n \n-    fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n+    pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n         glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n         PointerCast(bcx, static_ti.tydesc, T_ptr(self.tydesc_ty))\n     }\n \n-    fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n+    pub fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n         ~[self.c_uint(mt.mutbl as uint),\n           self.c_tydesc(mt.ty)]\n     }\n \n-    fn visit(&mut self, ty_name: ~str, args: &[ValueRef]) {\n+    pub fn visit(&mut self, ty_name: ~str, args: &[ValueRef]) {\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n@@ -119,19 +119,19 @@ pub impl Reflector {\n         self.bcx = next_bcx\n     }\n \n-    fn bracketed(&mut self,\n-                 bracket_name: ~str,\n-                 extra: &[ValueRef],\n-                 inner: &fn(&mut Reflector)) {\n+    pub fn bracketed(&mut self,\n+                     bracket_name: ~str,\n+                     extra: &[ValueRef],\n+                     inner: &fn(&mut Reflector)) {\n         self.visit(~\"enter_\" + bracket_name, extra);\n         inner(self);\n         self.visit(~\"leave_\" + bracket_name, extra);\n     }\n \n-    fn vstore_name_and_extra(&mut self,\n-                             t: ty::t,\n-                             vstore: ty::vstore) -> (~str, ~[ValueRef])\n-    {\n+    pub fn vstore_name_and_extra(&mut self,\n+                                 t: ty::t,\n+                                 vstore: ty::vstore)\n+                                 -> (~str, ~[ValueRef]) {\n         match vstore {\n             ty::vstore_fixed(n) => {\n                 let extra = vec::append(~[self.c_uint(n)],\n@@ -144,12 +144,12 @@ pub impl Reflector {\n         }\n     }\n \n-    fn leaf(&mut self, name: ~str) {\n+    pub fn leaf(&mut self, name: ~str) {\n         self.visit(name, []);\n     }\n \n     // Entrypoint\n-    fn visit_ty(&mut self, t: ty::t) {\n+    pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n         debug!(\"reflect::visit_ty %s\",\n                ty_to_str(bcx.ccx().tcx, t));\n@@ -351,7 +351,7 @@ pub impl Reflector {\n         }\n     }\n \n-    fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n+    pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n         for sig.inputs.eachi |i, arg| {\n             let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),"}, {"sha": "e3c0c3a04d896a54b0066a3c6fe57045f5e256c0", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -149,8 +149,8 @@ pub struct VecTypes {\n     llunit_size: ValueRef\n }\n \n-pub impl VecTypes {\n-    fn to_str(&self, ccx: @CrateContext) -> ~str {\n+impl VecTypes {\n+    pub fn to_str(&self, ccx: @CrateContext) -> ~str {\n         fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),"}, {"sha": "f02f117bd364b9a1ec5d72de6633b8fe769acdad", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -68,14 +68,15 @@ pub struct Method {\n     def_id: ast::def_id\n }\n \n-pub impl Method {\n-    fn new(ident: ast::ident,\n-           generics: ty::Generics,\n-           transformed_self_ty: Option<ty::t>,\n-           fty: BareFnTy,\n-           explicit_self: ast::explicit_self_,\n-           vis: ast::visibility,\n-           def_id: ast::def_id) -> Method {\n+impl Method {\n+    pub fn new(ident: ast::ident,\n+               generics: ty::Generics,\n+               transformed_self_ty: Option<ty::t>,\n+               fty: BareFnTy,\n+               explicit_self: ast::explicit_self_,\n+               vis: ast::visibility,\n+               def_id: ast::def_id)\n+               -> Method {\n         // Check the invariants.\n         if explicit_self == ast::sty_static {\n             assert!(transformed_self_ty.is_none());\n@@ -460,8 +461,8 @@ pub enum Region {\n     re_empty,\n }\n \n-pub impl Region {\n-    fn is_bound(&self) -> bool {\n+impl Region {\n+    pub fn is_bound(&self) -> bool {\n         match self {\n             &re_bound(*) => true,\n             _ => false\n@@ -879,8 +880,8 @@ pub struct Generics {\n     region_param: Option<region_variance>,\n }\n \n-pub impl Generics {\n-    fn has_type_params(&self) -> bool {\n+impl Generics {\n+    pub fn has_type_params(&self) -> bool {\n         !self.type_param_defs.is_empty()\n     }\n }\n@@ -1817,12 +1818,12 @@ pub struct TypeContents {\n     bits: u32\n }\n \n-pub impl TypeContents {\n-    fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n+impl TypeContents {\n+    pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n         iter::all(|bb| self.meets_bound(cx, bb), |f| bbs.each(f))\n     }\n \n-    fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {\n+    pub fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {\n         match bb {\n             BoundCopy => self.is_copy(cx),\n             BoundStatic => self.is_static(cx),\n@@ -1832,69 +1833,69 @@ pub impl TypeContents {\n         }\n     }\n \n-    fn intersects(&self, tc: TypeContents) -> bool {\n+    pub fn intersects(&self, tc: TypeContents) -> bool {\n         (self.bits & tc.bits) != 0\n     }\n \n-    fn is_copy(&self, cx: ctxt) -> bool {\n+    pub fn is_copy(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::noncopyable(cx))\n     }\n \n-    fn noncopyable(_cx: ctxt) -> TypeContents {\n+    pub fn noncopyable(_cx: ctxt) -> TypeContents {\n         TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_OWNED_CLOSURE +\n             TC_EMPTY_ENUM\n     }\n \n-    fn is_static(&self, cx: ctxt) -> bool {\n+    pub fn is_static(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::nonstatic(cx))\n     }\n \n-    fn nonstatic(_cx: ctxt) -> TypeContents {\n+    pub fn nonstatic(_cx: ctxt) -> TypeContents {\n         TC_BORROWED_POINTER\n     }\n \n-    fn is_owned(&self, cx: ctxt) -> bool {\n+    pub fn is_owned(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::nonowned(cx))\n     }\n \n-    fn nonowned(_cx: ctxt) -> TypeContents {\n+    pub fn nonowned(_cx: ctxt) -> TypeContents {\n         TC_MANAGED + TC_BORROWED_POINTER + TC_NON_OWNED\n     }\n \n-    fn contains_managed(&self) -> bool {\n+    pub fn contains_managed(&self) -> bool {\n         self.intersects(TC_MANAGED)\n     }\n \n-    fn is_const(&self, cx: ctxt) -> bool {\n+    pub fn is_const(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::nonconst(cx))\n     }\n \n-    fn nonconst(_cx: ctxt) -> TypeContents {\n+    pub fn nonconst(_cx: ctxt) -> TypeContents {\n         TC_MUTABLE\n     }\n \n-    fn is_sized(&self, cx: ctxt) -> bool {\n+    pub fn is_sized(&self, cx: ctxt) -> bool {\n         !self.intersects(TypeContents::dynamically_sized(cx))\n     }\n \n-    fn dynamically_sized(_cx: ctxt) -> TypeContents {\n+    pub fn dynamically_sized(_cx: ctxt) -> TypeContents {\n         TC_DYNAMIC_SIZE\n     }\n \n-    fn moves_by_default(&self, cx: ctxt) -> bool {\n+    pub fn moves_by_default(&self, cx: ctxt) -> bool {\n         self.intersects(TypeContents::nonimplicitly_copyable(cx))\n     }\n \n-    fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n+    pub fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n         TypeContents::noncopyable(cx) + TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n \n-    fn needs_drop(&self, cx: ctxt) -> bool {\n+    pub fn needs_drop(&self, cx: ctxt) -> bool {\n         let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n         self.intersects(tc)\n     }\n \n-    fn owned(_cx: ctxt) -> TypeContents {\n+    pub fn owned(_cx: ctxt) -> TypeContents {\n         //! Any kind of owned contents.\n         TC_OWNED_CLOSURE + TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n@@ -3120,8 +3121,8 @@ pub fn adjust_ty(cx: ctxt,\n     }\n }\n \n-pub impl AutoRef {\n-    fn map_region(&self, f: &fn(Region) -> Region) -> AutoRef {\n+impl AutoRef {\n+    pub fn map_region(&self, f: &fn(Region) -> Region) -> AutoRef {\n         match *self {\n             ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n             ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n@@ -3809,14 +3810,15 @@ pub enum DtorKind {\n     TraitDtor(def_id)\n }\n \n-pub impl DtorKind {\n-    fn is_not_present(&const self) -> bool {\n+impl DtorKind {\n+    pub fn is_not_present(&const self) -> bool {\n         match *self {\n             NoDtor => true,\n             _ => false\n         }\n     }\n-    fn is_present(&const self) -> bool {\n+\n+    pub fn is_present(&const self) -> bool {\n         !self.is_not_present()\n     }\n }"}, {"sha": "9b8393a7464bf17c72b93a043589bac1935e38b0", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 71, "deletions": 84, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -179,8 +179,8 @@ pub struct Candidate {\n     origin: method_origin,\n }\n \n-pub impl<'self> LookupContext<'self> {\n-    fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n+impl<'self> LookupContext<'self> {\n+    pub fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let self_ty = structurally_resolved_type(self.fcx,\n                                                      self.self_expr.span,\n                                                      self_ty);\n@@ -248,8 +248,8 @@ pub impl<'self> LookupContext<'self> {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    fn deref(&self, ty: ty::t, enum_dids: &mut ~[ast::def_id])\n-            -> Option<ty::t> {\n+    pub fn deref(&self, ty: ty::t, enum_dids: &mut ~[ast::def_id])\n+                 -> Option<ty::t> {\n         match ty::get(ty).sty {\n             ty_enum(did, _) => {\n                 // Watch out for newtype'd enums like \"enum t = @T\".\n@@ -275,7 +275,7 @@ pub impl<'self> LookupContext<'self> {\n     // ______________________________________________________________________\n     // Candidate collection (see comment at start of file)\n \n-    fn push_inherent_candidates(&self, self_ty: ty::t) {\n+    pub fn push_inherent_candidates(&self, self_ty: ty::t) {\n         /*!\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n@@ -326,7 +326,7 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn push_extension_candidates(&self, self_ty: ty::t) {\n+    pub fn push_extension_candidates(&self, self_ty: ty::t) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n@@ -359,9 +359,9 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn push_inherent_candidates_from_param(&self,\n-                                           rcvr_ty: ty::t,\n-                                           param_ty: param_ty) {\n+    pub fn push_inherent_candidates_from_param(&self,\n+                                               rcvr_ty: ty::t,\n+                                               param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n                param_ty);\n         let _indenter = indenter();\n@@ -417,11 +417,11 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn push_inherent_candidates_from_trait(&self,\n-                                           self_ty: ty::t,\n-                                           did: def_id,\n-                                           substs: &ty::substs,\n-                                           store: ty::TraitStore) {\n+    pub fn push_inherent_candidates_from_trait(&self,\n+                                               self_ty: ty::t,\n+                                               did: def_id,\n+                                               substs: &ty::substs,\n+                                               store: ty::TraitStore) {\n         debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n@@ -469,10 +469,10 @@ pub impl<'self> LookupContext<'self> {\n         });\n     }\n \n-    fn push_inherent_candidates_from_self(&self,\n-                                          self_ty: ty::t,\n-                                          did: def_id,\n-                                          substs: &ty::substs) {\n+    pub fn push_inherent_candidates_from_self(&self,\n+                                              self_ty: ty::t,\n+                                              did: def_id,\n+                                              substs: &ty::substs) {\n         struct MethodInfo {\n             method_ty: @ty::Method,\n             trait_def_id: ast::def_id,\n@@ -533,7 +533,7 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n+    pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos =\n             self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n         for opt_impl_infos.each |impl_infos| {\n@@ -544,8 +544,9 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn push_candidates_from_impl(&self, candidates: &mut ~[Candidate],\n-                                 impl_info: &resolve::Impl) {\n+    pub fn push_candidates_from_impl(&self,\n+                                     candidates: &mut ~[Candidate],\n+                                     impl_info: &resolve::Impl) {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n@@ -579,12 +580,14 @@ pub impl<'self> LookupContext<'self> {\n         });\n     }\n \n-    fn push_candidates_from_provided_methods(\n-            &self,\n-            candidates: &mut ~[Candidate],\n-            self_ty: ty::t,\n-            trait_def_id: def_id,\n-            methods: &mut ~[@ProvidedMethodInfo]) {\n+    pub fn push_candidates_from_provided_methods(&self,\n+                                                 candidates:\n+                                                 &mut ~[Candidate],\n+                                                 self_ty: ty::t,\n+                                                 trait_def_id: def_id,\n+                                                 methods:\n+                                                 &mut ~[@ProvidedMethodInfo])\n+                                                 {\n         debug!(\"(pushing candidates from provided methods) considering trait \\\n                 id %d:%d\",\n                trait_def_id.crate,\n@@ -618,12 +621,10 @@ pub impl<'self> LookupContext<'self> {\n     // ______________________________________________________________________\n     // Candidate selection (see comment at start of file)\n \n-    fn search_for_autoderefd_method(\n-        &self,\n-        self_ty: ty::t,\n-        autoderefs: uint)\n-        -> Option<method_map_entry>\n-    {\n+    pub fn search_for_autoderefd_method(&self,\n+                                        self_ty: ty::t,\n+                                        autoderefs: uint)\n+                                        -> Option<method_map_entry> {\n         let (self_ty, autoadjust) =\n             self.consider_reborrow(self_ty, autoderefs);\n         match self.search_for_method(self_ty) {\n@@ -639,10 +640,10 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn consider_reborrow(&self,\n-                         self_ty: ty::t,\n-                         autoderefs: uint) -> (ty::t, ty::AutoAdjustment)\n-    {\n+    pub fn consider_reborrow(&self,\n+                             self_ty: ty::t,\n+                             autoderefs: uint)\n+                             -> (ty::t, ty::AutoAdjustment) {\n         /*!\n          *\n          * In the event that we are invoking a method with a receiver\n@@ -702,12 +703,10 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn search_for_autosliced_method(\n-        &self,\n-        self_ty: ty::t,\n-        autoderefs: uint)\n-        -> Option<method_map_entry>\n-    {\n+    pub fn search_for_autosliced_method(&self,\n+                                        self_ty: ty::t,\n+                                        autoderefs: uint)\n+                                        -> Option<method_map_entry> {\n         /*!\n          *\n          * Searches for a candidate by converting things like\n@@ -770,12 +769,8 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn search_for_autoptrd_method(\n-        &self,\n-        self_ty: ty::t,\n-        autoderefs: uint)\n-        -> Option<method_map_entry>\n-    {\n+    pub fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n+                                      -> Option<method_map_entry> {\n         /*!\n          *\n          * Converts any type `T` to `&M T` where `M` is an\n@@ -806,14 +801,13 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn search_for_some_kind_of_autorefd_method(\n+    pub fn search_for_some_kind_of_autorefd_method(\n         &self,\n         kind: &fn(Region, ast::mutability) -> ty::AutoRef,\n         autoderefs: uint,\n         mutbls: &[ast::mutability],\n         mk_autoref_ty: &fn(ast::mutability, ty::Region) -> ty::t)\n-        -> Option<method_map_entry>\n-    {\n+        -> Option<method_map_entry> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region = self.infcx().next_region_var_nb(self.expr.span);\n@@ -834,10 +828,8 @@ pub impl<'self> LookupContext<'self> {\n         return None;\n     }\n \n-    fn search_for_method(&self,\n-                         rcvr_ty: ty::t)\n-        -> Option<method_map_entry>\n-    {\n+    pub fn search_for_method(&self, rcvr_ty: ty::t)\n+                             -> Option<method_map_entry> {\n         debug!(\"search_for_method(rcvr_ty=%s)\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -864,11 +856,10 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn consider_candidates(&self,\n-                           rcvr_ty: ty::t,\n-                           candidates: &mut ~[Candidate])\n-        -> Option<method_map_entry>\n-    {\n+    pub fn consider_candidates(&self,\n+                               rcvr_ty: ty::t,\n+                               candidates: &mut ~[Candidate])\n+                               -> Option<method_map_entry> {\n         let relevant_candidates =\n             candidates.filter_to_vec(|c| self.is_relevant(rcvr_ty, c));\n \n@@ -890,7 +881,7 @@ pub impl<'self> LookupContext<'self> {\n         Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n-    fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n+    pub fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n         let mut merged = ~[];\n         let mut i = 0;\n         while i < candidates.len() {\n@@ -936,11 +927,8 @@ pub impl<'self> LookupContext<'self> {\n         return merged;\n     }\n \n-    fn confirm_candidate(&self,\n-                         rcvr_ty: ty::t,\n-                         candidate: &Candidate)\n-        -> method_map_entry\n-    {\n+    pub fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n+                             -> method_map_entry {\n         let tcx = self.tcx();\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n \n@@ -1065,10 +1053,9 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn enforce_trait_instance_limitations(&self,\n-                                          method_fty: ty::t,\n-                                          candidate: &Candidate)\n-    {\n+    pub fn enforce_trait_instance_limitations(&self,\n+                                              method_fty: ty::t,\n+                                              candidate: &Candidate) {\n         /*!\n          *\n          * There are some limitations to calling functions through a\n@@ -1099,7 +1086,7 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n+    pub fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n         let bad;\n         match candidate.origin {\n@@ -1121,7 +1108,7 @@ pub impl<'self> LookupContext<'self> {\n \n     // `rcvr_ty` is the type of the expression. It may be a subtype of a\n     // candidate method's `self_ty`.\n-    fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n+    pub fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n         debug!(\"is_relevant(rcvr_ty=%s, candidate=%s)\",\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n@@ -1208,7 +1195,7 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n+    pub fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n         return match *origin {\n             method_static(did) => {\n                 ty::lookup_item_type(self.tcx(), did).ty\n@@ -1230,7 +1217,7 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn report_candidate(&self, idx: uint, origin: &method_origin) {\n+    pub fn report_candidate(&self, idx: uint, origin: &method_origin) {\n         match *origin {\n             method_static(impl_did) => {\n                 self.report_static_candidate(idx, impl_did)\n@@ -1245,7 +1232,7 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn report_static_candidate(&self, idx: uint, did: def_id) {\n+    pub fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::local_crate {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n@@ -1261,15 +1248,15 @@ pub impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn report_param_candidate(&self, idx: uint, did: def_id) {\n+    pub fn report_param_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn report_trait_candidate(&self, idx: uint, did: def_id) {\n+    pub fn report_trait_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the type of the receiver, \\\n@@ -1278,30 +1265,30 @@ pub impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&self) -> @mut infer::InferCtxt {\n+    pub fn infcx(&self) -> @mut infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n \n-    fn tcx(&self) -> ty::ctxt {\n+    pub fn tcx(&self) -> ty::ctxt {\n         self.fcx.tcx()\n     }\n \n-    fn ty_to_str(&self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    fn cand_to_str(&self, cand: &Candidate) -> ~str {\n+    pub fn cand_to_str(&self, cand: &Candidate) -> ~str {\n         fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, origin=%?)\",\n              self.ty_to_str(cand.rcvr_ty),\n              ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n              cand.origin)\n     }\n \n-    fn did_to_str(&self, did: def_id) -> ~str {\n+    pub fn did_to_str(&self, did: def_id) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(&self, s: ~str) -> ! {\n+    pub fn bug(&self, s: ~str) -> ! {\n         self.tcx().sess.bug(s)\n     }\n }"}, {"sha": "ac39e6141653ba9231b9232a3a3d04c679106691", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -186,7 +186,7 @@ pub struct PurityState {\n     priv from_fn: bool\n }\n \n-pub impl PurityState {\n+impl PurityState {\n     pub fn function(purity: ast::purity, def: ast::node_id) -> PurityState {\n         PurityState { def: def, purity: purity, from_fn: true }\n     }\n@@ -658,18 +658,17 @@ impl AstConv for FnCtxt {\n     }\n }\n \n-pub impl FnCtxt {\n-    fn infcx(&self) -> @mut infer::InferCtxt {\n+impl FnCtxt {\n+    pub fn infcx(&self) -> @mut infer::InferCtxt {\n         self.inh.infcx\n     }\n-    fn err_count_since_creation(&self) -> uint {\n+    pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-    fn search_in_scope_regions(\n-        &self,\n-        span: span,\n-        br: ty::bound_region) -> Result<ty::Region, RegionError>\n-    {\n+    pub fn search_in_scope_regions(&self,\n+                                   span: span,\n+                                   br: ty::bound_region)\n+                                   -> Result<ty::Region, RegionError> {\n         let in_scope_regions = self.in_scope_regions;\n         match in_scope_regions.find(br) {\n             Some(r) => result::Ok(r),\n@@ -703,14 +702,14 @@ impl region_scope for FnCtxt {\n     }\n }\n \n-pub impl FnCtxt {\n-    fn tag(&self) -> ~str {\n+impl FnCtxt {\n+    pub fn tag(&self) -> ~str {\n         unsafe {\n             fmt!(\"%x\", transmute(self))\n         }\n     }\n \n-    fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n+    pub fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n         match self.inh.locals.find(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -721,23 +720,23 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n+    pub fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n         fmt!(\"expr(%?:%s)\", expr.id,\n              pprust::expr_to_str(expr, self.tcx().sess.intr()))\n     }\n \n-    fn block_region(&self) -> ty::Region {\n+    pub fn block_region(&self) -> ty::Region {\n         ty::re_scope(self.region_lb)\n     }\n \n     #[inline(always)]\n-    fn write_ty(&self, node_id: ast::node_id, ty: ty::t) {\n+    pub fn write_ty(&self, node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n-    fn write_substs(&self, node_id: ast::node_id, substs: ty::substs) {\n+    pub fn write_substs(&self, node_id: ast::node_id, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n                    node_id,\n@@ -747,18 +746,18 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn write_ty_substs(&self,\n-                       node_id: ast::node_id,\n-                       ty: ty::t,\n-                       substs: ty::substs) {\n+    pub fn write_ty_substs(&self,\n+                           node_id: ast::node_id,\n+                           ty: ty::t,\n+                           substs: ty::substs) {\n         let ty = ty::subst(self.tcx(), &substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n     }\n \n-    fn write_autoderef_adjustment(&self,\n-                                  node_id: ast::node_id,\n-                                  derefs: uint) {\n+    pub fn write_autoderef_adjustment(&self,\n+                                      node_id: ast::node_id,\n+                                      derefs: uint) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n@@ -768,36 +767,36 @@ pub impl FnCtxt {\n         );\n     }\n \n-    fn write_adjustment(&self,\n-                        node_id: ast::node_id,\n-                        adj: @ty::AutoAdjustment) {\n+    pub fn write_adjustment(&self,\n+                            node_id: ast::node_id,\n+                            adj: @ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n-    fn write_nil(&self, node_id: ast::node_id) {\n+    pub fn write_nil(&self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_nil());\n     }\n-    fn write_bot(&self, node_id: ast::node_id) {\n+    pub fn write_bot(&self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_bot());\n     }\n-    fn write_error(@mut self, node_id: ast::node_id) {\n+    pub fn write_error(@mut self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n-    fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n+    pub fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n-    fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n+    pub fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n         expr.repr(self.tcx())\n     }\n \n-    fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n+    pub fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n         pat.repr(self.tcx())\n     }\n \n-    fn expr_ty(&self, ex: @ast::expr) -> ty::t {\n+    pub fn expr_ty(&self, ex: @ast::expr) -> ty::t {\n         match self.inh.node_types.find(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -807,7 +806,8 @@ pub impl FnCtxt {\n             }\n         }\n     }\n-    fn node_ty(&self, id: ast::node_id) -> ty::t {\n+\n+    pub fn node_ty(&self, id: ast::node_id) -> ty::t {\n         match self.inh.node_types.find(&id) {\n             Some(&t) => t,\n             None => {\n@@ -820,7 +820,8 @@ pub impl FnCtxt {\n             }\n         }\n     }\n-    fn node_ty_substs(&self, id: ast::node_id) -> ty::substs {\n+\n+    pub fn node_ty_substs(&self, id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(&id) {\n             Some(ts) => (/*bad*/copy *ts),\n             None => {\n@@ -834,32 +835,32 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn opt_node_ty_substs(&self, id: ast::node_id,\n-                          f: &fn(&ty::substs) -> bool) -> bool {\n+    pub fn opt_node_ty_substs(&self,\n+                              id: ast::node_id,\n+                              f: &fn(&ty::substs) -> bool)\n+                              -> bool {\n         match self.inh.node_type_substs.find(&id) {\n             Some(s) => f(s),\n             None => true\n         }\n     }\n \n-    fn mk_subty(&self,\n-                a_is_expected: bool,\n-                span: span,\n-                sub: ty::t,\n-                sup: ty::t)\n-             -> Result<(), ty::type_err> {\n+    pub fn mk_subty(&self,\n+                    a_is_expected: bool,\n+                    span: span,\n+                    sub: ty::t,\n+                    sup: ty::t)\n+                    -> Result<(), ty::type_err> {\n         infer::mk_subty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn can_mk_subty(&self,\n-                    sub: ty::t,\n-                    sup: ty::t)\n-                 -> Result<(), ty::type_err> {\n+    pub fn can_mk_subty(&self, sub: ty::t, sup: ty::t)\n+                        -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    fn mk_assignty(&self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n-                -> Result<(), ty::type_err> {\n+    pub fn mk_assignty(&self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n+                       -> Result<(), ty::type_err> {\n         match infer::mk_coercety(self.infcx(), false, expr.span, sub, sup) {\n             Ok(None) => result::Ok(()),\n             Err(ref e) => result::Err((*e)),\n@@ -870,59 +871,58 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn can_mk_assignty(&self,\n-                       sub: ty::t,\n-                       sup: ty::t)\n-                    -> Result<(), ty::type_err> {\n+    pub fn can_mk_assignty(&self, sub: ty::t, sup: ty::t)\n+                           -> Result<(), ty::type_err> {\n         infer::can_mk_coercety(self.infcx(), sub, sup)\n     }\n \n-    fn mk_eqty(&self,\n-               a_is_expected: bool,\n-               span: span,\n-               sub: ty::t,\n-               sup: ty::t)\n-            -> Result<(), ty::type_err> {\n+    pub fn mk_eqty(&self,\n+                   a_is_expected: bool,\n+                   span: span,\n+                   sub: ty::t,\n+                   sup: ty::t)\n+                   -> Result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn mk_subr(&self,\n-               a_is_expected: bool,\n-               span: span,\n-               sub: ty::Region,\n-               sup: ty::Region)\n-            -> Result<(), ty::type_err> {\n+    pub fn mk_subr(&self,\n+                   a_is_expected: bool,\n+                   span: span,\n+                   sub: ty::Region,\n+                   sup: ty::Region)\n+                   -> Result<(), ty::type_err> {\n         infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R) -> R {\n+    pub fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R)\n+                             -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n         let v = f();\n         self.region_lb = old_region_lb;\n         v\n     }\n \n-    fn region_var_if_parameterized(&self,\n-                                   rp: Option<ty::region_variance>,\n-                                   span: span)\n-                                -> Option<ty::Region> {\n+    pub fn region_var_if_parameterized(&self,\n+                                       rp: Option<ty::region_variance>,\n+                                       span: span)\n+                                       -> Option<ty::Region> {\n         rp.map(|_rp| self.infcx().next_region_var_nb(span))\n     }\n \n-    fn type_error_message(&self,\n-                          sp: span,\n-                          mk_msg: &fn(~str) -> ~str,\n-                          actual_ty: ty::t,\n-                          err: Option<&ty::type_err>) {\n+    pub fn type_error_message(&self,\n+                              sp: span,\n+                              mk_msg: &fn(~str) -> ~str,\n+                              actual_ty: ty::t,\n+                              err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n-    fn report_mismatched_return_types(&self,\n-                                      sp: span,\n-                                      e: ty::t,\n-                                      a: ty::t,\n-                                      err: &ty::type_err) {\n+    pub fn report_mismatched_return_types(&self,\n+                                          sp: span,\n+                                          e: ty::t,\n+                                          a: ty::t,\n+                                          err: &ty::type_err) {\n         // Derived error\n         if ty::type_is_error(e) || ty::type_is_error(a) {\n             return;\n@@ -943,11 +943,11 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn report_mismatched_types(&self,\n-                               sp: span,\n-                               e: ty::t,\n-                               a: ty::t,\n-                               err: &ty::type_err) {\n+    pub fn report_mismatched_types(&self,\n+                                   sp: span,\n+                                   e: ty::t,\n+                                   a: ty::t,\n+                                   err: &ty::type_err) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n }"}, {"sha": "4c088cd9cbdc4d485b7842e670d2c5f45e6ceb08", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -74,12 +74,12 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     }\n }\n \n-pub impl Rcx {\n-    fn tcx(&self) -> ty::ctxt {\n+impl Rcx {\n+    pub fn tcx(&self) -> ty::ctxt {\n         self.fcx.ccx.tcx\n     }\n \n-    fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n+    pub fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -116,12 +116,12 @@ pub impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(@mut self, id: ast::node_id) -> ty::t {\n+    pub fn resolve_node_type(@mut self, id: ast::node_id) -> ty::t {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n+    pub fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n             ty_unadjusted"}, {"sha": "9333d2e7b9d8d13636810e6d69a0a0744708d6d1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -65,8 +65,8 @@ pub struct VtableContext {\n     infcx: @mut infer::InferCtxt\n }\n \n-pub impl VtableContext {\n-    fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n+impl VtableContext {\n+    pub fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {"}, {"sha": "00454d658489bec5301e3a95920090b8c011b565", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -199,8 +199,8 @@ pub struct CoherenceChecker {\n     base_type_def_ids: @mut HashMap<def_id,def_id>,\n }\n \n-pub impl CoherenceChecker {\n-    fn check_coherence(self, crate: @crate) {\n+impl CoherenceChecker {\n+    pub fn check_coherence(self, crate: @crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n@@ -239,8 +239,9 @@ pub impl CoherenceChecker {\n         self.populate_destructor_table();\n     }\n \n-    fn check_implementation(&self,\n-                            item: @item, associated_traits: ~[@trait_ref]) {\n+    pub fn check_implementation(&self,\n+                                item: @item,\n+                                associated_traits: ~[@trait_ref]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n@@ -325,9 +326,9 @@ pub impl CoherenceChecker {\n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(&self,\n-                                   impl_id: ast::node_id,\n-                                   trait_ref: &ty::TraitRef) {\n+    pub fn instantiate_default_methods(&self,\n+                                       impl_id: ast::node_id,\n+                                       trait_ref: &ty::TraitRef) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n                impl_id, trait_ref.repr(tcx));\n@@ -416,8 +417,9 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn add_inherent_method(&self,\n-                           base_def_id: def_id, implementation: @Impl) {\n+    pub fn add_inherent_method(&self,\n+                               base_def_id: def_id,\n+                               implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods\n                   .find(&base_def_id) {\n@@ -434,7 +436,7 @@ pub impl CoherenceChecker {\n         implementation_list.push(implementation);\n     }\n \n-    fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {\n+    pub fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.extension_methods\n                   .find(&trait_id) {\n@@ -451,15 +453,14 @@ pub impl CoherenceChecker {\n         implementation_list.push(implementation);\n     }\n \n-    fn check_implementation_coherence(&self) {\n+    pub fn check_implementation_coherence(&self) {\n         let coherence_info = self.crate_context.coherence_info;\n         for coherence_info.extension_methods.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n \n-    fn check_implementation_coherence_of(&self, trait_def_id: def_id) {\n-\n+    pub fn check_implementation_coherence_of(&self, trait_def_id: def_id) {\n         // Unify pairs of polytypes.\n         do self.iter_impls_of_trait(trait_def_id) |a| {\n             let implementation_a = a;\n@@ -492,8 +493,10 @@ pub impl CoherenceChecker {\n \n     // Adds an impl of trait trait_t for self type self_t; that impl\n     // is the_impl\n-    fn add_impl_for_trait(&self,\n-                          trait_t: def_id, self_t: t, the_impl: @Impl) {\n+    pub fn add_impl_for_trait(&self,\n+                              trait_t: def_id,\n+                              self_t: t,\n+                              the_impl: @Impl) {\n         debug!(\"Adding impl %? of %? for %s\",\n                the_impl.did, trait_t,\n                ty_to_str(self.crate_context.tcx, self_t));\n@@ -509,7 +512,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n+    pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n         let coherence_info = self.crate_context.coherence_info;\n         let extension_methods = &*coherence_info.extension_methods;\n \n@@ -527,9 +530,10 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn each_provided_trait_method(&self,\n-            trait_did: ast::def_id,\n-            f: &fn(x: @ty::Method) -> bool) -> bool {\n+    pub fn each_provided_trait_method(&self,\n+                                      trait_did: ast::def_id,\n+                                      f: &fn(x: @ty::Method) -> bool)\n+                                      -> bool {\n         // Make a list of all the names of the provided methods.\n         // XXX: This is horrible.\n         let mut provided_method_idents = HashSet::new();\n@@ -548,9 +552,10 @@ pub impl CoherenceChecker {\n         return true;\n     }\n \n-    fn polytypes_unify(&self, polytype_a: ty_param_bounds_and_ty,\n-                       polytype_b: ty_param_bounds_and_ty)\n-                    -> bool {\n+    pub fn polytypes_unify(&self,\n+                           polytype_a: ty_param_bounds_and_ty,\n+                           polytype_b: ty_param_bounds_and_ty)\n+                           -> bool {\n         let universally_quantified_a =\n             self.universally_quantify_polytype(polytype_a);\n         let universally_quantified_b =\n@@ -564,8 +569,9 @@ pub impl CoherenceChecker {\n \n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables. Returns the monotype and the type variables created.\n-    fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n-                                  -> UniversalQuantificationResult {\n+    pub fn universally_quantify_polytype(&self,\n+                                         polytype: ty_param_bounds_and_ty)\n+                                         -> UniversalQuantificationResult {\n         // NDM--this span is bogus.\n         let self_region =\n             polytype.generics.region_param.map(\n@@ -594,11 +600,12 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn can_unify_universally_quantified<'a>\n-            (&self,\n-             a: &'a UniversalQuantificationResult,\n-             b: &'a UniversalQuantificationResult)\n-          -> bool {\n+    pub fn can_unify_universally_quantified<'a>(&self,\n+                                                a: &'a\n+                                                UniversalQuantificationResult,\n+                                                b: &'a\n+                                                UniversalQuantificationResult)\n+                                                -> bool {\n         let mut might_unify = true;\n         let _ = do self.inference_context.probe {\n             let result = self.inference_context.sub(true, dummy_sp())\n@@ -642,13 +649,13 @@ pub impl CoherenceChecker {\n         might_unify\n     }\n \n-    fn get_self_type_for_implementation(&self, implementation: @Impl)\n-                                     -> ty_param_bounds_and_ty {\n+    pub fn get_self_type_for_implementation(&self, implementation: @Impl)\n+                                            -> ty_param_bounds_and_ty {\n         return self.crate_context.tcx.tcache.get_copy(&implementation.did);\n     }\n \n     // Privileged scope checking\n-    fn check_privileged_scopes(self, crate: @crate) {\n+    pub fn check_privileged_scopes(self, crate: @crate) {\n         visit_crate(crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n                 match item.node {\n@@ -698,7 +705,7 @@ pub impl CoherenceChecker {\n         }));\n     }\n \n-    fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n+    pub fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n         let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n@@ -707,10 +714,13 @@ pub impl CoherenceChecker {\n \n     // This check doesn't really have anything to do with coherence. It's\n     // here for historical reasons\n-    fn please_check_that_trait_methods_are_implemented(&self,\n-        all_methods: &mut ~[@MethodInfo],\n-        trait_did: def_id,\n-        trait_ref_span: span) {\n+    pub fn please_check_that_trait_methods_are_implemented(&self,\n+                                                           all_methods:\n+                                                           &mut\n+                                                           ~[@MethodInfo],\n+                                                           trait_did: def_id,\n+                                                           trait_ref_span:\n+                                                           span) {\n \n         let tcx = self.crate_context.tcx;\n \n@@ -774,7 +784,7 @@ pub impl CoherenceChecker {\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n-    fn create_impl_from_item(&self, item: @item) -> @Impl {\n+    pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n                             all_provided_methods: &mut ~[@ProvidedMethodInfo],\n                             sess: driver::session::Session) {\n@@ -844,7 +854,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn span_of_impl(&self, implementation: @Impl) -> span {\n+    pub fn span_of_impl(&self, implementation: @Impl) -> span {\n         assert_eq!(implementation.did.crate, local_crate);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {\n@@ -859,9 +869,10 @@ pub impl CoherenceChecker {\n \n     // External crate handling\n \n-    fn add_impls_for_module(&self, impls_seen: &mut HashSet<def_id>,\n-                            crate_store: @mut CStore,\n-                            module_def_id: def_id) {\n+    pub fn add_impls_for_module(&self,\n+                                impls_seen: &mut HashSet<def_id>,\n+                                crate_store: @mut CStore,\n+                                module_def_id: def_id) {\n         let implementations = get_impls_for_mod(crate_store,\n                                                 module_def_id,\n                                                 None);\n@@ -934,8 +945,8 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn add_default_methods_for_external_trait(&self,\n-                                              trait_def_id: ast::def_id) {\n+    pub fn add_default_methods_for_external_trait(&self,\n+                                                  trait_def_id: ast::def_id) {\n         let tcx = self.crate_context.tcx;\n         let pmm = tcx.provided_methods;\n \n@@ -968,7 +979,7 @@ pub impl CoherenceChecker {\n \n     // Adds implementations and traits from external crates to the coherence\n     // info.\n-    fn add_external_crates(&self) {\n+    pub fn add_external_crates(&self) {\n         let mut impls_seen = HashSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n@@ -1001,7 +1012,7 @@ pub impl CoherenceChecker {\n     // Destructors\n     //\n \n-    fn populate_destructor_table(&self) {\n+    pub fn populate_destructor_table(&self) {\n         let coherence_info = self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();\n@@ -1050,13 +1061,12 @@ pub impl CoherenceChecker {\n     }\n }\n \n-fn subst_receiver_types_in_method_ty(\n-    tcx: ty::ctxt,\n-    impl_id: ast::node_id,\n-    trait_ref: &ty::TraitRef,\n-    new_def_id: ast::def_id,\n-    method: &ty::Method) -> ty::Method\n-{\n+fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n+                                     impl_id: ast::node_id,\n+                                     trait_ref: &ty::TraitRef,\n+                                     new_def_id: ast::def_id,\n+                                     method: &ty::Method)\n+                                     -> ty::Method {\n     /*!\n      * Substitutes the values for the receiver's type parameters\n      * that are found in method, leaving the method's type parameters"}, {"sha": "47f49ade336d1227b1a0597ee978b13860b9cff2", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -86,8 +86,8 @@ use syntax::ast;\n // function.\n pub struct Coerce(CombineFields);\n \n-pub impl Coerce {\n-    fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+impl Coerce {\n+    pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n         debug!(\"Coerce.tys(%s => %s)\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -149,17 +149,17 @@ pub impl Coerce {\n         }\n     }\n \n-    fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+    pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n         match Sub(**self).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n     }\n \n-    fn unpack_actual_value(&self,\n-                           a: ty::t,\n-                           f: &fn(&ty::sty) -> CoerceResult) -> CoerceResult\n-    {\n+    pub fn unpack_actual_value(&self,\n+                               a: ty::t,\n+                               f: &fn(&ty::sty) -> CoerceResult)\n+                               -> CoerceResult {\n         match resolve_type(self.infcx, a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n                 f(&ty::get(t).sty)\n@@ -173,12 +173,12 @@ pub impl Coerce {\n         }\n     }\n \n-    fn coerce_borrowed_pointer(&self,\n-                               a: ty::t,\n-                               sty_a: &ty::sty,\n-                               b: ty::t,\n-                               mt_b: ty::mt) -> CoerceResult\n-    {\n+    pub fn coerce_borrowed_pointer(&self,\n+                                   a: ty::t,\n+                                   sty_a: &ty::sty,\n+                                   b: ty::t,\n+                                   mt_b: ty::mt)\n+                                   -> CoerceResult {\n         debug!(\"coerce_borrowed_pointer(a=%s, sty_a=%?, b=%s, mt_b=%?)\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx), mt_b);\n@@ -211,11 +211,11 @@ pub impl Coerce {\n         })))\n     }\n \n-    fn coerce_borrowed_string(&self,\n-                              a: ty::t,\n-                              sty_a: &ty::sty,\n-                              b: ty::t) -> CoerceResult\n-    {\n+    pub fn coerce_borrowed_string(&self,\n+                                  a: ty::t,\n+                                  sty_a: &ty::sty,\n+                                  b: ty::t)\n+                                  -> CoerceResult {\n         debug!(\"coerce_borrowed_string(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n@@ -237,12 +237,12 @@ pub impl Coerce {\n         })))\n     }\n \n-    fn coerce_borrowed_vector(&self,\n-                              a: ty::t,\n-                              sty_a: &ty::sty,\n-                              b: ty::t,\n-                              mt_b: ty::mt) -> CoerceResult\n-    {\n+    pub fn coerce_borrowed_vector(&self,\n+                                  a: ty::t,\n+                                  sty_a: &ty::sty,\n+                                  b: ty::t,\n+                                  mt_b: ty::mt)\n+                                  -> CoerceResult {\n         debug!(\"coerce_borrowed_vector(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n@@ -266,11 +266,11 @@ pub impl Coerce {\n         })))\n     }\n \n-    fn coerce_borrowed_fn(&self,\n-                          a: ty::t,\n-                          sty_a: &ty::sty,\n-                          b: ty::t) -> CoerceResult\n-    {\n+    pub fn coerce_borrowed_fn(&self,\n+                              a: ty::t,\n+                              sty_a: &ty::sty,\n+                              b: ty::t)\n+                              -> CoerceResult {\n         debug!(\"coerce_borrowed_fn(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n@@ -302,22 +302,22 @@ pub impl Coerce {\n         })))\n     }\n \n-    fn coerce_from_bare_fn(&self,\n-                           a: ty::t,\n-                           fn_ty_a: &ty::BareFnTy,\n-                           b: ty::t) -> CoerceResult\n-    {\n+    pub fn coerce_from_bare_fn(&self,\n+                               a: ty::t,\n+                               fn_ty_a: &ty::BareFnTy,\n+                               b: ty::t)\n+                               -> CoerceResult {\n         do self.unpack_actual_value(b) |sty_b| {\n             self.coerce_from_bare_fn_post_unpack(a, fn_ty_a, b, sty_b)\n         }\n     }\n \n-    fn coerce_from_bare_fn_post_unpack(&self,\n-                                       a: ty::t,\n-                                       fn_ty_a: &ty::BareFnTy,\n-                                       b: ty::t,\n-                                       sty_b: &ty::sty) -> CoerceResult\n-    {\n+    pub fn coerce_from_bare_fn_post_unpack(&self,\n+                                           a: ty::t,\n+                                           fn_ty_a: &ty::BareFnTy,\n+                                           b: ty::t,\n+                                           sty_b: &ty::sty)\n+                                           -> CoerceResult {\n         /*!\n          *\n          * Attempts to coerce from a bare Rust function (`extern\n@@ -346,12 +346,12 @@ pub impl Coerce {\n         Ok(Some(adj))\n     }\n \n-    fn coerce_unsafe_ptr(&self,\n-                         a: ty::t,\n-                         sty_a: &ty::sty,\n-                         b: ty::t,\n-                         mt_b: ty::mt) -> CoerceResult\n-    {\n+    pub fn coerce_unsafe_ptr(&self,\n+                             a: ty::t,\n+                             sty_a: &ty::sty,\n+                             b: ty::t,\n+                             mt_b: ty::mt)\n+                             -> CoerceResult {\n         debug!(\"coerce_unsafe_ptr(a=%s, sty_a=%?, b=%s)\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));"}, {"sha": "cf3c64e5cd633aa2e564c68f0cd75194616de4d4", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -71,13 +71,15 @@ impl LatticeValue for ty::t {\n     }\n }\n \n-pub impl CombineFields {\n-    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n-                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-        &self,\n-        a_id: V,\n-        b_id: V) -> ures\n-    {\n+impl CombineFields {\n+    pub fn var_sub_var<T:Copy + InferStr + LatticeValue,\n+                       V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                                                                        a_id:\n+                                                                        V,\n+                                                                        b_id:\n+                                                                        V)\n+                                                                        ->\n+                                                                        ures {\n         /*!\n          *\n          * Make one variable a subtype of another variable.  This is a\n@@ -125,12 +127,12 @@ pub impl CombineFields {\n     }\n \n     /// make variable a subtype of T\n-    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n-                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-        &self,\n-        a_id: V,\n-        b: T) -> ures\n-    {\n+    pub fn var_sub_t<T:Copy + InferStr + LatticeValue,\n+                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                                                                      a_id: V,\n+                                                                      b: T)\n+                                                                      -> ures\n+                                                                      {\n         /*!\n          *\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n@@ -149,12 +151,12 @@ pub impl CombineFields {\n             a_id, a_bounds, b_bounds, node_a.rank)\n     }\n \n-    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n-                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-        &self,\n-        a: T,\n-        b_id: V) -> ures\n-    {\n+    pub fn t_sub_var<T:Copy + InferStr + LatticeValue,\n+                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                                                                      a: T,\n+                                                                      b_id: V)\n+                                                                      -> ures\n+                                                                      {\n         /*!\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n@@ -173,13 +175,12 @@ pub impl CombineFields {\n             b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n-    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n-        &self,\n-        a: &Bound<T>,\n-        b: &Bound<T>,\n-        lattice_op: LatticeOp<T>)\n-        -> cres<Bound<T>>\n-    {\n+    pub fn merge_bnd<T:Copy + InferStr + LatticeValue>(&self,\n+                                                       a: &Bound<T>,\n+                                                       b: &Bound<T>,\n+                                                       lattice_op:\n+                                                       LatticeOp<T>)\n+                                                       -> cres<Bound<T>> {\n         /*!\n          *\n          * Combines two bounds into a more general bound. */\n@@ -201,14 +202,14 @@ pub impl CombineFields {\n         }\n     }\n \n-    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n-                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n-        &self,\n-        v_id: V,\n-        a: &Bounds<T>,\n-        b: &Bounds<T>,\n-        rank: uint) -> ures\n-    {\n+    pub fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n+                                    V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                    &self,\n+                                    v_id: V,\n+                                    a: &Bounds<T>,\n+                                    b: &Bounds<T>,\n+                                    rank: uint)\n+                                    -> ures {\n         /*!\n          *\n          * Updates the bounds for the variable `v_id` to be the intersection\n@@ -263,11 +264,10 @@ pub impl CombineFields {\n         uok()\n     }\n \n-    fn bnds<T:Copy + InferStr + LatticeValue>(\n-        &self,\n-        a: &Bound<T>,\n-        b: &Bound<T>) -> ures\n-    {\n+    pub fn bnds<T:Copy + InferStr + LatticeValue>(&self,\n+                                                  a: &Bound<T>,\n+                                                  b: &Bound<T>)\n+                                                  -> ures {\n         debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();"}, {"sha": "1a73d5bd36bbb7df5a4a3a80da38017dfa60df90", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -34,10 +34,11 @@ use syntax::codemap::span;\n \n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n-pub impl Lub {\n-    fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }\n-    fn ty_bot(&self, b: ty::t)\n-             -> cres<ty::t> { self.bot_ty(b) } // commutative\n+impl Lub {\n+    pub fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }\n+    pub fn ty_bot(&self, b: ty::t) -> cres<ty::t> {\n+        self.bot_ty(b) // commutative\n+    }\n }\n \n impl Combine for Lub {"}, {"sha": "00e5415e0414aa9ba0f696ed5de3868531c90a6d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -535,24 +535,23 @@ struct Snapshot {\n     region_vars_snapshot: uint,\n }\n \n-pub impl InferCtxt {\n-    fn combine_fields(@mut self,\n-                      a_is_expected: bool,\n-                      span: span) -> CombineFields {\n+impl InferCtxt {\n+    pub fn combine_fields(@mut self, a_is_expected: bool, span: span)\n+                          -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        span: span}\n     }\n \n-    fn sub(@mut self, a_is_expected: bool, span: span) -> Sub {\n+    pub fn sub(@mut self, a_is_expected: bool, span: span) -> Sub {\n         Sub(self.combine_fields(a_is_expected, span))\n     }\n \n-    fn in_snapshot(&self) -> bool {\n+    pub fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    fn start_snapshot(&mut self) -> Snapshot {\n+    pub fn start_snapshot(&mut self) -> Snapshot {\n         Snapshot {\n             ty_var_bindings_len:\n                 self.ty_var_bindings.bindings.len(),\n@@ -565,7 +564,7 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn rollback_to(&mut self, snapshot: &Snapshot) {\n+    pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n@@ -578,7 +577,7 @@ pub impl InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -593,7 +592,7 @@ pub impl InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -607,7 +606,7 @@ pub impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -628,8 +627,8 @@ fn next_simple_var<V:Copy,T:Copy>(\n     return id;\n }\n \n-pub impl InferCtxt {\n-    fn next_ty_var_id(&mut self) -> TyVid {\n+impl InferCtxt {\n+    pub fn next_ty_var_id(&mut self) -> TyVid {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n         {\n@@ -639,38 +638,40 @@ pub impl InferCtxt {\n         return TyVid(id);\n     }\n \n-    fn next_ty_var(&mut self) -> ty::t {\n+    pub fn next_ty_var(&mut self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    fn next_ty_vars(&mut self, n: uint) -> ~[ty::t] {\n+    pub fn next_ty_vars(&mut self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_int_var_id(&mut self) -> IntVid {\n+    pub fn next_int_var_id(&mut self) -> IntVid {\n         IntVid(next_simple_var(&mut self.int_var_counter,\n                                &mut self.int_var_bindings))\n     }\n \n-    fn next_int_var(&mut self) -> ty::t {\n+    pub fn next_int_var(&mut self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    fn next_float_var_id(&mut self) -> FloatVid {\n+    pub fn next_float_var_id(&mut self) -> FloatVid {\n         FloatVid(next_simple_var(&mut self.float_var_counter,\n                                  &mut self.float_var_bindings))\n     }\n \n-    fn next_float_var(&mut self) -> ty::t {\n+    pub fn next_float_var(&mut self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    fn next_region_var_nb(&mut self, span: span) -> ty::Region {\n+    pub fn next_region_var_nb(&mut self, span: span) -> ty::Region {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }\n \n-    fn next_region_var_with_lb(&mut self, span: span,\n-                               lb_region: ty::Region) -> ty::Region {\n+    pub fn next_region_var_with_lb(&mut self,\n+                                   span: span,\n+                                   lb_region: ty::Region)\n+                                   -> ty::Region {\n         let region_var = self.next_region_var_nb(span);\n \n         // add lb_region as a lower bound on the newly built variable\n@@ -681,35 +682,36 @@ pub impl InferCtxt {\n         return region_var;\n     }\n \n-    fn next_region_var(&mut self, span: span, scope_id: ast::node_id)\n-                      -> ty::Region {\n+    pub fn next_region_var(&mut self, span: span, scope_id: ast::node_id)\n+                           -> ty::Region {\n         self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n     }\n \n-    fn resolve_regions(&mut self) {\n+    pub fn resolve_regions(&mut self) {\n         self.region_vars.resolve_regions();\n     }\n \n-    fn ty_to_str(@mut self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n+    pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)\n     }\n \n-    fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n-    fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n-                                                  trait_ref: &ty::TraitRef)\n-        -> ty::TraitRef\n-    {\n+\n+    pub fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n+                                                      trait_ref:\n+                                                      &ty::TraitRef)\n+                                                      -> ty::TraitRef {\n         // make up a dummy type just to reuse/abuse the resolve machinery\n         let dummy0 = ty::mk_trait(self.tcx,\n                                   trait_ref.def_id,\n@@ -732,18 +734,22 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn type_error_message_str(@mut self,\n-                              sp: span,\n-                              mk_msg: &fn(Option<~str>, ~str) -> ~str,\n-                              actual_ty: ~str, err: Option<&ty::type_err>) {\n+    pub fn type_error_message_str(@mut self,\n+                                  sp: span,\n+                                  mk_msg: &fn(Option<~str>, ~str) -> ~str,\n+                                  actual_ty: ~str,\n+                                  err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n-    fn type_error_message_str_with_expected(@mut self,\n-                                            sp: span,\n-                                            mk_msg: &fn(Option<~str>, ~str) -> ~str,\n-                                            expected_ty: Option<ty::t>, actual_ty: ~str,\n-                                            err: Option<&ty::type_err>) {\n+    pub fn type_error_message_str_with_expected(@mut self,\n+                                                sp: span,\n+                                                mk_msg:\n+                                                &fn(Option<~str>, ~str) ->\n+                                                ~str,\n+                                                expected_ty: Option<ty::t>,\n+                                                actual_ty: ~str,\n+                                                err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = %?, actual_ty = %s\", expected_ty, actual_ty);\n \n         let error_str = err.map_default(~\"\", |t_err|\n@@ -766,11 +772,11 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn type_error_message(@mut self,\n-                          sp: span,\n-                          mk_msg: &fn(~str) -> ~str,\n-                          actual_ty: ty::t,\n-                          err: Option<&ty::type_err>) {\n+    pub fn type_error_message(@mut self,\n+                              sp: span,\n+                              mk_msg: &fn(~str) -> ~str,\n+                              actual_ty: ty::t,\n+                              err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n@@ -781,8 +787,11 @@ pub impl InferCtxt {\n         self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_str(actual_ty), err);\n     }\n \n-    fn report_mismatched_types(@mut self, sp: span, e: ty::t, a: ty::t,\n-                               err: &ty::type_err) {\n+    pub fn report_mismatched_types(@mut self,\n+                                   sp: span,\n+                                   e: ty::t,\n+                                   a: ty::t,\n+                                   err: &ty::type_err) {\n         let resolved_expected =\n             self.resolve_type_vars_if_possible(e);\n         let mk_msg = match ty::get(resolved_expected).sty {\n@@ -799,10 +808,11 @@ pub impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    fn replace_bound_regions_with_fresh_regions(&mut self,\n-            span: span,\n-            fsig: &ty::FnSig)\n-         -> (ty::FnSig, isr_alist) {\n+    pub fn replace_bound_regions_with_fresh_regions(&mut self,\n+                                                    span: span,\n+                                                    fsig: &ty::FnSig)\n+                                                    -> (ty::FnSig,\n+                                                        isr_alist) {\n         let(isr, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 // N.B.: The name of the bound region doesn't have anything to"}, {"sha": "f99d096f03d752984c319819167d2f8902fcb4ce", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 68, "deletions": 78, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -643,12 +643,12 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     }\n }\n \n-pub impl RegionVarBindings {\n-    fn in_snapshot(&self) -> bool {\n+impl RegionVarBindings {\n+    pub fn in_snapshot(&self) -> bool {\n         self.undo_log.len() > 0\n     }\n \n-    fn start_snapshot(&mut self) -> uint {\n+    pub fn start_snapshot(&mut self) -> uint {\n         debug!(\"RegionVarBindings: snapshot()=%u\", self.undo_log.len());\n         if self.in_snapshot() {\n             self.undo_log.len()\n@@ -658,14 +658,14 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn commit(&mut self) {\n+    pub fn commit(&mut self) {\n         debug!(\"RegionVarBindings: commit()\");\n         while self.undo_log.len() > 0 {\n             self.undo_log.pop();\n         }\n     }\n \n-    fn rollback_to(&mut self, snapshot: uint) {\n+    pub fn rollback_to(&mut self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to(%u)\", snapshot);\n         while self.undo_log.len() > snapshot {\n             let undo_item = self.undo_log.pop();\n@@ -689,11 +689,11 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn num_vars(&mut self) -> uint {\n+    pub fn num_vars(&mut self) -> uint {\n         self.var_spans.len()\n     }\n \n-    fn new_region_var(&mut self, span: span) -> RegionVid {\n+    pub fn new_region_var(&mut self, span: span) -> RegionVid {\n         let id = self.num_vars();\n         self.var_spans.push(span);\n         let vid = RegionVid { id: id };\n@@ -705,13 +705,13 @@ pub impl RegionVarBindings {\n         return vid;\n     }\n \n-    fn new_skolemized(&mut self, br: ty::bound_region) -> Region {\n+    pub fn new_skolemized(&mut self, br: ty::bound_region) -> Region {\n         let sc = self.skolemization_count;\n         self.skolemization_count += 1;\n         re_infer(ReSkolemized(sc, br))\n     }\n \n-    fn new_bound(&mut self) -> Region {\n+    pub fn new_bound(&mut self) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -731,7 +731,7 @@ pub impl RegionVarBindings {\n         re_bound(br_fresh(sc))\n     }\n \n-    fn add_constraint(&mut self, constraint: Constraint, span: span) {\n+    pub fn add_constraint(&mut self, constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n@@ -744,10 +744,8 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn make_subregion(&mut self,\n-                      span: span,\n-                      sub: Region,\n-                      sup: Region) -> cres<()> {\n+    pub fn make_subregion(&mut self, span: span, sub: Region, sup: Region)\n+                          -> cres<()> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n@@ -785,11 +783,8 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn lub_regions(&mut self,\n-                   span: span,\n-                   a: Region,\n-                   b: Region)\n-                -> cres<Region> {\n+    pub fn lub_regions(&mut self, span: span, a: Region, b: Region)\n+                       -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n@@ -811,11 +806,8 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn glb_regions(&mut self,\n-                   span: span,\n-                   a: Region,\n-                   b: Region)\n-                -> cres<Region> {\n+    pub fn glb_regions(&mut self, span: span, a: Region, b: Region)\n+                       -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n@@ -838,7 +830,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n+    pub fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n                 self.var_spans[rid.to_uint()],\n@@ -864,15 +856,15 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn combine_vars(&mut self,\n-                    t: CombineMapType,\n-                    a: Region,\n-                    b: Region,\n-                    span: span,\n-                    relate: &fn(this: &mut RegionVarBindings,\n-                                old_r: Region,\n-                                new_r: Region) -> cres<()>)\n-                 -> cres<Region> {\n+    pub fn combine_vars(&mut self,\n+                        t: CombineMapType,\n+                        a: Region,\n+                        b: Region,\n+                        span: span,\n+                        relate: &fn(this: &mut RegionVarBindings,\n+                                    old_r: Region,\n+                                    new_r: Region) -> cres<()>)\n+                        -> cres<Region> {\n         let vars = TwoRegions { a: a, b: b };\n         let c;\n         {\n@@ -906,9 +898,8 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn vars_created_since_snapshot(&mut self,\n-                                   snapshot: uint)\n-                                -> ~[RegionVid] {\n+    pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n+                                       -> ~[RegionVid] {\n         do vec::build |push| {\n             for uint::range(snapshot, self.undo_log.len()) |i| {\n                 match self.undo_log[i] {\n@@ -919,7 +910,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn tainted(&mut self, snapshot: uint, r0: Region) -> ~[Region] {\n+    pub fn tainted(&mut self, snapshot: uint, r0: Region) -> ~[Region] {\n         /*!\n          *\n          * Computes all regions that have been related to `r0` in any\n@@ -1003,14 +994,14 @@ pub impl RegionVarBindings {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    fn resolve_regions(&mut self) {\n+    pub fn resolve_regions(&mut self) {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let v = self.infer_variable_values();\n         self.values.put_back(v);\n     }\n }\n \n-priv impl RegionVarBindings {\n+impl RegionVarBindings {\n     fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n         let rm = self.tcx.region_maps;\n         rm.is_subregion_of(sub, sup)\n@@ -1266,15 +1257,15 @@ struct SpannedRegion {\n     span: span,\n }\n \n-pub impl RegionVarBindings {\n-    fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n+impl RegionVarBindings {\n+    pub fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n         let mut graph = self.construct_graph();\n         self.expansion(&mut graph);\n         self.contraction(&mut graph);\n         self.extract_values_and_report_conflicts(&graph)\n     }\n \n-    fn construct_graph(&mut self) -> Graph {\n+    pub fn construct_graph(&mut self) -> Graph {\n         let num_vars = self.num_vars();\n         let num_edges = self.constraints.len();\n \n@@ -1339,7 +1330,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn expansion(&mut self, graph: &mut Graph) {\n+    pub fn expansion(&mut self, graph: &mut Graph) {\n         do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n@@ -1363,11 +1354,11 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn expand_node(&mut self,\n-                   a_region: Region,\n-                   b_vid: RegionVid,\n-                   b_node: &mut GraphNode)\n-                -> bool {\n+    pub fn expand_node(&mut self,\n+                       a_region: Region,\n+                       b_vid: RegionVid,\n+                       b_node: &mut GraphNode)\n+                       -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n                a_region, b_vid, b_node.value);\n \n@@ -1399,7 +1390,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn contraction(&mut self, graph: &mut Graph) {\n+    pub fn contraction(&mut self, graph: &mut Graph) {\n         do iterate_until_fixed_point(~\"Contraction\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(*) => {\n@@ -1423,11 +1414,11 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn contract_node(&mut self,\n-                     a_vid: RegionVid,\n-                     a_node: &mut GraphNode,\n-                     b_region: Region)\n-                  -> bool {\n+    pub fn contract_node(&mut self,\n+                         a_vid: RegionVid,\n+                         a_node: &mut GraphNode,\n+                         b_region: Region)\n+                         -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n                a_vid, a_node.value, a_node.classification, b_region);\n \n@@ -1495,10 +1486,8 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn extract_values_and_report_conflicts(\n-        &mut self,\n-        graph: &Graph) -> ~[GraphNodeValue]\n-    {\n+    pub fn extract_values_and_report_conflicts(&mut self, graph: &Graph)\n+                                               -> ~[GraphNodeValue] {\n         debug!(\"extract_values_and_report_conflicts()\");\n \n         // This is the best way that I have found to suppress\n@@ -1567,10 +1556,10 @@ pub impl RegionVarBindings {\n         })\n     }\n \n-    fn report_error_for_expanding_node(&mut self,\n-                                       graph: &Graph,\n-                                       dup_vec: &mut [uint],\n-                                       node_idx: RegionVid) {\n+    pub fn report_error_for_expanding_node(&mut self,\n+                                           graph: &Graph,\n+                                           dup_vec: &mut [uint],\n+                                           node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (lower_bounds, lower_dup) =\n@@ -1626,10 +1615,10 @@ pub impl RegionVarBindings {\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    fn report_error_for_contracting_node(&mut self,\n-                                         graph: &Graph,\n-                                         dup_vec: &mut [uint],\n-                                         node_idx: RegionVid) {\n+    pub fn report_error_for_contracting_node(&mut self,\n+                                             graph: &Graph,\n+                                             dup_vec: &mut [uint],\n+                                             node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n@@ -1685,12 +1674,12 @@ pub impl RegionVarBindings {\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    fn collect_concrete_regions(&mut self,\n-                                graph: &Graph,\n-                                orig_node_idx: RegionVid,\n-                                dir: Direction,\n-                                dup_vec: &mut [uint])\n-                             -> (~[SpannedRegion], bool) {\n+    pub fn collect_concrete_regions(&mut self,\n+                                    graph: &Graph,\n+                                    orig_node_idx: RegionVid,\n+                                    dir: Direction,\n+                                    dup_vec: &mut [uint])\n+                                    -> (~[SpannedRegion], bool) {\n         struct WalkState {\n             set: HashSet<RegionVid>,\n             stack: ~[RegionVid],\n@@ -1766,11 +1755,12 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn each_edge(&mut self,\n-                 graph: &Graph,\n-                 node_idx: RegionVid,\n-                 dir: Direction,\n-                 op: &fn(edge: &GraphEdge) -> bool) -> bool {\n+    pub fn each_edge(&mut self,\n+                     graph: &Graph,\n+                     node_idx: RegionVid,\n+                     dir: Direction,\n+                     op: &fn(edge: &GraphEdge) -> bool)\n+                     -> bool {\n         let mut edge_idx =\n             graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n         while edge_idx != uint::max_value {"}, {"sha": "c2ee7fc2647bd5da4ad3b5c863f61b6ff79d429c", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -98,12 +98,12 @@ pub fn resolver(infcx: @mut InferCtxt, modes: uint) -> ResolveState {\n     }\n }\n \n-pub impl ResolveState {\n-    fn should(&mut self, mode: uint) -> bool {\n+impl ResolveState {\n+    pub fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }\n \n-    fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n+    pub fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n         self.err = None;\n \n         debug!(\"Resolving %s (modes=%x)\",\n@@ -128,7 +128,8 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_region_chk(&mut self, orig: ty::Region) -> fres<ty::Region> {\n+    pub fn resolve_region_chk(&mut self, orig: ty::Region)\n+                              -> fres<ty::Region> {\n         self.err = None;\n         let resolved = indent(|| self.resolve_region(orig) );\n         match self.err {\n@@ -137,7 +138,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n         debug!(\"resolve_type(%s)\", typ.inf_str(self.infcx));\n         let _i = indenter();\n \n@@ -179,22 +180,22 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n+    pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n         debug!(\"Resolve_region(%s)\", orig.inf_str(self.infcx));\n         match orig {\n           ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n-    fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n+    pub fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n             return ty::re_infer(ty::ReVar(rid));\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    fn assert_not_rvar(&mut self, rid: RegionVid, r: ty::Region) {\n+    pub fn assert_not_rvar(&mut self, rid: RegionVid, r: ty::Region) {\n         match r {\n           ty::re_infer(ty::ReVar(rid2)) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n@@ -203,7 +204,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n+    pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n         if vec::contains(self.v_seen, &vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n@@ -237,7 +238,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {\n+    pub fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n@@ -260,7 +261,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_float_var(&mut self, vid: FloatVid) -> ty::t {\n+    pub fn resolve_float_var(&mut self, vid: FloatVid) -> ty::t {\n         if !self.should(resolve_fvar) {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }"}, {"sha": "e6e6753255e749864075e7691bd4517d21c547d0", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -77,15 +77,15 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n                 err_messages: messages};\n }\n \n-pub impl Env {\n-    fn create_region_hierarchy(&self, rh: &RH) {\n+impl Env {\n+    pub fn create_region_hierarchy(&self, rh: &RH) {\n         for rh.sub.each |child_rh| {\n             self.create_region_hierarchy(child_rh);\n             self.tcx.region_map.insert(child_rh.id, rh.id);\n         }\n     }\n \n-    fn create_simple_region_hierarchy(&self) {\n+    pub fn create_simple_region_hierarchy(&self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n         self.create_region_hierarchy(\n@@ -96,7 +96,7 @@ pub impl Env {\n                             sub: &[]}]});\n     }\n \n-    fn lookup_item(&self, names: &[~str]) -> ast::node_id {\n+    pub fn lookup_item(&self, names: &[~str]) -> ast::node_id {\n         return match search_mod(self, &self.crate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n@@ -144,44 +144,44 @@ pub impl Env {\n         }\n     }\n \n-    fn is_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+    pub fn is_subtype(&self, a: ty::t, b: ty::t) -> bool {\n         match infer::can_mk_subty(self.infcx, a, b) {\n             Ok(_) => true,\n             Err(_) => false\n         }\n     }\n \n-    fn assert_subtype(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n             fail!(\"%s is not a subtype of %s, but it should be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n-    fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n             fail!(\"%s is a subtype of %s, but it shouldn't be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n-    fn assert_strict_subtype(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_strict_subtype(&self, a: ty::t, b: ty::t) {\n         self.assert_subtype(a, b);\n         self.assert_not_subtype(b, a);\n     }\n \n-    fn assert_eq(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_eq(&self, a: ty::t, b: ty::t) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n     }\n \n-    fn ty_to_str(&self, a: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, a: ty::t) -> ~str {\n         ty_to_str(self.tcx, a)\n     }\n \n-    fn t_fn(&self, input_tys: &[ty::t], output_ty: ty::t) -> ty::t {\n+    pub fn t_fn(&self, input_tys: &[ty::t], output_ty: ty::t) -> ty::t {\n         let inputs = input_tys.map(|t| {mode: ast::expl(ast::by_copy),\n                                         ty: *t});\n         ty::mk_fn(self.tcx, FnTyBase {\n@@ -195,34 +195,34 @@ pub impl Env {\n         })\n     }\n \n-    fn t_int(&self) -> ty::t {\n+    pub fn t_int(&self) -> ty::t {\n         ty::mk_int(self.tcx)\n     }\n \n-    fn t_rptr_bound(&self, id: uint) -> ty::t {\n+    pub fn t_rptr_bound(&self, id: uint) -> ty::t {\n         ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::br_anon(id)), self.t_int())\n     }\n \n-    fn t_rptr_scope(&self, id: ast::node_id) -> ty::t {\n+    pub fn t_rptr_scope(&self, id: ast::node_id) -> ty::t {\n         ty::mk_imm_rptr(self.tcx, ty::re_scope(id), self.t_int())\n     }\n \n-    fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n+    pub fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n         ty::mk_imm_rptr(self.tcx,\n                         ty::re_free(ty::FreeRegion {scope_id: nid,\n                                                     bound_region: ty::br_anon(id)}),\n                         self.t_int())\n     }\n \n-    fn t_rptr_static(&self) -> ty::t {\n+    pub fn t_rptr_static(&self) -> ty::t {\n         ty::mk_imm_rptr(self.tcx, ty::re_static, self.t_int())\n     }\n \n-    fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }\n+    pub fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }\n \n-    fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n+    pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n \n-    fn resolve_regions(exp_count: uint) {\n+    pub fn resolve_regions(exp_count: uint) {\n         debug!(\"resolve_regions(%u)\", exp_count);\n \n         self.infcx.resolve_regions();\n@@ -237,7 +237,7 @@ pub impl Env {\n     }\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n-    fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n+    pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n             Err(e) => {\n                 fail!(\"Unexpected error computing LUB: %?\", e)\n@@ -255,7 +255,7 @@ pub impl Env {\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n-    fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n+    pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n         debug!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n                self.ty_to_str(t1),\n                self.ty_to_str(t2),\n@@ -277,7 +277,7 @@ pub impl Env {\n     }\n \n     /// Checks that `LUB(t1,t2)` is undefined\n-    fn check_no_lub(&self, t1: ty::t, t2: ty::t) {\n+    pub fn check_no_lub(&self, t1: ty::t, t2: ty::t) {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n@@ -287,7 +287,7 @@ pub impl Env {\n     }\n \n     /// Checks that `GLB(t1,t2)` is undefined\n-    fn check_no_glb(&self, t1: ty::t, t2: ty::t) {\n+    pub fn check_no_glb(&self, t1: ty::t, t2: ty::t) {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {"}, {"sha": "c6e4b485d29b530cc93e1ec291b6adfaa7624018", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -40,11 +40,9 @@ pub trait UnifyVid<T> {\n                                       -> &'v mut ValsAndBindings<Self, T>;\n }\n \n-pub impl InferCtxt {\n-    fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(\n-        &mut self,\n-        vid: V) -> Node<V, T>\n-    {\n+impl InferCtxt {\n+    pub fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(&mut self, vid: V)\n+                                                  -> Node<V, T> {\n         /*!\n          *\n          * Find the root node for `vid`. This uses the standard\n@@ -86,10 +84,10 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn set<T:Copy + InferStr,V:Copy + Vid + ToStr + UnifyVid<T>>(\n-            &mut self,\n-            vid: V,\n-            new_v: VarValue<V, T>) {\n+    pub fn set<T:Copy + InferStr,\n+               V:Copy + Vid + ToStr + UnifyVid<T>>(&mut self,\n+                                                   vid: V,\n+                                                   new_v: VarValue<V, T>) {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n@@ -106,11 +104,11 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn unify<T:Copy + InferStr,V:Copy + Vid + ToStr + UnifyVid<T>>(\n-        &mut self,\n-        node_a: &Node<V, T>,\n-        node_b: &Node<V, T>) -> (V, uint)\n-    {\n+    pub fn unify<T:Copy + InferStr,\n+                 V:Copy + Vid + ToStr + UnifyVid<T>>(&mut self,\n+                                                     node_a: &Node<V, T>,\n+                                                     node_b: &Node<V, T>)\n+                                                     -> (V, uint) {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n@@ -159,14 +157,14 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n     }\n }\n \n-pub impl InferCtxt {\n-    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n-                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-            &mut self,\n-            a_is_expected: bool,\n-            a_id: V,\n-            b_id: V)\n-         -> ures {\n+impl InferCtxt {\n+    pub fn simple_vars<T:Copy+Eq+InferStr+SimplyUnifiable,\n+                       V:Copy+Eq+Vid+ToStr+UnifyVid<Option<T>>>(&mut self,\n+                                                                a_is_expected:\n+                                                                bool,\n+                                                                a_id: V,\n+                                                                b_id: V)\n+                                                                -> ures {\n         /*!\n          *\n          * Unifies two simple variables.  Because simple variables do\n@@ -198,13 +196,13 @@ pub impl InferCtxt {\n         return uok();\n     }\n \n-    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n-                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-            &mut self,\n-            a_is_expected: bool,\n-            a_id: V,\n-            b: T)\n-         -> ures {\n+    pub fn simple_var_t<T:Copy+Eq+InferStr+SimplyUnifiable,\n+                        V:Copy+Eq+Vid+ToStr+UnifyVid<Option<T>>>(&mut self,\n+                                                                 a_is_expected\n+                                                                 : bool,\n+                                                                 a_id: V,\n+                                                                 b: T)\n+                                                                 -> ures {\n         /*!\n          *\n          * Sets the value of the variable `a_id` to `b`.  Because"}, {"sha": "85fceabf0ac8fbea555671de4d28a0adc0b305e7", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -26,40 +26,40 @@ fn bit<E:CLike>(e: E) -> uint {\n     1 << e.to_uint()\n }\n \n-pub impl<E:CLike> EnumSet<E> {\n-    fn empty() -> EnumSet<E> {\n+impl<E:CLike> EnumSet<E> {\n+    pub fn empty() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n-    fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n \n-    fn intersects(&self, e: EnumSet<E>) -> bool {\n+    pub fn intersects(&self, e: EnumSet<E>) -> bool {\n         (self.bits & e.bits) != 0\n     }\n \n-    fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n+    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n \n-    fn contains(&self, e: EnumSet<E>) -> bool {\n+    pub fn contains(&self, e: EnumSet<E>) -> bool {\n         (self.bits & e.bits) == e.bits\n     }\n \n-    fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n+    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n \n-    fn add(&mut self, e: E) {\n+    pub fn add(&mut self, e: E) {\n         self.bits |= bit(e);\n     }\n \n-    fn contains_elem(&self, e: E) -> bool {\n+    pub fn contains_elem(&self, e: E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n-    fn each(&self, f: &fn(E) -> bool) -> bool {\n+    pub fn each(&self, f: &fn(E) -> bool) -> bool {\n         let mut bits = self.bits;\n         let mut index = 0;\n         while bits != 0 {"}, {"sha": "283763c156471e0d4cec349d76ea5ff36e52f52f", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -172,8 +172,8 @@ pub struct IndexEntry {\n     link: ~str\n }\n \n-pub impl Doc {\n-    fn CrateDoc(&self) -> CrateDoc {\n+impl Doc {\n+    pub fn CrateDoc(&self) -> CrateDoc {\n         vec::foldl(None, self.pages, |_m, page| {\n             match copy *page {\n               doc::CratePage(doc) => Some(doc),\n@@ -182,14 +182,14 @@ pub impl Doc {\n         }).get()\n     }\n \n-    fn cratemod(&self) -> ModDoc {\n+    pub fn cratemod(&self) -> ModDoc {\n         copy self.CrateDoc().topmod\n     }\n }\n \n /// Some helper methods on ModDoc, mostly for testing\n-pub impl ModDoc {\n-    fn mods(&self) -> ~[ModDoc] {\n+impl ModDoc {\n+    pub fn mods(&self) -> ~[ModDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ModTag(ModDoc) => Some(ModDoc),\n@@ -198,7 +198,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn nmods(&self) -> ~[NmodDoc] {\n+    pub fn nmods(&self) -> ~[NmodDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               NmodTag(nModDoc) => Some(nModDoc),\n@@ -207,7 +207,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn fns(&self) -> ~[FnDoc] {\n+    pub fn fns(&self) -> ~[FnDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               FnTag(FnDoc) => Some(FnDoc),\n@@ -216,7 +216,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn consts(&self) -> ~[ConstDoc] {\n+    pub fn consts(&self) -> ~[ConstDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ConstTag(ConstDoc) => Some(ConstDoc),\n@@ -225,7 +225,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn enums(&self) -> ~[EnumDoc] {\n+    pub fn enums(&self) -> ~[EnumDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               EnumTag(EnumDoc) => Some(EnumDoc),\n@@ -234,7 +234,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn traits(&self) -> ~[TraitDoc] {\n+    pub fn traits(&self) -> ~[TraitDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               TraitTag(TraitDoc) => Some(TraitDoc),\n@@ -243,7 +243,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn impls(&self) -> ~[ImplDoc] {\n+    pub fn impls(&self) -> ~[ImplDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ImplTag(ImplDoc) => Some(ImplDoc),\n@@ -252,7 +252,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn types(&self) -> ~[TyDoc] {\n+    pub fn types(&self) -> ~[TyDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               TyTag(TyDoc) => Some(TyDoc),\n@@ -261,7 +261,7 @@ pub impl ModDoc {\n         }\n     }\n \n-    fn structs(&self) -> ~[StructDoc] {\n+    pub fn structs(&self) -> ~[StructDoc] {\n         do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n                 StructTag(StructDoc) => Some(StructDoc),"}, {"sha": "a2fa80daa3ba2bc0f251aed42e864139ba0991c9", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -212,8 +212,8 @@ mod test {\n     #[test]\n     fn should_prune_priv_associated_methods_on_pub_impls() {\n         let doc = mk_doc(\n-            ~\"pub impl Foo {\\\n-              fn bar() { }\\\n+            ~\"impl Foo {\\\n+              pub fn bar() { }\\\n               priv fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n@@ -222,7 +222,7 @@ mod test {\n     #[test]\n     fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n         let doc = mk_doc(\n-            ~\"priv impl Foo {\\\n+            ~\"impl Foo {\\\n               pub fn bar() { }\\\n               fn baz() { }\\\n               }\");\n@@ -232,7 +232,7 @@ mod test {\n     #[test]\n     fn should_prune_priv_associated_methods_on_priv_impls() {\n         let doc = mk_doc(\n-            ~\"priv impl Foo {\\\n+            ~\"impl Foo {\\\n               pub fn bar() { }\\\n               priv fn baz() { }\\\n               }\");\n@@ -242,7 +242,7 @@ mod test {\n     #[test]\n     fn should_prune_associated_impls_with_no_pub_methods() {\n         let doc = mk_doc(\n-            ~\"priv impl Foo {\\\n+            ~\"impl Foo {\\\n               fn baz() { }\\\n               }\");\n         assert!(doc.cratemod().impls().is_empty());"}, {"sha": "bf4c7027ce21b557f611bac8e072e744ba38d881", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -47,7 +47,7 @@ fn test() {\n          fn ifn() { } \\\n          enum ienum { ivar } \\\n          trait itrait { fn a(); } \\\n-         pub impl int { fn a() { } } \\\n+         impl int { fn a() { } } \\\n          type itype = int; \\\n          struct istruct { f: () }\";\n     do astsrv::from_str(source) |srv| {"}, {"sha": "ada03e777ca63fa641b4b148588e9427b84713f1", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -430,38 +430,37 @@ pub struct Crate {\n     cfgs: ~[~str]\n }\n \n-pub impl Crate {\n-\n-    fn new(p: &Path) -> Crate {\n+impl Crate {\n+    pub fn new(p: &Path) -> Crate {\n         Crate {\n             file: copy *p,\n             flags: ~[],\n             cfgs: ~[]\n         }\n     }\n \n-    fn flag(&self, flag: ~str) -> Crate {\n+    pub fn flag(&self, flag: ~str) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, [flag]),\n             .. copy *self\n         }\n     }\n \n-    fn flags(&self, flags: ~[~str]) -> Crate {\n+    pub fn flags(&self, flags: ~[~str]) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, flags),\n             .. copy *self\n         }\n     }\n \n-    fn cfg(&self, cfg: ~str) -> Crate {\n+    pub fn cfg(&self, cfg: ~str) -> Crate {\n         Crate {\n             cfgs: vec::append(copy self.cfgs, [cfg]),\n             .. copy *self\n         }\n     }\n \n-    fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n+    pub fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n         Crate {\n             cfgs: vec::append(copy self.cfgs, cfgs),\n             .. copy *self"}, {"sha": "34fd719fc4c6b1bc179c143731ddcf74abc760b5", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -107,8 +107,8 @@ pub struct PkgId {\n     version: Version\n }\n \n-pub impl PkgId {\n-    fn new(s: &str) -> PkgId {\n+impl PkgId {\n+    pub fn new(s: &str) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n         let p = Path(s);\n@@ -129,13 +129,13 @@ pub impl PkgId {\n         }\n     }\n \n-    fn hash(&self) -> ~str {\n+    pub fn hash(&self) -> ~str {\n         fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n              hash(self.remote_path.to_str() + self.version.to_str()),\n              self.version.to_str())\n     }\n \n-    fn short_name_with_version(&self) -> ~str {\n+    pub fn short_name_with_version(&self) -> ~str {\n         fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n     }\n }"}, {"sha": "ab4752ff847703c57642c170d74a24b84343e861", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,6 +10,8 @@\n \n //! A mutable, nullable memory location\n \n+#[missing_doc];\n+\n use cast::transmute_mut;\n use prelude::*;\n use util::replace;\n@@ -37,9 +39,9 @@ pub fn empty_cell<T>() -> Cell<T> {\n     Cell { value: None }\n }\n \n-pub impl<T> Cell<T> {\n+impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n-    fn take(&self) -> T {\n+    pub fn take(&self) -> T {\n         let this = unsafe { transmute_mut(self) };\n         if this.is_empty() {\n             fail!(\"attempt to take an empty cell\");\n@@ -49,7 +51,7 @@ pub impl<T> Cell<T> {\n     }\n \n     /// Returns the value, failing if the cell is full.\n-    fn put_back(&self, value: T) {\n+    pub fn put_back(&self, value: T) {\n         let this = unsafe { transmute_mut(self) };\n         if !this.is_empty() {\n             fail!(\"attempt to put a value back into a full cell\");\n@@ -58,20 +60,20 @@ pub impl<T> Cell<T> {\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n-    fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         self.value.is_none()\n     }\n \n-    // Calls a closure with a reference to the value.\n-    fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n+    /// Calls a closure with a reference to the value.\n+    pub fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n         let v = self.take();\n         let r = op(&v);\n         self.put_back(v);\n         r\n     }\n \n-    // Calls a closure with a mutable reference to the value.\n-    fn with_mut_ref<R>(&self, op: &fn(v: &mut T) -> R) -> R {\n+    /// Calls a closure with a mutable reference to the value.\n+    pub fn with_mut_ref<R>(&self, op: &fn(v: &mut T) -> R) -> R {\n         let mut v = self.take();\n         let r = op(&mut v);\n         self.put_back(v);"}, {"sha": "a376a71597694ac16139854b34d2c7e361f250de", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -150,14 +150,14 @@ pub struct PortSet<T> {\n     ports: ~[pipesy::Port<T>],\n }\n \n-pub impl<T: Owned> PortSet<T> {\n-    fn new() -> PortSet<T> {\n+impl<T: Owned> PortSet<T> {\n+    pub fn new() -> PortSet<T> {\n         PortSet {\n             ports: ~[]\n         }\n     }\n \n-    fn add(&self, port: Port<T>) {\n+    pub fn add(&self, port: Port<T>) {\n         let Port { inner } = port;\n         let port = match inner {\n             Left(p) => p,\n@@ -169,7 +169,7 @@ pub impl<T: Owned> PortSet<T> {\n         }\n     }\n \n-    fn chan(&self) -> Chan<T> {\n+    pub fn chan(&self) -> Chan<T> {\n         let (po, ch) = stream();\n         self.add(po);\n         ch\n@@ -470,20 +470,20 @@ mod pipesy {\n         (PortOne::new(port), ChanOne::new(chan))\n     }\n \n-    pub impl<T: Owned> PortOne<T> {\n-        fn recv(self) -> T { recv_one(self) }\n-        fn try_recv(self) -> Option<T> { try_recv_one(self) }\n-        fn unwrap(self) -> oneshot::server::Oneshot<T> {\n+    impl<T: Owned> PortOne<T> {\n+        pub fn recv(self) -> T { recv_one(self) }\n+        pub fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+        pub fn unwrap(self) -> oneshot::server::Oneshot<T> {\n             match self {\n                 PortOne { contents: s } => s\n             }\n         }\n     }\n \n-    pub impl<T: Owned> ChanOne<T> {\n-        fn send(self, data: T) { send_one(self, data) }\n-        fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n-        fn unwrap(self) -> oneshot::client::Oneshot<T> {\n+    impl<T: Owned> ChanOne<T> {\n+        pub fn send(self, data: T) { send_one(self, data) }\n+        pub fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+        pub fn unwrap(self) -> oneshot::client::Oneshot<T> {\n             match self {\n                 ChanOne { contents: s } => s\n             }"}, {"sha": "2f150a0d1b2835d054b3ec614c5e1e46283fe9d7", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -29,8 +29,8 @@ pub struct Condition<'self, T, U> {\n     key: local_data::LocalDataKey<'self, Handler<T, U>>\n }\n \n-pub impl<'self, T, U> Condition<'self, T, U> {\n-    fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n+impl<'self, T, U> Condition<'self, T, U> {\n+    pub fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = local_data::local_data_get(self.key);\n@@ -39,12 +39,12 @@ pub impl<'self, T, U> Condition<'self, T, U> {\n         }\n     }\n \n-    fn raise(&self, t: T) -> U {\n+    pub fn raise(&self, t: T) -> U {\n         let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n         self.raise_default(t, || fail!(copy msg))\n     }\n \n-    fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n+    pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n         unsafe {\n             match local_data_pop(self.key) {\n                 None => {\n@@ -73,8 +73,8 @@ struct Trap<'self, T, U> {\n     handler: @Handler<T, U>\n }\n \n-pub impl<'self, T, U> Trap<'self, T, U> {\n-    fn in<V>(&self, inner: &'self fn() -> V) -> V {\n+impl<'self, T, U> Trap<'self, T, U> {\n+    pub fn in<V>(&self, inner: &'self fn() -> V) -> V {\n         unsafe {\n             let _g = Guard { cond: self.cond };\n             debug!(\"Trap: pushing handler to TLS\");"}, {"sha": "fac0866f17e762b808e856826971224a3d122c0e", "filename": "src/libstd/either.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,6 +10,8 @@\n \n //! A type that represents one of two alternatives\n \n+#[allow(missing_doc)];\n+\n use container::Container;\n use cmp::Eq;\n use kinds::Copy;\n@@ -137,29 +139,29 @@ pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     }\n }\n \n-pub impl<T, U> Either<T, U> {\n+impl<T, U> Either<T, U> {\n     #[inline(always)]\n-    fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n+    pub fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n         either(f_left, f_right, self)\n     }\n \n     #[inline(always)]\n-    fn flip(self) -> Either<U, T> { flip(self) }\n+    pub fn flip(self) -> Either<U, T> { flip(self) }\n \n     #[inline(always)]\n-    fn to_result(self) -> Result<U, T> { to_result(self) }\n+    pub fn to_result(self) -> Result<U, T> { to_result(self) }\n \n     #[inline(always)]\n-    fn is_left(&self) -> bool { is_left(self) }\n+    pub fn is_left(&self) -> bool { is_left(self) }\n \n     #[inline(always)]\n-    fn is_right(&self) -> bool { is_right(self) }\n+    pub fn is_right(&self) -> bool { is_right(self) }\n \n     #[inline(always)]\n-    fn unwrap_left(self) -> T { unwrap_left(self) }\n+    pub fn unwrap_left(self) -> T { unwrap_left(self) }\n \n     #[inline(always)]\n-    fn unwrap_right(self) -> U { unwrap_right(self) }\n+    pub fn unwrap_right(self) -> U { unwrap_right(self) }\n }\n \n #[test]"}, {"sha": "2d56707e2f67a5d38546b6a0500da504343aae32", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,6 +13,8 @@\n //! The tables use a keyed hash with new random keys generated for each container, so the ordering\n //! of a set of keys in a hash table is randomized.\n \n+#[mutable_doc];\n+\n use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n@@ -81,7 +83,7 @@ fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n     }\n }\n \n-priv impl<K:Hash + Eq,V> HashMap<K, V> {\n+impl<K:Hash + Eq,V> HashMap<K, V> {\n     #[inline(always)]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n@@ -403,20 +405,20 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n }\n \n-pub impl<K: Hash + Eq, V> HashMap<K, V> {\n+impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// Create an empty HashMap\n-    fn new() -> HashMap<K, V> {\n+    pub fn new() -> HashMap<K, V> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashMap with space for at least `n` elements in\n     /// the hash table.\n-    fn with_capacity(capacity: uint) -> HashMap<K, V> {\n+    pub fn with_capacity(capacity: uint) -> HashMap<K, V> {\n         linear_map_with_capacity(capacity)\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n-    fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve_at_least(&mut self, n: uint) {\n         if n > self.buckets.len() {\n             let buckets = n * 4 / 3 + 1;\n             self.resize(uint::next_power_of_two(buckets));\n@@ -425,7 +427,7 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n-    fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -453,7 +455,8 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n-    fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n+    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V)\n+                                   -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -480,7 +483,9 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n         self.value_for_bucket(idx)\n     }\n \n-    fn consume(&mut self, f: &fn(K, V)) {\n+    /// Calls a function on each element of a hash map, destroying the hash\n+    /// map in the process.\n+    pub fn consume(&mut self, f: &fn(K, V)) {\n         let buckets = replace(&mut self.buckets,\n                               vec::from_fn(INITIAL_CAPACITY, |_| None));\n         self.size = 0;\n@@ -495,7 +500,9 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n-    fn get<'a>(&'a self, k: &K) -> &'a V {\n+    /// Retrieves a value for the given key, failing if the key is not\n+    /// present.\n+    pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n             None => fail!(\"No entry found for key: %?\", k),\n@@ -504,7 +511,7 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence\n-    fn contains_key_equiv<Q:Hash + Equiv<K>>(&self, key: &Q) -> bool {\n+    pub fn contains_key_equiv<Q:Hash + Equiv<K>>(&self, key: &Q) -> bool {\n         match self.bucket_for_key_equiv(key) {\n             FoundEntry(_) => {true}\n             TableFull | FoundHole(_) => {false}\n@@ -513,22 +520,23 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n-    fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n+    pub fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q)\n+                                             -> Option<&'a V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n }\n \n-pub impl<K: Hash + Eq, V: Copy> HashMap<K, V> {\n+impl<K: Hash + Eq, V: Copy> HashMap<K, V> {\n     /// Like `find`, but returns a copy of the value.\n-    fn find_copy(&self, k: &K) -> Option<V> {\n+    pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map_consume(|v| copy *v)\n     }\n \n     /// Like `get`, but returns a copy of the value.\n-    fn get_copy(&self, k: &K) -> V {\n+    pub fn get_copy(&self, k: &K) -> V {\n         copy *self.get(k)\n     }\n }\n@@ -632,29 +640,31 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     }\n }\n \n-pub impl <T:Hash + Eq> HashSet<T> {\n+impl<T:Hash + Eq> HashSet<T> {\n     /// Create an empty HashSet\n-    fn new() -> HashSet<T> {\n+    pub fn new() -> HashSet<T> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n-    fn with_capacity(capacity: uint) -> HashSet<T> {\n+    pub fn with_capacity(capacity: uint) -> HashSet<T> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n-    fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve_at_least(&mut self, n: uint) {\n         self.map.reserve_at_least(n)\n     }\n \n     /// Consumes all of the elements in the set, emptying it out\n-    fn consume(&mut self, f: &fn(T)) {\n+    pub fn consume(&mut self, f: &fn(T)) {\n         self.map.consume(|k, _| f(k))\n     }\n \n-    fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n+    /// Returns true if the hash set contains a value equivalent to the\n+    /// given query value.\n+    pub fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n }"}, {"sha": "b9d04edd8a3b00e27d1b65517289e42a1c1bc8aa", "filename": "src/libstd/option.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -145,21 +145,20 @@ impl<A> ExtendedIter<A> for Option<A> {\n     }\n }\n \n-pub impl<T> Option<T> {\n+impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n-    fn is_none(&const self) -> bool {\n+    pub fn is_none(&const self) -> bool {\n         match *self { None => true, Some(_) => false }\n     }\n \n     /// Returns true if the option contains some value\n     #[inline(always)]\n-    fn is_some(&const self) -> bool { !self.is_none() }\n+    pub fn is_some(&const self) -> bool { !self.is_none() }\n \n     /// Update an optional value by optionally running its content through a\n     /// function that returns an option.\n     #[inline(always)]\n-    fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n-\n+    pub fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n         match self {\n             Some(t) => f(t),\n             None => None\n@@ -168,7 +167,7 @@ pub impl<T> Option<T> {\n \n     /// Returns the leftmost Some() value, or None if both are None.\n     #[inline(always)]\n-    fn or(self, optb: Option<T>) -> Option<T> {\n+    pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(opta) => Some(opta),\n             _ => optb\n@@ -178,45 +177,49 @@ pub impl<T> Option<T> {\n     /// Update an optional value by optionally running its content by reference\n     /// through a function that returns an option.\n     #[inline(always)]\n-    fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n-        match *self { Some(ref x) => f(x), None => None }\n+    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>)\n+                            -> Option<U> {\n+        match *self {\n+            Some(ref x) => f(x),\n+            None => None\n+        }\n     }\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n+    pub fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n     }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n-    fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n+    pub fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         match self { None => None, Some(v) => Some(f(v)) }\n     }\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n+    pub fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n-    fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n+    pub fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n \n     /// Apply a function to the contained value or do nothing\n-    fn mutate(&mut self, f: &fn(T) -> T) {\n+    pub fn mutate(&mut self, f: &fn(T) -> T) {\n         if self.is_some() {\n             *self = Some(f(self.swap_unwrap()));\n         }\n     }\n \n     /// Apply a function to the contained value or set it to a default\n-    fn mutate_default(&mut self, def: T, f: &fn(T) -> T) {\n+    pub fn mutate_default(&mut self, def: T, f: &fn(T) -> T) {\n         if self.is_some() {\n             *self = Some(f(self.swap_unwrap()));\n         } else {\n@@ -239,7 +242,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    fn get_ref<'a>(&'a self) -> &'a T {\n+    pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n           Some(ref x) => x,\n           None => fail!(\"option::get_ref none\")\n@@ -261,15 +264,15 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n+    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n           Some(ref mut x) => x,\n           None => fail!(\"option::get_mut_ref none\")\n         }\n     }\n \n     #[inline(always)]\n-    fn unwrap(self) -> T {\n+    pub fn unwrap(self) -> T {\n         /*!\n         Moves a value out of an option type and returns it.\n \n@@ -301,7 +304,7 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `None`.\n      */\n     #[inline(always)]\n-    fn swap_unwrap(&mut self) -> T {\n+    pub fn swap_unwrap(&mut self) -> T {\n         if self.is_none() { fail!(\"option::swap_unwrap none\") }\n         util::replace(self, None).unwrap()\n     }\n@@ -315,15 +318,15 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `none`\n      */\n     #[inline(always)]\n-    fn expect(self, reason: &str) -> T {\n+    pub fn expect(self, reason: &str) -> T {\n         match self {\n           Some(val) => val,\n           None => fail!(reason.to_owned()),\n         }\n     }\n }\n \n-pub impl<T:Copy> Option<T> {\n+impl<T:Copy> Option<T> {\n     /**\n     Gets the value out of an option\n \n@@ -339,7 +342,7 @@ pub impl<T:Copy> Option<T> {\n     case explicitly.\n     */\n     #[inline(always)]\n-    fn get(self) -> T {\n+    pub fn get(self) -> T {\n         match self {\n           Some(x) => return x,\n           None => fail!(\"option::get none\")\n@@ -348,25 +351,28 @@ pub impl<T:Copy> Option<T> {\n \n     /// Returns the contained value or a default\n     #[inline(always)]\n-    fn get_or_default(self, def: T) -> T {\n+    pub fn get_or_default(self, def: T) -> T {\n         match self { Some(x) => x, None => def }\n     }\n \n     /// Applies a function zero or more times until the result is none.\n     #[inline(always)]\n-    fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n+    pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         let mut opt = self;\n         while opt.is_some() {\n             opt = blk(opt.unwrap());\n         }\n     }\n }\n \n-pub impl<T:Copy + Zero> Option<T> {\n+impl<T:Copy + Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline(always)]\n-    fn get_or_zero(self) -> T {\n-        match self { Some(x) => x, None => Zero::zero() }\n+    pub fn get_or_zero(self) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => Zero::zero()\n+        }\n     }\n }\n "}, {"sha": "a551b9bf3c0b3e3b5e07215790fd26a81ce5479e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -308,8 +308,8 @@ mod stat {\n }\n \n \n-pub impl Path {\n-    fn stat(&self) -> Option<libc::stat> {\n+impl Path {\n+    pub fn stat(&self) -> Option<libc::stat> {\n         unsafe {\n              do str::as_c_str(self.to_str()) |buf| {\n                 let mut st = stat::arch::default_stat();\n@@ -322,7 +322,7 @@ pub impl Path {\n     }\n \n     #[cfg(unix)]\n-    fn lstat(&self) -> Option<libc::stat> {\n+    pub fn lstat(&self) -> Option<libc::stat> {\n         unsafe {\n             do str::as_c_str(self.to_str()) |buf| {\n                 let mut st = stat::arch::default_stat();\n@@ -334,21 +334,21 @@ pub impl Path {\n         }\n     }\n \n-    fn exists(&self) -> bool {\n+    pub fn exists(&self) -> bool {\n         match self.stat() {\n             None => false,\n             Some(_) => true,\n         }\n     }\n \n-    fn get_size(&self) -> Option<i64> {\n+    pub fn get_size(&self) -> Option<i64> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => Some(st.st_size as i64),\n         }\n     }\n \n-    fn get_mode(&self) -> Option<uint> {\n+    pub fn get_mode(&self) -> Option<uint> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => Some(st.st_mode as uint),\n@@ -359,8 +359,8 @@ pub impl Path {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-pub impl Path {\n-    fn get_atime(&self) -> Option<(i64, int)> {\n+impl Path {\n+    pub fn get_atime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {\n@@ -370,7 +370,7 @@ pub impl Path {\n         }\n     }\n \n-    fn get_mtime(&self) -> Option<(i64, int)> {\n+    pub fn get_mtime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {\n@@ -380,7 +380,7 @@ pub impl Path {\n         }\n     }\n \n-    fn get_ctime(&self) -> Option<(i64, int)> {\n+    pub fn get_ctime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {\n@@ -393,8 +393,8 @@ pub impl Path {\n \n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n-pub impl Path {\n-    fn get_birthtime(&self) -> Option<(i64, int)> {\n+impl Path {\n+    pub fn get_birthtime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {\n@@ -406,8 +406,8 @@ pub impl Path {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub impl Path {\n-    fn get_atime(&self) -> Option<(i64, int)> {\n+impl Path {\n+    pub fn get_atime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {\n@@ -416,7 +416,7 @@ pub impl Path {\n         }\n     }\n \n-    fn get_mtime(&self) -> Option<(i64, int)> {\n+    pub fn get_mtime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {\n@@ -425,7 +425,7 @@ pub impl Path {\n         }\n     }\n \n-    fn get_ctime(&self) -> Option<(i64, int)> {\n+    pub fn get_ctime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n             Some(ref st) => {"}, {"sha": "9607d395151dafebc6fb9ea83bed9df1b8551c10", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -152,16 +152,16 @@ pub fn PacketHeader() -> PacketHeader {\n     }\n }\n \n-pub impl PacketHeader {\n+impl PacketHeader {\n     // Returns the old state.\n-    unsafe fn mark_blocked(&mut self, this: *rust_task) -> State {\n+    pub unsafe fn mark_blocked(&mut self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n         assert!(old_task.is_null());\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n-    unsafe fn unblock(&mut self) {\n+    pub unsafe fn unblock(&mut self) {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             rustrt::rust_task_deref(old_task)\n@@ -176,12 +176,12 @@ pub impl PacketHeader {\n     // unsafe because this can do weird things to the space/time\n     // continuum. It ends making multiple unique pointers to the same\n     // thing. You'll probably want to forget them when you're done.\n-    unsafe fn buf_header(&mut self) -> ~BufferHeader {\n+    pub unsafe fn buf_header(&mut self) -> ~BufferHeader {\n         assert!(self.buffer.is_not_null());\n         transmute_copy(&self.buffer)\n     }\n \n-    fn set_buffer<T:Owned>(&mut self, b: ~Buffer<T>) {\n+    pub fn set_buffer<T:Owned>(&mut self, b: ~Buffer<T>) {\n         unsafe {\n             self.buffer = transmute_copy(&b);\n         }\n@@ -694,12 +694,12 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n     }\n }\n \n-pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n-    fn unwrap(&mut self) -> *mut Packet<T> {\n+impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n+    pub fn unwrap(&mut self) -> *mut Packet<T> {\n         replace(&mut self.p, None).unwrap()\n     }\n \n-    fn header(&mut self) -> *mut PacketHeader {\n+    pub fn header(&mut self) -> *mut PacketHeader {\n         match self.p {\n             Some(packet) => unsafe {\n                 let packet = &mut *packet;\n@@ -710,7 +710,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         }\n     }\n \n-    fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n+    pub fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         replace(&mut self.buffer, None).unwrap()\n     }\n@@ -742,12 +742,12 @@ impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n     }\n }\n \n-pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n-    fn unwrap(&mut self) -> *mut Packet<T> {\n+impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n+    pub fn unwrap(&mut self) -> *mut Packet<T> {\n         replace(&mut self.p, None).unwrap()\n     }\n \n-    fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n+    pub fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         replace(&mut self.buffer, None).unwrap()\n     }\n }"}, {"sha": "40d1744f0fb1e255db6d63fec7e5e3631e0048d3", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -612,9 +612,9 @@ pub struct IsaacRng {\n     priv c: u32\n }\n \n-pub impl IsaacRng {\n+impl IsaacRng {\n     /// Create an ISAAC random number generator with a random seed.\n-    fn new() -> IsaacRng {\n+    pub fn new() -> IsaacRng {\n         IsaacRng::new_seeded(seed())\n     }\n \n@@ -623,7 +623,7 @@ pub impl IsaacRng {\n     /// will be silently ignored. A generator constructed with a given seed\n     /// will generate the same sequence of values as all other generators\n     /// constructed with the same seed.\n-    fn new_seeded(seed: &[u8]) -> IsaacRng {\n+    pub fn new_seeded(seed: &[u8]) -> IsaacRng {\n         let mut rng = IsaacRng {\n             cnt: 0,\n             rsl: [0, .. RAND_SIZE],\n@@ -643,7 +643,7 @@ pub impl IsaacRng {\n \n     /// Create an ISAAC random number generator using the default\n     /// fixed seed.\n-    fn new_unseeded() -> IsaacRng {\n+    pub fn new_unseeded() -> IsaacRng {\n         let mut rng = IsaacRng {\n             cnt: 0,\n             rsl: [0, .. RAND_SIZE],\n@@ -657,7 +657,7 @@ pub impl IsaacRng {\n     /// Initialises `self`. If `use_rsl` is true, then use the current value\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n-    priv fn init(&mut self, use_rsl: bool) {\n+    fn init(&mut self, use_rsl: bool) {\n         macro_rules! init_mut_many (\n             ($( $var:ident ),* = $val:expr ) => {\n                 let mut $( $var = $val ),*;\n@@ -715,7 +715,7 @@ pub impl IsaacRng {\n \n     /// Refills the output buffer (`self.rsl`)\n     #[inline]\n-    priv fn isaac(&mut self) {\n+    fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations\n         let mut a = self.a, b = self.b + self.c;\n@@ -795,9 +795,9 @@ impl Rng for XorShiftRng {\n     }\n }\n \n-pub impl XorShiftRng {\n+impl XorShiftRng {\n     /// Create an xor shift random number generator with a default seed.\n-    fn new() -> XorShiftRng {\n+    pub fn new() -> XorShiftRng {\n         // constants taken from http://en.wikipedia.org/wiki/Xorshift\n         XorShiftRng::new_seeded(123456789u32,\n                                 362436069u32,\n@@ -807,10 +807,10 @@ pub impl XorShiftRng {\n \n     /**\n      * Create a random number generator using the specified seed. A generator\n-     * constructed with a given seed will generate the same sequence of values as\n-     * all other generators constructed with the same seed.\n+     * constructed with a given seed will generate the same sequence of values\n+     * as all other generators constructed with the same seed.\n      */\n-    fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n+    pub fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n         XorShiftRng {\n             x: x,\n             y: y,"}, {"sha": "1eb3d3a0daaae8319c7efb6773c67879ad36d171", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -48,28 +48,28 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n     MovePtrAdaptor { inner: v }\n }\n \n-pub impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n+impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline(always)]\n-    fn bump(&self, sz: uint) {\n-      do self.inner.move_ptr() |p| {\n+    pub fn bump(&self, sz: uint) {\n+        do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n-      };\n+        };\n     }\n \n     #[inline(always)]\n-    fn align(&self, a: uint) {\n-      do self.inner.move_ptr() |p| {\n+    pub fn align(&self, a: uint) {\n+        do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n-      };\n+        };\n     }\n \n     #[inline(always)]\n-    fn align_to<T>(&self) {\n+    pub fn align_to<T>(&self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n     #[inline(always)]\n-    fn bump_past<T>(&self) {\n+    pub fn bump_past<T>(&self) {\n         self.bump(sys::size_of::<T>());\n     }\n }"}, {"sha": "14bec48782ff3abcb946c1f32676c22b79730466", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -174,25 +174,24 @@ impl MovePtr for ReprVisitor {\n     }\n }\n \n-pub impl ReprVisitor {\n-\n+impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n     #[inline(always)]\n-    fn get<T>(&self, f: &fn(&T)) -> bool {\n+    pub fn get<T>(&self, f: &fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(*self.ptr));\n         }\n         true\n     }\n \n     #[inline(always)]\n-    fn visit_inner(&self, inner: *TyDesc) -> bool {\n+    pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n         self.visit_ptr_inner(*self.ptr, inner)\n     }\n \n     #[inline(always)]\n-    fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n+    pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor(ptr, self.writer);\n             let v = reflect::MovePtrAdaptor(u);\n@@ -202,21 +201,21 @@ pub impl ReprVisitor {\n     }\n \n     #[inline(always)]\n-    fn write<T:Repr>(&self) -> bool {\n+    pub fn write<T:Repr>(&self) -> bool {\n         do self.get |v:&T| {\n             v.write_repr(self.writer);\n         }\n     }\n \n-    fn write_escaped_slice(&self, slice: &str) {\n+    pub fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n         for slice.each_char |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');\n     }\n \n-    fn write_mut_qualifier(&self, mtbl: uint) {\n+    pub fn write_mut_qualifier(&self, mtbl: uint) {\n         if mtbl == 0 {\n             self.writer.write_str(\"mut \");\n         } else if mtbl == 1 {\n@@ -227,8 +226,12 @@ pub impl ReprVisitor {\n         }\n     }\n \n-    fn write_vec_range(&self, mtbl: uint, ptr: *u8, len: uint,\n-                       inner: *TyDesc) -> bool {\n+    pub fn write_vec_range(&self,\n+                           mtbl: uint,\n+                           ptr: *u8,\n+                           len: uint,\n+                           inner: *TyDesc)\n+                           -> bool {\n         let mut p = ptr;\n         let end = ptr::offset(p, len);\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n@@ -248,13 +251,14 @@ pub impl ReprVisitor {\n         true\n     }\n \n-    fn write_unboxed_vec_repr(&self, mtbl: uint, v: &UnboxedVecRepr,\n-                              inner: *TyDesc) -> bool {\n+    pub fn write_unboxed_vec_repr(&self,\n+                                  mtbl: uint,\n+                                  v: &UnboxedVecRepr,\n+                                  inner: *TyDesc)\n+                                  -> bool {\n         self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n                              v.fill, inner)\n     }\n-\n-\n }\n \n impl TyVisitor for ReprVisitor {"}, {"sha": "8f7a0015bcf155786d3ebe59b60615b203e0e05d", "filename": "src/libstd/result.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,7 +10,7 @@\n \n //! A type representing either success or failure\n \n-// NB: transitionary, de-mode-ing.\n+#[allow(missing_doc)];\n \n use cmp::Eq;\n use either;\n@@ -227,55 +227,55 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n     }\n }\n \n-pub impl<T, E> Result<T, E> {\n+impl<T, E> Result<T, E> {\n     #[inline(always)]\n-    fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n+    pub fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n \n     #[inline(always)]\n-    fn is_ok(&self) -> bool { is_ok(self) }\n+    pub fn is_ok(&self) -> bool { is_ok(self) }\n \n     #[inline(always)]\n-    fn is_err(&self) -> bool { is_err(self) }\n+    pub fn is_err(&self) -> bool { is_err(self) }\n \n     #[inline(always)]\n-    fn iter(&self, f: &fn(&T)) { iter(self, f) }\n+    pub fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n     #[inline(always)]\n-    fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n+    pub fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n     #[inline(always)]\n-    fn unwrap(self) -> T { unwrap(self) }\n+    pub fn unwrap(self) -> T { unwrap(self) }\n \n     #[inline(always)]\n-    fn unwrap_err(self) -> E { unwrap_err(self) }\n+    pub fn unwrap_err(self) -> E { unwrap_err(self) }\n \n     #[inline(always)]\n-    fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n+    pub fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n     #[inline(always)]\n-    fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n+    pub fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n \n-pub impl<T:Copy,E> Result<T, E> {\n+impl<T:Copy,E> Result<T, E> {\n     #[inline(always)]\n-    fn get(&self) -> T { get(self) }\n+    pub fn get(&self) -> T { get(self) }\n \n     #[inline(always)]\n-    fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n+    pub fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n \n-pub impl<T, E: Copy> Result<T, E> {\n+impl<T, E: Copy> Result<T, E> {\n     #[inline(always)]\n-    fn get_err(&self) -> E { get_err(self) }\n+    pub fn get_err(&self) -> E { get_err(self) }\n \n     #[inline(always)]\n-    fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n+    pub fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n }"}, {"sha": "d5ca8473ceeac6913342f25ebda97b03949f8b52", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -27,16 +27,16 @@ pub struct Context {\n     regs: ~Registers\n }\n \n-pub impl Context {\n-    fn empty() -> Context {\n+impl Context {\n+    pub fn empty() -> Context {\n         Context {\n             start: None,\n             regs: new_regs()\n         }\n     }\n \n     /// Create a new context that will resume execution by running ~fn()\n-    fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n+    pub fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n         // XXX: Putting main into a ~ so it's a thin pointer and can\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n@@ -71,7 +71,7 @@ pub impl Context {\n     saving the registers values of the executing thread to a Context\n     then loading the registers from a previously saved Context.\n     */\n-    fn swap(out_context: &mut Context, in_context: &Context) {\n+    pub fn swap(out_context: &mut Context, in_context: &Context) {\n         let out_regs: &mut Registers = match out_context {\n             &Context { regs: ~ref mut r, _ } => r\n         };"}, {"sha": "064eb63afc627d3752d0c22e457aab735dc13e92", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -57,11 +57,10 @@ enum CleanupJob {\n     GiveTask(~Coroutine, UnsafeTaskReceiver)\n }\n \n-pub impl Scheduler {\n+impl Scheduler {\n+    pub fn in_task_context(&self) -> bool { self.current_task.is_some() }\n \n-    fn in_task_context(&self) -> bool { self.current_task.is_some() }\n-\n-    fn new(event_loop: ~EventLoopObject) -> Scheduler {\n+    pub fn new(event_loop: ~EventLoopObject) -> Scheduler {\n \n         // Lazily initialize the runtime TLS key\n         local_ptr::init_tls_key();\n@@ -80,7 +79,7 @@ pub impl Scheduler {\n     // the scheduler itself doesn't have to call event_loop.run.\n     // That will be important for embedding the runtime into external\n     // event loops.\n-    fn run(~self) -> ~Scheduler {\n+    pub fn run(~self) -> ~Scheduler {\n         assert!(!self.in_task_context());\n \n         let mut self_sched = self;\n@@ -107,7 +106,7 @@ pub impl Scheduler {\n     /// Pushes the task onto the work stealing queue and tells the event loop\n     /// to run it later. Always use this instead of pushing to the work queue\n     /// directly.\n-    fn enqueue_task(&mut self, task: ~Coroutine) {\n+    pub fn enqueue_task(&mut self, task: ~Coroutine) {\n         self.work_queue.push(task);\n         self.event_loop.callback(resume_task_from_queue);\n \n@@ -119,7 +118,7 @@ pub impl Scheduler {\n \n     // * Scheduler-context operations\n \n-    fn resume_task_from_queue(~self) {\n+    pub fn resume_task_from_queue(~self) {\n         assert!(!self.in_task_context());\n \n         rtdebug!(\"looking in work queue for task to schedule\");\n@@ -141,7 +140,7 @@ pub impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    fn terminate_current_task(~self) {\n+    pub fn terminate_current_task(~self) {\n         assert!(self.in_task_context());\n \n         rtdebug!(\"ending running task\");\n@@ -156,7 +155,7 @@ pub impl Scheduler {\n         abort!(\"control reached end of task\");\n     }\n \n-    fn schedule_new_task(~self, task: ~Coroutine) {\n+    pub fn schedule_new_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n@@ -167,7 +166,7 @@ pub impl Scheduler {\n         }\n     }\n \n-    fn schedule_task(~self, task: ~Coroutine) {\n+    pub fn schedule_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n@@ -180,7 +179,7 @@ pub impl Scheduler {\n \n     // Core scheduling ops\n \n-    fn resume_task_immediately(~self, task: ~Coroutine) {\n+    pub fn resume_task_immediately(~self, task: ~Coroutine) {\n         let mut this = self;\n         assert!(!this.in_task_context());\n \n@@ -218,7 +217,7 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn deschedule_running_task_and_then(~self, f: &fn(~Coroutine)) {\n+    pub fn deschedule_running_task_and_then(~self, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n@@ -248,7 +247,9 @@ pub impl Scheduler {\n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn switch_running_tasks_and_then(~self, next_task: ~Coroutine, f: &fn(~Coroutine)) {\n+    pub fn switch_running_tasks_and_then(~self,\n+                                         next_task: ~Coroutine,\n+                                         f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n@@ -279,12 +280,12 @@ pub impl Scheduler {\n \n     // * Other stuff\n \n-    fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n+    pub fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n         assert!(self.cleanup_job.is_none());\n         self.cleanup_job = Some(job);\n     }\n \n-    fn run_cleanup_job(&mut self) {\n+    pub fn run_cleanup_job(&mut self) {\n         rtdebug!(\"running cleanup job\");\n \n         assert!(self.cleanup_job.is_some());\n@@ -305,9 +306,9 @@ pub impl Scheduler {\n     /// callers should first arrange for that task to be located in the\n     /// Scheduler's current_task slot and set up the\n     /// post-context-switch cleanup job.\n-    fn get_contexts<'a>(&'a mut self) -> (&'a mut Context,\n-                                          Option<&'a mut Context>,\n-                                          Option<&'a mut Context>) {\n+    pub fn get_contexts<'a>(&'a mut self) -> (&'a mut Context,\n+                                              Option<&'a mut Context>,\n+                                              Option<&'a mut Context>) {\n         let last_task = match self.cleanup_job {\n             Some(GiveTask(~ref task, _)) => {\n                 Some(task)\n@@ -349,14 +350,14 @@ pub struct Coroutine {\n     task: ~Task\n }\n \n-pub impl Coroutine {\n-    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n+impl Coroutine {\n+    pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n         Coroutine::with_task(stack_pool, ~Task::new(), start)\n     }\n \n-    fn with_task(stack_pool: &mut StackPool,\n-                  task: ~Task,\n-                  start: ~fn()) -> Coroutine {\n+    pub fn with_task(stack_pool: &mut StackPool,\n+                     task: ~Task,\n+                     start: ~fn()) -> Coroutine {\n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n@@ -368,7 +369,7 @@ pub impl Coroutine {\n         };\n     }\n \n-    priv fn build_start_wrapper(start: ~fn()) -> ~fn() {\n+    fn build_start_wrapper(start: ~fn()) -> ~fn() {\n         // XXX: The old code didn't have this extra allocation\n         let wrapper: ~fn() = || {\n             // This is the first code to execute after the initial\n@@ -391,7 +392,7 @@ pub impl Coroutine {\n     }\n \n     /// Destroy the task and try to reuse its components\n-    fn recycle(~self, stack_pool: &mut StackPool) {\n+    pub fn recycle(~self, stack_pool: &mut StackPool) {\n         match self {\n             ~Coroutine {current_stack_segment, _} => {\n                 stack_pool.give_segment(current_stack_segment);"}, {"sha": "fa4b8f30f4e7677cd6571c64b424c2323106da25", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -19,8 +19,8 @@ pub struct StackSegment {\n     valgrind_id: c_uint\n }\n \n-pub impl StackSegment {\n-    fn new(size: uint) -> StackSegment {\n+impl StackSegment {\n+    pub fn new(size: uint) -> StackSegment {\n         unsafe {\n             // Crate a block of uninitialized values\n             let mut stack = vec::with_capacity(size);\n@@ -38,12 +38,12 @@ pub impl StackSegment {\n     }\n \n     /// Point to the low end of the allocated stack\n-    fn start(&self) -> *uint {\n-      vec::raw::to_ptr(self.buf) as *uint\n+    pub fn start(&self) -> *uint {\n+        vec::raw::to_ptr(self.buf) as *uint\n     }\n \n     /// Point one word beyond the high end of the allocated stack\n-    fn end(&self) -> *uint {\n+    pub fn end(&self) -> *uint {\n         vec::raw::to_ptr(self.buf).offset(self.buf.len()) as *uint\n     }\n }"}, {"sha": "bc29019131078535259778ee244406967e236f7f", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -19,8 +19,8 @@ pub struct Thread {\n     raw_thread: *raw_thread\n }\n \n-pub impl Thread {\n-    fn start(main: ~fn()) -> Thread {\n+impl Thread {\n+    pub fn start(main: ~fn()) -> Thread {\n         fn substart(main: &~fn()) -> *raw_thread {\n             unsafe { rust_raw_thread_start(main) }\n         }"}, {"sha": "e1def9ffd508bccf865fbf36ecd757d3c179ef65", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -17,8 +17,8 @@ use rt::uv::status_to_maybe_uv_error;\n pub struct IdleWatcher(*uvll::uv_idle_t);\n impl Watcher for IdleWatcher { }\n \n-pub impl IdleWatcher {\n-    fn new(loop_: &mut Loop) -> IdleWatcher {\n+impl IdleWatcher {\n+    pub fn new(loop_: &mut Loop) -> IdleWatcher {\n         unsafe {\n             let handle = uvll::idle_new();\n             assert!(handle.is_not_null());\n@@ -29,7 +29,7 @@ pub impl IdleWatcher {\n         }\n     }\n \n-    fn start(&mut self, cb: IdleCallback) {\n+    pub fn start(&mut self, cb: IdleCallback) {\n         {\n             let data = self.get_watcher_data();\n             data.idle_cb = Some(cb);\n@@ -48,16 +48,17 @@ pub impl IdleWatcher {\n         }\n     }\n \n-    fn stop(&mut self) {\n-        // NB: Not resetting the Rust idle_cb to None here because `stop` is likely\n-        // called from *within* the idle callback, causing a use after free\n+    pub fn stop(&mut self) {\n+        // NB: Not resetting the Rust idle_cb to None here because `stop` is\n+        // likely called from *within* the idle callback, causing a use after\n+        // free\n \n         unsafe {\n             assert!(0 == uvll::idle_stop(self.native_handle()));\n         }\n     }\n \n-    fn close(self, cb: NullCallback) {\n+    pub fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n             let data = this.get_watcher_data();"}, {"sha": "bc968fc3d60641f842c36e1f7a157366d5e98d3d", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -92,18 +92,18 @@ pub trait NativeHandle<T> {\n     pub fn native_handle(&self) -> T;\n }\n \n-pub impl Loop {\n-    fn new() -> Loop {\n+impl Loop {\n+    pub fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n         assert!(handle.is_not_null());\n         NativeHandle::from_native_handle(handle)\n     }\n \n-    fn run(&mut self) {\n+    pub fn run(&mut self) {\n         unsafe { uvll::run(self.native_handle()) };\n     }\n \n-    fn close(&mut self) {\n+    pub fn close(&mut self) {\n         unsafe { uvll::loop_delete(self.native_handle()) };\n     }\n }\n@@ -193,9 +193,8 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n \n pub struct UvError(uvll::uv_err_t);\n \n-pub impl UvError {\n-\n-    fn name(&self) -> ~str {\n+impl UvError {\n+    pub fn name(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let name_str = uvll::err_name(inner);\n@@ -204,7 +203,7 @@ pub impl UvError {\n         }\n     }\n \n-    fn desc(&self) -> ~str {\n+    pub fn desc(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let desc_str = uvll::strerror(inner);\n@@ -213,7 +212,7 @@ pub impl UvError {\n         }\n     }\n \n-    fn is_eof(&self) -> bool {\n+    pub fn is_eof(&self) -> bool {\n         self.code == uvll::EOF\n     }\n }"}, {"sha": "563d7fd1e81a16a0389124d498f055eb08fa0606", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -43,9 +43,8 @@ fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n pub struct StreamWatcher(*uvll::uv_stream_t);\n impl Watcher for StreamWatcher { }\n \n-pub impl StreamWatcher {\n-\n-    fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n+impl StreamWatcher {\n+    pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n         {\n             let data = self.get_watcher_data();\n             data.alloc_cb = Some(alloc);\n@@ -73,15 +72,15 @@ pub impl StreamWatcher {\n         }\n     }\n \n-    fn read_stop(&mut self) {\n+    pub fn read_stop(&mut self) {\n         // It would be nice to drop the alloc and read callbacks here,\n         // but read_stop may be called from inside one of them and we\n         // would end up freeing the in-use environment\n         let handle = self.native_handle();\n         unsafe { uvll::read_stop(handle); }\n     }\n \n-    fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n+    pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n         {\n             let data = self.get_watcher_data();\n             assert!(data.write_cb.is_none());\n@@ -110,15 +109,15 @@ pub impl StreamWatcher {\n         }\n     }\n \n-    fn accept(&mut self, stream: StreamWatcher) {\n+    pub fn accept(&mut self, stream: StreamWatcher) {\n         let self_handle = self.native_handle() as *c_void;\n         let stream_handle = stream.native_handle() as *c_void;\n         unsafe {\n             assert_eq!(0, uvll::accept(self_handle, stream_handle));\n         }\n     }\n \n-    fn close(self, cb: NullCallback) {\n+    pub fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n             let data = this.get_watcher_data();\n@@ -153,8 +152,8 @@ impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n pub struct TcpWatcher(*uvll::uv_tcp_t);\n impl Watcher for TcpWatcher { }\n \n-pub impl TcpWatcher {\n-    fn new(loop_: &mut Loop) -> TcpWatcher {\n+impl TcpWatcher {\n+    pub fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n@@ -165,7 +164,7 @@ pub impl TcpWatcher {\n         }\n     }\n \n-    fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n+    pub fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n         match address {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n@@ -183,7 +182,7 @@ pub impl TcpWatcher {\n         }\n     }\n \n-    fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n+    pub fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n         unsafe {\n             assert!(self.get_watcher_data().connect_cb.is_none());\n             self.get_watcher_data().connect_cb = Some(cb);\n@@ -216,7 +215,7 @@ pub impl TcpWatcher {\n         }\n     }\n \n-    fn listen(&mut self, cb: ConnectionCallback) {\n+    pub fn listen(&mut self, cb: ConnectionCallback) {\n         {\n             let data = self.get_watcher_data();\n             assert!(data.connect_cb.is_none());\n@@ -240,7 +239,7 @@ pub impl TcpWatcher {\n         }\n     }\n \n-    fn as_stream(&self) -> StreamWatcher {\n+    pub fn as_stream(&self) -> StreamWatcher {\n         NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n     }\n }\n@@ -295,9 +294,8 @@ pub struct WriteRequest(*uvll::uv_write_t);\n \n impl Request for WriteRequest { }\n \n-pub impl WriteRequest {\n-\n-    fn new() -> WriteRequest {\n+impl WriteRequest {\n+    pub fn new() -> WriteRequest {\n         let write_handle = unsafe {\n             malloc_req(UV_WRITE)\n         };\n@@ -306,14 +304,14 @@ pub impl WriteRequest {\n         WriteRequest(write_handle)\n     }\n \n-    fn stream(&self) -> StreamWatcher {\n+    pub fn stream(&self) -> StreamWatcher {\n         unsafe {\n             let stream_handle = uvll::get_stream_handle_from_write_req(self.native_handle());\n             NativeHandle::from_native_handle(stream_handle)\n         }\n     }\n \n-    fn delete(self) {\n+    pub fn delete(self) {\n         unsafe { free_req(self.native_handle() as *c_void) }\n     }\n }"}, {"sha": "1d4f65f1517f64ef81e25f308d21794b452766c0", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -33,15 +33,15 @@ pub struct UvEventLoop {\n     uvio: UvIoFactory\n }\n \n-pub impl UvEventLoop {\n-    fn new() -> UvEventLoop {\n+impl UvEventLoop {\n+    pub fn new() -> UvEventLoop {\n         UvEventLoop {\n             uvio: UvIoFactory(Loop::new())\n         }\n     }\n \n     /// A convenience constructor\n-    fn new_scheduler() -> Scheduler {\n+    pub fn new_scheduler() -> Scheduler {\n         Scheduler::new(~UvEventLoop::new())\n     }\n }\n@@ -57,7 +57,6 @@ impl Drop for UvEventLoop {\n }\n \n impl EventLoop for UvEventLoop {\n-\n     fn run(&mut self) {\n         self.uvio.uv_loop().run();\n     }\n@@ -103,8 +102,8 @@ fn test_callback_run_once() {\n \n pub struct UvIoFactory(Loop);\n \n-pub impl UvIoFactory {\n-    fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n+impl UvIoFactory {\n+    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n }"}, {"sha": "c7467364b4d9de930d385e635335fd5c8fed93a2", "filename": "src/libstd/rt/uvio.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuvio.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -29,15 +29,15 @@ pub struct UvEventLoop {\n     uvio: UvIoFactory\n }\n \n-pub impl UvEventLoop {\n-    fn new() -> UvEventLoop {\n+impl UvEventLoop {\n+    pub fn new() -> UvEventLoop {\n         UvEventLoop {\n             uvio: UvIoFactory(Loop::new())\n         }\n     }\n \n     /// A convenience constructor\n-    fn new_scheduler() -> Scheduler {\n+    pub fn new_scheduler() -> Scheduler {\n         Scheduler::new(~UvEventLoop::new())\n     }\n }\n@@ -90,8 +90,8 @@ fn test_callback_run_once() {\n \n pub struct UvIoFactory(Loop);\n \n-pub impl UvIoFactory {\n-    fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n+impl UvIoFactory {\n+    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n }"}, {"sha": "58d36113f0e35692abbc53ed0a150e8f05606063", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -21,21 +21,21 @@ pub struct WorkQueue<T> {\n     priv queue: ~Exclusive<~[T]>\n }\n \n-pub impl<T: Owned> WorkQueue<T> {\n-    fn new() -> WorkQueue<T> {\n+impl<T: Owned> WorkQueue<T> {\n+    pub fn new() -> WorkQueue<T> {\n         WorkQueue {\n             queue: ~exclusive(~[])\n         }\n     }\n \n-    fn push(&mut self, value: T) {\n+    pub fn push(&mut self, value: T) {\n         unsafe {\n             let value = Cell(value);\n             self.queue.with(|q| q.unshift(value.take()) );\n         }\n     }\n \n-    fn pop(&mut self) -> Option<T> {\n+    pub fn pop(&mut self) -> Option<T> {\n         unsafe {\n             do self.queue.with |q| {\n                 if !q.is_empty() {\n@@ -47,7 +47,7 @@ pub impl<T: Owned> WorkQueue<T> {\n         }\n     }\n \n-    fn steal(&mut self) -> Option<T> {\n+    pub fn steal(&mut self) -> Option<T> {\n         unsafe {\n             do self.queue.with |q| {\n                 if !q.is_empty() {\n@@ -59,7 +59,7 @@ pub impl<T: Owned> WorkQueue<T> {\n         }\n     }\n \n-    fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         unsafe {\n             self.queue.with_imm(|q| q.is_empty() )\n         }"}, {"sha": "07b521d019766322358b646ed1818cafdf492179", "filename": "src/libstd/run.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -136,8 +136,7 @@ pub struct ProcessOutput {\n     error: ~[u8],\n }\n \n-pub impl Process {\n-\n+impl Process {\n     /**\n      * Spawns a new Process.\n      *\n@@ -148,8 +147,8 @@ pub impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Process {\n-\n+    pub fn new(prog: &str, args: &[~str], options: ProcessOptions)\n+               -> Process {\n         let (in_pipe, in_fd) = match options.in_fd {\n             None => {\n                 let pipe = os::pipe();\n@@ -192,25 +191,25 @@ pub impl Process {\n     }\n \n     /// Returns the unique id of the process\n-    fn get_id(&self) -> pid_t { self.pid }\n+    pub fn get_id(&self) -> pid_t { self.pid }\n \n-    priv fn input_fd(&mut self) -> c_int {\n+    fn input_fd(&mut self) -> c_int {\n         match self.input {\n             Some(fd) => fd,\n             None => fail!(\"This Process's stdin was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n \n-    priv fn output_file(&mut self) -> *libc::FILE {\n+    fn output_file(&mut self) -> *libc::FILE {\n         match self.output {\n             Some(file) => file,\n             None => fail!(\"This Process's stdout was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n \n-    priv fn error_file(&mut self) -> *libc::FILE {\n+    fn error_file(&mut self) -> *libc::FILE {\n         match self.error {\n             Some(file) => file,\n             None => fail!(\"This Process's stderr was redirected to an \\\n@@ -225,7 +224,7 @@ pub impl Process {\n      *\n      * If this method returns true then self.input() will fail.\n      */\n-    fn input_redirected(&self) -> bool {\n+    pub fn input_redirected(&self) -> bool {\n         self.input.is_none()\n     }\n \n@@ -236,7 +235,7 @@ pub impl Process {\n      *\n      * If this method returns true then self.output() will fail.\n      */\n-    fn output_redirected(&self) -> bool {\n+    pub fn output_redirected(&self) -> bool {\n         self.output.is_none()\n     }\n \n@@ -247,7 +246,7 @@ pub impl Process {\n      *\n      * If this method returns true then self.error() will fail.\n      */\n-    fn error_redirected(&self) -> bool {\n+    pub fn error_redirected(&self) -> bool {\n         self.error.is_none()\n     }\n \n@@ -256,7 +255,7 @@ pub impl Process {\n      *\n      * Fails if this Process's stdin was redirected to an existing file descriptor.\n      */\n-    fn input(&mut self) -> @io::Writer {\n+    pub fn input(&mut self) -> @io::Writer {\n         // FIXME: the Writer can still be used after self is destroyed: #2625\n        io::fd_writer(self.input_fd(), false)\n     }\n@@ -266,7 +265,7 @@ pub impl Process {\n      *\n      * Fails if this Process's stdout was redirected to an existing file descriptor.\n      */\n-    fn output(&mut self) -> @io::Reader {\n+    pub fn output(&mut self) -> @io::Reader {\n         // FIXME: the Reader can still be used after self is destroyed: #2625\n         io::FILE_reader(self.output_file(), false)\n     }\n@@ -276,7 +275,7 @@ pub impl Process {\n      *\n      * Fails if this Process's stderr was redirected to an existing file descriptor.\n      */\n-    fn error(&mut self) -> @io::Reader {\n+    pub fn error(&mut self) -> @io::Reader {\n         // FIXME: the Reader can still be used after self is destroyed: #2625\n         io::FILE_reader(self.error_file(), false)\n     }\n@@ -287,7 +286,7 @@ pub impl Process {\n      * If this process is reading its stdin from an existing file descriptor, then this\n      * method does nothing.\n      */\n-    fn close_input(&mut self) {\n+    pub fn close_input(&mut self) {\n         match self.input {\n             Some(-1) | None => (),\n             Some(fd) => {\n@@ -299,7 +298,7 @@ pub impl Process {\n         }\n     }\n \n-    priv fn close_outputs(&mut self) {\n+    fn close_outputs(&mut self) {\n         fclose_and_null(&mut self.output);\n         fclose_and_null(&mut self.error);\n \n@@ -322,7 +321,7 @@ pub impl Process {\n      *\n      * If the child has already been finished then the exit code is returned.\n      */\n-    fn finish(&mut self) -> int {\n+    pub fn finish(&mut self) -> int {\n         for self.exit_code.each |&code| {\n             return code;\n         }\n@@ -342,8 +341,7 @@ pub impl Process {\n      * This method will fail if the child process's stdout or stderr streams were\n      * redirected to existing file descriptors.\n      */\n-    fn finish_with_output(&mut self) -> ProcessOutput {\n-\n+    pub fn finish_with_output(&mut self) -> ProcessOutput {\n         let output_file = self.output_file();\n         let error_file = self.error_file();\n \n@@ -378,8 +376,7 @@ pub impl Process {\n                               error: errs};\n     }\n \n-    priv fn destroy_internal(&mut self, force: bool) {\n-\n+    fn destroy_internal(&mut self, force: bool) {\n         // if the process has finished, and therefore had waitpid called,\n         // and we kill it, then on unix we might ending up killing a\n         // newer process that happens to have the same (re-used) id\n@@ -417,7 +414,7 @@ pub impl Process {\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    fn destroy(&mut self) { self.destroy_internal(false); }\n+    pub fn destroy(&mut self) { self.destroy_internal(false); }\n \n     /**\n      * Terminates the process as soon as possible without giving it a\n@@ -426,7 +423,7 @@ pub impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    fn force_destroy(&mut self) { self.destroy_internal(true); }\n+    pub fn force_destroy(&mut self) { self.destroy_internal(true); }\n }\n \n impl Drop for Process {"}, {"sha": "3b31d70f7a1bdd4af832482deb5dd05c9a7675d7", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -21,22 +21,22 @@ use vec::{CopyableVector, ImmutableVector, OwnedVector};\n #[deriving(Clone, Eq)]\n pub struct Ascii { priv chr: u8 }\n \n-pub impl Ascii {\n+impl Ascii {\n     /// Converts a ascii character into a `u8`.\n     #[inline(always)]\n-    fn to_byte(self) -> u8 {\n+    pub fn to_byte(self) -> u8 {\n         self.chr\n     }\n \n     /// Converts a ascii character into a `char`.\n     #[inline(always)]\n-    fn to_char(self) -> char {\n+    pub fn to_char(self) -> char {\n         self.chr as char\n     }\n \n     /// Convert to lowercase.\n     #[inline(always)]\n-    fn to_lower(self) -> Ascii {\n+    pub fn to_lower(self) -> Ascii {\n         if self.chr >= 65 && self.chr <= 90 {\n             Ascii{chr: self.chr | 0x20 }\n         } else {\n@@ -46,17 +46,17 @@ pub impl Ascii {\n \n     /// Convert to uppercase.\n     #[inline(always)]\n-    fn to_upper(self) -> Ascii {\n+    pub fn to_upper(self) -> Ascii {\n         if self.chr >= 97 && self.chr <= 122 {\n             Ascii{chr: self.chr & !0x20 }\n         } else {\n             self\n         }\n     }\n \n-    // Compares two ascii characters of equality, ignoring case.\n+    /// Compares two ascii characters of equality, ignoring case.\n     #[inline(always)]\n-    fn eq_ignore_case(self, other: Ascii) -> bool {\n+    pub fn eq_ignore_case(self, other: Ascii) -> bool {\n         self.to_lower().chr == other.to_lower().chr\n     }\n }"}, {"sha": "7c9639bb8f3cb9ce011687d14f64232506f84829", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -202,7 +202,7 @@ pub fn task() -> TaskBuilder {\n     }\n }\n \n-priv impl TaskBuilder {\n+impl TaskBuilder {\n     fn consume(&mut self) -> TaskBuilder {\n         if self.consumed {\n             fail!(\"Cannot copy a task_builder\"); // Fake move mode on self\n@@ -224,24 +224,24 @@ priv impl TaskBuilder {\n     }\n }\n \n-pub impl TaskBuilder {\n+impl TaskBuilder {\n     /// Decouple the child task's failure from the parent's. If either fails,\n     /// the other will not be killed.\n-    fn unlinked(&mut self) {\n+    pub fn unlinked(&mut self) {\n         self.opts.linked = false;\n     }\n \n     /// Unidirectionally link the child task's failure with the parent's. The\n     /// child's failure will not kill the parent, but the parent's will kill\n     /// the child.\n-    fn supervised(&mut self) {\n+    pub fn supervised(&mut self) {\n         self.opts.supervised = true;\n         self.opts.linked = false;\n     }\n \n     /// Link the child task's and parent task's failures. If either fails, the\n     /// other will be killed.\n-    fn linked(&mut self) {\n+    pub fn linked(&mut self) {\n         self.opts.linked = true;\n         self.opts.supervised = false;\n     }\n@@ -263,7 +263,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(&mut self, blk: &fn(v: Port<TaskResult>)) {\n+    pub fn future_result(&mut self, blk: &fn(v: Port<TaskResult>)) {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -283,7 +283,7 @@ pub impl TaskBuilder {\n     }\n \n     /// Configure a custom scheduler mode for the task.\n-    fn sched_mode(&mut self, mode: SchedMode) {\n+    pub fn sched_mode(&mut self, mode: SchedMode) {\n         self.opts.sched.mode = mode;\n     }\n \n@@ -299,7 +299,7 @@ pub impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n+    pub fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n         let prev_gen_body = replace(&mut self.gen_body, None);\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n@@ -331,7 +331,7 @@ pub impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(&mut self, f: ~fn()) {\n+    pub fn spawn(&mut self, f: ~fn()) {\n         let gen_body = replace(&mut self.gen_body, None);\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n@@ -353,7 +353,7 @@ pub impl TaskBuilder {\n     }\n \n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A:Owned>(&mut self, arg: A, f: ~fn(v: A)) {\n+    pub fn spawn_with<A:Owned>(&mut self, arg: A, f: ~fn(v: A)) {\n         let arg = Cell(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -373,7 +373,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T:Owned>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n+    pub fn try<T:Owned>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n "}, {"sha": "aea03b437ca1392912a9090ccfcba453f76f2f9d", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -145,28 +145,28 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n }\n \n-pub impl<T> TrieMap<T> {\n+impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n     #[inline(always)]\n-    fn new() -> TrieMap<T> {\n+    pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n     /// Visit all keys in reverse order\n     #[inline(always)]\n-    fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n-    fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+    pub fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n }\n@@ -208,28 +208,32 @@ impl Mutable for TrieSet {\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-pub impl TrieSet {\n+impl TrieSet {\n     /// Create an empty TrieSet\n     #[inline(always)]\n-    fn new() -> TrieSet {\n+    pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n     /// Return true if the set contains a value\n     #[inline(always)]\n-    fn contains(&self, value: &uint) -> bool {\n+    pub fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n     #[inline(always)]\n-    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n+    pub fn insert(&mut self, value: uint) -> bool {\n+        self.map.insert(value, ())\n+    }\n \n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n     #[inline(always)]\n-    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n+    pub fn remove(&mut self, value: &uint) -> bool {\n+        self.map.remove(value)\n+    }\n }\n \n struct TrieNode<T> {"}, {"sha": "07bcf6d953c3a91d0b826c3759d748c6e8e1446d", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -139,8 +139,8 @@ pub mod ct {\n         next: uint\n     }\n \n-    pub impl<T> Parsed<T> {\n-        fn new(val: T, next: uint) -> Parsed<T> {\n+    impl<T> Parsed<T> {\n+        pub fn new(val: T, next: uint) -> Parsed<T> {\n             Parsed {val: val, next: next}\n         }\n     }"}, {"sha": "f0b178c667013f7328b0ca50a2cdb06f68bf42d3", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -117,9 +117,9 @@ fn LittleLock() -> LittleLock {\n     }\n }\n \n-pub impl LittleLock {\n+impl LittleLock {\n     #[inline(always)]\n-    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+    pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         do atomically {\n             rust_lock_little_lock(self.l);\n             do (|| {\n@@ -162,15 +162,15 @@ impl<T:Owned> Clone for Exclusive<T> {\n     }\n }\n \n-pub impl<T:Owned> Exclusive<T> {\n+impl<T:Owned> Exclusive<T> {\n     // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n     // instead of a proper mutex. Same reason for being unsafe.\n     //\n     // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n-    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n+    pub unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n@@ -184,7 +184,7 @@ pub impl<T:Owned> Exclusive<T> {\n     }\n \n     #[inline(always)]\n-    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n+    pub unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))\n         }"}, {"sha": "e8e68ddd632e63c2c03c0e6619cf934dd7f60727", "filename": "src/libstd/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -90,9 +90,9 @@ pub fn NonCopyable() -> NonCopyable { NonCopyable { i: () } }\n /// A type with no inhabitants\n pub enum Void { }\n \n-pub impl Void {\n+impl Void {\n     /// A utility function for ignoring this uninhabited type\n-    fn uninhabited(self) -> ! {\n+    pub fn uninhabited(self) -> ! {\n         match self {\n             // Nothing to match on\n         }"}, {"sha": "75439dfaa786ca628c54ee9388f8c44c797416d4", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -109,18 +109,18 @@ pub fn all_names() -> ~[&'static str] {\n     AbiDatas.map(|d| d.name)\n }\n \n-pub impl Abi {\n+impl Abi {\n     #[inline]\n-    fn index(&self) -> uint {\n+    pub fn index(&self) -> uint {\n         *self as uint\n     }\n \n     #[inline]\n-    fn data(&self) -> &'static AbiData {\n+    pub fn data(&self) -> &'static AbiData {\n         &AbiDatas[self.index()]\n     }\n \n-    fn name(&self) -> &'static str {\n+    pub fn name(&self) -> &'static str {\n         self.data().name\n     }\n }\n@@ -131,70 +131,70 @@ impl Architecture {\n     }\n }\n \n-pub impl AbiSet {\n-    fn from(abi: Abi) -> AbiSet {\n+impl AbiSet {\n+    pub fn from(abi: Abi) -> AbiSet {\n         AbiSet { bits: (1 << abi.index()) }\n     }\n \n     #[inline]\n-    fn Rust() -> AbiSet {\n+    pub fn Rust() -> AbiSet {\n         AbiSet::from(Rust)\n     }\n \n     #[inline]\n-    fn C() -> AbiSet {\n+    pub fn C() -> AbiSet {\n         AbiSet::from(C)\n     }\n \n     #[inline]\n-    fn Intrinsic() -> AbiSet {\n+    pub fn Intrinsic() -> AbiSet {\n         AbiSet::from(RustIntrinsic)\n     }\n \n-    fn default() -> AbiSet {\n+    pub fn default() -> AbiSet {\n         AbiSet::C()\n     }\n \n-    fn empty() -> AbiSet {\n+    pub fn empty() -> AbiSet {\n         AbiSet { bits: 0 }\n     }\n \n     #[inline]\n-    fn is_rust(&self) -> bool {\n+    pub fn is_rust(&self) -> bool {\n         self.bits == 1 << Rust.index()\n     }\n \n     #[inline]\n-    fn is_c(&self) -> bool {\n+    pub fn is_c(&self) -> bool {\n         self.bits == 1 << C.index()\n     }\n \n     #[inline]\n-    fn is_intrinsic(&self) -> bool {\n+    pub fn is_intrinsic(&self) -> bool {\n         self.bits == 1 << RustIntrinsic.index()\n     }\n \n-    fn contains(&self, abi: Abi) -> bool {\n+    pub fn contains(&self, abi: Abi) -> bool {\n         (self.bits & (1 << abi.index())) != 0\n     }\n \n-    fn subset_of(&self, other_abi_set: AbiSet) -> bool {\n+    pub fn subset_of(&self, other_abi_set: AbiSet) -> bool {\n         (self.bits & other_abi_set.bits) == self.bits\n     }\n \n-    fn add(&mut self, abi: Abi) {\n+    pub fn add(&mut self, abi: Abi) {\n         self.bits |= (1 << abi.index());\n     }\n \n-    fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n+    pub fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n         each_abi(|abi| !self.contains(abi) || op(abi))\n     }\n \n-    fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n \n-    fn for_arch(&self, arch: Architecture) -> Option<Abi> {\n+    pub fn for_arch(&self, arch: Architecture) -> Option<Abi> {\n         // NB---Single platform ABIs come first\n         for self.each |abi| {\n             let data = abi.data();\n@@ -208,7 +208,7 @@ pub impl AbiSet {\n         None\n     }\n \n-    fn check_valid(&self) -> Option<(Abi, Abi)> {\n+    pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n         let mut abis = ~[];\n         for self.each |abi| { abis.push(abi); }\n "}, {"sha": "ac9734ebaa3bf9c7657077074877508cfc9e9ee1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -166,14 +166,14 @@ pub struct Generics {\n     ty_params: OptVec<TyParam>\n }\n \n-pub impl Generics {\n-    fn is_parameterized(&self) -> bool {\n+impl Generics {\n+    pub fn is_parameterized(&self) -> bool {\n         self.lifetimes.len() + self.ty_params.len() > 0\n     }\n-    fn is_lt_parameterized(&self) -> bool {\n+    pub fn is_lt_parameterized(&self) -> bool {\n         self.lifetimes.len() > 0\n     }\n-    fn is_type_parameterized(&self) -> bool {\n+    pub fn is_type_parameterized(&self) -> bool {\n         self.ty_params.len() > 0\n     }\n }"}, {"sha": "4da2d500dd84759efb38e104c8286c84b78c1442", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -373,17 +373,19 @@ pub struct id_range {\n     max: node_id,\n }\n \n-pub impl id_range {\n-    fn max() -> id_range {\n-        id_range {min: int::max_value,\n-                  max: int::min_value}\n+impl id_range {\n+    pub fn max() -> id_range {\n+        id_range {\n+            min: int::max_value,\n+            max: int::min_value,\n+        }\n     }\n \n-    fn empty(&self) -> bool {\n+    pub fn empty(&self) -> bool {\n         self.min >= self.max\n     }\n \n-    fn add(&mut self, id: node_id) {\n+    pub fn add(&mut self, id: node_id) {\n         self.min = int::min(self.min, id);\n         self.max = int::max(self.max, id + 1);\n     }"}, {"sha": "5f8d6e73cefab6846ce8da4c2535a37299236f19", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -271,13 +271,13 @@ pub struct FileMap {\n     multibyte_chars: @mut ~[MultiByteChar],\n }\n \n-pub impl FileMap {\n+impl FileMap {\n     // EFFECT: register a start-of-line offset in the\n     // table of line-beginnings.\n     // UNCHECKED INVARIANT: these offsets must be added in the right\n     // order and must be in the right places; there is shared knowledge\n     // about what ends a line between this file and parse.rs\n-    fn next_line(&self, pos: BytePos) {\n+    pub fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n         assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos))\n@@ -309,24 +309,23 @@ pub struct CodeMap {\n     files: @mut ~[@FileMap]\n }\n \n-pub impl CodeMap {\n+impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n             files: @mut ~[],\n         }\n     }\n \n     /// Add a new FileMap to the CodeMap and return it\n-    fn new_filemap(&self, filename: FileName, src: @~str) -> @FileMap {\n+    pub fn new_filemap(&self, filename: FileName, src: @~str) -> @FileMap {\n         return self.new_filemap_w_substr(filename, FssNone, src);\n     }\n \n-    fn new_filemap_w_substr(\n-        &self,\n-        filename: FileName,\n-        substr: FileSubstr,\n-        src: @~str\n-    ) -> @FileMap {\n+    pub fn new_filemap_w_substr(&self,\n+                                filename: FileName,\n+                                substr: FileSubstr,\n+                                src: @~str)\n+                                -> @FileMap {\n         let files = &mut *self.files;\n         let start_pos = if files.len() == 0 {\n             0\n@@ -359,8 +358,7 @@ pub impl CodeMap {\n         return self.lookup_pos(pos);\n     }\n \n-    pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt\n-    {\n+    pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         match (loc.file.substr) {\n             FssNone =>\n@@ -430,11 +428,9 @@ pub impl CodeMap {\n         //      (or expected function, found _|_)\n         fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n     }\n-\n }\n \n-priv impl CodeMap {\n-\n+impl CodeMap {\n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = &*self.files;\n         let len = files.len();"}, {"sha": "5fae6ff3c18b01cc1bf28cb9989b71501fbcb81a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -219,8 +219,9 @@ pub struct ExtCtxt {\n     trace_mac: @mut bool\n }\n \n-pub impl ExtCtxt {\n-    fn new(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg) -> @ExtCtxt {\n+impl ExtCtxt {\n+    pub fn new(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n+               -> @ExtCtxt {\n         @ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n@@ -230,21 +231,21 @@ pub impl ExtCtxt {\n         }\n     }\n \n-    fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n-    fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n-    fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n-    fn call_site(&self) -> span {\n+    pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n+    pub fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n+    pub fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n+    pub fn call_site(&self) -> span {\n         match *self.backtrace {\n             Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n             None => self.bug(\"missing top span\")\n         }\n     }\n-    fn print_backtrace(&self) { }\n-    fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n-    fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n-    fn mod_pop(&self) { self.mod_path.pop(); }\n-    fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n-    fn bt_push(&self, ei: codemap::ExpnInfo) {\n+    pub fn print_backtrace(&self) { }\n+    pub fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n+    pub fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n+    pub fn mod_pop(&self) { self.mod_path.pop(); }\n+    pub fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n+    pub fn bt_push(&self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n@@ -255,7 +256,7 @@ pub impl ExtCtxt {\n             }\n         }\n     }\n-    fn bt_pop(&self) {\n+    pub fn bt_pop(&self) {\n         match *self.backtrace {\n             Some(@ExpandedFrom(\n                 CallInfo {\n@@ -266,43 +267,43 @@ pub impl ExtCtxt {\n             _ => self.bug(\"tried to pop without a push\")\n         }\n     }\n-    fn span_fatal(&self, sp: span, msg: &str) -> ! {\n+    pub fn span_fatal(&self, sp: span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n     }\n-    fn span_err(&self, sp: span, msg: &str) {\n+    pub fn span_err(&self, sp: span, msg: &str) {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n-    fn span_warn(&self, sp: span, msg: &str) {\n+    pub fn span_warn(&self, sp: span, msg: &str) {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n-    fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n+    pub fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n     }\n-    fn span_bug(&self, sp: span, msg: &str) -> ! {\n+    pub fn span_bug(&self, sp: span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n-    fn bug(&self, msg: &str) -> ! {\n+    pub fn bug(&self, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.handler().bug(msg);\n     }\n-    fn next_id(&self) -> ast::node_id {\n+    pub fn next_id(&self) -> ast::node_id {\n         parse::next_node_id(self.parse_sess)\n     }\n-    fn trace_macros(&self) -> bool {\n+    pub fn trace_macros(&self) -> bool {\n         *self.trace_mac\n     }\n-    fn set_trace_macros(&self, x: bool) {\n+    pub fn set_trace_macros(&self, x: bool) {\n         *self.trace_mac = x\n     }\n-    fn str_of(&self, id: ast::ident) -> ~str {\n+    pub fn str_of(&self, id: ast::ident) -> ~str {\n         copy *self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(&self, st: &str) -> ast::ident {\n+    pub fn ident_of(&self, st: &str) -> ast::ident {\n         self.parse_sess.interner.intern(st)\n     }\n }\n@@ -436,7 +437,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n     }\n \n // traits just don't work anywhere...?\n-//pub impl Map<Name,SyntaxExtension> for MapChain {\n+//impl Map<Name,SyntaxExtension> for MapChain {\n \n     fn contains_key (&self, key: &K) -> bool {\n         match *self {"}, {"sha": "3b39cb691a629927a792a551e49f10ba5f6c4998", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -38,15 +38,18 @@ pub struct Path<'self> {\n     global: bool\n }\n \n-pub impl<'self> Path<'self> {\n-    fn new<'r>(path: ~[&'r str]) -> Path<'r> {\n+impl<'self> Path<'self> {\n+    pub fn new<'r>(path: ~[&'r str]) -> Path<'r> {\n         Path::new_(path, None, ~[], true)\n     }\n-    fn new_local<'r>(path: &'r str) -> Path<'r> {\n+    pub fn new_local<'r>(path: &'r str) -> Path<'r> {\n         Path::new_(~[ path ], None, ~[], false)\n     }\n-    fn new_<'r>(path: ~[&'r str], lifetime: Option<&'r str>, params: ~[~Ty<'r>], global: bool)\n-        -> Path<'r> {\n+    pub fn new_<'r>(path: ~[&'r str],\n+                    lifetime: Option<&'r str>,\n+                    params: ~[~Ty<'r>],\n+                    global: bool)\n+                    -> Path<'r> {\n         Path {\n             path: path,\n             lifetime: lifetime,\n@@ -55,13 +58,21 @@ pub impl<'self> Path<'self> {\n         }\n     }\n \n-    fn to_ty(&self, cx: @ExtCtxt, span: span,\n-             self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n+    pub fn to_ty(&self,\n+                 cx: @ExtCtxt,\n+                 span: span,\n+                 self_ty: ident,\n+                 self_generics: &Generics)\n+                 -> @ast::Ty {\n         cx.ty_path(self.to_path(cx, span,\n                                 self_ty, self_generics))\n     }\n-    fn to_path(&self, cx: @ExtCtxt, span: span,\n-               self_ty: ident, self_generics: &Generics) -> @ast::Path {\n+    pub fn to_path(&self,\n+                   cx: @ExtCtxt,\n+                   span: span,\n+                   self_ty: ident,\n+                   self_generics: &Generics)\n+                   -> @ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n@@ -108,9 +119,13 @@ fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Life\n     }\n }\n \n-pub impl<'self> Ty<'self> {\n-    fn to_ty(&self, cx: @ExtCtxt, span: span,\n-             self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n+impl<'self> Ty<'self> {\n+    pub fn to_ty(&self,\n+                 cx: @ExtCtxt,\n+                 span: span,\n+                 self_ty: ident,\n+                 self_generics: &Generics)\n+                 -> @ast::Ty {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n@@ -143,8 +158,12 @@ pub impl<'self> Ty<'self> {\n         }\n     }\n \n-    fn to_path(&self, cx: @ExtCtxt, span: span,\n-               self_ty: ident, self_generics: &Generics) -> @ast::Path {\n+    pub fn to_path(&self,\n+                   cx: @ExtCtxt,\n+                   span: span,\n+                   self_ty: ident,\n+                   self_generics: &Generics)\n+                   -> @ast::Path {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n@@ -192,14 +211,18 @@ pub struct LifetimeBounds<'self> {\n     bounds: ~[(&'self str, ~[Path<'self>])]\n }\n \n-pub impl<'self> LifetimeBounds<'self> {\n-    fn empty() -> LifetimeBounds<'static> {\n+impl<'self> LifetimeBounds<'self> {\n+    pub fn empty() -> LifetimeBounds<'static> {\n         LifetimeBounds {\n             lifetimes: ~[], bounds: ~[]\n         }\n     }\n-    fn to_generics(&self, cx: @ExtCtxt, span: span,\n-                   self_ty: ident, self_generics: &Generics) -> Generics {\n+    pub fn to_generics(&self,\n+                       cx: @ExtCtxt,\n+                       span: span,\n+                       self_ty: ident,\n+                       self_generics: &Generics)\n+                       -> Generics {\n         let lifetimes = do self.lifetimes.map |lt| {\n             cx.lifetime(span, cx.ident_of(*lt))\n         };"}, {"sha": "0eb0f5c615927068425b60de06641f4773ccf7d6", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -28,8 +28,8 @@ impl ToStr for direction {\n     }\n }\n \n-pub impl direction {\n-    fn reverse(&self) -> direction {\n+impl direction {\n+    pub fn reverse(&self) -> direction {\n         match *self {\n           send => recv,\n           recv => send\n@@ -45,21 +45,21 @@ pub struct next_state {\n // name, span, data, current state, next state\n pub struct message(~str, span, ~[@ast::Ty], state, Option<next_state>);\n \n-pub impl message {\n-    fn name(&mut self) -> ~str {\n+impl message {\n+    pub fn name(&mut self) -> ~str {\n         match *self {\n           message(ref id, _, _, _, _) => copy *id\n         }\n     }\n \n-    fn span(&mut self) -> span {\n+    pub fn span(&mut self) -> span {\n         match *self {\n           message(_, span, _, _, _) => span\n         }\n     }\n \n     /// Return the type parameters actually used by this message\n-    fn get_generics(&self) -> ast::Generics {\n+    pub fn get_generics(&self) -> ast::Generics {\n         match *self {\n           message(_, _, _, this, _) => copy this.generics\n         }\n@@ -79,31 +79,34 @@ pub struct state_ {\n     proto: protocol\n }\n \n-pub impl state_ {\n-    fn add_message(@self, name: ~str, span: span,\n-                   data: ~[@ast::Ty], next: Option<next_state>) {\n+impl state_ {\n+    pub fn add_message(@self,\n+                       name: ~str,\n+                       span: span,\n+                       data: ~[@ast::Ty],\n+                       next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n \n-    fn filename(&self) -> ~str {\n+    pub fn filename(&self) -> ~str {\n         self.proto.filename()\n     }\n \n-    fn data_name(&self) -> ast::ident {\n+    pub fn data_name(&self) -> ast::ident {\n         self.ident\n     }\n \n     /// Returns the type that is used for the messages.\n-    fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(&self.generics.ty_params)))\n     }\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n-    fn reachable(&self, f: &fn(state) -> bool) -> bool {\n+    pub fn reachable(&self, f: &fn(state) -> bool) -> bool {\n         for self.messages.each |m| {\n             match *m {\n               message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n@@ -140,48 +143,49 @@ pub struct protocol_ {\n     bounded: Option<bool>,\n }\n \n-pub impl protocol_ {\n+impl protocol_ {\n     /// Get a state.\n-    fn get_state(&self, name: &str) -> state {\n+    pub fn get_state(&self, name: &str) -> state {\n         self.states.find(|i| name == i.name).get()\n     }\n \n-    fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n+    pub fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(&self, name: &str) -> bool {\n+    pub fn has_state(&self, name: &str) -> bool {\n         self.states.find(|i| name == i.name).is_some()\n     }\n \n-    fn filename(&self) -> ~str {\n+    pub fn filename(&self) -> ~str {\n         ~\"proto://\" + self.name\n     }\n \n-    fn num_states(&self) -> uint {\n+    pub fn num_states(&self) -> uint {\n         let states = &mut *self.states;\n         states.len()\n     }\n \n-    fn has_ty_params(&self) -> bool {\n+    pub fn has_ty_params(&self) -> bool {\n         for self.states.each |s| {\n             if s.generics.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n         false\n     }\n-    fn is_bounded(&self) -> bool {\n+\n+    pub fn is_bounded(&self) -> bool {\n         let bounded = self.bounded.get();\n         bounded\n     }\n }\n \n-pub impl protocol_ {\n-    fn add_state_poly(@mut self,\n-                      name: ~str,\n-                      ident: ast::ident,\n-                      dir: direction,\n-                      generics: ast::Generics)\n-                   -> state {\n+impl protocol_ {\n+    pub fn add_state_poly(@mut self,\n+                          name: ~str,\n+                          ident: ast::ident,\n+                          dir: direction,\n+                          generics: ast::Generics)\n+                          -> state {\n         let messages = @mut ~[];\n         let states = &mut *self.states;\n "}, {"sha": "8a930cf9afd54d95dacc1e51c6f9a6abff4247b8", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -52,18 +52,18 @@ pub fn token_to_str(reader: @reader, token: &token::Token) -> ~str {\n     token::to_str(reader.interner(), token)\n }\n \n-pub impl Parser {\n+impl Parser {\n     // convert a token to a string using self's reader\n-    fn token_to_str(&self, token: &token::Token) -> ~str {\n+    pub fn token_to_str(&self, token: &token::Token) -> ~str {\n         token::to_str(self.reader.interner(), token)\n     }\n \n     // convert the current token to a string using self's reader\n-    fn this_token_to_str(&self) -> ~str {\n+    pub fn this_token_to_str(&self) -> ~str {\n         self.token_to_str(self.token)\n     }\n \n-    fn unexpected_last(&self, t: &token::Token) -> ! {\n+    pub fn unexpected_last(&self, t: &token::Token) -> ! {\n         self.span_fatal(\n             *self.last_span,\n             fmt!(\n@@ -73,7 +73,7 @@ pub impl Parser {\n         );\n     }\n \n-    fn unexpected(&self) -> ! {\n+    pub fn unexpected(&self) -> ! {\n         self.fatal(\n             fmt!(\n                 \"unexpected token: `%s`\",\n@@ -84,7 +84,7 @@ pub impl Parser {\n \n     // expect and consume the token t. Signal an error if\n     // the next token is not t.\n-    fn expect(&self, t: &token::Token) {\n+    pub fn expect(&self, t: &token::Token) {\n         if *self.token == *t {\n             self.bump();\n         } else {\n@@ -98,7 +98,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_ident(&self) -> ast::ident {\n+    pub fn parse_ident(&self) -> ast::ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match *self.token {\n@@ -120,7 +120,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_path_list_ident(&self) -> ast::path_list_ident {\n+    pub fn parse_path_list_ident(&self) -> ast::path_list_ident {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         let hi = self.last_span.hi;\n@@ -130,17 +130,17 @@ pub impl Parser {\n \n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n-    fn eat(&self, tok: &token::Token) -> bool {\n+    pub fn eat(&self, tok: &token::Token) -> bool {\n         return if *self.token == *tok { self.bump(); true } else { false };\n     }\n \n-    fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n+    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n         token::is_keyword(kw, self.token)\n     }\n \n     // if the next token is the given keyword, eat it and return\n     // true. Otherwise, return false.\n-    fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n+    pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n         let is_kw = match *self.token {\n             token::IDENT(sid, false) => kw.to_ident().repr == sid.repr,\n             _ => false\n@@ -152,7 +152,7 @@ pub impl Parser {\n     // if the given word is not a keyword, signal an error.\n     // if the next token is not the given word, signal an error.\n     // otherwise, eat it.\n-    fn expect_keyword(&self, kw: keywords::Keyword) {\n+    pub fn expect_keyword(&self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n             self.fatal(\n                 fmt!(\n@@ -165,15 +165,15 @@ pub impl Parser {\n     }\n \n     // signal an error if the given string is a strict keyword\n-    fn check_strict_keywords(&self) {\n+    pub fn check_strict_keywords(&self) {\n         if token::is_strict_keyword(self.token) {\n             self.span_err(*self.last_span,\n                           fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n         }\n     }\n \n     // signal an error if the current token is a reserved keyword\n-    fn check_reserved_keywords(&self) {\n+    pub fn check_reserved_keywords(&self) {\n         if token::is_reserved_keyword(self.token) {\n             self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n         }\n@@ -182,7 +182,7 @@ pub impl Parser {\n     // expect and consume a GT. if a >> is seen, replace it\n     // with a single > and continue. If a GT is not seen,\n     // signal an error.\n-    fn expect_gt(&self) {\n+    pub fn expect_gt(&self) {\n         if *self.token == token::GT {\n             self.bump();\n         } else if *self.token == token::BINOP(token::SHR) {\n@@ -203,11 +203,10 @@ pub impl Parser {\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    fn parse_seq_to_before_gt<T: Copy>(\n-        &self,\n-        sep: Option<token::Token>,\n-        f: &fn(&Parser) -> T\n-    ) -> OptVec<T> {\n+    pub fn parse_seq_to_before_gt<T: Copy>(&self,\n+                                           sep: Option<token::Token>,\n+                                           f: &fn(&Parser) -> T)\n+                                           -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n         while *self.token != token::GT\n@@ -224,11 +223,10 @@ pub impl Parser {\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T: Copy>(\n-        &self,\n-        sep: Option<token::Token>,\n-        f: &fn(&Parser) -> T\n-    ) -> OptVec<T> {\n+    pub fn parse_seq_to_gt<T: Copy>(&self,\n+                                    sep: Option<token::Token>,\n+                                    f: &fn(&Parser) -> T)\n+                                    -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n@@ -237,12 +235,11 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_end<T: Copy>(\n-        &self,\n-        ket: &token::Token,\n-        sep: SeqSep,\n-        f: &fn(&Parser) -> T\n-    ) -> ~[T] {\n+    pub fn parse_seq_to_end<T: Copy>(&self,\n+                                     ket: &token::Token,\n+                                     sep: SeqSep,\n+                                     f: &fn(&Parser) -> T)\n+                                     -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -251,12 +248,11 @@ pub impl Parser {\n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_before_end<T: Copy>(\n-        &self,\n-        ket: &token::Token,\n-        sep: SeqSep,\n-        f: &fn(&Parser) -> T\n-    ) -> ~[T] {\n+    pub fn parse_seq_to_before_end<T: Copy>(&self,\n+                                            ket: &token::Token,\n+                                            sep: SeqSep,\n+                                            f: &fn(&Parser) -> T)\n+                                            -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n         while *self.token != *ket {\n@@ -276,13 +272,12 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_unspanned_seq<T: Copy>(\n-        &self,\n-        bra: &token::Token,\n-        ket: &token::Token,\n-        sep: SeqSep,\n-        f: &fn(&Parser) -> T\n-    ) -> ~[T] {\n+    pub fn parse_unspanned_seq<T: Copy>(&self,\n+                                        bra: &token::Token,\n+                                        ket: &token::Token,\n+                                        sep: SeqSep,\n+                                        f: &fn(&Parser) -> T)\n+                                        -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -291,13 +286,12 @@ pub impl Parser {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T: Copy>(\n-        &self,\n-        bra: &token::Token,\n-        ket: &token::Token,\n-        sep: SeqSep,\n-        f: &fn(&Parser) -> T\n-    ) -> spanned<~[T]> {\n+    pub fn parse_seq<T: Copy>(&self,\n+                              bra: &token::Token,\n+                              ket: &token::Token,\n+                              sep: SeqSep,\n+                              f: &fn(&Parser) -> T)\n+                              -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);"}, {"sha": "f11219f6c9e1efd70844b9da4ad16af8e8855e19", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -73,9 +73,9 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n     }\n }\n \n-pub impl Parser {\n+impl Parser {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: span, kind: ObsoleteSyntax) {\n+    pub fn obsolete(&self, sp: span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n             ObsoleteLowerCaseKindBounds => (\n                 \"lower-case kind bounds\",\n@@ -232,13 +232,16 @@ pub impl Parser {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr {\n+    pub fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr {\n         self.obsolete(sp, kind);\n         self.mk_expr(sp.lo, sp.hi, expr_lit(@respan(sp, lit_nil)))\n     }\n \n-    priv fn report(&self, sp: span, kind: ObsoleteSyntax, kind_str: &str,\n-                   desc: &str) {\n+    fn report(&self,\n+              sp: span,\n+              kind: ObsoleteSyntax,\n+              kind_str: &str,\n+              desc: &str) {\n         self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n \n         if !self.obsolete_set.contains(&kind) {\n@@ -247,7 +250,8 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool {\n+    pub fn token_is_obsolete_ident(&self, ident: &str, token: &Token)\n+                                   -> bool {\n         match *token {\n             token::IDENT(sid, _) => {\n                 str::eq_slice(*self.id_to_str(sid), ident)\n@@ -256,11 +260,11 @@ pub impl Parser {\n         }\n     }\n \n-    fn is_obsolete_ident(&self, ident: &str) -> bool {\n+    pub fn is_obsolete_ident(&self, ident: &str) -> bool {\n         self.token_is_obsolete_ident(ident, self.token)\n     }\n \n-    fn eat_obsolete_ident(&self, ident: &str) -> bool {\n+    pub fn eat_obsolete_ident(&self, ident: &str) -> bool {\n         if self.is_obsolete_ident(ident) {\n             self.bump();\n             true\n@@ -269,7 +273,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_struct_ctor(&self) -> bool {\n+    pub fn try_parse_obsolete_struct_ctor(&self) -> bool {\n         if self.eat_obsolete_ident(\"new\") {\n             self.obsolete(*self.last_span, ObsoleteStructCtor);\n             self.parse_fn_decl();\n@@ -280,7 +284,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_with(&self) -> bool {\n+    pub fn try_parse_obsolete_with(&self) -> bool {\n         if *self.token == token::COMMA\n             && self.token_is_obsolete_ident(\"with\",\n                                             &self.look_ahead(1u)) {\n@@ -295,7 +299,8 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool {\n+    pub fn try_parse_obsolete_priv_section(&self, attrs: &[attribute])\n+                                           -> bool {\n         if self.is_keyword(keywords::Priv) && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n             self.eat_keyword(keywords::Priv);"}, {"sha": "00ad12ce40241fc21e38511e5068b3481be44a9e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 106, "deletions": 113, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -272,9 +272,9 @@ impl Drop for Parser {\n     fn finalize(&self) {}\n }\n \n-pub impl Parser {\n+impl Parser {\n     // advance the parser by one token\n-    fn bump(&self) {\n+    pub fn bump(&self) {\n         *self.last_span = copy *self.span;\n         let next = if *self.buffer_start == *self.buffer_end {\n             self.reader.next_token()\n@@ -288,76 +288,78 @@ pub impl Parser {\n         *self.tokens_consumed += 1u;\n     }\n     // EFFECT: replace the current token and span with the given one\n-    fn replace_token(&self, next: token::Token, lo: BytePos, hi: BytePos) {\n+    pub fn replace_token(&self,\n+                         next: token::Token,\n+                         lo: BytePos,\n+                         hi: BytePos) {\n         *self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n-    fn buffer_length(&self) -> int {\n+    pub fn buffer_length(&self) -> int {\n         if *self.buffer_start <= *self.buffer_end {\n             return *self.buffer_end - *self.buffer_start;\n         }\n         return (4 - *self.buffer_start) + *self.buffer_end;\n     }\n-    fn look_ahead(&self, distance: uint) -> token::Token {\n+    pub fn look_ahead(&self, distance: uint) -> token::Token {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[*self.buffer_end] = self.reader.next_token();\n             *self.buffer_end = (*self.buffer_end + 1) & 3;\n         }\n         return copy self.buffer[(*self.buffer_start + dist - 1) & 3].tok;\n     }\n-    fn fatal(&self, m: &str) -> ! {\n+    pub fn fatal(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*copy self.span, m)\n     }\n-    fn span_fatal(&self, sp: span, m: &str) -> ! {\n+    pub fn span_fatal(&self, sp: span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    fn span_note(&self, sp: span, m: &str) {\n+    pub fn span_note(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n-    fn bug(&self, m: &str) -> ! {\n+    pub fn bug(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(*copy self.span, m)\n     }\n-    fn warn(&self, m: &str) {\n+    pub fn warn(&self, m: &str) {\n         self.sess.span_diagnostic.span_warn(*copy self.span, m)\n     }\n-    fn span_err(&self, sp: span, m: &str) {\n+    pub fn span_err(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n-    fn abort_if_errors(&self) {\n+    pub fn abort_if_errors(&self) {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n-    fn get_id(&self) -> node_id { next_node_id(self.sess) }\n+    pub fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n-    fn id_to_str(&self, id: ident) -> @~str {\n+    pub fn id_to_str(&self, id: ident) -> @~str {\n         self.sess.interner.get(id)\n     }\n \n     // is this one of the keywords that signals a closure type?\n-    fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n+    pub fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n         token::is_keyword(keywords::Pure, tok) ||\n             token::is_keyword(keywords::Unsafe, tok) ||\n             token::is_keyword(keywords::Once, tok) ||\n             token::is_keyword(keywords::Fn, tok)\n     }\n \n-    fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n+    pub fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n         match *tok {\n             token::LIFETIME(*) => true,\n             _ => false,\n         }\n     }\n \n-    fn get_lifetime(&self, tok: &token::Token) -> ast::ident {\n+    pub fn get_lifetime(&self, tok: &token::Token) -> ast::ident {\n         match *tok {\n             token::LIFETIME(ref ident) => copy *ident,\n             _ => self.bug(\"not a lifetime\"),\n         }\n     }\n \n     // parse a ty_bare_fun type:\n-    fn parse_ty_bare_fn(&self) -> ty_\n-    {\n+    pub fn parse_ty_bare_fn(&self) -> ty_ {\n         /*\n \n         extern \"ABI\" [pure|unsafe] fn <'lt> (S) -> T\n@@ -386,10 +388,10 @@ pub impl Parser {\n     }\n \n     // parse a ty_closure type\n-    fn parse_ty_closure(&self,\n-                        sigil: ast::Sigil,\n-                        region: Option<@ast::Lifetime>)\n-                        -> ty_ {\n+    pub fn parse_ty_closure(&self,\n+                            sigil: ast::Sigil,\n+                            region: Option<@ast::Lifetime>)\n+                            -> ty_ {\n         /*\n \n         (&|~|@) ['r] [pure|unsafe] [once] fn [:Bounds] <'lt> (S) -> T\n@@ -440,7 +442,7 @@ pub impl Parser {\n     }\n \n     // looks like this should be called parse_unsafety\n-    fn parse_unsafety(&self) -> purity {\n+    pub fn parse_unsafety(&self) -> purity {\n         if self.eat_keyword(keywords::Pure) {\n             self.obsolete(*self.last_span, ObsoletePurity);\n             return impure_fn;\n@@ -452,7 +454,7 @@ pub impl Parser {\n     }\n \n     // parse a function type (following the 'fn')\n-    fn parse_ty_fn_decl(&self) -> (fn_decl, OptVec<ast::Lifetime>) {\n+    pub fn parse_ty_fn_decl(&self) -> (fn_decl, OptVec<ast::Lifetime>) {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -487,7 +489,7 @@ pub impl Parser {\n     }\n \n     // parse the methods in a trait declaration\n-    fn parse_trait_methods(&self) -> ~[trait_method] {\n+    pub fn parse_trait_methods(&self) -> ~[trait_method] {\n         do self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -563,17 +565,16 @@ pub impl Parser {\n         }\n     }\n \n-\n     // parse a possibly mutable type\n-    fn parse_mt(&self) -> mt {\n+    pub fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n     // parse [mut/const/imm] ID : TY\n     // now used only by obsolete record syntax parser...\n-    fn parse_ty_field(&self) -> ty_field {\n+    pub fn parse_ty_field(&self) -> ty_field {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n@@ -590,7 +591,7 @@ pub impl Parser {\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n+    pub fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n@@ -621,7 +622,7 @@ pub impl Parser {\n     // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n-    fn parse_ty(&self, _: bool) -> @Ty {\n+    pub fn parse_ty(&self, _: bool) -> @Ty {\n         maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -722,11 +723,9 @@ pub impl Parser {\n     }\n \n     // parse the type following a @ or a ~\n-    fn parse_box_or_uniq_pointee(\n-        &self,\n-        sigil: ast::Sigil,\n-        ctor: &fn(v: mt) -> ty_) -> ty_\n-    {\n+    pub fn parse_box_or_uniq_pointee(&self,\n+                                     sigil: ast::Sigil,\n+                                     ctor: &fn(v: mt) -> ty_) -> ty_ {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n@@ -765,7 +764,7 @@ pub impl Parser {\n         ctor(mt)\n     }\n \n-    fn parse_borrowed_pointee(&self) -> ty_ {\n+    pub fn parse_borrowed_pointee(&self) -> ty_ {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n@@ -778,7 +777,7 @@ pub impl Parser {\n     }\n \n     // parse an optional, obsolete argument mode.\n-    fn parse_arg_mode(&self) {\n+    pub fn parse_arg_mode(&self) {\n         if self.eat(&token::BINOP(token::MINUS)) {\n             self.obsolete(*self.span, ObsoleteMode);\n         } else if self.eat(&token::ANDAND) {\n@@ -794,7 +793,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn is_named_argument(&self) -> bool {\n+    pub fn is_named_argument(&self) -> bool {\n         let offset = if *self.token == token::BINOP(token::AND) {\n             1\n         } else if *self.token == token::BINOP(token::MINUS) {\n@@ -819,7 +818,7 @@ pub impl Parser {\n \n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n-    fn parse_arg_general(&self, require_name: bool) -> arg {\n+    pub fn parse_arg_general(&self, require_name: bool) -> arg {\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n             self.parse_arg_mode();\n@@ -844,12 +843,12 @@ pub impl Parser {\n     }\n \n     // parse a single function argument\n-    fn parse_arg(&self) -> arg_or_capture_item {\n+    pub fn parse_arg(&self) -> arg_or_capture_item {\n         either::Left(self.parse_arg_general(true))\n     }\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n-    fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n+    pub fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = self.parse_pat();\n@@ -870,7 +869,7 @@ pub impl Parser {\n         })\n     }\n \n-    fn maybe_parse_fixed_vstore(&self) -> Option<@ast::expr> {\n+    pub fn maybe_parse_fixed_vstore(&self) -> Option<@ast::expr> {\n         if self.eat(&token::BINOP(token::STAR)) {\n             self.obsolete(*self.last_span, ObsoleteFixedLengthVectorType);\n             Some(self.parse_expr())\n@@ -885,7 +884,7 @@ pub impl Parser {\n     }\n \n     // matches token_lit = LIT_INT | ...\n-    fn lit_from_token(&self, tok: &token::Token) -> lit_ {\n+    pub fn lit_from_token(&self, tok: &token::Token) -> lit_ {\n         match *tok {\n             token::LIT_INT(i, it) => lit_int(i, it),\n             token::LIT_UINT(u, ut) => lit_uint(u, ut),\n@@ -900,7 +899,7 @@ pub impl Parser {\n     }\n \n     // matches lit = true | false | token_lit\n-    fn parse_lit(&self) -> lit {\n+    pub fn parse_lit(&self) -> lit {\n         let lo = self.span.lo;\n         let lit = if self.eat_keyword(keywords::True) {\n             lit_bool(true)\n@@ -916,7 +915,7 @@ pub impl Parser {\n     }\n \n     // matches '-' lit | lit\n-    fn parse_literal_maybe_minus(&self) -> @expr {\n+    pub fn parse_literal_maybe_minus(&self) -> @expr {\n         let minus_lo = self.span.lo;\n         let minus_present = self.eat(&token::BINOP(token::MINUS));\n \n@@ -935,15 +934,15 @@ pub impl Parser {\n \n     // parse a path into a vector of idents, whether the path starts\n     // with ::, and a span.\n-    fn parse_path(&self) -> (~[ast::ident],bool,span) {\n+    pub fn parse_path(&self) -> (~[ast::ident],bool,span) {\n         let lo = self.span.lo;\n         let is_global = self.eat(&token::MOD_SEP);\n         let (ids,span{lo:_,hi,expn_info}) = self.parse_path_non_global();\n         (ids,is_global,span{lo:lo,hi:hi,expn_info:expn_info})\n     }\n \n     // parse a path beginning with an identifier into a vector of idents and a span\n-    fn parse_path_non_global(&self) -> (~[ast::ident],span) {\n+    pub fn parse_path_non_global(&self) -> (~[ast::ident],span) {\n         let lo = self.span.lo;\n         let mut ids = ~[];\n         // must be at least one to begin:\n@@ -966,8 +965,7 @@ pub impl Parser {\n     }\n \n     // parse a path that doesn't have type parameters attached\n-    fn parse_path_without_tps(&self)\n-        -> @ast::Path {\n+    pub fn parse_path_without_tps(&self) -> @ast::Path {\n         maybe_whole!(self, nt_path);\n         let (ids,is_global,sp) = self.parse_path();\n         @ast::Path { span: sp,\n@@ -980,7 +978,7 @@ pub impl Parser {\n     // parse a path optionally with type parameters. If 'colons'\n     // is true, then type parameters must be preceded by colons,\n     // as in a::t::<t1,t2>\n-    fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -1042,7 +1040,7 @@ pub impl Parser {\n     }\n \n     /// parses 0 or 1 lifetime\n-    fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n+    pub fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n         match *self.token {\n             token::LIFETIME(*) => {\n                 Some(@self.parse_lifetime())\n@@ -1064,7 +1062,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n+    pub fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n         match *tok {\n             token::LIFETIME(_) => true,\n             _ => false\n@@ -1073,7 +1071,7 @@ pub impl Parser {\n \n     /// Parses a single lifetime\n     // matches lifetime = ( LIFETIME ) | ( IDENT / )\n-    fn parse_lifetime(&self) -> ast::Lifetime {\n+    pub fn parse_lifetime(&self) -> ast::Lifetime {\n         match *self.token {\n             token::LIFETIME(i) => {\n                 let span = copy self.span;\n@@ -1107,7 +1105,7 @@ pub impl Parser {\n     // matches lifetimes = ( lifetime ) | ( lifetime , lifetimes )\n     // actually, it matches the empty one too, but putting that in there\n     // messes up the grammar....\n-    fn parse_lifetimes(&self) -> OptVec<ast::Lifetime> {\n+    pub fn parse_lifetimes(&self) -> OptVec<ast::Lifetime> {\n         /*!\n          *\n          * Parses zero or more comma separated lifetimes.\n@@ -1139,13 +1137,13 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_mutability(&self, tok: &token::Token) -> bool {\n+    pub fn token_is_mutability(&self, tok: &token::Token) -> bool {\n         token::is_keyword(keywords::Mut, tok) ||\n         token::is_keyword(keywords::Const, tok)\n     }\n \n     // parse mutability declaration (mut/const/imm)\n-    fn parse_mutability(&self) -> mutability {\n+    pub fn parse_mutability(&self) -> mutability {\n         if self.eat_keyword(keywords::Mut) {\n             m_mutbl\n         } else if self.eat_keyword(keywords::Const) {\n@@ -1156,7 +1154,7 @@ pub impl Parser {\n     }\n \n     // parse ident COLON expr\n-    fn parse_field(&self) -> field {\n+    pub fn parse_field(&self) -> field {\n         let lo = self.span.lo;\n         let i = self.parse_ident();\n         self.expect(&token::COLON);\n@@ -1167,7 +1165,7 @@ pub impl Parser {\n         })\n     }\n \n-    fn mk_expr(&self, lo: BytePos, hi: BytePos, node: expr_) -> @expr {\n+    pub fn mk_expr(&self, lo: BytePos, hi: BytePos, node: expr_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1176,7 +1174,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n+    pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1185,7 +1183,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_lit_u32(&self, i: u32) -> @expr {\n+    pub fn mk_lit_u32(&self, i: u32) -> @expr {\n         let span = self.span;\n         let lv_lit = @codemap::spanned {\n             node: lit_uint(i as u64, ty_u32),\n@@ -1203,7 +1201,7 @@ pub impl Parser {\n     // at the bottom (top?) of the precedence hierarchy,\n     // parse things like parenthesized exprs,\n     // macros, return, etc.\n-    fn parse_bottom_expr(&self) -> @expr {\n+    pub fn parse_bottom_expr(&self) -> @expr {\n         maybe_whole_expr!(self);\n \n         let lo = self.span.lo;\n@@ -1414,23 +1412,20 @@ pub impl Parser {\n     }\n \n     // parse a block or unsafe block\n-    fn parse_block_expr(\n-        &self,\n-        lo: BytePos,\n-        blk_mode: blk_check_mode\n-    ) -> @expr {\n+    pub fn parse_block_expr(&self, lo: BytePos, blk_mode: blk_check_mode)\n+                            -> @expr {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n     // parse a.b or a(13) or a[4] or just a\n-    fn parse_dot_or_call_expr(&self) -> @expr {\n+    pub fn parse_dot_or_call_expr(&self) -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    fn parse_dot_or_call_expr_with(&self, e0: @expr) -> @expr {\n+    pub fn parse_dot_or_call_expr_with(&self, e0: @expr) -> @expr {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -1504,7 +1499,7 @@ pub impl Parser {\n \n     // parse an optional separator followed by a kleene-style\n     // repetition token (+ or *).\n-    fn parse_sep_and_zerok(&self) -> (Option<token::Token>, bool) {\n+    pub fn parse_sep_and_zerok(&self) -> (Option<token::Token>, bool) {\n         if *self.token == token::BINOP(token::STAR)\n             || *self.token == token::BINOP(token::PLUS) {\n             let zerok = *self.token == token::BINOP(token::STAR);\n@@ -1525,7 +1520,7 @@ pub impl Parser {\n     }\n \n     // parse a single token tree from the input.\n-    fn parse_token_tree(&self) -> token_tree {\n+    pub fn parse_token_tree(&self) -> token_tree {\n         maybe_whole!(deref self, nt_tt);\n \n         // this is the fall-through for the 'match' below.\n@@ -1612,15 +1607,15 @@ pub impl Parser {\n \n     // parse a stream of tokens into a list of token_trees,\n     // up to EOF.\n-    fn parse_all_token_trees(&self) -> ~[token_tree] {\n+    pub fn parse_all_token_trees(&self) -> ~[token_tree] {\n         let mut tts = ~[];\n         while *self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n     }\n \n-    fn parse_matchers(&self) -> ~[matcher] {\n+    pub fn parse_matchers(&self) -> ~[matcher] {\n         // unification of matchers and token_trees would vastly improve\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n@@ -1642,12 +1637,11 @@ pub impl Parser {\n     // This goofy function is necessary to correctly match parens in matchers.\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n-    fn parse_matcher_subseq(\n-        &self,\n-        name_idx: @mut uint,\n-        bra: token::Token,\n-        ket: token::Token\n-    ) -> ~[matcher] {\n+    pub fn parse_matcher_subseq(&self,\n+                                name_idx: @mut uint,\n+                                bra: token::Token,\n+                                ket: token::Token)\n+                                -> ~[matcher] {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n@@ -1664,7 +1658,7 @@ pub impl Parser {\n         return ret_val;\n     }\n \n-    fn parse_matcher(&self, name_idx: @mut uint) -> matcher {\n+    pub fn parse_matcher(&self, name_idx: @mut uint) -> matcher {\n         let lo = self.span.lo;\n \n         let m = if *self.token == token::DOLLAR {\n@@ -1699,7 +1693,7 @@ pub impl Parser {\n     }\n \n     // parse a prefix-operator expr\n-    fn parse_prefix_expr(&self) -> @expr {\n+    pub fn parse_prefix_expr(&self) -> @expr {\n         let lo = self.span.lo;\n         let hi;\n \n@@ -1791,13 +1785,12 @@ pub impl Parser {\n     }\n \n     // parse an expression of binops\n-    fn parse_binops(&self) -> @expr {\n+    pub fn parse_binops(&self) -> @expr {\n         self.parse_more_binops(self.parse_prefix_expr(), 0)\n     }\n \n     // parse an expression of binops of at least min_prec precedence\n-    fn parse_more_binops(&self, lhs: @expr, min_prec: uint) ->\n-        @expr {\n+    pub fn parse_more_binops(&self, lhs: @expr, min_prec: uint) -> @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n         let peeked = copy *self.token;\n         if peeked == token::BINOP(token::OR) &&\n@@ -1841,7 +1834,7 @@ pub impl Parser {\n     // parse an assignment expression....\n     // actually, this seems to be the main entry point for\n     // parsing an arbitrary expression.\n-    fn parse_assign_expr(&self) -> @expr {\n+    pub fn parse_assign_expr(&self) -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match *self.token {\n@@ -1892,7 +1885,7 @@ pub impl Parser {\n     }\n \n     // parse an 'if' expression ('if' token already eaten)\n-    fn parse_if_expr(&self) -> @expr {\n+    pub fn parse_if_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n@@ -1907,7 +1900,7 @@ pub impl Parser {\n     }\n \n     // `|args| { ... }` or `{ ...}` like in `do` expressions\n-    fn parse_lambda_block_expr(&self) -> @expr {\n+    pub fn parse_lambda_block_expr(&self) -> @expr {\n         self.parse_lambda_expr_(\n             || {\n                 match *self.token {\n@@ -1935,19 +1928,18 @@ pub impl Parser {\n     }\n \n     // `|args| expr`\n-    fn parse_lambda_expr(&self) -> @expr {\n+    pub fn parse_lambda_expr(&self) -> @expr {\n         self.parse_lambda_expr_(|| self.parse_fn_block_decl(),\n                                 || self.parse_expr())\n     }\n \n     // parse something of the form |args| expr\n     // this is used both in parsing a lambda expr\n     // and in parsing a block expr as e.g. in for...\n-    fn parse_lambda_expr_(\n-        &self,\n-        parse_decl: &fn() -> fn_decl,\n-        parse_body: &fn() -> @expr\n-    ) -> @expr {\n+    pub fn parse_lambda_expr_(&self,\n+                              parse_decl: &fn() -> fn_decl,\n+                              parse_body: &fn() -> @expr)\n+                              -> @expr {\n         let lo = self.last_span.lo;\n         let decl = parse_decl();\n         let body = parse_body();\n@@ -1964,7 +1956,7 @@ pub impl Parser {\n                             expr_fn_block(decl, fakeblock));\n     }\n \n-    fn parse_else_expr(&self) -> @expr {\n+    pub fn parse_else_expr(&self) -> @expr {\n         if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n@@ -1976,9 +1968,11 @@ pub impl Parser {\n     // parse a 'for' or 'do'.\n     // the 'for' and 'do' expressions parse as calls, but look like\n     // function calls followed by a closure expression.\n-    fn parse_sugary_call_expr(&self, keyword: ~str,\n-                              sugar: CallSugar,\n-                              ctor: &fn(v: @expr) -> expr_) -> @expr {\n+    pub fn parse_sugary_call_expr(&self,\n+                                  keyword: ~str,\n+                                  sugar: CallSugar,\n+                                  ctor: &fn(v: @expr) -> expr_)\n+                                  -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -2035,15 +2029,15 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_while_expr(&self) -> @expr {\n+    pub fn parse_while_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n-    fn parse_loop_expr(&self, opt_ident: Option<ast::ident>) -> @expr {\n+    pub fn parse_loop_expr(&self, opt_ident: Option<ast::ident>) -> @expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n             *self.token == token::LBRACE\n@@ -2126,7 +2120,7 @@ pub impl Parser {\n     }\n \n     // parse an expression\n-    fn parse_expr(&self) -> @expr {\n+    pub fn parse_expr(&self) -> @expr {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n@@ -2257,7 +2251,7 @@ pub impl Parser {\n     }\n \n     // parse a pattern.\n-    fn parse_pat(&self) -> @pat {\n+    pub fn parse_pat(&self) -> @pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n@@ -2580,7 +2574,7 @@ pub impl Parser {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    fn parse_stmt(&self, item_attrs: ~[attribute]) -> @stmt {\n+    pub fn parse_stmt(&self, item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n@@ -2674,7 +2668,7 @@ pub impl Parser {\n     }\n \n     // parse a block. No inner attrs are allowed.\n-    fn parse_block(&self) -> blk {\n+    pub fn parse_block(&self) -> blk {\n         maybe_whole!(self, nt_block);\n \n         let lo = self.span.lo;\n@@ -2924,7 +2918,7 @@ pub impl Parser {\n     // matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n     //                  | ( < lifetimes , typaramseq ( , )? > )\n     // where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n-    fn parse_generics(&self) -> ast::Generics {\n+    pub fn parse_generics(&self) -> ast::Generics {\n         if self.eat(&token::LT) {\n             let lifetimes = self.parse_lifetimes();\n             let ty_params = self.parse_seq_to_gt(\n@@ -2958,9 +2952,7 @@ pub impl Parser {\n     }\n \n     // parse the argument list and result type of a function declaration\n-    fn parse_fn_decl(&self)\n-        -> fn_decl\n-    {\n+    pub fn parse_fn_decl(&self) -> fn_decl {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n@@ -3398,9 +3390,10 @@ pub impl Parser {\n     }\n \n     // parse a structure field declaration\n-    fn parse_single_struct_field(&self,\n-                                 vis: visibility,\n-                                 attrs: ~[attribute]) -> @struct_field {\n+    pub fn parse_single_struct_field(&self,\n+                                     vis: visibility,\n+                                     attrs: ~[attribute])\n+                                     -> @struct_field {\n         if self.eat_obsolete_ident(\"let\") {\n             self.obsolete(*self.last_span, ObsoleteLet);\n         }\n@@ -4214,7 +4207,7 @@ pub impl Parser {\n         return iovi_none;\n     }\n \n-    fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n+    pub fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true) {\n             iovi_none =>\n                 None,\n@@ -4493,7 +4486,7 @@ pub impl Parser {\n \n     // Parses a source module as a crate. This is the main\n     // entry point for the parser.\n-    fn parse_crate_mod(&self) -> @crate {\n+    pub fn parse_crate_mod(&self) -> @crate {\n         let lo = self.span.lo;\n         // parse the crate's inner attrs, maybe (oops) one\n         // of the attrs of an item:\n@@ -4507,7 +4500,7 @@ pub impl Parser {\n                                config: copy self.cfg })\n     }\n \n-    fn parse_str(&self) -> @~str {\n+    pub fn parse_str(&self) -> @~str {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();"}, {"sha": "b716384c6ccc5b5dfafc03ad31176fbb22dc12df", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -393,21 +393,22 @@ pub struct ident_interner {\n     priv interner: StrInterner,\n }\n \n-pub impl ident_interner {\n-    fn intern(&self, val: &str) -> ast::ident {\n+impl ident_interner {\n+    pub fn intern(&self, val: &str) -> ast::ident {\n         ast::ident { repr: self.interner.intern(val), ctxt: 0 }\n     }\n-    fn gensym(&self, val: &str) -> ast::ident {\n+    pub fn gensym(&self, val: &str) -> ast::ident {\n         ast::ident { repr: self.interner.gensym(val), ctxt: 0 }\n     }\n-    fn get(&self, idx: ast::ident) -> @~str {\n+    pub fn get(&self, idx: ast::ident) -> @~str {\n         self.interner.get(idx.repr)\n     }\n-    fn len(&self) -> uint {\n+    pub fn len(&self) -> uint {\n         self.interner.len()\n     }\n-    fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n-                                                     -> Option<ast::ident> {\n+    pub fn find_equiv<Q:Hash +\n+                        IterBytes +\n+                        Equiv<@~str>>(&self, val: &Q) -> Option<ast::ident> {\n         match self.interner.find_equiv(val) {\n             Some(v) => Some(ast::ident { repr: v, ctxt: 0 }),\n             None => None,\n@@ -586,8 +587,8 @@ pub mod keywords {\n         Be,\n     }\n \n-    pub impl Keyword {\n-        fn to_ident(&self) -> ident {\n+    impl Keyword {\n+        pub fn to_ident(&self) -> ident {\n             match *self {\n                 As => ident { repr: 35, ctxt: 0 },\n                    Break => ident { repr: 36, ctxt: 0 },"}, {"sha": "f6059980697faa94718c6fa5e6c1540d282c9361", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -87,11 +87,12 @@ pub enum token {\n     EOF,\n }\n \n-pub impl token {\n-    fn is_eof(&self) -> bool {\n+impl token {\n+    pub fn is_eof(&self) -> bool {\n         match *self { EOF => true, _ => false }\n     }\n-    fn is_hardbreak_tok(&self) -> bool {\n+\n+    pub fn is_hardbreak_tok(&self) -> bool {\n         match *self {\n             BREAK(break_t {\n                 offset: 0,\n@@ -274,11 +275,13 @@ pub struct Printer {\n     pending_indentation: int,\n }\n \n-pub impl Printer {\n-    fn last_token(&mut self) -> token { self.token[self.right] }\n+impl Printer {\n+    pub fn last_token(&mut self) -> token { self.token[self.right] }\n     // be very careful with this!\n-    fn replace_last_token(&mut self, t: token) { self.token[self.right] = t; }\n-    fn pretty_print(&mut self, t: token) {\n+    pub fn replace_last_token(&mut self, t: token) {\n+        self.token[self.right] = t;\n+    }\n+    pub fn pretty_print(&mut self, t: token) {\n         debug!(\"pp ~[%u,%u]\", self.left, self.right);\n         match t {\n           EOF => {\n@@ -346,7 +349,7 @@ pub impl Printer {\n           }\n         }\n     }\n-    fn check_stream(&mut self) {\n+    pub fn check_stream(&mut self) {\n         debug!(\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -362,7 +365,7 @@ pub impl Printer {\n             if self.left != self.right { self.check_stream(); }\n         }\n     }\n-    fn scan_push(&mut self, x: uint) {\n+    pub fn scan_push(&mut self, x: uint) {\n         debug!(\"scan_push %u\", x);\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n@@ -373,32 +376,32 @@ pub impl Printer {\n         }\n         self.scan_stack[self.top] = x;\n     }\n-    fn scan_pop(&mut self) -> uint {\n+    pub fn scan_pop(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n         return x;\n     }\n-    fn scan_top(&mut self) -> uint {\n+    pub fn scan_top(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n         return self.scan_stack[self.top];\n     }\n-    fn scan_pop_bottom(&mut self) -> uint {\n+    pub fn scan_pop_bottom(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.bottom += 1u; self.bottom %= self.buf_len; }\n         return x;\n     }\n-    fn advance_right(&mut self) {\n+    pub fn advance_right(&mut self) {\n         self.right += 1u;\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    fn advance_left(&mut self, x: token, L: int) {\n+    pub fn advance_left(&mut self, x: token, L: int) {\n         debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n@@ -418,7 +421,7 @@ pub impl Printer {\n             }\n         }\n     }\n-    fn check_stack(&mut self, k: int) {\n+    pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n             match copy self.token[x] {\n@@ -441,17 +444,17 @@ pub impl Printer {\n             }\n         }\n     }\n-    fn print_newline(&mut self, amount: int) {\n+    pub fn print_newline(&mut self, amount: int) {\n         debug!(\"NEWLINE %d\", amount);\n         (*self.out).write_str(\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n-    fn indent(&mut self, amount: int) {\n+    pub fn indent(&mut self, amount: int) {\n         debug!(\"INDENT %d\", amount);\n         self.pending_indentation += amount;\n     }\n-    fn get_top(&mut self) -> print_stack_elt {\n+    pub fn get_top(&mut self) -> print_stack_elt {\n         let print_stack = &mut *self.print_stack;\n         let n = print_stack.len();\n         if n != 0u {\n@@ -463,14 +466,14 @@ pub impl Printer {\n             }\n         }\n     }\n-    fn print_str(&mut self, s: &str) {\n+    pub fn print_str(&mut self, s: &str) {\n         while self.pending_indentation > 0 {\n             (*self.out).write_str(\" \");\n             self.pending_indentation -= 1;\n         }\n         (*self.out).write_str(s);\n     }\n-    fn print(&mut self, x: token, L: int) {\n+    pub fn print(&mut self, x: token, L: int) {\n         debug!(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n                self.space);\n         debug!(\"%s\", buf_str(copy self.token,"}, {"sha": "c3deb65163dddb70c03bcf01709b052159283e38", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -27,21 +27,21 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n-pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n-    fn new() -> Interner<T> {\n+impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n+    pub fn new() -> Interner<T> {\n         Interner {\n             map: @mut HashMap::new(),\n             vect: @mut ~[],\n         }\n     }\n \n-    fn prefill(init: &[T]) -> Interner<T> {\n+    pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n         for init.each() |v| { rv.intern(*v); }\n         rv\n     }\n \n-    fn intern(&self, val: T) -> uint {\n+    pub fn intern(&self, val: T) -> uint {\n         match self.map.find(&val) {\n             Some(&idx) => return idx,\n             None => (),\n@@ -54,7 +54,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n         new_idx\n     }\n \n-    fn gensym(&self, val: T) -> uint {\n+    pub fn gensym(&self, val: T) -> uint {\n         let new_idx = {\n             let vect = &*self.vect;\n             vect.len()\n@@ -67,11 +67,11 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    fn get(&self, idx: uint) -> T { self.vect[idx] }\n+    pub fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n-    fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n+    pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n \n-    fn find_equiv<Q:Hash + IterBytes + Equiv<T>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<T>>(&self, val: &Q)\n                                               -> Option<uint> {\n         match self.map.find_equiv(val) {\n             Some(v) => Some(*v),\n@@ -88,21 +88,21 @@ pub struct StrInterner {\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n-pub impl StrInterner {\n-    fn new() -> StrInterner {\n+impl StrInterner {\n+    pub fn new() -> StrInterner {\n         StrInterner {\n             map: @mut HashMap::new(),\n             vect: @mut ~[],\n         }\n     }\n \n-    fn prefill(init: &[&str]) -> StrInterner {\n+    pub fn prefill(init: &[&str]) -> StrInterner {\n         let rv = StrInterner::new();\n         for init.each() |v| { rv.intern(*v); }\n         rv\n     }\n \n-    fn intern(&self, val: &str) -> uint {\n+    pub fn intern(&self, val: &str) -> uint {\n         match self.map.find_equiv(&StringRef(val)) {\n             Some(&idx) => return idx,\n             None => (),\n@@ -114,7 +114,7 @@ pub impl StrInterner {\n         new_idx\n     }\n \n-    fn gensym(&self, val: &str) -> uint {\n+    pub fn gensym(&self, val: &str) -> uint {\n         let new_idx = self.len();\n         // leave out of .map to avoid colliding\n         self.vect.push(@val.to_owned());\n@@ -124,12 +124,12 @@ pub impl StrInterner {\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    fn get(&self, idx: uint) -> @~str { self.vect[idx] }\n+    pub fn get(&self, idx: uint) -> @~str { self.vect[idx] }\n \n-    fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n+    pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n \n-    fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n-                                              -> Option<uint> {\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+                                                         -> Option<uint> {\n         match self.map.find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,"}, {"sha": "a15373a703377bf6c0da022b7e56ad6252c039f4", "filename": "src/test/auxiliary/anon_trait_static_method_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,8 +12,8 @@ pub struct Foo {\n     x: int\n }\n \n-pub impl Foo {\n-    fn new() -> Foo {\n+impl Foo {\n+    pub fn new() -> Foo {\n         Foo { x: 3 }\n     }\n }"}, {"sha": "c0275249ca6d47cd93a921a33910e8427e7766fc", "filename": "src/test/auxiliary/cci_class_2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,8 +16,8 @@ pub mod kitties {\n \n     }\n \n-    pub impl cat {\n-        fn speak(&self) {}\n+    impl cat {\n+        pub fn speak(&self) {}\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "7ebf5a1e75a7fceb7052fa03fc7ab2d508de5a0a", "filename": "src/test/auxiliary/cci_class_3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -15,9 +15,9 @@ pub mod kitties {\n         how_hungry : int,\n     }\n \n-    pub impl cat {\n-        fn speak(&mut self) { self.meows += 1u; }\n-        fn meow_count(&mut self) -> uint { self.meows }\n+    impl cat {\n+        pub fn speak(&mut self) { self.meows += 1u; }\n+        pub fn meow_count(&mut self) -> uint { self.meows }\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "98e5c8c2b5bbd59316a209d5c1e41673bbe95388", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,10 +16,10 @@ pub mod kitties {\n         name : ~str,\n     }\n \n-    pub impl cat {\n-        fn speak(&mut self) { self.meow(); }\n+    impl cat {\n+        pub fn speak(&mut self) { self.meow(); }\n \n-        fn eat(&mut self) -> bool {\n+        pub fn eat(&mut self) -> bool {\n             if self.how_hungry > 0 {\n                 error!(\"OM NOM NOM\");\n                 self.how_hungry -= 2;\n@@ -31,8 +31,8 @@ pub mod kitties {\n         }\n     }\n \n-    pub impl cat {\n-        fn meow(&mut self) {\n+    impl cat {\n+        pub fn meow(&mut self) {\n             error!(\"Meow\");\n             self.meows += 1u;\n             if self.meows % 5u == 0u {"}, {"sha": "d64930b3dab22b34f7cecdb694969037159123b8", "filename": "src/test/auxiliary/cci_class_5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,8 +16,8 @@ pub mod kitties {\n         how_hungry : int,\n     }\n \n-    pub impl cat {\n-      priv fn nap(&self) { for uint::range(1, 10000u) |_i|{}}\n+    impl cat {\n+        priv fn nap(&self) { for uint::range(1, 10000u) |_i|{}}\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "90344a544bff4e2a579657ca1ef16243bb6c8215", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,11 +16,12 @@ pub mod kitties {\n         how_hungry : int,\n     }\n \n-    pub impl<U> cat<U> {\n-        fn speak<T>(&mut self, stuff: ~[T]) {\n+    impl<U> cat<U> {\n+        pub fn speak<T>(&mut self, stuff: ~[T]) {\n             self.meows += stuff.len();\n         }\n-        fn meow_count(&mut self) -> uint { self.meows }\n+\n+        pub fn meow_count(&mut self) -> uint { self.meows }\n     }\n \n     pub fn cat<U>(in_x : uint, in_y : int, in_info: ~[U]) -> cat<U> {"}, {"sha": "1e82b85f728c068abd589f0454cd4193c6003dcd", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -21,7 +21,7 @@ pub mod kitty {\n        fn to_str(&self) -> ~str { copy self.name }\n     }\n \n-    priv impl cat {\n+    impl cat {\n         fn meow(&mut self) {\n             error!(\"Meow\");\n             self.meows += 1u;\n@@ -32,10 +32,10 @@ pub mod kitty {\n \n     }\n \n-    pub impl cat {\n-        fn speak(&mut self) { self.meow(); }\n+    impl cat {\n+        pub fn speak(&mut self) { self.meow(); }\n \n-        fn eat(&mut self) -> bool {\n+        pub fn eat(&mut self) -> bool {\n             if self.how_hungry > 0 {\n                 error!(\"OM NOM NOM\");\n                 self.how_hungry -= 2;"}, {"sha": "4752c5a3bac56c67a5207bbbf90ed6cffc9c30fb", "filename": "src/test/auxiliary/impl_privacy_xc_1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -4,6 +4,6 @@ pub struct Fish {\n     x: int\n }\n \n-pub impl Fish {\n-    fn swim(&self) {}\n+impl Fish {\n+    pub fn swim(&self) {}\n }"}, {"sha": "1475b1a75a6652b3874c570fad115316a4ce7a33", "filename": "src/test/auxiliary/issue_2472_b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -11,8 +11,8 @@\n \n pub struct S(());\n \n-pub impl S {\n-    fn foo(&self) { }\n+impl S {\n+    pub fn foo(&self) { }\n }\n \n pub trait T {"}, {"sha": "a0b742515494c11a13b738d8c95caf9d757aa4f4", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -35,8 +35,8 @@ fn timed(result: &mut float, op: &fn()) {\n     *result = (end - start);\n }\n \n-pub impl Results {\n-    fn bench_int<T:Set<uint>,\n+impl Results {\n+    pub fn bench_int<T:Set<uint>,\n                  R: rand::Rng>(\n                  &mut self,\n                  rng: &mut R,\n@@ -79,7 +79,7 @@ pub impl Results {\n         }\n     }\n \n-    fn bench_str<T:Set<~str>,\n+    pub fn bench_str<T:Set<~str>,\n                  R:rand::Rng>(\n                  &mut self,\n                  rng: &mut R,"}, {"sha": "25bdf7dc3feffd935bbca3ba335eb67afb98bb25", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -35,8 +35,8 @@ struct Noise2DContext {\n     permutations: [int, ..256],\n }\n \n-pub impl Noise2DContext {\n-    fn new() -> Noise2DContext {\n+impl Noise2DContext {\n+    pub fn new() -> Noise2DContext {\n         let mut r = rand::rng();\n         let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n         for int::range(0, 256) |i| {\n@@ -55,17 +55,17 @@ pub impl Noise2DContext {\n     }\n \n     #[inline(always)]\n-    fn get_gradient(&self, x: int, y: int) -> Vec2 {\n+    pub fn get_gradient(&self, x: int, y: int) -> Vec2 {\n         let idx = self.permutations[x & 255] + self.permutations[y & 255];\n         self.rgradients[idx & 255]\n     }\n \n     #[inline]\n-    fn get_gradients(&self,\n-                     gradients: &mut [Vec2, ..4],\n-                     origins: &mut [Vec2, ..4],\n-                     x: f32,\n-                     y: f32) {\n+    pub fn get_gradients(&self,\n+                         gradients: &mut [Vec2, ..4],\n+                         origins: &mut [Vec2, ..4],\n+                         x: f32,\n+                         y: f32) {\n         let x0f = f32::floor(x);\n         let y0f = f32::floor(y);\n         let x0 = x0f as int;\n@@ -85,7 +85,7 @@ pub impl Noise2DContext {\n     }\n \n     #[inline]\n-    fn get(&self, x: f32, y: f32) -> f32 {\n+    pub fn get(&self, x: f32, y: f32) -> f32 {\n         let p = Vec2 {x: x, y: y};\n         let mut gradients = [ Vec2 { x: 0.0, y: 0.0 }, ..4 ];\n         let mut origins = [ Vec2 { x: 0.0, y: 0.0 }, ..4 ];"}, {"sha": "3bf08cfb934f8c26cdee5a8ec33762b7ee452059", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -44,7 +44,7 @@ struct Sudoku {\n     grid: grid\n }\n \n-pub impl Sudoku {\n+impl Sudoku {\n     pub fn new(g: grid) -> Sudoku {\n         return Sudoku { grid: g }\n     }"}, {"sha": "85bb60e05853ee27e318dc48a3cc047dbf45846e", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,9 +14,8 @@ struct cat {\n   how_hungry : int,\n }\n \n-pub impl cat {\n-\n-  fn speak(&self) { self.meows += 1u; }\n+impl cat {\n+    pub fn speak(&self) { self.meows += 1u; }\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "e2fbce6e195f579783b00938340fbbaebad8fc8a", "filename": "src/test/compile-fail/borrowck-auto-mut-ref-to-immut-var.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,8 +16,8 @@ struct Foo {\n     x: int\n }\n \n-pub impl Foo {\n-    fn printme(&mut self) {\n+impl Foo {\n+    pub fn printme(&mut self) {\n         io::println(fmt!(\"%d\", self.x));\n     }\n }"}, {"sha": "4bbd1b0decf57c8b3f222bf80669e30564b0f0b4", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,11 +10,12 @@\n \n struct X(Either<(uint,uint),extern fn()>);\n \n-pub impl X {\n-    fn with(&self, blk: &fn(x: &Either<(uint,uint),extern fn()>)) {\n+impl X {\n+    pub fn with(&self, blk: &fn(x: &Either<(uint,uint),extern fn()>)) {\n         blk(&**self)\n     }\n }\n+\n fn main() {\n     let mut x = X(Right(main));\n     do (&mut x).with |opt| {"}, {"sha": "0aa7cbf50b7a327e8a2ec1df94d33123811cadda", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,10 +12,10 @@ struct Foo {\n     x: int,\n }\n \n-pub impl Foo {\n-    fn f(&self) {}\n-    fn g(&const self) {}\n-    fn h(&mut self) {}\n+impl Foo {\n+    pub fn f(&self) {}\n+    pub fn g(&const self) {}\n+    pub fn h(&mut self) {}\n }\n \n fn a(x: &mut Foo) {"}, {"sha": "1a0bec7d723b3fba41d86910bd8737ea823a26a8", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,12 +14,12 @@ struct Foo {\n   n: HashSet<int>,\n }\n \n-pub impl Foo {\n-  fn foo(&mut self, fun: &fn(&int)) {\n-    for self.n.each |f| {\n-      fun(f);\n+impl Foo {\n+    pub fn foo(&mut self, fun: &fn(&int)) {\n+        for self.n.each |f| {\n+            fun(f);\n+        }\n     }\n-  }\n }\n \n fn bar(f: &mut Foo) {"}, {"sha": "b205c5be2179c16050aec75e2946a02bfb24ee3e", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -19,8 +19,8 @@ impl Add<int,int> for Point {\n     }\n }\n \n-pub impl Point {\n-    fn times(&self, z: int) -> int {\n+impl Point {\n+    pub fn times(&self, z: int) -> int {\n         self.x * self.y * z\n     }\n }"}, {"sha": "7f7c58a60df0500eb8da81ba8155767cc5521ddd", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -19,9 +19,8 @@ struct cat {\n   name : ~str,\n }\n \n-pub impl cat {\n-\n-  fn eat(&self) -> bool {\n+impl cat {\n+  pub fn eat(&self) -> bool {\n     if self.how_hungry > 0 {\n         error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n@@ -39,7 +38,7 @@ impl noisy for cat {\n \n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&self) {\n       error!(\"Meow\");\n       self.meows += 1;"}, {"sha": "c27c27b5942e1b3276e86c410a94a21883c57b8b", "filename": "src/test/compile-fail/class-missing-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,7 +12,7 @@ struct cat {\n   priv meows : uint,\n }\n \n-priv impl cat {\n+impl cat {\n     fn sleep(&self) { loop{} }\n     fn meow(&self) {\n       error!(\"Meow\");"}, {"sha": "cb559b91889bb848221d34be55e480b359a2367e", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,6 +14,6 @@ struct cat {\n   tail: int,\n }\n \n-pub impl cat {\n-  fn meow() { tail += 1; } //~ ERROR: Did you mean: `self.tail`\n+impl cat {\n+  pub fn meow() { tail += 1; } //~ ERROR: Did you mean: `self.tail`\n }"}, {"sha": "91ae0e1c07a555e9d6f47556e174ad66e145b339", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,7 +14,7 @@ pub mod stream {\n         use std::option;\n         use std::pipes;\n \n-        pub impl<T:Owned> Stream<T> {\n+        impl<T:Owned> Stream<T> {\n             pub fn recv() -> extern fn(v: Stream<T>) -> ::stream::Stream<T> {\n               // resolve really should report just one error here.\n               // Change the test case when it changes."}, {"sha": "d3aec178c238ad6d28d8766b5ab67ff69a20dc26", "filename": "src/test/compile-fail/issue-3021-b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,8 +16,8 @@ fn siphash(k0 : u64) {\n         v0: u64,\n     }\n \n-    pub impl siphash {\n-        fn reset(&mut self) {\n+    impl siphash {\n+        pub fn reset(&mut self) {\n            self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR attempted dynamic environment-capture\n            //~^ ERROR unresolved name `k0`.\n         }"}, {"sha": "02ccf14138a355d6620d39edb540296babad7052", "filename": "src/test/compile-fail/issue-3080.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3080.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,8 +10,8 @@\n \n // xfail-test\n struct x(());\n-pub impl x {\n-    unsafe fn with() { } // This should fail\n+impl x {\n+    pub unsafe fn with() { } // This should fail\n }\n \n fn main() {"}, {"sha": "4e128b63e925722862c07458e355358b1ae778d2", "filename": "src/test/compile-fail/issue-3707.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,11 +12,11 @@ struct Obj {\n     member: uint\n }\n \n-pub impl Obj {\n-    fn boom() -> bool {\n+impl Obj {\n+    pub fn boom() -> bool {\n         return 1+1 == 2\n     }\n-    fn chirp(&self) {\n+    pub fn chirp(&self) {\n         self.boom(); //~ ERROR `&Obj` does not implement any method in scope named `boom`\n     }\n }"}, {"sha": "9647d412d2cdb8e70857cac782090e729c10959f", "filename": "src/test/compile-fail/issue-3763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -15,7 +15,7 @@ mod my_mod {\n     pub fn MyStruct () -> MyStruct {\n         MyStruct {priv_field: 4}\n     }\n-    pub impl MyStruct {\n+    impl MyStruct {\n         priv fn happyfun(&self) {}\n     }\n }"}, {"sha": "30c2b9eef8ca00e24dc2fb8a6086db05225d66a9", "filename": "src/test/compile-fail/mutable-class-fields-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields-2.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,8 +14,8 @@ struct cat {\n   how_hungry : int,\n }\n \n-pub impl cat {\n-  fn eat(&self) {\n+impl cat {\n+  pub fn eat(&self) {\n     self.how_hungry -= 5; //~ ERROR cannot assign\n   }\n "}, {"sha": "26b7d73ab2af2db19099f5665e157359a257a4dc", "filename": "src/test/compile-fail/private-impl-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,7 +13,7 @@ mod a {\n         x: int\n     }\n \n-    pub impl Foo {\n+    impl Foo {\n         priv fn foo(&self) {}\n     }\n }"}, {"sha": "0c67980a5515c3de893e6cf4be0cd89853756e13", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -19,7 +19,7 @@ mod kitties {\n         how_hungry : int,\n     }\n \n-    pub impl cat {\n+    impl cat {\n         priv fn nap(&self) { uint::range(1u, 10000u, |_i| false); }\n     }\n "}, {"sha": "0516264d45797dc2cbaf957ec12dd6ed5148c5c7", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,13 +12,13 @@ struct dog {\n     cats_chased: uint,\n }\n \n-pub impl dog {\n-    fn chase_cat(&mut self) {\n+impl dog {\n+    pub fn chase_cat(&mut self) {\n         let p: &'static mut uint = &mut self.cats_chased; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n         *p += 1u;\n     }\n \n-    fn chase_cat_2(&mut self) {\n+    pub fn chase_cat_2(&mut self) {\n         let p: &'blk mut uint = &mut self.cats_chased;\n         *p += 1u;\n     }"}, {"sha": "f1172690f4dfa85331a6371702f7a0738836eafe", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,8 +14,8 @@ struct dog {\n     food: uint,\n }\n \n-pub impl dog {\n-    fn chase_cat(&mut self) {\n+impl dog {\n+    pub fn chase_cat(&mut self) {\n         for uint::range(0u, 10u) |_i| {\n             let p: &'static mut uint = &mut self.food; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n             *p = 3u;"}, {"sha": "d438b55f4af790ce9fbad129ce87e52b7374807a", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -22,8 +22,8 @@ mod argparse {\n         Flag { name: name, desc: desc, max_count: 1, value: 0 }\n     }\n \n-    pub impl<'self> Flag<'self> {\n-        fn set_desc(self, s: &str) -> Flag<'self> {\n+    impl<'self> Flag<'self> {\n+        pub fn set_desc(self, s: &str) -> Flag<'self> {\n             Flag { //~ ERROR cannot infer an appropriate lifetime\n                 name: self.name,\n                 desc: s,"}, {"sha": "f687a6f97024a8840870e99487163a97ac933409", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // error-pattern: implement a trait or new type instead\n-pub impl <T> Option<T> {\n-    fn foo(&self) { }\n+impl<T> Option<T> {\n+    pub fn foo(&self) { }\n }\n \n fn main() { }"}, {"sha": "5b4d67fb0cef27e5c904144a36723ed25dad22d8", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -6,13 +6,13 @@ impl Drop for S {\n     fn finalize(&self) {}\n }\n \n-pub impl S {\n-    fn foo(self) -> int {\n+impl S {\n+    pub fn foo(self) -> int {\n         self.bar();\n         return self.x;  //~ ERROR use of moved value: `self`\n     }\n \n-    fn bar(self) {}\n+    pub fn bar(self) {}\n }\n \n fn main() {"}, {"sha": "c38f4821b881e4b04c745decee451f2bba38c0f0", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -2,13 +2,13 @@ struct S {\n     x: ~int\n }\n \n-pub impl S {\n-    fn foo(self) -> int {\n+impl S {\n+    pub fn foo(self) -> int {\n         self.bar();\n         return *self.x;  //~ ERROR use of moved value: `self`\n     }\n \n-    fn bar(self) {}\n+    pub fn bar(self) {}\n }\n \n fn main() {"}, {"sha": "843e9436229ec67473ec8c4ece823c117da41325", "filename": "src/test/run-pass/anon-trait-static-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,8 +12,8 @@ struct Foo {\n     x: int\n }\n \n-pub impl Foo {\n-    fn new() -> Foo {\n+impl Foo {\n+    pub fn new() -> Foo {\n         Foo { x: 3 }\n     }\n }"}, {"sha": "8adc2cfd571906595a3322ca25cce7d602566eaf", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,8 +13,8 @@\n \n struct Foo(uint);\n \n-pub impl Foo {\n-    fn len(&self) -> uint { **self }\n+impl Foo {\n+    pub fn len(&self) -> uint { **self }\n }\n \n pub fn main() {"}, {"sha": "b00d8980c69fefbb56eb2be088a7793dbcda5671", "filename": "src/test/run-pass/autoderef-and-borrow-method-receiver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,8 +12,8 @@ struct Foo {\n     x: int,\n }\n \n-pub impl Foo {\n-    fn f(&const self) {}\n+impl Foo {\n+    pub fn f(&const self) {}\n }\n \n fn g(x: &mut Foo) {"}, {"sha": "50e9b6d81b5175626c4f5b68c26459ca9b0671fd", "filename": "src/test/run-pass/borrowck-nested-calls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,10 +14,10 @@\n \n struct Foo {a: uint, b: uint}\n \n-pub impl Foo {\n-    fn inc_a(&mut self, v: uint) { self.a += v; }\n+impl Foo {\n+    pub fn inc_a(&mut self, v: uint) { self.a += v; }\n \n-    fn next_b(&mut self) -> uint {\n+    pub fn next_b(&mut self) -> uint {\n         let b = self.b;\n         self.b += 1;\n         b"}, {"sha": "284db7af66be3b65bf5e42b7dcb0a8de8b6f7c00", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -2,8 +2,8 @@ struct Wizard {\n     spells: ~[&'static str]\n }\n \n-pub impl Wizard {\n-    fn cast(&mut self) {\n+impl Wizard {\n+    pub fn cast(&mut self) {\n         for self.spells.each |&spell| {\n             println(spell);\n         }"}, {"sha": "361cafc40a962426e6eb69b372b9653a89a18b59", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -20,7 +20,7 @@ struct dog {\n   volume : @mut int,\n }\n \n-pub impl dog {\n+impl dog {\n     priv fn bark(&self) -> int {\n       debug!(\"Woof %u %d\", *self.barks, *self.volume);\n       *self.barks += 1u;\n@@ -57,11 +57,11 @@ impl noisy for cat {\n   fn speak(&self) -> int { self.meow() as int }\n }\n \n-pub impl cat {\n-  fn meow_count(&self) -> uint { *self.meows }\n+impl cat {\n+  pub fn meow_count(&self) -> uint { *self.meows }\n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&self) -> uint {\n       debug!(\"Meow\");\n       *self.meows += 1u;"}, {"sha": "a8ff9061216871f5e85e82e9c4a265c00ab96ce3", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -22,8 +22,8 @@ impl noisy for cat {\n   fn speak(&mut self) { self.meow(); }\n }\n \n-pub impl cat {\n-  fn eat(&mut self) -> bool {\n+impl cat {\n+  pub fn eat(&mut self) -> bool {\n     if self.how_hungry > 0 {\n         error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n@@ -36,7 +36,7 @@ pub impl cat {\n   }\n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&mut self) {\n       error!(\"Meow\");\n       self.meows += 1u;"}, {"sha": "11ef86035c56f444947d708e21414cb54ca085a2", "filename": "src/test/run-pass/class-exports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-exports.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -21,8 +21,8 @@ mod kitty {\n         name: ~str,\n     }\n \n-    pub impl cat {\n-        fn get_name(&self) -> ~str { self.name.clone() }\n+    impl cat {\n+        pub fn get_name(&self) -> ~str { self.name.clone() }\n     }\n \n     pub fn cat(in_name: ~str) -> cat {"}, {"sha": "88686bcdbfa359b8a33ec0f811f27121e641b8b5", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -37,10 +37,10 @@ struct cat<T> {\n     name : T,\n }\n \n-pub impl<T> cat<T> {\n-    fn speak(&mut self) { self.meow(); }\n+impl<T> cat<T> {\n+    pub fn speak(&mut self) { self.meow(); }\n \n-    fn eat(&mut self) -> bool {\n+    pub fn eat(&mut self) -> bool {\n         if self.how_hungry > 0 {\n             error!(\"OM NOM NOM\");\n             self.how_hungry -= 2;\n@@ -113,20 +113,20 @@ impl<T> Map<int, T> for cat<T> {\n     fn swap(&mut self, _k: int, _v: T) -> Option<T> { fail!() }\n }\n \n-pub impl<T> cat<T> {\n-    fn get<'a>(&'a self, k: &int) -> &'a T {\n+impl<T> cat<T> {\n+    pub fn get<'a>(&'a self, k: &int) -> &'a T {\n         match self.find(k) {\n           Some(v) => { v }\n           None    => { fail!(\"epic fail\"); }\n         }\n     }\n \n-    fn new(in_x: int, in_y: int, in_name: T) -> cat<T> {\n+    pub fn new(in_x: int, in_y: int, in_name: T) -> cat<T> {\n         cat{meows: in_x, how_hungry: in_y, name: in_name }\n     }\n }\n \n-priv impl<T> cat<T> {\n+impl<T> cat<T> {\n     fn meow(&mut self) {\n         self.meows += 1;\n         error!(\"Meow %d\", self.meows);"}, {"sha": "70020b395103da1ecdfa87f7c56d158262417d83", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -22,8 +22,8 @@ struct cat {\n   name : ~str,\n }\n \n-pub impl cat {\n-    fn eat(&mut self) -> bool {\n+impl cat {\n+    pub fn eat(&mut self) -> bool {\n         if self.how_hungry > 0 {\n             error!(\"OM NOM NOM\");\n             self.how_hungry -= 2;\n@@ -40,7 +40,7 @@ impl noisy for cat {\n     fn speak(&mut self) { self.meow(); }\n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&mut self) {\n         error!(\"Meow\");\n         self.meows += 1u;"}, {"sha": "8c7c62ce27e3ffbb5451353fbee944bb652b9990", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -23,7 +23,7 @@ struct cat {\n     name : ~str,\n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&mut self) {\n         error!(\"Meow\");\n         self.meows += 1u;\n@@ -33,8 +33,8 @@ priv impl cat {\n     }\n }\n \n-pub impl cat {\n-    fn eat(&mut self) -> bool {\n+impl cat {\n+    pub fn eat(&mut self) -> bool {\n         if self.how_hungry > 0 {\n             error!(\"OM NOM NOM\");\n             self.how_hungry -= 2;"}, {"sha": "fca128b9a97350e86cd18c0f92596fdd98055a6b", "filename": "src/test/run-pass/class-methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,9 +14,9 @@ struct cat {\n   how_hungry : int,\n }\n \n-pub impl cat {\n-    fn speak(&mut self) { self.meows += 1u; }\n-    fn meow_count(&mut self) -> uint { self.meows }\n+impl cat {\n+    pub fn speak(&mut self) { self.meows += 1u; }\n+    pub fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat(in_x: uint, in_y: int) -> cat {"}, {"sha": "0201501bc7c64848ec7418a8cb214d88034d6c66", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -15,11 +15,11 @@ struct cat<U> {\n     how_hungry : int,\n }\n \n-pub impl<U> cat<U> {\n-    fn speak<T>(&mut self, stuff: ~[T]) {\n+impl<U> cat<U> {\n+    pub fn speak<T>(&mut self, stuff: ~[T]) {\n         self.meows += stuff.len();\n     }\n-    fn meow_count(&mut self) -> uint { self.meows }\n+    pub fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat<U>(in_x : uint, in_y : int, in_info: ~[U]) -> cat<U> {"}, {"sha": "f31b702519349f306779b9c2fd3809928dfe744f", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,10 +16,10 @@ struct cat {\n     name : ~str,\n }\n \n-pub impl cat {\n-    fn speak(&mut self) { self.meow(); }\n+impl cat {\n+    pub fn speak(&mut self) { self.meow(); }\n \n-    fn eat(&mut self) -> bool {\n+    pub fn eat(&mut self) -> bool {\n         if self.how_hungry > 0 {\n             error!(\"OM NOM NOM\");\n             self.how_hungry -= 2;\n@@ -32,7 +32,7 @@ pub impl cat {\n     }\n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&mut self) {\n         error!(\"Meow\");\n         self.meows += 1u;"}, {"sha": "8533add411949adc5cc9d6ce9674cf52023a7419", "filename": "src/test/run-pass/class-typarams.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-typarams.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,9 +14,9 @@ struct cat<U> {\n     how_hungry : int,\n }\n \n-pub impl<U> cat<U> {\n-    fn speak(&mut self) { self.meows += 1u; }\n-    fn meow_count(&mut self) -> uint { self.meows }\n+impl<U> cat<U> {\n+    pub fn speak(&mut self) { self.meows += 1u; }\n+    pub fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat<U>(in_x : uint, in_y : int) -> cat<U> {"}, {"sha": "f27738cf4216ee17eba5cd0a9a4ced7fd97230a2", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,8 +14,8 @@ struct cat {\n     how_hungry : int,\n }\n \n-pub impl cat {\n-  fn speak(&mut self) {}\n+impl cat {\n+    pub fn speak(&mut self) {}\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "89d89d116a38d992c05e19f7c7288a60f05a9ad8", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -17,10 +17,10 @@ struct cat {\n     name : ~str,\n }\n \n-pub impl cat {\n-    fn speak(&mut self) { self.meow(); }\n+impl cat {\n+    pub fn speak(&mut self) { self.meow(); }\n \n-    fn eat(&mut self) -> bool {\n+    pub fn eat(&mut self) -> bool {\n         if self.how_hungry > 0 {\n             error!(\"OM NOM NOM\");\n             self.how_hungry -= 2;\n@@ -32,7 +32,7 @@ pub impl cat {\n     }\n }\n \n-priv impl cat {\n+impl cat {\n     fn meow(&mut self) {\n         error!(\"Meow\");\n         self.meows += 1u;"}, {"sha": "438c70c6583f4956486cbef66133147e33d86e72", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -2,8 +2,8 @@ struct SpeechMaker {\n     speeches: uint\n }\n \n-pub impl SpeechMaker {\n-    fn how_many(&const self) -> uint { self.speeches }\n+impl SpeechMaker {\n+    pub fn how_many(&const self) -> uint { self.speeches }\n }\n \n fn foo(speaker: &const SpeechMaker) -> uint {"}, {"sha": "3adb805581dd0d119f879d04a6f355e5938a7262", "filename": "src/test/run-pass/coerce-reborrow-mut-ptr-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-rcvr.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -2,8 +2,8 @@ struct SpeechMaker {\n     speeches: uint\n }\n \n-pub impl SpeechMaker {\n-    fn talk(&mut self) {\n+impl SpeechMaker {\n+    pub fn talk(&mut self) {\n         self.speeches += 1;\n     }\n }"}, {"sha": "098a001cfcde977eee7cb9f748c95f1f1c0789ac", "filename": "src/test/run-pass/const-enum-byref-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fconst-enum-byref-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fconst-enum-byref-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-byref-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -11,8 +11,8 @@\n enum E { V, VV(int) }\n static C: E = V;\n \n-pub impl E {\n-    fn method(&self) {\n+impl E {\n+    pub fn method(&self) {\n         match *self {\n             V => {}\n             VV(*) => fail!()"}, {"sha": "eb62c8a91d2423a125f1a995114cb682fcc9b618", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,11 +14,11 @@ struct Box {\n     x: uint\n }\n \n-pub impl Box {\n-    fn set_many(&mut self, xs: &[uint]) {\n+impl Box {\n+    pub fn set_many(&mut self, xs: &[uint]) {\n         for xs.each |x| { self.x = *x; }\n     }\n-    fn set_many2(@mut self, xs: &[uint]) {\n+    pub fn set_many2(@mut self, xs: &[uint]) {\n         for xs.each |x| { self.x = *x; }\n     }\n }"}, {"sha": "80e16af922847da1ce8cbf4a563d72ecffaec341", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -30,8 +30,8 @@ fn linear_map<K,V>() -> HashMap<K,V> {\n         size: 0})\n }\n \n-pub impl<K,V> HashMap<K,V> {\n-    fn len(&mut self) -> uint {\n+impl<K,V> HashMap<K,V> {\n+    pub fn len(&mut self) -> uint {\n         self.size\n     }\n }"}, {"sha": "25e404021619e796fd0404ae9c5a68fcdbaa0d14", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -26,10 +26,10 @@ fn compute_area(shape: &shape) -> float {\n     }\n }\n \n-pub impl shape {\n+impl shape {\n     // self is in the implicit self region\n-    fn select<'r, T>(&self, threshold: float,\n-                     a: &'r T, b: &'r T) -> &'r T {\n+    pub fn select<'r, T>(&self, threshold: float, a: &'r T, b: &'r T)\n+                         -> &'r T {\n         if compute_area(self) > threshold {a} else {b}\n     }\n }\n@@ -54,12 +54,12 @@ fn thing(x: A) -> thing {\n     }\n }\n \n-pub impl thing {\n-    fn foo(@self) -> int { *self.x.a }\n-    fn bar(~self) -> int { *self.x.a }\n-    fn quux(&self) -> int { *self.x.a }\n-    fn baz<'a>(&'a self) -> &'a A { &self.x }\n-    fn spam(self) -> int { *self.x.a }\n+impl thing {\n+    pub fn foo(@self) -> int { *self.x.a }\n+    pub fn bar(~self) -> int { *self.x.a }\n+    pub fn quux(&self) -> int { *self.x.a }\n+    pub fn baz<'a>(&'a self) -> &'a A { &self.x }\n+    pub fn spam(self) -> int { *self.x.a }\n }\n \n trait Nus { fn f(&self); }"}, {"sha": "a33fc4f2e7402204de52172e1d39ea64071676ef", "filename": "src/test/run-pass/impl-implicit-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fimpl-implicit-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fimpl-implicit-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-implicit-trait.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,17 +13,17 @@ enum option_<T> {\n     some_(T),\n }\n \n-pub impl<T> option_<T> {\n-    fn foo(&self) -> bool { true }\n+impl<T> option_<T> {\n+    pub fn foo(&self) -> bool { true }\n }\n \n enum option__ {\n     none__,\n     some__(int)\n }\n \n-pub impl option__ {\n-    fn foo(&self) -> bool { true }\n+impl option__ {\n+    pub fn foo(&self) -> bool { true }\n }\n \n pub fn main() {"}, {"sha": "155f9cff29629fa4cbe19a005d3e150fc5d2c05e", "filename": "src/test/run-pass/issue-2311-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,8 +13,8 @@ struct foo<A> {\n     x: A,\n }\n \n-pub impl<A:Copy> foo<A> {\n-   fn bar<B,C:clam<A>>(&self, c: C) -> B {\n+impl<A:Copy> foo<A> {\n+   pub fn bar<B,C:clam<A>>(&self, c: C) -> B {\n      fail!();\n    }\n }"}, {"sha": "59ca02f50fc3a57c454898504035b9781665de7c", "filename": "src/test/run-pass/issue-2312.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2312.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,8 +14,8 @@ trait clam<A> { }\n \n struct foo(int);\n \n-pub impl foo {\n-    fn bar<B,C:clam<B>>(&self, c: C) -> B { fail!(); }\n+impl foo {\n+    pub fn bar<B,C:clam<B>>(&self, c: C) -> B { fail!(); }\n }\n \n pub fn main() { }"}, {"sha": "c26038afd764f4af14a60e50b22162317b3eb4c1", "filename": "src/test/run-pass/issue-2445-b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,8 +12,8 @@ struct c1<T> {\n     x: T,\n }\n \n-pub impl<T:Copy> c1<T> {\n-    fn f1(&self, x: int) {\n+impl<T:Copy> c1<T> {\n+    pub fn f1(&self, x: int) {\n     }\n }\n \n@@ -23,8 +23,8 @@ fn c1<T:Copy>(x: T) -> c1<T> {\n     }\n }\n \n-pub impl<T:Copy> c1<T> {\n-    fn f2(&self, x: int) {\n+impl<T:Copy> c1<T> {\n+    pub fn f2(&self, x: int) {\n     }\n }\n "}, {"sha": "64d60725978763848ef5b253230e6113dba4856d", "filename": "src/test/run-pass/issue-2445.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2445.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,8 +12,8 @@ struct c1<T> {\n     x: T,\n }\n \n-pub impl<T:Copy> c1<T> {\n-    fn f1(&self, x: T) {}\n+impl<T:Copy> c1<T> {\n+    pub fn f1(&self, x: T) {}\n }\n \n fn c1<T:Copy>(x: T) -> c1<T> {\n@@ -22,8 +22,8 @@ fn c1<T:Copy>(x: T) -> c1<T> {\n     }\n }\n \n-pub impl<T:Copy> c1<T> {\n-    fn f2(&self, x: T) {}\n+impl<T:Copy> c1<T> {\n+    pub fn f2(&self, x: T) {}\n }\n \n "}, {"sha": "5e5fb70bcd4a5b200c6c6cf2571a700cff888a8d", "filename": "src/test/run-pass/issue-2487-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -17,8 +17,8 @@ impl Drop for socket {\n     fn finalize(&self) {}\n }\n \n-pub impl socket {\n-    fn set_identity(&self)  {\n+impl socket {\n+    pub fn set_identity(&self)  {\n         do closure {\n             setsockopt_bytes(self.sock.clone())\n         }"}, {"sha": "c26fef49be73574b9725c143ab0a021d2957a702", "filename": "src/test/run-pass/issue-2502.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -12,8 +12,8 @@ struct font<'self> {\n     fontbuf: &'self ~[u8],\n }\n \n-pub impl<'self> font<'self> {\n-    fn buf(&self) -> &'self ~[u8] {\n+impl<'self> font<'self> {\n+    pub fn buf(&self) -> &'self ~[u8] {\n         self.fontbuf\n     }\n }"}, {"sha": "d51470cf9bd916ed65c067fceafa83bb675e4b28", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -172,8 +172,8 @@ pub mod pipes {\n         }\n     }\n \n-    pub impl<T:Owned> send_packet<T> {\n-        fn unwrap(&mut self) -> *packet<T> {\n+    impl<T:Owned> send_packet<T> {\n+        pub fn unwrap(&mut self) -> *packet<T> {\n             util::replace(&mut self.p, None).unwrap()\n         }\n     }\n@@ -202,8 +202,8 @@ pub mod pipes {\n         }\n     }\n \n-    pub impl<T:Owned> recv_packet<T> {\n-        fn unwrap(&mut self) -> *packet<T> {\n+    impl<T:Owned> recv_packet<T> {\n+        pub fn unwrap(&mut self) -> *packet<T> {\n             util::replace(&mut self.p, None).unwrap()\n         }\n     }"}, {"sha": "9cc5e5910435fd9f89f5fedbc673f93aec8d69d9", "filename": "src/test/run-pass/issue-3220.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3220.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3220.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3220.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -19,7 +19,10 @@ fn thing() -> thing {\n         x: 0\n     }\n }\n-pub impl thing { fn f(self) {} }\n+\n+impl thing {\n+    pub fn f(self) {}\n+}\n \n pub fn main() {\n     let z = thing();"}, {"sha": "711dfd3778b5b8b6cf46ecf7700e15d3caf35a6e", "filename": "src/test/run-pass/issue-3447.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3447.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,8 +13,8 @@ struct list<'self, T> {\n     next: Option<@mut list<'self, T>>\n }\n \n-pub impl<'self, T> list<'self, T>{\n-    fn addEnd(&mut self, element: &'self T) {\n+impl<'self, T> list<'self, T>{\n+    pub fn addEnd(&mut self, element: &'self T) {\n         let newList = list {\n             element: element,\n             next: None"}, {"sha": "a94abe04fded2b7e829788686b62b0f9bacbcd1a", "filename": "src/test/run-pass/issue-3753.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3753.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -24,7 +24,7 @@ pub enum Shape {\n     Rectangle(Point, Point)\n }\n \n-pub impl Shape {\n+impl Shape {\n     pub fn area(&self, sh: Shape) -> float {\n         match sh {\n             Circle(_, size) => float::consts::pi * size * size,"}, {"sha": "0a22e8bcfd07eac07ebd7edf8290a208936ba367", "filename": "src/test/run-pass/issue-3860.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3860.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -10,8 +10,8 @@\n \n struct Foo { x: int }\n \n-pub impl Foo {\n-    fn stuff<'a>(&'a mut self) -> &'a mut Foo {\n+impl Foo {\n+    pub fn stuff<'a>(&'a mut self) -> &'a mut Foo {\n         return self;\n     }\n }"}, {"sha": "6b0796a1260d5a5528a5d2b1d9c2d7b265de0a62", "filename": "src/test/run-pass/issue-3904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fissue-3904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3904.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -23,8 +23,8 @@ struct X {\n     err: ErrPrinter\n }\n \n-pub impl X {\n-    fn boom() {\n+impl X {\n+    pub fn boom() {\n         exit(self.err, \"prog\", \"arg\");\n     }\n }"}, {"sha": "c34067c329d27a537c2e17bbcda1533c1a4d7f48", "filename": "src/test/run-pass/max-min-classes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fmax-min-classes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fmax-min-classes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmax-min-classes.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -17,8 +17,8 @@ struct Foo {\n     y: int,\n }\n \n-pub impl Foo {\n-    fn sum(&self) -> int {\n+impl Foo {\n+    pub fn sum(&self) -> int {\n         self.x + self.y\n     }\n }"}, {"sha": "55a7edbb679c6df17dc0b044e340ad72888747a4", "filename": "src/test/run-pass/move-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fmove-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fmove-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -2,12 +2,12 @@ struct S {\n     x: ~str\n }\n \n-pub impl S {\n-    fn foo(self) {\n+impl S {\n+    pub fn foo(self) {\n         self.bar();\n     }\n \n-    fn bar(self) {\n+    pub fn bar(self) {\n         println(self.x);\n     }\n }"}, {"sha": "6ab9856c0700aefd9abcfafaaa1e461d1f478531", "filename": "src/test/run-pass/nested-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fnested-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fnested-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-class.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -13,8 +13,8 @@ pub fn main() {\n         i: int,\n     }\n \n-    pub impl b {\n-        fn do_stuff(&self) -> int { return 37; }\n+    impl b {\n+        pub fn do_stuff(&self) -> int { return 37; }\n     }\n \n     fn b(i:int) -> b {"}, {"sha": "868cbbfa8021284dd061e6a9f30ad5468312d05c", "filename": "src/test/run-pass/private-class-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,8 +14,8 @@ struct cat {\n     how_hungry : int,\n }\n \n-pub impl cat {\n-  fn meow_count(&mut self) -> uint { self.meows }\n+impl cat {\n+  pub fn meow_count(&mut self) -> uint { self.meows }\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "de07cc7c4d0183de728fdc7e5cf2de6b427a8f1f", "filename": "src/test/run-pass/private-method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -16,14 +16,14 @@ struct cat {\n     how_hungry : int,\n }\n \n-pub impl cat {\n-    fn play(&mut self) {\n+impl cat {\n+    pub fn play(&mut self) {\n         self.meows += 1u;\n         self.nap();\n     }\n }\n \n-priv impl cat {\n+impl cat {\n     fn nap(&mut self) { for uint::range(1u, 10u) |_i| { }}\n }\n "}, {"sha": "2927279f6a29e40b6fc5d9a9b603ea0ab7689486", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -0,0 +1,14 @@\n+use std::cast::transmute;\n+\n+mod a {\n+    extern {\n+        pub fn free(x: *u8);\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        a::free(transmute(0));\n+    }\n+}\n+"}, {"sha": "f4ccd038afee85678f98b20d67640740b70eb275", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -33,29 +33,29 @@ fn align(size: uint, align: uint) -> uint {\n \n struct ptr_visit_adaptor<V>(Inner<V>);\n \n-pub impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n+impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n \n     #[inline(always)]\n-    fn bump(&self, sz: uint) {\n+    pub fn bump(&self, sz: uint) {\n       do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    fn align(&self, a: uint) {\n+    pub fn align(&self, a: uint) {\n       do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    fn align_to<T>(&self) {\n+    pub fn align_to<T>(&self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n     #[inline(always)]\n-    fn bump_past<T>(&self) {\n+    pub fn bump_past<T>(&self) {\n         self.bump(sys::size_of::<T>());\n     }\n \n@@ -485,14 +485,14 @@ struct Stuff {\n     vals: ~[~str]\n }\n \n-pub impl my_visitor {\n-    fn get<T>(&self, f: &fn(T)) {\n+impl my_visitor {\n+    pub fn get<T>(&self, f: &fn(T)) {\n         unsafe {\n             f(*(self.ptr1 as *T));\n         }\n     }\n \n-    fn visit_inner(&self, inner: *TyDesc) -> bool {\n+    pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = my_visitor(**self);\n             let v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});"}, {"sha": "58c13885e036cea44a8998eadb16de9ed69c21c2", "filename": "src/test/run-pass/regions-expl-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fregions-expl-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fregions-expl-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-expl-self.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -14,8 +14,8 @@ struct Foo {\n     f: uint\n }\n \n-pub impl Foo {\n-    fn foo<'a>(&'a self) {}\n+impl Foo {\n+    pub fn foo<'a>(&'a self) {}\n }\n \n-pub fn main() {}\n\\ No newline at end of file\n+pub fn main() {}"}, {"sha": "c240c6708a4ac2dd89a8e87fbfc6ea19f4bdb716", "filename": "src/test/run-pass/resource-destruct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44af5064d0ac3d45223f1555b299f10fd4902f5c/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct.rs?ref=44af5064d0ac3d45223f1555b299f10fd4902f5c", "patch": "@@ -21,8 +21,8 @@ impl Drop for shrinky_pointer {\n     }\n }\n \n-pub impl shrinky_pointer {\n-  fn look_at(&self) -> int { return **(self.i); }\n+impl shrinky_pointer {\n+    pub fn look_at(&self) -> int { return **(self.i); }\n }\n \n fn shrinky_pointer(i: @@mut int) -> shrinky_pointer {"}]}