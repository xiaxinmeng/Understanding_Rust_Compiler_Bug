{"sha": "01b3490a551bc46c3d2b99d1a811ee93201f32f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYjM0OTBhNTUxYmM0NmMzZDJiOTlkMWE4MTFlZTkzMjAxZjMyZjM=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-28T01:08:54Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-28T01:59:58Z"}, "message": "libstd: impl Integer for BigUint/BigInt.\n\nAlso remove abs() method from the non-trait impl for BigInt/BigUint.\nThat method is provided in the Signed trait.", "tree": {"sha": "56877c7688669b98a999641f1c61f91f52b66381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56877c7688669b98a999641f1c61f91f52b66381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01b3490a551bc46c3d2b99d1a811ee93201f32f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01b3490a551bc46c3d2b99d1a811ee93201f32f3", "html_url": "https://github.com/rust-lang/rust/commit/01b3490a551bc46c3d2b99d1a811ee93201f32f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01b3490a551bc46c3d2b99d1a811ee93201f32f3/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd5b1de1812f308ad68472d2ab06c15d3c342d75", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd5b1de1812f308ad68472d2ab06c15d3c342d75", "html_url": "https://github.com/rust-lang/rust/commit/dd5b1de1812f308ad68472d2ab06c15d3c342d75"}], "stats": {"total": 440, "additions": 297, "deletions": 143}, "files": [{"sha": "551e04e212219e30a18343337cdfdecf66d78462", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 297, "deletions": 143, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/01b3490a551bc46c3d2b99d1a811ee93201f32f3/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b3490a551bc46c3d2b99d1a811ee93201f32f3/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=01b3490a551bc46c3d2b99d1a811ee93201f32f3", "patch": "@@ -284,6 +284,141 @@ impl Neg<BigUint> for BigUint {\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n+impl Integer for BigUint {\n+    #[inline(always)]\n+    fn div(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.div_mod(other);\n+        return d;\n+    }\n+\n+    #[inline(always)]\n+    fn modulo(&self, other: &BigUint) -> BigUint {\n+        let (_, m) = self.div_mod(other);\n+        return m;\n+    }\n+\n+    #[inline(always)]\n+    fn div_mod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        if other.is_zero() { fail!() }\n+        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n+        if *other == One::one() { return (copy *self, Zero::zero()); }\n+\n+        match self.cmp(other) {\n+            Less    => return (Zero::zero(), copy *self),\n+            Equal   => return (One::one(), Zero::zero()),\n+            Greater => {} // Do nothing\n+        }\n+\n+        let mut shift = 0;\n+        let mut n = *other.data.last();\n+        while n < (1 << BigDigit::bits - 2) {\n+            n <<= 1;\n+            shift += 1;\n+        }\n+        assert!(shift < BigDigit::bits);\n+        let (d, m) = div_mod_inner(self << shift, other << shift);\n+        return (d, m >> shift);\n+\n+        #[inline(always)]\n+        fn div_mod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+            let mut m = a;\n+            let mut d = Zero::zero::<BigUint>();\n+            let mut n = 1;\n+            while m >= b {\n+                let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n+                let mut prod = b * d0;\n+                while prod > m {\n+                    d0   -= d_unit;\n+                    prod -= b_unit;\n+                }\n+                if d0.is_zero() {\n+                    n = 2;\n+                    loop;\n+                }\n+                n = 1;\n+                d += d0;\n+                m -= prod;\n+            }\n+            return (d, m);\n+        }\n+\n+        #[inline(always)]\n+        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n+            -> (BigUint, BigUint, BigUint) {\n+            if a.data.len() < n {\n+                return (Zero::zero(), Zero::zero(), copy *a);\n+            }\n+\n+            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n+            let bn = *b.data.last();\n+            let mut d = ~[];\n+            let mut carry = 0;\n+            for an.each_reverse |elt| {\n+                let ai = BigDigit::to_uint(carry, *elt);\n+                let di = ai / (bn as uint);\n+                assert!(di < BigDigit::base);\n+                carry = (ai % (bn as uint)) as BigDigit;\n+                d = ~[di as BigDigit] + d;\n+            }\n+\n+            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n+            if shift == 0 {\n+                return (BigUint::new(d), One::one(), copy *b);\n+            }\n+            return (BigUint::from_slice(d).shl_unit(shift),\n+                    One::one::<BigUint>().shl_unit(shift),\n+                    b.shl_unit(shift));\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        self.div_mod(other)\n+    }\n+\n+    /**\n+     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+     *\n+     * The result is always positive\n+     */\n+    #[inline(always)]\n+    fn gcd(&self, other: &BigUint) -> BigUint {\n+        // Use Euclid's algorithm\n+        let mut m = *self, n = *other;\n+        while !m.is_zero() {\n+            let temp = m;\n+            m = n % temp;\n+            n = temp;\n+        }\n+        return n;\n+    }\n+\n+    /**\n+     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+     */\n+    #[inline(always)]\n+    fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool {\n+        // Considering only the last digit.\n+        if self.data.is_empty() {\n+            true\n+        } else {\n+            self.data.last().is_even()\n+        }\n+    }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { !self.is_even() }\n+}\n+\n impl IntConvertible for BigUint {\n     fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n@@ -386,93 +521,7 @@ pub impl BigUint {\n         }\n     }\n \n-    fn abs(&self) -> BigUint { copy *self }\n-\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.div_mod(other);\n-        return d;\n-    }\n-    fn modulo(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.div_mod(other);\n-        return m;\n-    }\n-\n-    fn div_mod(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail!() }\n-        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n-        if *other == One::one() { return (copy *self, Zero::zero()); }\n-\n-        match self.cmp(other) {\n-            Less    => return (Zero::zero(), copy *self),\n-            Equal   => return (One::one(), Zero::zero()),\n-            Greater => {} // Do nothing\n-        }\n-\n-        let mut shift = 0;\n-        let mut n = *other.data.last();\n-        while n < (1 << BigDigit::bits - 2) {\n-            n <<= 1;\n-            shift += 1;\n-        }\n-        assert!(shift < BigDigit::bits);\n-        let (d, m) = div_mod_inner(self << shift, other << shift);\n-        return (d, m >> shift);\n-\n-        fn div_mod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n-            let mut m = a;\n-            let mut d = Zero::zero::<BigUint>();\n-            let mut n = 1;\n-            while m >= b {\n-                let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n-                let mut prod = b * d0;\n-                while prod > m {\n-                    d0   -= d_unit;\n-                    prod -= b_unit;\n-                }\n-                if d0.is_zero() {\n-                    n = 2;\n-                    loop;\n-                }\n-                n = 1;\n-                d += d0;\n-                m -= prod;\n-            }\n-            return (d, m);\n-        }\n-\n-        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n-            -> (BigUint, BigUint, BigUint) {\n-            if a.data.len() < n {\n-                return (Zero::zero(), Zero::zero(), copy *a);\n-            }\n-\n-            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n-            let bn = *b.data.last();\n-            let mut d = ~[];\n-            let mut carry = 0;\n-            for an.each_reverse |elt| {\n-                let ai = BigDigit::to_uint(carry, *elt);\n-                let di = ai / (bn as uint);\n-                assert!(di < BigDigit::base);\n-                carry = (ai % (bn as uint)) as BigDigit;\n-                d = ~[di as BigDigit] + d;\n-            }\n-\n-            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n-            if shift == 0 {\n-                return (BigUint::new(d), One::one(), copy *b);\n-            }\n-            return (BigUint::from_slice(d).shl_unit(shift),\n-                    One::one::<BigUint>().shl_unit(shift),\n-                    b.shl_unit(shift));\n-        }\n-    }\n-\n-    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.div_mod(other)\n-    }\n-\n-    fn to_uint(&self) -> uint {\n+    pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n             1 => self.data[0] as uint,\n@@ -679,15 +728,15 @@ impl Shr<uint, BigInt> for BigInt {\n }\n \n impl Zero for BigInt {\n-    pub fn zero() -> BigInt {\n+    fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n-    pub fn one() -> BigInt {\n+    fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n@@ -778,6 +827,88 @@ impl Neg<BigInt> for BigInt {\n     }\n }\n \n+impl Integer for BigInt {\n+    #[inline(always)]\n+    fn div(&self, other: &BigInt) -> BigInt {\n+        let (d, _) = self.div_mod(other);\n+        return d;\n+    }\n+\n+    #[inline(always)]\n+    fn modulo(&self, other: &BigInt) -> BigInt {\n+        let (_, m) = self.div_mod(other);\n+        return m;\n+    }\n+\n+    #[inline(always)]\n+    fn div_mod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // m.sign == other.sign\n+        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n+        let d = BigInt::from_biguint(Plus, d_ui),\n+            m = BigInt::from_biguint(Plus, m_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail!(),\n+            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n+            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n+                (-d, Zero::zero())\n+            } else {\n+                (-d - One::one(), m + *other)\n+            },\n+            (Minus, Plus) => if m.is_zero() {\n+                (-d, Zero::zero())\n+            } else {\n+                (-d - One::one(), other - m)\n+            },\n+            (Minus, Minus) => (d, -m)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // r.sign == self.sign\n+        let (q_ui, r_ui) = self.data.div_mod(&other.data);\n+        let q = BigInt::from_biguint(Plus, q_ui);\n+        let r = BigInt::from_biguint(Plus, r_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail!(),\n+            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n+            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n+            (Minus, Plus)                 => (-q, -r),\n+            (Minus, Minus)                => ( q, -r)\n+        }\n+    }\n+\n+    /**\n+     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+     *\n+     * The result is always positive\n+     */\n+    #[inline(always)]\n+    fn gcd(&self, other: &BigInt) -> BigInt {\n+        BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n+    }\n+\n+    /**\n+     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+     */\n+    #[inline(always)]\n+    fn lcm(&self, other: &BigInt) -> BigInt {\n+        BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n+    }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: &BigInt) -> bool { self.data.divisible_by(&other.data) }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool { self.data.is_even() }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { self.data.is_odd() }\n+}\n+\n impl IntConvertible for BigInt {\n     fn to_int(&self) -> int {\n         match self.sign {\n@@ -813,7 +944,7 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n-    pub fn from_str_radix(s: &str, radix: uint)\n+    fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n         BigInt::parse_bytes(str::to_bytes(s), radix)\n     }\n@@ -858,57 +989,6 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n-    fn abs(&self) -> BigInt {\n-        BigInt::from_biguint(Plus, copy self.data)\n-    }\n-\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.div_mod(other);\n-        return d;\n-    }\n-    fn modulo(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.div_mod(other);\n-        return m;\n-    }\n-\n-    fn div_mod(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui),\n-            m = BigInt::from_biguint(Plus, m_ui);\n-        match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n-            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), m + *other)\n-            },\n-            (Minus, Plus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), other - m)\n-            },\n-            (Minus, Minus) => (d, -m)\n-        }\n-    }\n-\n-    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // r.sign == self.sign\n-        let (q_ui, r_ui) = self.data.div_mod(&other.data);\n-        let q = BigInt::from_biguint(Plus, q_ui);\n-        let r = BigInt::from_biguint(Plus, r_ui);\n-        match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n-            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n-            (Minus, Plus)                 => (-q, -r),\n-            (Minus, Minus)                => ( q, -r)\n-        }\n-    }\n-\n-    fn is_zero(&self) -> bool { self.sign == Zero }\n-\n     fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n@@ -1229,6 +1309,41 @@ mod biguint_tests {\n         }\n     }\n \n+    #[test]\n+    fn test_gcd() {\n+        fn check(a: uint, b: uint, c: uint) {\n+            let big_a = BigUint::from_uint(a);\n+            let big_b = BigUint::from_uint(b);\n+            let big_c = BigUint::from_uint(c);\n+\n+            assert_eq!(big_a.gcd(&big_b), big_c);\n+        }\n+\n+        check(10, 2, 2);\n+        check(10, 3, 1);\n+        check(0, 3, 3);\n+        check(3, 3, 3);\n+        check(56, 42, 14);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        fn check(a: uint, b: uint, c: uint) {\n+            let big_a = BigUint::from_uint(a);\n+            let big_b = BigUint::from_uint(b);\n+            let big_c = BigUint::from_uint(c);\n+\n+            assert_eq!(big_a.lcm(&big_b), big_c);\n+        }\n+\n+        check(1, 0, 0);\n+        check(0, 1, 0);\n+        check(1, 1, 1);\n+        check(8, 9, 72);\n+        check(11, 5, 55);\n+        check(99, 17, 1683);\n+    }\n+\n     fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n         let bits = BigDigit::bits;\n         ~[( Zero::zero(), ~[\n@@ -1664,11 +1779,50 @@ mod bigint_tests {\n         }\n     }\n \n+    #[test]\n+    fn test_gcd() {\n+        fn check(a: int, b: int, c: int) {\n+            let big_a: BigInt = IntConvertible::from_int(a);\n+            let big_b: BigInt = IntConvertible::from_int(b);\n+            let big_c: BigInt = IntConvertible::from_int(c);\n+\n+            assert_eq!(big_a.gcd(&big_b), big_c);\n+        }\n+\n+        check(10, 2, 2);\n+        check(10, 3, 1);\n+        check(0, 3, 3);\n+        check(3, 3, 3);\n+        check(56, 42, 14);\n+        check(3, -3, 3);\n+        check(-6, 3, 3);\n+        check(-4, -2, 2);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        fn check(a: int, b: int, c: int) {\n+            let big_a: BigInt = IntConvertible::from_int(a);\n+            let big_b: BigInt = IntConvertible::from_int(b);\n+            let big_c: BigInt = IntConvertible::from_int(c);\n+\n+            assert_eq!(big_a.lcm(&big_b), big_c);\n+        }\n+\n+        check(1, 0, 0);\n+        check(0, 1, 0);\n+        check(1, 1, 1);\n+        check(-1, 1, 1);\n+        check(1, -1, 1);\n+        check(-1, -1, 1);\n+        check(8, 9, 72);\n+        check(11, 5, 55);\n+    }\n+\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert!(ans == IntConvertible::from_int::<BigInt>(\n-                n).to_str_radix(10));\n+            assert!(ans == IntConvertible::from_int::<BigInt>(n).to_str_radix(10));\n         }\n         check(10, \"10\");\n         check(1, \"1\");"}]}