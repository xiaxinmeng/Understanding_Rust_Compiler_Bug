{"sha": "1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMjNkZDc5NTczMzU4NWI3OTU1YWQ1YjU2NWViZDJiYzNkNGQzY2E=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-29T13:45:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-29T13:45:28Z"}, "message": "Merge #9722\n\n9722: fix: Refine extraction targets of extract_function assist r=Veykril a=Veykril\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/7748\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0551abc875397a0c6768695b4ad9faaebc120b6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0551abc875397a0c6768695b4ad9faaebc120b6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhArD4CRBK7hj4Ov3rIwAA9gMIAKX+Bg/nOy04M3n8ZN/f3bGb\nmixS5H6IwH0GtL211wrUi0cDisbNULLaAXXzMawFENIqSEqZ6BwdZe8Hxn8wsHZC\nNBegFYfV1KYbpK1K4SMVT4QRIx9Tj3DBv9kWh7HIIFqMyJrQ5AmFZpS+Mu1IvHTF\n64eQR0TTRtN98G/q+QWTk027xVeb+iXIsLSAPr1KBcd+i9Amq7ypt9RFip16jP7Z\nlNKUIQjmj2tSVWePQCMcevOYns/aqPoJPaven0cVrf/Ur/gSjiGw4z4btMexgQtV\nHPFBqQEMU1hmGoRmc8jndC1qPK9f0pg4Ptykz1ncAa8w+ME0rWikpFnaEL9hkYo=\n=LwxK\n-----END PGP SIGNATURE-----\n", "payload": "tree 0551abc875397a0c6768695b4ad9faaebc120b6d\nparent 8d3b294ef7df0863941d65c433394f0f0ceaffa3\nparent 2b461c50d7a05c76c996d75e858cfe3c8a7390b7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627566328 +0000\ncommitter GitHub <noreply@github.com> 1627566328 +0000\n\nMerge #9722\n\n9722: fix: Refine extraction targets of extract_function assist r=Veykril a=Veykril\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/7748\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "html_url": "https://github.com/rust-lang/rust/commit/1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d3b294ef7df0863941d65c433394f0f0ceaffa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3b294ef7df0863941d65c433394f0f0ceaffa3", "html_url": "https://github.com/rust-lang/rust/commit/8d3b294ef7df0863941d65c433394f0f0ceaffa3"}, {"sha": "2b461c50d7a05c76c996d75e858cfe3c8a7390b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b461c50d7a05c76c996d75e858cfe3c8a7390b7", "html_url": "https://github.com/rust-lang/rust/commit/2b461c50d7a05c76c996d75e858cfe3c8a7390b7"}], "stats": {"total": 128, "additions": 64, "deletions": 64}, "files": [{"sha": "d0a49d1f37a9763eb748ed0958c486fb1d2ea281", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "patch": "@@ -617,22 +617,22 @@ fn main() {\n     #[test]\n     fn test_rename_struct_field() {\n         check(\n-            \"j\",\n+            \"foo\",\n             r#\"\n-struct Foo { i$0: i32 }\n+struct Foo { field$0: i32 }\n \n impl Foo {\n     fn new(i: i32) -> Self {\n-        Self { i: i }\n+        Self { field: i }\n     }\n }\n \"#,\n             r#\"\n-struct Foo { j: i32 }\n+struct Foo { foo: i32 }\n \n impl Foo {\n     fn new(i: i32) -> Self {\n-        Self { j: i }\n+        Self { foo: i }\n     }\n }\n \"#,\n@@ -643,22 +643,22 @@ impl Foo {\n     fn test_rename_field_in_field_shorthand() {\n         cov_mark::check!(test_rename_field_in_field_shorthand);\n         check(\n-            \"j\",\n+            \"field\",\n             r#\"\n-struct Foo { i$0: i32 }\n+struct Foo { foo$0: i32 }\n \n impl Foo {\n-    fn new(i: i32) -> Self {\n-        Self { i }\n+    fn new(foo: i32) -> Self {\n+        Self { foo }\n     }\n }\n \"#,\n             r#\"\n-struct Foo { j: i32 }\n+struct Foo { field: i32 }\n \n impl Foo {\n-    fn new(i: i32) -> Self {\n-        Self { j: i }\n+    fn new(foo: i32) -> Self {\n+        Self { field: foo }\n     }\n }\n \"#,"}, {"sha": "abf8329f01772984bd7b14484ade072ae946fb12", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "patch": "@@ -16,7 +16,7 @@ use syntax::{\n         AstNode,\n     },\n     ted,\n-    SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n+    SyntaxKind::{self, COMMENT},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n \n@@ -466,22 +466,17 @@ enum FunctionBody {\n }\n \n impl FunctionBody {\n-    fn from_whole_node(node: SyntaxNode) -> Option<Self> {\n-        match node.kind() {\n-            PATH_EXPR => None,\n-            BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()).map(Self::Expr),\n-            RETURN_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()).map(Self::Expr),\n-            BLOCK_EXPR => ast::BlockExpr::cast(node)\n-                .filter(|it| it.is_standalone())\n-                .map(Into::into)\n-                .map(Self::Expr),\n-            _ => ast::Expr::cast(node).map(Self::Expr),\n+    fn from_expr(expr: ast::Expr) -> Option<Self> {\n+        match expr {\n+            ast::Expr::BreakExpr(it) => it.expr().map(Self::Expr),\n+            ast::Expr::ReturnExpr(it) => it.expr().map(Self::Expr),\n+            ast::Expr::BlockExpr(it) if !it.is_standalone() => None,\n+            expr => Some(Self::Expr(expr)),\n         }\n     }\n \n-    fn from_range(node: SyntaxNode, text_range: TextRange) -> Option<FunctionBody> {\n-        let block = ast::BlockExpr::cast(node)?;\n-        Some(Self::Span { parent: block, text_range })\n+    fn from_range(parent: ast::BlockExpr, text_range: TextRange) -> FunctionBody {\n+        Self::Span { parent, text_range }\n     }\n \n     fn indent_level(&self) -> IndentLevel {\n@@ -592,44 +587,39 @@ struct OutlivedLocal {\n ///   ```\n ///\n fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n-    // we have selected exactly the expr node\n-    // wrap it before anything else\n-    if node.text_range() == selection_range {\n-        let body = FunctionBody::from_whole_node(node.clone());\n-        if body.is_some() {\n-            return body;\n-        }\n+    if let Some(stmt) = ast::Stmt::cast(node.clone()) {\n+        return match stmt {\n+            ast::Stmt::Item(_) => None,\n+            ast::Stmt::ExprStmt(_) | ast::Stmt::LetStmt(_) => Some(FunctionBody::from_range(\n+                node.parent().and_then(ast::BlockExpr::cast)?,\n+                node.text_range(),\n+            )),\n+        };\n     }\n \n-    // we have selected a few statements in a block\n-    // so covering_element returns the whole block\n-    if node.kind() == BLOCK_EXPR {\n-        // Extract the full statements.\n-        let statements_range = node\n-            .children()\n-            .filter(|c| selection_range.intersect(c.text_range()).is_some())\n-            .fold(selection_range, |acc, c| acc.cover(c.text_range()));\n-        let body = FunctionBody::from_range(node.clone(), statements_range);\n-        if body.is_some() {\n-            return body;\n-        }\n+    let expr = ast::Expr::cast(node.clone())?;\n+    // A node got selected fully\n+    if node.text_range() == selection_range {\n+        return FunctionBody::from_expr(expr.clone());\n     }\n \n-    // we have selected single statement\n-    // `from_whole_node` failed because (let) statement is not and expression\n-    // so we try to expand covering_element to parent and repeat the previous\n-    if let Some(parent) = node.parent() {\n-        if parent.kind() == BLOCK_EXPR {\n-            // Extract the full statement.\n-            let body = FunctionBody::from_range(parent, node.text_range());\n-            if body.is_some() {\n-                return body;\n-            }\n+    // Covering element returned the parent block of one or multiple statements that have been selected\n+    if let ast::Expr::BlockExpr(block) = expr {\n+        // Extract the full statements.\n+        let mut statements_range = block\n+            .statements()\n+            .filter(|stmt| selection_range.intersect(stmt.syntax().text_range()).is_some())\n+            .fold(selection_range, |acc, stmt| acc.cover(stmt.syntax().text_range()));\n+        if let Some(e) = block\n+            .tail_expr()\n+            .filter(|it| selection_range.intersect(it.syntax().text_range()).is_some())\n+        {\n+            statements_range = statements_range.cover(e.syntax().text_range());\n         }\n+        return Some(FunctionBody::from_range(block, statements_range));\n     }\n \n-    // select the closest containing expr (both ifs are used)\n-    std::iter::once(node.clone()).chain(node.ancestors()).find_map(FunctionBody::from_whole_node)\n+    node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n }\n \n /// list local variables that are referenced in `body`\n@@ -3743,6 +3733,16 @@ async fn $0fun_name() {\n async fn some_function() {\n \n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_extract_standalone_blocks() {\n+        check_assist_not_applicable(\n+            extract_function,\n+            r#\"\n+fn main() $0{}$0\n \"#,\n         );\n     }"}, {"sha": "4ca3260877c6a65f52028e11175745fbf8358c0e", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1323dd795733585b7955ad5b565ebd2bc3d4d3ca/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=1323dd795733585b7955ad5b565ebd2bc3d4d3ca", "patch": "@@ -229,7 +229,7 @@ fn rename_reference(\n     let ident_kind = IdentifierKind::classify(new_name)?;\n \n     if matches!(\n-        def, // is target a lifetime?\n+        def,\n         Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n     ) {\n         match ident_kind {\n@@ -240,13 +240,13 @@ fn rename_reference(\n             IdentifierKind::Lifetime => cov_mark::hit!(rename_lifetime),\n         }\n     } else {\n-        match (ident_kind, def) {\n-            (IdentifierKind::Lifetime, _) => {\n+        match ident_kind {\n+            IdentifierKind::Lifetime => {\n                 cov_mark::hit!(rename_not_an_ident_ref);\n                 bail!(\"Invalid name `{}`: not an identifier\", new_name);\n             }\n-            (IdentifierKind::Ident, _) => cov_mark::hit!(rename_non_local),\n-            (IdentifierKind::Underscore, _) => (),\n+            IdentifierKind::Ident => cov_mark::hit!(rename_non_local),\n+            IdentifierKind::Underscore => (),\n         }\n     }\n \n@@ -325,6 +325,8 @@ pub fn source_edit_from_references(\n \n fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n     if let Some(_) = ast::RecordPatField::for_field_name(name) {\n+        // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+        // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n         if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n             return Some((\n                 TextRange::empty(ident_pat.syntax().text_range().start()),\n@@ -368,8 +370,6 @@ fn source_edit_from_name_ref(\n                 None\n             }\n             // init shorthand\n-            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n             (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n                 cov_mark::hit!(test_rename_field_in_field_shorthand);\n                 let s = name_ref.syntax().text_range().start();"}]}