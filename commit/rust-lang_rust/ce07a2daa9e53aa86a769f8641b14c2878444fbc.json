{"sha": "ce07a2daa9e53aa86a769f8641b14c2878444fbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMDdhMmRhYTllNTNhYTg2YTc2OWY4NjQxYjE0YzI4Nzg0NDRmYmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-23T10:58:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-23T10:58:06Z"}, "message": "Merge #2636\n\n2636: Chalk update and refactoring r=flodiebold a=flodiebold\n\nThis updates the Chalk integration to https://github.com/rust-lang/chalk/pull/311, which will presumably get merged soon, and refactors it some more, most notably introducing our own `TypeFamily` instead of reusing `ChalkIr`. It's still mostly the same as `ChalkIr` though, except for using Salsa `InternId`s directly.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "fc5802a209c642e862171a1d022634eefd2a03a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5802a209c642e862171a1d022634eefd2a03a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce07a2daa9e53aa86a769f8641b14c2878444fbc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeAJ2+CRBK7hj4Ov3rIwAAdHIIAHRJcb95s1bk6TatImWE248j\nMSAm3C7+IfO3j2a3ewBnU36g/ZFobwQj/RD6FvH5Tlce4WY3VXz/Gz2AHznElhc+\nJ1dxXT1N6sWSHDd1+883gtU3RAQ8t+XxOyghHZSb7BLhDRNYuNLkOYdOEFnUkvMS\nYTnIBjkR7B3N13YK7ksPilX0HbPvhuhL7vQicrP1H1f5HEmJkNNkevA5zz1TY4uD\n4ggbSl/sjYj1LdEbADB4hbE3PN9eSuthZvh6XT0BEnTrxVe1y6OYqxLznIuaSZQc\nmdvTvPjc5M1QDMgsH1qxZXhasZivY+LCt7yp5SPsmHUKv4MvEWhbN8RJwbJoLMU=\n=Z0C/\n-----END PGP SIGNATURE-----\n", "payload": "tree fc5802a209c642e862171a1d022634eefd2a03a9\nparent 31c5888a4c0913c44d13f25f8cb79e0701e84f71\nparent 1f7f4578f72721c1b0e17e8405f986fd2ce89aaf\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1577098686 +0000\ncommitter GitHub <noreply@github.com> 1577098686 +0000\n\nMerge #2636\n\n2636: Chalk update and refactoring r=flodiebold a=flodiebold\n\nThis updates the Chalk integration to https://github.com/rust-lang/chalk/pull/311, which will presumably get merged soon, and refactors it some more, most notably introducing our own `TypeFamily` instead of reusing `ChalkIr`. It's still mostly the same as `ChalkIr` though, except for using Salsa `InternId`s directly.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce07a2daa9e53aa86a769f8641b14c2878444fbc", "html_url": "https://github.com/rust-lang/rust/commit/ce07a2daa9e53aa86a769f8641b14c2878444fbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce07a2daa9e53aa86a769f8641b14c2878444fbc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31c5888a4c0913c44d13f25f8cb79e0701e84f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/31c5888a4c0913c44d13f25f8cb79e0701e84f71", "html_url": "https://github.com/rust-lang/rust/commit/31c5888a4c0913c44d13f25f8cb79e0701e84f71"}, {"sha": "1f7f4578f72721c1b0e17e8405f986fd2ce89aaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7f4578f72721c1b0e17e8405f986fd2ce89aaf", "html_url": "https://github.com/rust-lang/rust/commit/1f7f4578f72721c1b0e17e8405f986fd2ce89aaf"}], "stats": {"total": 660, "additions": 354, "deletions": 306}, "files": [{"sha": "e724c1a76b77fcb6456bcb45a62a63b8982d7f02", "filename": "Cargo.lock", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -128,7 +128,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb#151949dece8117d180b5d197a7afa968c3ba14bb\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -138,52 +138,52 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb#151949dece8117d180b5d197a7afa968c3ba14bb\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb#151949dece8117d180b5d197a7afa968c3ba14bb\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb#151949dece8117d180b5d197a7afa968c3ba14bb\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb#151949dece8117d180b5d197a7afa968c3ba14bb\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb#151949dece8117d180b5d197a7afa968c3ba14bb\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5#ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -995,9 +995,9 @@ name = \"ra_hir_ty\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1782,12 +1782,12 @@ dependencies = [\n \"checksum cargo_metadata 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46e3374c604fb39d1a2f35ed5e4a4e30e60d01fab49446e08f1b3e9a90aef202\"\n \"checksum cc 1.0.48 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f52a465a666ca3d838ebbf08b241383421412fe7ebb463527bba275526d89f76\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=151949dece8117d180b5d197a7afa968c3ba14bb)\" = \"<none>\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5)\" = \"<none>\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n \"checksum console 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5d540c2d34ac9dd0deb5f3b5f54c36c79efa78f6b3ad19106a554d07a7b5d9f\""}, {"sha": "60793db442511b31c42b363f37ecb62145e174ee", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -21,10 +21,9 @@ ra_prof = { path = \"../ra_prof\" }\n ra_syntax = { path = \"../ra_syntax\" }\n test_utils = { path = \"../test_utils\" }\n \n-# https://github.com/rust-lang/chalk/pull/294\n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"151949dece8117d180b5d197a7afa968c3ba14bb\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"151949dece8117d180b5d197a7afa968c3ba14bb\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"151949dece8117d180b5d197a7afa968c3ba14bb\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n \n lalrpop-intern = \"0.15.1\"\n "}, {"sha": "d52f65b83634204019e4c82d3e6fe77e572b9457", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -10,7 +10,7 @@ use ra_db::{salsa, CrateId};\n \n use crate::{\n     method_resolution::CrateImplBlocks,\n-    traits::{AssocTyValue, Impl},\n+    traits::{chalk, AssocTyValue, Impl},\n     CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, TraitRef, Ty, TyDefId, TypeCtor,\n     ValueTyDefId,\n };\n@@ -77,39 +77,24 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n \n-    #[salsa::invoke(crate::traits::chalk::associated_ty_data_query)]\n-    fn associated_ty_data(\n-        &self,\n-        id: chalk_ir::TypeId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n+    #[salsa::invoke(chalk::associated_ty_data_query)]\n+    fn associated_ty_data(&self, id: chalk::AssocTypeId) -> Arc<chalk::AssociatedTyDatum>;\n \n-    #[salsa::invoke(crate::traits::chalk::trait_datum_query)]\n-    fn trait_datum(\n-        &self,\n-        krate: CrateId,\n-        trait_id: chalk_ir::TraitId,\n-    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n+    #[salsa::invoke(chalk::trait_datum_query)]\n+    fn trait_datum(&self, krate: CrateId, trait_id: chalk::TraitId) -> Arc<chalk::TraitDatum>;\n \n-    #[salsa::invoke(crate::traits::chalk::struct_datum_query)]\n-    fn struct_datum(\n-        &self,\n-        krate: CrateId,\n-        struct_id: chalk_ir::StructId,\n-    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n+    #[salsa::invoke(chalk::struct_datum_query)]\n+    fn struct_datum(&self, krate: CrateId, struct_id: chalk::StructId) -> Arc<chalk::StructDatum>;\n \n     #[salsa::invoke(crate::traits::chalk::impl_datum_query)]\n-    fn impl_datum(\n-        &self,\n-        krate: CrateId,\n-        impl_id: chalk_ir::ImplId,\n-    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n+    fn impl_datum(&self, krate: CrateId, impl_id: chalk::ImplId) -> Arc<chalk::ImplDatum>;\n \n     #[salsa::invoke(crate::traits::chalk::associated_ty_value_query)]\n     fn associated_ty_value(\n         &self,\n         krate: CrateId,\n-        id: chalk_rust_ir::AssociatedTyValueId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n+        id: chalk::AssociatedTyValueId,\n+    ) -> Arc<chalk::AssociatedTyValue>;\n \n     #[salsa::invoke(crate::traits::trait_solve_query)]\n     fn trait_solve("}, {"sha": "ce9a06fde4b94bec40f1f438dbcaf698d5e68f1d", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -865,7 +865,7 @@ mod foo {\n \n #[test]\n fn method_resolution_where_clause_for_unknown_trait() {\n-    // The blanket impl shouldn't apply because we can't even resolve UnknownTrait\n+    // The blanket impl currently applies because we ignore the unresolved where clause\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -875,7 +875,7 @@ impl<T> Trait for T where T: UnknownTrait {}\n fn test() { (&S).foo()<|>; }\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n+    assert_eq!(t, \"u128\");\n }\n \n #[test]"}, {"sha": "ae316922bdea8a3df540c06642e0b4c48ca82544", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -958,6 +958,23 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn error_bound_chalk() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    fn foo(&self) -> u32 {}\n+}\n+\n+fn test(x: (impl Trait + UnknownTrait)) {\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n #[test]\n fn assoc_type_bindings() {\n     assert_snapshot!("}, {"sha": "c4dc857bc7b9cbe3ad61b1a885fb53188114f2d2", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -1,7 +1,7 @@\n //! Trait solving using Chalk.\n use std::sync::{Arc, Mutex};\n \n-use chalk_ir::{cast::Cast, family::ChalkIr};\n+use chalk_ir::cast::Cast;\n use hir_def::{expr::ExprId, DefWithBodyId, ImplId, TraitId, TypeAliasId};\n use log::debug;\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -12,15 +12,15 @@ use crate::db::HirDatabase;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n-use self::chalk::{from_chalk, ToChalk};\n+use self::chalk::{from_chalk, ToChalk, TypeFamily};\n \n pub(crate) mod chalk;\n mod builtin;\n \n #[derive(Debug, Clone)]\n pub struct TraitSolver {\n     krate: CrateId,\n-    inner: Arc<Mutex<chalk_solve::Solver<ChalkIr>>>,\n+    inner: Arc<Mutex<chalk_solve::Solver<TypeFamily>>>,\n }\n \n /// We need eq for salsa\n@@ -36,8 +36,8 @@ impl TraitSolver {\n     fn solve(\n         &self,\n         db: &impl HirDatabase,\n-        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<ChalkIr>>>,\n-    ) -> Option<chalk_solve::Solution<ChalkIr>> {\n+        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<TypeFamily>>>,\n+    ) -> Option<chalk_solve::Solution<TypeFamily>> {\n         let context = ChalkContext { db, krate: self.krate };\n         debug!(\"solve goal: {:?}\", goal);\n         let mut solver = match self.inner.lock() {\n@@ -201,17 +201,17 @@ pub(crate) fn trait_solve_query(\n \n fn solution_from_chalk(\n     db: &impl HirDatabase,\n-    solution: chalk_solve::Solution<ChalkIr>,\n+    solution: chalk_solve::Solution<TypeFamily>,\n ) -> Solution {\n-    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<ChalkIr>>| {\n+    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<TypeFamily>>| {\n         let value = subst\n             .value\n             .parameters\n             .into_iter()\n             .map(|p| {\n-                let ty = match p {\n-                    chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n-                    chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+                let ty = match p.ty() {\n+                    Some(ty) => from_chalk(db, ty.clone()),\n+                    None => unimplemented!(),\n                 };\n                 ty\n             })\n@@ -291,7 +291,7 @@ impl FnTrait {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ClosureFnTraitImplData {\n     def: DefWithBodyId,\n     expr: ExprId,\n@@ -300,7 +300,7 @@ pub struct ClosureFnTraitImplData {\n \n /// An impl. Usually this comes from an impl block, but some built-in types get\n /// synthetic impls.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum Impl {\n     /// A normal impl from an impl block.\n     ImplBlock(ImplId),"}, {"sha": "dd41176f0df66469b8bf4d5cb150bb8acd1721ca", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -28,24 +28,24 @@ pub(super) fn get_builtin_impls(\n     trait_: TraitId,\n     mut callback: impl FnMut(Impl),\n ) {\n+    // Note: since impl_datum needs to be infallible, we need to make sure here\n+    // that we have all prerequisites to build the respective impls.\n     if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n         for &fn_trait in [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n         {\n             if let Some(actual_trait) = get_fn_trait(db, krate, fn_trait) {\n                 if trait_ == actual_trait {\n                     let impl_ = super::ClosureFnTraitImplData { def: *def, expr: *expr, fn_trait };\n-                    callback(Impl::ClosureFnTraitImpl(impl_));\n+                    if check_closure_fn_trait_impl_prerequisites(db, krate, impl_) {\n+                        callback(Impl::ClosureFnTraitImpl(impl_));\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n-pub(super) fn impl_datum(\n-    db: &impl HirDatabase,\n-    krate: CrateId,\n-    impl_: Impl,\n-) -> Option<BuiltinImplData> {\n+pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplBlock(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n@@ -65,21 +65,38 @@ pub(super) fn associated_ty_value(\n     }\n }\n \n+fn check_closure_fn_trait_impl_prerequisites(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> bool {\n+    // the respective Fn/FnOnce/FnMut trait needs to exist\n+    if get_fn_trait(db, krate, data.fn_trait).is_none() {\n+        return false;\n+    }\n+\n+    // FIXME: there are more assumptions that we should probably check here:\n+    // the traits having no type params, FnOnce being a supertrait\n+\n+    // the FnOnce trait needs to exist and have an assoc type named Output\n+    let fn_once_trait = match get_fn_trait(db, krate, super::FnTrait::FnOnce) {\n+        Some(t) => t,\n+        None => return false,\n+    };\n+    db.trait_data(fn_once_trait).associated_type_by_name(&name![Output]).is_some()\n+}\n+\n fn closure_fn_trait_impl_datum(\n     db: &impl HirDatabase,\n     krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n-) -> Option<BuiltinImplData> {\n+) -> BuiltinImplData {\n     // for some closure |X, Y| -> Z:\n     // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n \n-    let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n-\n-    // validate FnOnce trait, since we need it in the assoc ty value definition\n-    // and don't want to return a valid value only to find out later that FnOnce\n-    // is broken\n-    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n+    let trait_ = get_fn_trait(db, krate, data.fn_trait) // get corresponding fn trait\n+        // the existence of the Fn trait has been checked before\n+        .expect(\"fn trait for closure impl missing\");\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         Expr::Lambda { args, .. } => args.len() as u16,\n@@ -107,12 +124,12 @@ fn closure_fn_trait_impl_datum(\n \n     let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone());\n \n-    Some(BuiltinImplData {\n+    BuiltinImplData {\n         num_vars: num_args as usize + 1,\n         trait_ref,\n         where_clauses: Vec::new(),\n         assoc_ty_values: vec![output_ty_id],\n-    })\n+    }\n }\n \n fn closure_fn_trait_output_assoc_ty_value("}, {"sha": "555930c9bfa12afbdec21d679f39bc63b42ed8c4", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 249, "deletions": 219, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce07a2daa9e53aa86a769f8641b14c2878444fbc/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=ce07a2daa9e53aa86a769f8641b14c2878444fbc", "patch": "@@ -1,17 +1,11 @@\n //! Conversion code from/to Chalk.\n-use std::sync::Arc;\n+use std::{fmt, sync::Arc};\n \n use log::debug;\n \n-use chalk_ir::{\n-    cast::Cast, family::ChalkIr, Identifier, Parameter, PlaceholderIndex, TypeId, TypeKindId,\n-    TypeName, UniverseIndex,\n-};\n-use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n+use chalk_ir::{cast::Cast, Parameter, PlaceholderIndex, TypeName, UniverseIndex};\n \n-use hir_def::{\n-    AssocContainerId, AssocItemId, GenericDefId, HasModule, ImplId, Lookup, TraitId, TypeAliasId,\n-};\n+use hir_def::{AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId};\n use ra_db::{\n     salsa::{InternId, InternKey},\n     CrateId,\n@@ -23,9 +17,83 @@ use crate::{\n     ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n-/// This represents a trait whose name we could not resolve.\n-const UNKNOWN_TRAIT: chalk_ir::TraitId =\n-    chalk_ir::TraitId(chalk_ir::RawId { index: u32::max_value() });\n+#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct TypeFamily {}\n+\n+impl chalk_ir::family::TypeFamily for TypeFamily {\n+    type InternedType = Box<chalk_ir::TyData<Self>>;\n+    type InternedLifetime = chalk_ir::LifetimeData<Self>;\n+    type InternedParameter = chalk_ir::ParameterData<Self>;\n+    type DefId = InternId;\n+\n+    // FIXME: implement these\n+    fn debug_struct_id(\n+        _type_kind_id: chalk_ir::StructId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn debug_trait_id(\n+        _type_kind_id: chalk_ir::TraitId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn debug_assoc_type_id(\n+        _id: chalk_ir::AssocTypeId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn debug_projection(\n+        _projection: &chalk_ir::ProjectionTy<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn intern_ty(ty: chalk_ir::TyData<Self>) -> Box<chalk_ir::TyData<Self>> {\n+        Box::new(ty)\n+    }\n+\n+    fn ty_data(ty: &Box<chalk_ir::TyData<Self>>) -> &chalk_ir::TyData<Self> {\n+        ty\n+    }\n+\n+    fn intern_lifetime(lifetime: chalk_ir::LifetimeData<Self>) -> chalk_ir::LifetimeData<Self> {\n+        lifetime\n+    }\n+\n+    fn lifetime_data(lifetime: &chalk_ir::LifetimeData<Self>) -> &chalk_ir::LifetimeData<Self> {\n+        lifetime\n+    }\n+\n+    fn intern_parameter(parameter: chalk_ir::ParameterData<Self>) -> chalk_ir::ParameterData<Self> {\n+        parameter\n+    }\n+\n+    fn parameter_data(parameter: &chalk_ir::ParameterData<Self>) -> &chalk_ir::ParameterData<Self> {\n+        parameter\n+    }\n+}\n+\n+impl chalk_ir::family::HasTypeFamily for TypeFamily {\n+    type TypeFamily = Self;\n+}\n+\n+pub type AssocTypeId = chalk_ir::AssocTypeId<TypeFamily>;\n+pub type AssociatedTyDatum = chalk_rust_ir::AssociatedTyDatum<TypeFamily>;\n+pub type TraitId = chalk_ir::TraitId<TypeFamily>;\n+pub type TraitDatum = chalk_rust_ir::TraitDatum<TypeFamily>;\n+pub type StructId = chalk_ir::StructId<TypeFamily>;\n+pub type StructDatum = chalk_rust_ir::StructDatum<TypeFamily>;\n+pub type ImplId = chalk_ir::ImplId<TypeFamily>;\n+pub type ImplDatum = chalk_rust_ir::ImplDatum<TypeFamily>;\n+pub type AssociatedTyValueId = chalk_rust_ir::AssociatedTyValueId;\n+pub type AssociatedTyValue = chalk_rust_ir::AssociatedTyValue<TypeFamily>;\n \n pub(super) trait ToChalk {\n     type Chalk;\n@@ -41,21 +109,11 @@ where\n }\n \n impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty<ChalkIr>;\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty<ChalkIr> {\n+    type Chalk = chalk_ir::Ty<TypeFamily>;\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty<TypeFamily> {\n         match self {\n             Ty::Apply(apply_ty) => {\n-                let name = match apply_ty.ctor {\n-                    TypeCtor::AssociatedType(type_alias) => {\n-                        let type_id = type_alias.to_chalk(db);\n-                        TypeName::AssociatedType(type_id)\n-                    }\n-                    _ => {\n-                        // other TypeCtors get interned and turned into a chalk StructId\n-                        let struct_id = apply_ty.ctor.to_chalk(db);\n-                        TypeName::TypeKindId(struct_id.into())\n-                    }\n-                };\n+                let name = apply_ty.ctor.to_chalk(db);\n                 let parameters = apply_ty.parameters.to_chalk(db);\n                 chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n@@ -65,17 +123,30 @@ impl ToChalk for Ty {\n                 chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast().intern()\n             }\n             Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty::<ChalkIr>()\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n+                    .to_ty::<TypeFamily>()\n             }\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             Ty::Dyn(predicates) => {\n-                let where_clauses = predicates.iter().cloned().map(|p| p.to_chalk(db)).collect();\n-                chalk_ir::TyData::Dyn(make_binders(where_clauses, 1)).intern()\n+                let where_clauses = predicates\n+                    .iter()\n+                    .filter(|p| !p.is_error())\n+                    .cloned()\n+                    .map(|p| p.to_chalk(db))\n+                    .collect();\n+                let bounded_ty = chalk_ir::BoundedTy { bounds: make_binders(where_clauses, 1) };\n+                chalk_ir::TyData::Dyn(bounded_ty).intern()\n             }\n             Ty::Opaque(predicates) => {\n-                let where_clauses = predicates.iter().cloned().map(|p| p.to_chalk(db)).collect();\n-                chalk_ir::TyData::Opaque(make_binders(where_clauses, 1)).intern()\n+                let where_clauses = predicates\n+                    .iter()\n+                    .filter(|p| !p.is_error())\n+                    .cloned()\n+                    .map(|p| p.to_chalk(db))\n+                    .collect();\n+                let bounded_ty = chalk_ir::BoundedTy { bounds: make_binders(where_clauses, 1) };\n+                chalk_ir::TyData::Opaque(bounded_ty).intern()\n             }\n             Ty::Unknown => {\n                 let parameters = Vec::new();\n@@ -84,30 +155,19 @@ impl ToChalk for Ty {\n             }\n         }\n     }\n-    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<ChalkIr>) -> Self {\n+    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<TypeFamily>) -> Self {\n         match chalk.data().clone() {\n-            chalk_ir::TyData::Apply(apply_ty) => {\n-                // FIXME this is kind of hacky due to the fact that\n-                // TypeName::Placeholder is a Ty::Param on our side\n-                match apply_ty.name {\n-                    TypeName::TypeKindId(TypeKindId::StructId(struct_id)) => {\n-                        let ctor = from_chalk(db, struct_id);\n-                        let parameters = from_chalk(db, apply_ty.parameters);\n-                        Ty::Apply(ApplicationTy { ctor, parameters })\n-                    }\n-                    TypeName::AssociatedType(type_id) => {\n-                        let ctor = TypeCtor::AssociatedType(from_chalk(db, type_id));\n-                        let parameters = from_chalk(db, apply_ty.parameters);\n-                        Ty::Apply(ApplicationTy { ctor, parameters })\n-                    }\n-                    TypeName::Error => Ty::Unknown,\n-                    // FIXME handle TypeKindId::Trait/Type here\n-                    TypeName::TypeKindId(_) => unimplemented!(),\n-                    TypeName::Placeholder(idx) => {\n-                        assert_eq!(idx.ui, UniverseIndex::ROOT);\n-                        Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n-                    }\n+            chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n+                TypeName::Error => Ty::Unknown,\n+                _ => {\n+                    let ctor = from_chalk(db, apply_ty.name);\n+                    let parameters = from_chalk(db, apply_ty.parameters);\n+                    Ty::Apply(ApplicationTy { ctor, parameters })\n                 }\n+            },\n+            chalk_ir::TyData::Placeholder(idx) => {\n+                assert_eq!(idx.ui, UniverseIndex::ROOT);\n+                Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n             }\n             chalk_ir::TyData::Projection(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n@@ -118,123 +178,140 @@ impl ToChalk for Ty {\n             chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx as u32),\n             chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n             chalk_ir::TyData::Dyn(where_clauses) => {\n-                assert_eq!(where_clauses.binders.len(), 1);\n+                assert_eq!(where_clauses.bounds.binders.len(), 1);\n                 let predicates =\n-                    where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n+                    where_clauses.bounds.value.into_iter().map(|c| from_chalk(db, c)).collect();\n                 Ty::Dyn(predicates)\n             }\n             chalk_ir::TyData::Opaque(where_clauses) => {\n-                assert_eq!(where_clauses.binders.len(), 1);\n+                assert_eq!(where_clauses.bounds.binders.len(), 1);\n                 let predicates =\n-                    where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n+                    where_clauses.bounds.value.into_iter().map(|c| from_chalk(db, c)).collect();\n                 Ty::Opaque(predicates)\n             }\n         }\n     }\n }\n \n impl ToChalk for Substs {\n-    type Chalk = Vec<chalk_ir::Parameter<ChalkIr>>;\n+    type Chalk = Vec<chalk_ir::Parameter<TypeFamily>>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter<ChalkIr>> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter<TypeFamily>> {\n         self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter<ChalkIr>>) -> Substs {\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        parameters: Vec<chalk_ir::Parameter<TypeFamily>>,\n+    ) -> Substs {\n         let tys = parameters\n             .into_iter()\n-            .map(|p| match p {\n-                chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n-                chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+            .map(|p| match p.ty() {\n+                Some(ty) => from_chalk(db, ty.clone()),\n+                None => unimplemented!(),\n             })\n             .collect();\n         Substs(tys)\n     }\n }\n \n impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef<ChalkIr>;\n+    type Chalk = chalk_ir::TraitRef<TypeFamily>;\n \n-    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<ChalkIr> {\n+    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<TypeFamily> {\n         let trait_id = self.trait_.to_chalk(db);\n         let parameters = self.substs.to_chalk(db);\n         chalk_ir::TraitRef { trait_id, parameters }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<ChalkIr>) -> Self {\n+    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<TypeFamily>) -> Self {\n         let trait_ = from_chalk(db, trait_ref.trait_id);\n         let substs = from_chalk(db, trait_ref.parameters);\n         TraitRef { trait_, substs }\n     }\n }\n \n-impl ToChalk for TraitId {\n-    type Chalk = chalk_ir::TraitId;\n+impl ToChalk for hir_def::TraitId {\n+    type Chalk = TraitId;\n \n-    fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n-        chalk_ir::TraitId(id_to_chalk(self))\n+    fn to_chalk(self, _db: &impl HirDatabase) -> TraitId {\n+        chalk_ir::TraitId(self.as_intern_id())\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> TraitId {\n-        id_from_chalk(trait_id.0)\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: TraitId) -> hir_def::TraitId {\n+        InternKey::from_intern_id(trait_id.0)\n     }\n }\n \n impl ToChalk for TypeCtor {\n-    type Chalk = chalk_ir::StructId;\n+    type Chalk = TypeName<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::StructId {\n-        db.intern_type_ctor(self).into()\n+    fn to_chalk(self, db: &impl HirDatabase) -> TypeName<TypeFamily> {\n+        match self {\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let type_id = type_alias.to_chalk(db);\n+                TypeName::AssociatedType(type_id)\n+            }\n+            _ => {\n+                // other TypeCtors get interned and turned into a chalk StructId\n+                let struct_id = db.intern_type_ctor(self).into();\n+                TypeName::Struct(struct_id)\n+            }\n+        }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, struct_id: chalk_ir::StructId) -> TypeCtor {\n-        db.lookup_intern_type_ctor(struct_id.into())\n+    fn from_chalk(db: &impl HirDatabase, type_name: TypeName<TypeFamily>) -> TypeCtor {\n+        match type_name {\n+            TypeName::Struct(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n+            TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n+            TypeName::Error => {\n+                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n+                unreachable!()\n+            }\n+        }\n     }\n }\n \n impl ToChalk for Impl {\n-    type Chalk = chalk_ir::ImplId;\n+    type Chalk = ImplId;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n+    fn to_chalk(self, db: &impl HirDatabase) -> ImplId {\n         db.intern_chalk_impl(self).into()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> Impl {\n+    fn from_chalk(db: &impl HirDatabase, impl_id: ImplId) -> Impl {\n         db.lookup_intern_chalk_impl(impl_id.into())\n     }\n }\n \n impl ToChalk for TypeAliasId {\n-    type Chalk = chalk_ir::TypeId;\n+    type Chalk = AssocTypeId;\n \n-    fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TypeId {\n-        chalk_ir::TypeId(id_to_chalk(self))\n+    fn to_chalk(self, _db: &impl HirDatabase) -> AssocTypeId {\n+        chalk_ir::AssocTypeId(self.as_intern_id())\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAliasId {\n-        id_from_chalk(type_alias_id.0)\n+    fn from_chalk(_db: &impl HirDatabase, type_alias_id: AssocTypeId) -> TypeAliasId {\n+        InternKey::from_intern_id(type_alias_id.0)\n     }\n }\n \n impl ToChalk for AssocTyValue {\n-    type Chalk = chalk_rust_ir::AssociatedTyValueId;\n+    type Chalk = AssociatedTyValueId;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValueId {\n+    fn to_chalk(self, db: &impl HirDatabase) -> AssociatedTyValueId {\n         db.intern_assoc_ty_value(self).into()\n     }\n \n-    fn from_chalk(\n-        db: &impl HirDatabase,\n-        assoc_ty_value_id: chalk_rust_ir::AssociatedTyValueId,\n-    ) -> AssocTyValue {\n+    fn from_chalk(db: &impl HirDatabase, assoc_ty_value_id: AssociatedTyValueId) -> AssocTyValue {\n         db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n     }\n }\n \n impl ToChalk for GenericPredicate {\n-    type Chalk = chalk_ir::QuantifiedWhereClause<ChalkIr>;\n+    type Chalk = chalk_ir::QuantifiedWhereClause<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause<TypeFamily> {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n@@ -246,26 +323,16 @@ impl ToChalk for GenericPredicate {\n                 }),\n                 0,\n             ),\n-            GenericPredicate::Error => {\n-                let impossible_trait_ref = chalk_ir::TraitRef {\n-                    trait_id: UNKNOWN_TRAIT,\n-                    parameters: vec![Ty::Unknown.to_chalk(db).cast()],\n-                };\n-                make_binders(chalk_ir::WhereClause::Implemented(impossible_trait_ref), 0)\n-            }\n+            GenericPredicate::Error => panic!(\"tried passing GenericPredicate::Error to Chalk\"),\n         }\n     }\n \n     fn from_chalk(\n         db: &impl HirDatabase,\n-        where_clause: chalk_ir::QuantifiedWhereClause<ChalkIr>,\n+        where_clause: chalk_ir::QuantifiedWhereClause<TypeFamily>,\n     ) -> GenericPredicate {\n         match where_clause.value {\n             chalk_ir::WhereClause::Implemented(tr) => {\n-                if tr.trait_id == UNKNOWN_TRAIT {\n-                    // FIXME we need an Error enum on the Chalk side to avoid this\n-                    return GenericPredicate::Error;\n-                }\n                 GenericPredicate::Implemented(from_chalk(db, tr))\n             }\n             chalk_ir::WhereClause::ProjectionEq(projection_eq) => {\n@@ -278,9 +345,9 @@ impl ToChalk for GenericPredicate {\n }\n \n impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy<ChalkIr>;\n+    type Chalk = chalk_ir::ProjectionTy<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy<TypeFamily> {\n         chalk_ir::ProjectionTy {\n             associated_ty_id: self.associated_ty.to_chalk(db),\n             parameters: self.parameters.to_chalk(db),\n@@ -289,7 +356,7 @@ impl ToChalk for ProjectionTy {\n \n     fn from_chalk(\n         db: &impl HirDatabase,\n-        projection_ty: chalk_ir::ProjectionTy<ChalkIr>,\n+        projection_ty: chalk_ir::ProjectionTy<TypeFamily>,\n     ) -> ProjectionTy {\n         ProjectionTy {\n             associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n@@ -299,31 +366,31 @@ impl ToChalk for ProjectionTy {\n }\n \n impl ToChalk for super::ProjectionPredicate {\n-    type Chalk = chalk_ir::Normalize<ChalkIr>;\n+    type Chalk = chalk_ir::Normalize<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<TypeFamily> {\n         chalk_ir::Normalize {\n             projection: self.projection_ty.to_chalk(db),\n             ty: self.ty.to_chalk(db),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<ChalkIr>) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<TypeFamily>) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for Obligation {\n-    type Chalk = chalk_ir::DomainGoal<ChalkIr>;\n+    type Chalk = chalk_ir::DomainGoal<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal<TypeFamily> {\n         match self {\n             Obligation::Trait(tr) => tr.to_chalk(db).cast(),\n             Obligation::Projection(pr) => pr.to_chalk(db).cast(),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal<ChalkIr>) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal<TypeFamily>) -> Self {\n         unimplemented!()\n     }\n }\n@@ -347,32 +414,33 @@ where\n }\n \n impl ToChalk for Arc<super::TraitEnvironment> {\n-    type Chalk = chalk_ir::Environment<ChalkIr>;\n+    type Chalk = chalk_ir::Environment<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Environment<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Environment<TypeFamily> {\n         let mut clauses = Vec::new();\n         for pred in &self.predicates {\n             if pred.is_error() {\n                 // for env, we just ignore errors\n                 continue;\n             }\n-            let program_clause: chalk_ir::ProgramClause<ChalkIr> = pred.clone().to_chalk(db).cast();\n+            let program_clause: chalk_ir::ProgramClause<TypeFamily> =\n+                pred.clone().to_chalk(db).cast();\n             clauses.push(program_clause.into_from_env_clause());\n         }\n         chalk_ir::Environment::new().add_clauses(clauses)\n     }\n \n     fn from_chalk(\n         _db: &impl HirDatabase,\n-        _env: chalk_ir::Environment<ChalkIr>,\n+        _env: chalk_ir::Environment<TypeFamily>,\n     ) -> Arc<super::TraitEnvironment> {\n         unimplemented!()\n     }\n }\n \n impl<T: ToChalk> ToChalk for super::InEnvironment<T>\n where\n-    T::Chalk: chalk_ir::family::HasTypeFamily<TypeFamily = ChalkIr>,\n+    T::Chalk: chalk_ir::family::HasTypeFamily<TypeFamily = TypeFamily>,\n {\n     type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n \n@@ -395,9 +463,9 @@ where\n }\n \n impl ToChalk for builtin::BuiltinImplData {\n-    type Chalk = chalk_rust_ir::ImplDatum<ChalkIr>;\n+    type Chalk = ImplDatum;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::ImplDatum<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> ImplDatum {\n         let impl_type = chalk_rust_ir::ImplType::External;\n         let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n \n@@ -413,15 +481,15 @@ impl ToChalk for builtin::BuiltinImplData {\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _data: chalk_rust_ir::ImplDatum<ChalkIr>) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _data: ImplDatum) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n-    type Chalk = chalk_rust_ir::AssociatedTyValue<ChalkIr>;\n+    type Chalk = AssociatedTyValue;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValue<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> AssociatedTyValue {\n         let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: self.value.to_chalk(db) };\n \n         chalk_rust_ir::AssociatedTyValue {\n@@ -433,7 +501,7 @@ impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n \n     fn from_chalk(\n         _db: &impl HirDatabase,\n-        _data: chalk_rust_ir::AssociatedTyValue<ChalkIr>,\n+        _data: AssociatedTyValue,\n     ) -> builtin::BuiltinImplAssocTyValueData {\n         unimplemented!()\n     }\n@@ -450,46 +518,46 @@ fn convert_where_clauses(\n     db: &impl HirDatabase,\n     def: GenericDefId,\n     substs: &Substs,\n-) -> Vec<chalk_ir::QuantifiedWhereClause<ChalkIr>> {\n+) -> Vec<chalk_ir::QuantifiedWhereClause<TypeFamily>> {\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n         if pred.is_error() {\n-            // HACK: Return just the single predicate (which is always false\n-            // anyway), otherwise Chalk can easily get into slow situations\n-            return vec![pred.clone().subst(substs).to_chalk(db)];\n+            // skip errored predicates completely\n+            continue;\n         }\n         result.push(pred.clone().subst(substs).to_chalk(db));\n     }\n     result\n }\n \n-impl<'a, DB> chalk_solve::RustIrDatabase<ChalkIr> for ChalkContext<'a, DB>\n+impl<'a, DB> chalk_solve::RustIrDatabase<TypeFamily> for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n {\n-    fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum<ChalkIr>> {\n+    fn associated_ty_data(&self, id: AssocTypeId) -> Arc<AssociatedTyDatum> {\n         self.db.associated_ty_data(id)\n     }\n-    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum<ChalkIr>> {\n+    fn trait_datum(&self, trait_id: TraitId) -> Arc<TraitDatum> {\n         self.db.trait_datum(self.krate, trait_id)\n     }\n-    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum<ChalkIr>> {\n+    fn struct_datum(&self, struct_id: StructId) -> Arc<StructDatum> {\n         self.db.struct_datum(self.krate, struct_id)\n     }\n-    fn impl_datum(&self, impl_id: chalk_ir::ImplId) -> Arc<ImplDatum<ChalkIr>> {\n+    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n         self.db.impl_datum(self.krate, impl_id)\n     }\n     fn impls_for_trait(\n         &self,\n-        trait_id: chalk_ir::TraitId,\n-        parameters: &[Parameter<ChalkIr>],\n-    ) -> Vec<chalk_ir::ImplId> {\n+        trait_id: TraitId,\n+        parameters: &[Parameter<TypeFamily>],\n+    ) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n-        if trait_id == UNKNOWN_TRAIT {\n-            return Vec::new();\n-        }\n-        let trait_: TraitId = from_chalk(self.db, trait_id);\n+        let trait_: hir_def::TraitId = from_chalk(self.db, trait_id);\n+\n+        // Note: Since we're using impls_for_trait, only impls where the trait\n+        // can be resolved should ever reach Chalk. `impl_datum` relies on that\n+        // and will panic if the trait can't be resolved.\n         let mut result: Vec<_> = self\n             .db\n             .impls_for_trait(self.krate, trait_.into())\n@@ -508,39 +576,32 @@ where\n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n     }\n-    fn impl_provided_for(\n-        &self,\n-        auto_trait_id: chalk_ir::TraitId,\n-        struct_id: chalk_ir::StructId,\n-    ) -> bool {\n+    fn impl_provided_for(&self, auto_trait_id: TraitId, struct_id: StructId) -> bool {\n         debug!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n         false // FIXME\n     }\n-    fn type_name(&self, _id: TypeKindId) -> Identifier {\n-        unimplemented!()\n-    }\n-    fn associated_ty_value(\n-        &self,\n-        id: chalk_rust_ir::AssociatedTyValueId,\n-    ) -> Arc<AssociatedTyValue<ChalkIr>> {\n+    fn associated_ty_value(&self, id: AssociatedTyValueId) -> Arc<AssociatedTyValue> {\n         self.db.associated_ty_value(self.krate.into(), id)\n     }\n-    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n+    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<TypeFamily>> {\n         vec![]\n     }\n-    fn local_impls_to_coherence_check(\n-        &self,\n-        _trait_id: chalk_ir::TraitId,\n-    ) -> Vec<chalk_ir::ImplId> {\n+    fn local_impls_to_coherence_check(&self, _trait_id: TraitId) -> Vec<ImplId> {\n         // We don't do coherence checking (yet)\n         unimplemented!()\n     }\n+    fn as_struct_id(&self, id: &TypeName<TypeFamily>) -> Option<StructId> {\n+        match id {\n+            TypeName::Struct(struct_id) => Some(*struct_id),\n+            _ => None,\n+        }\n+    }\n }\n \n pub(crate) fn associated_ty_data_query(\n     db: &impl HirDatabase,\n-    id: TypeId,\n-) -> Arc<AssociatedTyDatum<ChalkIr>> {\n+    id: AssocTypeId,\n+) -> Arc<AssociatedTyDatum> {\n     debug!(\"associated_ty_data {:?}\", id);\n     let type_alias: TypeAliasId = from_chalk(db, id);\n     let trait_ = match type_alias.lookup(db).container {\n@@ -565,28 +626,10 @@ pub(crate) fn associated_ty_data_query(\n pub(crate) fn trait_datum_query(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    trait_id: chalk_ir::TraitId,\n-) -> Arc<TraitDatum<ChalkIr>> {\n+    trait_id: TraitId,\n+) -> Arc<TraitDatum> {\n     debug!(\"trait_datum {:?}\", trait_id);\n-    if trait_id == UNKNOWN_TRAIT {\n-        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses: Vec::new() };\n-\n-        let flags = chalk_rust_ir::TraitFlags {\n-            auto: false,\n-            marker: false,\n-            upstream: true,\n-            fundamental: false,\n-            non_enumerable: true,\n-            coinductive: false,\n-        };\n-        return Arc::new(TraitDatum {\n-            id: trait_id,\n-            binders: make_binders(trait_datum_bound, 1),\n-            flags,\n-            associated_ty_ids: vec![],\n-        });\n-    }\n-    let trait_: TraitId = from_chalk(db, trait_id);\n+    let trait_: hir_def::TraitId = from_chalk(db, trait_id);\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n     let generic_params = generics(db, trait_.into());\n@@ -616,10 +659,10 @@ pub(crate) fn trait_datum_query(\n pub(crate) fn struct_datum_query(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    struct_id: chalk_ir::StructId,\n-) -> Arc<StructDatum<ChalkIr>> {\n+    struct_id: StructId,\n+) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n-    let type_ctor: TypeCtor = from_chalk(db, struct_id);\n+    let type_ctor: TypeCtor = from_chalk(db, TypeName::Struct(struct_id));\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n     let num_params = type_ctor.num_ty_params(db);\n     let upstream = type_ctor.krate(db) != Some(krate);\n@@ -648,25 +691,27 @@ pub(crate) fn struct_datum_query(\n pub(crate) fn impl_datum_query(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    impl_id: chalk_ir::ImplId,\n-) -> Arc<ImplDatum<ChalkIr>> {\n+    impl_id: ImplId,\n+) -> Arc<ImplDatum> {\n     let _p = ra_prof::profile(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n     let impl_: Impl = from_chalk(db, impl_id);\n     match impl_ {\n         Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n-        _ => builtin::impl_datum(db, krate, impl_).map(|d| Arc::new(d.to_chalk(db))),\n+        _ => Arc::new(builtin::impl_datum(db, krate, impl_).to_chalk(db)),\n     }\n-    .unwrap_or_else(invalid_impl_datum)\n }\n \n fn impl_block_datum(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    chalk_id: chalk_ir::ImplId,\n-    impl_id: ImplId,\n-) -> Option<Arc<ImplDatum<ChalkIr>>> {\n-    let trait_ref = db.impl_trait(impl_id)?;\n+    chalk_id: ImplId,\n+    impl_id: hir_def::ImplId,\n+) -> Arc<ImplDatum> {\n+    let trait_ref = db\n+        .impl_trait(impl_id)\n+        // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n+        .expect(\"invalid impl passed to Chalk\");\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db, impl_id.into());\n@@ -718,29 +763,14 @@ fn impl_block_datum(\n         polarity,\n         associated_ty_value_ids,\n     };\n-    Some(Arc::new(impl_datum))\n-}\n-\n-fn invalid_impl_datum() -> Arc<ImplDatum<ChalkIr>> {\n-    let trait_ref = chalk_ir::TraitRef {\n-        trait_id: UNKNOWN_TRAIT,\n-        parameters: vec![chalk_ir::TyData::BoundVar(0).cast().intern().cast()],\n-    };\n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses: Vec::new() };\n-    let impl_datum = ImplDatum {\n-        binders: make_binders(impl_datum_bound, 1),\n-        impl_type: chalk_rust_ir::ImplType::External,\n-        polarity: chalk_rust_ir::Polarity::Positive,\n-        associated_ty_value_ids: Vec::new(),\n-    };\n     Arc::new(impl_datum)\n }\n \n pub(crate) fn associated_ty_value_query(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    id: chalk_rust_ir::AssociatedTyValueId,\n-) -> Arc<chalk_rust_ir::AssociatedTyValue<ChalkIr>> {\n+    id: AssociatedTyValueId,\n+) -> Arc<AssociatedTyValue> {\n     let data: AssocTyValue = from_chalk(db, id);\n     match data {\n         AssocTyValue::TypeAlias(type_alias) => {\n@@ -754,7 +784,7 @@ fn type_alias_associated_ty_value(\n     db: &impl HirDatabase,\n     _krate: CrateId,\n     type_alias: TypeAliasId,\n-) -> Arc<AssociatedTyValue<ChalkIr>> {\n+) -> Arc<AssociatedTyValue> {\n     let type_alias_data = db.type_alias_data(type_alias);\n     let impl_id = match type_alias.lookup(db).container {\n         AssocContainerId::ImplId(it) => it,\n@@ -786,27 +816,27 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n     chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n }\n \n-impl From<chalk_ir::StructId> for crate::TypeCtorId {\n-    fn from(struct_id: chalk_ir::StructId) -> Self {\n-        id_from_chalk(struct_id.0)\n+impl From<StructId> for crate::TypeCtorId {\n+    fn from(struct_id: StructId) -> Self {\n+        InternKey::from_intern_id(struct_id.0)\n     }\n }\n \n-impl From<crate::TypeCtorId> for chalk_ir::StructId {\n+impl From<crate::TypeCtorId> for StructId {\n     fn from(type_ctor_id: crate::TypeCtorId) -> Self {\n-        chalk_ir::StructId(id_to_chalk(type_ctor_id))\n+        chalk_ir::StructId(type_ctor_id.as_intern_id())\n     }\n }\n \n-impl From<chalk_ir::ImplId> for crate::traits::GlobalImplId {\n-    fn from(impl_id: chalk_ir::ImplId) -> Self {\n-        id_from_chalk(impl_id.0)\n+impl From<ImplId> for crate::traits::GlobalImplId {\n+    fn from(impl_id: ImplId) -> Self {\n+        InternKey::from_intern_id(impl_id.0)\n     }\n }\n \n-impl From<crate::traits::GlobalImplId> for chalk_ir::ImplId {\n+impl From<crate::traits::GlobalImplId> for ImplId {\n     fn from(impl_id: crate::traits::GlobalImplId) -> Self {\n-        chalk_ir::ImplId(id_to_chalk(impl_id))\n+        chalk_ir::ImplId(impl_id.as_intern_id())\n     }\n }\n "}]}