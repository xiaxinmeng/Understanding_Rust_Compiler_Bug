{"sha": "0b1669d96cee9dec9035a50fdf0a967a68605f98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMTY2OWQ5NmNlZTlkZWM5MDM1YTUwZmRmMGE5NjdhNjg2MDVmOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-25T14:25:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-25T14:25:37Z"}, "message": "Auto merge of #57714 - matthewjasper:wellformed-unreachable, r=pnkfelix\n\n[NLL] Clean up handling of type annotations\n\n* Renames (Canonical)?UserTypeAnnotation -> (Canonical)?UserType so that the name CanonicalUserTypeAnnotation is free.\n* Keep the inferred type associated to user type annotations in the MIR, so that it can be compared against the annotated type, even when the annotated expression gets removed from the MIR. (#54943)\n* Use the inferred type to allow infallible handling of user type projections (#57531)\n* Uses revisions for the tests in #56993\n* Check the types of `Unevaluated` constants with no annotations (#46702)\n* Some drive-by cleanup\n\nCloses #46702\nCloses #54943\nCloses #57531\nCloses #57731\ncc #56993 leaving this open to track the underlying issue: we are not running tests with full NLL enabled on CI at the moment\n\nr? @nikomatsakis", "tree": {"sha": "8e40b6ff988aca0ba94b901c13a72c39321cf692", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e40b6ff988aca0ba94b901c13a72c39321cf692"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b1669d96cee9dec9035a50fdf0a967a68605f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1669d96cee9dec9035a50fdf0a967a68605f98", "html_url": "https://github.com/rust-lang/rust/commit/0b1669d96cee9dec9035a50fdf0a967a68605f98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b1669d96cee9dec9035a50fdf0a967a68605f98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7187db619c134697647f96e82111cbcbae337d4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7187db619c134697647f96e82111cbcbae337d4f", "html_url": "https://github.com/rust-lang/rust/commit/7187db619c134697647f96e82111cbcbae337d4f"}, {"sha": "620a03f5aa7490cc904f868c91fbb303ec6a3274", "url": "https://api.github.com/repos/rust-lang/rust/commits/620a03f5aa7490cc904f868c91fbb303ec6a3274", "html_url": "https://github.com/rust-lang/rust/commit/620a03f5aa7490cc904f868c91fbb303ec6a3274"}], "stats": {"total": 1140, "additions": 849, "deletions": 291}, "files": [{"sha": "79c2b89522dbf4683123e7b22723eb9dd4430007", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1240,16 +1240,22 @@ impl_stable_hash_for!(\n     }\n );\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotation<'gcx> {\n+impl_stable_hash_for!(\n+    struct ty::CanonicalUserTypeAnnotation<'tcx> {\n+        user_ty, span, inferred_ty\n+    }\n+);\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserType<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ty::UserTypeAnnotation::Ty(ref ty) => {\n+            ty::UserType::Ty(ref ty) => {\n                 ty.hash_stable(hcx, hasher);\n             }\n-            ty::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n+            ty::UserType::TypeOf(ref def_id, ref substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }"}, {"sha": "f824ab7e5b39546c4c989a827b346b4b237067ea", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::layout::VariantIdx;\n use ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n-    UserTypeAnnotationIndex, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n };\n use util::ppaux;\n "}, {"sha": "649370059f0ea7e01c18e1b87f2ce38ae91d2e4e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -75,21 +75,20 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                          elem: &PlaceElem<'tcx>)\n                          -> PlaceTy<'tcx>\n     {\n-        self.projection_ty_core(tcx, elem, |_, _, ty| -> Result<Ty<'tcx>, ()> { Ok(ty) })\n-            .unwrap()\n+        self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n     /// projects `place_ty` onto `elem`, returning the appropriate\n     /// `Ty` or downcast variant corresponding to that projection.\n     /// The `handle_field` callback must map a `Field` to its `Ty`,\n     /// (which should be trivial when `T` = `Ty`).\n-    pub fn projection_ty_core<V, T, E>(\n+    pub fn projection_ty_core<V, T>(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         elem: &ProjectionElem<'tcx, V, T>,\n-        mut handle_field: impl FnMut(&Self, &Field, &T) -> Result<Ty<'tcx>, E>)\n-        -> Result<PlaceTy<'tcx>, E>\n+        mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n+        -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug, T: ::std::fmt::Debug\n     {\n@@ -140,10 +139,10 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                     }\n                 },\n             ProjectionElem::Field(ref f, ref fty) =>\n-                PlaceTy::Ty { ty: handle_field(&self, f, fty)? },\n+                PlaceTy::Ty { ty: handle_field(&self, f, fty) },\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n-        Ok(answer)\n+        answer\n     }\n }\n "}, {"sha": "598303f29328fb8cb883ef787dcbad0a2b64b055", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1,7 +1,6 @@\n use hir::def_id::DefId;\n-use infer::canonical::Canonical;\n use ty::subst::Substs;\n-use ty::{ClosureSubsts, GeneratorSubsts, Region, Ty};\n+use ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Region, Ty};\n use mir::*;\n use syntax_pos::Span;\n \n@@ -221,7 +220,7 @@ macro_rules! make_mir_visitor {\n             fn visit_user_type_annotation(\n                 &mut self,\n                 index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n+                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.super_user_type_annotation(index, ty);\n             }\n@@ -309,12 +308,15 @@ macro_rules! make_mir_visitor {\n                     self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n                 }\n \n-                for index in mir.user_type_annotations.indices() {\n-                    let (span, annotation) = & $($mutability)* mir.user_type_annotations[index];\n+                macro_rules! type_annotations {\n+                    (mut) => (mir.user_type_annotations.iter_enumerated_mut());\n+                    () => (mir.user_type_annotations.iter_enumerated());\n+                };\n+\n+                for (index, annotation) in type_annotations!($($mutability)*) {\n                     self.visit_user_type_annotation(\n                         index, annotation\n                     );\n-                    self.visit_span(span);\n                 }\n \n                 self.visit_span(&$($mutability)* mir.span);\n@@ -882,8 +884,10 @@ macro_rules! make_mir_visitor {\n             fn super_user_type_annotation(\n                 &mut self,\n                 _index: UserTypeAnnotationIndex,\n-                _ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n+                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n+                self.visit_span(& $($mutability)* ty.span);\n+                self.visit_ty(& $($mutability)* ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n@@ -964,6 +968,9 @@ pub enum TyContext {\n         source_info: SourceInfo,\n     },\n \n+    /// The inferred type of a user type annotation.\n+    UserTy(Span),\n+\n     /// The return type of the function.\n     ReturnTy(SourceInfo),\n "}, {"sha": "15f627b3ee8c4ab4d4c0694b8a2f74ecd1262718", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1,28 +1,23 @@\n use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::Fallible;\n use hir::def_id::DefId;\n-use mir::ProjectionKind;\n-use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use ty::{ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::UserSubsts;\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct AscribeUserType<'tcx> {\n     pub mir_ty: Ty<'tcx>,\n-    pub variance: ty::Variance,\n     pub def_id: DefId,\n     pub user_substs: UserSubsts<'tcx>,\n-    pub projs: &'tcx ty::List<ProjectionKind<'tcx>>,\n }\n \n impl<'tcx> AscribeUserType<'tcx> {\n     pub fn new(\n         mir_ty: Ty<'tcx>,\n-        variance: ty::Variance,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n-        projs: &'tcx ty::List<ProjectionKind<'tcx>>,\n     ) -> Self {\n-        Self { mir_ty, variance, def_id, user_substs, projs }\n+        Self { mir_ty,  def_id, user_substs }\n     }\n }\n \n@@ -52,19 +47,19 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx>\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for AscribeUserType<'tcx> {\n-        mir_ty, variance, def_id, user_substs, projs\n+        mir_ty, def_id, user_substs\n     }\n }\n \n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for AscribeUserType<'a> {\n         type Lifted = AscribeUserType<'tcx>;\n-        mir_ty, variance, def_id, user_substs, projs\n+        mir_ty, def_id, user_substs\n     }\n }\n \n impl_stable_hash_for! {\n     struct AscribeUserType<'tcx> {\n-        mir_ty, variance, def_id, user_substs, projs\n+        mir_ty, def_id, user_substs\n     }\n }"}, {"sha": "4c8f81411163c374a2c464815376fef0f41bf4db", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -350,7 +350,7 @@ pub struct TypeckTables<'tcx> {\n     /// canonical substitutions would include only `for<X> { Vec<X> }`.\n     ///\n     /// See also `AscribeUserType` statement in MIR.\n-    user_provided_types: ItemLocalMap<CanonicalUserTypeAnnotation<'tcx>>,\n+    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n \n     /// Stores the canonicalized types provided by the user. See also\n     /// `AscribeUserType` statement in MIR.\n@@ -493,7 +493,7 @@ impl<'tcx> TypeckTables<'tcx> {\n \n     pub fn user_provided_types(\n         &self\n-    ) -> LocalTableInContext<'_, CanonicalUserTypeAnnotation<'tcx>> {\n+    ) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n             data: &self.user_provided_types\n@@ -502,7 +502,7 @@ impl<'tcx> TypeckTables<'tcx> {\n \n     pub fn user_provided_types_mut(\n         &mut self\n-    ) -> LocalTableInContextMut<'_, CanonicalUserTypeAnnotation<'tcx>> {\n+    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.user_provided_types\n@@ -800,25 +800,46 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n newtype_index! {\n     pub struct UserTypeAnnotationIndex {\n-        DEBUG_FORMAT = \"UserTypeAnnotation({})\",\n+        DEBUG_FORMAT = \"UserType({})\",\n         const START_INDEX = 0,\n     }\n }\n \n /// Mapping of type annotation indices to canonical user type annotations.\n pub type CanonicalUserTypeAnnotations<'tcx> =\n-    IndexVec<UserTypeAnnotationIndex, (Span, CanonicalUserTypeAnnotation<'tcx>)>;\n+    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct CanonicalUserTypeAnnotation<'tcx> {\n+    pub user_ty: CanonicalUserType<'tcx>,\n+    pub span: Span,\n+    pub inferred_ty: Ty<'tcx>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for CanonicalUserTypeAnnotation<'tcx> {\n+        user_ty, span, inferred_ty\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for CanonicalUserTypeAnnotation<'a> {\n+        type Lifted = CanonicalUserTypeAnnotation<'tcx>;\n+        user_ty, span, inferred_ty\n+    }\n+}\n+\n \n /// Canonicalized user type annotation.\n-pub type CanonicalUserTypeAnnotation<'gcx> = Canonical<'gcx, UserTypeAnnotation<'gcx>>;\n+pub type CanonicalUserType<'gcx> = Canonical<'gcx, UserType<'gcx>>;\n \n-impl CanonicalUserTypeAnnotation<'gcx> {\n+impl CanonicalUserType<'gcx> {\n     /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n     /// i.e. each thing is mapped to a canonical variable with the same index.\n     pub fn is_identity(&self) -> bool {\n         match self.value {\n-            UserTypeAnnotation::Ty(_) => false,\n-            UserTypeAnnotation::TypeOf(_, user_substs) => {\n+            UserType::Ty(_) => false,\n+            UserType::TypeOf(_, user_substs) => {\n                 if user_substs.user_self_ty.is_some() {\n                     return false;\n                 }\n@@ -853,7 +874,7 @@ impl CanonicalUserTypeAnnotation<'gcx> {\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum UserTypeAnnotation<'tcx> {\n+pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n \n     /// The canonical type is the result of `type_of(def_id)` with the\n@@ -862,17 +883,17 @@ pub enum UserTypeAnnotation<'tcx> {\n }\n \n EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n+    impl<'tcx> TypeFoldable<'tcx> for UserType<'tcx> {\n+        (UserType::Ty)(ty),\n+        (UserType::TypeOf)(def, substs),\n     }\n }\n \n EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n-        type Lifted = UserTypeAnnotation<'tcx>;\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n+    impl<'a, 'tcx> Lift<'tcx> for UserType<'a> {\n+        type Lifted = UserType<'tcx>;\n+        (UserType::Ty)(ty),\n+        (UserType::TypeOf)(def, substs),\n     }\n }\n "}, {"sha": "930bbc0888517a0e78f9d72b20eaa88cc1817574", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -73,8 +73,8 @@ pub use self::binding::BindingMode::*;\n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n pub use self::context::{Lift, TypeckTables, CtxtInterners};\n pub use self::context::{\n-    UserTypeAnnotationIndex, UserTypeAnnotation, CanonicalUserTypeAnnotation,\n-    CanonicalUserTypeAnnotations,\n+    UserTypeAnnotationIndex, UserType, CanonicalUserType,\n+    CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n };\n \n pub use self::instance::{Instance, InstanceDef};"}, {"sha": "588f46cb77fe26f845e342178d8567d63911843b", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -7,7 +7,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n-use rustc::mir::{Statement, Terminator};\n+use rustc::mir::{SourceInfo, Statement, Terminator};\n use rustc::mir::UserTypeProjection;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n@@ -66,11 +66,12 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// call. Make them live at the location where they appear.\n     fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n         match ty_context {\n-            TyContext::ReturnTy(source_info)\n-            | TyContext::YieldTy(source_info)\n-            | TyContext::LocalDecl { source_info, .. } => {\n+            TyContext::ReturnTy(SourceInfo { span, .. })\n+            | TyContext::YieldTy(SourceInfo { span, .. })\n+            | TyContext::UserTy(span)\n+            | TyContext::LocalDecl { source_info: SourceInfo { span, .. }, .. } => {\n                 span_bug!(\n-                    source_info.span,\n+                    span,\n                     \"should not be visiting outside of the CFG: {:?}\",\n                     ty_context\n                 );"}, {"sha": "e6a974fd8cc94d92407d9eead619066d866305d9", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1,9 +1,5 @@\n-use rustc::infer::canonical::Canonical;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{\n-    self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable, UserTypeAnnotation,\n-    UserTypeAnnotationIndex,\n-};\n+use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n use rustc::mir::{Location, Mir};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n@@ -59,18 +55,6 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n-    fn visit_user_type_annotation(\n-        &mut self,\n-        _index: UserTypeAnnotationIndex,\n-        _ty: &mut Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n-    ) {\n-        // User type annotations represent the types that the user\n-        // wrote in the progarm. We don't want to erase the regions\n-        // from these types: rather, we want to add them as\n-        // constraints at type-check time.\n-        debug!(\"visit_user_type_annotation: skipping renumber\");\n-    }\n-\n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n         debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n "}, {"sha": "3e6aa358ee0d15d1d7491cd34f9bf2b1ff85225e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 108, "deletions": 114, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -35,10 +35,10 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind, UserSubsts};\n use rustc::ty::{\n-    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserTypeAnnotation,\n-    UserTypeAnnotationIndex,\n+    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserType,\n+    CanonicalUserTypeAnnotation, UserTypeAnnotationIndex,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -283,7 +283,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n-                let annotation = self.cx.instantiated_type_annotations[&annotation_index];\n+                let annotation = &self.mir.user_type_annotations[annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n@@ -293,6 +293,39 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     terr,\n                 );\n             }\n+        } else {\n+            match *constant.literal {\n+                ty::LazyConst::Unevaluated(def_id, substs) => {\n+                    if let Err(terr) = self.cx.fully_perform_op(\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                            constant.ty, def_id, UserSubsts { substs, user_self_ty: None },\n+                        )),\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            constant,\n+                            \"bad constant type {:?} ({:?})\",\n+                            constant,\n+                            terr\n+                        );\n+                    }\n+                }\n+                ty::LazyConst::Evaluated(lit) => {\n+                    if let ty::FnDef(def_id, substs) = lit.ty.sty {\n+                        let tcx = self.tcx();\n+\n+                        let instantiated_predicates = tcx\n+                            .predicates_of(def_id)\n+                            .instantiate(tcx, substs);\n+                        self.cx.normalize_and_prove_instantiated_predicates(\n+                            instantiated_predicates,\n+                            location.to_locations(),\n+                        );\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -374,8 +407,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Checks that the constant's `ty` field matches up with what\n-    /// would be expected from its literal.\n+    /// Checks that the constant's `ty` field matches up with what would be\n+    /// expected from its literal. Unevaluated constants and well-formed\n+    /// constraints are checked by `visit_constant`.\n     fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         debug!(\n             \"sanitize_constant(constant={:?}, location={:?})\",\n@@ -387,35 +421,6 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ty::LazyConst::Unevaluated(..) => return,\n         };\n \n-        // FIXME(#46702) -- We need some way to get the predicates\n-        // associated with the \"pre-evaluated\" form of the\n-        // constant. For example, consider that the constant\n-        // may have associated constant projections (`<Foo as\n-        // Trait<'a, 'b>>::SOME_CONST`) that impose\n-        // constraints on `'a` and `'b`. These constraints\n-        // would be lost if we just look at the normalized\n-        // value.\n-        if let ty::FnDef(def_id, substs) = literal.ty.sty {\n-            let tcx = self.tcx();\n-            let type_checker = &mut self.cx;\n-\n-            // FIXME -- For now, use the substitutions from\n-            // `value.ty` rather than `value.val`. The\n-            // renumberer will rewrite them to independent\n-            // sets of regions; in principle, we ought to\n-            // derive the type of the `value.val` from \"first\n-            // principles\" and equate with value.ty, but as we\n-            // are transitioning to the miri-based system, we\n-            // don't have a handy function for that, so for\n-            // now we just ignore `value.val` regions.\n-\n-            let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-            type_checker.normalize_and_prove_instantiated_predicates(\n-                instantiated_predicates,\n-                location.to_locations(),\n-            );\n-        }\n-\n         debug!(\"sanitize_constant: expected_ty={:?}\", literal.ty);\n \n         if let Err(terr) = self.cx.eq_types(\n@@ -740,15 +745,6 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n-    /// For each user-type annotation (identified by a UserTypeAnnotationIndex), we create\n-    /// an \"instantiated\" version at the beginning of type check, which replaces each\n-    /// canonical variable with a fresh inference variable. These instantiated versions are\n-    /// stored either in this field or in user_substs, depending on the kind of user-type\n-    /// annotation. They are then referenced by the code which has the job of enforcing these\n-    /// annotations. Part of the reason for this setup is that it allows us to enforce basic\n-    /// WF criteria on the types even if the code that referenced them is dead\n-    /// code (see #54943).\n-    instantiated_type_annotations: FxHashMap<UserTypeAnnotationIndex, UserTypeAnnotation<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -905,36 +901,69 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            instantiated_type_annotations: Default::default(),\n         };\n-        checker.instantiate_user_type_annotations();\n+        checker.check_user_type_annotations();\n         checker\n     }\n \n-    /// Instantiate canonical types from user type annotations in the `Mir` into the\n-    /// `TypeChecker`. Used when relating user type annotations and when checking if\n-    /// annotations are well-formed.\n-    fn instantiate_user_type_annotations(&mut self) {\n+    /// Equate the inferred type and the annotated type for user type annotations\n+    fn check_user_type_annotations(&mut self) {\n         debug!(\n-            \"instantiate_user_type_annotations: user_type_annotations={:?}\",\n+            \"check_user_type_annotations: user_type_annotations={:?}\",\n              self.mir.user_type_annotations\n         );\n-        for annotation_index in self.mir.user_type_annotations.indices() {\n-            let (span, canonical_annotation) = &self.mir.user_type_annotations[annotation_index];\n-            let (mut annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n-                *span, &canonical_annotation\n+        for user_annotation in &self.mir.user_type_annotations {\n+            let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n+            let (annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                span, user_ty\n             );\n             match annotation {\n-                UserTypeAnnotation::Ty(ref mut ty) =>\n-                    *ty = self.normalize(ty, Locations::All(*span)),\n-                _ => {},\n+                UserType::Ty(mut ty) => {\n+                    ty = self.normalize(ty, Locations::All(span));\n+\n+                    if let Err(terr) = self.eq_types(\n+                        ty,\n+                        inferred_ty,\n+                        Locations::All(span),\n+                        ConstraintCategory::BoringNoLocation,\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            user_annotation,\n+                            \"bad user type ({:?} = {:?}): {:?}\",\n+                            ty,\n+                            inferred_ty,\n+                            terr\n+                        );\n+                    }\n+\n+                    self.prove_predicate(\n+                        ty::Predicate::WellFormed(inferred_ty),\n+                        Locations::All(span),\n+                        ConstraintCategory::TypeAnnotation,\n+                    );\n+                },\n+                UserType::TypeOf(def_id, user_substs) => {\n+                    if let Err(terr) = self.fully_perform_op(\n+                        Locations::All(span),\n+                        ConstraintCategory::BoringNoLocation,\n+                        self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                            inferred_ty, def_id, user_substs,\n+                        )),\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            user_annotation,\n+                            \"bad user type AscribeUserType({:?}, {:?} {:?}): {:?}\",\n+                            inferred_ty,\n+                            def_id,\n+                            user_substs,\n+                            terr\n+                        );\n+                    }\n+                },\n             }\n-            self.instantiated_type_annotations.insert(annotation_index, annotation);\n         }\n-        debug!(\n-            \"instantiate_user_type_annotations: instantiated_type_annotations={:?}\",\n-            self.instantiated_type_annotations,\n-        );\n     }\n \n     /// Given some operation `op` that manipulates types, proves\n@@ -1066,58 +1095,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        let type_annotation = self.instantiated_type_annotations[&user_ty.base];\n-        match type_annotation {\n-            UserTypeAnnotation::Ty(ty) => {\n-                // The `TypeRelating` code assumes that \"unresolved inference\n-                // variables\" appear in the \"a\" side, so flip `Contravariant`\n-                // ambient variance to get the right relationship.\n-                let v1 = ty::Contravariant.xform(v);\n-                let tcx = self.infcx.tcx;\n+        let annotated_type = self.mir.user_type_annotations[user_ty.base].inferred_ty;\n+        let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n-                // We need to follow any provided projetions into the type.\n-                //\n-                // if we hit a ty var as we descend, then just skip the\n-                // attempt to relate the mir local with any type.\n-                #[derive(Debug)] struct HitTyVar;\n-                let mut curr_projected_ty: Result<PlaceTy, HitTyVar>;\n-\n-                curr_projected_ty = Ok(PlaceTy::from_ty(ty));\n-                for proj in &user_ty.projs {\n-                    let projected_ty = if let Ok(projected_ty) = curr_projected_ty {\n-                        projected_ty\n-                    } else {\n-                        break;\n-                    };\n-                    curr_projected_ty = projected_ty.projection_ty_core(\n-                        tcx, proj, |this, field, &()| {\n-                            if this.to_ty(tcx).is_ty_var() {\n-                                Err(HitTyVar)\n-                            } else {\n-                                let ty = this.field_ty(tcx, field);\n-                                Ok(self.normalize(ty, locations))\n-                            }\n-                        });\n-                }\n-                debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n-                       user_ty.base, ty, user_ty.projs, curr_projected_ty);\n+        let tcx = self.infcx.tcx;\n \n-                if let Ok(projected_ty) = curr_projected_ty {\n-                    let ty = projected_ty.to_ty(tcx);\n-                    self.relate_types(ty, v1, a, locations, category)?;\n-                }\n-            }\n-            UserTypeAnnotation::TypeOf(def_id, user_substs) => {\n-                let projs = self.infcx.tcx.intern_projs(&user_ty.projs);\n-                self.fully_perform_op(\n-                    locations,\n-                    category,\n-                    self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                        a, v, def_id, user_substs, projs,\n-                    )),\n-                )?;\n-            }\n+        for proj in &user_ty.projs {\n+            let projected_ty = curr_projected_ty.projection_ty_core(tcx, proj, |this, field, &()| {\n+                let ty = this.field_ty(tcx, field);\n+                self.normalize(ty, locations)\n+            });\n+            curr_projected_ty = projected_ty;\n         }\n+        debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n+                user_ty.base, annotated_type, user_ty.projs, curr_projected_ty);\n+\n+        let ty = curr_projected_ty.to_ty(tcx);\n+        self.relate_types(a, v, ty, locations, category)?;\n \n         Ok(())\n     }\n@@ -1286,7 +1280,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n-                        let annotation = self.instantiated_type_annotations[&annotation_index];\n+                        let annotation = &mir.user_type_annotations[annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n@@ -1345,7 +1339,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n-                    let annotation = self.instantiated_type_annotations[&projection.base];\n+                    let annotation = &mir.user_type_annotations[projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,"}, {"sha": "31e0c0daa3fa66ad0dc6f9a8a9413c41b0254314", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -3,6 +3,7 @@\n use build::Builder;\n use hair::*;\n use rustc::mir::*;\n+use rustc::ty::CanonicalUserTypeAnnotation;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n@@ -30,8 +31,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 value,\n             } => this.as_constant(value),\n             ExprKind::Literal { literal, user_ty } => {\n-                let user_ty = user_ty.map(|ty| {\n-                    this.canonical_user_type_annotations.push((span, ty))\n+                let user_ty = user_ty.map(|user_ty| {\n+                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+                        span,\n+                        user_ty,\n+                        inferred_ty: ty,\n+                    })\n                 });\n                 Constant {\n                     span,"}, {"sha": "6bd61ab53fd2182df6c75dfb0ebd0721a9b4d58b", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -6,7 +6,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::*;\n-use rustc::ty::Variance;\n+use rustc::ty::{CanonicalUserTypeAnnotation, Variance};\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -134,7 +134,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let place = unpack!(block = this.as_place(block, source));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n-                        (source_info.span, user_ty)\n+                        CanonicalUserTypeAnnotation {\n+                            span: source_info.span,\n+                            user_ty,\n+                            inferred_ty: expr.ty,\n+                        }\n                     );\n                     this.cfg.push(\n                         block,\n@@ -157,7 +161,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n-                        (source_info.span, user_ty)\n+                        CanonicalUserTypeAnnotation {\n+                            span: source_info.span,\n+                            user_ty,\n+                            inferred_ty: expr.ty,\n+                        }\n                     );\n                     this.cfg.push(\n                         block,"}, {"sha": "3de2f4757865044f9e020817130dd97493a4209b", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -9,7 +9,7 @@ use hair::*;\n use rustc::middle::region;\n use rustc::mir::interpret::EvalErrorKind;\n use rustc::mir::*;\n-use rustc::ty::{self, Ty, UpvarSubsts};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, UpvarSubsts};\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -331,8 +331,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .collect()\n                 };\n \n+                let inferred_ty = expr.ty;\n                 let user_ty = user_ty.map(|ty| {\n-                    this.canonical_user_type_annotations.push((expr_span, ty))\n+                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+                        span: source_info.span,\n+                        user_ty: ty,\n+                        inferred_ty,\n+                    })\n                 });\n                 let adt = box AggregateKind::Adt(\n                     adt_def,"}, {"sha": "2f1e8c03f2f7eefddb32199b0b551ac764eaa165", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -9,7 +9,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use hair::*;\n use rustc::mir::*;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n@@ -303,7 +303,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = box pat_ascription_ty.user_ty(\n-                    &mut self.canonical_user_type_annotations, ty_source_info.span\n+                    &mut self.canonical_user_type_annotations,\n+                    place.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                    ty_source_info.span,\n                 );\n                 self.cfg.push(\n                     block,\n@@ -570,10 +572,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 //\n                 // Note that the variance doesn't apply here, as we are tracking the effect\n                 // of `user_ty` on any bindings contained with subpattern.\n-                let annotation = (user_ty_span, user_ty.base);\n+                let annotation = CanonicalUserTypeAnnotation {\n+                    span: user_ty_span,\n+                    user_ty: user_ty.user_ty,\n+                    inferred_ty: subpattern.ty,\n+                };\n                 let projection = UserTypeProjection {\n                     base: self.canonical_user_type_annotations.push(annotation),\n-                    projs: user_ty.projs.clone(),\n+                    projs: Vec::new(),\n                 };\n                 let subpattern_user_ty = pattern_user_ty.push_projection(&projection, user_ty_span);\n                 self.visit_bindings(subpattern, subpattern_user_ty, f)\n@@ -1337,7 +1343,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             );\n \n             let user_ty = box ascription.user_ty.clone().user_ty(\n-                &mut self.canonical_user_type_annotations, source_info.span\n+                &mut self.canonical_user_type_annotations,\n+                ascription.source.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                source_info.span\n             );\n             self.cfg.push(\n                 block,"}, {"sha": "8d64c9e9ada89daa8ea5e71d444527f63d20d979", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -278,7 +278,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     let user_ty = user_provided_types.get(fun.hir_id)\n                         .map(|u_ty| *u_ty)\n                         .map(|mut u_ty| {\n-                            if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                            if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n                                 *did = adt_def.did;\n                             }\n                             u_ty\n@@ -797,7 +797,7 @@ fn user_substs_applied_to_def(\n     cx: &mut Cx<'a, 'gcx, 'tcx>,\n     hir_id: hir::HirId,\n     def: &Def,\n-) -> Option<ty::CanonicalUserTypeAnnotation<'tcx>> {\n+) -> Option<ty::CanonicalUserType<'tcx>> {\n     debug!(\"user_substs_applied_to_def: def={:?}\", def);\n     let user_provided_type = match def {\n         // A reference to something callable -- e.g., a fn, method, or"}, {"sha": "f0f8acb31df4208eaedcd6a0423f9f550e6ea879", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::Canonical;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Ty, Const, LazyConst, UserTypeAnnotation};\n+use rustc::ty::{AdtDef, UpvarSubsts, Ty, Const, LazyConst, UserType};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax::ast;\n@@ -265,20 +265,20 @@ pub enum ExprKind<'tcx> {\n \n         /// Optional user-given substs: for something like `let x =\n         /// Bar::<T> { ... }`.\n-        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n     PlaceTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     ValueTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n@@ -288,7 +288,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Literal {\n         literal: &'tcx LazyConst<'tcx>,\n-        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "06a50f35be1cf428280e52f5841dbf208a9d8646", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -12,10 +12,10 @@ use hair::util::UserAnnotatedTyHelpers;\n use hair::constant::*;\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::{ProjectionElem, UserTypeProjection};\n+use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift};\n-use rustc::ty::{CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, UserTypeAnnotation};\n+use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift, UserType};\n+use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -60,26 +60,29 @@ pub struct Pattern<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct PatternTypeProjection<'tcx> {\n-    pub base: CanonicalUserTypeAnnotation<'tcx>,\n-    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n+    pub user_ty: CanonicalUserType<'tcx>,\n }\n \n impl<'tcx> PatternTypeProjection<'tcx> {\n-    pub(crate) fn from_user_type(user_annotation: CanonicalUserTypeAnnotation<'tcx>) -> Self {\n+    pub(crate) fn from_user_type(user_annotation: CanonicalUserType<'tcx>) -> Self {\n         Self {\n-            base: user_annotation,\n-            projs: Vec::new(),\n+            user_ty: user_annotation,\n         }\n     }\n \n     pub(crate) fn user_ty(\n         self,\n         annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+        inferred_ty: Ty<'tcx>,\n         span: Span,\n     ) -> UserTypeProjection<'tcx> {\n         UserTypeProjection {\n-            base: annotations.push((span, self.base)),\n-            projs: self.projs\n+            base: annotations.push(CanonicalUserTypeAnnotation {\n+                span,\n+                user_ty: self.user_ty,\n+                inferred_ty,\n+            }),\n+            projs: Vec::new(),\n         }\n     }\n }\n@@ -1040,7 +1043,7 @@ macro_rules! CloneImpls {\n CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, ast::NodeId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n-    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, UserTypeAnnotation<'tcx>,\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, UserType<'tcx>,\n     UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>\n }\n "}, {"sha": "cb4a72387fa161bab7be4c6cb14e0929a2d50c8d", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir;\n-use rustc::ty::{self, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotation};\n+use rustc::ty::{self, CanonicalUserType, TyCtxt, UserType};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n@@ -12,13 +12,13 @@ crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     fn user_substs_applied_to_ty_of_hir_id(\n         &self,\n         hir_id: hir::HirId,\n-    ) -> Option<CanonicalUserTypeAnnotation<'tcx>> {\n+    ) -> Option<CanonicalUserType<'tcx>> {\n         let user_provided_types = self.tables().user_provided_types();\n         let mut user_ty = *user_provided_types.get(hir_id)?;\n         debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n         match &self.tables().node_id_to_type(hir_id).sty {\n             ty::Adt(adt_def, ..) => {\n-                if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut user_ty.value {\n+                if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {\n                     *did = adt_def.did;\n                 }\n                 Some(user_ty)"}, {"sha": "3a15356806a9767b13e6fdb4d1b2b211ffac547d", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -634,8 +634,8 @@ fn write_user_type_annotations(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n     if !mir.user_type_annotations.is_empty() {\n         writeln!(w, \"| User Type Annotations\")?;\n     }\n-    for (index, (span, annotation)) in mir.user_type_annotations.iter_enumerated() {\n-        writeln!(w, \"| {:?}: {:?} at {:?}\", index.index(), annotation, span)?;\n+    for (index, annotation) in mir.user_type_annotations.iter_enumerated() {\n+        writeln!(w, \"| {:?}: {:?} at {:?}\", index.index(), annotation.user_ty, annotation.span)?;\n     }\n     if !mir.user_type_annotations.is_empty() {\n         writeln!(w, \"|\")?;"}, {"sha": "526637e108d40bb861f1f90f19b3e330172e43eb", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -2,8 +2,6 @@ use rustc::infer::at::ToTrace;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::ProjectionKind;\n-use rustc::mir::tcx::PlaceTy;\n use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n use rustc::traits::query::type_op::normalize::Normalize;\n@@ -44,17 +42,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (\n-                param_env, AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n+                param_env, AscribeUserType { mir_ty, def_id, user_substs }\n             ) = key.into_parts();\n \n             debug!(\n-                \"type_op_ascribe_user_type: mir_ty={:?} variance={:?} def_id={:?} \\\n-                 user_substs={:?} projs={:?}\",\n-                mir_ty, variance, def_id, user_substs, projs\n+                \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n+                mir_ty, def_id, user_substs\n             );\n \n             let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n-            cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs, projs)?;\n+            cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n \n             Ok(())\n         })\n@@ -112,10 +109,8 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n     fn relate_mir_and_user_ty(\n         &mut self,\n         mir_ty: Ty<'tcx>,\n-        variance: Variance,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n-        projs: &[ProjectionKind<'tcx>],\n     ) -> Result<(), NoSolution> {\n         let UserSubsts {\n             user_self_ty,\n@@ -128,35 +123,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n         let ty = self.normalize(ty);\n \n-        // We need to follow any provided projetions into the type.\n-        //\n-        // if we hit a ty var as we descend, then just skip the\n-        // attempt to relate the mir local with any type.\n-\n-        struct HitTyVar;\n-        let mut curr_projected_ty: Result<PlaceTy, HitTyVar>;\n-        curr_projected_ty = Ok(PlaceTy::from_ty(ty));\n-        for proj in projs {\n-            let projected_ty = if let Ok(projected_ty) = curr_projected_ty {\n-                projected_ty\n-            } else {\n-                break;\n-            };\n-            curr_projected_ty = projected_ty.projection_ty_core(\n-                tcx, proj, |this, field, &()| {\n-                    if this.to_ty(tcx).is_ty_var() {\n-                        Err(HitTyVar)\n-                    } else {\n-                        let ty = this.field_ty(tcx, field);\n-                        Ok(self.normalize(ty))\n-                    }\n-                });\n-        }\n-\n-        if let Ok(projected_ty) = curr_projected_ty {\n-            let ty = projected_ty.to_ty(tcx);\n-            self.relate(mir_ty, variance, ty)?;\n-        }\n+        self.relate(mir_ty, Variance::Invariant, ty)?;\n \n         // Prove the predicates coming along with `def_id`.\n         //"}, {"sha": "240db801fb2f22c4ffd6d91ff6bd27e97263ed10", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -103,8 +103,8 @@ use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{\n-    self, AdtKind, CanonicalUserTypeAnnotation, Ty, TyCtxt, GenericParamDefKind, Visibility,\n-    ToPolyTraitRef, ToPredicate, RegionKind, UserTypeAnnotation\n+    self, AdtKind, CanonicalUserType, Ty, TyCtxt, GenericParamDefKind, Visibility,\n+    ToPolyTraitRef, ToPredicate, RegionKind, UserType\n };\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n@@ -985,7 +985,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                 };\n \n                 let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(\n-                    &UserTypeAnnotation::Ty(revealed_ty)\n+                    &UserType::Ty(revealed_ty)\n                 );\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                        ty.hir_id, o_ty, revealed_ty, c_ty);\n@@ -2194,7 +2194,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         user_self_ty: None, // not relevant here\n                     };\n \n-                    self.infcx.canonicalize_user_type_annotation(&UserTypeAnnotation::TypeOf(\n+                    self.infcx.canonicalize_user_type_annotation(&UserType::TypeOf(\n                         method.def_id,\n                         user_substs,\n                     ))\n@@ -2239,7 +2239,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if !substs.is_noop() {\n             let canonicalized = self.infcx.canonicalize_user_type_annotation(\n-                &UserTypeAnnotation::TypeOf(def_id, UserSubsts {\n+                &UserType::TypeOf(def_id, UserSubsts {\n                     substs,\n                     user_self_ty,\n                 })\n@@ -2252,7 +2252,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_user_type_annotation(\n         &self,\n         hir_id: hir::HirId,\n-        canonical_user_type_annotation: CanonicalUserTypeAnnotation<'tcx>,\n+        canonical_user_type_annotation: CanonicalUserType<'tcx>,\n     ) {\n         debug!(\n             \"write_user_type_annotation: hir_id={:?} canonical_user_type_annotation={:?} tag={}\",\n@@ -2437,10 +2437,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // types that involve projections, since those can resolve to\n         // `'static` bounds (modulo #54940, which hopefully will be\n         // fixed by the time you see this comment, dear reader,\n-        // although I have my doubts). Other sorts of things are\n-        // already sufficiently enforced with erased regions. =)\n-        if ty.has_free_regions() || ty.has_projections() {\n-            let c_ty = self.infcx.canonicalize_response(&UserTypeAnnotation::Ty(ty));\n+        // although I have my doubts). Also pass in types with inference\n+        // types, because they may be repeated. Other sorts of things\n+        // are already sufficiently enforced with erased regions. =)\n+        if ty.has_free_regions() || ty.has_projections() || ty.has_infer_types() {\n+            let c_ty = self.infcx.canonicalize_response(&UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.tables.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }"}, {"sha": "238b087fe32f86b3dc431672d4396aeaba2775cb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -404,7 +404,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 .user_provided_types_mut()\n                 .insert(hir_id, c_ty.clone());\n \n-            if let ty::UserTypeAnnotation::TypeOf(_, user_substs) = c_ty.value {\n+            if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                 if self.rustc_dump_user_substs {\n                     // This is a unit-testing mechanism.\n                     let node_id = self.tcx().hir().hir_to_node_id(hir_id);"}, {"sha": "1bbbe67a12cb8f990274ed7818be22877fba0f56", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -37,7 +37,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, UserTypeProjection { base: UserTypeAnnotation(1), projs: [] });\n+//        AscribeUserType(_4, o, UserTypeProjection { base: UserType(1), projs: [] });\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "bb794409ae01f635c02baa4cf814d749db2ba570", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -75,18 +75,18 @@ fn main() {\n //         _10 = move _8;\n //         Retag(_10);\n //         ...\n-//         _14 = &mut (*_10);\n-//         Retag(_14);\n-//         _13 = move _14 as *mut i32 (Misc);\n-//         Retag([raw] _13);\n+//         _15 = &mut (*_10);\n+//         Retag(_15);\n+//         _14 = move _15 as *mut i32 (Misc);\n+//         Retag([raw] _14);\n //         ...\n-//         _17 = move _18(move _19) -> bb2;\n+//         _18 = move _19(move _20) -> bb2;\n //     }\n //\n //     bb2: {\n-//         Retag(_17);\n+//         Retag(_18);\n //         ...\n-//         _21 = const Test::foo_shr(move _22, move _24) -> bb3;\n+//         _22 = const Test::foo_shr(move _23, move _25) -> bb3;\n //     }\n //\n //     bb3: {"}, {"sha": "ce4e010674359670526297c83d84bef3cf11d4d9", "filename": "src/test/ui/issue-54943.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fissue-54943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fissue-54943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1,7 +1,3 @@\n-// compile-pass\n-// FIXME(#54943) This test targets the scenario where proving the WF requirements of a user\n-// type annotation requires checking dead code. This test should actually fail to compile.\n-\n #![feature(nll)]\n #![allow(warnings)]\n \n@@ -11,7 +7,7 @@ fn boo<'a>() {\n     return;\n \n     let x = foo::<&'a u32>();\n-    //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n+    //~^ ERROR lifetime may not live long enough\n }\n \n fn main() {}"}, {"sha": "aa68177bcdb58dd5a268d92d21192e24f5620181", "filename": "src/test/ui/issue-54943.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fissue-54943.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fissue-54943.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-54943.rs:9:13\n+   |\n+LL | fn boo<'a>() {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |     let x = foo::<&'a u32>();\n+   |             ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "77c50e53868e1aef033cd87d992cc86a96cc9535", "filename": "src/test/ui/issues/issue-57866.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fissues%2Fissue-57866.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fissues%2Fissue-57866.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57866.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,26 @@\n+// compile-pass\n+\n+#![feature(type_alias_enum_variants)]\n+\n+enum Outer<T> {\n+    A(T)\n+}\n+\n+enum Inner {\n+    A(i32)\n+}\n+\n+type OuterAlias = Outer<Inner>;\n+\n+fn ice(x: OuterAlias) {\n+    // Fine\n+    match x {\n+        OuterAlias::A(Inner::A(_)) => (),\n+    }\n+    // Not fine\n+    match x {\n+        OuterAlias::A(Inner::A(y)) => (),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "597b096dbe60747e62822051882d8ce97c7deaa1", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -2,7 +2,7 @@ error[E0309]: the associated type `<T as MyTrait<'_>>::Output` may not live long\n   --> $DIR/projection-where-clause-env-wrong-bound.rs:17:5\n    |\n LL |     bar::<T::Output>() //~ ERROR may not live long enough\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as MyTrait<'_>>::Output: 'a`...\n "}, {"sha": "3c2ac474778f9463f3c111527743b7d233287a37", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-none.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -2,7 +2,7 @@ error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-where-clause-none.rs:16:5\n    |\n LL |     bar::<T::Output>() //~ ERROR the parameter type `T` may not live long enough\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n "}, {"sha": "a2e3ab41614f699c1355a2c29fb9797e46098f57", "filename": "src/test/ui/nll/ty-outlives/wf-unreachable.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,54 @@\n+// Test that we check that user type annotations are well-formed, even in dead\n+// code.\n+\n+#![feature(nll)]\n+\n+fn uninit<'a>() {\n+    return;\n+    let x: &'static &'a ();                         //~ ERROR lifetime may not live long enough\n+}\n+\n+fn var_type<'a>() {\n+    return;\n+    let x: &'static &'a () = &&();                  //~ ERROR lifetime may not live long enough\n+}\n+\n+fn uninit_infer<'a>() {\n+    let x: &'static &'a _;                          //~ ERROR lifetime may not live long enough\n+    x = && ();\n+}\n+\n+fn infer<'a>() {\n+    return;\n+    let x: &'static &'a _ = &&();                   //~ ERROR lifetime may not live long enough\n+}\n+\n+fn uninit_no_var<'a>() {\n+    return;\n+    let _: &'static &'a ();                         //~ ERROR lifetime may not live long enough\n+}\n+\n+fn no_var<'a>() {\n+    return;\n+    let _: &'static &'a () = &&();                  //~ ERROR lifetime may not live long enough\n+}\n+\n+fn infer_no_var<'a>() {\n+    return;\n+    let _: &'static &'a _ = &&();                   //~ ERROR lifetime may not live long enough\n+}\n+\n+trait X<'a, 'b> {}\n+\n+struct C<'a, 'b, T: X<'a, 'b>>(T, &'a (), &'b ());\n+\n+impl X<'_, '_> for i32 {}\n+impl<'a> X<'a, 'a> for () {}\n+\n+// This type annotation is not well-formed because we substitute `()` for `_`.\n+fn required_substs<'a>() {\n+    return;\n+    let _: C<'static, 'a, _> = C((), &(), &());     //~ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "14642a1e615df8c89bcd5cd0a5ce0e90e5a13a2b", "filename": "src/test/ui/nll/ty-outlives/wf-unreachable.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,73 @@\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:8:12\n+   |\n+LL | fn uninit<'a>() {\n+   |           -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let x: &'static &'a ();                         //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:13:12\n+   |\n+LL | fn var_type<'a>() {\n+   |             -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let x: &'static &'a () = &&();                  //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:17:12\n+   |\n+LL | fn uninit_infer<'a>() {\n+   |                 -- lifetime `'a` defined here\n+LL |     let x: &'static &'a _;                          //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:23:12\n+   |\n+LL | fn infer<'a>() {\n+   |          -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let x: &'static &'a _ = &&();                   //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:28:12\n+   |\n+LL | fn uninit_no_var<'a>() {\n+   |                  -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let _: &'static &'a ();                         //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:33:12\n+   |\n+LL | fn no_var<'a>() {\n+   |           -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let _: &'static &'a () = &&();                  //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:38:12\n+   |\n+LL | fn infer_no_var<'a>() {\n+   |                 -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let _: &'static &'a _ = &&();                   //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/wf-unreachable.rs:51:12\n+   |\n+LL | fn required_substs<'a>() {\n+   |                    -- lifetime `'a` defined here\n+LL |     return;\n+LL |     let _: C<'static, 'a, _> = C((), &(), &());     //~ ERROR lifetime may not live long enough\n+   |            ^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "123be6b3e4098dc7911844576054e45b48db3f1f", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,29 @@\n+// Test that we still check constants are well-formed, even when we there's no\n+// type annotation to check.\n+\n+#![feature(nll)]\n+\n+const FUN: fn(&'static ()) = |_| {};\n+struct A;\n+impl A {\n+    const ASSOCIATED_FUN: fn(&'static ()) = |_| {};\n+}\n+\n+struct B<'a>(&'a ());\n+impl B<'static> {\n+    const ALSO_ASSOCIATED_FUN: fn(&'static ()) = |_| {};\n+}\n+\n+trait Z: 'static {\n+    const TRAIT_ASSOCIATED_FUN: fn(&'static Self) = |_| ();\n+}\n+\n+impl Z for () {}\n+\n+fn main() {\n+    let x = ();\n+    FUN(&x);                        //~ ERROR `x` does not live long enough\n+    A::ASSOCIATED_FUN(&x);          //~ ERROR `x` does not live long enough\n+    B::ALSO_ASSOCIATED_FUN(&x);     //~ ERROR `x` does not live long enough\n+    <_>::TRAIT_ASSOCIATED_FUN(&x);  //~ ERROR `x` does not live long enough\n+}"}, {"sha": "57cfaa2db043219a19b50e81d12fc6a3f7631228", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-2.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-2.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,50 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:25:9\n+   |\n+LL |     FUN(&x);                        //~ ERROR `x` does not live long enough\n+   |     ----^^-\n+   |     |   |\n+   |     |   borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:26:23\n+   |\n+LL |     A::ASSOCIATED_FUN(&x);          //~ ERROR `x` does not live long enough\n+   |     ------------------^^-\n+   |     |                 |\n+   |     |                 borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:27:28\n+   |\n+LL |     B::ALSO_ASSOCIATED_FUN(&x);     //~ ERROR `x` does not live long enough\n+   |     -----------------------^^-\n+   |     |                      |\n+   |     |                      borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+LL |     <_>::TRAIT_ASSOCIATED_FUN(&x);  //~ ERROR `x` does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/constant-in-expr-inherent-2.rs:28:31\n+   |\n+LL |     <_>::TRAIT_ASSOCIATED_FUN(&x);  //~ ERROR `x` does not live long enough\n+   |     --------------------------^^-\n+   |     |                         |\n+   |     |                         borrowed value does not live long enough\n+   |     argument requires that `x` is borrowed for `'static`\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "23b76bb196470984af9a50c1ce09bca138fd3f94", "filename": "src/test/ui/nll/user-annotations/downcast-infer.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdowncast-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdowncast-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdowncast-infer.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,11 @@\n+// compile-pass\n+\n+// Check that we don't try to downcast `_` when type-checking the annotation.\n+fn main() {\n+    let x = Some(Some(Some(1)));\n+\n+    match x {\n+        Some::<Option<_>>(Some(Some(v))) => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "f4969bb4067c79218e80a2d7000018da69915c81", "filename": "src/test/ui/nll/user-annotations/issue-57731-ascibed-coupled-types.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-57731-ascibed-coupled-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-57731-ascibed-coupled-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-57731-ascibed-coupled-types.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,40 @@\n+// Check that repeated type variables are correctly handled\n+\n+#![allow(unused)]\n+#![feature(nll, type_ascription)]\n+\n+type PairUncoupled<'a, 'b, T> = (&'a T, &'b T);\n+type PairCoupledTypes<T> = (T, T);\n+type PairCoupledRegions<'a, T> = (&'a T, &'a T);\n+\n+fn uncoupled_wilds_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),) = ((s, _x),): (PairUncoupled<_>,);\n+    y // OK\n+}\n+\n+fn coupled_wilds_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),) = ((s, _x),): (PairCoupledTypes<_>,);\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn coupled_regions_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),) = ((s, _x),): (PairCoupledRegions<_>,);\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn cast_uncoupled_wilds_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),) = ((s, _x),) as (PairUncoupled<_>,);\n+    y // OK\n+}\n+\n+fn cast_coupled_wilds_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),) = ((s, _x),) as (PairCoupledTypes<_>,);\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn cast_coupled_regions_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),) = ((s, _x),) as (PairCoupledRegions<_>,);\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "76be637220a1505b259356180441471ec4bce6d2", "filename": "src/test/ui/nll/user-annotations/issue-57731-ascibed-coupled-types.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-57731-ascibed-coupled-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-57731-ascibed-coupled-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-57731-ascibed-coupled-types.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,38 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-57731-ascibed-coupled-types.rs:17:5\n+   |\n+LL | fn coupled_wilds_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                      -- lifetime `'a` defined here\n+LL |     let ((y, _z),) = ((s, _x),): (PairCoupledTypes<_>,);\n+LL |     y //~ ERROR lifetime may not live long enough\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-57731-ascibed-coupled-types.rs:22:5\n+   |\n+LL | fn coupled_regions_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                        -- lifetime `'a` defined here\n+LL |     let ((y, _z),) = ((s, _x),): (PairCoupledRegions<_>,);\n+LL |     y //~ ERROR lifetime may not live long enough\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-57731-ascibed-coupled-types.rs:32:5\n+   |\n+LL | fn cast_coupled_wilds_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                           -- lifetime `'a` defined here\n+LL |     let ((y, _z),) = ((s, _x),) as (PairCoupledTypes<_>,);\n+LL |     y //~ ERROR lifetime may not live long enough\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-57731-ascibed-coupled-types.rs:37:5\n+   |\n+LL | fn cast_coupled_regions_rhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                             -- lifetime `'a` defined here\n+LL |     let ((y, _z),) = ((s, _x),) as (PairCoupledRegions<_>,);\n+LL |     y //~ ERROR lifetime may not live long enough\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "76ead4e94ef667e7c8f32bf345ac74846edf582d", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.ast.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.ast.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,20 @@\n+error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:45:13\n+   |\n+LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 37:15\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:37:15\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |               ^^\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 37:18\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:37:18\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |                  ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0491`."}, {"sha": "ad94d375b5bb75ce8260f21204961d2cb0d16595", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.mir.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.mir.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,13 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:45:13\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |               -- -- lifetime `'b` defined here\n+   |               |\n+   |               lifetime `'a` defined here\n+...\n+LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d5349219923063f67d9a6584754cceed4ad00a1", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -3,6 +3,9 @@\n // outlive the location in which the type appears, even when the\n // associted type is in a supertype. Issue #22246.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![allow(dead_code)]\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -40,7 +43,8 @@ fn with_assoc<'a,'b>() {\n     // FIXME (#54943) NLL doesn't enforce WF condition in unreachable code if\n     // `_x` is changed to `_`\n     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n-    //~^ ERROR reference has a longer lifetime\n+    //[ast]~^ ERROR reference has a longer lifetime\n+    //[mir]~^^ ERROR lifetime may not live long enough\n }\n \n fn main() {"}, {"sha": "73266ab50fad039344d6976b50920eba8f0fb3a0", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.ast.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.ast.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,32 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/regions-free-region-ordering-caller.rs:11:12\n+   |\n+LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |                     ---------     ---------\n+   |                     |\n+   |                     these two types are declared with different lifetimes...\n+LL |     let z: Option<&'b &'a usize> = None;//[ast]~ ERROR E0623\n+   |            ^^^^^^^^^^^^^^^^^^^^^ ...but data from `a` flows into `b` here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/regions-free-region-ordering-caller.rs:17:12\n+   |\n+LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |                     ---------     ---------\n+   |                     |\n+   |                     these two types are declared with different lifetimes...\n+LL |     let y: Paramd<'a> = Paramd { x: a };\n+LL |     let z: Option<&'b Paramd<'a>> = None;//[ast]~ ERROR E0623\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ ...but data from `a` flows into `b` here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n+   |\n+LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |                     ---------     --------- these two types are declared with different lifetimes...\n+LL |     let z: Option<&'a &'b usize> = None;//[ast]~ ERROR E0623\n+   |            ^^^^^^^^^^^^^^^^^^^^^ ...but data from `b` flows into `a` here\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0623`."}, {"sha": "abec468c9ea3e185cc09b64212458949b2d79ccf", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.mir.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.mir.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,33 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regions-free-region-ordering-caller.rs:11:12\n+   |\n+LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |          --  -- lifetime `'b` defined here\n+   |          |\n+   |          lifetime `'a` defined here\n+LL |     let z: Option<&'b &'a usize> = None;//[ast]~ ERROR E0623\n+   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/regions-free-region-ordering-caller.rs:17:12\n+   |\n+LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |          --  -- lifetime `'b` defined here\n+   |          |\n+   |          lifetime `'a` defined here\n+LL |     let y: Paramd<'a> = Paramd { x: a };\n+LL |     let z: Option<&'b Paramd<'a>> = None;//[ast]~ ERROR E0623\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n+   |\n+LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n+   |          --  -- lifetime `'b` defined here\n+   |          |\n+   |          lifetime `'a` defined here\n+LL |     let z: Option<&'a &'b usize> = None;//[ast]~ ERROR E0623\n+   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "621e6e78b4650861e757420fcffa91f498075a9b", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -2,19 +2,25 @@\n // than the thing it points at and ensure that they result in\n // errors. See also regions-free-region-ordering-callee.rs\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n struct Paramd<'a> { x: &'a usize }\n \n fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n-    let z: Option<&'b &'a usize> = None;//~ ERROR E0623\n+    let z: Option<&'b &'a usize> = None;//[ast]~ ERROR E0623\n+    //[mir]~^ ERROR lifetime may not live long enough\n }\n \n fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n     let y: Paramd<'a> = Paramd { x: a };\n-    let z: Option<&'b Paramd<'a>> = None;//~ ERROR E0623\n+    let z: Option<&'b Paramd<'a>> = None;//[ast]~ ERROR E0623\n+    //[mir]~^ ERROR lifetime may not live long enough\n }\n \n fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n-    let z: Option<&'a &'b usize> = None;//~ ERROR E0623\n+    let z: Option<&'a &'b usize> = None;//[ast]~ ERROR E0623\n+    //[mir]~^ ERROR lifetime may not live long enough\n }\n \n fn main() {}"}, {"sha": "539343a68294f35415ce28a8e18a50f3bc8c63d4", "filename": "src/test/ui/regions/regions-free-region-ordering-caller1.nll.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -12,6 +12,21 @@ LL |     let z: &'a & usize = &(&y);\n LL | }\n    | - temporary value is freed at the end of this statement\n \n-error: aborting due to previous error\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/regions-free-region-ordering-caller1.rs:9:27\n+   |\n+LL | fn call1<'a>(x: &'a usize) {\n+   |          -- lifetime `'a` defined here\n+...\n+LL |     let z: &'a & usize = &(&y);\n+   |            -----------    ^^^^ borrowed value does not live long enough\n+   |            |\n+   |            type annotation requires that `y` is borrowed for `'a`\n+...\n+LL | }\n+   | - `y` dropped here while still borrowed\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0716`.\n+Some errors occurred: E0597, E0716.\n+For more information about an error, try `rustc --explain E0597`."}, {"sha": "d83301840088d509b067d7513d0748cd1a9de902", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.ast.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.ast.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,37 @@\n+error[E0491]: in type `&'a WithHrAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+   |\n+LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 32:15\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:15\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |               ^^\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 32:18\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:18\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |                  ^^\n+\n+error[E0491]: in type `&'a WithHrAssocSub<TheType<'b>>`, reference has a longer lifetime than the data it references\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+   |\n+LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 53:19\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:53:19\n+   |\n+LL | fn with_assoc_sub<'a,'b>() {\n+   |                   ^^\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 53:22\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:53:22\n+   |\n+LL | fn with_assoc_sub<'a,'b>() {\n+   |                      ^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0491`."}, {"sha": "5028663ba6d04f6de8c2815ec513fad25fd1f9a1", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.mir.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.mir.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,24 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |               -- -- lifetime `'b` defined here\n+   |               |\n+   |               lifetime `'a` defined here\n+...\n+LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+   |\n+LL | fn with_assoc_sub<'a,'b>() {\n+   |                   -- -- lifetime `'b` defined here\n+   |                   |\n+   |                   lifetime `'a` defined here\n+...\n+LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2871d962c42c9d13cd215a945f7f2ca7e461e316", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -1,6 +1,9 @@\n // Test that structs with higher-ranked where clauses don't generate\n // \"outlives\" requirements. Issue #22246.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![allow(dead_code)]\n \n \n@@ -30,7 +33,8 @@ fn with_assoc<'a,'b>() {\n     // We get an error because 'b:'a does not hold:\n \n     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n-    //~^ ERROR reference has a longer lifetime\n+    //[ast]~^ ERROR reference has a longer lifetime\n+    //[mir]~^^ ERROR lifetime may not live long enough\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -51,7 +55,8 @@ fn with_assoc_sub<'a,'b>() {\n     // below to be well-formed, it is not related to the HR relation.\n \n     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n-    //~^ ERROR reference has a longer lifetime\n+    //[ast]~^ ERROR reference has a longer lifetime\n+    //[mir]~^^ ERROR lifetime may not live long enough\n }\n \n "}, {"sha": "9e31065ca4eec52842b24537adc67c9be3ac8ed7", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.ast.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.ast.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,20 @@\n+error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n+  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+   |\n+LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 31:15\n+  --> $DIR/regions-outlives-projection-container-wc.rs:31:15\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |               ^^\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 31:18\n+  --> $DIR/regions-outlives-projection-container-wc.rs:31:18\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |                  ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0491`."}, {"sha": "880fe17b740e4b508c68f9e508c2eace409e38d1", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.mir.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.mir.stderr?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -0,0 +1,13 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+   |\n+LL | fn with_assoc<'a,'b>() {\n+   |               -- -- lifetime `'b` defined here\n+   |               |\n+   |               lifetime `'a` defined here\n+...\n+LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "37622211327c0ab515d430934b047edd8290f5d1", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1669d96cee9dec9035a50fdf0a967a68605f98/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs?ref=0b1669d96cee9dec9035a50fdf0a967a68605f98", "patch": "@@ -3,6 +3,9 @@\n // outlive the location in which the type appears, even when the\n // constraint is in a where clause not a bound. Issue #22246.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![allow(dead_code)]\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -32,7 +35,8 @@ fn with_assoc<'a,'b>() {\n     // which is &'b (), must outlive 'a.\n \n     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-    //~^ ERROR reference has a longer lifetime\n+    //[ast]~^ ERROR reference has a longer lifetime\n+    //[mir]~^^ ERROR lifetime may not live long enough\n }\n \n fn main() {"}]}