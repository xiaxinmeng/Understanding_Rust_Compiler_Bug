{"sha": "0661b0a36d483dfb7041a3526b07eeec2b67b2d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NjFiMGEzNmQ0ODNkZmI3MDQxYTM1MjZiMDdlZWVjMmI2N2IyZDA=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-09-19T14:47:03Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-09-19T17:02:42Z"}, "message": "BTreeMap: wrap node's raw parent pointer in NonNull", "tree": {"sha": "58244153c87ad7cbf807a361d3c29275bc0e6b85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58244153c87ad7cbf807a361d3c29275bc0e6b85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0661b0a36d483dfb7041a3526b07eeec2b67b2d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0661b0a36d483dfb7041a3526b07eeec2b67b2d0", "html_url": "https://github.com/rust-lang/rust/commit/0661b0a36d483dfb7041a3526b07eeec2b67b2d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0661b0a36d483dfb7041a3526b07eeec2b67b2d0/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0925fba747b4cf910592540aa1f817778dc315c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0925fba747b4cf910592540aa1f817778dc315c", "html_url": "https://github.com/rust-lang/rust/commit/a0925fba747b4cf910592540aa1f817778dc315c"}], "stats": {"total": 42, "additions": 22, "deletions": 20}, "files": [{"sha": "ae42701b36a530449c4b873a321b83361a611277", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0661b0a36d483dfb7041a3526b07eeec2b67b2d0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0661b0a36d483dfb7041a3526b07eeec2b67b2d0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=0661b0a36d483dfb7041a3526b07eeec2b67b2d0", "patch": "@@ -12,7 +12,7 @@\n //     edges: if height > 0 {\n //         [Box<Node<K, V, height - 1>>; 2 * B]\n //     } else { () },\n-//     parent: *const Node<K, V, height + 1>,\n+//     parent: Option<NonNull<Node<K, V, height + 1>>>,\n //     parent_idx: u16,\n //     len: u16,\n // }\n@@ -50,9 +50,8 @@ const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n /// The underlying representation of leaf nodes.\n #[repr(C)]\n struct LeafNode<K, V> {\n-    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n-    /// This either points to an actual node or is null.\n-    parent: *const InternalNode<K, V>,\n+    /// We want to be covariant in `K` and `V`.\n+    parent: Option<NonNull<InternalNode<K, V>>>,\n \n     /// This node's index into the parent node's `edges` array.\n     /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n@@ -80,7 +79,7 @@ impl<K, V> LeafNode<K, V> {\n             // be both slightly faster and easier to track in Valgrind.\n             keys: MaybeUninit::uninit_array(),\n             vals: MaybeUninit::uninit_array(),\n-            parent: ptr::null(),\n+            parent: None,\n             parent_idx: MaybeUninit::uninit(),\n             len: 0,\n         }\n@@ -224,7 +223,7 @@ impl<K, V> Root<K, V> {\n             )\n         };\n         self.height -= 1;\n-        self.node_as_mut().as_leaf_mut().parent = ptr::null();\n+        self.node_as_mut().as_leaf_mut().parent = None;\n \n         unsafe {\n             Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n@@ -309,7 +308,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn len(&self) -> usize {\n         // Crucially, we only access the `len` field here. If BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n-        unsafe { (*self.as_leaf_ptr()).len as usize }\n+        unsafe { usize::from((*self.as_leaf_ptr()).len) }\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -365,16 +364,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n         // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n-        let parent_as_leaf = unsafe { (*self.as_leaf_ptr()).parent as *const LeafNode<K, V> };\n-        if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n-            Ok(Handle {\n-                node: NodeRef { height: self.height + 1, node: non_zero, _marker: PhantomData },\n-                idx: unsafe { usize::from(*(*self.as_leaf_ptr()).parent_idx.as_ptr()) },\n+        let leaf_ptr = self.as_leaf_ptr();\n+        unsafe { (*leaf_ptr).parent }\n+            .as_ref()\n+            .map(|parent| Handle {\n+                node: NodeRef {\n+                    height: self.height + 1,\n+                    node: parent.cast(),\n+                    _marker: PhantomData,\n+                },\n+                idx: unsafe { usize::from((*leaf_ptr).parent_idx.assume_init()) },\n                 _marker: PhantomData,\n             })\n-        } else {\n-            Err(self)\n-        }\n+            .ok_or(self)\n     }\n \n     pub fn first_edge(self) -> Handle<Self, marker::Edge> {\n@@ -572,7 +574,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         let len = &mut self.as_leaf_mut().len;\n-        let idx = *len as usize;\n+        let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n@@ -617,7 +619,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(edge.height == self.height - 1);\n \n         let len = &mut self.as_leaf_mut().len;\n-        let idx = *len as usize;\n+        let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n@@ -672,7 +674,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     let edge =\n                         ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.node_as_mut().as_leaf_mut().parent = ptr::null();\n+                    new_root.node_as_mut().as_leaf_mut().parent = None;\n                     Some(new_root)\n                 }\n             };\n@@ -704,7 +706,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.node_as_mut().as_leaf_mut().parent = ptr::null();\n+                    new_root.node_as_mut().as_leaf_mut().parent = None;\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -956,7 +958,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     /// when the ordering of edges has been changed, such as in the various `insert` methods.\n     fn correct_parent_link(mut self) {\n         let idx = self.idx as u16;\n-        let ptr = self.node.as_internal_mut() as *mut _;\n+        let ptr = NonNull::new(self.node.as_internal_mut());\n         let mut child = self.descend();\n         child.as_leaf_mut().parent = ptr;\n         child.as_leaf_mut().parent_idx.write(idx);"}]}