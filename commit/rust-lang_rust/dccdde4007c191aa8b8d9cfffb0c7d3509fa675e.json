{"sha": "dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjY2RkZTQwMDdjMTkxYWE4YjhkOWNmZmZiMGM3ZDM1MDlmYTY3NWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-24T09:33:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-24T09:33:17Z"}, "message": "Auto merge of #22755 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "f4493e88a229c9622daf5389616001fd48d337c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4493e88a229c9622daf5389616001fd48d337c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "html_url": "https://github.com/rust-lang/rust/commit/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef56da541a90c62801440702a3e3c009e5332be", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef56da541a90c62801440702a3e3c009e5332be", "html_url": "https://github.com/rust-lang/rust/commit/0ef56da541a90c62801440702a3e3c009e5332be"}, {"sha": "b182cd7245a999ac702f88c89dcc28811d6fdf8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b182cd7245a999ac702f88c89dcc28811d6fdf8a", "html_url": "https://github.com/rust-lang/rust/commit/b182cd7245a999ac702f88c89dcc28811d6fdf8a"}], "stats": {"total": 2349, "additions": 1401, "deletions": 948}, "files": [{"sha": "31524579df7c0c1fef4a509e0e909aa819eb4ef1", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -2165,7 +2165,7 @@ fn needs_foo_or_bar() {\n \n // This function is only included when compiling for a unixish OS with a 32-bit\n // architecture\n-#[cfg(all(unix, target_word_size = \"32\"))]\n+#[cfg(all(unix, target_pointer_width = \"32\"))]\n fn on_32bit_unix() {\n   // ...\n }\n@@ -2193,9 +2193,9 @@ The following configurations must be defined by the implementation:\n * `target_os = \"...\"`. Operating system of the target, examples include\n   `\"win32\"`, `\"macos\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"`, `\"dragonfly\"`,\n   `\"bitrig\"` or `\"openbsd\"`.\n-* `target_word_size = \"...\"`. Target word size in bits. This is set to `\"32\"`\n-  for targets with 32-bit pointers, and likewise set to `\"64\"` for 64-bit\n-  pointers.\n+* `target_pointer_width = \"...\"`. Target pointer width in bits. This is set\n+  to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n+  64-bit pointers.\n * `unix`. See `target_family`.\n * `windows`. See `target_family`.\n "}, {"sha": "cd158283180a268381a35370837bd968f7753ed8", "filename": "src/doc/rust.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -56,6 +56,7 @@\n /* General structure */\n \n body {\n+    background-color: white;\n     margin: 0 auto;\n     padding: 0 15px;\n     font-family: \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;"}, {"sha": "0f46b4da0d6f971b6ae3371d4850a5b8774493f0", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -361,16 +361,16 @@ duration a *lifetime*. Let's try a more complex example:\n \n ```{rust}\n fn main() {\n-    let x = &mut 5;\n+    let mut x = 5;\n \n-    if *x < 10 {\n+    if x < 10 {\n         let y = &x;\n \n         println!(\"Oh no: {}\", y);\n         return;\n     }\n \n-    *x -= 1;\n+    x -= 1;\n \n     println!(\"Oh no: {}\", x);\n }\n@@ -382,17 +382,18 @@ mutated, and therefore, lets us pass. This wouldn't work:\n \n ```{rust,ignore}\n fn main() {\n-    let x = &mut 5;\n+    let mut x = 5;\n \n-    if *x < 10 {\n+    if x < 10 {\n         let y = &x;\n-        *x -= 1;\n+\n+        x -= 1;\n \n         println!(\"Oh no: {}\", y);\n         return;\n     }\n \n-    *x -= 1;\n+    x -= 1;\n \n     println!(\"Oh no: {}\", x);\n }\n@@ -401,12 +402,12 @@ fn main() {\n It gives this error:\n \n ```text\n-test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n-test.rs:5         *x -= 1;\n-                  ^~\n-test.rs:4:16: 4:18 note: borrow of `*x` occurs here\n-test.rs:4         let y = &x;\n-                          ^~\n+test.rs:7:9: 7:15 error: cannot assign to `x` because it is borrowed\n+test.rs:7         x -= 1;\n+                  ^~~~~~\n+test.rs:5:18: 5:19 note: borrow of `x` occurs here\n+test.rs:5         let y = &x;\n+                           ^\n ```\n \n As you might guess, this kind of analysis is complex for a human, and therefore"}, {"sha": "fc1ab9bf9e8dca6278f004d521ed8382050866eb", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -93,8 +93,8 @@ dynamic dispatch is sometimes more efficient.\n \n However, the common case is that it is more efficient to use static dispatch,\n and one can always have a thin statically-dispatched wrapper function that does\n-a dynamic, but not vice versa, meaning static calls are more flexible. The\n-standard library tries to be statically dispatched where possible for this\n+a dynamic dispatch, but not vice versa, meaning static calls are more flexible.\n+The standard library tries to be statically dispatched where possible for this\n reason. \n \n ## Dynamic dispatch"}, {"sha": "f3c44a84ee50ac5f0fc7c210383bfa7d84e22c02", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -132,7 +132,7 @@ impl<T> ToOwned for T where T: Clone {\n /// ```rust\n /// use std::borrow::Cow;\n ///\n-/// fn abs_all(input: &mut Cow<[int]>) {\n+/// fn abs_all(input: &mut Cow<[i32]>) {\n ///     for i in 0..input.len() {\n ///         let v = input[i];\n ///         if v < 0 {"}, {"sha": "98673af3c68a84ab3b6e7b3a9cea8094ec8d2796", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -404,7 +404,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core::fmt::{Formatter, Result, Write, rt};\n-pub use core::fmt::{Show, String, Octal, Binary};\n+pub use core::fmt::{Octal, Binary};\n pub use core::fmt::{Display, Debug};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};"}, {"sha": "f92e631c1f25c4becc028f0056484346b26fa603", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -40,10 +40,10 @@ pub enum ExponentFormat {\n pub enum SignificantDigits {\n     /// At most the given number of digits will be printed, truncating any\n     /// trailing zeroes.\n-    DigMax(uint),\n+    DigMax(usize),\n \n     /// Precisely the given number of digits will be printed.\n-    DigExact(uint)\n+    DigExact(usize)\n }\n \n /// How to emit the sign of a number.\n@@ -240,27 +240,27 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == b'-'\n-                    || buf[i as uint] == b'+' {\n-                        for j in (i as uint + 1..end).rev() {\n+                    || buf[i as usize] == b'-'\n+                    || buf[i as usize] == b'+' {\n+                        for j in (i as usize + 1..end).rev() {\n                             buf[j + 1] = buf[j];\n                         }\n-                        buf[(i + 1) as uint] = value2ascii(1);\n+                        buf[(i + 1) as usize] = value2ascii(1);\n                         end += 1;\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == b'.' { i -= 1; continue; }\n+                    if buf[i as usize] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(buf[i as usize]);\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        buf[i as usize] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        buf[i as usize] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -311,7 +311,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             struct Filler<'a> {\n                 buf: &'a mut [u8],\n-                end: &'a mut uint,\n+                end: &'a mut usize,\n             }\n \n             impl<'a> fmt::Write for Filler<'a> {"}, {"sha": "0bf44dd77aaa199a939a505974232b581f54aee6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 38, "deletions": 55, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -110,11 +110,14 @@ pub trait Write {\n /// traits.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {\n-    flags: uint,\n+    #[cfg(not(stage0))]\n+    flags: u32,\n+    #[cfg(stage0)]\n+    flags: usize,\n     fill: char,\n     align: rt::v1::Alignment,\n-    width: Option<uint>,\n-    precision: Option<uint>,\n+    width: Option<usize>,\n+    precision: Option<usize>,\n \n     buf: &'a mut (Write+'a),\n     curarg: slice::Iter<'a, ArgumentV1<'a>>,\n@@ -140,7 +143,7 @@ pub struct ArgumentV1<'a> {\n \n impl<'a> ArgumentV1<'a> {\n     #[inline(never)]\n-    fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n+    fn show_usize(x: &usize, f: &mut Formatter) -> Result {\n         Display::fmt(x, f)\n     }\n \n@@ -156,15 +159,22 @@ impl<'a> ArgumentV1<'a> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[doc(hidden)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_uint(x: &uint) -> ArgumentV1 {\n-        ArgumentV1::new(x, ArgumentV1::show_uint)\n+        ArgumentV1::new(x, ArgumentV1::show_usize)\n+    }\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn from_usize(x: &usize) -> ArgumentV1 {\n+        ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n \n-    fn as_uint(&self) -> Option<uint> {\n-        if self.formatter as uint == ArgumentV1::show_uint as uint {\n-            Some(unsafe { *(self.value as *const _ as *const uint) })\n+    fn as_usize(&self) -> Option<usize> {\n+        if self.formatter as usize == ArgumentV1::show_usize as usize {\n+            Some(unsafe { *(self.value as *const _ as *const usize) })\n         } else {\n             None\n         }\n@@ -194,7 +204,7 @@ impl<'a> Arguments<'a> {\n     /// The `pieces` array must be at least as long as `fmt` to construct\n     /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -246,16 +256,6 @@ impl<'a> Display for Arguments<'a> {\n     }\n }\n \n-/// Format trait for the `:?` format. Useful for debugging, all types\n-/// should implement this.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n-#[unstable(feature = \"old_fmt\")]\n-pub trait Show {\n-    /// Formats the value using the given formatter.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -269,22 +269,6 @@ pub trait Debug {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-#[allow(deprecated)]\n-impl<T: Show + ?Sized> Debug for T {\n-    #[allow(deprecated)]\n-    fn fmt(&self, f: &mut Formatter) -> Result { Show::fmt(self, f) }\n-}\n-\n-/// When a value can be semantically expressed as a String, this trait may be\n-/// used. It corresponds to the default format, `{}`.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n-#[unstable(feature = \"old_fmt\")]\n-pub trait String {\n-    /// Formats the value using the given formatter.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default \\\n@@ -297,12 +281,6 @@ pub trait Display {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-#[allow(deprecated)]\n-impl<T: String + ?Sized> Display for T {\n-    #[allow(deprecated)]\n-    fn fmt(&self, f: &mut Formatter) -> Result { String::fmt(self, f) }\n-}\n-\n /// Format trait for the `o` character\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Octal {\n@@ -434,15 +412,15 @@ impl<'a> Formatter<'a> {\n         (value.formatter)(value.value, self)\n     }\n \n-    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<uint> {\n+    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n         match *cnt {\n             rt::v1::Count::Is(n) => Some(n),\n             rt::v1::Count::Implied => None,\n             rt::v1::Count::Param(i) => {\n-                self.args[i].as_uint()\n+                self.args[i].as_usize()\n             }\n             rt::v1::Count::NextParam => {\n-                self.curarg.next().and_then(|arg| arg.as_uint())\n+                self.curarg.next().and_then(|arg| arg.as_usize())\n             }\n         }\n     }\n@@ -476,12 +454,12 @@ impl<'a> Formatter<'a> {\n         let mut sign = None;\n         if !is_positive {\n             sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagV1::SignPlus as uint)) != 0 {\n+        } else if self.flags & (1 << (FlagV1::SignPlus as u32)) != 0 {\n             sign = Some('+'); width += 1;\n         }\n \n         let mut prefixed = false;\n-        if self.flags & (1 << (FlagV1::Alternate as uint)) != 0 {\n+        if self.flags & (1 << (FlagV1::Alternate as u32)) != 0 {\n             prefixed = true; width += prefix.char_len();\n         }\n \n@@ -511,7 +489,7 @@ impl<'a> Formatter<'a> {\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n-            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as uint)) != 0 => {\n+            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as u32)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n                 self.with_padding(min - width, Alignment::Right, |f| {\n@@ -581,7 +559,7 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: uint, default: Alignment,\n+    fn with_padding<F>(&mut self, padding: usize, default: Alignment,\n                        f: F) -> Result\n         where F: FnOnce(&mut Formatter) -> Result,\n     {\n@@ -627,6 +605,11 @@ impl<'a> Formatter<'a> {\n         write(self.buf, fmt)\n     }\n \n+    #[cfg(not(stage0))]\n+    /// Flags for formatting (packed version of rt::Flag)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn flags(&self) -> u32 { self.flags }\n+    #[cfg(stage0)]\n     /// Flags for formatting (packed version of rt::Flag)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flags(&self) -> usize { self.flags }\n@@ -641,11 +624,11 @@ impl<'a> Formatter<'a> {\n \n     /// Optionally specified integer width that the output should be\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn width(&self) -> Option<uint> { self.width }\n+    pub fn width(&self) -> Option<usize> { self.width }\n \n     /// Optionally specified precision for numeric types\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn precision(&self) -> Option<uint> { self.precision }\n+    pub fn precision(&self) -> Option<usize> { self.precision }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -731,9 +714,9 @@ impl Display for char {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (FlagV1::Alternate as uint);\n-        let ret = LowerHex::fmt(&(*self as uint), f);\n-        f.flags &= !(1 << (FlagV1::Alternate as uint));\n+        f.flags |= 1 << (FlagV1::Alternate as u32);\n+        let ret = LowerHex::fmt(&(*self as u32), f);\n+        f.flags &= !(1 << (FlagV1::Alternate as u32));\n         ret\n     }\n }\n@@ -889,7 +872,7 @@ impl<'a> Debug for &'a (any::Any+'a) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as u32)) == 0 {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n@@ -901,7 +884,7 @@ impl<T: Debug> Debug for [T] {\n             }\n             try!(write!(f, \"{:?}\", *x))\n         }\n-        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as u32)) == 0 {\n             try!(write!(f, \"]\"));\n         }\n         Ok(())"}, {"sha": "0175e21c8da6152b47bfbbae924118a19bc3bc64", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -214,7 +214,7 @@ macro_rules! integer {\n         show! { $Uint with $SU }\n     }\n }\n-integer! { int, uint, \"i\", \"u\" }\n+integer! { isize, usize, \"i\", \"u\" }\n integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }"}, {"sha": "c35611acb81428561ccb4634f72889588e534ec6", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -32,8 +32,12 @@ pub struct FormatSpec {\n     pub fill: char,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub align: Alignment,\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub flags: uint,\n+    pub flags: usize,\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub flags: u32,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub precision: Count,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "edc4b7e10ee49b04b024a3b3076d2f425f12358a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -20,7 +20,7 @@\n //!\n //! #[derive(Hash)]\n //! struct Person {\n-//!     id: uint,\n+//!     id: u32,\n //!     name: String,\n //!     phone: u64,\n //! }\n@@ -38,7 +38,7 @@\n //! use std::hash::{hash, Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n-//!     id: uint,\n+//!     id: u32,\n //!     name: String,\n //!     phone: u64,\n //! }"}, {"sha": "39bcbacdff182c23b137037d007099a58ca17ed8", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -34,13 +34,13 @@ use super::Hasher;\n pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n-    length: uint, // how many bytes we've processed\n+    length: usize, // how many bytes we've processed\n     v0: u64,      // hash state\n     v1: u64,\n     v2: u64,\n     v3: u64,\n     tail: u64, // unprocessed bytes le\n-    ntail: uint,  // how many bytes in tail are valid\n+    ntail: usize,  // how many bytes in tail are valid\n }\n \n // sadly, these macro definitions can't appear later,"}, {"sha": "09089f2d04c5f8f3ec3f8110a5b23eeeb7a707d3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -86,6 +86,7 @@ use usize;\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling `.iter()` or a similar \\\n                             method\"]\n pub trait Iterator {\n+    /// The type of the elements being iterated\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n@@ -122,9 +123,11 @@ pub trait FromIterator<A> {\n /// Conversion into an `Iterator`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n+    /// The type of the elements being iterated\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n+    /// A container for iterating over elements of type Item\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type IntoIter: Iterator<Item=Self::Item>;\n "}, {"sha": "c382ac46d5db9895a99241e95d32291f3da1650e", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -184,6 +184,7 @@ macro_rules! forward_ref_binop {\n #[lang=\"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n+    /// The resulting type after applying the `+` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -237,6 +238,7 @@ add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n #[lang=\"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n+    /// The resulting type after applying the `-` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -290,6 +292,7 @@ sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n #[lang=\"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n+    /// The resulting type after applying the `*` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -343,6 +346,7 @@ mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n #[lang=\"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n+    /// The resulting type after applying the `/` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -396,6 +400,7 @@ div_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n #[lang=\"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n+    /// The resulting type after applying the `%` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n@@ -468,6 +473,7 @@ rem_float_impl! { f64, fmod }\n #[lang=\"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n+    /// The resulting type after applying the `-` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -544,6 +550,7 @@ neg_uint_impl! { u64, i64 }\n #[lang=\"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n+    /// The resulting type after applying the `!` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -597,6 +604,7 @@ not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n #[lang=\"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n+    /// The resulting type after applying the `&` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -650,6 +658,7 @@ bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n #[lang=\"bitor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n+    /// The resulting type after applying the `|` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -703,6 +712,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n #[lang=\"bitxor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n+    /// The resulting type after applying the `^` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -756,6 +766,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n #[lang=\"shl\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n+    /// The resulting type after applying the `<<` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -827,6 +838,7 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n #[lang=\"shr\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n+    /// The resulting type after applying the `>>` operator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n@@ -900,6 +912,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Idx: ?Sized> {\n+    /// The returned type after indexing\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n@@ -1047,6 +1060,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n #[lang=\"deref\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n+    /// The resulting type after dereferencing\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n@@ -1122,6 +1136,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait Fn<Args> {\n+    /// The returned type after the call operator is used.\n     type Output;\n \n     /// This is called when the call operator is used.\n@@ -1133,6 +1148,7 @@ pub trait Fn<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait FnMut<Args> {\n+    /// The returned type after the call operator is used.\n     type Output;\n \n     /// This is called when the call operator is used.\n@@ -1144,6 +1160,7 @@ pub trait FnMut<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait FnOnce<Args> {\n+    /// The returned type after the call operator is used.\n     type Output;\n \n     /// This is called when the call operator is used."}, {"sha": "b44cc899787f54cc7c29001de7e8018e231daf08", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -249,6 +249,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Methods on raw pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PtrExt: Sized {\n+    /// The type which is being pointed at\n     type Target;\n \n     /// Returns true if the pointer is null.\n@@ -284,6 +285,7 @@ pub trait PtrExt: Sized {\n /// Methods on mutable raw pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n+    /// The type which is being pointed at\n     type Target;\n \n     /// Returns `None` if the pointer is null, or else returns a mutable"}, {"sha": "4e25e51e9a466075c58b49ae0207413b88a8b426", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -24,7 +24,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unicode)]\n \n@@ -65,7 +64,7 @@ pub struct FormatSpec<'a> {\n     /// Optionally specified alignment\n     pub align: Alignment,\n     /// Packed version of various flags provided\n-    pub flags: uint,\n+    pub flags: u32,\n     /// The integer precision to use\n     pub precision: Count<'a>,\n     /// The string width requested for the resulting format\n@@ -82,7 +81,7 @@ pub enum Position<'a> {\n     /// The argument will be in the next position. This is the default.\n     ArgumentNext,\n     /// The argument is located at a specific index.\n-    ArgumentIs(uint),\n+    ArgumentIs(usize),\n     /// The argument has a name.\n     ArgumentNamed(&'a str),\n }\n@@ -121,11 +120,11 @@ pub enum Flag {\n #[derive(Copy, PartialEq)]\n pub enum Count<'a> {\n     /// The count is specified explicitly.\n-    CountIs(uint),\n+    CountIs(usize),\n     /// The count is specified by the argument with the given name.\n     CountIsName(&'a str),\n     /// The count is specified by the argument at the given index.\n-    CountIsParam(uint),\n+    CountIsParam(usize),\n     /// The count is specified by the next parameter.\n     CountIsNextParam,\n     /// The count is implied and cannot be explicitly specified.\n@@ -237,7 +236,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n-    fn string(&mut self, start: uint) -> &'a str {\n+    fn string(&mut self, start: usize) -> &'a str {\n         loop {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n@@ -314,13 +313,13 @@ impl<'a> Parser<'a> {\n         }\n         // Sign flags\n         if self.consume('+') {\n-            spec.flags |= 1 << (FlagSignPlus as uint);\n+            spec.flags |= 1 << (FlagSignPlus as u32);\n         } else if self.consume('-') {\n-            spec.flags |= 1 << (FlagSignMinus as uint);\n+            spec.flags |= 1 << (FlagSignMinus as u32);\n         }\n         // Alternate marker\n         if self.consume('#') {\n-            spec.flags |= 1 << (FlagAlternate as uint);\n+            spec.flags |= 1 << (FlagAlternate as u32);\n         }\n         // Width and precision\n         let mut havewidth = false;\n@@ -333,7 +332,7 @@ impl<'a> Parser<'a> {\n                 spec.width = CountIsParam(0);\n                 havewidth = true;\n             } else {\n-                spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+                spec.flags |= 1 << (FlagSignAwareZeroPad as u32);\n             }\n         }\n         if !havewidth {\n@@ -413,7 +412,7 @@ impl<'a> Parser<'a> {\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n     /// with overflow at all, it's just accumulating digits.\n-    fn integer(&mut self) -> Option<uint> {\n+    fn integer(&mut self) -> Option<usize> {\n         let mut cur = 0;\n         let mut found = false;\n         loop {\n@@ -617,7 +616,7 @@ mod tests {\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n-                flags: (1 << FlagSignMinus as uint),\n+                flags: (1 << FlagSignMinus as u32),\n                 precision: CountImplied,\n                 width: CountImplied,\n                 ty: \"\",\n@@ -628,7 +627,7 @@ mod tests {\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n-                flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n+                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n                 precision: CountImplied,\n                 width: CountImplied,\n                 ty: \"\","}, {"sha": "8a00622486ddc294a9cdd9506f1375cf8e3f8148", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -1577,6 +1577,14 @@ impl LintPass for MissingDoc {\n                                      tm.span, \"a type method\");\n     }\n \n+    fn check_trait_method(&mut self, cx: &Context, it: &ast::TraitItem) {\n+        if let ast::TraitItem::TypeTraitItem(ref ty) = *it {\n+            let assoc_ty = &ty.ty_param;\n+            self.check_missing_docs_attrs(cx, Some(assoc_ty.id), &ty.attrs,\n+                                          assoc_ty.span, \"an associated type\");\n+        }\n+    }\n+\n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n         if let ast::NamedField(_, vis) = sf.node.kind {\n             if vis == ast::Public || self.in_variant {\n@@ -1848,7 +1856,7 @@ impl LintPass for UnconditionalRecursion {\n                 continue\n             }\n             visited.insert(cfg_id);\n-            let node_id = cfg.graph.node_data(idx).id;\n+            let node_id = cfg.graph.node_data(idx).id();\n \n             // is this a recursive call?\n             if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {"}, {"sha": "11609ebe675efa8522265339ad71d4463828eae0", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -153,9 +153,6 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n-        ty::ty_open(_) => {\n-            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n-        }\n     }\n \n     let end = w.tell().unwrap();"}, {"sha": "52eedc460eb8749695fcb74cca6efab951c950cd", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 143, "deletions": 99, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -11,16 +11,15 @@\n use middle::cfg::*;\n use middle::def;\n use middle::graph;\n+use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ptr::P;\n-use util::nodemap::NodeMap;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -36,35 +35,29 @@ struct LoopScope {\n pub fn construct(tcx: &ty::ctxt,\n                  blk: &ast::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n-    let entry = add_initial_dummy_node(&mut graph);\n+    let entry = graph.add_node(CFGNodeData::Entry);\n \n     // `fn_exit` is target of return exprs, which lies somewhere\n     // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n     // also resolves chicken-and-egg problem that arises if you try to\n     // have return exprs jump to `block_exit` during construction.)\n-    let fn_exit = add_initial_dummy_node(&mut graph);\n+    let fn_exit = graph.add_node(CFGNodeData::Exit);\n     let block_exit;\n \n     let mut cfg_builder = CFGBuilder {\n-        exit_map: NodeMap(),\n         graph: graph,\n         fn_exit: fn_exit,\n         tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n     block_exit = cfg_builder.block(blk, entry);\n     cfg_builder.add_contained_edge(block_exit, fn_exit);\n-    let CFGBuilder {exit_map, graph, ..} = cfg_builder;\n-    CFG {exit_map: exit_map,\n-         graph: graph,\n+    let CFGBuilder {graph, ..} = cfg_builder;\n+    CFG {graph: graph,\n          entry: entry,\n          exit: fn_exit}\n }\n \n-fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n-    g.add_node(CFGNodeData { id: ast::DUMMY_NODE_ID })\n-}\n-\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n@@ -74,19 +67,19 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-        self.add_node(blk.id, &[expr_exit])\n+        self.add_ast_node(blk.id, &[expr_exit])\n     }\n \n     fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             ast::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n-                self.add_node(id, &[exit])\n+                self.add_ast_node(id, &[exit])\n             }\n \n             ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n                 let exit = self.expr(&**expr, pred);\n-                self.add_node(id, &[exit])\n+                self.add_ast_node(id, &[exit])\n             }\n \n             ast::StmtMac(..) => {\n@@ -115,33 +108,33 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {\n-                self.add_node(pat.id, &[pred])\n+                self.add_ast_node(pat.id, &[pred])\n             }\n \n             ast::PatBox(ref subpat) |\n             ast::PatRegion(ref subpat, _) |\n             ast::PatIdent(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&**subpat, pred);\n-                self.add_node(pat.id, &[subpat_exit])\n+                self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatVec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_node(pat.id, &[post_exit])\n+                self.add_ast_node(pat.id, &[post_exit])\n             }\n \n             ast::PatMac(_) => {\n@@ -157,28 +150,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n     }\n \n-    fn pats_any(&mut self,\n-                pats: &[P<ast::Pat>],\n-                pred: CFGIndex) -> CFGIndex {\n-        //! Handles case where just one of the patterns must match.\n-\n-        if pats.len() == 1 {\n-            self.pat(&*pats[0], pred)\n-        } else {\n-            let collect = self.add_dummy_node(&[]);\n-            for pat in pats {\n-                let pat_exit = self.pat(&**pat, pred);\n-                self.add_contained_edge(pat_exit, collect);\n-            }\n-            collect\n-        }\n-    }\n-\n     fn expr(&mut self, expr: &ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n-                self.add_node(expr.id, &[blk_exit])\n+                self.add_ast_node(expr.id, &[blk_exit])\n             }\n \n             ast::ExprIf(ref cond, ref then, None) => {\n@@ -198,7 +174,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n-                self.add_node(expr.id, &[cond_exit, then_exit])          // 3,4\n+                self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n             ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -219,7 +195,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n                 let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n-                self.add_node(expr.id, &[then_exit, else_exit])          // 4, 5\n+                self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }\n \n             ast::ExprIfLet(..) => {\n@@ -247,7 +223,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n                 let cond_exit = self.expr(&**cond, loopback);             // 2\n-                let expr_exit = self.add_node(expr.id, &[cond_exit]);     // 3\n+                let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -283,7 +259,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_node(expr.id, &[]);              // 2\n+                let expr_exit = self.add_ast_node(expr.id, &[]);          // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -296,45 +272,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //    [discr]\n-                //       |\n-                //       v 2\n-                //    [cond1]\n-                //      /  \\\n-                //     |    \\\n-                //     v 3   \\\n-                //  [pat1]    \\\n-                //     |       |\n-                //     v 4     |\n-                //  [guard1]   |\n-                //     |       |\n-                //     |       |\n-                //     v 5     v\n-                //  [body1]  [cond2]\n-                //     |      /  \\\n-                //     |    ...  ...\n-                //     |     |    |\n-                //     v 6   v    v\n-                //  [.....expr.....]\n-                //\n-                let discr_exit = self.expr(&**discr, pred);              // 1\n-\n-                let expr_exit = self.add_node(expr.id, &[]);\n-                let mut cond_exit = discr_exit;\n-                for arm in arms {\n-                    cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(&arm.pats,\n-                                                  cond_exit);            // 3\n-                    let guard_exit = self.opt_expr(&arm.guard,\n-                                                   pats_exit);           // 4\n-                    let body_exit = self.expr(&*arm.body, guard_exit);   // 5\n-                    self.add_contained_edge(body_exit, expr_exit);       // 6\n-                }\n-                expr_exit\n+                self.match_(expr.id, &discr, &arms, pred)\n             }\n \n             ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n@@ -354,30 +292,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&**l, pred);                      // 1\n                 let r_exit = self.expr(&**r, l_exit);                    // 2\n-                self.add_node(expr.id, &[l_exit, r_exit])                 // 3,4\n+                self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n             }\n \n             ast::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_node(expr.id, &[v_exit]);\n+                let b = self.add_ast_node(expr.id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let b = self.add_node(expr.id, &[pred]);\n+                let b = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let a = self.add_node(expr.id, &[pred]);\n+                let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprVec(ref elems) => {\n@@ -454,7 +392,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n-                self.add_node(expr.id, &[post_outputs])\n+                self.add_ast_node(expr.id, &[post_outputs])\n             }\n \n             ast::ExprMac(..) |\n@@ -481,7 +419,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         if return_ty.diverges() {\n-            self.add_node(ast::DUMMY_NODE_ID, &[])\n+            self.add_unreachable_node()\n         } else {\n             ret\n         }\n@@ -508,20 +446,126 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_node(expr.id, &[subexprs_exit])\n+        self.add_ast_node(expr.id, &[subexprs_exit])\n+    }\n+\n+    fn match_(&mut self, id: ast::NodeId, discr: &ast::Expr,\n+              arms: &[ast::Arm], pred: CFGIndex) -> CFGIndex {\n+        // The CFG for match expression is quite complex, so no ASCII\n+        // art for it (yet).\n+        //\n+        // The CFG generated below matches roughly what trans puts\n+        // out. Each pattern and guard is visited in parallel, with\n+        // arms containing multiple patterns generating multiple nodes\n+        // for the same guard expression. The guard expressions chain\n+        // into each other from top to bottom, with a specific\n+        // exception to allow some additional valid programs\n+        // (explained below). Trans differs slightly in that the\n+        // pattern matching may continue after a guard but the visible\n+        // behaviour should be the same.\n+        //\n+        // What is going on is explained in further comments.\n+\n+        // Visit the discriminant expression\n+        let discr_exit = self.expr(discr, pred);\n+\n+        // Add a node for the exit of the match expression as a whole.\n+        let expr_exit = self.add_ast_node(id, &[]);\n+\n+        // Keep track of the previous guard expressions\n+        let mut prev_guards = Vec::new();\n+        // Track if the previous pattern contained bindings or wildcards\n+        let mut prev_has_bindings = false;\n+\n+        for arm in arms {\n+            // Add an exit node for when we've visited all the\n+            // patterns and the guard (if there is one) in the arm.\n+            let arm_exit = self.add_dummy_node(&[]);\n+\n+            for pat in &arm.pats {\n+                // Visit the pattern, coming from the discriminant exit\n+                let mut pat_exit = self.pat(&**pat, discr_exit);\n+\n+                // If there is a guard expression, handle it here\n+                if let Some(ref guard) = arm.guard {\n+                    // Add a dummy node for the previous guard\n+                    // expression to target\n+                    let guard_start = self.add_dummy_node(&[pat_exit]);\n+                    // Visit the guard expression\n+                    let guard_exit = self.expr(&**guard, guard_start);\n+\n+                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n+                        &self.tcx.def_map, &**pat);\n+\n+                    // If both this pattern and the previous pattern\n+                    // were free of bindings, they must consist only\n+                    // of \"constant\" patterns. Note we cannot match an\n+                    // all-constant pattern, fail the guard, and then\n+                    // match *another* all-constant pattern. This is\n+                    // because if the previous pattern matches, then\n+                    // we *cannot* match this one, unless all the\n+                    // constants are the same (which is rejected by\n+                    // `check_match`).\n+                    //\n+                    // We can use this to be smarter about the flow\n+                    // along guards. If the previous pattern matched,\n+                    // then we know we will not visit the guard in\n+                    // this one (whether or not the guard succeeded),\n+                    // if the previous pattern failed, then we know\n+                    // the guard for that pattern will not have been\n+                    // visited. Thus, it is not possible to visit both\n+                    // the previous guard and the current one when\n+                    // both patterns consist only of constant\n+                    // sub-patterns.\n+                    //\n+                    // However, if the above does not hold, then all\n+                    // previous guards need to be wired to visit the\n+                    // current guard pattern.\n+                    if prev_has_bindings || this_has_bindings {\n+                        while let Some(prev) = prev_guards.pop() {\n+                            self.add_contained_edge(prev, guard_start);\n+                        }\n+                    }\n+\n+                    prev_has_bindings = this_has_bindings;\n+\n+                    // Push the guard onto the list of previous guards\n+                    prev_guards.push(guard_exit);\n+\n+                    // Update the exit node for the pattern\n+                    pat_exit = guard_exit;\n+                }\n+\n+                // Add an edge from the exit of this pattern to the\n+                // exit of the arm\n+                self.add_contained_edge(pat_exit, arm_exit);\n+            }\n+\n+            // Visit the body of this arm\n+            let body_exit = self.expr(&arm.body, arm_exit);\n+\n+            // Link the body to the exit of the expression\n+            self.add_contained_edge(body_exit, expr_exit);\n+        }\n+\n+        expr_exit\n     }\n \n     fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(ast::DUMMY_NODE_ID, preds)\n+        self.add_node(CFGNodeData::Dummy, preds)\n     }\n \n-    fn add_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n-        assert!(!self.exit_map.contains_key(&id));\n-        let node = self.graph.add_node(CFGNodeData {id: id});\n-        if id != ast::DUMMY_NODE_ID {\n-            assert!(!self.exit_map.contains_key(&id));\n-            self.exit_map.insert(id, node);\n-        }\n+    fn add_ast_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n+        assert!(id != ast::DUMMY_NODE_ID);\n+        self.add_node(CFGNodeData::AST(id), preds)\n+    }\n+\n+    fn add_unreachable_node(&mut self) -> CFGIndex {\n+        self.add_node(CFGNodeData::Unreachable, &[])\n+    }\n+\n+    fn add_node(&mut self, data: CFGNodeData, preds: &[CFGIndex]) -> CFGIndex {\n+        let node = self.graph.add_node(data);\n         for &pred in preds {\n             self.add_contained_edge(pred, node);\n         }"}, {"sha": "0c5eca3c12968ee3b93d6b31371109271ef572c0", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -65,10 +65,10 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             dot::LabelText::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n             dot::LabelText::LabelStr(\"exit\".into_cow())\n-        } else if n.data.id == ast::DUMMY_NODE_ID {\n+        } else if n.data.id() == ast::DUMMY_NODE_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.ast_map.node_to_string(n.data.id);\n+            let s = self.ast_map.node_to_string(n.data.id());\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             dot::LabelText::EscStr(s.into_cow())"}, {"sha": "e8a99f59b1e95b365c9c0e4184757608978b8638", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -14,21 +14,33 @@\n use middle::graph;\n use middle::ty;\n use syntax::ast;\n-use util::nodemap::NodeMap;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n-    pub exit_map: NodeMap<CFGIndex>,\n     pub graph: CFGGraph,\n     pub entry: CFGIndex,\n     pub exit: CFGIndex,\n }\n \n-#[derive(Copy)]\n-pub struct CFGNodeData {\n-    pub id: ast::NodeId\n+#[derive(Copy, PartialEq)]\n+pub enum CFGNodeData {\n+    AST(ast::NodeId),\n+    Entry,\n+    Exit,\n+    Dummy,\n+    Unreachable,\n+}\n+\n+impl CFGNodeData {\n+    pub fn id(&self) -> ast::NodeId {\n+        if let CFGNodeData::AST(id) = *self {\n+            id\n+        } else {\n+            ast::DUMMY_NODE_ID\n+        }\n+    }\n }\n \n pub struct CFGEdgeData {\n@@ -50,6 +62,6 @@ impl CFG {\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n-        self.graph.depth_traverse(self.entry).any(|node| node.id == id)\n+        self.graph.depth_traverse(self.entry).any(|node| node.id() == id)\n     }\n }"}, {"sha": "1718df702553f0f94886f0b365fd880ad55ad439", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 68, "deletions": 40, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -53,7 +53,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n-    nodeid_to_index: NodeMap<CFGIndex>,\n+    nodeid_to_index: NodeMap<Vec<CFGIndex>>,\n \n     // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -88,11 +88,9 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n     changed: bool\n }\n \n-fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n-    let opt_cfgindex = index.get(&id).cloned();\n-    opt_cfgindex.unwrap_or_else(|| {\n-        panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n-    })\n+fn get_cfg_indices<'a>(id: ast::NodeId, index: &'a NodeMap<Vec<CFGIndex>>) -> &'a [CFGIndex] {\n+    let opt_indices = index.get(&id);\n+    opt_indices.map(|v| &v[..]).unwrap_or(&[])\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n@@ -114,9 +112,13 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             pprust::NodePat(pat) => pat.id\n         };\n \n-        if self.has_bitset_for_nodeid(id) {\n-            assert!(self.bits_per_id > 0);\n-            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        if !self.has_bitset_for_nodeid(id) {\n+            return Ok(());\n+        }\n+\n+        assert!(self.bits_per_id > 0);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = &self.on_entry[start.. end];\n             let entry_str = bits_to_string(on_entry);\n@@ -144,7 +146,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n }\n \n fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n-                         cfg: &cfg::CFG) -> NodeMap<CFGIndex> {\n+                         cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n     let mut index = NodeMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n@@ -157,28 +159,38 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n \n     cfg.graph.each_node(|node_idx, node| {\n-        if node.data.id != ast::DUMMY_NODE_ID {\n-            index.insert(node.data.id, node_idx);\n+        if let cfg::CFGNodeData::AST(id) = node.data {\n+            match index.entry(id).get() {\n+                Ok(v) => v.push(node_idx),\n+                Err(e) => {\n+                    e.insert(vec![node_idx]);\n+                }\n+            }\n         }\n         true\n     });\n \n     return index;\n \n-    fn add_entries_from_fn_decl(index: &mut NodeMap<CFGIndex>,\n+    fn add_entries_from_fn_decl(index: &mut NodeMap<Vec<CFGIndex>>,\n                                 decl: &ast::FnDecl,\n                                 entry: CFGIndex) {\n         //! add mappings from the ast nodes for the formal bindings to\n         //! the entry-node in the graph.\n         struct Formals<'a> {\n             entry: CFGIndex,\n-            index: &'a mut NodeMap<CFGIndex>,\n+            index: &'a mut NodeMap<Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n         visit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> visit::Visitor<'v> for Formals<'a> {\n             fn visit_pat(&mut self, p: &ast::Pat) {\n-                self.index.insert(p.id, self.entry);\n+                match self.index.entry(p.id).get() {\n+                    Ok(v) => v.push(self.entry),\n+                    Err(e) => {\n+                        e.insert(vec![self.entry]);\n+                    }\n+                }\n                 visit::walk_pat(self, p)\n             }\n         }\n@@ -230,10 +242,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &mut self.gens[start.. end];\n-        set_bit(gens, bit);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let gens = &mut self.gens[start.. end];\n+            set_bit(gens, bit);\n+        }\n     }\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n@@ -243,10 +257,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = &mut self.kills[start.. end];\n-        set_bit(kills, bit);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let kills = &mut self.kills[start.. end];\n+            set_bit(kills, bit);\n+        }\n     }\n \n     fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n@@ -279,16 +295,21 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, f: F) -> bool where\n+    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n         F: FnMut(uint) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        self.each_bit_for_node(Entry, cfgidx, f)\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            if !self.each_bit_for_node(Entry, cfgidx, |i| f(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n@@ -320,7 +341,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit<F>(&self, id: ast::NodeId, f: F) -> bool where\n+    pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n         F: FnMut(uint) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n@@ -334,12 +355,17 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             return true;\n         }\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &self.gens[start.. end];\n-        debug!(\"{} each_gen_bit(id={}, gens={})\",\n-               self.analysis_name, id, bits_to_string(gens));\n-        self.each_bit(gens, f)\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let gens = &self.gens[start.. end];\n+            debug!(\"{} each_gen_bit(id={}, gens={})\",\n+                   self.analysis_name, id, bits_to_string(gens));\n+            if !self.each_bit(gens, |i| f(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n@@ -400,13 +426,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             let mut changed = false;\n             for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).cloned();\n+                let opt_cfg_idx = self.nodeid_to_index.get(&node_id);\n                 match opt_cfg_idx {\n-                    Some(cfg_idx) => {\n-                        let (start, end) = self.compute_id_range(cfg_idx);\n-                        let kills = &self.kills[start.. end];\n-                        if bitwise(&mut orig_kills, kills, &Union) {\n-                            changed = true;\n+                    Some(indices) => {\n+                        for &cfg_idx in indices {\n+                            let (start, end) = self.compute_id_range(cfg_idx);\n+                            let kills = &self.kills[start.. end];\n+                            if bitwise(&mut orig_kills, kills, &Union) {\n+                                changed = true;\n+                            }\n                         }\n                     }\n                     None => {\n@@ -482,7 +510,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n         cfg.graph.each_node(|node_index, node| {\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n-                   node_index, node.data.id, bits_to_string(in_out));\n+                   node_index, node.data.id(), bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);\n "}, {"sha": "7584a2e44cc7c0b3316be2718c153705e530ec03", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -93,7 +93,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n                 None\n             }\n         }\n-        ty::ty_open(_) | ty::ty_infer(_) | ty::ty_err => None,\n+        ty::ty_infer(_) | ty::ty_err => None,\n     }\n }\n "}, {"sha": "e41b949d5df1d75cb98d80b57fccc83bb79a76eb", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -135,7 +135,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 t\n             }\n \n-            ty::ty_open(..) |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "a7df2f4a5dafb4dfe3e4b90e6a2a0b748ca05f2f", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -119,6 +119,21 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n+/// Checks if the pattern contains any patterns that bind something to\n+/// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    let mut contains_bindings = false;\n+    walk_pat(pat, |p| {\n+        if pat_is_binding_or_wild(dm, p) {\n+            contains_bindings = true;\n+            false // there's at least one binding/wildcard, can short circuit now.\n+        } else {\n+            true\n+        }\n+    });\n+    contains_bindings\n+}\n+\n pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     match pat.node {\n         ast::PatIdent(ast::BindByValue(_), ref path1, None) => {"}, {"sha": "4d45bb841f49ff0cecf1d999366c8a73b8110236", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -194,7 +194,6 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n         ty::ty_closure(..) |\n         ty::ty_infer(..) |\n-        ty::ty_open(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\","}, {"sha": "64835a666faef46d6fe23c518d88108d5dbe7663", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -42,9 +42,6 @@ pub enum ObjectSafetyViolation<'tcx> {\n /// Reasons a method might not be object-safe.\n #[derive(Copy,Clone,Debug)]\n pub enum MethodViolationCode {\n-    /// e.g., `fn(self)`\n-    ByValueSelf,\n-\n     /// e.g., `fn foo()`\n     StaticMethod,\n \n@@ -157,19 +154,25 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n+{\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let trait_predicates = ty::lookup_predicates(tcx, trait_def_id);\n+    generics_require_sized_self(tcx, &trait_def.generics, &trait_predicates)\n+}\n+\n+fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     generics: &ty::Generics<'tcx>,\n+                                     predicates: &ty::GenericPredicates<'tcx>)\n+                                     -> bool\n {\n     let sized_def_id = match tcx.lang_items.sized_trait() {\n         Some(def_id) => def_id,\n         None => { return false; /* No Sized trait, can't require it! */ }\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    let free_substs = ty::construct_free_substs(tcx, &trait_def.generics, ast::DUMMY_NODE_ID);\n-\n-    let trait_predicates = ty::lookup_predicates(tcx, trait_def_id);\n-    let predicates = trait_predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n-\n+    let free_substs = ty::construct_free_substs(tcx, generics, ast::DUMMY_NODE_ID);\n+    let predicates = predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n             match predicate {\n@@ -192,17 +195,21 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              method: &ty::Method<'tcx>)\n                                              -> Option<MethodViolationCode>\n {\n-    // The method's first parameter must be something that derefs to\n-    // `&self`. For now, we only accept `&self` and `Box<Self>`.\n-    match method.explicit_self {\n-        ty::ByValueExplicitSelfCategory => {\n-            return Some(MethodViolationCode::ByValueSelf);\n-        }\n+    // Any method that has a `Self : Sized` requisite is otherwise\n+    // exempt from the regulations.\n+    if generics_require_sized_self(tcx, &method.generics, &method.predicates) {\n+        return None;\n+    }\n \n+    // The method's first parameter must be something that derefs (or\n+    // autorefs) to `&self`. For now, we only accept `self`, `&self`\n+    // and `Box<Self>`.\n+    match method.explicit_self {\n         ty::StaticExplicitSelfCategory => {\n             return Some(MethodViolationCode::StaticMethod);\n         }\n \n+        ty::ByValueExplicitSelfCategory |\n         ty::ByReferenceExplicitSelfCategory(..) |\n         ty::ByBoxExplicitSelfCategory => {\n         }"}, {"sha": "8086ca71e019ed556cf939cf0f40dcde84bc4c5c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -1626,25 +1626,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_open(ty) => {\n-                // these only crop up in trans, and represent an\n-                // \"opened\" unsized/existential type (one that has\n-                // been dereferenced)\n-                match bound {\n-                    ty::BoundCopy => {\n-                        Ok(If(vec!(ty)))\n-                    }\n-\n-                    ty::BoundSized => {\n-                        Err(Unimplemented)\n-                    }\n-\n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n-            }\n             ty::ty_err => {\n                 Ok(If(Vec::new()))\n             }\n@@ -1718,8 +1699,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Some(vec![referent_ty])\n             }\n \n-            ty::ty_open(element_ty) => {Some(vec![element_ty])},\n-\n             ty::ty_ptr(ty::mt { ty: element_ty, ..}) |\n             ty::ty_rptr(_, ty::mt { ty: element_ty, ..}) => {\n                 Some(vec![element_ty])"}, {"sha": "3d059e27c5207d4cf5f0f3dd30e8211323b75ddc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 40, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -930,7 +930,7 @@ impl<'tcx> ctxt<'tcx> {\n         sty_debug_print!(\n             self,\n             ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_trait,\n-            ty_struct, ty_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n+            ty_struct, ty_closure, ty_tup, ty_param, ty_infer, ty_projection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -1374,12 +1374,6 @@ pub enum sty<'tcx> {\n     ty_projection(ProjectionTy<'tcx>),\n     ty_param(ParamTy), // type parameter\n \n-    ty_open(Ty<'tcx>), // A deref'ed fat pointer, i.e., a dynamically sized value\n-                       // and its size. Only ever used in trans. It is not necessary\n-                       // earlier since we don't need to distinguish a DST with its\n-                       // size (e.g., in a deref) vs a DST with the size elsewhere (\n-                       // e.g., in a field).\n-\n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n@@ -2689,7 +2683,7 @@ impl FlagComputation {\n                 self.add_bounds(bounds);\n             }\n \n-            &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n+            &ty_uniq(tt) | &ty_vec(tt, _) => {\n                 self.add_ty(tt)\n             }\n \n@@ -2964,8 +2958,6 @@ pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'t\n     mk_param(cx, def.space, def.index, def.name)\n }\n \n-pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n-\n impl<'tcx> TyS<'tcx> {\n     /// Iterator that walks `self` and any types reachable from\n     /// `self`, in depth-first order. Note that just walks the types\n@@ -3164,7 +3156,6 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n-        ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                  ty_to_string(cx, ty))),\n     }\n@@ -3583,12 +3574,6 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 TC::All\n             }\n \n-            ty_open(ty) => {\n-                let result = tc_ty(cx, ty, cache);\n-                assert!(!result.is_sized(cx));\n-                result.unsafe_pointer() | TC::Nonsized\n-            }\n-\n             ty_infer(_) |\n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n@@ -3747,7 +3732,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_vec(_, None) => {\n                 false\n             }\n-            ty_uniq(typ) | ty_open(typ) => {\n+            ty_uniq(typ) => {\n                 type_requires(cx, seen, r_ty, typ)\n             }\n             ty_rptr(_, ref mt) => {\n@@ -4106,14 +4091,6 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n     }\n }\n \n-pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n-        _ => cx.sess.bug(&format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty)))\n-    }\n-}\n-\n pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_uniq(ty) => ty,\n@@ -4122,14 +4099,6 @@ pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     }\n }\n \n-// Extract the unsized type in an open type (or just return ty if it is not open).\n-pub fn unopen_type<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty_open(ty) => ty,\n-        _ => ty\n-    }\n-}\n-\n // Returns the type of ty[i]\n pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.sty {\n@@ -4802,7 +4771,6 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n             }\n         }\n         ty_err => \"type error\".to_string(),\n-        ty_open(_) => \"opened DST\".to_string(),\n     }\n }\n \n@@ -6328,16 +6296,15 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     hash!(p.idx);\n                     hash!(token::get_name(p.name));\n                 }\n-                ty_open(_) => byte!(22),\n                 ty_infer(_) => unreachable!(),\n-                ty_err => byte!(23),\n+                ty_err => byte!(21),\n                 ty_closure(d, r, _) => {\n-                    byte!(24);\n+                    byte!(22);\n                     did(state, d);\n                     region(state, *r);\n                 }\n                 ty_projection(ref data) => {\n-                    byte!(25);\n+                    byte!(23);\n                     did(state, data.trait_ref.def_id);\n                     hash!(token::get_name(data.item_name));\n                 }\n@@ -6666,7 +6633,6 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_projection(_) |\n             ty_param(_) |\n             ty_infer(_) |\n-            ty_open(_) |\n             ty_err => {\n             }\n         }"}, {"sha": "d2469c052ac51348aa613fa42023c3a332f7ccc5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -626,9 +626,6 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_vec(typ, sz) => {\n             ty::ty_vec(typ.fold_with(this), sz)\n         }\n-        ty::ty_open(typ) => {\n-            ty::ty_open(typ.fold_with(this))\n-        }\n         ty::ty_enum(tid, ref substs) => {\n             let substs = substs.fold_with(this);\n             ty::ty_enum(tid, this.tcx().mk_substs(substs))"}, {"sha": "3336e7ee8bf71e6186107a989782913d8dd13f2f", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -28,7 +28,7 @@ impl<'tcx> TypeWalker<'tcx> {\n             ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n             ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n             }\n-            ty::ty_uniq(ty) | ty::ty_vec(ty, _) | ty::ty_open(ty) => {\n+            ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n                 self.stack.push(ty);\n             }\n             ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {"}, {"sha": "15b3c6d9d0602c7ed65a0ce39c560de1e99f4414", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -20,7 +20,7 @@ use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, Ty, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn};\n-use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n+use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup};\n use middle::ty::{ty_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n@@ -369,8 +369,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             buf.push_str(&mt_to_string(cx, tm));\n             buf\n         }\n-        ty_open(typ) =>\n-            format!(\"opened<{}>\", ty_to_string(cx, typ)),\n         ty_tup(ref elems) => {\n             let strs = elems\n                 .iter()"}, {"sha": "759147b939cb850a5f84279de7d8859e850c9c9d", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -20,6 +20,11 @@ pub fn opts() -> TargetOptions {\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!(\n+            // GNU-style linkers will use this to omit linking to libraries\n+            // which don't actually fulfill any relocations, but only for\n+            // libraries which follow this flag.  Thus, use it before\n+            // specifying libraries to link to.\n+            \"-Wl,--as-needed\".to_string(),\n         ),\n         position_independent_executables: true,\n         .. Default::default()"}, {"sha": "b0a03408b51e1fed5dc832b662dc0ca620f86769", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -612,13 +612,26 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 let (suggestion, _) =\n                     move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n-                self.tcx.sess.span_note(\n-                    expr_span,\n-                    &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n-                            ol,\n-                            moved_lp_msg,\n-                            expr_ty.user_string(self.tcx),\n-                            suggestion));\n+                // If the two spans are the same, it's because the expression will be evaluated\n+                // multiple times. Avoid printing the same span and adjust the wording so it makes\n+                // more sense that it's from multiple evalutations.\n+                if expr_span == use_span {\n+                    self.tcx.sess.note(\n+                        &format!(\"`{}` was previously moved here{} because it has type `{}`, \\\n+                                  which is {}\",\n+                                 ol,\n+                                 moved_lp_msg,\n+                                 expr_ty.user_string(self.tcx),\n+                                 suggestion));\n+                } else {\n+                    self.tcx.sess.span_note(\n+                        expr_span,\n+                        &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n+                                 ol,\n+                                 moved_lp_msg,\n+                                 expr_ty.user_string(self.tcx),\n+                                 suggestion));\n+                }\n             }\n \n             move_data::MovePat => {"}, {"sha": "a2c9930c0ed2fdc36f4469af01af05eb292f4c28", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -52,7 +52,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n-        let id = n.1.data.id;\n+        let id = n.1.data.id();\n         debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;"}, {"sha": "26e1a981f1bae25de1e722c0783e17af900126a9", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -678,7 +678,7 @@ fn bind_subslice_pat(bcx: Block,\n }\n \n fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 left_ty: Ty,\n+                                 left_ty: Ty<'tcx>,\n                                  before: uint,\n                                  after: uint,\n                                  val: ValueRef)"}, {"sha": "3ea14d3c58929dd5967c0a9893bb29a7e1233ca8", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -699,7 +699,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n         st.fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()\n+        st.fields.iter().map(|&ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }\n }\n "}, {"sha": "b18b7b75d32fc1fc65acd2980779716b1d74ec33", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -676,8 +676,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                   let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                       llfld_a\n                   } else {\n-                      let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n-                      let scratch = datum::rvalue_scratch_datum(cx, boxed_ty, \"__fat_ptr_iter\");\n+                      let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n                       Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n                       Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n                       scratch.val\n@@ -1353,7 +1352,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n // the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n     for n in cfg.graph.depth_traverse(cfg.entry) {\n-        match tcx.map.find(n.id) {\n+        match tcx.map.find(n.id()) {\n             Some(ast_map::NodeExpr(ex)) => {\n                 if let ast::ExprRet(Some(ref ret_expr)) = ex.node {\n                     let mut visitor = FindNestedReturn::new();"}, {"sha": "a3ba506fc46a2034b977589d18f3300cb6c89d56", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -120,14 +120,16 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n // Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     let param_env = ty::empty_parameter_environment(tcx);\n-    ty::type_is_sized(&param_env, DUMMY_SP, ty)\n-}\n-\n-pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::ty_open(_) => true,\n-        _ => type_is_sized(cx, ty),\n+    // FIXME(#4287) This can cause errors due to polymorphic recursion,\n+    // a better span should be provided, if available.\n+    let err_count = tcx.sess.err_count();\n+    let is_sized = ty::type_is_sized(&param_env, DUMMY_SP, ty);\n+    // Those errors aren't fatal, but an incorrect result can later\n+    // trip over asserts in both rustc's trans and LLVM.\n+    if err_count < tcx.sess.err_count() {\n+        tcx.sess.abort_if_errors();\n     }\n+    is_sized\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -211,9 +213,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n     }\n }\n \n-pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n-                         ty: Ty<'tcx>)\n-                         -> bool {\n+pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty::type_contents(cx, ty).needs_drop(cx)\n }\n "}, {"sha": "19046d84d6972f5b2ff4df293a9cd3271c801b01", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -146,8 +146,8 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 (const_deref_ptr(cx, v), mt.ty)\n             } else {\n                 // Derefing a fat pointer does not change the representation,\n-                // just the type to ty_open.\n-                (v, ty::mk_open(cx.tcx(), mt.ty))\n+                // just the type to the unsized contents.\n+                (v, mt.ty)\n             }\n         }\n         None => {\n@@ -290,15 +290,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // an optimisation, it is necessary for mutable vectors to\n                         // work properly.\n                         ty = match ty::deref(ty, true) {\n-                            Some(mt) => {\n-                                if type_is_sized(cx.tcx(), mt.ty) {\n-                                    mt.ty\n-                                } else {\n-                                    // Derefing a fat pointer does not change the representation,\n-                                    // just the type to ty_open.\n-                                    ty::mk_open(cx.tcx(), mt.ty)\n-                                }\n-                            }\n+                            Some(mt) => mt.ty,\n                             None => {\n                                 cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n                                                        ty_to_string(cx.tcx(), ty)))\n@@ -319,11 +311,12 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     llconst = addr_of(cx, llconst, \"autoref\", e.id);\n                 }\n                 Some(box ty::AutoUnsize(ref k)) => {\n-                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n                     let info = expr::unsized_info(cx, k, e.id, ty, param_substs,\n                         |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t));\n \n-                    let base = ptrcast(llconst, type_of::type_of(cx, unsized_ty).ptr_to());\n+                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n+                    let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n+                    let base = ptrcast(llconst, ptr_ty);\n                     let prev_const = cx.const_unsized().borrow_mut()\n                                        .insert(base, llconst);\n                     assert!(prev_const.is_none() || prev_const == Some(llconst));\n@@ -477,16 +470,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               };\n               let (arr, len) = match bt.sty {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_open(ty) => match ty.sty {\n-                      ty::ty_vec(_, None) | ty::ty_str => {\n-                          let e1 = const_get_elt(cx, bv, &[0]);\n-                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n-                      },\n-                      _ => cx.sess().span_bug(base.span,\n-                                              &format!(\"index-expr base must be a vector \\\n-                                                       or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)))\n-                  },\n+                  ty::ty_vec(_, None) | ty::ty_str => {\n+                      let e1 = const_get_elt(cx, bv, &[0]);\n+                      (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n+                  }\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))"}, {"sha": "8262dbf55ddaefe0ca376064cff207eb648c27d9", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -492,8 +492,6 @@ impl<'tcx> Datum<'tcx, Expr> {\n                                  -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n-        assert!(lltype_is_sized(bcx.tcx(), self.ty),\n-                \"Trying to convert unsized value to lval\");\n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n             |r| {\n@@ -549,15 +547,10 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n                                 -> Datum<'tcx, Lvalue> where\n         F: FnOnce(ValueRef) -> ValueRef,\n     {\n-        let val = match self.ty.sty {\n-            _ if type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n-            ty::ty_open(_) => {\n-                let base = Load(bcx, expr::get_dataptr(bcx, self.val));\n-                gep(base)\n-            }\n-            _ => bcx.tcx().sess.bug(\n-                &format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty)))\n+        let val = if type_is_sized(bcx.tcx(), self.ty) {\n+            gep(self.val)\n+        } else {\n+            gep(Load(bcx, expr::get_dataptr(bcx, self.val)))\n         };\n         Datum {\n             val: val,\n@@ -566,7 +559,8 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n         }\n     }\n \n-    pub fn get_vec_base_and_len(&self, bcx: Block) -> (ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len<'blk>(&self, bcx: Block<'blk, 'tcx>)\n+                                      -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair.\n \n         tvec::get_base_and_len(bcx, self.val, self.ty)"}, {"sha": "162881f58c74e2a96a4fe18a9d4fb0e3361a1791", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -3828,7 +3828,6 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::ty_err |\n         ty::ty_infer(_) |\n-        ty::ty_open(_) |\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\"}, {"sha": "9e9ee4537524b81bfc262027c61bb614c45296ad", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -451,8 +451,6 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum_ty = datum.ty;\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n-        let dest_ty = ty::mk_open(tcx, unsized_ty);\n-        debug!(\"dest_ty={}\", unsized_ty.repr(bcx.tcx()));\n \n         let info = unsized_info(bcx.ccx(), k, expr.id, datum_ty, bcx.fcx.param_substs,\n                                 |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n@@ -462,20 +460,16 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n         // Compute the base pointer. This doesn't change the pointer value,\n         // but merely its type.\n-        let base = match *k {\n-            ty::UnsizeStruct(..) | ty::UnsizeVtable(..) => {\n-                PointerCast(bcx, lval.val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n-            }\n-            ty::UnsizeLength(..) => {\n-                GEPi(bcx, lval.val, &[0, 0])\n-            }\n-        };\n+        let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n+        let base = PointerCast(bcx, lval.val, ptr_ty);\n \n-        let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n-        Store(bcx, base, get_dataptr(bcx, scratch.val));\n-        Store(bcx, info, get_len(bcx, scratch.val));\n+        let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n+        // HACK(eddyb) get around issues with lifetime intrinsics.\n+        let scratch = alloca_no_lifetime(bcx, llty, \"__fat_ptr\");\n+        Store(bcx, base, get_dataptr(bcx, scratch));\n+        Store(bcx, info, get_len(bcx, scratch));\n \n-        DatumBlock::new(bcx, scratch.to_expr_datum())\n+        DatumBlock::new(bcx, Datum::new(scratch, unsized_ty, LvalueExpr))\n     }\n \n     fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -711,7 +705,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n-    let bare_ty = ty::unopen_type(base_datum.ty);\n+    let bare_ty = base_datum.ty;\n     let repr = adt::represent_type(bcx.ccx(), bare_ty);\n     with_field_tys(bcx.tcx(), bare_ty, None, move |discr, field_tys| {\n         let ix = get_idx(bcx.tcx(), field_tys);\n@@ -723,7 +717,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         if type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         } else {\n-            let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n+            let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n             Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n             let info = Load(bcx, get_len(bcx, base_datum.val));\n             Store(bcx, info, get_len(bcx, scratch.val));\n@@ -809,7 +803,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n             } else {\n-                Datum::new(datum.val, ty::mk_open(bcx.tcx(), elt_ty), LvalueExpr)\n+                Datum::new(datum.val, elt_ty, LvalueExpr)\n             }\n         }\n         None => {\n@@ -1671,7 +1665,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            lval: Datum<'tcx, Lvalue>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n-    let dest_ty = ty::close_type(bcx.tcx(), lval.ty);\n+    let dest_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), lval.ty);\n     let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n     memcpy_ty(bcx, scratch.val, lval.val, scratch.ty);\n \n@@ -1685,16 +1679,13 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n-    match sub_datum.ty.sty {\n-        ty::ty_open(_) => {\n-            // Opened DST value, close to a fat pointer\n-            ref_fat_ptr(bcx, sub_datum)\n-        }\n-        _ => {\n-            // Sized value, ref to a thin pointer\n-            let ty = expr_ty(bcx, expr);\n-            immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n-        }\n+    if !type_is_sized(bcx.tcx(), sub_datum.ty) {\n+        // DST lvalue, close to a fat pointer\n+        ref_fat_ptr(bcx, sub_datum)\n+    } else {\n+        // Sized value, ref to a thin pointer\n+        let ty = expr_ty(bcx, expr);\n+        immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n     }\n }\n \n@@ -2234,16 +2225,15 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if type_is_sized(bcx.tcx(), content_ty) {\n                 deref_owned_pointer(bcx, expr, datum, content_ty)\n             } else {\n-                // A fat pointer and an opened DST value have the same\n-                // representation just different types. Since there is no\n-                // temporary for `*e` here (because it is unsized), we cannot\n-                // emulate the sized object code path for running drop glue and\n-                // free. Instead, we schedule cleanup for `e`, turning it into\n-                // an lvalue.\n+                // A fat pointer and a DST lvalue have the same representation\n+                // just different types. Since there is no temporary for `*e`\n+                // here (because it is unsized), we cannot emulate the sized\n+                // object code path for running drop glue and free. Instead,\n+                // we schedule cleanup for `e`, turning it into an lvalue.\n                 let datum = unpack_datum!(\n                     bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n \n-                let datum = Datum::new(datum.val, ty::mk_open(bcx.tcx(), content_ty), LvalueExpr);\n+                let datum = Datum::new(datum.val, content_ty, LvalueExpr);\n                 DatumBlock::new(bcx, datum)\n             }\n         }\n@@ -2260,11 +2250,9 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // owner (or, in the case of *T, by the user).\n                 DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n             } else {\n-                // A fat pointer and an opened DST value have the same representation\n+                // A fat pointer and a DST lvalue have the same representation\n                 // just different types.\n-                DatumBlock::new(bcx, Datum::new(datum.val,\n-                                                ty::mk_open(bcx.tcx(), content_ty),\n-                                                LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr))\n             }\n         }\n "}, {"sha": "c14683aeade058407b940b8a4f61ee856e5f7536", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -34,7 +34,7 @@ use trans::expr;\n use trans::machine::*;\n use trans::tvec;\n use trans::type_::Type;\n-use trans::type_of::{type_of, sizing_type_of, align_of};\n+use trans::type_of::{self, type_of, sizing_type_of, align_of};\n use middle::ty::{self, Ty};\n use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n@@ -265,8 +265,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         assert_eq!(params.len(), 1);\n         let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n             // The dtor expects a fat pointer, so make one, even if we have to fake it.\n-            let boxed_ty = ty::mk_open(bcx.tcx(), t);\n-            let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n+            let scratch = datum::rvalue_scratch_datum(bcx, t, \"__fat_ptr_drop_self\");\n             Store(bcx, value, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n             Store(bcx,\n                   // If we just had a thin pointer, make a fat pointer by sticking\n@@ -284,20 +283,18 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Add all the fields as a value which needs to be cleaned at the end of\n         // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n         // the order in which fields get dropped.\n-        for (i, ty) in st.fields.iter().enumerate().rev() {\n+        for (i, &ty) in st.fields.iter().enumerate().rev() {\n             let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n \n-            let val = if type_is_sized(bcx.tcx(), *ty) {\n+            let val = if type_is_sized(bcx.tcx(), ty) {\n                 llfld_a\n             } else {\n-                let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n-                let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_field\");\n+                let scratch = datum::rvalue_scratch_datum(bcx, ty, \"__fat_ptr_drop_field\");\n                 Store(bcx, llfld_a, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n                 Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n                 scratch.val\n             };\n-            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n-                                             val, *ty);\n+            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope), val, ty);\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n@@ -502,7 +499,10 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     // tydescs.\n     assert!(!ccx.finished_tydescs().get());\n \n-    let llty = type_of(ccx, t);\n+    // This really shouldn't be like this, size/align will be wrong for\n+    // unsized types (i.e. [T] will have the size/align of T).\n+    // But we need it until we split this out into a \"type name\" intrinsic.\n+    let llty = type_of::in_memory_type_of(ccx, t);\n \n     if ccx.sess().count_type_sizes() {\n         println!(\"{}\\t{}\", llsize_of_real(ccx, llty),"}, {"sha": "3411f12886d2266c959bfecb0f1a5d6975045e6b", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -818,9 +818,6 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                         param_substs,\n                         substs.clone()).val;\n \n-                    // currently, at least, by-value self is not object safe\n-                    assert!(m.explicit_self != ty::ByValueExplicitSelfCategory);\n-\n                     Some(fn_ref).into_iter()\n                 }\n             }"}, {"sha": "d3acd23e6416d8537fbd4e2e356019af8f5a50a5", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -372,38 +372,31 @@ pub fn get_fixed_base_and_len(bcx: Block,\n     (base, len)\n }\n \n-fn get_slice_base_and_len(bcx: Block,\n-                          llval: ValueRef)\n-                          -> (ValueRef, ValueRef) {\n-    let base = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_ADDR]));\n-    let len = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_EXTRA]));\n-    (base, len)\n-}\n-\n /// Converts a vector into the slice pair.  The vector should be stored in `llval` which should be\n /// by-reference.  If you have a datum, you would probably prefer to call\n /// `Datum::get_base_and_len()` which will handle any conversions for you.\n-pub fn get_base_and_len(bcx: Block,\n-                        llval: ValueRef,\n-                        vec_ty: Ty)\n-                        -> (ValueRef, ValueRef) {\n+pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    llval: ValueRef,\n+                                    vec_ty: Ty<'tcx>)\n+                                    -> (ValueRef, ValueRef) {\n     let ccx = bcx.ccx();\n \n     match vec_ty.sty {\n         ty::ty_vec(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n-        ty::ty_open(ty) => match ty.sty {\n-            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n-            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\")\n-        },\n+        ty::ty_vec(_, None) | ty::ty_str => {\n+            let base = Load(bcx, expr::get_dataptr(bcx, llval));\n+            let len = Load(bcx, expr::get_len(bcx, llval));\n+            (base, len)\n+        }\n \n         // Only used for pattern matching.\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n-            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n-            ty::ty_vec(_, Some(n)) => {\n-                let base = GEPi(bcx, Load(bcx, llval), &[0, 0]);\n-                (base, C_uint(ccx, n))\n-            }\n-            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+            let inner = if type_is_sized(bcx.tcx(), ty) {\n+                Load(bcx, llval)\n+            } else {\n+                llval\n+            };\n+            get_base_and_len(bcx, inner, ty)\n         },\n         _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n     }"}, {"sha": "d5ec18e641b7963de9a11ff5cfb71f36f785c8e2", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -232,14 +232,6 @@ impl Type {\n         Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n     }\n \n-    pub fn opaque_trait(ccx: &CrateContext) -> Type {\n-        Type::struct_(ccx, &[Type::opaque_trait_data(ccx).ptr_to(), Type::vtable_ptr(ccx)], false)\n-    }\n-\n-    pub fn opaque_trait_data(ccx: &CrateContext) -> Type {\n-        Type::i8(ccx)\n-    }\n-\n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n             llvm::LLVMGetTypeKind(self.to_ref())"}, {"sha": "97278eb0512e226ea0018c27258bbe79ed42ccd1", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 71, "deletions": 93, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::named_ty::*;\n-\n use middle::subst;\n use trans::adt;\n use trans::common::*;\n@@ -183,9 +181,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     }\n \n     let llsizingty = match t.sty {\n-        _ if !lltype_is_sized(cx.tcx(), t) => {\n-            cx.sess().bug(&format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)))\n+        _ if !type_is_sized(cx.tcx(), t) => {\n+            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -232,15 +229,11 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::ty_open(_) => {\n-            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n-        }\n-\n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n                                   ppaux::ty_to_string(cx.tcx(), t)))\n         }\n-        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n+        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => unreachable!()\n     };\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n@@ -270,25 +263,37 @@ pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     }\n }\n \n-// NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    fn type_of_unsize_info<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-        // It is possible to end up here with a sized type. This happens with a\n-        // struct which might be unsized, but is monomorphised to a sized type.\n-        // In this case we'll fake a fat pointer with no unsize info (we use 0).\n-        // However, its still a fat pointer, so we need some type use.\n-        if type_is_sized(cx.tcx(), t) {\n-            return Type::i8p(cx);\n-        }\n-\n-        match unsized_part_of_type(cx.tcx(), t).sty {\n-            ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyUs(false)),\n-            ty::ty_trait(_) => Type::vtable_ptr(cx),\n-            _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n-                       t.repr(cx.tcx()))\n-        }\n-    }\n+/// Get the LLVM type corresponding to a Rust type, i.e. `middle::ty::Ty`.\n+/// This is the right LLVM type for an alloca containg a value of that type,\n+/// and the pointee of an Lvalue Datum (which is always a LLVM pointer).\n+/// For unsized types, the returned type is a fat pointer, thus the resulting\n+/// LLVM type for a `Trait` Lvalue is `{ i8*, void(i8*)** }*`, which is a double\n+/// indirection to the actual data, unlike a `i8` Lvalue, which is just `i8*`.\n+/// This is needed due to the treatment of immediate values, as a fat pointer\n+/// is too large for it to be placed in SSA value (by our rules).\n+/// For the raw type without far pointer indirection, see `in_memory_type_of`.\n+pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+    let ty = if !type_is_sized(cx.tcx(), ty) {\n+        ty::mk_imm_ptr(cx.tcx(), ty)\n+    } else {\n+        ty\n+    };\n+    in_memory_type_of(cx, ty)\n+}\n \n+/// Get the LLVM type corresponding to a Rust type, i.e. `middle::ty::Ty`.\n+/// This is the right LLVM type for a field/array element of that type,\n+/// and is the same as `type_of` for all Sized types.\n+/// Unsized types, however, are represented by a \"minimal unit\", e.g.\n+/// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n+/// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n+/// If the type is an unsized struct, the regular layout is generated,\n+/// with the inner-most trailing unsized field using the \"minimal unit\"\n+/// of that field's type - this is useful for taking the address of\n+/// that field and ensuring the struct has the right alignment.\n+/// For the LLVM type of a value as a whole, see `type_of`.\n+/// NB: If you update this, be sure to update `sizing_type_of()` as well.\n+pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Check the cache.\n     match cx.lltypes().borrow().get(&t) {\n         Some(&llty) => return llty,\n@@ -307,7 +312,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     let t_norm = erase_regions(cx.tcx(), &t);\n \n     if t != t_norm {\n-        let llty = type_of(cx, t_norm);\n+        let llty = in_memory_type_of(cx, t_norm);\n         debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n                 t.repr(cx.tcx()),\n                 t,\n@@ -331,52 +336,58 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n-          let name = llvm_type_name(cx, an_enum, did, tps);\n+          let name = llvm_type_name(cx, did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n-      ty::ty_closure(did, _, ref substs) => {\n+      ty::ty_closure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n           // Unboxed closures can have substitutions in all spaces\n           // inherited from their environment, so we use entire\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n-          let name = llvm_type_name(cx, a_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, &name[..])\n+          adt::incomplete_type_of(cx, &*repr, \"closure\")\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n-          match ty.sty {\n-              ty::ty_str => {\n+          if !type_is_sized(cx.tcx(), ty) {\n+              if let ty::ty_str = ty.sty {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n                   cx.tn().find_type(\"str_slice\").unwrap()\n+              } else {\n+                  let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n+                  let unsized_part = unsized_part_of_type(cx.tcx(), ty);\n+                  let info_ty = match unsized_part.sty {\n+                      ty::ty_str | ty::ty_vec(..) => {\n+                          Type::uint_from_ty(cx, ast::TyUs(false))\n+                      }\n+                      ty::ty_trait(_) => Type::vtable_ptr(cx),\n+                      _ => panic!(\"Unexpected type returned from \\\n+                                   unsized_part_of_type: {} for ty={}\",\n+                                  unsized_part.repr(cx.tcx()), ty.repr(cx.tcx()))\n+                  };\n+                  Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n-              ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ if !type_is_sized(cx.tcx(), ty) => {\n-                  let p_ty = type_of(cx, ty).ptr_to();\n-                  Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, ty)], false)\n-              }\n-              _ => type_of(cx, ty).ptr_to(),\n+          } else {\n+              in_memory_type_of(cx, ty).ptr_to()\n           }\n       }\n \n       ty::ty_vec(ty, Some(size)) => {\n           let size = size as u64;\n-          let llty = type_of(cx, ty);\n+          let llty = in_memory_type_of(cx, ty);\n           ensure_array_fits_in_address_space(cx, llty, size, t);\n           Type::array(&llty, size)\n       }\n-      ty::ty_vec(ty, None) => {\n-          type_of(cx, ty)\n-      }\n \n-      ty::ty_trait(..) => {\n-          Type::opaque_trait_data(cx)\n-      }\n-\n-      ty::ty_str => Type::i8(cx),\n+      // Unsized slice types (and str) have the type of their element, and\n+      // traits have the type of u8. This is so that the data pointer inside\n+      // fat pointers is of the right type (e.g. for array accesses), even\n+      // when taking the address of an unsized field in a struct.\n+      ty::ty_vec(ty, None) => in_memory_type_of(cx, ty),\n+      ty::ty_str | ty::ty_trait(..) => Type::i8(cx),\n \n       ty::ty_bare_fn(..) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n@@ -388,7 +399,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n       }\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n-              let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n+              let llet = in_memory_type_of(cx, ty::simd_type(cx.tcx(), t));\n               let n = ty::simd_size(cx.tcx(), t) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n               Type::vector(&llet, n)\n@@ -398,29 +409,11 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n-              let name = llvm_type_name(cx, a_struct, did, tps);\n+              let name = llvm_type_name(cx, did, tps);\n               adt::incomplete_type_of(cx, &*repr, &name[..])\n           }\n       }\n \n-      ty::ty_open(t) => match t.sty {\n-          ty::ty_struct(..) => {\n-              let p_ty = type_of(cx, t).ptr_to();\n-              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n-          }\n-          ty::ty_vec(ty, None) => {\n-              let p_ty = type_of(cx, ty).ptr_to();\n-              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n-          }\n-          ty::ty_str => {\n-              let p_ty = Type::i8p(cx);\n-              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n-          }\n-          ty::ty_trait(..) => Type::opaque_trait(cx),\n-          _ => cx.sess().bug(&format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t)))\n-      },\n-\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_projection(..) => cx.sess().bug(\"type_of with ty_projection\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n@@ -444,7 +437,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         _ => ()\n     }\n \n-    return llty;\n+    llty\n }\n \n pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n@@ -453,37 +446,22 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     machine::llalign_of_min(cx, llty)\n }\n \n-// Want refinements! (Or case classes, I guess\n-#[derive(Copy)]\n-pub enum named_ty {\n-    a_struct,\n-    an_enum,\n-    a_closure,\n-}\n-\n-pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                what: named_ty,\n-                                did: ast::DefId,\n-                                tps: &[Ty<'tcx>])\n-                                -> String {\n-    let name = match what {\n-        a_struct => \"struct\",\n-        an_enum => \"enum\",\n-        a_closure => return \"closure\".to_string(),\n-    };\n-\n+fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                            did: ast::DefId,\n+                            tps: &[Ty<'tcx>])\n+                            -> String {\n     let base = ty::item_path_str(cx.tcx(), did);\n     let strings: Vec<String> = tps.iter().map(|t| t.repr(cx.tcx())).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {\n-        format!(\"{}<{:?}>\", base, strings)\n+        format!(\"{}<{}>\", base, strings.connect(\", \"))\n     };\n \n     if did.krate == 0 {\n-        format!(\"{}.{}\", name, tstr)\n+        tstr\n     } else {\n-        format!(\"{}.{}[{}{}]\", name, tstr, \"#\", did.krate)\n+        format!(\"{}.{}\", did.krate, tstr)\n     }\n }\n "}, {"sha": "581279c2c9ca89ee082120a71e87d96aced31f75", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -305,9 +305,9 @@ fn create_region_substs<'tcx>(\n             rscope.anon_regions(span, expected_num_region_params);\n \n         if supplied_num_region_params != 0 || anon_regions.is_err() {\n-            span_err!(tcx.sess, span, E0107,\n-                      \"wrong number of lifetime parameters: expected {}, found {}\",\n-                      expected_num_region_params, supplied_num_region_params);\n+            report_lifetime_number_error(tcx, span,\n+                                         supplied_num_region_params,\n+                                         expected_num_region_params);\n         }\n \n         match anon_regions {\n@@ -355,31 +355,14 @@ fn create_substs_for_ast_path<'tcx>(\n                                                .count();\n \n     let mut type_substs = types_provided;\n+    check_type_argument_count(this.tcx(), span, supplied_ty_param_count,\n+                              required_ty_param_count, formal_ty_param_count);\n+\n     if supplied_ty_param_count < required_ty_param_count {\n-        let expected = if required_ty_param_count < formal_ty_param_count {\n-            \"expected at least\"\n-        } else {\n-            \"expected\"\n-        };\n-        span_err!(this.tcx().sess, span, E0243,\n-                  \"wrong number of type arguments: {} {}, found {}\",\n-                  expected,\n-                  required_ty_param_count,\n-                  supplied_ty_param_count);\n         while type_substs.len() < required_ty_param_count {\n             type_substs.push(tcx.types.err);\n         }\n     } else if supplied_ty_param_count > formal_ty_param_count {\n-        let expected = if required_ty_param_count < formal_ty_param_count {\n-            \"expected at most\"\n-        } else {\n-            \"expected\"\n-        };\n-        span_err!(this.tcx().sess, span, E0244,\n-                  \"wrong number of type arguments: {} {}, found {}\",\n-                  expected,\n-                  formal_ty_param_count,\n-                  supplied_ty_param_count);\n         type_substs.truncate(formal_ty_param_count);\n     }\n     assert!(type_substs.len() >= required_ty_param_count &&\n@@ -1847,7 +1830,16 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,\n                                                      &mut builtin_bounds) {\n-                            // FIXME(#20302) -- we should check for things like Copy<T>\n+                            let segments = &b.trait_ref.path.segments;\n+                            let parameters = &segments[segments.len() - 1].parameters;\n+                            if parameters.types().len() > 0 {\n+                                check_type_argument_count(tcx, b.trait_ref.path.span,\n+                                                          parameters.types().len(), 0, 0);\n+                            }\n+                            if parameters.lifetimes().len() > 0{\n+                                report_lifetime_number_error(tcx, b.trait_ref.path.span,\n+                                                             parameters.lifetimes().len(), 0);\n+                            }\n                             continue; // success\n                         }\n                     }\n@@ -1880,3 +1872,34 @@ fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n             \"associated type bindings are not allowed here\");\n     }\n }\n+\n+fn check_type_argument_count(tcx: &ty::ctxt, span: Span, supplied: usize,\n+                             required: usize, accepted: usize) {\n+    if supplied < required {\n+        let expected = if required < accepted {\n+            \"expected at least\"\n+        } else {\n+            \"expected\"\n+        };\n+        span_err!(tcx.sess, span, E0243,\n+                  \"wrong number of type arguments: {} {}, found {}\",\n+                  expected, required, supplied);\n+    } else if supplied > accepted {\n+        let expected = if required < accepted {\n+            \"expected at most\"\n+        } else {\n+            \"expected\"\n+        };\n+        span_err!(tcx.sess, span, E0244,\n+                  \"wrong number of type arguments: {} {}, found {}\",\n+                  expected,\n+                  accepted,\n+                  supplied);\n+    }\n+}\n+\n+fn report_lifetime_number_error(tcx: &ty::ctxt, span: Span, number: usize, expected: usize) {\n+    span_err!(tcx.sess, span, E0107,\n+              \"wrong number of lifetime parameters: expected {}, found {}\",\n+              expected, number);\n+}"}, {"sha": "f65e585d23edd3c8c11e2ac3c11db443db9bd7ed", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -161,12 +161,6 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 //   entering the fn check. We should do this after\n                 //   the fn check, then we can call this case a bug().\n             }\n-\n-            ty::ty_open(_) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx())));\n-            }\n         }\n     }\n "}, {"sha": "d7db21f3a2f762350f94f0636886695f8b203fbf", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -404,26 +404,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                all_substs.repr(self.tcx()));\n \n         // Instantiate the bounds on the method with the\n-        // type/early-bound-regions substitutions performed.  The only\n-        // late-bound-regions that can appear in bounds are from the\n-        // impl, and those were already instantiated above.\n-        //\n-        // FIXME(DST). Super hack. For a method on a trait object\n-        // `Trait`, the generic signature requires that\n-        // `Self:Trait`. Since, for an object, we bind `Self` to the\n-        // type `Trait`, this leads to an obligation\n-        // `Trait:Trait`. Until such time we DST is fully implemented,\n-        // that obligation is not necessarily satisfied. (In the\n-        // future, it would be.) But we know that the true `Self` DOES implement\n-        // the trait. So we just delete this requirement. Hack hack hack.\n-        let mut method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n-        match pick.kind {\n-            probe::ObjectPick(..) => {\n-                assert_eq!(method_predicates.predicates.get_slice(subst::SelfSpace).len(), 1);\n-                method_predicates.predicates.pop(subst::SelfSpace);\n-            }\n-            _ => { }\n-        }\n+        // type/early-bound-regions substitutions performed. There can\n+        // be no late-bound regions appearing here.\n+        let method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n         let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n                                                                        &method_predicates);\n "}, {"sha": "630530cf11f841186dcb2e0c899e2b6d1ab28661", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -133,14 +133,6 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                      in the supertrait listing\");\n             }\n \n-            ObjectSafetyViolation::Method(method, MethodViolationCode::ByValueSelf) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` has a receiver type of `Self`, \\\n-                              which cannot be used with a trait object\",\n-                             method.name.user_string(tcx)));\n-            }\n-\n             ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n                 tcx.sess.span_note(\n                     span,"}, {"sha": "7dac1eeb6f11723d95acf77184e164a6c7a24d8d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -25,7 +25,7 @@ use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int};\n use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::{ty_projection};\n use middle::ty;\n@@ -75,7 +75,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_tup(..) |\n-        ty_param(..) | ty_err | ty_open(..) |\n+        ty_param(..) | ty_err |\n         ty_ptr(_) | ty_rptr(_, _) | ty_projection(..) => {\n             None\n         }"}, {"sha": "90ca6a798056bf6e7694e1ea893f76888fa75a9f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -849,7 +849,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::ty_uniq(typ) | ty::ty_vec(typ, _) | ty::ty_open(typ) => {\n+            ty::ty_uniq(typ) | ty::ty_vec(typ, _) => {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n "}, {"sha": "a3e0cecdd4826092f506d16c2824e013f86c9d87", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -1619,7 +1619,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::ty_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n-            ty::ty_open(..) => panic!(\"ty_open\"),\n             ty::ty_err => panic!(\"ty_err\"),\n         }\n     }"}, {"sha": "94457a5d71441b784dc52e9969f6d5e77703ea60", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -37,6 +37,7 @@ pub trait OwnedAsciiExt {\n /// Extension methods for ASCII-subset only operations on string slices\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsciiExt {\n+    /// Container type for copied ASCII characters.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Owned;\n "}, {"sha": "3a06d2d03bf3f7046ec7c74479f9936abb704be8", "filename": "src/libstd/collections/hash/state.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -27,6 +27,7 @@ use marker;\n /// to `Default` when asked to create a hasher.\n #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n pub trait HashState {\n+    /// Type of the hasher that will be created.\n     type Hasher: hash::Hasher;\n \n     /// Creates a new hasher based on the given state of this object."}, {"sha": "82b69ddebff68630fcf70bf1da0d61c342ed754b", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -12,27 +12,47 @@ use core::prelude::*;\n \n use boxed::Box;\n use cmp;\n-use io::{self, SeekFrom, Read, Write, Seek, BufRead};\n+use io::{self, SeekFrom, Read, Write, Seek, BufRead, Error, ErrorKind};\n+use fmt;\n use mem;\n use slice;\n+use string::String;\n use vec::Vec;\n \n // =============================================================================\n // Forwarding implementations\n \n impl<'a, R: Read + ?Sized> Read for &'a mut R {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> { (**self).read_to_end(buf) }\n+\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n+        (**self).read_to_string(buf)\n+    }\n }\n impl<'a, W: Write + ?Sized> Write for &'a mut W {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> { (**self).write_all(buf) }\n+\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> { (**self).write_fmt(fmt) }\n+\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n }\n impl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n }\n impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+\n     fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<()> {\n+        (**self).read_until(byte, buf)\n+    }\n+\n+    fn read_line(&mut self, buf: &mut String) -> io::Result<()> { (**self).read_line(buf) }\n }\n \n impl<R: Read + ?Sized> Read for Box<R> {\n@@ -76,6 +96,15 @@ impl<'a> Write for &'a mut [u8] {\n         *self = b;\n         Ok(amt)\n     }\n+\n+    fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n+        if try!(self.write(data)) == data.len() {\n+            Ok(())\n+        } else {\n+            Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\", None))\n+        }\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -84,5 +113,11 @@ impl Write for Vec<u8> {\n         self.push_all(buf);\n         Ok(buf.len())\n     }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        try!(self.write(buf));\n+        Ok(())\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }"}, {"sha": "dad0ff0a15e299424d265b076d15f20f229c525b", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -23,7 +23,6 @@\n #[doc(no_inline)] pub use mem::drop;\n \n // Reexported types and traits\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use boxed::Box;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -45,9 +44,7 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use slice::AsSlice;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n+#[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt, AsSlice};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use str::{Str, StrExt};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f697d10d5dfab14ad5f85ee1db0a45569f89fc52", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -33,13 +33,13 @@ use sync::{Mutex, Condvar};\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n-    num_threads: uint,\n+    num_threads: usize,\n }\n \n // The inner state of a double barrier\n struct BarrierState {\n-    count: uint,\n-    generation_id: uint,\n+    count: usize,\n+    generation_id: usize,\n }\n \n /// A result returned from wait.\n@@ -54,7 +54,7 @@ impl Barrier {\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(n: uint) -> Barrier {\n+    pub fn new(n: usize) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n                 count: 0,\n@@ -115,7 +115,7 @@ mod tests {\n \n     #[test]\n     fn test_barrier() {\n-        const N: uint = 10;\n+        const N: usize = 10;\n \n         let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();"}, {"sha": "aa87abc6e9aacdecce704f680c08911e2888d780", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -327,7 +327,7 @@ impl StaticCondvar {\n     }\n \n     fn verify(&self, mutex: &sys_mutex::Mutex) {\n-        let addr = mutex as *const _ as uint;\n+        let addr = mutex as *const _ as usize;\n         match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar.\n@@ -388,7 +388,7 @@ mod tests {\n \n     #[test]\n     fn notify_all() {\n-        const N: uint = 10;\n+        const N: usize = 10;\n \n         let data = Arc::new((Mutex::new(0), Condvar::new()));\n         let (tx, rx) = channel();"}, {"sha": "2e4155ea35128d070c7854e304a40b58a30a87ac", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -61,17 +61,17 @@ impl SignalToken {\n         wake\n     }\n \n-    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n+    /// Convert to an unsafe usize value. Useful for storing in a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_to_uint(self) -> uint {\n+    pub unsafe fn cast_to_usize(self) -> usize {\n         mem::transmute(self.inner)\n     }\n \n-    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n+    /// Convert from an unsafe usize value. Useful for retrieving a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_from_uint(signal_ptr: uint) -> SignalToken {\n+    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n         SignalToken { inner: mem::transmute(signal_ptr) }\n     }\n "}, {"sha": "7bd1f3542eb13828ca4a2806e53a623bc8c68e45", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -94,7 +94,7 @@\n //!\n //! // The call to recv() will return an error because the channel has already\n //! // hung up (or been deallocated)\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! drop(tx);\n //! assert!(rx.recv().is_err());\n //! ```\n@@ -105,7 +105,7 @@\n //! use std::thread;\n //! use std::sync::mpsc::sync_channel;\n //!\n-//! let (tx, rx) = sync_channel::<int>(0);\n+//! let (tx, rx) = sync_channel::<i32>(0);\n //! thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53).unwrap();\n@@ -123,7 +123,7 @@\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! let mut timer = Timer::new().unwrap();\n //! let timeout = timer.oneshot(Duration::seconds(10));\n //!\n@@ -147,7 +147,7 @@\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! let mut timer = Timer::new().unwrap();\n //!\n //! loop {\n@@ -525,7 +525,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n+pub fn sync_channel<T: Send>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n@@ -1028,7 +1028,7 @@ mod test {\n     use super::*;\n     use thread;\n \n-    pub fn stress_factor() -> uint {\n+    pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n             Ok(val) => val.parse().unwrap(),\n             Err(..) => 1,\n@@ -1037,7 +1037,7 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n@@ -1058,7 +1058,7 @@ mod test {\n \n     #[test]\n     fn smoke_shared() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n@@ -1068,7 +1068,7 @@ mod test {\n \n     #[test]\n     fn smoke_threads() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n@@ -1077,21 +1077,21 @@ mod test {\n \n     #[test]\n     fn smoke_port_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn smoke_shared_port_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(1).is_err())\n     }\n \n     #[test]\n     fn smoke_shared_port_gone2() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n@@ -1100,7 +1100,7 @@ mod test {\n \n     #[test]\n     fn port_gone_concurrent() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n@@ -1109,7 +1109,7 @@ mod test {\n \n     #[test]\n     fn port_gone_concurrent_shared() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n@@ -1119,7 +1119,7 @@ mod test {\n \n     #[test]\n     fn smoke_chan_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n@@ -1135,7 +1135,7 @@ mod test {\n \n     #[test]\n     fn chan_gone_concurrent() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n@@ -1145,7 +1145,7 @@ mod test {\n \n     #[test]\n     fn stress() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n             for _ in 0..10000 { tx.send(1).unwrap(); }\n         });\n@@ -1157,9 +1157,9 @@ mod test {\n \n     #[test]\n     fn stress_shared() {\n-        static AMT: uint = 10000;\n-        static NTHREADS: uint = 8;\n-        let (tx, rx) = channel::<int>();\n+        static AMT: u32 = 10000;\n+        static NTHREADS: u32 = 8;\n+        let (tx, rx) = channel::<i32>();\n \n         let t = thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n@@ -1184,7 +1184,7 @@ mod test {\n     #[test]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx2, rx2) = channel::<i32>();\n         let t1 = thread::spawn(move|| {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n@@ -1203,7 +1203,7 @@ mod test {\n \n     #[test]\n     fn recv_from_outside_runtime() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n@@ -1217,8 +1217,8 @@ mod test {\n \n     #[test]\n     fn no_runtime() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let t1 = thread::spawn(move|| {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n@@ -1234,21 +1234,21 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (_tx, rx) = channel::<int>();\n+        let (_tx, rx) = channel::<i32>();\n         drop(rx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (tx, _rx) = channel::<int>();\n+        let (tx, _rx) = channel::<i32>();\n         drop(tx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         drop(rx);\n         assert!(tx.send(box 0).is_err());\n     }\n@@ -1257,7 +1257,7 @@ mod test {\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             drop(tx);\n             rx.recv().unwrap();\n         }).join();\n@@ -1267,64 +1267,64 @@ mod test {\n \n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         tx.send(box 10).unwrap();\n         assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         assert!(tx.send(10).is_ok());\n         assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(10).is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(10).unwrap();\n         assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n         tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n-        let (_tx, rx) = channel::<int>();\n+        let (_tx, rx) = channel::<i32>();\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n@@ -1334,7 +1334,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n@@ -1347,7 +1347,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1358,7 +1358,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1371,7 +1371,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             thread::spawn(move|| {\n                 let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n@@ -1405,7 +1405,7 @@ mod test {\n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: Sender<Box<int>>, i: int) {\n+            fn send(tx: Sender<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1414,7 +1414,7 @@ mod test {\n                 });\n             }\n \n-            fn recv(rx: Receiver<Box<int>>, i: int) {\n+            fn recv(rx: Receiver<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1451,8 +1451,8 @@ mod test {\n \n     #[test]\n     fn test_nested_recv_iter() {\n-        let (tx, rx) = channel::<int>();\n-        let (total_tx, total_rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n+        let (total_tx, total_rx) = channel::<i32>();\n \n         let _t = thread::spawn(move|| {\n             let mut acc = 0;\n@@ -1471,7 +1471,7 @@ mod test {\n \n     #[test]\n     fn test_recv_iter_break() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n \n         let _t = thread::spawn(move|| {\n@@ -1496,7 +1496,7 @@ mod test {\n \n     #[test]\n     fn try_recv_states() {\n-        let (tx1, rx1) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n         let _t = thread::spawn(move|| {\n@@ -1550,7 +1550,7 @@ mod sync_tests {\n     use thread;\n     use super::*;\n \n-    pub fn stress_factor() -> uint {\n+    pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n             Ok(val) => val.parse().unwrap(),\n             Err(..) => 1,\n@@ -1559,7 +1559,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n@@ -1572,7 +1572,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_shared() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n@@ -1582,7 +1582,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_threads() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n@@ -1591,14 +1591,14 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_port_gone() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn smoke_shared_port_gone2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n@@ -1607,7 +1607,7 @@ mod sync_tests {\n \n     #[test]\n     fn port_gone_concurrent() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n@@ -1616,7 +1616,7 @@ mod sync_tests {\n \n     #[test]\n     fn port_gone_concurrent_shared() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n@@ -1626,7 +1626,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_chan_gone() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n@@ -1642,7 +1642,7 @@ mod sync_tests {\n \n     #[test]\n     fn chan_gone_concurrent() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n@@ -1652,7 +1652,7 @@ mod sync_tests {\n \n     #[test]\n     fn stress() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n             for _ in 0..10000 { tx.send(1).unwrap(); }\n         });\n@@ -1663,9 +1663,9 @@ mod sync_tests {\n \n     #[test]\n     fn stress_shared() {\n-        static AMT: uint = 1000;\n-        static NTHREADS: uint = 8;\n-        let (tx, rx) = sync_channel::<int>(0);\n+        static AMT: u32 = 1000;\n+        static NTHREADS: u32 = 8;\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n         thread::spawn(move|| {\n@@ -1692,21 +1692,21 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (_tx, rx) = sync_channel::<int>(0);\n+        let (_tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         drop(tx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         drop(rx);\n         assert!(tx.send(box 0).is_err());\n     }\n@@ -1715,7 +1715,7 @@ mod sync_tests {\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             drop(tx);\n             rx.recv().unwrap();\n         }).join();\n@@ -1725,70 +1725,70 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = sync_channel::<Box<int>>(1);\n+        let (tx, rx) = sync_channel::<Box<i32>>(1);\n         tx.send(box 10).unwrap();\n         assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n         assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         assert_eq!(tx.try_send(10), Err(TrySendError::Disconnected(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed2() {\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         assert_eq!(tx.try_send(10), Err(TrySendError::Full(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(10).unwrap();\n         assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n         tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n-        let (_tx, rx) = sync_channel::<int>(0);\n+        let (_tx, rx) = sync_channel::<i32>(0);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n@@ -1798,7 +1798,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n@@ -1811,7 +1811,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1822,7 +1822,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1835,7 +1835,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n@@ -1853,7 +1853,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<Box<int>>(0);\n+            let (tx, rx) = sync_channel::<Box<i32>>(0);\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n@@ -1864,12 +1864,12 @@ mod sync_tests {\n     #[test]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<Box<int>>(0);\n+            let (tx, rx) = sync_channel::<Box<i32>>(0);\n \n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: SyncSender<Box<int>>, i: int) {\n+            fn send(tx: SyncSender<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1878,7 +1878,7 @@ mod sync_tests {\n                 });\n             }\n \n-            fn recv(rx: Receiver<Box<int>>, i: int) {\n+            fn recv(rx: Receiver<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1915,8 +1915,8 @@ mod sync_tests {\n \n     #[test]\n     fn test_nested_recv_iter() {\n-        let (tx, rx) = sync_channel::<int>(0);\n-        let (total_tx, total_rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n+        let (total_tx, total_rx) = sync_channel::<i32>(0);\n \n         let _t = thread::spawn(move|| {\n             let mut acc = 0;\n@@ -1935,7 +1935,7 @@ mod sync_tests {\n \n     #[test]\n     fn test_recv_iter_break() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n         let _t = thread::spawn(move|| {\n@@ -1960,7 +1960,7 @@ mod sync_tests {\n \n     #[test]\n     fn try_recv_states() {\n-        let (tx1, rx1) = sync_channel::<int>(1);\n+        let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n         let _t = thread::spawn(move|| {\n@@ -2007,29 +2007,29 @@ mod sync_tests {\n \n     #[test]\n     fn send1() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n         let _t =thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send4() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n@@ -2048,20 +2048,20 @@ mod sync_tests {\n \n     #[test]\n     fn try_send1() {\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send2() {\n-        let (tx, _rx) = sync_channel::<int>(1);\n+        let (tx, _rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send3() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n         assert_eq!(tx.try_send(1), Err(TrySendError::Disconnected(1)));"}, {"sha": "f287712d9d45d59bdc2eb7745ed4ddd468092fe0", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -22,7 +22,7 @@\n ///\n /// # Implementation\n ///\n-/// Oneshots are implemented around one atomic uint variable. This variable\n+/// Oneshots are implemented around one atomic usize variable. This variable\n /// indicates both the state of the port/chan but also contains any tasks\n /// blocked on the port. All atomic operations happen on this one word.\n ///\n@@ -45,9 +45,9 @@ use core::mem;\n use sync::atomic::{AtomicUsize, Ordering};\n \n // Various states you can find a port in.\n-const EMPTY: uint = 0;          // initial state: no data, no blocked receiver\n-const DATA: uint = 1;           // data ready for receiver to take\n-const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n+const EMPTY: usize = 0;          // initial state: no data, no blocked receiver\n+const DATA: usize = 1;           // data ready for receiver to take\n+const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The\n // protocol ensures that when the state moves *to* a pointer,\n // ownership of the token is given to the packet, and when the state\n@@ -123,7 +123,7 @@ impl<T: Send> Packet<T> {\n             // There is a thread waiting on the other end. We leave the 'DATA'\n             // state inside so it'll pick it up on the other end.\n             ptr => unsafe {\n-                SignalToken::cast_from_uint(ptr).signal();\n+                SignalToken::cast_from_usize(ptr).signal();\n                 Ok(())\n             }\n         }\n@@ -143,15 +143,15 @@ impl<T: Send> Packet<T> {\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n-            let ptr = unsafe { signal_token.cast_to_uint() };\n+            let ptr = unsafe { signal_token.cast_to_usize() };\n \n             // race with senders to enter the blocking state\n             if self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) == EMPTY {\n                 wait_token.wait();\n                 debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n             } else {\n                 // drop the signal token, since we never blocked\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n             }\n         }\n \n@@ -220,7 +220,7 @@ impl<T: Send> Packet<T> {\n             DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n \n             // If someone's waiting, we gotta wake them up\n-            ptr => UpWoke(unsafe { SignalToken::cast_from_uint(ptr) })\n+            ptr => UpWoke(unsafe { SignalToken::cast_from_usize(ptr) })\n         }\n     }\n \n@@ -230,7 +230,7 @@ impl<T: Send> Packet<T> {\n \n             // If someone's waiting, we gotta wake them up\n             ptr => unsafe {\n-                SignalToken::cast_from_uint(ptr).signal();\n+                SignalToken::cast_from_usize(ptr).signal();\n             }\n         }\n     }\n@@ -283,15 +283,15 @@ impl<T: Send> Packet<T> {\n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n     pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n             EMPTY => SelSuccess,\n             DATA => {\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                 SelCanceled\n             }\n             DISCONNECTED if self.data.is_some() => {\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                 SelCanceled\n             }\n             DISCONNECTED => {\n@@ -300,15 +300,15 @@ impl<T: Send> Packet<T> {\n                     // propagate upwards whether the upgrade can receive\n                     // data\n                     GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { SignalToken::cast_from_uint(ptr) }, upgrade)\n+                        SelUpgraded(unsafe { SignalToken::cast_from_usize(ptr) }, upgrade)\n                     }\n \n                     // If the other end disconnected without sending an\n                     // upgrade, then we have data to receive (the channel is\n                     // disconnected).\n                     up => {\n                         self.upgrade = up;\n-                        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                         SelCanceled\n                     }\n                 }\n@@ -360,7 +360,7 @@ impl<T: Send> Packet<T> {\n \n             // We woke ourselves up from select.\n             ptr => unsafe {\n-                drop(SignalToken::cast_from_uint(ptr));\n+                drop(SignalToken::cast_from_usize(ptr));\n                 Ok(false)\n             }\n         }"}, {"sha": "8de5bbc6206658c10d740bc67974e19edb00434f", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -71,7 +71,7 @@ use sync::mpsc::blocking::{self, SignalToken};\n pub struct Select {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n-    next_id: Cell<uint>,\n+    next_id: Cell<usize>,\n }\n \n impl !marker::Send for Select {}\n@@ -82,7 +82,7 @@ impl !marker::Send for Select {}\n pub struct Handle<'rx, T:'rx> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n-    id: uint,\n+    id: usize,\n     selector: &'rx Select,\n     next: *mut Handle<'static, ()>,\n     prev: *mut Handle<'static, ()>,\n@@ -154,12 +154,12 @@ impl Select {\n     /// the matching `id` will have some sort of event available on it. The\n     /// event could either be that data is available or the corresponding\n     /// channel has been closed.\n-    pub fn wait(&self) -> uint {\n+    pub fn wait(&self) -> usize {\n         self.wait2(true)\n     }\n \n     /// Helper method for skipping the preflight checks during testing\n-    fn wait2(&self, do_preflight_checks: bool) -> uint {\n+    fn wait2(&self, do_preflight_checks: bool) -> usize {\n         // Note that this is currently an inefficient implementation. We in\n         // theory have knowledge about all receivers in the set ahead of time,\n         // so this method shouldn't really have to iterate over all of them yet\n@@ -254,7 +254,7 @@ impl Select {\n impl<'rx, T: Send> Handle<'rx, T> {\n     /// Retrieve the id of this handle.\n     #[inline]\n-    pub fn id(&self) -> uint { self.id }\n+    pub fn id(&self) -> usize { self.id }\n \n     /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n@@ -369,8 +369,8 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         tx1.send(1).unwrap();\n         select! {\n             foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n@@ -394,11 +394,11 @@ mod test {\n \n     #[test]\n     fn smoke2() {\n-        let (_tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n-        let (_tx3, rx3) = channel::<int>();\n-        let (_tx4, rx4) = channel::<int>();\n-        let (tx5, rx5) = channel::<int>();\n+        let (_tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n+        let (_tx3, rx3) = channel::<i32>();\n+        let (_tx4, rx4) = channel::<i32>();\n+        let (tx5, rx5) = channel::<i32>();\n         tx5.send(4).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!(\"1\") },\n@@ -411,8 +411,8 @@ mod test {\n \n     #[test]\n     fn closed() {\n-        let (_tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (_tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         drop(tx2);\n \n         select! {\n@@ -423,9 +423,9 @@ mod test {\n \n     #[test]\n     fn unblocks() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n-        let (tx3, rx3) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n+        let (tx3, rx3) = channel::<i32>();\n \n         let _t = thread::spawn(move|| {\n             for _ in 0..20 { thread::yield_now(); }\n@@ -447,8 +447,8 @@ mod test {\n \n     #[test]\n     fn both_ready() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -473,9 +473,9 @@ mod test {\n \n     #[test]\n     fn stress() {\n-        static AMT: int = 10000;\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        static AMT: i32 = 10000;\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -500,8 +500,8 @@ mod test {\n \n     #[test]\n     fn cloning() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -522,8 +522,8 @@ mod test {\n \n     #[test]\n     fn cloning2() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -716,7 +716,7 @@ mod test {\n \n     #[test]\n     fn sync1() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         select! {\n             n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n@@ -725,7 +725,7 @@ mod test {\n \n     #[test]\n     fn sync2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             for _ in 0..100 { thread::yield_now() }\n             tx.send(1).unwrap();\n@@ -737,8 +737,8 @@ mod test {\n \n     #[test]\n     fn sync3() {\n-        let (tx1, rx1) = sync_channel::<int>(0);\n-        let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n+        let (tx1, rx1) = sync_channel::<i32>(0);\n+        let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n         let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n         let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {"}, {"sha": "8d14824d37feed09e3e0c9916b2b2431b8897b4b", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -101,7 +101,7 @@ impl<T: Send> Packet<T> {\n         token.map(|token| {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-            self.to_wake.store(unsafe { token.cast_to_uint() }, Ordering::SeqCst);\n+            self.to_wake.store(unsafe { token.cast_to_usize() }, Ordering::SeqCst);\n             self.cnt.store(-1, Ordering::SeqCst);\n \n             // This store is a little sketchy. What's happening here is that\n@@ -241,7 +241,7 @@ impl<T: Send> Packet<T> {\n     // Returns true if blocking should proceed.\n     fn decrement(&mut self, token: SignalToken) -> StartResult {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n@@ -258,7 +258,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, Ordering::SeqCst);\n-        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n         Abort\n     }\n \n@@ -380,7 +380,7 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n \n     ////////////////////////////////////////////////////////////////////////////"}, {"sha": "ce40fa2672ab32555339aca56e87deed24dbf4a9", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -69,7 +69,7 @@ pub struct Queue<T> {\n \n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n-    cache_bound: uint,\n+    cache_bound: usize,\n     cache_additions: AtomicUsize,\n     cache_subtractions: AtomicUsize,\n }\n@@ -107,7 +107,7 @@ impl<T: Send> Queue<T> {\n     ///               cache (if desired). If the value is 0, then the cache has\n     ///               no bound. Otherwise, the cache will never grow larger than\n     ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn new(bound: uint) -> Queue<T> {\n+    pub unsafe fn new(bound: usize) -> Queue<T> {\n         let n1 = Node::new();\n         let n2 = Node::new();\n         (*n1).next.store(n2, Ordering::Relaxed);\n@@ -319,7 +319,7 @@ mod test {\n             stress_bound(1);\n         }\n \n-        unsafe fn stress_bound(bound: uint) {\n+        unsafe fn stress_bound(bound: usize) {\n             let q = Arc::new(Queue::new(bound));\n \n             let (tx, rx) = channel();"}, {"sha": "5a1e05f9c1565e1e28512f51685cc5b59849b20a", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -43,7 +43,7 @@ pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: int, // How many times has a port received without blocking?\n+    steals: isize, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n@@ -146,15 +146,15 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n     fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n@@ -171,7 +171,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, Ordering::SeqCst);\n-        Err(unsafe { SignalToken::cast_from_uint(ptr) })\n+        Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n@@ -350,7 +350,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: int) -> int {\n+    fn bump(&mut self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);"}, {"sha": "33c1614e1b297dfe7037782d6533c6c6fe19a943", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -64,7 +64,7 @@ struct State<T> {\n     queue: Queue,       // queue of senders waiting to send data\n     blocker: Blocker,   // currently blocked task on this channel\n     buf: Buffer<T>,     // storage for buffered messages\n-    cap: uint,          // capacity of this channel\n+    cap: usize,         // capacity of this channel\n \n     /// A curious flag used to indicate whether a sender failed or succeeded in\n     /// blocking. This is used to transmit information back to the task that it\n@@ -101,8 +101,8 @@ unsafe impl Send for Node {}\n /// A simple ring-buffer\n struct Buffer<T> {\n     buf: Vec<Option<T>>,\n-    start: uint,\n-    size: uint,\n+    start: usize,\n+    size: usize,\n }\n \n #[derive(Debug)]\n@@ -137,7 +137,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n }\n \n impl<T: Send> Packet<T> {\n-    pub fn new(cap: uint) -> Packet<T> {\n+    pub fn new(cap: usize) -> Packet<T> {\n         Packet {\n             channels: AtomicUsize::new(1),\n             lock: Mutex::new(State {\n@@ -442,8 +442,8 @@ impl<T> Buffer<T> {\n         result.take().unwrap()\n     }\n \n-    fn size(&self) -> uint { self.size }\n-    fn cap(&self) -> uint { self.buf.len() }\n+    fn size(&self) -> usize { self.size }\n+    fn cap(&self) -> usize { self.buf.len() }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "02b2db572ec4fe49be4efa50643560b4638c759d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -50,7 +50,7 @@ use sys_common::mutex as sys;\n /// use std::thread;\n /// use std::sync::mpsc::channel;\n ///\n-/// const N: uint = 10;\n+/// const N: usize = 10;\n ///\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n /// // let the main thread know once all increments are done.\n@@ -377,9 +377,9 @@ mod test {\n     #[test]\n     fn lots_and_lots() {\n         static M: StaticMutex = MUTEX_INIT;\n-        static mut CNT: uint = 0;\n-        static J: uint = 1000;\n-        static K: uint = 3;\n+        static mut CNT: u32 = 0;\n+        static J: u32 = 1000;\n+        static K: u32 = 3;\n \n         fn inc() {\n             for _ in 0..J {\n@@ -501,7 +501,7 @@ mod test {\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<Mutex<int>>,\n+                i: Arc<Mutex<i32>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}, {"sha": "31f3dfd877cfb682f6e2208d30dc6f48f27ec0ad", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -89,7 +89,7 @@ impl TaskPool {\n     /// # Panics\n     ///\n     /// This function will panic if `threads` is 0.\n-    pub fn new(threads: uint) -> TaskPool {\n+    pub fn new(threads: usize) -> TaskPool {\n         assert!(threads >= 1);\n \n         let (tx, rx) = channel::<Thunk>();\n@@ -142,7 +142,7 @@ mod test {\n     use super::*;\n     use sync::mpsc::channel;\n \n-    const TEST_TASKS: uint = 4;\n+    const TEST_TASKS: usize = 4;\n \n     #[test]\n     fn test_works() {"}, {"sha": "c6b9c2cba5227f34190513944b590aaf5b2169dc", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -18,7 +18,7 @@ use libc::{self, c_int, c_void, size_t, off_t, c_char, mode_t};\n use mem;\n use path::{Path, PathBuf};\n use ptr;\n-use rc::Rc;\n+use sync::Arc;\n use sys::fd::FileDesc;\n use sys::{c, cvt, cvt_r};\n use sys_common::FromInner;\n@@ -31,14 +31,18 @@ pub struct FileAttr {\n }\n \n pub struct ReadDir {\n-    dirp: *mut libc::DIR,\n-    root: Rc<PathBuf>,\n+    dirp: Dir,\n+    root: Arc<PathBuf>,\n }\n \n+struct Dir(*mut libc::DIR);\n+\n+unsafe impl Send for Dir {}\n+unsafe impl Sync for Dir {}\n+\n pub struct DirEntry {\n-    buf: Vec<u8>,\n-    dirent: *mut libc::dirent_t,\n-    root: Rc<PathBuf>,\n+    buf: Vec<u8>, // actually *mut libc::dirent_t\n+    root: Arc<PathBuf>,\n }\n \n #[derive(Clone)]\n@@ -109,7 +113,7 @@ impl Iterator for ReadDir {\n \n         let mut entry_ptr = ptr::null_mut();\n         loop {\n-            if unsafe { libc::readdir_r(self.dirp, ptr, &mut entry_ptr) != 0 } {\n+            if unsafe { libc::readdir_r(self.dirp.0, ptr, &mut entry_ptr) != 0 } {\n                 return Some(Err(Error::last_os_error()))\n             }\n             if entry_ptr.is_null() {\n@@ -118,7 +122,6 @@ impl Iterator for ReadDir {\n \n             let entry = DirEntry {\n                 buf: buf,\n-                dirent: entry_ptr,\n                 root: self.root.clone()\n             };\n             if entry.name_bytes() == b\".\" || entry.name_bytes() == b\"..\" {\n@@ -130,9 +133,9 @@ impl Iterator for ReadDir {\n     }\n }\n \n-impl Drop for ReadDir {\n+impl Drop for Dir {\n     fn drop(&mut self) {\n-        let r = unsafe { libc::closedir(self.dirp) };\n+        let r = unsafe { libc::closedir(self.0) };\n         debug_assert_eq!(r, 0);\n     }\n }\n@@ -147,9 +150,13 @@ impl DirEntry {\n             fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;\n         }\n         unsafe {\n-            CStr::from_ptr(rust_list_dir_val(self.dirent)).to_bytes()\n+            CStr::from_ptr(rust_list_dir_val(self.dirent())).to_bytes()\n         }\n     }\n+\n+    fn dirent(&self) -> *mut libc::dirent_t {\n+        self.buf.as_ptr() as *mut _\n+    }\n }\n \n impl OpenOptions {\n@@ -279,14 +286,14 @@ pub fn mkdir(p: &Path) -> io::Result<()> {\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = Rc::new(p.to_path_buf());\n+    let root = Arc::new(p.to_path_buf());\n     let p = try!(cstr(p));\n     unsafe {\n         let ptr = libc::opendir(p.as_ptr());\n         if ptr.is_null() {\n             Err(Error::last_os_error())\n         } else {\n-            Ok(ReadDir { dirp: ptr, root: root })\n+            Ok(ReadDir { dirp: Dir(ptr), root: root })\n         }\n     }\n }"}, {"sha": "117f819eeeb3fd870ac36dc485d6874630ad0ced", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -19,6 +19,7 @@ use libc::{self, HANDLE};\n use mem;\n use path::{Path, PathBuf};\n use ptr;\n+use sync::Arc;\n use sys::handle::Handle as RawHandle;\n use sys::{c, cvt};\n use vec::Vec;\n@@ -27,12 +28,20 @@ pub struct File { handle: RawHandle }\n pub struct FileAttr { data: c::WIN32_FILE_ATTRIBUTE_DATA }\n \n pub struct ReadDir {\n-    handle: libc::HANDLE,\n-    root: PathBuf,\n+    handle: FindNextFileHandle,\n+    root: Arc<PathBuf>,\n     first: Option<libc::WIN32_FIND_DATAW>,\n }\n \n-pub struct DirEntry { path: PathBuf }\n+struct FindNextFileHandle(libc::HANDLE);\n+\n+unsafe impl Send for FindNextFileHandle {}\n+unsafe impl Sync for FindNextFileHandle {}\n+\n+pub struct DirEntry {\n+    root: Arc<PathBuf>,\n+    data: libc::WIN32_FIND_DATAW,\n+}\n \n #[derive(Clone, Default)]\n pub struct OpenOptions {\n@@ -61,7 +70,7 @@ impl Iterator for ReadDir {\n         unsafe {\n             let mut wfd = mem::zeroed();\n             loop {\n-                if libc::FindNextFileW(self.handle, &mut wfd) == 0 {\n+                if libc::FindNextFileW(self.handle.0, &mut wfd) == 0 {\n                     if libc::GetLastError() ==\n                         c::ERROR_NO_MORE_FILES as libc::DWORD {\n                         return None\n@@ -77,29 +86,31 @@ impl Iterator for ReadDir {\n     }\n }\n \n-impl Drop for ReadDir {\n+impl Drop for FindNextFileHandle {\n     fn drop(&mut self) {\n-        let r = unsafe { libc::FindClose(self.handle) };\n+        let r = unsafe { libc::FindClose(self.0) };\n         debug_assert!(r != 0);\n     }\n }\n \n impl DirEntry {\n-    fn new(root: &Path, wfd: &libc::WIN32_FIND_DATAW) -> Option<DirEntry> {\n+    fn new(root: &Arc<PathBuf>, wfd: &libc::WIN32_FIND_DATAW) -> Option<DirEntry> {\n         match &wfd.cFileName[0..3] {\n             // check for '.' and '..'\n             [46, 0, ..] |\n             [46, 46, 0, ..] => return None,\n             _ => {}\n         }\n \n-        let filename = super::truncate_utf16_at_nul(&wfd.cFileName);\n-        let filename: OsString = OsStringExt::from_wide(filename);\n-        Some(DirEntry { path: root.join(&filename) })\n+        Some(DirEntry {\n+            root: root.clone(),\n+            data: *wfd,\n+        })\n     }\n \n     pub fn path(&self) -> PathBuf {\n-        self.path.clone()\n+        let filename = super::truncate_utf16_at_nul(&self.data.cFileName);\n+        self.root.join(&<OsString as OsStringExt>::from_wide(filename))\n     }\n }\n \n@@ -312,7 +323,11 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n         let mut wfd = mem::zeroed();\n         let find_handle = libc::FindFirstFileW(path.as_ptr(), &mut wfd);\n         if find_handle != libc::INVALID_HANDLE_VALUE {\n-            Ok(ReadDir { handle: find_handle, root: root, first: Some(wfd) })\n+            Ok(ReadDir {\n+                handle: FindNextFileHandle(find_handle),\n+                root: Arc::new(root),\n+                first: Some(wfd),\n+            })\n         } else {\n             Err(Error::last_os_error())\n         }"}, {"sha": "6aad2bbcc7f08b47ab57f6dbd0f097cedbd2ce08", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -342,12 +342,15 @@ impl Builder {\n     }\n }\n \n-/// Spawn a new, returning a join handle for it.\n+/// Spawn a new thread, returning a `JoinHandle` for it.\n ///\n-/// The child thread may outlive the parent (unless the parent thread\n-/// is the main thread; the whole process is terminated when the main\n-/// thread finishes.) The join handle can be used to block on\n-/// termination of the child thread, including recovering its panics.\n+/// The join handle will implicitly *detach* the child thread upon being\n+/// dropped. In this case, the child thread may outlive the parent (unless\n+/// the parent thread is the main thread; the whole process is terminated when\n+/// the main thread finishes.) Additionally, the join handle provides a `join`\n+/// method that can be used to join the child thread. If the child thread\n+/// panics, `join` will return an `Err` containing the argument given to\n+/// `panic`.\n ///\n /// # Panics\n ///"}, {"sha": "d65156dae9604835e9459e8874a1823a79d0d9de", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -74,7 +74,7 @@ pub mod __impl {\n /// use std::cell::RefCell;\n /// use std::thread;\n ///\n-/// thread_local!(static FOO: RefCell<uint> = RefCell::new(1));\n+/// thread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n ///\n /// FOO.with(|f| {\n ///     assert_eq!(*f.borrow(), 1);\n@@ -503,7 +503,7 @@ mod imp {\n         unsafe fn ptr(&'static self) -> Option<*mut T> {\n             let ptr = self.os.get() as *mut Value<T>;\n             if !ptr.is_null() {\n-                if ptr as uint == 1 {\n+                if ptr as usize == 1 {\n                     return None\n                 }\n                 return Some(&mut (*ptr).value as *mut T);\n@@ -563,7 +563,7 @@ mod tests {\n \n     #[test]\n     fn smoke_no_dtor() {\n-        thread_local!(static FOO: UnsafeCell<int> = UnsafeCell { value: 1 });\n+        thread_local!(static FOO: UnsafeCell<i32> = UnsafeCell { value: 1 });\n \n         FOO.with(|f| unsafe {\n             assert_eq!(*f.get(), 1);\n@@ -632,7 +632,7 @@ mod tests {\n         thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell {\n             value: None\n         });\n-        static mut HITS: uint = 0;\n+        static mut HITS: u32 = 0;\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n@@ -723,8 +723,8 @@ mod dynamic_tests {\n \n     #[test]\n     fn smoke() {\n-        fn square(i: int) -> int { i * i }\n-        thread_local!(static FOO: int = square(3));\n+        fn square(i: i32) -> i32 { i * i }\n+        thread_local!(static FOO: i32 = square(3));\n \n         FOO.with(|f| {\n             assert_eq!(*f, 9);\n@@ -733,12 +733,12 @@ mod dynamic_tests {\n \n     #[test]\n     fn hashmap() {\n-        fn map() -> RefCell<HashMap<int, int>> {\n+        fn map() -> RefCell<HashMap<i32, i32>> {\n             let mut m = HashMap::new();\n             m.insert(1, 2);\n             RefCell::new(m)\n         }\n-        thread_local!(static FOO: RefCell<HashMap<int, int>> = map());\n+        thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n \n         FOO.with(|map| {\n             assert_eq!(map.borrow()[1], 2);\n@@ -747,7 +747,7 @@ mod dynamic_tests {\n \n     #[test]\n     fn refcell_vec() {\n-        thread_local!(static FOO: RefCell<Vec<uint>> = RefCell::new(vec![1, 2, 3]));\n+        thread_local!(static FOO: RefCell<Vec<u32>> = RefCell::new(vec![1, 2, 3]));\n \n         FOO.with(|vec| {\n             assert_eq!(vec.borrow().len(), 3);"}, {"sha": "a2a5d8b81f40458e43b018fe77bb9d5426ee294d", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -24,7 +24,7 @@\n //! # Example\n //!\n //! ```\n-//! scoped_thread_local!(static FOO: uint);\n+//! scoped_thread_local!(static FOO: u32);\n //!\n //! // Initially each scoped slot is empty.\n //! assert!(!FOO.is_set());\n@@ -140,7 +140,7 @@ impl<T> Key<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// scoped_thread_local!(static FOO: uint);\n+    /// scoped_thread_local!(static FOO: u32);\n     ///\n     /// FOO.set(&100, || {\n     ///     let val = FOO.with(|v| *v);\n@@ -192,7 +192,7 @@ impl<T> Key<T> {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// scoped_thread_local!(static FOO: uint);\n+    /// scoped_thread_local!(static FOO: u32);\n     ///\n     /// FOO.with(|slot| {\n     ///     // work with `slot`\n@@ -269,11 +269,11 @@ mod tests {\n     use cell::Cell;\n     use prelude::v1::*;\n \n-    scoped_thread_local!(static FOO: uint);\n+    scoped_thread_local!(static FOO: u32);\n \n     #[test]\n     fn smoke() {\n-        scoped_thread_local!(static BAR: uint);\n+        scoped_thread_local!(static BAR: u32);\n \n         assert!(!BAR.is_set());\n         BAR.set(&1, || {\n@@ -287,7 +287,7 @@ mod tests {\n \n     #[test]\n     fn cell_allowed() {\n-        scoped_thread_local!(static BAR: Cell<uint>);\n+        scoped_thread_local!(static BAR: Cell<u32>);\n \n         BAR.set(&Cell::new(1), || {\n             BAR.with(|slot| {"}, {"sha": "656d507ed69b826952ecbe61bb354f1c72c69836", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -702,12 +702,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs(false),\n                                                                   ast::Sign::new(i))))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n-    }\n     fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU32)))\n     }\n+    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n+        self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n+    }\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }"}, {"sha": "91262556abd706f72ee4bcc91b90d279d1292221", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -417,7 +417,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     parse::AlignUnknown => align(\"Unknown\"),\n                 };\n                 let align = self.ecx.expr_path(align);\n-                let flags = self.ecx.expr_usize(sp, arg.format.flags);\n+                let flags = self.ecx.expr_u32(sp, arg.format.flags);\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n@@ -610,7 +610,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         ecx.ident_of_std(\"core\"),\n                         ecx.ident_of(\"fmt\"),\n                         ecx.ident_of(\"ArgumentV1\"),\n-                        ecx.ident_of(\"from_uint\")], vec![arg])\n+                        ecx.ident_of(\"from_usize\")], vec![arg])\n             }\n         };\n "}, {"sha": "96a06968c5fa3cc961496cba8a20ee33163eddc7", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -17,7 +17,7 @@ pub mod kitty {\n       pub name : String,\n     }\n \n-    impl fmt::String for cat {\n+    impl fmt::Display for cat {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n             write!(f, \"{}\", self.name)\n         }"}, {"sha": "98a9c713e84c331c9d305a63ff0ffa0cb79cec4f", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-implemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n use std::marker::MarkerTrait;\n "}, {"sha": "57d25a3bf586dcab40fe8df4857095ca8db25ed7", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n \n // Test that two blanket impls conflict (at least without negative"}, {"sha": "b3ef79c6cc01e98474df89b02339b3406df1f5fa", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-cross-crate.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -13,7 +13,7 @@\n extern crate go_trait;\n \n use go_trait::{Go,GoMut};\n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n \n struct MyThingy;"}, {"sha": "7b60a5ecbd71f4ac8533599cfb20cb73c4b42a71", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-multidispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n \n // Test that a blank impl for all T conflicts with an impl for some"}, {"sha": "d218b64af05270f0dec430b4b1001d410edfd0e9", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n \n // Test that a blank impl for all T conflicts with an impl for some"}, {"sha": "87b007fdd698239d3af23c2558975c29ad994eb2", "filename": "src/test/compile-fail/coherence-tuple-conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n \n // Test that a blank impl for all T conflicts with an impl for some"}, {"sha": "d682ef7d70c9db931e5cbb28f74bee4b2c3ed41c", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -15,8 +15,7 @@ fn needs_fn<F>(x: F) where F: Fn(isize) -> isize {}\n \n fn main() {\n     let _: () = (box |_: isize| {}) as Box<FnOnce(isize)>;\n-    //~^ ERROR object-safe\n-    //~| ERROR mismatched types\n+    //~^ ERROR mismatched types\n     //~| expected `()`\n     //~| found `Box<core::ops::FnOnce(isize)>`\n     //~| expected ()"}, {"sha": "d39efa3c2ab78f909815c6db507a9a0be4a6419a", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,28 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reached the recursion limit during monomorphization\n-// issue 2258\n+//~^^^^^^^^^^ ERROR overflow\n+//\n+// We get an error message at the top of file (dummy span).\n+// This is not helpful, but also kind of annoying to prevent,\n+// so for now just live with it.\n+// This test case was originally for issue #2258.\n \n-trait to_opt {\n+trait ToOpt {\n     fn to_option(&self) -> Option<Self>;\n }\n \n-impl to_opt for usize {\n+impl ToOpt for usize {\n     fn to_option(&self) -> Option<usize> {\n         Some(*self)\n     }\n }\n \n-impl<T:Clone> to_opt for Option<T> {\n+impl<T:Clone> ToOpt for Option<T> {\n     fn to_option(&self) -> Option<Option<T>> {\n         Some((*self).clone())\n     }\n }\n \n-fn function<T:to_opt + Clone>(counter: usize, t: T) {\n+fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n     if counter > 0_usize {\n         function(counter - 1_usize, t.to_option());\n+        // FIXME(#4287) Error message should be here. It should be\n+        // a type error to instantiate `test` at a type other than T.\n     }\n }\n "}, {"sha": "9f76f360f26ba7db9cf81f7def9321c8110111ad", "filename": "src/test/compile-fail/issue-17441.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -14,11 +14,11 @@ fn main() {\n     let _foo = &[1_usize, 2] as [usize];\n     //~^ ERROR cast to unsized type: `&[usize; 2]` as `[usize]`\n     //~^^ HELP consider using an implicit coercion to `&[usize]` instead\n-    let _bar = box 1_usize as std::fmt::Show;\n-    //~^ ERROR cast to unsized type: `Box<usize>` as `core::fmt::Show`\n-    //~^^ HELP did you mean `Box<core::fmt::Show>`?\n-    let _baz = 1_usize as std::fmt::Show;\n-    //~^ ERROR cast to unsized type: `usize` as `core::fmt::Show`\n+    let _bar = box 1_usize as std::fmt::Debug;\n+    //~^ ERROR cast to unsized type: `Box<usize>` as `core::fmt::Debug`\n+    //~^^ HELP did you mean `Box<core::fmt::Debug>`?\n+    let _baz = 1_usize as std::fmt::Debug;\n+    //~^ ERROR cast to unsized type: `usize` as `core::fmt::Debug`\n     //~^^ HELP consider using a box or reference as appropriate\n     let _quux = [1_usize, 2] as [usize];\n     //~^ ERROR cast to unsized type: `[usize; 2]` as `[usize]`"}, {"sha": "8fb543fb96703cda1a50fc7c0731dfc11288656f", "filename": "src/test/compile-fail/issue-18959.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -17,7 +17,11 @@ impl Foo for Thing {\n     fn foo<T>(&self, _: &T) {}\n }\n \n-#[inline(never)] fn foo(b: &Bar) { b.foo(&0_usize) }\n+#[inline(never)]\n+fn foo(b: &Bar) {\n+    b.foo(&0usize)\n+    //~^ ERROR the trait `Foo` is not implemented for the type `Bar`\n+}\n \n fn main() {\n     let mut thing = Thing;"}, {"sha": "cb2d4e10e6e7166237e4e459a2c35b08f4c7ec50", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -17,15 +17,15 @@\n #![doc=\"More garbage\"]\n \n type Typedef = String;\n-pub type PubTypedef = String; //~ ERROR: missing documentation\n+pub type PubTypedef = String; //~ ERROR: missing documentation for a type alias\n \n struct Foo {\n     a: isize,\n     b: isize,\n }\n \n-pub struct PubFoo { //~ ERROR: missing documentation\n-    pub a: isize,      //~ ERROR: missing documentation\n+pub struct PubFoo { //~ ERROR: missing documentation for a struct\n+    pub a: isize,      //~ ERROR: missing documentation for a struct field\n     b: isize,\n }\n \n@@ -36,11 +36,11 @@ pub struct PubFoo2 {\n }\n \n mod module_no_dox {}\n-pub mod pub_module_no_dox {} //~ ERROR: missing documentation\n+pub mod pub_module_no_dox {} //~ ERROR: missing documentation for a module\n \n /// dox\n pub fn foo() {}\n-pub fn foo2() {} //~ ERROR: missing documentation\n+pub fn foo2() {} //~ ERROR: missing documentation for a function\n fn foo3() {}\n #[allow(missing_docs)] pub fn foo4() {}\n \n@@ -58,23 +58,36 @@ trait B {\n     fn foo_with_impl(&self) {}\n }\n \n-pub trait C { //~ ERROR: missing documentation\n-    fn foo(&self); //~ ERROR: missing documentation\n-    fn foo_with_impl(&self) {} //~ ERROR: missing documentation\n+pub trait C { //~ ERROR: missing documentation for a trait\n+    fn foo(&self); //~ ERROR: missing documentation for a type method\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a method\n }\n \n #[allow(missing_docs)]\n pub trait D {\n     fn dummy(&self) { }\n }\n \n+/// dox\n+pub trait E {\n+    type AssociatedType; //~ ERROR: missing documentation for an associated type\n+    type AssociatedTypeDef = Self; //~ ERROR: missing documentation for an associated type\n+\n+    /// dox\n+    type DocumentedType;\n+    /// dox\n+    type DocumentedTypeDef = Self;\n+    /// dox\n+    fn dummy(&self) {}\n+}\n+\n impl Foo {\n     pub fn foo() {}\n     fn bar() {}\n }\n \n impl PubFoo {\n-    pub fn foo() {} //~ ERROR: missing documentation\n+    pub fn foo() {} //~ ERROR: missing documentation for a method\n     /// dox\n     pub fn foo1() {}\n     fn foo2() {}\n@@ -111,9 +124,9 @@ enum Baz {\n     BarB\n }\n \n-pub enum PubBaz { //~ ERROR: missing documentation\n-    PubBazA { //~ ERROR: missing documentation\n-        a: isize, //~ ERROR: missing documentation\n+pub enum PubBaz { //~ ERROR: missing documentation for an enum\n+    PubBazA { //~ ERROR: missing documentation for a variant\n+        a: isize, //~ ERROR: missing documentation for a struct field\n     },\n }\n \n@@ -139,14 +152,14 @@ pub fn baz() {}\n mod internal_impl {\n     /// dox\n     pub fn documented() {}\n-    pub fn undocumented1() {} //~ ERROR: missing documentation\n-    pub fn undocumented2() {} //~ ERROR: missing documentation\n+    pub fn undocumented1() {} //~ ERROR: missing documentation for a function\n+    pub fn undocumented2() {} //~ ERROR: missing documentation for a function\n     fn undocumented3() {}\n     /// dox\n     pub mod globbed {\n         /// dox\n         pub fn also_documented() {}\n-        pub fn also_undocumented1() {} //~ ERROR: missing documentation\n+        pub fn also_undocumented1() {} //~ ERROR: missing documentation for a function\n         fn also_undocumented2() {}\n     }\n }"}, {"sha": "5d29d0e1fd083914964e45c8bb686ab5da2a082f", "filename": "src/test/compile-fail/move-in-guard-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (1, _) if take(x) => (),\n+        (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "23af25797975f3720843c415adf2ef098ffbd48a", "filename": "src/test/compile-fail/move-in-guard-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (1, _) |\n+        (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "1b20a902c9d527c7bc3ac6a204847d2939e415bc", "filename": "src/test/compile-fail/object-safety-by-value-self-use.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self-use.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that while a trait with by-value self is object-safe, we\n+// can't actually invoke it from an object (yet...?).\n+\n+#![feature(rustc_attrs)]\n+\n+trait Bar {\n+    fn bar(self);\n+}\n+\n+trait Baz {\n+    fn baz(self: Self);\n+}\n+\n+fn use_bar(t: Box<Bar>) {\n+    t.bar() //~ ERROR cannot move a value of type Bar\n+}\n+\n+fn main() { }\n+"}, {"sha": "976717249e8eb2400fe6e307b625bd0fc8e73e18", "filename": "src/test/compile-fail/object-safety-by-value-self.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that we correctly prevent users from making trait objects\n-// from traits with a `fn(self)` method.\n+// Check that a trait with by-value self is considered object-safe.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n \n trait Bar {\n     fn bar(self);\n@@ -19,29 +21,35 @@ trait Baz {\n     fn baz(self: Self);\n }\n \n+trait Quux {\n+    // Legal because of the where clause:\n+    fn baz(self: Self) where Self : Sized;\n+}\n+\n fn make_bar<T:Bar>(t: &T) -> &Bar {\n-    t\n-        //~^ ERROR `Bar` is not object-safe\n-        //~| NOTE method `bar` has a receiver type of `Self`\n+    t // legal\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n-    t as &Bar\n-        //~^ ERROR `Bar` is not object-safe\n-        //~| NOTE method `bar` has a receiver type of `Self`\n+    t as &Bar // legal\n }\n \n fn make_baz<T:Baz>(t: &T) -> &Baz {\n-    t\n-        //~^ ERROR `Baz` is not object-safe\n-        //~| NOTE method `baz` has a receiver type of `Self`\n+    t // legal\n }\n \n fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n-    t as &Baz\n-        //~^ ERROR `Baz` is not object-safe\n-        //~| NOTE method `baz` has a receiver type of `Self`\n+    t as &Baz // legal\n+}\n+\n+fn make_quux<T:Quux>(t: &T) -> &Quux {\n+    t\n+}\n+\n+fn make_quux_explicit<T:Quux>(t: &T) -> &Quux {\n+    t as &Quux\n }\n \n-fn main() {\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n }"}, {"sha": "fd20accfa1e6b562bd319e86b3a987a86baefcaf", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -9,12 +9,18 @@\n // except according to those terms.\n \n // Check that we correctly prevent users from making trait objects\n-// from traits with generic methods.\n+// from traits with generic methods, unless `where Self : Sized` is\n+// present.\n \n trait Bar {\n     fn bar<T>(&self, t: T);\n }\n \n+trait Quux {\n+    fn bar<T>(&self, t: T)\n+        where Self : Sized;\n+}\n+\n fn make_bar<T:Bar>(t: &T) -> &Bar {\n     t\n         //~^ ERROR `Bar` is not object-safe\n@@ -27,5 +33,13 @@ fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n         //~| NOTE method `bar` has generic type parameters\n }\n \n+fn make_quux<T:Quux>(t: &T) -> &Quux {\n+    t\n+}\n+\n+fn make_quux_explicit<T:Quux>(t: &T) -> &Quux {\n+    t as &Quux\n+}\n+\n fn main() {\n }"}, {"sha": "b546774ccbd8cae8deb49bb638bf3e8fa886fac1", "filename": "src/test/compile-fail/object-safety-mentions-Self.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n // Check that we correctly prevent users from making trait objects\n-// form traits that make use of `Self` in an argument or return position.\n+// form traits that make use of `Self` in an argument or return\n+// position, unless `where Self : Sized` is present..\n \n trait Bar {\n     fn bar(&self, x: &Self);\n@@ -19,6 +20,10 @@ trait Baz {\n     fn bar(&self) -> Self;\n }\n \n+trait Quux {\n+    fn get(&self, s: &Self) -> Self where Self : Sized;\n+}\n+\n fn make_bar<T:Bar>(t: &T) -> &Bar {\n     t\n         //~^ ERROR `Bar` is not object-safe\n@@ -43,5 +48,13 @@ fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n }\n \n+fn make_quux<T:Quux>(t: &T) -> &Quux {\n+    t\n+}\n+\n+fn make_quux_explicit<T:Quux>(t: &T) -> &Quux {\n+    t as &Quux\n+}\n+\n fn main() {\n }"}, {"sha": "55f3b995336534c5e7cf8e9424ceb167bf2387b5", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,10 +10,9 @@\n \n //~^^^^^^^^^^ ERROR overflow\n //\n-// We also get a second error message at the top of file (dummy\n-// span). This is not helpful, but also kind of annoying to prevent,\n-// so for now just live with it, since we also get a second message\n-// that is more helpful.\n+// We get an error message at the top of file (dummy span).\n+// This is not helpful, but also kind of annoying to prevent,\n+// so for now just live with it.\n \n enum Nil {NilValue}\n struct Cons<T> {head:isize, tail:T}\n@@ -28,9 +27,8 @@ impl<T:Dot> Dot for Cons<T> {\n }\n fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n   match n {    0 => {first.dot(second)}\n-      //~^ ERROR: reached the recursion limit during monomorphization\n-      // Error message should be here. It should be a type error\n-      // to instantiate `test` at a type other than T. (See #4287)\n+      // FIXME(#4287) Error message should be here. It should be\n+      // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n   }\n }"}, {"sha": "b09b10ffa0aad9dc22572e47f9348b44d7d7e7ac", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -18,4 +18,5 @@ fn main() {\n     10.dup::<i32>(); //~ ERROR does not take type parameters\n     10.blah::<i32, i32>(); //~ ERROR incorrect number of type parameters\n     (box 10 as Box<bar>).dup(); //~ ERROR cannot convert to a trait object\n+    //~^ ERROR the trait `bar` is not implemented for the type `bar`\n }"}, {"sha": "fb6c43a19059a42885a94ada94ab2f894e54dd1a", "filename": "src/test/compile-fail/typeck-builtin-bound-type-parameters.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Ftypeck-builtin-bound-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Ftypeck-builtin-bound-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-builtin-bound-type-parameters.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo1<T:Copy<U>, U>(x: T) {}\n+//~^ ERROR: wrong number of type arguments: expected 0, found 1\n+\n+trait Trait: Copy<Send> {}\n+//~^ ERROR: wrong number of type arguments: expected 0, found 1\n+\n+struct MyStruct1<T: Copy<T>>;\n+//~^ ERROR wrong number of type arguments: expected 0, found 1\n+\n+struct MyStruct2<'a, T: Copy<'a>>;\n+//~^ ERROR: wrong number of lifetime parameters: expected 0, found 1\n+\n+fn foo2<'a, T:Copy<'a, U>, U>(x: T) {}\n+//~^ ERROR: wrong number of type arguments: expected 0, found 1\n+//~^^ ERROR: wrong number of lifetime parameters: expected 0, found 1\n+\n+fn main() {\n+}"}, {"sha": "1998f8ab15529e5cc110fcd28462a8e6ab0d4b74", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -18,7 +18,7 @@ struct Number {\n     n: i64\n }\n \n-impl fmt::String for Number {\n+impl fmt::Display for Number {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.n)\n     }"}, {"sha": "5de8627001087ea474eba75aa7f003a3caf3e762", "filename": "src/test/parse-fail/issue-22647.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fparse-fail%2Fissue-22647.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fparse-fail%2Fissue-22647.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-22647.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let caller<F> = |f: F|  //~ ERROR unexpected token: `<`\n+    where F: Fn() -> i32\n+    {\n+        let x = f();\n+        println!(\"Y {}\",x);\n+        return x;\n+    };\n+\n+    caller(bar_handler);\n+}\n+\n+fn bar_handler() -> i32 {\n+    5\n+}"}, {"sha": "abc9e599467e99c661caa098b478b26a32ffa721", "filename": "src/test/parse-fail/issue-22712.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fparse-fail%2Fissue-22712.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fparse-fail%2Fissue-22712.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-22712.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<B> {\n+    buffer: B\n+}\n+\n+fn bar() {\n+    let Foo<Vec<u8>>  //~ ERROR unexpected token: `<`\n+}\n+\n+fn main() {}"}, {"sha": "8febbf8309ea78cb046705b4c04ad9d3c7d5b0be", "filename": "src/test/parse-fail/trailing-plus-in-bounds.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n \n fn main() {\n-    let x: Box<Show+> = box 3 as Box<Show+>;\n+    let x: Box<Debug+> = box 3 as Box<Debug+>;\n     //~^ ERROR at least one type parameter bound must be specified\n     //~^^ ERROR at least one type parameter bound must be specified\n }\n-"}, {"sha": "51c6b14e1deedb01fed39975d73f22ed15b113cf", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -22,12 +22,12 @@ digraph block {\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n-    N8 -> N9;\n+    N6 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N13;\n+    N12 -> N8;\n+    N8 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N7;"}, {"sha": "fb7d2ad97bd5f553277f80ae09dfcba4cbd3f1bd", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -32,16 +32,16 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n+    N9 -> N12;\n+    N12 -> N11;\n+    N11 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N10;\n-    N11 -> N16;\n-    N16 -> N17;\n+    N9 -> N17;\n     N17 -> N18;\n-    N18 -> N19;\n+    N18 -> N16;\n+    N16 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n     N21 -> N22;"}, {"sha": "daff321efcfd9d39299fb7c03e35b30934635d8c", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -54,7 +54,7 @@ fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n     }\n }\n \n-impl fmt::String for cat {\n+impl fmt::Display for cat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.name)\n     }"}, {"sha": "b16b033c22fccafc6854593e9f4cbb553a63cb98", "filename": "src/test/run-pass/coherence-multidispatch-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fcoherence-multidispatch-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fcoherence-multidispatch-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-multidispatch-tuple.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::default::Default;\n \n // Test that an impl for homogeneous pairs does not conflict with a"}, {"sha": "1ecdd39ca7af5e884e35e01e21650416a221431c", "filename": "src/test/run-pass/issue-22577.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22577.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{fs, net};\n+\n+fn assert_both<T: Send + Sync>() {}\n+\n+fn main() {\n+    assert_both::<fs::File>();\n+    assert_both::<fs::Metadata>();\n+    assert_both::<fs::ReadDir>();\n+    assert_both::<fs::DirEntry>();\n+    assert_both::<fs::WalkDir>();\n+    assert_both::<fs::OpenOptions>();\n+    assert_both::<fs::Permissions>();\n+\n+    assert_both::<net::TcpStream>();\n+    assert_both::<net::TcpListener>();\n+    assert_both::<net::UdpSocket>();\n+    assert_both::<net::SocketAddr>();\n+    assert_both::<net::IpAddr>();\n+}"}, {"sha": "be4d475229591bc7c5b178dc6f2b5c2eef25c53e", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -101,7 +101,7 @@ impl AsciiArt {\n \n // Allows AsciiArt to be converted to a string using the libcore ToString trait.\n // Note that the %s fmt! specifier will not call this automatically.\n-impl fmt::String for AsciiArt {\n+impl fmt::Display for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n         let lines = self.lines.iter()"}, {"sha": "64c4f1fdbaeabf6e2d9e06bdb80646e4063c4ede", "filename": "src/test/run-pass/move-guard-const.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (2, 1) if take(x) => (),\n+        (1, 2) if take(x) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "ae092333134ea0f0b53c988058387c4bfdb41c18", "filename": "src/test/run-pass/object-safety-sized-self-by-value-self.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-by-value-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-by-value-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-by-value-self.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that a trait is still object-safe (and usable) if it has\n+// methods with by-value self so long as they require `Self : Sized`.\n+\n+trait Counter {\n+    fn tick(&mut self) -> u32;\n+    fn get(self) -> u32 where Self : Sized;\n+}\n+\n+struct CCounter {\n+    c: u32\n+}\n+\n+impl Counter for CCounter {\n+    fn tick(&mut self) -> u32 { self.c += 1; self.c }\n+    fn get(self) -> u32 where Self : Sized { self.c }\n+}\n+\n+fn tick1<C:Counter>(mut c: C) -> u32 {\n+    tick2(&mut c);\n+    c.get()\n+}\n+\n+fn tick2(c: &mut Counter) {\n+    tick3(c);\n+}\n+\n+fn tick3<C:?Sized+Counter>(c: &mut C) {\n+    c.tick();\n+    c.tick();\n+}\n+\n+fn main() {\n+    let mut c = CCounter { c: 0 };\n+    let value = tick1(c);\n+    assert_eq!(value, 2);\n+}"}, {"sha": "1a42c4b6ef6649be36b0e8bae0b765c4e2b1b150", "filename": "src/test/run-pass/object-safety-sized-self-generic-method.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-generic-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-generic-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-generic-method.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that a trait is still object-safe (and usable) if it has\n+// generic methods so long as they require `Self : Sized`.\n+\n+trait Counter {\n+    fn tick(&mut self) -> u32;\n+    fn with<F:FnOnce(u32)>(&self, f: F) where Self : Sized;\n+}\n+\n+struct CCounter {\n+    c: u32\n+}\n+\n+impl Counter for CCounter {\n+    fn tick(&mut self) -> u32 { self.c += 1; self.c }\n+    fn with<F:FnOnce(u32)>(&self, f: F) { f(self.c); }\n+}\n+\n+fn tick1<C:Counter>(c: &mut C) {\n+    tick2(c);\n+    c.with(|i| ());\n+}\n+\n+fn tick2(c: &mut Counter) {\n+    tick3(c);\n+}\n+\n+fn tick3<C:?Sized+Counter>(c: &mut C) {\n+    c.tick();\n+    c.tick();\n+}\n+\n+fn main() {\n+    let mut c = CCounter { c: 0 };\n+    tick1(&mut c);\n+    assert_eq!(c.tick(), 3);\n+}"}, {"sha": "7f075bbb6c2f226bb1a38ef4b1cd9193e737fdf3", "filename": "src/test/run-pass/object-safety-sized-self-return-Self.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-return-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-return-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-safety-sized-self-return-Self.rs?ref=dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that a trait is still object-safe (and usable) if it has\n+// methods that return `Self` so long as they require `Self : Sized`.\n+\n+trait Counter {\n+    fn new() -> Self where Self : Sized;\n+    fn tick(&mut self) -> u32;\n+}\n+\n+struct CCounter {\n+    c: u32\n+}\n+\n+impl Counter for CCounter {\n+    fn new() -> CCounter { CCounter { c: 0 } }\n+    fn tick(&mut self) -> u32 { self.c += 1; self.c }\n+}\n+\n+fn preticked<C:Counter>() -> C {\n+    let mut c: C = Counter::new();\n+    tick(&mut c);\n+    c\n+}\n+\n+fn tick(c: &mut Counter) {\n+    tick_generic(c);\n+}\n+\n+fn tick_generic<C:?Sized+Counter>(c: &mut C) {\n+    c.tick();\n+    c.tick();\n+}\n+\n+fn main() {\n+    let mut c = preticked::<CCounter>();\n+    tick(&mut c);\n+    assert_eq!(c.tick(), 5);\n+}"}]}