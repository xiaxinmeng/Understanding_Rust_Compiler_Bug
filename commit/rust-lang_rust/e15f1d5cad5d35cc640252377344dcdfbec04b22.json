{"sha": "e15f1d5cad5d35cc640252377344dcdfbec04b22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNWYxZDVjYWQ1ZDM1Y2M2NDAyNTIzNzczNDRkY2RmYmVjMDRiMjI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-19T05:43:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:23Z"}, "message": "std: refactor global_loop::get.. make it reusable", "tree": {"sha": "b056b79a70bb8d6510e6d8e6675681e907bb9323", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b056b79a70bb8d6510e6d8e6675681e907bb9323"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e15f1d5cad5d35cc640252377344dcdfbec04b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e15f1d5cad5d35cc640252377344dcdfbec04b22", "html_url": "https://github.com/rust-lang/rust/commit/e15f1d5cad5d35cc640252377344dcdfbec04b22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e15f1d5cad5d35cc640252377344dcdfbec04b22/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afb35f752f89e9466f8f15e701808871b6dcdb6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/afb35f752f89e9466f8f15e701808871b6dcdb6e", "html_url": "https://github.com/rust-lang/rust/commit/afb35f752f89e9466f8f15e701808871b6dcdb6e"}], "stats": {"total": 110, "additions": 88, "deletions": 22}, "files": [{"sha": "b220ba9fe19ef0dec9d214f250d2e019dbb11c4a", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e15f1d5cad5d35cc640252377344dcdfbec04b22/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15f1d5cad5d35cc640252377344dcdfbec04b22/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=e15f1d5cad5d35cc640252377344dcdfbec04b22", "patch": "@@ -6,7 +6,7 @@ import ll = uv_ll;\n import hl = uv_hl;\n import get_gl = get;\n \n-export get;\n+export get, get_single_task_gl;\n \n native mod rustrt {\n     fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n@@ -26,7 +26,44 @@ loop is running.\n loop.\n \"]\n fn get() -> hl::high_level_loop {\n+    ret get_single_task_gl();\n+}\n+\n+#[doc(hidden)]\n+fn get_single_task_gl() -> hl::high_level_loop {\n     let global_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n+    ret spawn_global_weak_task(\n+        global_loop_chan_ptr,\n+        {|weak_exit_po, msg_po, loop_ptr, first_msg|\n+            log(debug, \"about to enter inner loop\");\n+            unsafe {\n+                single_task_loop_body(weak_exit_po, msg_po, loop_ptr,\n+                                      copy(first_msg))\n+            }\n+        },\n+        {|msg_ch|\n+            log(debug, \"after priv::chan_from_global_ptr\");\n+            unsafe {\n+                let handle = get_global_async_handle_native_representation()\n+                    as **ll::uv_async_t;\n+                hl::single_task_loop(\n+                    { async_handle: handle, op_chan: msg_ch })\n+            }\n+        }\n+    );\n+}\n+\n+// INTERNAL API\n+\n+fn spawn_global_weak_task(\n+        global_loop_chan_ptr: *libc::uintptr_t,\n+        weak_task_body_cb: fn~(\n+            comm::port<()>,\n+            comm::port<hl::high_level_msg>,\n+            *libc::c_void,\n+            hl::high_level_msg) -> bool,\n+        after_task_spawn_cb: fn~(comm::chan<hl::high_level_msg>)\n+          -> hl::high_level_loop) -> hl::high_level_loop {\n     log(debug, #fmt(\"ENTERING global_loop::get() loop chan: %?\",\n        global_loop_chan_ptr));\n \n@@ -44,25 +81,26 @@ fn get() -> hl::high_level_loop {\n     };\n     unsafe {\n         log(debug, \"before priv::chan_from_global_ptr\");\n-        let chan = priv::chan_from_global_ptr::<hl::high_level_msg>(\n+        let msg_ch = priv::chan_from_global_ptr::<hl::high_level_msg>(\n             global_loop_chan_ptr,\n             builder_fn) {|port|\n \n             // the actual body of our global loop lives here\n             log(debug, \"initialized global port task!\");\n             log(debug, \"GLOBAL initialized global port task!\");\n-            outer_global_loop_body(port);\n+            outer_global_loop_body(port, weak_task_body_cb);\n         };\n-        log(debug, \"after priv::chan_from_global_ptr\");\n-        let handle = get_global_async_handle_native_representation()\n-            as **ll::uv_async_t;\n-        ret { async_handle: handle, op_chan: chan };\n+        ret after_task_spawn_cb(msg_ch);\n     }\n }\n \n-// INTERNAL API\n-\n-unsafe fn outer_global_loop_body(msg_po: comm::port<hl::high_level_msg>) {\n+unsafe fn outer_global_loop_body(\n+    msg_po: comm::port<hl::high_level_msg>,\n+    weak_task_body_cb: fn~(\n+        comm::port<()>,\n+        comm::port<hl::high_level_msg>,\n+        *libc::c_void,\n+        hl::high_level_msg) -> bool) {\n     // we're going to use a single libuv-generated loop ptr\n     // for the duration of the process\n     let loop_ptr = ll::loop_new();\n@@ -87,9 +125,8 @@ unsafe fn outer_global_loop_body(msg_po: comm::port<hl::high_level_msg>) {\n                                    left_val));\n                     false\n                 }, {|right_val|\n-                    log(debug, \"about to enter inner loop\");\n-                    inner_global_loop_body(weak_exit_po, msg_po, loop_ptr,\n-                                          copy(right_val))\n+                    weak_task_body_cb(weak_exit_po, msg_po, loop_ptr,\n+                                      right_val)\n                 }, comm::select2(weak_exit_po, msg_po));\n             log(debug,#fmt(\"GLOBAL LOOP EXITED, WAITING TO RESTART? %?\",\n                        continue));\n@@ -99,7 +136,7 @@ unsafe fn outer_global_loop_body(msg_po: comm::port<hl::high_level_msg>) {\n     ll::loop_delete(loop_ptr);\n }\n \n-unsafe fn inner_global_loop_body(weak_exit_po_in: comm::port<()>,\n+unsafe fn single_task_loop_body(weak_exit_po_in: comm::port<()>,\n                           msg_po_in: comm::port<hl::high_level_msg>,\n                           loop_ptr: *libc::c_void,\n                           -first_interaction: hl::high_level_msg) -> bool {"}, {"sha": "b235cdd5e07c80fbbe56b481e60a533ec3f871a7", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e15f1d5cad5d35cc640252377344dcdfbec04b22/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15f1d5cad5d35cc640252377344dcdfbec04b22/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=e15f1d5cad5d35cc640252377344dcdfbec04b22", "patch": "@@ -6,7 +6,7 @@ provide a high-level, abstracted interface to some set of\n libuv functionality.\n \"];\n \n-export high_level_loop, high_level_msg;\n+export high_level_loop, hl_loop_ext, high_level_msg;\n export run_high_level_loop, interact, ref_handle, unref_handle;\n \n import ll = uv_ll;\n@@ -22,10 +22,39 @@ the C uv loop to process any pending callbacks\n * op_chan - a channel used to send function callbacks to be processed\n by the C uv loop\n \"]\n-type high_level_loop = {\n-    async_handle: **ll::uv_async_t,\n-    op_chan: comm::chan<high_level_msg>\n-};\n+enum high_level_loop {\n+    single_task_loop({\n+        async_handle: **ll::uv_async_t,\n+        op_chan: comm::chan<high_level_msg>\n+    }),\n+    monitor_task_loop({\n+        op_chan: comm::chan<high_level_msg>\n+    })\n+}\n+\n+impl hl_loop_ext for high_level_loop {\n+    fn async_handle() -> **ll::uv_async_t {\n+        alt self {\n+          single_task_loop({async_handle, op_chan}) {\n+            ret async_handle;\n+          }\n+          _ {\n+            fail \"variant of hl::high_level_loop that doesn't include\" +\n+                \"an async_handle field\";\n+          }\n+        }\n+    }\n+    fn op_chan() -> comm::chan<high_level_msg> {\n+        alt self {\n+          single_task_loop({async_handle, op_chan}) {\n+            ret op_chan;\n+          }\n+          monitor_task_loop({op_chan}) {\n+            ret op_chan;\n+          }\n+        }\n+    }\n+}\n \n #[doc=\"\n Represents the range of interactions with a `high_level_loop`\n@@ -158,15 +187,15 @@ enum global_loop_data {\n \n unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n                               -msg: high_level_msg) unsafe {\n-    comm::send(hl_loop.op_chan, msg);\n+    comm::send(hl_loop.op_chan(), msg);\n \n     // if the global async handle == 0, then that means\n     // the loop isn't active, so we don't need to wake it up,\n     // (the loop's enclosing task should be blocking on a message\n     // receive on this port)\n-    if (*(hl_loop.async_handle) != 0 as *ll::uv_async_t) {\n+    if (*(hl_loop.async_handle()) != 0 as *ll::uv_async_t) {\n         log(debug,\"global async handle != 0, waking up loop..\");\n-        ll::async_send(*(hl_loop.async_handle));\n+        ll::async_send(*(hl_loop.async_handle()));\n     }\n     else {\n         log(debug,\"GLOBAL ASYNC handle == 0\");"}]}