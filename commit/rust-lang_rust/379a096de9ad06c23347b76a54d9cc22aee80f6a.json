{"sha": "379a096de9ad06c23347b76a54d9cc22aee80f6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OWEwOTZkZTlhZDA2YzIzMzQ3Yjc2YTU0ZDljYzIyYWVlODBmNmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T15:14:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T15:14:11Z"}, "message": "Refactor main_loop", "tree": {"sha": "427fd07eb770b627cfc5d7376ed3746632509650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/427fd07eb770b627cfc5d7376ed3746632509650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/379a096de9ad06c23347b76a54d9cc22aee80f6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/379a096de9ad06c23347b76a54d9cc22aee80f6a", "html_url": "https://github.com/rust-lang/rust/commit/379a096de9ad06c23347b76a54d9cc22aee80f6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/379a096de9ad06c23347b76a54d9cc22aee80f6a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd20c2ec5bc0c5ac02149479c2b5f3746f3df505", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd20c2ec5bc0c5ac02149479c2b5f3746f3df505", "html_url": "https://github.com/rust-lang/rust/commit/dd20c2ec5bc0c5ac02149479c2b5f3746f3df505"}], "stats": {"total": 816, "additions": 402, "deletions": 414}, "files": [{"sha": "4dcab7a61f9007cafdf447907951e7011b80ed61", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=379a096de9ad06c23347b76a54d9cc22aee80f6a", "patch": "@@ -120,7 +120,13 @@ impl FlycheckActor {\n     ) -> FlycheckActor {\n         FlycheckActor { sender, config, workspace_root, last_update_req: None, check_process: None }\n     }\n-\n+    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n+        select! {\n+            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n+        }\n+    }\n     fn run(&mut self, inbox: Receiver<Restart>) {\n         // If we rerun the thread, we need to discard the previous check results first\n         self.send(Message::ClearDiagnostics);\n@@ -167,15 +173,6 @@ impl FlycheckActor {\n             }\n         }\n     }\n-\n-    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n-        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n-        select! {\n-            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n-            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n-        }\n-    }\n-\n     fn should_recheck(&mut self) -> bool {\n         if let Some(_last_update_req) = &self.last_update_req {\n             // We currently only request an update on save, as we need up to"}, {"sha": "56d50c78997944fdeec759c2344f0ef866080d60", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=379a096de9ad06c23347b76a54d9cc22aee80f6a", "patch": "@@ -5,7 +5,7 @@\n \n use std::{convert::TryFrom, sync::Arc};\n \n-use crossbeam_channel::{unbounded, Receiver};\n+use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::{FlycheckConfig, FlycheckHandle};\n use lsp_types::Url;\n use parking_lot::RwLock;\n@@ -22,6 +22,7 @@ use crate::{\n     line_endings::LineEndings,\n     main_loop::{ReqQueue, Task},\n     request_metrics::{LatestRequests, RequestMetrics},\n+    show_message,\n     thread_pool::TaskPool,\n     to_proto::url_from_abs_path,\n     Result,\n@@ -66,6 +67,7 @@ impl Default for Status {\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n pub(crate) struct GlobalState {\n+    sender: Sender<lsp_server::Message>,\n     pub(crate) config: Config,\n     pub(crate) task_pool: (TaskPool<Task>, Receiver<Task>),\n     pub(crate) analysis_host: AnalysisHost,\n@@ -95,6 +97,7 @@ pub(crate) struct GlobalStateSnapshot {\n \n impl GlobalState {\n     pub(crate) fn new(\n+        sender: Sender<lsp_server::Message>,\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         config: Config,\n@@ -162,6 +165,7 @@ impl GlobalState {\n         };\n \n         let mut res = GlobalState {\n+            sender,\n             config,\n             task_pool,\n             analysis_host,\n@@ -252,6 +256,19 @@ impl GlobalState {\n     pub(crate) fn complete_request(&mut self, request: RequestMetrics) {\n         self.latest_requests.write().record(request)\n     }\n+\n+    pub(crate) fn send(&mut self, message: lsp_server::Message) {\n+        self.sender.send(message).unwrap()\n+    }\n+    pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n+        show_message(typ, message, &self.sender)\n+    }\n+}\n+\n+impl Drop for GlobalState {\n+    fn drop(&mut self) {\n+        self.analysis_host.request_cancellation()\n+    }\n }\n \n impl GlobalStateSnapshot {"}, {"sha": "f3c8b5978d45f16ff8a68a5d6cbf8f2774f9f9ea", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 371, "deletions": 396, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=379a096de9ad06c23347b76a54d9cc22aee80f6a", "patch": "@@ -5,9 +5,9 @@ use std::{\n     time::{Duration, Instant},\n };\n \n-use crossbeam_channel::{never, select, RecvError, Sender};\n+use crossbeam_channel::{never, select, Receiver};\n use lsp_server::{Connection, ErrorCode, Notification, Request, RequestId, Response};\n-use lsp_types::{request::Request as _, NumberOrString};\n+use lsp_types::{notification::Notification as _, request::Request as _, NumberOrString};\n use ra_db::VfsPath;\n use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n@@ -50,7 +50,7 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         SetThreadPriority(thread, thread_priority_above_normal);\n     }\n \n-    let mut global_state = {\n+    let global_state = {\n         let workspaces = {\n             if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n@@ -113,40 +113,371 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        GlobalState::new(workspaces, config.lru_capacity, config, req_queue)\n+        GlobalState::new(\n+            connection.sender.clone(),\n+            workspaces,\n+            config.lru_capacity,\n+            config,\n+            req_queue,\n+        )\n     };\n \n     log::info!(\"server initialized, serving requests\");\n-    {\n-        loop {\n-            log::trace!(\"selecting\");\n-            let event = select! {\n-                recv(&connection.receiver) -> msg => match msg {\n-                    Ok(msg) => Event::Lsp(msg),\n-                    Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n-                },\n-                recv(&global_state.task_pool.1) -> task => Event::Task(task.unwrap()),\n-                recv(global_state.task_receiver) -> task => match task {\n-                    Ok(task) => Event::Vfs(task),\n-                    Err(RecvError) => return Err(\"vfs died\".into()),\n+    global_state.run(connection.receiver)?;\n+    Ok(())\n+}\n+\n+impl GlobalState {\n+    fn next_event(&self, inbox: &Receiver<lsp_server::Message>) -> Option<Event> {\n+        select! {\n+            recv(inbox) -> msg =>\n+                msg.ok().map(Event::Lsp),\n+\n+            recv(self.task_pool.1) -> task =>\n+                Some(Event::Task(task.unwrap())),\n+\n+            recv(self.task_receiver) -> task =>\n+                Some(Event::Vfs(task.unwrap())),\n+\n+            recv(self.flycheck.as_ref().map_or(&never(), |it| &it.1)) -> task =>\n+                Some(Event::Flycheck(task.unwrap())),\n+        }\n+    }\n+\n+    fn run(mut self, inbox: Receiver<lsp_server::Message>) -> Result<()> {\n+        while let Some(event) = self.next_event(&inbox) {\n+            let loop_start = Instant::now();\n+            // NOTE: don't count blocking select! call as a loop-turn time\n+            let _p = profile(\"main_loop_inner/loop-turn\");\n+\n+            log::info!(\"loop turn = {:?}\", event);\n+            let queue_count = self.task_pool.0.len();\n+            if queue_count > 0 {\n+                log::info!(\"queued count = {}\", queue_count);\n+            }\n+\n+            let mut became_ready = false;\n+            match event {\n+                Event::Lsp(msg) => match msg {\n+                    lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n+                    lsp_server::Message::Notification(not) => {\n+                        if not.method == lsp_types::notification::Exit::METHOD {\n+                            return Ok(());\n+                        }\n+                        self.on_notification(not)?;\n+                    }\n+                    lsp_server::Message::Response(resp) => {\n+                        let handler = self.req_queue.outgoing.complete(resp.id.clone());\n+                        handler(&mut self, resp)\n+                    }\n                 },\n-                recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.1)) -> task => match task {\n-                    Ok(task) => Event::Flycheck(task),\n-                    Err(RecvError) => return Err(\"check watcher died\".into()),\n+                Event::Task(task) => {\n+                    self.on_task(task);\n+                    self.maybe_collect_garbage();\n+                }\n+                Event::Vfs(task) => match task {\n+                    vfs::loader::Message::Loaded { files } => {\n+                        let vfs = &mut self.vfs.write().0;\n+                        for (path, contents) in files {\n+                            let path = VfsPath::from(path);\n+                            if !self.mem_docs.contains(&path) {\n+                                vfs.set_file_contents(path, contents)\n+                            }\n+                        }\n+                    }\n+                    vfs::loader::Message::Progress { n_total, n_done } => {\n+                        let state = if n_done == 0 {\n+                            Progress::Begin\n+                        } else if n_done < n_total {\n+                            Progress::Report\n+                        } else {\n+                            assert_eq!(n_done, n_total);\n+                            self.status = Status::Ready;\n+                            became_ready = true;\n+                            Progress::End\n+                        };\n+                        report_progress(\n+                            &mut self,\n+                            \"roots scanned\",\n+                            state,\n+                            Some(format!(\"{}/{}\", n_done, n_total)),\n+                            Some(percentage(n_done, n_total)),\n+                        )\n+                    }\n                 },\n-            };\n-            if let Event::Lsp(lsp_server::Message::Request(req)) = &event {\n-                if connection.handle_shutdown(&req)? {\n-                    break;\n+                Event::Flycheck(task) => on_check_task(task, &mut self)?,\n+            }\n+\n+            let state_changed = self.process_changes();\n+            if became_ready {\n+                if let Some(flycheck) = &self.flycheck {\n+                    flycheck.0.update();\n+                }\n+            }\n+\n+            if self.status == Status::Ready && (state_changed || became_ready) {\n+                let subscriptions = self\n+                    .mem_docs\n+                    .iter()\n+                    .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n+                    .collect::<Vec<_>>();\n+\n+                self.update_file_notifications_on_threadpool(subscriptions);\n+            }\n+\n+            let loop_duration = loop_start.elapsed();\n+            if loop_duration > Duration::from_millis(100) {\n+                log::error!(\"overly long loop turn: {:?}\", loop_duration);\n+                if env::var(\"RA_PROFILE\").is_ok() {\n+                    self.show_message(\n+                        lsp_types::MessageType::Error,\n+                        format!(\"overly long loop turn: {:?}\", loop_duration),\n+                    )\n+                }\n+            }\n+        }\n+        Err(\"client exited without proper shutdown sequence\")?\n+    }\n+\n+    fn on_request(&mut self, request_received: Instant, req: Request) -> Result<()> {\n+        let mut pool_dispatcher =\n+            PoolDispatcher { req: Some(req), global_state: self, request_received };\n+        pool_dispatcher\n+            .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n+            .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n+            .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n+            .on_sync::<lsp_types::request::Shutdown>(|_, ()| Ok(()))?\n+            .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n+                handlers::handle_selection_range(s.snapshot(), p)\n+            })?\n+            .on_sync::<lsp_ext::MatchingBrace>(|s, p| {\n+                handlers::handle_matching_brace(s.snapshot(), p)\n+            })?\n+            .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)?\n+            .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)?\n+            .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)?\n+            .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)?\n+            .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n+            .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n+            .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n+            .on::<lsp_ext::ResolveCodeActionRequest>(handlers::handle_resolve_code_action)?\n+            .on::<lsp_ext::HoverRequest>(handlers::handle_hover)?\n+            .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n+            .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n+            .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n+            .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)?\n+            .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)?\n+            .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n+            .on::<lsp_types::request::Completion>(handlers::handle_completion)?\n+            .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)?\n+            .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n+            .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n+            .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n+            .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n+            .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n+            .on::<lsp_types::request::References>(handlers::handle_references)?\n+            .on::<lsp_types::request::Formatting>(handlers::handle_formatting)?\n+            .on::<lsp_types::request::DocumentHighlightRequest>(\n+                handlers::handle_document_highlight,\n+            )?\n+            .on::<lsp_types::request::CallHierarchyPrepare>(\n+                handlers::handle_call_hierarchy_prepare,\n+            )?\n+            .on::<lsp_types::request::CallHierarchyIncomingCalls>(\n+                handlers::handle_call_hierarchy_incoming,\n+            )?\n+            .on::<lsp_types::request::CallHierarchyOutgoingCalls>(\n+                handlers::handle_call_hierarchy_outgoing,\n+            )?\n+            .on::<lsp_types::request::SemanticTokensRequest>(handlers::handle_semantic_tokens)?\n+            .on::<lsp_types::request::SemanticTokensRangeRequest>(\n+                handlers::handle_semantic_tokens_range,\n+            )?\n+            .on::<lsp_ext::Ssr>(handlers::handle_ssr)?\n+            .finish();\n+        Ok(())\n+    }\n+    fn on_notification(&mut self, not: Notification) -> Result<()> {\n+        let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n+            Ok(params) => {\n+                let id: RequestId = match params.id {\n+                    NumberOrString::Number(id) => id.into(),\n+                    NumberOrString::String(id) => id.into(),\n+                };\n+                if let Some(response) = self.req_queue.incoming.cancel(id) {\n+                    self.send(response.into())\n+                }\n+                return Ok(());\n+            }\n+            Err(not) => not,\n+        };\n+        let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n+            Ok(params) => {\n+                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    if !self.mem_docs.insert(path.clone()) {\n+                        log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n+                    }\n+                    self.vfs\n+                        .write()\n+                        .0\n+                        .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n+                }\n+                return Ok(());\n+            }\n+            Err(not) => not,\n+        };\n+        let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n+            Ok(params) => {\n+                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    assert!(self.mem_docs.contains(&path));\n+                    let vfs = &mut self.vfs.write().0;\n+                    let file_id = vfs.file_id(&path).unwrap();\n+                    let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n+                    apply_document_changes(&mut text, params.content_changes);\n+                    vfs.set_file_contents(path, Some(text.into_bytes()))\n+                }\n+                return Ok(());\n+            }\n+            Err(not) => not,\n+        };\n+        let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n+            Ok(params) => {\n+                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    if !self.mem_docs.remove(&path) {\n+                        log::error!(\"orphan DidCloseTextDocument: {}\", path)\n+                    }\n+                    if let Some(path) = path.as_path() {\n+                        self.loader.invalidate(path.to_path_buf());\n+                    }\n+                }\n+                let params = lsp_types::PublishDiagnosticsParams {\n+                    uri: params.text_document.uri,\n+                    diagnostics: Vec::new(),\n+                    version: None,\n                 };\n+                let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n+                self.send(not.into());\n+                return Ok(());\n+            }\n+            Err(not) => not,\n+        };\n+        let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n+            Ok(_params) => {\n+                if let Some(flycheck) = &self.flycheck {\n+                    flycheck.0.update();\n+                }\n+                return Ok(());\n             }\n-            assert!(!global_state.vfs.read().0.has_changes());\n-            loop_turn(&connection, &mut global_state, event)?;\n-            assert!(!global_state.vfs.read().0.has_changes());\n+            Err(not) => not,\n+        };\n+        let not = match notification_cast::<lsp_types::notification::DidChangeConfiguration>(not) {\n+            Ok(_) => {\n+                // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n+                // this notification's parameters should be ignored and the actual config queried separately.\n+                let request = self.req_queue.outgoing.register(\n+                    lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n+                    lsp_types::ConfigurationParams {\n+                        items: vec![lsp_types::ConfigurationItem {\n+                            scope_uri: None,\n+                            section: Some(\"rust-analyzer\".to_string()),\n+                        }],\n+                    },\n+                    |this, resp| {\n+                        log::debug!(\"config update response: '{:?}\", resp);\n+                        let Response { error, result, .. } = resp;\n+\n+                        match (error, result) {\n+                            (Some(err), _) => {\n+                                log::error!(\"failed to fetch the server settings: {:?}\", err)\n+                            }\n+                            (None, Some(configs)) => {\n+                                if let Some(new_config) = configs.get(0) {\n+                                    let mut config = this.config.clone();\n+                                    config.update(&new_config);\n+                                    this.update_configuration(config);\n+                                }\n+                            }\n+                            (None, None) => log::error!(\n+                                \"received empty server settings response from the client\"\n+                            ),\n+                        }\n+                    },\n+                );\n+                self.send(request.into());\n+\n+                return Ok(());\n+            }\n+            Err(not) => not,\n+        };\n+        let not = match notification_cast::<lsp_types::notification::DidChangeWatchedFiles>(not) {\n+            Ok(params) => {\n+                for change in params.changes {\n+                    if let Ok(path) = from_proto::abs_path(&change.uri) {\n+                        self.loader.invalidate(path)\n+                    }\n+                }\n+                return Ok(());\n+            }\n+            Err(not) => not,\n+        };\n+        if not.method.starts_with(\"$/\") {\n+            return Ok(());\n         }\n+        log::error!(\"unhandled notification: {:?}\", not);\n+        Ok(())\n+    }\n+    fn on_task(&mut self, task: Task) {\n+        match task {\n+            Task::Respond(response) => {\n+                if let Some((method, start)) = self.req_queue.incoming.complete(response.id.clone())\n+                {\n+                    let duration = start.elapsed();\n+                    log::info!(\"handled req#{} in {:?}\", response.id, duration);\n+                    self.complete_request(RequestMetrics {\n+                        id: response.id.clone(),\n+                        method: method.to_string(),\n+                        duration,\n+                    });\n+                    self.send(response.into());\n+                }\n+            }\n+            Task::Diagnostics(tasks) => {\n+                tasks.into_iter().for_each(|task| on_diagnostic_task(task, self))\n+            }\n+            Task::Unit => (),\n+        }\n+    }\n+    fn update_file_notifications_on_threadpool(&mut self, subscriptions: Vec<FileId>) {\n+        log::trace!(\"updating notifications for {:?}\", subscriptions);\n+        if self.config.publish_diagnostics {\n+            let snapshot = self.snapshot();\n+            let subscriptions = subscriptions.clone();\n+            self.task_pool.0.spawn(move || {\n+                let diagnostics = subscriptions\n+                    .into_iter()\n+                    .filter_map(|file_id| {\n+                        handlers::publish_diagnostics(&snapshot, file_id)\n+                            .map_err(|err| {\n+                                if !is_canceled(&*err) {\n+                                    log::error!(\"failed to compute diagnostics: {:?}\", err);\n+                                }\n+                                ()\n+                            })\n+                            .ok()\n+                    })\n+                    .collect::<Vec<_>>();\n+                Task::Diagnostics(diagnostics)\n+            })\n+        }\n+        self.task_pool.0.spawn({\n+            let subs = subscriptions;\n+            let snap = self.snapshot();\n+            move || {\n+                snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ());\n+                Task::Unit\n+            }\n+        });\n     }\n-    global_state.analysis_host.request_cancellation();\n-    Ok(())\n }\n \n #[derive(Debug)]\n@@ -199,333 +530,10 @@ pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n \n-fn loop_turn(connection: &Connection, global_state: &mut GlobalState, event: Event) -> Result<()> {\n-    let loop_start = Instant::now();\n-\n-    // NOTE: don't count blocking select! call as a loop-turn time\n-    let _p = profile(\"main_loop_inner/loop-turn\");\n-    log::info!(\"loop turn = {:?}\", event);\n-    let queue_count = global_state.task_pool.0.len();\n-    if queue_count > 0 {\n-        log::info!(\"queued count = {}\", queue_count);\n-    }\n-\n-    let mut became_ready = false;\n-    match event {\n-        Event::Task(task) => {\n-            on_task(task, &connection.sender, global_state);\n-            global_state.maybe_collect_garbage();\n-        }\n-        Event::Vfs(task) => match task {\n-            vfs::loader::Message::Loaded { files } => {\n-                let vfs = &mut global_state.vfs.write().0;\n-                for (path, contents) in files {\n-                    let path = VfsPath::from(path);\n-                    if !global_state.mem_docs.contains(&path) {\n-                        vfs.set_file_contents(path, contents)\n-                    }\n-                }\n-            }\n-            vfs::loader::Message::Progress { n_total, n_done } => {\n-                let state = if n_done == 0 {\n-                    Progress::Begin\n-                } else if n_done < n_total {\n-                    Progress::Report\n-                } else {\n-                    assert_eq!(n_done, n_total);\n-                    global_state.status = Status::Ready;\n-                    became_ready = true;\n-                    Progress::End\n-                };\n-                report_progress(\n-                    global_state,\n-                    &connection.sender,\n-                    \"roots scanned\",\n-                    state,\n-                    Some(format!(\"{}/{}\", n_done, n_total)),\n-                    Some(percentage(n_done, n_total)),\n-                )\n-            }\n-        },\n-        Event::Flycheck(task) => on_check_task(task, global_state, &connection.sender)?,\n-        Event::Lsp(msg) => match msg {\n-            lsp_server::Message::Request(req) => {\n-                on_request(global_state, &connection.sender, loop_start, req)?\n-            }\n-            lsp_server::Message::Notification(not) => {\n-                on_notification(&connection.sender, global_state, not)?;\n-            }\n-            lsp_server::Message::Response(resp) => {\n-                let handler = global_state.req_queue.outgoing.complete(resp.id.clone());\n-                handler(global_state, resp)\n-            }\n-        },\n-    };\n-\n-    let state_changed = global_state.process_changes();\n-\n-    if became_ready {\n-        if let Some(flycheck) = &global_state.flycheck {\n-            flycheck.0.update();\n-        }\n-    }\n-\n-    if global_state.status == Status::Ready && (state_changed || became_ready) {\n-        let subscriptions = global_state\n-            .mem_docs\n-            .iter()\n-            .map(|path| global_state.vfs.read().0.file_id(&path).unwrap())\n-            .collect::<Vec<_>>();\n-\n-        update_file_notifications_on_threadpool(global_state, subscriptions.clone());\n-        global_state.task_pool.0.spawn({\n-            let subs = subscriptions;\n-            let snap = global_state.snapshot();\n-            move || {\n-                snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ());\n-                Task::Unit\n-            }\n-        });\n-    }\n-\n-    let loop_duration = loop_start.elapsed();\n-    if loop_duration > Duration::from_millis(100) {\n-        log::error!(\"overly long loop turn: {:?}\", loop_duration);\n-        if env::var(\"RA_PROFILE\").is_ok() {\n-            show_message(\n-                lsp_types::MessageType::Error,\n-                format!(\"overly long loop turn: {:?}\", loop_duration),\n-                &connection.sender,\n-            );\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-fn on_task(task: Task, msg_sender: &Sender<lsp_server::Message>, global_state: &mut GlobalState) {\n-    match task {\n-        Task::Respond(response) => {\n-            if let Some((method, start)) =\n-                global_state.req_queue.incoming.complete(response.id.clone())\n-            {\n-                let duration = start.elapsed();\n-                log::info!(\"handled req#{} in {:?}\", response.id, duration);\n-                global_state.complete_request(RequestMetrics {\n-                    id: response.id.clone(),\n-                    method: method.to_string(),\n-                    duration,\n-                });\n-                msg_sender.send(response.into()).unwrap();\n-            }\n-        }\n-        Task::Diagnostics(tasks) => {\n-            tasks.into_iter().for_each(|task| on_diagnostic_task(task, msg_sender, global_state))\n-        }\n-        Task::Unit => (),\n-    }\n-}\n-\n-fn on_request(\n-    global_state: &mut GlobalState,\n-    msg_sender: &Sender<lsp_server::Message>,\n-    request_received: Instant,\n-    req: Request,\n-) -> Result<()> {\n-    let mut pool_dispatcher =\n-        PoolDispatcher { req: Some(req), global_state, msg_sender, request_received };\n-    pool_dispatcher\n-        .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n-        .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n-        .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n-        .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n-            handlers::handle_selection_range(s.snapshot(), p)\n-        })?\n-        .on_sync::<lsp_ext::MatchingBrace>(|s, p| handlers::handle_matching_brace(s.snapshot(), p))?\n-        .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)?\n-        .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)?\n-        .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)?\n-        .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)?\n-        .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n-        .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n-        .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n-        .on::<lsp_ext::ResolveCodeActionRequest>(handlers::handle_resolve_code_action)?\n-        .on::<lsp_ext::HoverRequest>(handlers::handle_hover)?\n-        .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n-        .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n-        .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n-        .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)?\n-        .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)?\n-        .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n-        .on::<lsp_types::request::Completion>(handlers::handle_completion)?\n-        .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)?\n-        .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n-        .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n-        .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n-        .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n-        .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n-        .on::<lsp_types::request::References>(handlers::handle_references)?\n-        .on::<lsp_types::request::Formatting>(handlers::handle_formatting)?\n-        .on::<lsp_types::request::DocumentHighlightRequest>(handlers::handle_document_highlight)?\n-        .on::<lsp_types::request::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)?\n-        .on::<lsp_types::request::CallHierarchyIncomingCalls>(\n-            handlers::handle_call_hierarchy_incoming,\n-        )?\n-        .on::<lsp_types::request::CallHierarchyOutgoingCalls>(\n-            handlers::handle_call_hierarchy_outgoing,\n-        )?\n-        .on::<lsp_types::request::SemanticTokensRequest>(handlers::handle_semantic_tokens)?\n-        .on::<lsp_types::request::SemanticTokensRangeRequest>(\n-            handlers::handle_semantic_tokens_range,\n-        )?\n-        .on::<lsp_ext::Ssr>(handlers::handle_ssr)?\n-        .finish();\n-    Ok(())\n-}\n-\n-fn on_notification(\n-    msg_sender: &Sender<lsp_server::Message>,\n-    global_state: &mut GlobalState,\n-    not: Notification,\n-) -> Result<()> {\n-    let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n-        Ok(params) => {\n-            let id: RequestId = match params.id {\n-                NumberOrString::Number(id) => id.into(),\n-                NumberOrString::String(id) => id.into(),\n-            };\n-            if let Some(response) = global_state.req_queue.incoming.cancel(id) {\n-                msg_sender.send(response.into()).unwrap()\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n-        Ok(params) => {\n-            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !global_state.mem_docs.insert(path.clone()) {\n-                    log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n-                }\n-                global_state\n-                    .vfs\n-                    .write()\n-                    .0\n-                    .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n-        Ok(params) => {\n-            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                assert!(global_state.mem_docs.contains(&path));\n-                let vfs = &mut global_state.vfs.write().0;\n-                let file_id = vfs.file_id(&path).unwrap();\n-                let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n-                apply_document_changes(&mut text, params.content_changes);\n-                vfs.set_file_contents(path, Some(text.into_bytes()))\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n-        Ok(params) => {\n-            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !global_state.mem_docs.remove(&path) {\n-                    log::error!(\"orphan DidCloseTextDocument: {}\", path)\n-                }\n-                if let Some(path) = path.as_path() {\n-                    global_state.loader.invalidate(path.to_path_buf());\n-                }\n-            }\n-            let params = lsp_types::PublishDiagnosticsParams {\n-                uri: params.text_document.uri,\n-                diagnostics: Vec::new(),\n-                version: None,\n-            };\n-            let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n-            msg_sender.send(not.into()).unwrap();\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n-        Ok(_params) => {\n-            if let Some(flycheck) = &global_state.flycheck {\n-                flycheck.0.update();\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidChangeConfiguration>(not) {\n-        Ok(_) => {\n-            // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n-            // this notification's parameters should be ignored and the actual config queried separately.\n-            let request = global_state.req_queue.outgoing.register(\n-                lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n-                lsp_types::ConfigurationParams {\n-                    items: vec![lsp_types::ConfigurationItem {\n-                        scope_uri: None,\n-                        section: Some(\"rust-analyzer\".to_string()),\n-                    }],\n-                },\n-                |global_state, resp| {\n-                    log::debug!(\"config update response: '{:?}\", resp);\n-                    let Response { error, result, .. } = resp;\n-\n-                    match (error, result) {\n-                        (Some(err), _) => {\n-                            log::error!(\"failed to fetch the server settings: {:?}\", err)\n-                        }\n-                        (None, Some(configs)) => {\n-                            if let Some(new_config) = configs.get(0) {\n-                                let mut config = global_state.config.clone();\n-                                config.update(&new_config);\n-                                global_state.update_configuration(config);\n-                            }\n-                        }\n-                        (None, None) => {\n-                            log::error!(\"received empty server settings response from the client\")\n-                        }\n-                    }\n-                },\n-            );\n-            msg_sender.send(request.into())?;\n-\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidChangeWatchedFiles>(not) {\n-        Ok(params) => {\n-            for change in params.changes {\n-                if let Ok(path) = from_proto::abs_path(&change.uri) {\n-                    global_state.loader.invalidate(path)\n-                }\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    if not.method.starts_with(\"$/\") {\n-        return Ok(());\n-    }\n-    log::error!(\"unhandled notification: {:?}\", not);\n-    Ok(())\n-}\n-\n-fn on_check_task(\n-    task: flycheck::Message,\n-    global_state: &mut GlobalState,\n-    msg_sender: &Sender<lsp_server::Message>,\n-) -> Result<()> {\n+fn on_check_task(task: flycheck::Message, global_state: &mut GlobalState) -> Result<()> {\n     match task {\n         flycheck::Message::ClearDiagnostics => {\n-            on_diagnostic_task(DiagnosticTask::ClearCheck, msg_sender, global_state)\n+            on_diagnostic_task(DiagnosticTask::ClearCheck, global_state)\n         }\n \n         flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n@@ -550,7 +558,6 @@ fn on_check_task(\n                         diag.diagnostic,\n                         diag.fixes.into_iter().map(|it| it.into()).collect(),\n                     ),\n-                    msg_sender,\n                     global_state,\n                 )\n             }\n@@ -563,26 +570,22 @@ fn on_check_task(\n                 flycheck::Progress::End => (Progress::End, None),\n             };\n \n-            report_progress(global_state, msg_sender, \"cargo check\", state, message, None);\n+            report_progress(global_state, \"cargo check\", state, message, None);\n         }\n     };\n \n     Ok(())\n }\n \n-fn on_diagnostic_task(\n-    task: DiagnosticTask,\n-    msg_sender: &Sender<lsp_server::Message>,\n-    state: &mut GlobalState,\n-) {\n-    let subscriptions = state.diagnostics.handle_task(task);\n+fn on_diagnostic_task(task: DiagnosticTask, global_state: &mut GlobalState) {\n+    let subscriptions = global_state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n-        let url = file_id_to_url(&state.vfs.read().0, file_id);\n-        let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n+        let url = file_id_to_url(&global_state.vfs.read().0, file_id);\n+        let diagnostics = global_state.diagnostics.diagnostics_for(file_id).cloned().collect();\n         let params = lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None };\n         let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n-        msg_sender.send(not.into()).unwrap();\n+        global_state.send(not.into());\n     }\n }\n \n@@ -599,7 +602,6 @@ fn percentage(done: usize, total: usize) -> f64 {\n \n fn report_progress(\n     global_state: &mut GlobalState,\n-    sender: &Sender<lsp_server::Message>,\n     title: &str,\n     state: Progress,\n     message: Option<String>,\n@@ -616,7 +618,7 @@ fn report_progress(\n                 lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n                 DO_NOTHING,\n             );\n-            sender.send(work_done_progress_create.into()).unwrap();\n+            global_state.send(work_done_progress_create.into());\n \n             lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n                 title: title.into(),\n@@ -641,13 +643,12 @@ fn report_progress(\n             token,\n             value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n         });\n-    sender.send(notification.into()).unwrap();\n+    global_state.send(notification.into());\n }\n \n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     global_state: &'a mut GlobalState,\n-    msg_sender: &'a Sender<lsp_server::Message>,\n     request_received: Instant,\n }\n \n@@ -674,7 +675,7 @@ impl<'a> PoolDispatcher<'a> {\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.global_state);\n+        self.global_state.on_task(task);\n         Ok(self)\n     }\n \n@@ -736,7 +737,7 @@ impl<'a> PoolDispatcher<'a> {\n                     ErrorCode::MethodNotFound as i32,\n                     \"unknown request\".to_string(),\n                 );\n-                self.msg_sender.send(resp.into()).unwrap();\n+                self.global_state.send(resp.into());\n             }\n         }\n     }\n@@ -767,29 +768,3 @@ where\n     };\n     Task::Respond(response)\n }\n-\n-fn update_file_notifications_on_threadpool(\n-    global_state: &mut GlobalState,\n-    subscriptions: Vec<FileId>,\n-) {\n-    log::trace!(\"updating notifications for {:?}\", subscriptions);\n-    if global_state.config.publish_diagnostics {\n-        let snapshot = global_state.snapshot();\n-        global_state.task_pool.0.spawn(move || {\n-            let diagnostics = subscriptions\n-                .into_iter()\n-                .filter_map(|file_id| {\n-                    handlers::publish_diagnostics(&snapshot, file_id)\n-                        .map_err(|err| {\n-                            if !is_canceled(&*err) {\n-                                log::error!(\"failed to compute diagnostics: {:?}\", err);\n-                            }\n-                            ()\n-                        })\n-                        .ok()\n-                })\n-                .collect::<Vec<_>>();\n-            Task::Diagnostics(diagnostics)\n-        })\n-    }\n-}"}, {"sha": "25ba8d7982dd3fee97150198c4e2ea34d7d512f1", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379a096de9ad06c23347b76a54d9cc22aee80f6a/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=379a096de9ad06c23347b76a54d9cc22aee80f6a", "patch": "@@ -82,7 +82,12 @@ impl NotifyActor {\n             watcher_receiver,\n         }\n     }\n-\n+    fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n+        select! {\n+            recv(receiver) -> it => it.ok().map(Event::Message),\n+            recv(&self.watcher_receiver) -> it => Some(Event::NotifyEvent(it.unwrap())),\n+        }\n+    }\n     fn run(mut self, inbox: Receiver<Message>) {\n         while let Some(event) = self.next_event(&inbox) {\n             log::debug!(\"vfs-notify event: {:?}\", event);\n@@ -154,12 +159,6 @@ impl NotifyActor {\n             }\n         }\n     }\n-    fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n-        select! {\n-            recv(receiver) -> it => it.ok().map(Event::Message),\n-            recv(&self.watcher_receiver) -> it => Some(Event::NotifyEvent(it.unwrap())),\n-        }\n-    }\n     fn load_entry(\n         &mut self,\n         entry: loader::Entry,"}]}