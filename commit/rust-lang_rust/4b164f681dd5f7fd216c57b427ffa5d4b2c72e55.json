{"sha": "4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMTY0ZjY4MWRkNWY3ZmQyMTZjNTdiNDI3ZmZhNWQ0YjJjNzJlNTU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-08T17:04:17Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-20T20:14:11Z"}, "message": "Correctly lower paths to generic associated types", "tree": {"sha": "53ad51b504d9b5bc5e2bf6975ed3bdee64bc1ff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53ad51b504d9b5bc5e2bf6975ed3bdee64bc1ff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "html_url": "https://github.com/rust-lang/rust/commit/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5028f686d6fa27cef8d96b5c82d23bd61bdb0a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5028f686d6fa27cef8d96b5c82d23bd61bdb0a5", "html_url": "https://github.com/rust-lang/rust/commit/c5028f686d6fa27cef8d96b5c82d23bd61bdb0a5"}], "stats": {"total": 117, "additions": 95, "deletions": 22}, "files": [{"sha": "b105180b4875cfcd2980607de6c7e4b5ede1061b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "patch": "@@ -1305,7 +1305,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_>) -> PolyTraitRef<'tcx> {\n+    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our"}, {"sha": "465262181f41ea87585a3cc6b3ffacb80b548ef3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "patch": "@@ -1026,11 +1026,11 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// Extracts the underlying trait reference from this projection.\n     /// For example, if this is a projection of `<T as Iterator>::Item`,\n     /// then this function would return a `T: Iterator` trait reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::TraitRef<'tcx> {\n+    pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::TraitRef {\n             def_id,\n-            substs: self.substs,\n+            substs: self.substs.truncate_to(tcx, tcx.generics_of(def_id)),\n         }\n     }\n "}, {"sha": "9b737428d5aaf9807188a7851ce02e32a6ae27d5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "patch": "@@ -88,6 +88,7 @@ pub trait AstConv<'tcx> {\n     fn projected_ty_from_poly_trait_ref(&self,\n                                         span: Span,\n                                         item_def_id: DefId,\n+                                        item_segment: &hir::PathSegment,\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>;\n \n@@ -205,6 +206,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n             span,\n             def_id,\n+            &[],\n             item_segment.generic_args(),\n             item_segment.infer_args,\n             None,\n@@ -615,9 +617,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///    `Output = u32` are returned in the `Vec<ConvertedBinding...>` result.\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n+    ///\n+    /// For (generic) associated types\n+    ///\n+    /// ```\n+    /// <Vec<u8> as Iterable<u8>>::Iter::<'a>\n+    /// ```\n+    ///\n+    /// We have the parent substs are the substs for the parent trait:\n+    /// `[Vec<u8>, u8]` and `generic_args` are the arguments for the associated\n+    /// type itself: `['a]`. The returned `SubstsRef` concatenates these two\n+    /// lists: `[Vec<u8>, u8, 'a]`.\n     fn create_substs_for_ast_path<'a>(&self,\n         span: Span,\n         def_id: DefId,\n+        parent_substs: &[subst::GenericArg<'tcx>],\n         generic_args: &'a hir::GenericArgs,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>)\n@@ -633,17 +647,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n         let generic_params = tcx.generics_of(def_id);\n \n-        // If a self-type was declared, one should be provided.\n-        assert_eq!(generic_params.has_self, self_ty.is_some());\n+        if generic_params.has_self {\n+            if generic_params.parent.is_some() {\n+                // The parent is a trait so it should have at least one subst\n+                // for the `Self` type.\n+                assert!(!parent_substs.is_empty())\n+            } else {\n+                // This item (presumably a trait) needs a self-type.\n+                assert!(self_ty.is_some());\n+            }\n+        } else {\n+            assert!(self_ty.is_none() && parent_substs.is_empty());\n+        }\n \n-        let has_self = generic_params.has_self;\n         let (_, potential_assoc_types) = Self::check_generic_arg_count(\n             tcx,\n             span,\n             &generic_params,\n             &generic_args,\n             GenericArgPosition::Type,\n-            has_self,\n+            self_ty.is_some(),\n             infer_args,\n         );\n \n@@ -652,7 +675,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default && has_self {\n+                if is_object && has_default {\n                     let self_param = tcx.types.self_param;\n                     if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n                         // There is no suitable inference default for a type parameter\n@@ -668,7 +691,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let substs = Self::create_substs_for_generic_args(\n             tcx,\n             def_id,\n-            &[][..],\n+            parent_substs,\n             self_ty.is_some(),\n             self_ty,\n             // Provide the generic args, and whether types should be inferred.\n@@ -780,6 +803,30 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         (substs, assoc_bindings, potential_assoc_types)\n     }\n \n+    crate fn create_substs_for_associated_item(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        item_def_id: DefId,\n+        item_segment: &hir::PathSegment,\n+        parent_substs: SubstsRef<'tcx>,\n+    ) -> SubstsRef<'tcx> {\n+        if tcx.generics_of(item_def_id).params.is_empty() {\n+            self.prohibit_generics(slice::from_ref(item_segment));\n+\n+            parent_substs\n+        } else {\n+            self.create_substs_for_ast_path(\n+                span,\n+                item_def_id,\n+                parent_substs,\n+                item_segment.generic_args(),\n+                item_segment.infer_args,\n+                None,\n+            ).0\n+        }\n+    }\n+\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the `DefId` of the defining trait.\n     /// The type _cannot_ be a type other than a trait type.\n@@ -919,6 +966,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         self.create_substs_for_ast_path(span,\n                                         trait_def_id,\n+                                        &[],\n                                         trait_segment.generic_args(),\n                                         trait_segment.infer_args,\n                                         Some(self_ty))\n@@ -1665,8 +1713,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n \n-        self.prohibit_generics(slice::from_ref(assoc_segment));\n-\n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n         if let ty::Adt(adt_def, _) = qself_ty.kind {\n@@ -1677,6 +1723,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n+                        self.prohibit_generics(slice::from_ref(assoc_segment));\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n                         variant_resolution = Some(variant_def.def_id);\n@@ -1767,7 +1814,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n \n-        let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n+        let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, assoc_segment, bound);\n         let ty = self.normalize_ty(span, ty);\n \n         let kind = DefKind::AssocTy;\n@@ -1818,8 +1865,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: trait_def_id={:?}\", trait_def_id);\n \n-        self.prohibit_generics(slice::from_ref(item_segment));\n-\n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n         } else {\n@@ -1861,9 +1906,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                                         self_ty,\n                                                         trait_segment);\n \n+        let item_substs = self.create_substs_for_associated_item(\n+            tcx,\n+            span,\n+            item_def_id,\n+            item_segment,\n+            trait_ref.substs,\n+        );\n+\n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.normalize_ty(span, tcx.mk_projection(item_def_id, trait_ref.substs))\n+        self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n     pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment>>(\n@@ -2518,21 +2571,22 @@ impl<'tcx> Bounds<'tcx> {\n         // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {\n-                let trait_ref = ty::TraitRef {\n+                let trait_ref = ty::Binder::bind(ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[])\n-                };\n+                });\n                 (trait_ref.to_predicate(), span)\n             })\n         });\n \n         sized_predicate.into_iter().chain(\n             self.region_bounds.iter().map(|&(region_bound, span)| {\n                 // Account for the binder being introduced below; no need to shift `param_ty`\n-                // because, at present at least, it can only refer to early-bound regions.\n+                // because, at present at least, it either only refers to early-bound regions,\n+                // or it's a generic associated type that deliberately has escaping bound vars.\n                 let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                 let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                (ty::Binder::dummy(outlives).to_predicate(), span)\n+                (ty::Binder::bind(outlives).to_predicate(), span)\n             }).chain(\n                 self.trait_bounds.iter().map(|&(bound_trait_ref, span)| {\n                     (bound_trait_ref.to_predicate(), span)"}, {"sha": "c96ace5881e6567b2b5469e092d7e69029748a6a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "patch": "@@ -2613,6 +2613,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn projected_ty_from_poly_trait_ref(&self,\n                                         span: Span,\n                                         item_def_id: DefId,\n+                                        item_segment: &hir::PathSegment,\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n@@ -2622,7 +2623,16 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             &poly_trait_ref\n         );\n \n-        self.tcx().mk_projection(item_def_id, trait_ref.substs)\n+        let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n+            self,\n+            self.tcx,\n+            span,\n+            item_def_id,\n+            item_segment,\n+            trait_ref.substs,\n+        );\n+\n+        self.tcx().mk_projection(item_def_id, item_substs)\n     }\n \n     fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "27285632fdc6d8aca85fd4dd653140e93df179ac", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "patch": "@@ -224,10 +224,19 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n+        item_segment: &hir::PathSegment,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n-            self.tcx().mk_projection(item_def_id, trait_ref.substs)\n+            let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n+                self,\n+                self.tcx,\n+                span,\n+                item_def_id,\n+                item_segment,\n+                trait_ref.substs,\n+            );\n+            self.tcx().mk_projection(item_def_id, item_substs)\n         } else {\n             // There are no late-bound regions; we can just ignore the binder.\n             span_err!("}, {"sha": "a3a703cf50e9807efb0bfee0c2e581d444d5dee3", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b164f681dd5f7fd216c57b427ffa5d4b2c72e55/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=4b164f681dd5f7fd216c57b427ffa5d4b2c72e55", "patch": "@@ -135,7 +135,7 @@ pub fn identify_constrained_generic_params<'tcx>(\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(\n-    tcx: TyCtxt<'_>,\n+    tcx: TyCtxt<'tcx>,\n     predicates: &mut [(ty::Predicate<'tcx>, Span)],\n     impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n     input_parameters: &mut FxHashSet<Parameter>,"}]}