{"sha": "e1280d81af3101d918fcd1ff9ca040b59e7d907b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMjgwZDgxYWYzMTAxZDkxOGZjZDFmZjljYTA0MGI1OWU3ZDkwN2I=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-01-17T07:42:11Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-01-26T18:57:23Z"}, "message": "Point to immutable arg/fields when trying to use as &mut\n\nPoint to immutable borrow arguments and fields when trying to use them as\nmutable borrows. Add label to primary span on \"cannot borrow as mutable\"\nerrors.\n\nPresent the following output when trying to access an immutable borrow's\nfield as mutable:\n\n```\nerror[E0389]: cannot borrow data mutably in a `&` reference\n  --> $DIR/issue-38147-1.rs:27:9\n   |\n26 | fn f(&self) {\n   |      -----  use `&mut self` here to make mutable\n27 |     f.s.push('x');\n   |     ^^^ assignment into an immutable reference\n```\n\nAnd the following when trying to access an immutable struct field as mutable:\n\n```\nerror: cannot borrow immutable borrowed content `*self.s` as mutable\n  --> $DIR/issue-38147-3.rs:17:9\n   |\n12 |     s: &'a String\n   |     ------------- use `&'a mut String` here to make mutable\n...|\n16 |     fn f(&self) {\n   |          -----  use `&mut self` here to make mutable\n17 |         self.s.push('x');\n   |         ^^^^^^ cannot borrow as mutable\n```", "tree": {"sha": "a9d70a19087b78e9a12fb9ae46aeea8365ebe369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d70a19087b78e9a12fb9ae46aeea8365ebe369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1280d81af3101d918fcd1ff9ca040b59e7d907b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1280d81af3101d918fcd1ff9ca040b59e7d907b", "html_url": "https://github.com/rust-lang/rust/commit/e1280d81af3101d918fcd1ff9ca040b59e7d907b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1280d81af3101d918fcd1ff9ca040b59e7d907b/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "491b978822a56f23acf9ba46f90861958bc1e36c", "url": "https://api.github.com/repos/rust-lang/rust/commits/491b978822a56f23acf9ba46f90861958bc1e36c", "html_url": "https://github.com/rust-lang/rust/commit/491b978822a56f23acf9ba46f90861958bc1e36c"}], "stats": {"total": 377, "additions": 310, "deletions": 67}, "files": [{"sha": "ff2f1dc1ba28a85f83f67d795c56ed2f50cfeaa5", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -38,7 +38,7 @@ use syntax_pos::Span;\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct FnLikeNode<'a> { node: map::Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object"}, {"sha": "85902af68538f66f0e18780a03e7e43d2eb29ed2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -193,6 +193,63 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n+impl<'tcx> cmt_<'tcx> {\n+    pub fn get_field(&self, name: ast::Name) -> Option<DefId> {\n+        match self.cat {\n+            Categorization::Deref(ref cmt, ..) |\n+            Categorization::Interior(ref cmt, _) |\n+            Categorization::Downcast(ref cmt, _) => {\n+                if let Categorization::Local(_) = cmt.cat {\n+                    if let ty::TyAdt(def, _) = self.ty.sty {\n+                        return def.struct_variant().find_field_named(name).map(|x| x.did);\n+                    }\n+                    None\n+                } else {\n+                    cmt.get_field(name)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    pub fn get_field_name(&self) -> Option<ast::Name> {\n+        match self.cat {\n+            Categorization::Interior(_, ref ik) => {\n+                if let InteriorKind::InteriorField(FieldName::NamedField(name)) = *ik {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            }\n+            Categorization::Deref(ref cmt, ..) |\n+            Categorization::Downcast(ref cmt, _) => {\n+                cmt.get_field_name()\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn get_arg_if_immutable(&self, map: &hir_map::Map) -> Option<ast::NodeId> {\n+        match self.cat {\n+            Categorization::Deref(ref cmt, ..) |\n+            Categorization::Interior(ref cmt, _) |\n+            Categorization::Downcast(ref cmt, _) => {\n+                if let Categorization::Local(nid) = cmt.cat {\n+                    if let ty::TyAdt(_, _) = self.ty.sty {\n+                        if let ty::TyRef(_, ty::TypeAndMut{mutbl: MutImmutable, ..}) = cmt.ty.sty {\n+                            return Some(nid);\n+                        }\n+                    }\n+                    None\n+                } else {\n+                    cmt.get_arg_if_immutable(map)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+}\n+\n pub trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;"}, {"sha": "36fc5149b40d8de66d41539e33013093c21eb45d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -1325,6 +1325,7 @@ bitflags! {\n     }\n }\n \n+#[derive(Debug)]\n pub struct VariantDef {\n     /// The variant's DefId. If this is a tuple-like struct,\n     /// this is the DefId of the struct's ctor.\n@@ -1335,6 +1336,7 @@ pub struct VariantDef {\n     pub ctor_kind: CtorKind,\n }\n \n+#[derive(Debug)]\n pub struct FieldDef {\n     pub did: DefId,\n     pub name: Name,"}, {"sha": "d6164e69ffd3a9656fea55571ac0e4209f011d12", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -134,7 +134,7 @@ pub enum TypeVariants<'tcx> {\n     TyRawPtr(TypeAndMut<'tcx>),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&a mut T` or `&'a T`.\n+    /// `&'a mut T` or `&'a T`.\n     TyRef(&'tcx Region, TypeAndMut<'tcx>),\n \n     /// The anonymous type of a function declaration/definition. Each"}, {"sha": "1783ca74a25923fdf4fcad56f6b5a29c75e93788", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -195,15 +195,17 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         loan_cause,\n-                        mc::AliasableReason::UnaliasableImmutable);\n+                        mc::AliasableReason::UnaliasableImmutable,\n+                        cmt);\n             Err(())\n         }\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         loan_cause,\n-                        alias_cause);\n+                        alias_cause,\n+                        cmt);\n             Err(())\n         }\n         (..) => {"}, {"sha": "4386a5bd1591d6a8fd37be17c9526bb0d6858fc2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -540,7 +540,7 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n // Errors\n \n // Errors that can occur\n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub enum bckerr_code<'tcx> {\n     err_mutbl,\n     /// superscope, subscope, loan cause\n@@ -550,7 +550,7 @@ pub enum bckerr_code<'tcx> {\n \n // Combination of an error code and the categorization of the expression\n // that caused it\n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub struct BckError<'tcx> {\n     span: Span,\n     cause: AliasableViolationKind,\n@@ -601,12 +601,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             _ => { }\n         }\n \n-        // General fallback.\n-        let span = err.span.clone();\n-        let mut db = self.struct_span_err(\n-            err.span,\n-            &self.bckerr_to_string(&err));\n-        self.note_and_explain_bckerr(&mut db, err, span);\n+        let mut db = self.bckerr_to_diag(&err);\n+        self.note_and_explain_bckerr(&mut db, err);\n         db.emit();\n     }\n \n@@ -771,8 +767,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    pub fn bckerr_to_string(&self, err: &BckError<'tcx>) -> String {\n-        match err.code {\n+    pub fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n+        let span = err.span.clone();\n+        let mut immutable_field = None;\n+\n+        let msg = &match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n                     mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n@@ -783,6 +782,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             format!(\"{} {}\",\n                                     err.cmt.mutbl.to_user_str(),\n                                     self.cmt_to_string(&err.cmt))\n+\n                         }\n                         Some(lp) => {\n                             format!(\"{} {} `{}`\",\n@@ -807,6 +807,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n+                        // Check for this field's definition to see if it is an immutable reference\n+                        // and suggest making it mutable if that is the case.\n+                        immutable_field = err.cmt.get_field_name()\n+                            .and_then(|name| err.cmt.get_field(name))\n+                            .and_then(|did| self.tcx.hir.as_local_node_id(did))\n+                            .and_then(|nid| {\n+                                if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(nid) {\n+                                    return self.suggest_mut_for_immutable(&field.ty)\n+                                        .map(|msg| (self.tcx.hir.span(nid), msg));\n+                                }\n+                                None\n+                            });\n+\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n@@ -830,13 +843,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                          its contents can be safely reborrowed\",\n                         descr)\n             }\n+        };\n+\n+        let mut db = self.struct_span_err(span, msg);\n+        if let Some((span, msg)) = immutable_field {\n+            db.span_label(span, &msg);\n         }\n+        db\n     }\n \n     pub fn report_aliasability_violation(&self,\n                                          span: Span,\n                                          kind: AliasableViolationKind,\n-                                         cause: mc::AliasableReason) {\n+                                         cause: mc::AliasableReason,\n+                                         cmt: mc::cmt<'tcx>) {\n         let mut is_closure = false;\n         let prefix = match kind {\n             MutabilityViolation => {\n@@ -903,6 +923,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     self.tcx.sess, span, E0389,\n                     \"{} in a `&` reference\", prefix);\n                 e.span_label(span, &\"assignment into an immutable reference\");\n+                if let Some(nid) = cmt.get_arg_if_immutable(&self.tcx.hir) {\n+                    self.immutable_argument_should_be_mut(nid, &mut e);\n+                }\n                 e\n             }\n         };\n@@ -913,6 +936,55 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n+    /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n+    fn suggest_mut_for_immutable(&self, pty: &hir::Ty) -> Option<String> {\n+        // Check wether the argument is an immutable reference\n+        if let hir::TyRptr(opt_lifetime, hir::MutTy {\n+            mutbl: hir::Mutability::MutImmutable,\n+            ref ty\n+        }) = pty.node {\n+            // Account for existing lifetimes when generating the message\n+            if let Some(lifetime) = opt_lifetime {\n+                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(ty.span) {\n+                    if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n+                        .span_to_snippet(lifetime.span) {\n+                            return Some(format!(\"use `&{} mut {}` here to make mutable\",\n+                                                lifetime_snippet,\n+                                                snippet));\n+                    }\n+                }\n+            } else if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(pty.span) {\n+                if snippet.starts_with(\"&\") {\n+                    return Some(format!(\"use `{}` here to make mutable\",\n+                                        snippet.replace(\"&\", \"&mut \")));\n+                }\n+            } else {\n+                bug!(\"couldn't find a snippet for span: {:?}\", pty.span);\n+            }\n+        }\n+        None\n+    }\n+\n+    fn immutable_argument_should_be_mut(&self, nid: ast::NodeId, db: &mut DiagnosticBuilder) {\n+        let parent = self.tcx.hir.get_parent_node(nid);\n+        let parent_node = self.tcx.hir.get(parent);\n+\n+        // The parent node is like a fn\n+        if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n+            // `nid`'s parent's `Body`\n+            let fn_body = self.tcx.hir.body(fn_like.body());\n+            // Get the position of `nid` in the arguments list\n+            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == nid);\n+            if let Some(i) = arg_pos {\n+                // The argument's `Ty`\n+                let arg_ty = &fn_like.decl().inputs[i];\n+                if let Some(msg) = self.suggest_mut_for_immutable(&arg_ty) {\n+                    db.span_label(arg_ty.span, &msg);\n+                }\n+            }\n+        }\n+    }\n+\n     fn report_out_of_scope_escaping_closure_capture(&self,\n                                                     err: &BckError<'tcx>,\n                                                     capture_span: Span)\n@@ -961,8 +1033,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>,\n-        error_span: Span) {\n+    pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n+        let error_span = err.span.clone();\n         match err.code {\n             err_mutbl => self.note_and_explain_mutbl_error(db, &err, &error_span),\n             err_out_of_scope(super_scope, sub_scope, cause) => {\n@@ -1103,41 +1175,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             _ => {\n-                if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n-                    if let Categorization::Local(local_id) = inner_cmt.cat {\n-                        let parent = self.tcx.hir.get_parent_node(local_id);\n-\n-                        if let Some(fn_like) = FnLikeNode::from_node(self.tcx.hir.get(parent)) {\n-                            if let Some(i) = self.tcx.hir.body(fn_like.body()).arguments.iter()\n-                                                     .position(|arg| arg.pat.id == local_id) {\n-                                let arg_ty = &fn_like.decl().inputs[i];\n-                                if let hir::TyRptr(\n-                                    opt_lifetime,\n-                                    hir::MutTy{mutbl: hir::Mutability::MutImmutable, ref ty}) =\n-                                    arg_ty.node {\n-                                    if let Some(lifetime) = opt_lifetime {\n-                                        if let Ok(snippet) = self.tcx.sess.codemap()\n-                                            .span_to_snippet(ty.span) {\n-                                            if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n-                                                .span_to_snippet(lifetime.span) {\n-                                                    db.span_label(arg_ty.span,\n-                                                                  &format!(\"use `&{} mut {}` \\\n-                                                                            here to make mutable\",\n-                                                                            lifetime_snippet,\n-                                                                            snippet));\n-                                            }\n-                                        }\n-                                    }\n-                                    else if let Ok(snippet) = self.tcx.sess.codemap()\n-                                        .span_to_snippet(arg_ty.span) {\n-                                        if snippet.starts_with(\"&\") {\n-                                            db.span_label(arg_ty.span,\n-                                                          &format!(\"use `{}` here to make mutable\",\n-                                                                   snippet.replace(\"&\", \"&mut \")));\n-                                        }\n-                                    }\n-                                }\n-                            }\n+                if let Categorization::Deref(..) = err.cmt.cat {\n+                    db.span_label(*error_span, &\"cannot borrow as mutable\");\n+                    if let Some(local_id) = err.cmt.get_arg_if_immutable(&self.tcx.hir) {\n+                        self.immutable_argument_should_be_mut(local_id, db);\n+                    } else if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n+                        if let Categorization::Local(local_id) = inner_cmt.cat {\n+                            self.immutable_argument_should_be_mut(local_id, db);\n                         }\n                     }\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {"}, {"sha": "136921dd0a5694838942d8db7f255bc3b92cbabe", "filename": "src/test/ui/did_you_mean/issue-38147-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Pass<'a> {\n+    s: &'a mut String\n+}\n+\n+impl<'a> Pass<'a> {\n+    fn f(&mut self) {\n+        self.s.push('x');\n+    }\n+}\n+\n+struct Foo<'a> {\n+    s: &'a mut String\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn f(&self) {\n+        self.s.push('x');\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e9f2b1dad806d52429b48060b5a1136315856584", "filename": "src/test/ui/did_you_mean/issue-38147-1.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,10 @@\n+error[E0389]: cannot borrow data mutably in a `&` reference\n+  --> $DIR/issue-38147-1.rs:27:9\n+   |\n+26 |     fn f(&self) {\n+   |          ----- use `&mut self` here to make mutable\n+27 |         self.s.push('x');\n+   |         ^^^^^^ assignment into an immutable reference\n+\n+error: aborting due to previous error\n+"}, {"sha": "a5d533edf75ecdc61ca80bfadf27eeaf9dedd57f", "filename": "src/test/ui/did_you_mean/issue-38147-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Bar<'a> {\n+    s: &'a String\n+}\n+\n+impl<'a> Bar<'a> {\n+    fn f(&mut self) {\n+        self.s.push('x');\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fdaf0cd44d9d4626900657bba701823726b49b76", "filename": "src/test/ui/did_you_mean/issue-38147-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,11 @@\n+error: cannot borrow immutable borrowed content `*self.s` as mutable\n+  --> $DIR/issue-38147-2.rs:17:9\n+   |\n+12 |     s: &'a String\n+   |     ------------- use `&'a mut String` here to make mutable\n+...\n+17 |         self.s.push('x');\n+   |         ^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+"}, {"sha": "5e8f2d3eaefaab67f3e7e65da458141a083d1b5a", "filename": "src/test/ui/did_you_mean/issue-38147-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Qux<'a> {\n+    s: &'a String\n+}\n+\n+impl<'a> Qux<'a> {\n+    fn f(&self) {\n+        self.s.push('x');\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d2280fa561bdeb12cf049731f2c2f7c83104692d", "filename": "src/test/ui/did_you_mean/issue-38147-3.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,13 @@\n+error: cannot borrow immutable borrowed content `*self.s` as mutable\n+  --> $DIR/issue-38147-3.rs:17:9\n+   |\n+12 |     s: &'a String\n+   |     ------------- use `&'a mut String` here to make mutable\n+...\n+16 |     fn f(&self) {\n+   |          ----- use `&mut self` here to make mutable\n+17 |         self.s.push('x');\n+   |         ^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+"}, {"sha": "4eb20ceeed48e50a1b32f8204dafe21e97279bc8", "filename": "src/test/ui/did_you_mean/issue-38147-4.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.rs?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'a> {\n+    s: &'a mut String\n+}\n+\n+fn f(x: usize, f: &Foo) {\n+    f.s.push('x');\n+}\n+\n+fn main() {}"}, {"sha": "9a8853f4fbbdb15dfe2bfa8330db4c5b4d4e8344", "filename": "src/test/ui/did_you_mean/issue-38147-4.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -0,0 +1,10 @@\n+error[E0389]: cannot borrow data mutably in a `&` reference\n+  --> $DIR/issue-38147-4.rs:16:5\n+   |\n+15 | fn f(x: usize, f: &Foo) {\n+   |                   ---- use `&mut Foo` here to make mutable\n+16 |     f.s.push('x');\n+   |     ^^^ assignment into an immutable reference\n+\n+error: aborting due to previous error\n+"}, {"sha": "b83a6aaebf3232026db99be66a7af5d9ebccf1e6", "filename": "src/test/ui/span/borrowck-borrow-overloaded-auto-deref-mut.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -12,7 +12,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 74 | fn deref_extend_mut_field1(x: &Own<Point>) -> &mut isize {\n    |                               ----------- use `&mut Own<Point>` here to make mutable\n 75 |     &mut x.y //~ ERROR cannot borrow\n-   |          ^\n+   |          ^ cannot borrow as mutable\n \n error[E0499]: cannot borrow `*x` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:88:19\n@@ -38,7 +38,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 101 | fn assign_field2<'a>(x: &'a Own<Point>) {\n     |                         -------------- use `&'a mut Own<Point>` here to make mutable\n 102 |     x.y = 3; //~ ERROR cannot borrow\n-    |     ^\n+    |     ^ cannot borrow as mutable\n \n error[E0499]: cannot borrow `*x` as mutable more than once at a time\n    --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:111:5\n@@ -64,7 +64,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 130 | fn deref_extend_mut_method1(x: &Own<Point>) -> &mut isize {\n     |                                ----------- use `&mut Own<Point>` here to make mutable\n 131 |     x.y_mut() //~ ERROR cannot borrow\n-    |     ^\n+    |     ^ cannot borrow as mutable\n \n error: cannot borrow immutable argument `x` as mutable\n    --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:139:6\n@@ -80,7 +80,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 142 | fn assign_method2<'a>(x: &'a Own<Point>) {\n     |                          -------------- use `&'a mut Own<Point>` here to make mutable\n 143 |     *x.y_mut() = 3; //~ ERROR cannot borrow\n-    |      ^\n+    |      ^ cannot borrow as mutable\n \n error: aborting due to 10 previous errors\n "}, {"sha": "af954a4d7924f1bada77d8e0be10738ad34af0dc", "filename": "src/test/ui/span/borrowck-borrow-overloaded-deref-mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -12,7 +12,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 50 | fn deref_extend_mut1<'a>(x: &'a Own<isize>) -> &'a mut isize {\n    |                             -------------- use `&'a mut Own<isize>` here to make mutable\n 51 |     &mut **x //~ ERROR cannot borrow\n-   |           ^^\n+   |           ^^ cannot borrow as mutable\n \n error: cannot borrow immutable argument `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:59:6\n@@ -28,7 +28,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 62 | fn assign2<'a>(x: &'a Own<isize>) {\n    |                   -------------- use `&'a mut Own<isize>` here to make mutable\n 63 |     **x = 3; //~ ERROR cannot borrow\n-   |      ^^\n+   |      ^^ cannot borrow as mutable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f2f0e027f0161927da53cdb4f77f8dfe8e445a53", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -17,13 +17,15 @@ error: cannot borrow immutable borrowed content `*f` as mutable\n 35 | fn test2<F>(f: &F) where F: FnMut() {\n    |                -- use `&mut F` here to make mutable\n 36 |     (*f)(); //~ ERROR: cannot borrow immutable borrowed content `*f` as mutable\n-   |     ^^^^\n+   |     ^^^^ cannot borrow as mutable\n \n error: cannot borrow immutable `Box` content `*f.f` as mutable\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:44:5\n    |\n+43 | fn test4(f: &Test) {\n+   |             ----- use `&mut Test` here to make mutable\n 44 |     f.f.call_mut(()) //~ ERROR: cannot borrow immutable `Box` content `*f.f` as mutable\n-   |     ^^^\n+   |     ^^^ cannot borrow as mutable\n \n error[E0504]: cannot move `f` into closure because it is borrowed\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:63:13"}, {"sha": "2349bfaf75e6f4fe37c3fde7703a554142b6ad4a", "filename": "src/test/ui/span/borrowck-call-method-from-mut-aliasable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -5,7 +5,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n    |         ---- use `&mut Foo` here to make mutable\n 26 |     x.f();\n 27 |     x.h(); //~ ERROR cannot borrow\n-   |     ^\n+   |     ^ cannot borrow as mutable\n \n error: aborting due to previous error\n "}, {"sha": "251a9e4aa57555730d0a988b08fd59cf839cd035", "filename": "src/test/ui/span/borrowck-fn-in-const-b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -4,7 +4,7 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n 16 |     fn broken(x: &Vec<String>) {\n    |                  ------------ use `&mut Vec<String>` here to make mutable\n 17 |         x.push(format!(\"this is broken\"));\n-   |         ^\n+   |         ^ cannot borrow as mutable\n \n error: aborting due to previous error\n "}, {"sha": "4ef1cb9c239e4ba3fe0ee5ce5a944714c8689ed4", "filename": "src/test/ui/span/borrowck-object-mutability.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -5,13 +5,13 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n    |                         ---- use `&mut Foo` here to make mutable\n 18 |     x.borrowed();\n 19 |     x.borrowed_mut(); //~ ERROR cannot borrow\n-   |     ^\n+   |     ^ cannot borrow as mutable\n \n error: cannot borrow immutable `Box` content `*x` as mutable\n   --> $DIR/borrowck-object-mutability.rs:29:5\n    |\n 29 |     x.borrowed_mut(); //~ ERROR cannot borrow\n-   |     ^\n+   |     ^ cannot borrow as mutable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e4ed062214715a823bc4ca1613bd4fab2a04a0cf", "filename": "src/test/ui/span/mut-arg-hint.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1280d81af3101d918fcd1ff9ca040b59e7d907b/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr?ref=e1280d81af3101d918fcd1ff9ca040b59e7d907b", "patch": "@@ -4,23 +4,23 @@ error: cannot borrow immutable borrowed content `*a` as mutable\n 17 | pub fn foo<'a>(mut a: &'a String) {\n    |                       ---------- use `&'a mut String` here to make mutable\n 18 |     a.push_str(\"foo\");\n-   |     ^\n+   |     ^ cannot borrow as mutable\n \n error: cannot borrow immutable borrowed content `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:13:9\n    |\n 12 |     fn foo(mut a: &String) {\n    |                   ------- use `&mut String` here to make mutable\n 13 |         a.push_str(\"bar\");\n-   |         ^\n+   |         ^ cannot borrow as mutable\n \n error: cannot borrow immutable borrowed content `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:25:9\n    |\n 24 |     pub fn foo(mut a: &String) {\n    |                       ------- use `&mut String` here to make mutable\n 25 |         a.push_str(\"foo\");\n-   |         ^\n+   |         ^ cannot borrow as mutable\n \n error: aborting due to 3 previous errors\n "}]}