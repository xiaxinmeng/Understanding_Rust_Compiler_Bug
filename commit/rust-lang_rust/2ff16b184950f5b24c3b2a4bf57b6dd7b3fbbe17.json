{"sha": "2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZjE2YjE4NDk1MGY1YjI0YzNiMmE0YmY1N2I2ZGQ3YjNmYmJlMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-02T16:41:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-02T16:41:27Z"}, "message": "auto merge of #11996 : lecram/rust/master, r=pcwalton\n\nThis Pull Request aims to add backticks to all instances of code inside comments in snippets present in tutorial.md. It also includes backticks for filenames in the same conditions. See #11796 for motivation.", "tree": {"sha": "a905cf8bfa90202fa0b85f1454ab2a906efc3107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a905cf8bfa90202fa0b85f1454ab2a906efc3107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17", "html_url": "https://github.com/rust-lang/rust/commit/2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "html_url": "https://github.com/rust-lang/rust/commit/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b"}, {"sha": "6ad383ef402d4b6f92fe4980fdd6813f24774190", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad383ef402d4b6f92fe4980fdd6813f24774190", "html_url": "https://github.com/rust-lang/rust/commit/6ad383ef402d4b6f92fe4980fdd6813f24774190"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "5122ac35602cebdc4304158d64777f0d462dabad", "filename": "doc/tutorial.md", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2ff16b184950f5b24c3b2a4bf57b6dd7b3fbbe17", "patch": "@@ -326,10 +326,10 @@ Rust will assume that an unsuffixed integer literal has type\n `int`.\n \n ~~~~\n-let a = 1;       // a is an int\n-let b = 10i;     // b is an int, due to the 'i' suffix\n-let c = 100u;    // c is a uint\n-let d = 1000i32; // d is an i32\n+let a = 1;       // `a` is an `int`\n+let b = 10i;     // `b` is an `int`, due to the `i` suffix\n+let c = 100u;    // `c` is a `uint`\n+let d = 1000i32; // `d` is an `i32`\n ~~~~\n \n There are two floating-point types: `f32`, and `f64`.\n@@ -400,10 +400,10 @@ error when the types of the directives don't match the types of the arguments.\n ~~~~\n # let mystery_object = ();\n \n-// {} will print the \"default format\" of a type\n+// `{}` will print the \"default format\" of a type\n println!(\"{} is {}\", \"the answer\", 43);\n \n-// {:?} will conveniently print any type\n+// `{:?}` will conveniently print any type\n println!(\"what is this thing: {:?}\", mystery_object);\n ~~~~\n \n@@ -612,7 +612,7 @@ struct without inherited mutability would result in a type error.\n let mut mypoint = Point { x: 1.0, y: 1.0 };\n let origin = Point { x: 0.0, y: 0.0 };\n \n-mypoint.y += 1.0; // mypoint is mutable, and its fields as well\n+mypoint.y += 1.0; // `mypoint` is mutable, and its fields as well\n origin.y += 1.0; // ERROR: assigning to immutable field\n ~~~~\n \n@@ -1085,8 +1085,8 @@ Avoiding a move can be done with the library-defined `clone` method:\n \n ~~~~\n let x = ~5;\n-let y = x.clone(); // y is a newly allocated box\n-let z = x; // no new memory allocated, x can no longer be used\n+let y = x.clone(); // `y` is a newly allocated box\n+let z = x; // no new memory allocated, `x` can no longer be used\n ~~~~\n \n The `clone` method is provided by the `Clone` trait, and can be derived for\n@@ -1340,7 +1340,7 @@ fn foo() -> (u64, u64, u64, u64, u64, u64) {\n     (5, 5, 5, 5, 5, 5)\n }\n \n-let x = ~foo(); // allocates a ~ box, and writes the integers directly to it\n+let x = ~foo(); // allocates a `~` box, and writes the integers directly to it\n ~~~~\n \n Beyond the properties granted by the size, an owned box behaves as a regular\n@@ -1353,7 +1353,7 @@ y += 2;\n \n let x = ~5; // immutable\n let mut y = ~5; // mutable\n-*y += 2; // the * operator is needed to access the contained value\n+*y += 2; // the `*` operator is needed to access the contained value\n ~~~~\n \n # References\n@@ -1451,9 +1451,9 @@ of a non-`Freeze` type is [`RefCell<T>`][refcell].\n ~~~~\n let mut x = 5;\n {\n-    let y = &x; // x is now frozen, it cannot be modified\n+    let y = &x; // `x` is now frozen, it cannot be modified\n }\n-// x is now unfrozen again\n+// `x` is now unfrozen again\n # x = 3;\n ~~~~\n \n@@ -1559,7 +1559,7 @@ let mut numbers = ~[1, 2, 3];\n numbers.push(4);\n numbers.push(5);\n \n-// The type of a unique vector is written as ~[int]\n+// The type of a unique vector is written as `~[int]`\n let more_numbers: ~[int] = numbers;\n \n // The original `numbers` value can no longer be used, due to move semantics.\n@@ -1576,7 +1576,7 @@ the elements.\n // A slice\n let xs = &[1, 2, 3];\n \n-// Slices have their type written as &[int]\n+// Slices have their type written as `&[int]`\n let ys: &[int] = xs;\n \n // Other vector types coerce to slices\n@@ -1586,7 +1586,7 @@ let zs: &[int] = three;\n // An unadorned string literal is an immutable string slice\n let string = \"foobar\";\n \n-// A string slice type is written as &str\n+// A string slice type is written as `&str`\n let view: &str = string.slice(0, 3);\n ~~~\n \n@@ -1600,7 +1600,7 @@ let mut xs = [1, 2, 3];\n let view = xs.mut_slice(0, 2);\n view[0] = 5;\n \n-// The type of a mutable slice is written as &mut [T]\n+// The type of a mutable slice is written as `&mut [T]`\n let ys: &mut [int] = &mut [1, 2, 3];\n ~~~\n \n@@ -2546,7 +2546,7 @@ that binary is collectively called a 'crate'.\n For example, for a simple hello world program your crate only consists of this code:\n \n ~~~~\n-// main.rs\n+// `main.rs`\n fn main() {\n     println!(\"Hello world!\");\n }\n@@ -2675,8 +2675,8 @@ fn main() {\n     f.farmer.rest();\n \n     // This wouldn't compile because both are private:\n-    // f.feed_chickens();\n-    // let chicken_counter = f.chickens.len();\n+    // `f.feed_chickens();`\n+    // `let chicken_counter = f.chickens.len();`\n }\n # fn make_me_a_farm() -> farm::Farm { farm::make_me_a_farm() }\n # fn make_me_a_chicken() -> farm::Chicken { 0 }\n@@ -2708,8 +2708,8 @@ If it finds both, that's a compile error.\n So, if we want to move the content of `mod farm` into it's own file, it would look like this:\n \n ~~~~ {.ignore}\n-// main.rs - contains body of the crate root\n-mod farm; // Compiler will look for 'farm.rs' and 'farm/mod.rs'\n+// `main.rs` - contains body of the crate root\n+mod farm; // Compiler will look for `farm.rs` and `farm/mod.rs`\n \n fn main() {\n     println!(\"Hello farm!\");\n@@ -2718,7 +2718,7 @@ fn main() {\n ~~~~\n \n ~~~~\n-// farm.rs - contains body of module 'farm' in the crate root\n+// `farm.rs` - contains body of module 'farm' in the crate root\n pub fn chicken() { println!(\"cluck cluck\"); }\n pub fn cow() { println!(\"mooo\"); }\n \n@@ -2743,7 +2743,7 @@ is contained in, if any.\n For example, given a file with this module body:\n \n ~~~ {.ignore}\n-// src/main.rs\n+// `src/main.rs`\n mod plants;\n mod animals {\n     mod fish;\n@@ -2771,13 +2771,13 @@ depending on how and where you've moved a module body to its own file.\n For example, if we move the `animals` module above into its own file...\n \n ~~~ {.ignore}\n-// src/main.rs\n+// `src/main.rs`\n mod plants;\n mod animals;\n ~~~\n \n ~~~ {.ignore}\n-// src/animals.rs or src/animals/mod.rs\n+// `src/animals.rs` or `src/animals/mod.rs`\n mod fish;\n mod mammals {\n     mod humans;\n@@ -2874,7 +2874,7 @@ use farm::cow;\n fn cow() { println!(\"Mooo!\") }\n \n fn main() {\n-    cow() // resolves to the locally defined cow() function\n+    cow() // resolves to the locally defined `cow()` function\n }\n ~~~\n \n@@ -2924,21 +2924,21 @@ fn main() {\n And here an example with multiple files:\n \n ~~~{.ignore}\n-// a.rs - crate root\n+// `a.rs` - crate root\n use b::foo;\n mod b;\n fn main() { foo(); }\n ~~~\n \n ~~~{.ignore}\n-// b.rs\n+// `b.rs`\n use b::c::bar;\n pub mod c;\n pub fn foo() { bar(); }\n ~~~\n \n ~~~\n-// c.rs\n+// `c.rs`\n pub fn bar() { println!(\"Baz!\"); }\n # fn main() {}\n ~~~\n@@ -3101,7 +3101,7 @@ without conflict.\n Therefore, if you plan to compile your crate as a library, you should annotate it with that information:\n \n ~~~~\n-// lib.rs\n+// `lib.rs`\n \n # #[crate_type = \"lib\"];\n // Package ID\n@@ -3125,7 +3125,7 @@ Other crate settings and metadata include things like enabling/disabling certain\n or setting the crate type (library or executable) explicitly:\n \n ~~~~\n-// lib.rs\n+// `lib.rs`\n // ...\n \n // This crate is a library (\"bin\" is the default)\n@@ -3144,15 +3144,15 @@ Now for something that you can actually compile yourself.\n We define two crates, and use one of them as a library in the other.\n \n ~~~~\n-// world.rs\n+// `world.rs`\n #[crate_id = \"world#0.42\"];\n # extern mod extra;\n pub fn explore() -> &'static str { \"world\" }\n # fn main() {}\n ~~~~\n \n ~~~~ {.ignore}\n-// main.rs\n+// `main.rs`\n extern mod world;\n fn main() { println!(\"hello {}\", world::explore()); }\n ~~~~\n@@ -3203,7 +3203,7 @@ For example, it re-exports `range` which is defined in `std::iter::range`:\n use iter_range = std::iter::range;\n \n fn main() {\n-    // range is imported by default\n+    // `range` is imported by default\n     for _ in range(0, 10) {}\n \n     // Doesn't hinder you from importing it under a different name yourself"}]}