{"sha": "ff80cde998fd1068757ef788b1be51e7df4a7192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODBjZGU5OThmZDEwNjg3NTdlZjc4OGIxYmU1MWU3ZGY0YTcxOTI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-14T08:29:49Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-14T16:15:50Z"}, "message": "Rollup merge of #48971 - mark-i-m:fix_readmes, r=nikomatsakis\n\nMove librustc_typeck READMEs to rustc guide\n\ncc https://github.com/rust-lang-nursery/rustc-guide/issues/2 and #48478\n\nDon't merge this before https://github.com/rust-lang-nursery/rustc-guide/pull/85\n\nr? @nikomatsakis", "tree": {"sha": "efaceca456815cd807bff97267446b9eb9758f54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efaceca456815cd807bff97267446b9eb9758f54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff80cde998fd1068757ef788b1be51e7df4a7192", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlqpSrYACgkQ/vbIBR0O\nATz3vw/9FpWdj7BXpWfYqAFqGlqQR/Mk52HdfYnBmmp4W6lQWKyjy0lfrkULCt0u\nLVbmJFYOTKZwAcfidqHdHDAuPbTGF7wyrm8oHVIFWrn+jTB3b/2wYMoh8VHnXhwK\nRkveyZHbQnXk5CHRNoX+VNPWCEOh5T8w/vaJysiEE6lZZT3qZ0L2Owv6Wo+xWzlT\ntR7ChG0I3F/uBg+PxXWbcXcsVDVKLYK/2qFsnTCAOwtDTuvXS5B+fLTawOXVTiPH\n1SkLu/yaecGk+E7eorwom3jqnvAG1A/RJm5dZIX0zyhQFhVi6vjHo3oC/ENMqCgi\n7sEjabdvzM2YHNVKUXCz5giADch1QVrs22EIgyFfTKdLxn/V6IDtXUZfx6OP+Lzl\njBDJoxYWagDtw2p0ixvX4harYdVZQ0C5SQxXnZy1y50llOS/jYcHBoNdRfvLwsRU\n8k/qcT/RgD4cEiJusVENcktY/o4S4luDcMUhnyzRyMPPZSCjVZsOoDHYfCgei2tE\nQcL7ofyyCtMbBpxaOGPi6kaR6muMWmzuceHFwl4CtCL7mKO5GJLmK4VuZR61hM0l\nSnS++ZF8ECXY+kdONuFnbkyLWGzsLswxfWH75VQTJTRGm0dNkX2PBqTcYag2CoNT\nTpNB7yloJF7OxWdxQ9G/iQyWKF2do7Oacy4F9PoOyg4fLFLdZSM=\n=auyi\n-----END PGP SIGNATURE-----", "payload": "tree efaceca456815cd807bff97267446b9eb9758f54\nparent c144fb79cd8f753fc82447d9675b251dfd53ea02\nparent 5a073d496d0a401980233d8ec3e8569abfc2269f\nauthor kennytm <kennytm@gmail.com> 1521016189 +0800\ncommitter kennytm <kennytm@gmail.com> 1521044150 +0800\n\nRollup merge of #48971 - mark-i-m:fix_readmes, r=nikomatsakis\n\nMove librustc_typeck READMEs to rustc guide\n\ncc https://github.com/rust-lang-nursery/rustc-guide/issues/2 and #48478\n\nDon't merge this before https://github.com/rust-lang-nursery/rustc-guide/pull/85\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff80cde998fd1068757ef788b1be51e7df4a7192", "html_url": "https://github.com/rust-lang/rust/commit/ff80cde998fd1068757ef788b1be51e7df4a7192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff80cde998fd1068757ef788b1be51e7df4a7192/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c144fb79cd8f753fc82447d9675b251dfd53ea02", "url": "https://api.github.com/repos/rust-lang/rust/commits/c144fb79cd8f753fc82447d9675b251dfd53ea02", "html_url": "https://github.com/rust-lang/rust/commit/c144fb79cd8f753fc82447d9675b251dfd53ea02"}, {"sha": "5a073d496d0a401980233d8ec3e8569abfc2269f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a073d496d0a401980233d8ec3e8569abfc2269f", "html_url": "https://github.com/rust-lang/rust/commit/5a073d496d0a401980233d8ec3e8569abfc2269f"}], "stats": {"total": 453, "additions": 15, "deletions": 438}, "files": [{"sha": "f00597cb27f0caaf71da6d1c5b265fe912d9561f", "filename": "src/librustc_typeck/README.md", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FREADME.md?ref=ff80cde998fd1068757ef788b1be51e7df4a7192", "patch": "@@ -1,48 +1,5 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n+For high-level intro to how type checking works in rustc, see the\n+[type checking] chapter of the [rustc guide].\n \n-The `rustc_typeck` crate contains the source for \"type collection\" and\n-\"type checking\", as well as a few other bits of related functionality.\n-(It draws heavily on the [type inferencing][infer] and\n-[trait solving][traits] code found in librustc.)\n-\n-[infer]: ../librustc/infer/README.md\n-[traits]: ../librustc/traits/README.md\n-\n-## Type collection\n-\n-Type \"collection\" is the process of converting the types found in the\n-HIR (`hir::Ty`), which represent the syntactic things that the user\n-wrote, into the **internal representation** used by the compiler\n-(`Ty<'tcx>`) -- we also do similar conversions for where-clauses and\n-other bits of the function signature.\n-\n-To try and get a sense for the difference, consider this function:\n-\n-```rust\n-struct Foo { }\n-fn foo(x: Foo, y: self::Foo) { .. }\n-//        ^^^     ^^^^^^^^^\n-```\n-\n-Those two parameters `x` and `y` each have the same type: but they\n-will have distinct `hir::Ty` nodes. Those nodes will have different\n-spans, and of course they encode the path somewhat differently. But\n-once they are \"collected\" into `Ty<'tcx>` nodes, they will be\n-represented by the exact same internal type.\n-\n-Collection is defined as a bundle of queries (e.g., `type_of`) for\n-computing information about the various functions, traits, and other\n-items in the crate being compiled. Note that each of these queries is\n-concerned with *interprocedural* things -- for example, for a function\n-definition, collection will figure out the type and signature of the\n-function, but it will not visit the *body* of the function in any way,\n-nor examine type annotations on local variables (that's the job of\n-type *checking*).\n-\n-For more details, see the `collect` module.\n-\n-## Type checking\n-\n-TODO\n+[type checking]: https://rust-lang-nursery.github.io/rustc-guide/type-checking.html\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/"}, {"sha": "b5d317d602538f2cf83cfed10e18680e35c417c1", "filename": "src/librustc_typeck/check/method/README.md", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c144fb79cd8f753fc82447d9675b251dfd53ea02/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c144fb79cd8f753fc82447d9675b251dfd53ea02/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md?ref=c144fb79cd8f753fc82447d9675b251dfd53ea02", "patch": "@@ -1,111 +0,0 @@\n-# Method lookup\n-\n-Method lookup can be rather complex due to the interaction of a number\n-of factors, such as self types, autoderef, trait lookup, etc. This\n-file provides an overview of the process. More detailed notes are in\n-the code itself, naturally.\n-\n-One way to think of method lookup is that we convert an expression of\n-the form:\n-\n-    receiver.method(...)\n-\n-into a more explicit UFCS form:\n-\n-    Trait::method(ADJ(receiver), ...) // for a trait call\n-    ReceiverType::method(ADJ(receiver), ...) // for an inherent method call\n-\n-Here `ADJ` is some kind of adjustment, which is typically a series of\n-autoderefs and then possibly an autoref (e.g., `&**receiver`). However\n-we sometimes do other adjustments and coercions along the way, in\n-particular unsizing (e.g., converting from `[T; n]` to `[T]`).\n-\n-## The Two Phases\n-\n-Method lookup is divided into two major phases: probing (`probe.rs`)\n-and confirmation (`confirm.rs`). The probe phase is when we decide\n-what method to call and how to adjust the receiver. The confirmation\n-phase \"applies\" this selection, updating the side-tables, unifying\n-type variables, and otherwise doing side-effectful things.\n-\n-One reason for this division is to be more amenable to caching.  The\n-probe phase produces a \"pick\" (`probe::Pick`), which is designed to be\n-cacheable across method-call sites. Therefore, it does not include\n-inference variables or other information.\n-\n-## Probe phase\n-\n-The probe phase (`probe.rs`) decides what method is being called and\n-how to adjust the receiver.\n-\n-### Steps\n-\n-The first thing that the probe phase does is to create a series of\n-*steps*. This is done by progressively dereferencing the receiver type\n-until it cannot be deref'd anymore, as well as applying an optional\n-\"unsize\" step. So if the receiver has type `Rc<Box<[T; 3]>>`, this\n-might yield:\n-\n-    Rc<Box<[T; 3]>>\n-    Box<[T; 3]>\n-    [T; 3]\n-    [T]\n-\n-### Candidate assembly\n-\n-We then search along those steps to create a list of *candidates*. A\n-`Candidate` is a method item that might plausibly be the method being\n-invoked. For each candidate, we'll derive a \"transformed self type\"\n-that takes into account explicit self.\n-\n-Candidates are grouped into two kinds, inherent and extension.\n-\n-**Inherent candidates** are those that are derived from the\n-type of the receiver itself.  So, if you have a receiver of some\n-nominal type `Foo` (e.g., a struct), any methods defined within an\n-impl like `impl Foo` are inherent methods.  Nothing needs to be\n-imported to use an inherent method, they are associated with the type\n-itself (note that inherent impls can only be defined in the same\n-module as the type itself).\n-\n-FIXME: Inherent candidates are not always derived from impls.  If you\n-have a trait object, such as a value of type `Box<ToString>`, then the\n-trait methods (`to_string()`, in this case) are inherently associated\n-with it. Another case is type parameters, in which case the methods of\n-their bounds are inherent. However, this part of the rules is subject\n-to change: when DST's \"impl Trait for Trait\" is complete, trait object\n-dispatch could be subsumed into trait matching, and the type parameter\n-behavior should be reconsidered in light of where clauses.\n-\n-**Extension candidates** are derived from imported traits.  If I have\n-the trait `ToString` imported, and I call `to_string()` on a value of\n-type `T`, then we will go off to find out whether there is an impl of\n-`ToString` for `T`.  These kinds of method calls are called \"extension\n-methods\".  They can be defined in any module, not only the one that\n-defined `T`.  Furthermore, you must import the trait to call such a\n-method.\n-\n-So, let's continue our example. Imagine that we were calling a method\n-`foo` with the receiver `Rc<Box<[T; 3]>>` and there is a trait `Foo`\n-that defines it with `&self` for the type `Rc<U>` as well as a method\n-on the type `Box` that defines `Foo` but with `&mut self`. Then we\n-might have two candidates:\n-\n-    &Rc<Box<[T; 3]>> from the impl of `Foo` for `Rc<U>` where `U=Box<T; 3]>\n-    &mut Box<[T; 3]>> from the inherent impl on `Box<U>` where `U=[T; 3]`\n-\n-### Candidate search\n-\n-Finally, to actually pick the method, we will search down the steps,\n-trying to match the receiver type against the candidate types. At\n-each step, we also consider an auto-ref and auto-mut-ref to see whether\n-that makes any of the candidates match. We pick the first step where\n-we find a match.\n-\n-In the case of our example, the first step is `Rc<Box<[T; 3]>>`,\n-which does not itself match any candidate. But when we autoref it, we\n-get the type `&Rc<Box<[T; 3]>>` which does match. We would then\n-recursively consider all where-clauses that appear on the impl: if\n-those match (or we cannot rule out that they do), then this is the\n-method we would pick. Otherwise, we would continue down the series of\n-steps."}, {"sha": "1664f46464d15ad2bd3673a19810d3d15b62baef", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ff80cde998fd1068757ef788b1be51e7df4a7192", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Method lookup: the secret sauce of Rust. See `README.md`.\n+//! Method lookup: the secret sauce of Rust. See the [rustc guide] chapter.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/method-lookup.html\n \n use check::FnCtxt;\n use hir::def::Def;"}, {"sha": "64d3389b34af7ed83b9e115414aba552689276d1", "filename": "src/librustc_typeck/variance/README.md", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/c144fb79cd8f753fc82447d9675b251dfd53ea02/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c144fb79cd8f753fc82447d9675b251dfd53ea02/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=c144fb79cd8f753fc82447d9675b251dfd53ea02", "patch": "@@ -1,276 +0,0 @@\n-## Variance of type and lifetime parameters\n-\n-This file infers the variance of type and lifetime parameters. The\n-algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n-Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n-written by Altidor et al., and hereafter referred to as The Paper.\n-\n-This inference is explicitly designed *not* to consider the uses of\n-types within code. To determine the variance of type parameters\n-defined on type `X`, we only consider the definition of the type `X`\n-and the definitions of any types it references.\n-\n-We only infer variance for type parameters found on *data types*\n-like structs and enums. In these cases, there is fairly straightforward\n-explanation for what variance means. The variance of the type\n-or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n-(resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n-(resp. `'a` and `'b`).\n-\n-We do not infer variance for type parameters found on traits, fns,\n-or impls. Variance on trait parameters can make indeed make sense\n-(and we used to compute it) but it is actually rather subtle in\n-meaning and not that useful in practice, so we removed it. See the\n-addendum for some details. Variances on fn/impl parameters, otoh,\n-doesn't make sense because these parameters are instantiated and\n-then forgotten, they don't persist in types or compiled\n-byproducts.\n-\n-### The algorithm\n-\n-The basic idea is quite straightforward. We iterate over the types\n-defined and, for each use of a type parameter X, accumulate a\n-constraint indicating that the variance of X must be valid for the\n-variance of that use site. We then iteratively refine the variance of\n-X until all constraints are met. There is *always* a sol'n, because at\n-the limit we can declare all type parameters to be invariant and all\n-constraints will be satisfied.\n-\n-As a simple example, consider:\n-\n-    enum Option<A> { Some(A), None }\n-    enum OptionalFn<B> { Some(|B|), None }\n-    enum OptionalMap<C> { Some(|C| -> C), None }\n-\n-Here, we will generate the constraints:\n-\n-    1. V(A) <= +\n-    2. V(B) <= -\n-    3. V(C) <= +\n-    4. V(C) <= -\n-\n-These indicate that (1) the variance of A must be at most covariant;\n-(2) the variance of B must be at most contravariant; and (3, 4) the\n-variance of C must be at most covariant *and* contravariant. All of these\n-results are based on a variance lattice defined as follows:\n-\n-       *      Top (bivariant)\n-    -     +\n-       o      Bottom (invariant)\n-\n-Based on this lattice, the solution `V(A)=+`, `V(B)=-`, `V(C)=o` is the\n-optimal solution. Note that there is always a naive solution which\n-just declares all variables to be invariant.\n-\n-You may be wondering why fixed-point iteration is required. The reason\n-is that the variance of a use site may itself be a function of the\n-variance of other type parameters. In full generality, our constraints\n-take the form:\n-\n-    V(X) <= Term\n-    Term := + | - | * | o | V(X) | Term x Term\n-\n-Here the notation `V(X)` indicates the variance of a type/region\n-parameter `X` with respect to its defining class. `Term x Term`\n-represents the \"variance transform\" as defined in the paper:\n-\n->  If the variance of a type variable `X` in type expression `E` is `V2`\n-  and the definition-site variance of the [corresponding] type parameter\n-  of a class `C` is `V1`, then the variance of `X` in the type expression\n-  `C<E>` is `V3 = V1.xform(V2)`.\n-\n-### Constraints\n-\n-If I have a struct or enum with where clauses:\n-\n-    struct Foo<T:Bar> { ... }\n-\n-you might wonder whether the variance of `T` with respect to `Bar`\n-affects the variance `T` with respect to `Foo`. I claim no.  The\n-reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n-`Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n-`X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n-case, the upcast will be illegal, but not because of a variance\n-failure, but rather because the target type `Foo<Y>` is itself just\n-not well-formed. Basically we get to assume well-formedness of all\n-types involved before considering variance.\n-\n-#### Dependency graph management\n-\n-Because variance is a whole-crate inference, its dependency graph\n-can become quite muddled if we are not careful. To resolve this, we refactor\n-into two queries:\n-\n-- `crate_variances` computes the variance for all items in the current crate.\n-- `variances_of` accesses the variance for an individual reading; it\n-  works by requesting `crate_variances` and extracting the relevant data.\n-\n-If you limit yourself to reading `variances_of`, your code will only\n-depend then on the inference inferred for that particular item.\n-\n-Ultimately, this setup relies on the red-green algorithm.\n-In particular, every variance query ultimately depends on -- effectively --\n-all type definitions in the entire crate (through `crate_variances`),\n-but since most changes will not result in a change\n-to the actual results from variance inference,\n-the `variances_of` query will wind up being considered green after it is re-evaluated.\n-\n-### Addendum: Variance on traits\n-\n-As mentioned above, we used to permit variance on traits. This was\n-computed based on the appearance of trait type parameters in\n-method signatures and was used to represent the compatibility of\n-vtables in trait objects (and also \"virtual\" vtables or dictionary\n-in trait bounds). One complication was that variance for\n-associated types is less obvious, since they can be projected out\n-and put to myriad uses, so it's not clear when it is safe to allow\n-`X<A>::Bar` to vary (or indeed just what that means). Moreover (as\n-covered below) all inputs on any trait with an associated type had\n-to be invariant, limiting the applicability. Finally, the\n-annotations (`MarkerTrait`, `PhantomFn`) needed to ensure that all\n-trait type parameters had a variance were confusing and annoying\n-for little benefit.\n-\n-Just for historical reference,I am going to preserve some text indicating\n-how one could interpret variance and trait matching.\n-\n-#### Variance and object types\n-\n-Just as with structs and enums, we can decide the subtyping\n-relationship between two object types `&Trait<A>` and `&Trait<B>`\n-based on the relationship of `A` and `B`. Note that for object\n-types we ignore the `Self` type parameter -- it is unknown, and\n-the nature of dynamic dispatch ensures that we will always call a\n-function that is expected the appropriate `Self` type. However, we\n-must be careful with the other type parameters, or else we could\n-end up calling a function that is expecting one type but provided\n-another.\n-\n-To see what I mean, consider a trait like so:\n-\n-    trait ConvertTo<A> {\n-        fn convertTo(&self) -> A;\n-    }\n-\n-Intuitively, If we had one object `O=&ConvertTo<Object>` and another\n-`S=&ConvertTo<String>`, then `S <: O` because `String <: Object`\n-(presuming Java-like \"string\" and \"object\" types, my go to examples\n-for subtyping). The actual algorithm would be to compare the\n-(explicit) type parameters pairwise respecting their variance: here,\n-the type parameter A is covariant (it appears only in a return\n-position), and hence we require that `String <: Object`.\n-\n-You'll note though that we did not consider the binding for the\n-(implicit) `Self` type parameter: in fact, it is unknown, so that's\n-good. The reason we can ignore that parameter is precisely because we\n-don't need to know its value until a call occurs, and at that time (as\n-you said) the dynamic nature of virtual dispatch means the code we run\n-will be correct for whatever value `Self` happens to be bound to for\n-the particular object whose method we called. `Self` is thus different\n-from `A`, because the caller requires that `A` be known in order to\n-know the return type of the method `convertTo()`. (As an aside, we\n-have rules preventing methods where `Self` appears outside of the\n-receiver position from being called via an object.)\n-\n-#### Trait variance and vtable resolution\n-\n-But traits aren't only used with objects. They're also used when\n-deciding whether a given impl satisfies a given trait bound. To set the\n-scene here, imagine I had a function:\n-\n-    fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n-        ...\n-    }\n-\n-Now imagine that I have an implementation of `ConvertTo` for `Object`:\n-\n-    impl ConvertTo<i32> for Object { ... }\n-\n-And I want to call `convertAll` on an array of strings. Suppose\n-further that for whatever reason I specifically supply the value of\n-`String` for the type parameter `T`:\n-\n-    let mut vector = vec![\"string\", ...];\n-    convertAll::<i32, String>(vector);\n-\n-Is this legal? To put another way, can we apply the `impl` for\n-`Object` to the type `String`? The answer is yes, but to see why\n-we have to expand out what will happen:\n-\n-- `convertAll` will create a pointer to one of the entries in the\n-  vector, which will have type `&String`\n-- It will then call the impl of `convertTo()` that is intended\n-  for use with objects. This has the type:\n-\n-      fn(self: &Object) -> i32\n-\n-  It is ok to provide a value for `self` of type `&String` because\n-  `&String <: &Object`.\n-\n-OK, so intuitively we want this to be legal, so let's bring this back\n-to variance and see whether we are computing the correct result. We\n-must first figure out how to phrase the question \"is an impl for\n-`Object,i32` usable where an impl for `String,i32` is expected?\"\n-\n-Maybe it's helpful to think of a dictionary-passing implementation of\n-type classes. In that case, `convertAll()` takes an implicit parameter\n-representing the impl. In short, we *have* an impl of type:\n-\n-    V_O = ConvertTo<i32> for Object\n-\n-and the function prototype expects an impl of type:\n-\n-    V_S = ConvertTo<i32> for String\n-\n-As with any argument, this is legal if the type of the value given\n-(`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n-The answer will depend on the variance of the various parameters. In\n-this case, because the `Self` parameter is contravariant and `A` is\n-covariant, it means that:\n-\n-    V_O <: V_S iff\n-        i32 <: i32\n-        String <: Object\n-\n-These conditions are satisfied and so we are happy.\n-\n-#### Variance and associated types\n-\n-Traits with associated types -- or at minimum projection\n-expressions -- must be invariant with respect to all of their\n-inputs. To see why this makes sense, consider what subtyping for a\n-trait reference means:\n-\n-    <T as Trait> <: <U as Trait>\n-\n-means that if I know that `T as Trait`, I also know that `U as\n-Trait`. Moreover, if you think of it as dictionary passing style,\n-it means that a dictionary for `<T as Trait>` is safe to use where\n-a dictionary for `<U as Trait>` is expected.\n-\n-The problem is that when you can project types out from `<T as\n-Trait>`, the relationship to types projected out of `<U as Trait>`\n-is completely unknown unless `T==U` (see #21726 for more\n-details). Making `Trait` invariant ensures that this is true.\n-\n-Another related reason is that if we didn't make traits with\n-associated types invariant, then projection is no longer a\n-function with a single result. Consider:\n-\n-```\n-trait Identity { type Out; fn foo(&self); }\n-impl<T> Identity for T { type Out = T; ... }\n-```\n-\n-Now if I have `<&'static () as Identity>::Out`, this can be\n-validly derived as `&'a ()` for any `'a`:\n-\n-    <&'a () as Identity> <: <&'static () as Identity>\n-    if &'static () < : &'a ()   -- Identity is contravariant in Self\n-    if 'static : 'a             -- Subtyping rules for relations\n-\n-This change otoh means that `<'static () as Identity>::Out` is\n-always `&'static ()` (which might then be upcast to `'a ()`,\n-separately). This was helpful in solving #21750.\n-\n-"}, {"sha": "fd2b964103a3026a3c957b8f05f58b2e52ca6a58", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=ff80cde998fd1068757ef788b1be51e7df4a7192", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Module for inferring the variance of type and lifetime\n-//! parameters. See README.md for details.\n+//! Module for inferring the variance of type and lifetime parameters. See the [rustc guide]\n+//! chapter for more info.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/variance.html\n \n use arena;\n use rustc::hir;"}, {"sha": "b9ab00130b3c3c984f671d98958dd163575b69dd", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff80cde998fd1068757ef788b1be51e7df4a7192/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=ff80cde998fd1068757ef788b1be51e7df4a7192", "patch": "@@ -87,7 +87,10 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n         lang_items: lang_items(tcx),\n     };\n \n-    // See README.md for a discussion on dep-graph management.\n+    // See the following for a discussion on dep-graph management.\n+    //\n+    // - https://rust-lang-nursery.github.io/rustc-guide/query.html\n+    // - https://rust-lang-nursery.github.io/rustc-guide/variance.html\n     tcx.hir.krate().visit_all_item_likes(&mut terms_cx);\n \n     terms_cx"}]}