{"sha": "a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOGYzYTdkNGQ5MzdjMmIyNmM4YTI5ZWRhYmU3ZmIwODlkMGI1Zjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-23T21:46:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-24T01:54:08Z"}, "message": "More complete fix to #3162 (borrowck bug related to access to rec fields)", "tree": {"sha": "778e2d94eca68fd3e579b2ad8ac2725602afe340", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/778e2d94eca68fd3e579b2ad8ac2725602afe340"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "html_url": "https://github.com/rust-lang/rust/commit/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83e7c869bdfadf0ed8aca92e76fc5073b63402e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/83e7c869bdfadf0ed8aca92e76fc5073b63402e2", "html_url": "https://github.com/rust-lang/rust/commit/83e7c869bdfadf0ed8aca92e76fc5073b63402e2"}], "stats": {"total": 90, "additions": 51, "deletions": 39}, "files": [{"sha": "863efc79d4a30543958b297a2f5cdd04de0c4601", "filename": "src/libcore/task.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -851,12 +851,10 @@ fn each_ancestor(list:        &mut AncestorList,\n                     do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n                         // Decide whether this group is dead. Note that the\n                         // group being *dead* is disjoint from it *failing*.\n-                        match *tg_opt {\n-                            some(ref tg) => {\n-                                nobe_is_dead = taskgroup_is_dead(tg);\n-                            },\n-                            none => { }\n-                        }\n+                        nobe_is_dead = match *tg_opt {\n+                            some(ref tg) => taskgroup_is_dead(tg),\n+                            none => nobe_is_dead\n+                        };\n                         // Call iterator block. (If the group is dead, it's\n                         // safe to skip it. This will leave our *rust_task\n                         // hanging around in the group even after it's freed,"}, {"sha": "c6be27c4b77a02716241eb2f568d54d20ebf5f91", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -75,6 +75,7 @@ export swap;\n export reverse;\n export reversed;\n export iter, iter_between, each, eachi, reach, reachi;\n+export each_mut, each_const;\n export iter2;\n export iteri;\n export riter;\n@@ -1174,6 +1175,24 @@ pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n     }\n }\n \n+/// Like `each()`, but for the case where you have\n+/// a vector with mutable contents and you would like\n+/// to mutate the contents as you iterate.\n+#[inline(always)]\n+pure fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+    do vec::as_mut_buf(v) |p, n| {\n+        let mut n = n;\n+        let mut p = p;\n+        while n > 0u {\n+            unsafe {\n+                if !f(&mut *p) { break; }\n+                p = ptr::mut_offset(p, 1u);\n+            }\n+            n -= 1u;\n+        }\n+    }\n+}\n+\n /**\n  * Iterates over a vector's elements and indices\n  *"}, {"sha": "22219c77f6cc1c46c6626043cec2f87fb5c59523", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -158,7 +158,8 @@ fn sha1() -> sha1 {\n     fn mk_result(st: sha1state) -> ~[u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n         let mut rs: ~[u8] = ~[];\n-        for vec::each(st.h) |hpart| {\n+        for vec::each_mut(st.h) |ptr_hpart| {\n+            let hpart = *ptr_hpart;\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n             let c = (hpart >> 8u32 & 0xFFu32) as u8;"}, {"sha": "586a428c1d70a235c13431f98e00726d6b427787", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -205,10 +205,10 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n \n \n /* helper: descend into a matcher */\n-fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n+pure fn follow(m: arb_depth<matchable>, idx_path: &[uint]) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n-    for vec::each(*idx_path) |idx| {\n+    for vec::each(idx_path) |idx| {\n         res = match res {\n           leaf(_) => return res,/* end of the line */\n           seq(new_ms, _) => new_ms[idx]\n@@ -222,7 +222,7 @@ fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n     match mmaybe {\n       none => return none,\n       some(m) => {\n-        return match follow(m, idx_path) {\n+        return match follow(m, *idx_path) {\n               seq(_, sp) => {\n                 cx.span_fatal(sp,\n                               ~\"syntax matched under ... but not \" +\n@@ -274,7 +274,8 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             do free_vars(b, repeat_me) |fv| {\n-                let cur_pos = follow(b.get(fv), idx_path);\n+                let fv_depth = b.get(fv);\n+                let cur_pos = follow(fv_depth, *idx_path);\n                 match cur_pos {\n                   leaf(_) => (),\n                   seq(ms, _) => {"}, {"sha": "e68a81209927db0eb03fcb89c6075a3faf72f9b7", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -146,19 +146,12 @@ impl parser: parser_common {\n \n     fn eat_keyword(word: ~str) -> bool {\n         self.require_keyword(word);\n-\n-        let mut bump = false;\n-        let val = match self.token {\n-          token::IDENT(sid, false) => {\n-            if word == *self.id_to_str(sid) {\n-                bump = true;\n-                true\n-            } else { false }\n-          }\n+        let is_kw = match self.token {\n+          token::IDENT(sid, false) => (word == *self.id_to_str(sid)),\n           _ => false\n         };\n-        if bump { self.bump() }\n-        val\n+        if is_kw { self.bump() }\n+        is_kw\n     }\n \n     fn expect_keyword(word: ~str) {"}, {"sha": "6db7297618b58856adf504c21b5869ea03391430", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -326,19 +326,8 @@ impl check_loan_ctxt {\n             // even to data owned by the current stack frame.  This is\n             // because that aliasable data might have been located on\n             // the current stack frame, we don't know.\n-            match cmt.lp {\n-              some(@lp_local(*)) | some(@lp_arg(*)) => {\n-                // it's ok to mutate a local variable, as it is either\n-                // lent our or not.  The problem arises when you have\n-                // some subcomponent that might have been lent out\n-                // through an alias on the condition that you ensure\n-                // purity.\n-              }\n-              none | some(@lp_comp(*)) | some(@lp_deref(*)) => {\n-                self.report_purity_error(\n-                    pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n-              }\n-            }\n+            self.report_purity_error(\n+                pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n           }\n           some(pc_pure_fn) => {\n             if cmt.lp.is_none() {"}, {"sha": "da6b0b5087bbef3c33d024ff93ee0872c92cc5d1", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -2065,7 +2065,7 @@ struct Resolver {\n                                                            str_of(name)));\n                             return Failed;\n                         }\n-                        ModuleDef(module_) => {\n+                        ModuleDef(copy module_) => {\n                             search_module = module_;\n                         }\n                     }"}, {"sha": "ce84269bb67acbb41fadb0b934127eeca585f927", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -116,10 +116,13 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n }\n \n fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n-    let mut done = true;\n     // Optimization -- don't descend type if all params already have this use\n-    for vec::each(cx.uses) |u| { if u & use != use { done = false } }\n-    if !done { type_needs_inner(cx, use, ty, @nil); }\n+    for vec::each_mut(cx.uses) |u| {\n+        if *u & use != use {\n+            type_needs_inner(cx, use, ty, @nil);\n+            return;\n+        }\n+    }\n }\n \n fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,"}, {"sha": "7ac3cfca07e922d4a8e871465a7728b97a376897", "filename": "src/test/compile-fail/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=a08f3a7d4d937c2b26c8a29edabe7fb089d0b5f7", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let mut _a = 3;\n+    let _b = &mut _a;\n+    {\n+        let _c = &*_b; //~ ERROR illegal borrow unless pure\n+        _a = 4; //~ NOTE impure due to assigning to mutable local variable\n+    }\n+}"}]}