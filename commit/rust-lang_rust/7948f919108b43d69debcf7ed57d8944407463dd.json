{"sha": "7948f919108b43d69debcf7ed57d8944407463dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NDhmOTE5MTA4YjQzZDY5ZGViY2Y3ZWQ1N2Q4OTQ0NDA3NDYzZGQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-19T00:37:36Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Run the annoying lint separately", "tree": {"sha": "d92a3b711e0e787a7574a8a0af53ea614453e838", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d92a3b711e0e787a7574a8a0af53ea614453e838"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7948f919108b43d69debcf7ed57d8944407463dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7948f919108b43d69debcf7ed57d8944407463dd", "html_url": "https://github.com/rust-lang/rust/commit/7948f919108b43d69debcf7ed57d8944407463dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7948f919108b43d69debcf7ed57d8944407463dd/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "html_url": "https://github.com/rust-lang/rust/commit/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d"}], "stats": {"total": 97, "additions": 43, "deletions": 54}, "files": [{"sha": "f4dd7d2dcd64fea74e0103e2ddfd33a372c3340b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7948f919108b43d69debcf7ed57d8944407463dd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7948f919108b43d69debcf7ed57d8944407463dd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=7948f919108b43d69debcf7ed57d8944407463dd", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::lint;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n@@ -184,51 +184,42 @@ impl IntRange {\n     }\n \n     /// Split this range, as described at the top of the file.\n-    fn split<'p, 'tcx>(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        hir_id: Option<HirId>,\n-    ) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        // We collect the span and range of all the intersecting ranges to lint on likely incorrect\n-        // range patterns. (#63987)\n-        let mut overlaps = vec![];\n+    fn split<'p, 'tcx>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n         let mut split_range = SplitIntRange::new(self.clone());\n-        let row_len = pcx.matrix.column_count().unwrap_or(0);\n-        let intranges = pcx\n-            .matrix\n-            .head_ctors_and_spans(pcx.cx)\n-            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)));\n-        let intranges = intranges.inspect(|(range, span)| {\n-            if let Some(intersection) = self.intersection(&range) {\n-                if row_len == 1 && self.suspicious_intersection(&range) {\n-                    // FIXME: for now, only check for overlapping ranges on simple range\n-                    // patterns. Otherwise with the current logic the following is detected\n-                    // as overlapping:\n-                    // ```\n-                    // match (0u8, true) {\n-                    //   (0 ..= 125, false) => {}\n-                    //   (125 ..= 255, true) => {}\n-                    //   _ => {}\n-                    // }\n-                    // ```\n-                    overlaps.push((intersection.clone(), *span));\n-                }\n-            }\n-        });\n-        split_range.split(intranges.map(|(range, _)| range).cloned());\n-\n-        self.lint_overlapping_range_endpoints(pcx, hir_id, overlaps);\n-\n+        let intranges = pcx.matrix.head_ctors(pcx.cx).filter_map(|ctor| ctor.as_int_range());\n+        split_range.split(intranges.cloned());\n         split_range.iter().map(IntRange).collect()\n     }\n \n-    fn lint_overlapping_range_endpoints(\n-        &self,\n-        pcx: PatCtxt<'_, '_, '_>,\n-        hir_id: Option<HirId>,\n-        overlaps: Vec<(IntRange, Span)>,\n-    ) {\n-        if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n+    /// Lint on likely incorrect range patterns (#63987)\n+    pub(super) fn lint_overlapping_range_endpoints(&self, pcx: PatCtxt<'_, '_, '_>, hir_id: HirId) {\n+        if self.is_singleton() {\n+            return;\n+        }\n+\n+        if pcx.matrix.column_count().unwrap_or(0) != 1 {\n+            // FIXME: for now, only check for overlapping ranges on simple range\n+            // patterns. Otherwise with the current logic the following is detected\n+            // as overlapping:\n+            // ```\n+            // match (0u8, true) {\n+            //   (0 ..= 125, false) => {}\n+            //   (125 ..= 255, true) => {}\n+            //   _ => {}\n+            // }\n+            // ```\n+            return;\n+        }\n+\n+        let overlaps: Vec<_> = pcx\n+            .matrix\n+            .head_ctors_and_spans(pcx.cx)\n+            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n+            .filter(|(range, _)| self.suspicious_intersection(range))\n+            .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n+            .collect();\n+\n+        if !overlaps.is_empty() {\n             pcx.cx.tcx.struct_span_lint_hir(\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n                 hir_id,\n@@ -673,21 +664,14 @@ impl<'tcx> Constructor<'tcx> {\n     /// This function may discard some irrelevant constructors if this preserves behavior and\n     /// diagnostics. Eg. for the `_` case, we ignore the constructors already present in the\n     /// matrix, unless all of them are.\n-    ///\n-    /// `hir_id` is `None` when we're evaluating the wildcard pattern. In that case we do not want\n-    /// to lint for overlapping ranges.\n-    pub(super) fn split<'p>(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        hir_id: Option<HirId>,\n-    ) -> SmallVec<[Self; 1]> {\n+    pub(super) fn split<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n         debug!(\"Constructor::split({:#?}, {:#?})\", self, pcx.matrix);\n \n         match self {\n             Wildcard => Constructor::split_wildcard(pcx),\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n-            IntRange(ctor_range) if !ctor_range.is_singleton() => ctor_range.split(pcx, hir_id),\n+            IntRange(ctor_range) if !ctor_range.is_singleton() => ctor_range.split(pcx),\n             Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(pcx),\n             // Any other constructor can be used unchanged.\n             _ => smallvec![self.clone()],\n@@ -937,7 +921,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n             pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n         // Since `all_ctors` never contains wildcards, this won't recurse further.\n         let all_ctors =\n-            all_constructors(pcx).into_iter().flat_map(|ctor| ctor.split(pcx, None)).collect();\n+            all_constructors(pcx).into_iter().flat_map(|ctor| ctor.split(pcx)).collect();\n \n         MissingConstructors { all_ctors, used_ctors }\n     }"}, {"sha": "877d48a85b76b22c88e3b3c6d3a0ef7204aba65a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7948f919108b43d69debcf7ed57d8944407463dd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7948f919108b43d69debcf7ed57d8944407463dd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=7948f919108b43d69debcf7ed57d8944407463dd", "patch": "@@ -991,11 +991,16 @@ fn is_useful<'p, 'tcx>(\n         });\n         Usefulness::merge(usefulnesses)\n     } else {\n+        let v_ctor = v.head_ctor(cx);\n+        if let Constructor::IntRange(ctor_range) = &v_ctor {\n+            // Lint on likely incorrect range patterns (#63987)\n+            ctor_range.lint_overlapping_range_endpoints(pcx, hir_id)\n+        }\n         // We split the head constructor of `v`.\n-        let ctors = v.head_ctor(cx).split(pcx, Some(hir_id));\n+        let split_ctors = v_ctor.split(pcx);\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n-        let usefulnesses = ctors.into_iter().map(|ctor| {\n+        let usefulnesses = split_ctors.into_iter().map(|ctor| {\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n             let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);"}]}