{"sha": "7c3c5889888809dafe3906b472e07a9cdf399f03", "node_id": "C_kwDOAAsO6NoAKDdjM2M1ODg5ODg4ODA5ZGFmZTM5MDZiNDcyZTA3YTljZGYzOTlmMDM", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-28T17:03:17Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-06T16:11:04Z"}, "message": "remove ItemLikeVisitor impl for InherentOverlapChecker\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "4f7f7522889943e243d46ca3791e8d7a7c8dc03f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7f7522889943e243d46ca3791e8d7a7c8dc03f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c3c5889888809dafe3906b472e07a9cdf399f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3c5889888809dafe3906b472e07a9cdf399f03", "html_url": "https://github.com/rust-lang/rust/commit/7c3c5889888809dafe3906b472e07a9cdf399f03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c3c5889888809dafe3906b472e07a9cdf399f03/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e", "html_url": "https://github.com/rust-lang/rust/commit/63849b6ecf03e2df98f65bd0e6e89a7d12986f9e"}], "stats": {"total": 339, "additions": 163, "deletions": 176}, "files": [{"sha": "6ddaecb91b213430f8689cb455182b5977eff7e4", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 163, "deletions": 176, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/7c3c5889888809dafe3906b472e07a9cdf399f03/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3c5889888809dafe3906b472e07a9cdf399f03/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=7c3c5889888809dafe3906b472e07a9cdf399f03", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_index::vec::IndexVec;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -12,7 +12,10 @@ use smallvec::SmallVec;\n use std::collections::hash_map::Entry;\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, (): ()) {\n-    tcx.hir().visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n+    let mut inherent_overlap_checker = InherentOverlapChecker { tcx };\n+    for id in tcx.hir().items() {\n+        inherent_overlap_checker.check_item(id);\n+    }\n }\n \n struct InherentOverlapChecker<'tcx> {\n@@ -121,200 +124,184 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n             || true,\n         );\n     }\n-}\n \n-impl<'tcx> ItemLikeVisitor<'_> for InherentOverlapChecker<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        match item.kind {\n-            hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::Union(..) => {\n-                let impls = self.tcx.inherent_impls(item.def_id);\n+    fn check_item(&mut self, id: hir::ItemId) {\n+        let def_kind = self.tcx.hir().def_kind(id.def_id);\n+        if !matches!(def_kind, DefKind::Enum | DefKind::Struct | DefKind::Trait | DefKind::Union) {\n+            return;\n+        }\n \n-                // If there is only one inherent impl block,\n-                // there is nothing to overlap check it with\n-                if impls.len() <= 1 {\n-                    return;\n-                }\n+        let impls = self.tcx.inherent_impls(id.def_id);\n \n-                let overlap_mode = OverlapMode::get(self.tcx, item.def_id.to_def_id());\n+        // If there is only one inherent impl block,\n+        // there is nothing to overlap check it with\n+        if impls.len() <= 1 {\n+            return;\n+        }\n \n-                let impls_items = impls\n-                    .iter()\n-                    .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n-                    .collect::<SmallVec<[_; 8]>>();\n+        let overlap_mode = OverlapMode::get(self.tcx, id.def_id.to_def_id());\n \n-                // Perform a O(n^2) algorithm for small n,\n-                // otherwise switch to an allocating algorithm with\n-                // faster asymptotic runtime.\n-                const ALLOCATING_ALGO_THRESHOLD: usize = 500;\n-                if impls.len() < ALLOCATING_ALGO_THRESHOLD {\n-                    for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n-                        for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n-                            if self.impls_have_common_items(impl_items1, impl_items2) {\n-                                self.check_for_overlapping_inherent_impls(\n-                                    overlap_mode,\n-                                    impl1_def_id,\n-                                    impl2_def_id,\n-                                );\n-                            }\n-                        }\n+        let impls_items = impls\n+            .iter()\n+            .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n+            .collect::<SmallVec<[_; 8]>>();\n+\n+        // Perform a O(n^2) algorithm for small n,\n+        // otherwise switch to an allocating algorithm with\n+        // faster asymptotic runtime.\n+        const ALLOCATING_ALGO_THRESHOLD: usize = 500;\n+        if impls.len() < ALLOCATING_ALGO_THRESHOLD {\n+            for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n+                for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n+                    if self.impls_have_common_items(impl_items1, impl_items2) {\n+                        self.check_for_overlapping_inherent_impls(\n+                            overlap_mode,\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                        );\n                     }\n-                } else {\n-                    // Build a set of connected regions of impl blocks.\n-                    // Two impl blocks are regarded as connected if they share\n-                    // an item with the same unhygienic identifier.\n-                    // After we have assembled the connected regions,\n-                    // run the O(n^2) algorithm on each connected region.\n-                    // This is advantageous to running the algorithm over the\n-                    // entire graph when there are many connected regions.\n+                }\n+            }\n+        } else {\n+            // Build a set of connected regions of impl blocks.\n+            // Two impl blocks are regarded as connected if they share\n+            // an item with the same unhygienic identifier.\n+            // After we have assembled the connected regions,\n+            // run the O(n^2) algorithm on each connected region.\n+            // This is advantageous to running the algorithm over the\n+            // entire graph when there are many connected regions.\n \n-                    rustc_index::newtype_index! {\n-                        pub struct RegionId {\n-                            ENCODABLE = custom\n+            rustc_index::newtype_index! {\n+                pub struct RegionId {\n+                    ENCODABLE = custom\n+                }\n+            }\n+            struct ConnectedRegion {\n+                idents: SmallVec<[Symbol; 8]>,\n+                impl_blocks: FxHashSet<usize>,\n+            }\n+            let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n+            // Reverse map from the Symbol to the connected region id.\n+            let mut connected_region_ids = FxHashMap::default();\n+\n+            for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n+                if impl_items.len() == 0 {\n+                    continue;\n+                }\n+                // First obtain a list of existing connected region ids\n+                let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n+                let mut ids = impl_items\n+                    .in_definition_order()\n+                    .filter_map(|item| {\n+                        let entry = connected_region_ids.entry(item.name);\n+                        if let Entry::Occupied(e) = &entry {\n+                            Some(*e.get())\n+                        } else {\n+                            idents_to_add.push(item.name);\n+                            None\n                         }\n+                    })\n+                    .collect::<SmallVec<[RegionId; 8]>>();\n+                // Sort the id list so that the algorithm is deterministic\n+                ids.sort_unstable();\n+                ids.dedup();\n+                let ids = ids;\n+                match &ids[..] {\n+                    // Create a new connected region\n+                    [] => {\n+                        let id_to_set = connected_regions.next_index();\n+                        // Update the connected region ids\n+                        for ident in &idents_to_add {\n+                            connected_region_ids.insert(*ident, id_to_set);\n+                        }\n+                        connected_regions.insert(\n+                            id_to_set,\n+                            ConnectedRegion {\n+                                idents: idents_to_add,\n+                                impl_blocks: std::iter::once(i).collect(),\n+                            },\n+                        );\n                     }\n-                    struct ConnectedRegion {\n-                        idents: SmallVec<[Symbol; 8]>,\n-                        impl_blocks: FxHashSet<usize>,\n+                    // Take the only id inside the list\n+                    &[id_to_set] => {\n+                        let region = connected_regions[id_to_set].as_mut().unwrap();\n+                        region.impl_blocks.insert(i);\n+                        region.idents.extend_from_slice(&idents_to_add);\n+                        // Update the connected region ids\n+                        for ident in &idents_to_add {\n+                            connected_region_ids.insert(*ident, id_to_set);\n+                        }\n                     }\n-                    let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n-                    // Reverse map from the Symbol to the connected region id.\n-                    let mut connected_region_ids = FxHashMap::default();\n-\n-                    for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n-                        if impl_items.len() == 0 {\n-                            continue;\n+                    // We have multiple connected regions to merge.\n+                    // In the worst case this might add impl blocks\n+                    // one by one and can thus be O(n^2) in the size\n+                    // of the resulting final connected region, but\n+                    // this is no issue as the final step to check\n+                    // for overlaps runs in O(n^2) as well.\n+                    &[id_to_set, ..] => {\n+                        let mut region = connected_regions.remove(id_to_set).unwrap();\n+                        region.impl_blocks.insert(i);\n+                        region.idents.extend_from_slice(&idents_to_add);\n+                        // Update the connected region ids\n+                        for ident in &idents_to_add {\n+                            connected_region_ids.insert(*ident, id_to_set);\n                         }\n-                        // First obtain a list of existing connected region ids\n-                        let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n-                        let mut ids = impl_items\n-                            .in_definition_order()\n-                            .filter_map(|item| {\n-                                let entry = connected_region_ids.entry(item.name);\n-                                if let Entry::Occupied(e) = &entry {\n-                                    Some(*e.get())\n-                                } else {\n-                                    idents_to_add.push(item.name);\n-                                    None\n-                                }\n-                            })\n-                            .collect::<SmallVec<[RegionId; 8]>>();\n-                        // Sort the id list so that the algorithm is deterministic\n-                        ids.sort_unstable();\n-                        ids.dedup();\n-                        let ids = ids;\n-                        match &ids[..] {\n-                            // Create a new connected region\n-                            [] => {\n-                                let id_to_set = connected_regions.next_index();\n-                                // Update the connected region ids\n-                                for ident in &idents_to_add {\n-                                    connected_region_ids.insert(*ident, id_to_set);\n-                                }\n-                                connected_regions.insert(\n-                                    id_to_set,\n-                                    ConnectedRegion {\n-                                        idents: idents_to_add,\n-                                        impl_blocks: std::iter::once(i).collect(),\n-                                    },\n-                                );\n-                            }\n-                            // Take the only id inside the list\n-                            &[id_to_set] => {\n-                                let region = connected_regions[id_to_set].as_mut().unwrap();\n-                                region.impl_blocks.insert(i);\n-                                region.idents.extend_from_slice(&idents_to_add);\n-                                // Update the connected region ids\n-                                for ident in &idents_to_add {\n-                                    connected_region_ids.insert(*ident, id_to_set);\n-                                }\n-                            }\n-                            // We have multiple connected regions to merge.\n-                            // In the worst case this might add impl blocks\n-                            // one by one and can thus be O(n^2) in the size\n-                            // of the resulting final connected region, but\n-                            // this is no issue as the final step to check\n-                            // for overlaps runs in O(n^2) as well.\n-                            &[id_to_set, ..] => {\n-                                let mut region = connected_regions.remove(id_to_set).unwrap();\n-                                region.impl_blocks.insert(i);\n-                                region.idents.extend_from_slice(&idents_to_add);\n-                                // Update the connected region ids\n-                                for ident in &idents_to_add {\n-                                    connected_region_ids.insert(*ident, id_to_set);\n-                                }\n-\n-                                // Remove other regions from ids.\n-                                for &id in ids.iter() {\n-                                    if id == id_to_set {\n-                                        continue;\n-                                    }\n-                                    let r = connected_regions.remove(id).unwrap();\n-                                    for ident in r.idents.iter() {\n-                                        connected_region_ids.insert(*ident, id_to_set);\n-                                    }\n-                                    region.idents.extend_from_slice(&r.idents);\n-                                    region.impl_blocks.extend(r.impl_blocks);\n-                                }\n \n-                                connected_regions.insert(id_to_set, region);\n+                        // Remove other regions from ids.\n+                        for &id in ids.iter() {\n+                            if id == id_to_set {\n+                                continue;\n+                            }\n+                            let r = connected_regions.remove(id).unwrap();\n+                            for ident in r.idents.iter() {\n+                                connected_region_ids.insert(*ident, id_to_set);\n                             }\n+                            region.idents.extend_from_slice(&r.idents);\n+                            region.impl_blocks.extend(r.impl_blocks);\n                         }\n+\n+                        connected_regions.insert(id_to_set, region);\n                     }\n+                }\n+            }\n \n-                    debug!(\n-                        \"churning through {} components (sum={}, avg={}, var={}, max={})\",\n-                        connected_regions.len(),\n-                        impls.len(),\n-                        impls.len() / connected_regions.len(),\n-                        {\n-                            let avg = impls.len() / connected_regions.len();\n-                            let s = connected_regions\n-                                .iter()\n-                                .flatten()\n-                                .map(|r| r.impl_blocks.len() as isize - avg as isize)\n-                                .map(|v| v.abs() as usize)\n-                                .sum::<usize>();\n-                            s / connected_regions.len()\n-                        },\n-                        connected_regions\n-                            .iter()\n-                            .flatten()\n-                            .map(|r| r.impl_blocks.len())\n-                            .max()\n-                            .unwrap()\n-                    );\n-                    // List of connected regions is built. Now, run the overlap check\n-                    // for each pair of impl blocks in the same connected region.\n-                    for region in connected_regions.into_iter().flatten() {\n-                        let mut impl_blocks =\n-                            region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n-                        impl_blocks.sort_unstable();\n-                        for (i, &impl1_items_idx) in impl_blocks.iter().enumerate() {\n-                            let &(&impl1_def_id, impl_items1) = &impls_items[impl1_items_idx];\n-                            for &impl2_items_idx in impl_blocks[(i + 1)..].iter() {\n-                                let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n-                                if self.impls_have_common_items(impl_items1, impl_items2) {\n-                                    self.check_for_overlapping_inherent_impls(\n-                                        overlap_mode,\n-                                        impl1_def_id,\n-                                        impl2_def_id,\n-                                    );\n-                                }\n-                            }\n+            debug!(\n+                \"churning through {} components (sum={}, avg={}, var={}, max={})\",\n+                connected_regions.len(),\n+                impls.len(),\n+                impls.len() / connected_regions.len(),\n+                {\n+                    let avg = impls.len() / connected_regions.len();\n+                    let s = connected_regions\n+                        .iter()\n+                        .flatten()\n+                        .map(|r| r.impl_blocks.len() as isize - avg as isize)\n+                        .map(|v| v.abs() as usize)\n+                        .sum::<usize>();\n+                    s / connected_regions.len()\n+                },\n+                connected_regions.iter().flatten().map(|r| r.impl_blocks.len()).max().unwrap()\n+            );\n+            // List of connected regions is built. Now, run the overlap check\n+            // for each pair of impl blocks in the same connected region.\n+            for region in connected_regions.into_iter().flatten() {\n+                let mut impl_blocks =\n+                    region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n+                impl_blocks.sort_unstable();\n+                for (i, &impl1_items_idx) in impl_blocks.iter().enumerate() {\n+                    let &(&impl1_def_id, impl_items1) = &impls_items[impl1_items_idx];\n+                    for &impl2_items_idx in impl_blocks[(i + 1)..].iter() {\n+                        let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n+                        if self.impls_have_common_items(impl_items1, impl_items2) {\n+                            self.check_for_overlapping_inherent_impls(\n+                                overlap_mode,\n+                                impl1_def_id,\n+                                impl2_def_id,\n+                            );\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n }"}]}