{"sha": "37ca36783c57ad8cce17f3b19fc1016202eb612c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Y2EzNjc4M2M1N2FkOGNjZTE3ZjNiMTlmYzEwMTYyMDJlYjYxMmM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-05-06T11:38:01Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-05-10T23:08:01Z"}, "message": "Reorganise driver code.\n\nThe goal of this refactoring is to make the rustc driver code easier to understand and use. Since this is as close to an API as we have, I think it is important that it is nice. On getting stuck in, I found that there wasn't as much to change as I'd hoped to make the stage... fns easier to use by tools.\n\nThis patch only moves code around - mostly just moving code to different files, but a few extracted method refactorings too. To summarise the changes: I added driver::config which handles everything about configuring the compiler. driver::session now just defines and builds session objects. I moved driver code from librustc/lib.rs to librustc/driver/mod.rs so all the code is one place. I extracted methods to make emulating the compiler without being the compiler a little easier. Within the driver directory, I moved code around to more logically fit in the modules.", "tree": {"sha": "1bac4c2657cceab4ccb8d0c217d2e71854e6d574", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bac4c2657cceab4ccb8d0c217d2e71854e6d574"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37ca36783c57ad8cce17f3b19fc1016202eb612c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37ca36783c57ad8cce17f3b19fc1016202eb612c", "html_url": "https://github.com/rust-lang/rust/commit/37ca36783c57ad8cce17f3b19fc1016202eb612c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37ca36783c57ad8cce17f3b19fc1016202eb612c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11571cd9c1cde63c3b46ca65e608b84647785ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11571cd9c1cde63c3b46ca65e608b84647785ac8", "html_url": "https://github.com/rust-lang/rust/commit/11571cd9c1cde63c3b46ca65e608b84647785ac8"}], "stats": {"total": 2818, "additions": 1444, "deletions": 1374}, "files": [{"sha": "792992833a218e3f9709d121c0618c41c7fa436b", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use back::target_strs;\n-use driver::session::sess_os_to_meta_os;\n+use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n@@ -22,7 +22,7 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n     return target_strs::t {\n         module_asm: \"\".to_owned(),\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {"}, {"sha": "45641d08d1e351ae461c413f98919256526bbf14", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -12,8 +12,9 @@ use back::archive::{Archive, METADATA_FILENAME};\n use back::rpath;\n use back::svh::Svh;\n use driver::driver::{CrateTranslation, OutputFilenames};\n-use driver::session::{NoDebugInfo, Session};\n-use driver::session;\n+use driver::config::NoDebugInfo;\n+use driver::session::Session;\n+use driver::config;\n use lib::llvm::llvm;\n use lib::llvm::ModuleRef;\n use lib;\n@@ -92,8 +93,9 @@ pub mod write {\n     use back::link::{OutputTypeExe, OutputTypeLlvmAssembly};\n     use back::link::{OutputTypeObject};\n     use driver::driver::{CrateTranslation, OutputFilenames};\n-    use driver::session::{NoDebugInfo, Session};\n-    use driver::session;\n+    use driver::config::NoDebugInfo;\n+    use driver::session::Session;\n+    use driver::config;\n     use lib::llvm::llvm;\n     use lib::llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n     use lib;\n@@ -139,10 +141,10 @@ pub mod write {\n             }\n \n             let opt_level = match sess.opts.optimize {\n-              session::No => lib::llvm::CodeGenLevelNone,\n-              session::Less => lib::llvm::CodeGenLevelLess,\n-              session::Default => lib::llvm::CodeGenLevelDefault,\n-              session::Aggressive => lib::llvm::CodeGenLevelAggressive,\n+              config::No => lib::llvm::CodeGenLevelNone,\n+              config::Less => lib::llvm::CodeGenLevelLess,\n+              config::Default => lib::llvm::CodeGenLevelDefault,\n+              config::Aggressive => lib::llvm::CodeGenLevelAggressive,\n             };\n             let use_softfp = sess.opts.cg.soft_float;\n \n@@ -231,7 +233,7 @@ pub mod write {\n             // emitting an rlib. Whenever an rlib is created, the bytecode is\n             // inserted into the archive in order to allow LTO against it.\n             if sess.opts.cg.save_temps ||\n-               (sess.crate_types.borrow().contains(&session::CrateTypeRlib) &&\n+               (sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n                 sess.opts.output_types.contains(&OutputTypeExe)) {\n                 output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n@@ -378,10 +380,10 @@ pub mod write {\n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3\n         let vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n-                             (sess.opts.optimize == session::Default ||\n-                              sess.opts.optimize == session::Aggressive);\n+                             (sess.opts.optimize == config::Default ||\n+                              sess.opts.optimize == config::Aggressive);\n         let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n-                            sess.opts.optimize == session::Aggressive;\n+                            sess.opts.optimize == config::Aggressive;\n \n         let mut llvm_c_strs = Vec::new();\n         let mut llvm_args = Vec::new();\n@@ -823,14 +825,14 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n+pub fn filename_for_input(sess: &Session, crate_type: config::CrateType,\n                           id: &CrateId, out_filename: &Path) -> Path {\n     let libname = output_lib_filename(id);\n     match crate_type {\n-        session::CrateTypeRlib => {\n+        config::CrateTypeRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n-        session::CrateTypeDylib => {\n+        config::CrateTypeDylib => {\n             let (prefix, suffix) = match sess.targ_cfg.os {\n                 abi::OsWin32 => (loader::WIN32_DLL_PREFIX, loader::WIN32_DLL_SUFFIX),\n                 abi::OsMacos => (loader::MACOS_DLL_PREFIX, loader::MACOS_DLL_SUFFIX),\n@@ -840,16 +842,16 @@ pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n             };\n             out_filename.with_filename(format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n-        session::CrateTypeStaticlib => {\n+        config::CrateTypeStaticlib => {\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n-        session::CrateTypeExecutable => out_filename.clone(),\n+        config::CrateTypeExecutable => out_filename.clone(),\n     }\n }\n \n fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n-                      crate_type: session::CrateType,\n+                      crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       id: &CrateId) -> Path {\n     let obj_filename = outputs.temp_path(OutputTypeObject);\n@@ -877,16 +879,16 @@ fn link_binary_output(sess: &Session,\n     }\n \n     match crate_type {\n-        session::CrateTypeRlib => {\n+        config::CrateTypeRlib => {\n             link_rlib(sess, Some(trans), &obj_filename, &out_filename);\n         }\n-        session::CrateTypeStaticlib => {\n+        config::CrateTypeStaticlib => {\n             link_staticlib(sess, &obj_filename, &out_filename);\n         }\n-        session::CrateTypeExecutable => {\n+        config::CrateTypeExecutable => {\n             link_natively(sess, trans, false, &obj_filename, &out_filename);\n         }\n-        session::CrateTypeDylib => {\n+        config::CrateTypeDylib => {\n             link_natively(sess, trans, true, &obj_filename, &out_filename);\n         }\n     }\n@@ -1045,7 +1047,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     let mut cc_args = sess.targ_cfg.target_strs.cc_args.clone();\n     cc_args.push_all_move(link_args(sess, dylib, tmpdir.path(), trans,\n                                     obj_filename, out_filename));\n-    if (sess.opts.debugging_opts & session::PRINT_LINK_ARGS) != 0 {\n+    if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n         println!(\"{} link args: '{}'\", cc_prog, cc_args.connect(\"' '\"));\n     }\n \n@@ -1161,8 +1163,8 @@ fn link_args(sess: &Session,\n \n         // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n         // numeric argument, but other linkers do.\n-        if sess.opts.optimize == session::Default ||\n-           sess.opts.optimize == session::Aggressive {\n+        if sess.opts.optimize == config::Default ||\n+           sess.opts.optimize == config::Aggressive {\n             args.push(\"-Wl,-O1\".to_owned());\n         }\n     } else if sess.targ_cfg.os == abi::OsMacos {\n@@ -1373,9 +1375,9 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let data = if dylib {\n-        trans.crate_formats.get(&session::CrateTypeDylib)\n+        trans.crate_formats.get(&config::CrateTypeDylib)\n     } else {\n-        trans.crate_formats.get(&session::CrateTypeExecutable)\n+        trans.crate_formats.get(&config::CrateTypeExecutable)\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n@@ -1403,7 +1405,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: &session::Config, stem: &str) -> ~str {\n+    fn unlib(config: &config::Config, stem: &str) -> ~str {\n         if stem.starts_with(\"lib\") && config.os != abi::OsWin32 {\n             stem.slice(3, stem.len()).to_owned()\n         } else {"}, {"sha": "f581b7a38a80e2b7ad2996fbba3c959c145f9870", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -11,6 +11,7 @@\n use back::archive::ArchiveRO;\n use back::link;\n use driver::session;\n+use driver::config;\n use lib::llvm::{ModuleRef, TargetMachineRef, llvm, True, False};\n use metadata::cstore;\n use util::common::time;\n@@ -29,7 +30,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // Make sure we actually can run LTO\n     for crate_type in sess.crate_types.borrow().iter() {\n         match *crate_type {\n-            session::CrateTypeExecutable | session::CrateTypeStaticlib => {}\n+            config::CrateTypeExecutable | config::CrateTypeStaticlib => {}\n             _ => {\n                 sess.fatal(\"lto can only be run for executables and \\\n                             static library outputs\");"}, {"sha": "ddf67ae564a3eaa18e52ea4fc98a1605272e056b", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use back::target_strs;\n-use driver::session::sess_os_to_meta_os;\n+use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_owned(),\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {"}, {"sha": "b572b59cf6e3b337f05e3609a4d33d7d12964ec1", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -10,15 +10,15 @@\n \n \n use back::target_strs;\n-use driver::session::sess_os_to_meta_os;\n+use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_owned(),\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {"}, {"sha": "58f1a72e03c62c1fc9c2fb9d3490a1582c7a96b0", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -10,15 +10,15 @@\n \n \n use back::target_strs;\n-use driver::session::sess_os_to_meta_os;\n+use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_owned(),\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {"}, {"sha": "ef8c8f1f70a478a9b7924e225a620b35750f52ed", "filename": "src/librustc/driver/config.rs", "status": "added", "additions": 769, "deletions": 0, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -0,0 +1,769 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Contains infrastructure for configuring the compiler, including parsing\n+//! command line options.\n+\n+use driver::early_error;\n+use driver::driver;\n+use driver::session::Session;\n+\n+use back;\n+use back::link;\n+use back::target_strs;\n+use back::{arm, x86, x86_64, mips};\n+use metadata;\n+use middle::lint;\n+\n+use syntax::abi;\n+use syntax::ast;\n+use syntax::ast::{IntTy, UintTy};\n+use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse;\n+use syntax::parse::token::InternedString;\n+\n+use collections::HashSet;\n+use getopts::{optopt, optmulti, optflag, optflagopt};\n+use getopts;\n+use lib::llvm::llvm;\n+use std::cell::{RefCell};\n+\n+\n+pub struct Config {\n+    pub os: abi::Os,\n+    pub arch: abi::Architecture,\n+    pub target_strs: target_strs::t,\n+    pub int_type: IntTy,\n+    pub uint_type: UintTy,\n+}\n+\n+#[deriving(Clone, Eq)]\n+pub enum OptLevel {\n+    No, // -O0\n+    Less, // -O1\n+    Default, // -O2\n+    Aggressive // -O3\n+}\n+\n+#[deriving(Clone, Eq)]\n+pub enum DebugInfoLevel {\n+    NoDebugInfo,\n+    LimitedDebugInfo,\n+    FullDebugInfo,\n+}\n+\n+#[deriving(Clone)]\n+pub struct Options {\n+    // The crate config requested for the session, which may be combined\n+    // with additional crate configurations during the compile process\n+    pub crate_types: Vec<CrateType>,\n+\n+    pub gc: bool,\n+    pub optimize: OptLevel,\n+    pub debuginfo: DebugInfoLevel,\n+    pub lint_opts: Vec<(lint::Lint, lint::level)> ,\n+    pub output_types: Vec<back::link::OutputType> ,\n+    // This was mutable for rustpkg, which updates search paths based on the\n+    // parsed code. It remains mutable in case its replacements wants to use\n+    // this.\n+    pub addl_lib_search_paths: RefCell<HashSet<Path>>,\n+    pub maybe_sysroot: Option<Path>,\n+    pub target_triple: ~str,\n+    // User-specified cfg meta items. The compiler itself will add additional\n+    // items to the crate config, and during parsing the entire crate config\n+    // will be added to the crate AST node.  This should not be used for\n+    // anything except building the full crate config prior to parsing.\n+    pub cfg: ast::CrateConfig,\n+    pub test: bool,\n+    pub parse_only: bool,\n+    pub no_trans: bool,\n+    pub no_analysis: bool,\n+    pub debugging_opts: u64,\n+    /// Whether to write dependency files. It's (enabled, optional filename).\n+    pub write_dependency_info: (bool, Option<Path>),\n+    /// Crate id-related things to maybe print. It's (crate_id, crate_name, crate_file_name).\n+    pub print_metas: (bool, bool, bool),\n+    pub cg: CodegenOptions,\n+}\n+\n+/// Some reasonable defaults\n+pub fn basic_options() -> Options {\n+    Options {\n+        crate_types: Vec::new(),\n+        gc: false,\n+        optimize: No,\n+        debuginfo: NoDebugInfo,\n+        lint_opts: Vec::new(),\n+        output_types: Vec::new(),\n+        addl_lib_search_paths: RefCell::new(HashSet::new()),\n+        maybe_sysroot: None,\n+        target_triple: driver::host_triple().to_owned(),\n+        cfg: Vec::new(),\n+        test: false,\n+        parse_only: false,\n+        no_trans: false,\n+        no_analysis: false,\n+        debugging_opts: 0,\n+        write_dependency_info: (false, None),\n+        print_metas: (false, false, false),\n+        cg: basic_codegen_options(),\n+    }\n+}\n+\n+// The type of entry function, so\n+// users can have their own entry\n+// functions that don't start a\n+// scheduler\n+#[deriving(Eq)]\n+pub enum EntryFnType {\n+    EntryMain,\n+    EntryStart,\n+    EntryNone,\n+}\n+\n+#[deriving(Eq, Ord, Clone, TotalOrd, TotalEq, Hash)]\n+pub enum CrateType {\n+    CrateTypeExecutable,\n+    CrateTypeDylib,\n+    CrateTypeRlib,\n+    CrateTypeStaticlib,\n+}\n+\n+macro_rules! debugging_opts(\n+    ([ $opt:ident ] $cnt:expr ) => (\n+        pub static $opt: u64 = 1 << $cnt;\n+    );\n+    ([ $opt:ident, $($rest:ident),* ] $cnt:expr ) => (\n+        pub static $opt: u64 = 1 << $cnt;\n+        debugging_opts!([ $($rest),* ] $cnt + 1)\n+    )\n+)\n+\n+debugging_opts!(\n+    [\n+        VERBOSE,\n+        TIME_PASSES,\n+        COUNT_LLVM_INSNS,\n+        TIME_LLVM_PASSES,\n+        TRANS_STATS,\n+        ASM_COMMENTS,\n+        NO_VERIFY,\n+        BORROWCK_STATS,\n+        NO_LANDING_PADS,\n+        DEBUG_LLVM,\n+        SHOW_SPAN,\n+        COUNT_TYPE_SIZES,\n+        META_STATS,\n+        NO_OPT,\n+        GC,\n+        PRINT_LINK_ARGS,\n+        PRINT_LLVM_PASSES,\n+        LTO,\n+        AST_JSON,\n+        AST_JSON_NOEXPAND,\n+        LS\n+    ]\n+    0\n+)\n+\n+pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n+    vec!((\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n+     (\"time-passes\", \"measure time of each rustc pass\", TIME_PASSES),\n+     (\"count-llvm-insns\", \"count where LLVM \\\n+                           instrs originate\", COUNT_LLVM_INSNS),\n+     (\"time-llvm-passes\", \"measure time of each LLVM pass\",\n+      TIME_LLVM_PASSES),\n+     (\"trans-stats\", \"gather trans statistics\", TRANS_STATS),\n+     (\"asm-comments\", \"generate comments into the assembly (may change behavior)\",\n+      ASM_COMMENTS),\n+     (\"no-verify\", \"skip LLVM verification\", NO_VERIFY),\n+     (\"borrowck-stats\", \"gather borrowck statistics\",  BORROWCK_STATS),\n+     (\"no-landing-pads\", \"omit landing pads for unwinding\",\n+      NO_LANDING_PADS),\n+     (\"debug-llvm\", \"enable debug output from LLVM\", DEBUG_LLVM),\n+     (\"show-span\", \"show spans for compiler debugging\", SHOW_SPAN),\n+     (\"count-type-sizes\", \"count the sizes of aggregate types\",\n+      COUNT_TYPE_SIZES),\n+     (\"meta-stats\", \"gather metadata statistics\", META_STATS),\n+     (\"no-opt\", \"do not optimize, even if -O is passed\", NO_OPT),\n+     (\"print-link-args\", \"Print the arguments passed to the linker\",\n+      PRINT_LINK_ARGS),\n+     (\"gc\", \"Garbage collect shared data (experimental)\", GC),\n+     (\"print-llvm-passes\",\n+      \"Prints the llvm optimization passes being run\",\n+      PRINT_LLVM_PASSES),\n+     (\"lto\", \"Perform LLVM link-time optimizations\", LTO),\n+     (\"ast-json\", \"Print the AST as JSON and halt\", AST_JSON),\n+     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n+     (\"ls\", \"List the symbols defined by a library crate\", LS))\n+}\n+\n+/// Declare a macro that will define all CodegenOptions fields and parsers all\n+/// at once. The goal of this macro is to define an interface that can be\n+/// programmatically used by the option parser in order to initialize the struct\n+/// without hardcoding field names all over the place.\n+///\n+/// The goal is to invoke this macro once with the correct fields, and then this\n+/// macro generates all necessary code. The main gotcha of this macro is the\n+/// cgsetters module which is a bunch of generated code to parse an option into\n+/// its respective field in the struct. There are a few hand-written parsers for\n+/// parsing specific types of values in this module.\n+macro_rules! cgoptions(\n+    ($($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n+(\n+    #[deriving(Clone)]\n+    pub struct CodegenOptions { $(pub $opt: $t),* }\n+\n+    pub fn basic_codegen_options() -> CodegenOptions {\n+        CodegenOptions { $($opt: $init),* }\n+    }\n+\n+    pub type CodegenSetter = fn(&mut CodegenOptions, v: Option<&str>) -> bool;\n+    pub static CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n+                                      &'static str)] =\n+        &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n+\n+    mod cgsetters {\n+        use super::CodegenOptions;\n+\n+        $(\n+            pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n+                $parse(&mut cg.$opt, v)\n+            }\n+        )*\n+\n+        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+            match v {\n+                Some(..) => false,\n+                None => { *slot = true; true }\n+            }\n+        }\n+\n+        fn parse_opt_string(slot: &mut Option<~str>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = Some(s.to_owned()); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_string(slot: &mut ~str, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.to_owned(); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_list(slot: &mut Vec<~str>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    for s in s.words() {\n+                        slot.push(s.to_owned());\n+                    }\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+    }\n+) )\n+\n+cgoptions!(\n+    ar: Option<~str> = (None, parse_opt_string,\n+        \"tool to assemble archives with\"),\n+    linker: Option<~str> = (None, parse_opt_string,\n+        \"system linker to link outputs with\"),\n+    link_args: Vec<~str> = (Vec::new(), parse_list,\n+        \"extra arguments to pass to the linker (space separated)\"),\n+    target_cpu: ~str = (\"generic\".to_owned(), parse_string,\n+        \"select target processor (llc -mcpu=help for details)\"),\n+    target_feature: ~str = (\"\".to_owned(), parse_string,\n+        \"target specific attributes (llc -mattr=help for details)\"),\n+    passes: Vec<~str> = (Vec::new(), parse_list,\n+        \"a list of extra LLVM passes to run (space separated)\"),\n+    llvm_args: Vec<~str> = (Vec::new(), parse_list,\n+        \"a list of arguments to pass to llvm (space separated)\"),\n+    save_temps: bool = (false, parse_bool,\n+        \"save all temporary output files during compilation\"),\n+    android_cross_path: Option<~str> = (None, parse_opt_string,\n+        \"the path to the Android NDK\"),\n+    no_rpath: bool = (false, parse_bool,\n+        \"disables setting the rpath in libs/exes\"),\n+    no_prepopulate_passes: bool = (false, parse_bool,\n+        \"don't pre-populate the pass manager with a list of passes\"),\n+    no_vectorize_loops: bool = (false, parse_bool,\n+        \"don't run the loop vectorization optimization passes\"),\n+    no_vectorize_slp: bool = (false, parse_bool,\n+        \"don't run LLVM's SLP vectorization pass\"),\n+    soft_float: bool = (false, parse_bool,\n+        \"generate software floating point library calls\"),\n+    prefer_dynamic: bool = (false, parse_bool,\n+        \"prefer dynamic linking to static linking\"),\n+    no_integrated_as: bool = (false, parse_bool,\n+        \"use an external assembler rather than LLVM's integrated one\"),\n+    relocation_model: ~str = (\"pic\".to_owned(), parse_string,\n+         \"choose the relocation model to use (llc -relocation-model for details)\"),\n+)\n+\n+pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n+{\n+    let mut cg = basic_codegen_options();\n+    for option in matches.opt_strs(\"C\").move_iter() {\n+        let mut iter = option.splitn('=', 1);\n+        let key = iter.next().unwrap();\n+        let value = iter.next();\n+        let option_to_lookup = key.replace(\"-\", \"_\");\n+        let mut found = false;\n+        for &(candidate, setter, _) in CG_OPTIONS.iter() {\n+            if option_to_lookup.as_slice() != candidate { continue }\n+            if !setter(&mut cg, value) {\n+                match value {\n+                    Some(..) => early_error(format!(\"codegen option `{}` takes \\\n+                                                     no value\", key)),\n+                    None => early_error(format!(\"codegen option `{0}` requires \\\n+                                                 a value (-C {0}=<value>)\",\n+                                                key))\n+                }\n+            }\n+            found = true;\n+            break;\n+        }\n+        if !found {\n+            early_error(format!(\"unknown codegen option: `{}`\", key));\n+        }\n+    }\n+    return cg;\n+}\n+\n+pub fn default_lib_output() -> CrateType {\n+    CrateTypeRlib\n+}\n+\n+pub fn cfg_os_to_meta_os(os: abi::Os) -> metadata::loader::Os {\n+    use metadata::loader;\n+\n+    match os {\n+        abi::OsWin32 => loader::OsWin32,\n+        abi::OsLinux => loader::OsLinux,\n+        abi::OsAndroid => loader::OsAndroid,\n+        abi::OsMacos => loader::OsMacos,\n+        abi::OsFreebsd => loader::OsFreebsd\n+    }\n+}\n+\n+pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n+    let tos = match sess.targ_cfg.os {\n+        abi::OsWin32 =>   InternedString::new(\"win32\"),\n+        abi::OsMacos =>   InternedString::new(\"macos\"),\n+        abi::OsLinux =>   InternedString::new(\"linux\"),\n+        abi::OsAndroid => InternedString::new(\"android\"),\n+        abi::OsFreebsd => InternedString::new(\"freebsd\"),\n+    };\n+\n+    // ARM is bi-endian, however using NDK seems to default\n+    // to little-endian unless a flag is provided.\n+    let (end,arch,wordsz) = match sess.targ_cfg.arch {\n+        abi::X86 =>    (\"little\", \"x86\",    \"32\"),\n+        abi::X86_64 => (\"little\", \"x86_64\", \"64\"),\n+        abi::Arm =>    (\"little\", \"arm\",    \"32\"),\n+        abi::Mips =>   (\"big\",    \"mips\",   \"32\")\n+    };\n+\n+    let fam = match sess.targ_cfg.os {\n+        abi::OsWin32 => InternedString::new(\"windows\"),\n+        _ => InternedString::new(\"unix\")\n+    };\n+\n+    let mk = attr::mk_name_value_item_str;\n+    return vec!(// Target bindings.\n+         attr::mk_word_item(fam.clone()),\n+         mk(InternedString::new(\"target_os\"), tos),\n+         mk(InternedString::new(\"target_family\"), fam),\n+         mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n+         mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n+         mk(InternedString::new(\"target_word_size\"),\n+            InternedString::new(wordsz))\n+    );\n+}\n+\n+pub fn append_configuration(cfg: &mut ast::CrateConfig,\n+                            name: InternedString) {\n+    if !cfg.iter().any(|mi| mi.name() == name) {\n+        cfg.push(attr::mk_word_item(name))\n+    }\n+}\n+\n+pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n+    // Combine the configuration requested by the session (command line) with\n+    // some default and generated configuration items\n+    let default_cfg = default_configuration(sess);\n+    let mut user_cfg = sess.opts.cfg.clone();\n+    // If the user wants a test runner, then add the test cfg\n+    if sess.opts.test {\n+        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n+    }\n+    // If the user requested GC, then add the GC cfg\n+    append_configuration(&mut user_cfg, if sess.opts.gc {\n+        InternedString::new(\"gc\")\n+    } else {\n+        InternedString::new(\"nogc\")\n+    });\n+    user_cfg.move_iter().collect::<Vec<_>>().append(default_cfg.as_slice())\n+}\n+\n+pub fn get_os(triple: &str) -> Option<abi::Os> {\n+    for &(name, os) in os_names.iter() {\n+        if triple.contains(name) { return Some(os) }\n+    }\n+    None\n+}\n+static os_names : &'static [(&'static str, abi::Os)] = &'static [\n+    (\"mingw32\", abi::OsWin32),\n+    (\"win32\",   abi::OsWin32),\n+    (\"darwin\",  abi::OsMacos),\n+    (\"android\", abi::OsAndroid),\n+    (\"linux\",   abi::OsLinux),\n+    (\"freebsd\", abi::OsFreebsd)];\n+\n+pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n+    for &(arch, abi) in architecture_abis.iter() {\n+        if triple.contains(arch) { return Some(abi) }\n+    }\n+    None\n+}\n+static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'static [\n+    (\"i386\",   abi::X86),\n+    (\"i486\",   abi::X86),\n+    (\"i586\",   abi::X86),\n+    (\"i686\",   abi::X86),\n+    (\"i786\",   abi::X86),\n+\n+    (\"x86_64\", abi::X86_64),\n+\n+    (\"arm\",    abi::Arm),\n+    (\"xscale\", abi::Arm),\n+    (\"thumb\",  abi::Arm),\n+\n+    (\"mips\",   abi::Mips)];\n+\n+pub fn build_target_config(sopts: &Options) -> Config {\n+    let os = match get_os(sopts.target_triple) {\n+      Some(os) => os,\n+      None => early_error(\"unknown operating system\")\n+    };\n+    let arch = match get_arch(sopts.target_triple) {\n+      Some(arch) => arch,\n+      None => early_error(\"unknown architecture: \" + sopts.target_triple)\n+    };\n+    let (int_type, uint_type) = match arch {\n+      abi::X86 => (ast::TyI32, ast::TyU32),\n+      abi::X86_64 => (ast::TyI64, ast::TyU64),\n+      abi::Arm => (ast::TyI32, ast::TyU32),\n+      abi::Mips => (ast::TyI32, ast::TyU32)\n+    };\n+    let target_triple = sopts.target_triple.clone();\n+    let target_strs = match arch {\n+      abi::X86 => x86::get_target_strs(target_triple, os),\n+      abi::X86_64 => x86_64::get_target_strs(target_triple, os),\n+      abi::Arm => arm::get_target_strs(target_triple, os),\n+      abi::Mips => mips::get_target_strs(target_triple, os)\n+    };\n+    Config {\n+        os: os,\n+        arch: arch,\n+        target_strs: target_strs,\n+        int_type: int_type,\n+        uint_type: uint_type,\n+    }\n+}\n+\n+// rustc command line options\n+pub fn optgroups() -> Vec<getopts::OptGroup> {\n+    vec!(\n+        optflag(\"h\", \"help\", \"Display this message\"),\n+        optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n+        optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n+        optmulti(\"\", \"crate-type\", \"Comma separated list of types of crates\n+                                    for the compiler to emit\",\n+                 \"[bin|lib|rlib|dylib|staticlib]\"),\n+        optmulti(\"\", \"emit\", \"Comma separated list of types of output for the compiler to emit\",\n+                 \"[asm|bc|ir|obj|link]\"),\n+        optflag(\"\", \"crate-id\", \"Output the crate id and exit\"),\n+        optflag(\"\", \"crate-name\", \"Output the crate name and exit\"),\n+        optflag(\"\", \"crate-file-name\", \"Output the file(s) that would be written if compilation \\\n+              continued and exit\"),\n+        optflag(\"g\",  \"\",  \"Equivalent to --debuginfo=2\"),\n+        optopt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n+             0 = no debug info,\n+             1 = line-tables only (for stacktraces and breakpoints),\n+             2 = full debug info with variable and type information (same as -g)\", \"LEVEL\"),\n+        optflag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n+        optflag(\"\", \"no-analysis\",\n+              \"Parse and expand the source, but run no analysis and produce no output\"),\n+        optflag(\"O\", \"\", \"Equivalent to --opt-level=2\"),\n+        optopt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n+        optopt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n+        optopt( \"\",  \"out-dir\", \"Write output to compiler-chosen filename in <dir>\", \"DIR\"),\n+        optflag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, or link\"),\n+        optflagopt(\"\", \"pretty\",\n+                 \"Pretty-print the input instead of compiling;\n+                  valid types are: normal (un-annotated source),\n+                  expanded (crates expanded),\n+                  typed (crates expanded, with type annotations),\n+                  or identified (fully parenthesized,\n+                  AST nodes and blocks with IDs)\", \"TYPE\"),\n+        optflagopt(\"\", \"dep-info\",\n+                 \"Output dependency info to <filename> after compiling, \\\n+                  in a format suitable for use by Makefiles\", \"FILENAME\"),\n+        optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n+        optflag(\"\", \"test\", \"Build a test harness\"),\n+        optopt(\"\", \"target\", \"Target triple cpu-manufacturer-kernel[-os]\n+                            to compile for (see chapter 3.4 of http://www.sourceware.org/autobook/\n+                            for details)\", \"TRIPLE\"),\n+        optmulti(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n+        optmulti(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n+        optmulti(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n+        optmulti(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n+        optmulti(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n+        optmulti(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n+        optflag( \"v\", \"version\", \"Print version info and exit\")\n+    )\n+}\n+\n+\n+// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n+fn parse_cfgspecs(cfgspecs: Vec<~str> ) -> ast::CrateConfig {\n+    cfgspecs.move_iter().map(|s| {\n+        parse::parse_meta_from_source_str(\"cfgspec\".to_strbuf(),\n+                                          s.to_strbuf(),\n+                                          Vec::new(),\n+                                          &parse::new_parse_sess())\n+    }).collect::<ast::CrateConfig>()\n+}\n+\n+pub fn build_session_options(matches: &getopts::Matches) -> Options {\n+    let mut crate_types: Vec<CrateType> = Vec::new();\n+    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n+    for unparsed_crate_type in unparsed_crate_types.iter() {\n+        for part in unparsed_crate_type.split(',') {\n+            let new_part = match part {\n+                \"lib\"       => default_lib_output(),\n+                \"rlib\"      => CrateTypeRlib,\n+                \"staticlib\" => CrateTypeStaticlib,\n+                \"dylib\"     => CrateTypeDylib,\n+                \"bin\"       => CrateTypeExecutable,\n+                _ => early_error(format!(\"unknown crate type: `{}`\", part))\n+            };\n+            crate_types.push(new_part)\n+        }\n+    }\n+\n+    let parse_only = matches.opt_present(\"parse-only\");\n+    let no_trans = matches.opt_present(\"no-trans\");\n+    let no_analysis = matches.opt_present(\"no-analysis\");\n+\n+    let lint_levels = [lint::allow, lint::warn,\n+                       lint::deny, lint::forbid];\n+    let mut lint_opts = Vec::new();\n+    let lint_dict = lint::get_lint_dict();\n+    for level in lint_levels.iter() {\n+        let level_name = lint::level_to_str(*level);\n+\n+        let level_short = level_name.slice_chars(0, 1);\n+        let level_short = level_short.to_ascii().to_upper().into_str();\n+        let flags = matches.opt_strs(level_short).move_iter().collect::<Vec<_>>().append(\n+                                   matches.opt_strs(level_name).as_slice());\n+        for lint_name in flags.iter() {\n+            let lint_name = lint_name.replace(\"-\", \"_\");\n+            match lint_dict.find_equiv(&lint_name) {\n+              None => {\n+                early_error(format!(\"unknown {} flag: {}\",\n+                                    level_name, lint_name));\n+              }\n+              Some(lint) => {\n+                lint_opts.push((lint.lint, *level));\n+              }\n+            }\n+        }\n+    }\n+\n+    let mut debugging_opts = 0;\n+    let debug_flags = matches.opt_strs(\"Z\");\n+    let debug_map = debugging_opts_map();\n+    for debug_flag in debug_flags.iter() {\n+        let mut this_bit = 0;\n+        for tuple in debug_map.iter() {\n+            let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n+            if *name == *debug_flag { this_bit = bit; break; }\n+        }\n+        if this_bit == 0 {\n+            early_error(format!(\"unknown debug flag: {}\", *debug_flag))\n+        }\n+        debugging_opts |= this_bit;\n+    }\n+\n+    if debugging_opts & DEBUG_LLVM != 0 {\n+        unsafe { llvm::LLVMSetDebug(1); }\n+    }\n+\n+    let mut output_types = Vec::new();\n+    if !parse_only && !no_trans {\n+        let unparsed_output_types = matches.opt_strs(\"emit\");\n+        for unparsed_output_type in unparsed_output_types.iter() {\n+            for part in unparsed_output_type.split(',') {\n+                let output_type = match part.as_slice() {\n+                    \"asm\"  => link::OutputTypeAssembly,\n+                    \"ir\"   => link::OutputTypeLlvmAssembly,\n+                    \"bc\"   => link::OutputTypeBitcode,\n+                    \"obj\"  => link::OutputTypeObject,\n+                    \"link\" => link::OutputTypeExe,\n+                    _ => early_error(format!(\"unknown emission type: `{}`\", part))\n+                };\n+                output_types.push(output_type)\n+            }\n+        }\n+    };\n+    output_types.as_mut_slice().sort();\n+    output_types.dedup();\n+    if output_types.len() == 0 {\n+        output_types.push(link::OutputTypeExe);\n+    }\n+\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));\n+    let target = matches.opt_str(\"target\").unwrap_or(driver::host_triple().to_owned());\n+    let opt_level = {\n+        if (debugging_opts & NO_OPT) != 0 {\n+            No\n+        } else if matches.opt_present(\"O\") {\n+            if matches.opt_present(\"opt-level\") {\n+                early_error(\"-O and --opt-level both provided\");\n+            }\n+            Default\n+        } else if matches.opt_present(\"opt-level\") {\n+            match matches.opt_str(\"opt-level\").as_ref().map(|s| s.as_slice()) {\n+                None      |\n+                Some(\"0\") => No,\n+                Some(\"1\") => Less,\n+                Some(\"2\") => Default,\n+                Some(\"3\") => Aggressive,\n+                Some(arg) => {\n+                    early_error(format!(\"optimization level needs to be between 0-3 \\\n+                                        (instead was `{}`)\", arg));\n+                }\n+            }\n+        } else {\n+            No\n+        }\n+    };\n+    let gc = debugging_opts & GC != 0;\n+    let debuginfo = if matches.opt_present(\"g\") {\n+        if matches.opt_present(\"debuginfo\") {\n+            early_error(\"-g and --debuginfo both provided\");\n+        }\n+        FullDebugInfo\n+    } else if matches.opt_present(\"debuginfo\") {\n+        match matches.opt_str(\"debuginfo\").as_ref().map(|s| s.as_slice()) {\n+            Some(\"0\") => NoDebugInfo,\n+            Some(\"1\") => LimitedDebugInfo,\n+            None      |\n+            Some(\"2\") => FullDebugInfo,\n+            Some(arg) => {\n+                early_error(format!(\"optimization level needs to be between 0-3 \\\n+                                    (instead was `{}`)\", arg));\n+            }\n+        }\n+    } else {\n+        NoDebugInfo\n+    };\n+\n+    let addl_lib_search_paths = matches.opt_strs(\"L\").iter().map(|s| {\n+        Path::new(s.as_slice())\n+    }).collect();\n+\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\").move_iter().collect());\n+    let test = matches.opt_present(\"test\");\n+    let write_dependency_info = (matches.opt_present(\"dep-info\"),\n+                                 matches.opt_str(\"dep-info\").map(|p| Path::new(p)));\n+\n+    let print_metas = (matches.opt_present(\"crate-id\"),\n+                       matches.opt_present(\"crate-name\"),\n+                       matches.opt_present(\"crate-file-name\"));\n+    let cg = build_codegen_options(matches);\n+\n+    Options {\n+        crate_types: crate_types,\n+        gc: gc,\n+        optimize: opt_level,\n+        debuginfo: debuginfo,\n+        lint_opts: lint_opts,\n+        output_types: output_types,\n+        addl_lib_search_paths: RefCell::new(addl_lib_search_paths),\n+        maybe_sysroot: sysroot_opt,\n+        target_triple: target,\n+        cfg: cfg,\n+        test: test,\n+        parse_only: parse_only,\n+        no_trans: no_trans,\n+        no_analysis: no_analysis,\n+        debugging_opts: debugging_opts,\n+        write_dependency_info: write_dependency_info,\n+        print_metas: print_metas,\n+        cg: cg,\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+\n+    use driver::config::{build_configuration, optgroups, build_session_options};\n+    use driver::session::build_session;\n+\n+    use getopts::getopts;\n+    use syntax::attr;\n+    use syntax::attr::AttrMetaMethods;\n+\n+    // When the user supplies --test we should implicitly supply --cfg test\n+    #[test]\n+    fn test_switch_implies_cfg_test() {\n+        let matches =\n+            &match getopts([\"--test\".to_owned()], optgroups().as_slice()) {\n+              Ok(m) => m,\n+              Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n+            };\n+        let sessopts = build_session_options(matches);\n+        let sess = build_session(sessopts, None);\n+        let cfg = build_configuration(&sess);\n+        assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n+    }\n+\n+    // When the user supplies --test and --cfg test, don't implicitly add\n+    // another --cfg test\n+    #[test]\n+    fn test_switch_implies_cfg_test_unless_cfg_test() {\n+        let matches =\n+            &match getopts([\"--test\".to_owned(), \"--cfg=test\".to_owned()],\n+                           optgroups().as_slice()) {\n+              Ok(m) => m,\n+              Err(f) => {\n+                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\",\n+                       f.to_err_msg());\n+              }\n+            };\n+        let sessopts = build_session_options(matches);\n+        let sess = build_session(sessopts, None);\n+        let cfg = build_configuration(&sess);\n+        let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n+        assert!(test_items.next().is_some());\n+        assert!(test_items.next().is_none());\n+    }\n+}"}, {"sha": "19f2d33e5b1eb667cac465ef79e8f05d8abba22d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 109, "deletions": 590, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -10,56 +10,89 @@\n \n \n use back::link;\n-use back::{arm, x86, x86_64, mips};\n-use driver::session::{Aggressive, CrateTypeExecutable, CrateType,\n-                      FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use driver::session::{Session, No, Less, Default};\n-use driver::session;\n+use driver::session::Session;\n+use driver::config;\n use front;\n-use lib::llvm::llvm;\n use lib::llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n-use metadata::{creader, filesearch};\n-use metadata::cstore::CStore;\n+use metadata::creader;\n use metadata::creader::Loader;\n-use metadata;\n use middle::{trans, freevars, kind, ty, typeck, lint, reachable};\n use middle::dependency_format;\n use middle;\n use util::common::time;\n use util::ppaux;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{NodeSet};\n \n use serialize::{json, Encodable};\n \n-use std::cell::{Cell, RefCell};\n use std::io;\n use std::io::fs;\n use std::io::MemReader;\n-use std::os;\n-use getopts::{optopt, optmulti, optflag, optflagopt};\n-use getopts;\n use syntax::ast;\n-use syntax::abi;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n-use syntax::codemap;\n use syntax::crateid::CrateId;\n-use syntax::diagnostic;\n-use syntax::diagnostic::Emitter;\n use syntax::ext::base::CrateLoader;\n use syntax::parse;\n-use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n use syntax;\n \n-pub enum PpMode {\n-    PpmNormal,\n-    PpmExpanded,\n-    PpmTyped,\n-    PpmIdentified,\n-    PpmExpandedIdentified\n+pub fn host_triple() -> &'static str {\n+    // Get the host triple out of the build environment. This ensures that our\n+    // idea of the host triple is the same as for the set of libraries we've\n+    // actually built.  We can't just take LLVM's host triple because they\n+    // normalize all ix86 architectures to i386.\n+    //\n+    // Instead of grabbing the host triple (for the current host), we grab (at\n+    // compile time) the target triple that this rustc is built with and\n+    // calling that (at runtime) the host triple.\n+    (option_env!(\"CFG_COMPILER_HOST_TRIPLE\")).\n+        expect(\"CFG_COMPILER_HOST_TRIPLE\")\n+}\n+\n+pub fn compile_input(sess: Session,\n+                     cfg: ast::CrateConfig,\n+                     input: &Input,\n+                     outdir: &Option<Path>,\n+                     output: &Option<Path>) {\n+    // We need nested scopes here, because the intermediate results can keep\n+    // large chunks of memory alive and we want to free them as soon as\n+    // possible to keep the peak memory usage low\n+    let (outputs, trans, sess) = {\n+        let (outputs, expanded_crate, ast_map) = {\n+            let krate = phase_1_parse_input(&sess, cfg, input);\n+            if stop_after_phase_1(&sess) { return; }\n+            let outputs = build_output_filenames(input,\n+                                                 outdir,\n+                                                 output,\n+                                                 krate.attrs.as_slice(),\n+                                                 &sess);\n+            let loader = &mut Loader::new(&sess);\n+            let id = link::find_crate_id(krate.attrs.as_slice(),\n+                                         outputs.out_filestem);\n+            let (expanded_crate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n+                                                                         krate, &id);\n+            (outputs, expanded_crate, ast_map)\n+        };\n+        write_out_deps(&sess, input, &outputs, &expanded_crate);\n+\n+        if stop_after_phase_2(&sess) { return; }\n+\n+        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n+        if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n+        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate,\n+                                                     analysis, &outputs);\n+\n+        // Discard interned strings as they are no longer required.\n+        token::get_ident_interner().clear();\n+\n+        (outputs, trans, tcx.sess)\n+    };\n+    phase_5_run_llvm_passes(&sess, &trans, &outputs);\n+    if stop_after_phase_5(&sess) { return; }\n+    phase_6_link_output(&sess, &trans, &outputs);\n }\n \n /**\n@@ -78,78 +111,6 @@ pub fn source_name(input: &Input) -> ~str {\n     }\n }\n \n-pub fn default_configuration(sess: &Session) ->\n-   ast::CrateConfig {\n-    let tos = match sess.targ_cfg.os {\n-        abi::OsWin32 =>   InternedString::new(\"win32\"),\n-        abi::OsMacos =>   InternedString::new(\"macos\"),\n-        abi::OsLinux =>   InternedString::new(\"linux\"),\n-        abi::OsAndroid => InternedString::new(\"android\"),\n-        abi::OsFreebsd => InternedString::new(\"freebsd\"),\n-    };\n-\n-    // ARM is bi-endian, however using NDK seems to default\n-    // to little-endian unless a flag is provided.\n-    let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 =>    (\"little\", \"x86\",    \"32\"),\n-        abi::X86_64 => (\"little\", \"x86_64\", \"64\"),\n-        abi::Arm =>    (\"little\", \"arm\",    \"32\"),\n-        abi::Mips =>   (\"big\",    \"mips\",   \"32\")\n-    };\n-\n-    let fam = match sess.targ_cfg.os {\n-        abi::OsWin32 => InternedString::new(\"windows\"),\n-        _ => InternedString::new(\"unix\")\n-    };\n-\n-    let mk = attr::mk_name_value_item_str;\n-    return vec!(// Target bindings.\n-         attr::mk_word_item(fam.clone()),\n-         mk(InternedString::new(\"target_os\"), tos),\n-         mk(InternedString::new(\"target_family\"), fam),\n-         mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n-         mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n-         mk(InternedString::new(\"target_word_size\"),\n-            InternedString::new(wordsz))\n-    );\n-}\n-\n-pub fn append_configuration(cfg: &mut ast::CrateConfig,\n-                            name: InternedString) {\n-    if !cfg.iter().any(|mi| mi.name() == name) {\n-        cfg.push(attr::mk_word_item(name))\n-    }\n-}\n-\n-pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n-    // Combine the configuration requested by the session (command line) with\n-    // some default and generated configuration items\n-    let default_cfg = default_configuration(sess);\n-    let mut user_cfg = sess.opts.cfg.clone();\n-    // If the user wants a test runner, then add the test cfg\n-    if sess.opts.test {\n-        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n-    }\n-    // If the user requested GC, then add the GC cfg\n-    append_configuration(&mut user_cfg, if sess.opts.gc {\n-        InternedString::new(\"gc\")\n-    } else {\n-        InternedString::new(\"nogc\")\n-    });\n-    user_cfg.move_iter().collect::<Vec<_>>().append(default_cfg.as_slice())\n-}\n-\n-// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: Vec<~str> )\n-                  -> ast::CrateConfig {\n-    cfgspecs.move_iter().map(|s| {\n-        parse::parse_meta_from_source_str(\"cfgspec\".to_strbuf(),\n-                                          s.to_strbuf(),\n-                                          Vec::new(),\n-                                          &parse::new_parse_sess())\n-    }).collect::<ast::CrateConfig>()\n-}\n-\n pub enum Input {\n     /// Load source from file\n     FileInput(Path),\n@@ -183,7 +144,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n         }\n     });\n \n-    if sess.opts.debugging_opts & session::AST_JSON_NOEXPAND != 0 {\n+    if sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0 {\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         // unwrapping so IoError isn't ignored\n@@ -211,7 +172,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n \n-    *sess.crate_types.borrow_mut() = session::collect_crate_types(sess, krate.attrs.as_slice());\n+    *sess.crate_types.borrow_mut() = collect_crate_types(sess, krate.attrs.as_slice());\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &krate));\n@@ -262,7 +223,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let (krate, map) = time(time_passes, \"assinging node ids and indexing ast\", krate, |krate|\n          front::assign_node_ids_and_map::assign_node_ids_and_map(sess, krate));\n \n-    if sess.opts.debugging_opts & session::AST_JSON != 0 {\n+    if sess.opts.debugging_opts & config::AST_JSON != 0 {\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         // unwrapping so IoError isn't ignored\n@@ -466,15 +427,15 @@ pub fn stop_after_phase_1(sess: &Session) -> bool {\n     if sess.show_span() {\n         return true;\n     }\n-    return sess.opts.debugging_opts & session::AST_JSON_NOEXPAND != 0;\n+    return sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0;\n }\n \n pub fn stop_after_phase_2(sess: &Session) -> bool {\n     if sess.opts.no_analysis {\n         debug!(\"invoked with --no-analysis, returning early from compile_input\");\n         return true;\n     }\n-    return sess.opts.debugging_opts & session::AST_JSON != 0;\n+    return sess.opts.debugging_opts & config::AST_JSON != 0;\n }\n \n pub fn stop_after_phase_5(sess: &Session) -> bool {\n@@ -547,46 +508,6 @@ fn write_out_deps(sess: &Session,\n     }\n }\n \n-pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n-                     outdir: &Option<Path>, output: &Option<Path>) {\n-    // We need nested scopes here, because the intermediate results can keep\n-    // large chunks of memory alive and we want to free them as soon as\n-    // possible to keep the peak memory usage low\n-    let (outputs, trans, sess) = {\n-        let (outputs, expanded_crate, ast_map) = {\n-            let krate = phase_1_parse_input(&sess, cfg, input);\n-            if stop_after_phase_1(&sess) { return; }\n-            let outputs = build_output_filenames(input,\n-                                                 outdir,\n-                                                 output,\n-                                                 krate.attrs.as_slice(),\n-                                                 &sess);\n-            let loader = &mut Loader::new(&sess);\n-            let id = link::find_crate_id(krate.attrs.as_slice(),\n-                                         outputs.out_filestem);\n-            let (expanded_crate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n-                                                                         krate, &id);\n-            (outputs, expanded_crate, ast_map)\n-        };\n-        write_out_deps(&sess, input, &outputs, &expanded_crate);\n-\n-        if stop_after_phase_2(&sess) { return; }\n-\n-        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n-        if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n-        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate,\n-                                                     analysis, &outputs);\n-\n-        // Discard interned strings as they are no longer required.\n-        token::get_ident_interner().clear();\n-\n-        (outputs, trans, tcx.sess)\n-    };\n-    phase_5_run_llvm_passes(&sess, &trans, &outputs);\n-    if stop_after_phase_5(&sess) { return; }\n-    phase_6_link_output(&sess, &trans, &outputs);\n-}\n-\n struct IdentifiedAnnotation;\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n@@ -657,7 +578,7 @@ impl pprust::PpAnn for TypedAnnotation {\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n-                          ppm: PpMode,\n+                          ppm: ::driver::PpMode,\n                           ofile: Option<Path>) {\n     let krate = phase_1_parse_input(&sess, cfg, input);\n     let id = link::find_crate_id(krate.attrs.as_slice(), input.filestem());\n@@ -727,405 +648,60 @@ pub fn pretty_print_input(sess: Session,\n \n }\n \n-pub fn get_os(triple: &str) -> Option<abi::Os> {\n-    for &(name, os) in os_names.iter() {\n-        if triple.contains(name) { return Some(os) }\n+pub fn collect_crate_types(session: &Session,\n+                           attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n+    // If we're generating a test executable, then ignore all other output\n+    // styles at all other locations\n+    if session.opts.test {\n+        return vec!(config::CrateTypeExecutable)\n     }\n-    None\n-}\n-static os_names : &'static [(&'static str, abi::Os)] = &'static [\n-    (\"mingw32\", abi::OsWin32),\n-    (\"win32\",   abi::OsWin32),\n-    (\"darwin\",  abi::OsMacos),\n-    (\"android\", abi::OsAndroid),\n-    (\"linux\",   abi::OsLinux),\n-    (\"freebsd\", abi::OsFreebsd)];\n-\n-pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    for &(arch, abi) in architecture_abis.iter() {\n-        if triple.contains(arch) { return Some(abi) }\n-    }\n-    None\n-}\n-static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'static [\n-    (\"i386\",   abi::X86),\n-    (\"i486\",   abi::X86),\n-    (\"i586\",   abi::X86),\n-    (\"i686\",   abi::X86),\n-    (\"i786\",   abi::X86),\n-\n-    (\"x86_64\", abi::X86_64),\n-\n-    (\"arm\",    abi::Arm),\n-    (\"xscale\", abi::Arm),\n-    (\"thumb\",  abi::Arm),\n-\n-    (\"mips\",   abi::Mips)];\n \n-pub fn build_target_config(sopts: &session::Options) -> session::Config {\n-    let os = match get_os(sopts.target_triple) {\n-      Some(os) => os,\n-      None => early_error(\"unknown operating system\")\n-    };\n-    let arch = match get_arch(sopts.target_triple) {\n-      Some(arch) => arch,\n-      None => early_error(\"unknown architecture: \" + sopts.target_triple)\n-    };\n-    let (int_type, uint_type) = match arch {\n-      abi::X86 => (ast::TyI32, ast::TyU32),\n-      abi::X86_64 => (ast::TyI64, ast::TyU64),\n-      abi::Arm => (ast::TyI32, ast::TyU32),\n-      abi::Mips => (ast::TyI32, ast::TyU32)\n-    };\n-    let target_triple = sopts.target_triple.clone();\n-    let target_strs = match arch {\n-      abi::X86 => x86::get_target_strs(target_triple, os),\n-      abi::X86_64 => x86_64::get_target_strs(target_triple, os),\n-      abi::Arm => arm::get_target_strs(target_triple, os),\n-      abi::Mips => mips::get_target_strs(target_triple, os)\n-    };\n-    session::Config {\n-        os: os,\n-        arch: arch,\n-        target_strs: target_strs,\n-        int_type: int_type,\n-        uint_type: uint_type,\n-    }\n-}\n-\n-pub fn host_triple() -> &'static str {\n-    // Get the host triple out of the build environment. This ensures that our\n-    // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n-    // normalize all ix86 architectures to i386.\n-    //\n-    // Instead of grabbing the host triple (for the current host), we grab (at\n-    // compile time) the target triple that this rustc is built with and\n-    // calling that (at runtime) the host triple.\n-    (option_env!(\"CFG_COMPILER_HOST_TRIPLE\")).\n-        expect(\"CFG_COMPILER_HOST_TRIPLE\")\n-}\n-\n-pub fn build_session_options(matches: &getopts::Matches) -> session::Options {\n-    let mut crate_types: Vec<CrateType> = Vec::new();\n-    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n-    for unparsed_crate_type in unparsed_crate_types.iter() {\n-        for part in unparsed_crate_type.split(',') {\n-            let new_part = match part {\n-                \"lib\"       => session::default_lib_output(),\n-                \"rlib\"      => session::CrateTypeRlib,\n-                \"staticlib\" => session::CrateTypeStaticlib,\n-                \"dylib\"     => session::CrateTypeDylib,\n-                \"bin\"       => session::CrateTypeExecutable,\n-                _ => early_error(format!(\"unknown crate type: `{}`\", part))\n-            };\n-            crate_types.push(new_part)\n-        }\n-    }\n-\n-    let parse_only = matches.opt_present(\"parse-only\");\n-    let no_trans = matches.opt_present(\"no-trans\");\n-    let no_analysis = matches.opt_present(\"no-analysis\");\n-\n-    let lint_levels = [lint::allow, lint::warn,\n-                       lint::deny, lint::forbid];\n-    let mut lint_opts = Vec::new();\n-    let lint_dict = lint::get_lint_dict();\n-    for level in lint_levels.iter() {\n-        let level_name = lint::level_to_str(*level);\n-\n-        let level_short = level_name.slice_chars(0, 1);\n-        let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = matches.opt_strs(level_short).move_iter().collect::<Vec<_>>().append(\n-                                   matches.opt_strs(level_name).as_slice());\n-        for lint_name in flags.iter() {\n-            let lint_name = lint_name.replace(\"-\", \"_\");\n-            match lint_dict.find_equiv(&lint_name) {\n-              None => {\n-                early_error(format!(\"unknown {} flag: {}\",\n-                                    level_name, lint_name));\n-              }\n-              Some(lint) => {\n-                lint_opts.push((lint.lint, *level));\n-              }\n-            }\n-        }\n-    }\n-\n-    let mut debugging_opts = 0;\n-    let debug_flags = matches.opt_strs(\"Z\");\n-    let debug_map = session::debugging_opts_map();\n-    for debug_flag in debug_flags.iter() {\n-        let mut this_bit = 0;\n-        for tuple in debug_map.iter() {\n-            let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n-            if *name == *debug_flag { this_bit = bit; break; }\n-        }\n-        if this_bit == 0 {\n-            early_error(format!(\"unknown debug flag: {}\", *debug_flag))\n-        }\n-        debugging_opts |= this_bit;\n-    }\n-\n-    if debugging_opts & session::DEBUG_LLVM != 0 {\n-        unsafe { llvm::LLVMSetDebug(1); }\n-    }\n-\n-    let mut output_types = Vec::new();\n-    if !parse_only && !no_trans {\n-        let unparsed_output_types = matches.opt_strs(\"emit\");\n-        for unparsed_output_type in unparsed_output_types.iter() {\n-            for part in unparsed_output_type.split(',') {\n-                let output_type = match part.as_slice() {\n-                    \"asm\"  => link::OutputTypeAssembly,\n-                    \"ir\"   => link::OutputTypeLlvmAssembly,\n-                    \"bc\"   => link::OutputTypeBitcode,\n-                    \"obj\"  => link::OutputTypeObject,\n-                    \"link\" => link::OutputTypeExe,\n-                    _ => early_error(format!(\"unknown emission type: `{}`\", part))\n-                };\n-                output_types.push(output_type)\n-            }\n-        }\n-    };\n-    output_types.as_mut_slice().sort();\n-    output_types.dedup();\n-    if output_types.len() == 0 {\n-        output_types.push(link::OutputTypeExe);\n-    }\n-\n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));\n-    let target = matches.opt_str(\"target\").unwrap_or(host_triple().to_owned());\n-    let opt_level = {\n-        if (debugging_opts & session::NO_OPT) != 0 {\n-            No\n-        } else if matches.opt_present(\"O\") {\n-            if matches.opt_present(\"opt-level\") {\n-                early_error(\"-O and --opt-level both provided\");\n-            }\n-            Default\n-        } else if matches.opt_present(\"opt-level\") {\n-            match matches.opt_str(\"opt-level\").as_ref().map(|s| s.as_slice()) {\n-                None      |\n-                Some(\"0\") => No,\n-                Some(\"1\") => Less,\n-                Some(\"2\") => Default,\n-                Some(\"3\") => Aggressive,\n-                Some(arg) => {\n-                    early_error(format!(\"optimization level needs to be between 0-3 \\\n-                                        (instead was `{}`)\", arg));\n-                }\n-            }\n-        } else {\n-            No\n-        }\n-    };\n-    let gc = debugging_opts & session::GC != 0;\n-    let debuginfo = if matches.opt_present(\"g\") {\n-        if matches.opt_present(\"debuginfo\") {\n-            early_error(\"-g and --debuginfo both provided\");\n-        }\n-        FullDebugInfo\n-    } else if matches.opt_present(\"debuginfo\") {\n-        match matches.opt_str(\"debuginfo\").as_ref().map(|s| s.as_slice()) {\n-            Some(\"0\") => NoDebugInfo,\n-            Some(\"1\") => LimitedDebugInfo,\n-            None      |\n-            Some(\"2\") => FullDebugInfo,\n-            Some(arg) => {\n-                early_error(format!(\"optimization level needs to be between 0-3 \\\n-                                    (instead was `{}`)\", arg));\n-            }\n-        }\n+    // Only check command line flags if present. If no types are specified by\n+    // command line, then reuse the empty `base` Vec to hold the types that\n+    // will be found in crate attributes.\n+    let mut base = session.opts.crate_types.clone();\n+    if base.len() > 0 {\n+        return base\n     } else {\n-        NoDebugInfo\n-    };\n-\n-    let addl_lib_search_paths = matches.opt_strs(\"L\").iter().map(|s| {\n-        Path::new(s.as_slice())\n-    }).collect();\n-\n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\").move_iter().collect());\n-    let test = matches.opt_present(\"test\");\n-    let write_dependency_info = (matches.opt_present(\"dep-info\"),\n-                                 matches.opt_str(\"dep-info\").map(|p| Path::new(p)));\n-\n-    let print_metas = (matches.opt_present(\"crate-id\"),\n-                       matches.opt_present(\"crate-name\"),\n-                       matches.opt_present(\"crate-file-name\"));\n-    let cg = build_codegen_options(matches);\n-\n-    session::Options {\n-        crate_types: crate_types,\n-        gc: gc,\n-        optimize: opt_level,\n-        debuginfo: debuginfo,\n-        lint_opts: lint_opts,\n-        output_types: output_types,\n-        addl_lib_search_paths: RefCell::new(addl_lib_search_paths),\n-        maybe_sysroot: sysroot_opt,\n-        target_triple: target,\n-        cfg: cfg,\n-        test: test,\n-        parse_only: parse_only,\n-        no_trans: no_trans,\n-        no_analysis: no_analysis,\n-        debugging_opts: debugging_opts,\n-        write_dependency_info: write_dependency_info,\n-        print_metas: print_metas,\n-        cg: cg,\n-    }\n-}\n-\n-pub fn build_codegen_options(matches: &getopts::Matches)\n-        -> session::CodegenOptions\n-{\n-    let mut cg = session::basic_codegen_options();\n-    for option in matches.opt_strs(\"C\").move_iter() {\n-        let mut iter = option.splitn('=', 1);\n-        let key = iter.next().unwrap();\n-        let value = iter.next();\n-        let option_to_lookup = key.replace(\"-\", \"_\");\n-        let mut found = false;\n-        for &(candidate, setter, _) in session::CG_OPTIONS.iter() {\n-            if option_to_lookup.as_slice() != candidate { continue }\n-            if !setter(&mut cg, value) {\n-                match value {\n-                    Some(..) => early_error(format!(\"codegen option `{}` takes \\\n-                                                     no value\", key)),\n-                    None => early_error(format!(\"codegen option `{0}` requires \\\n-                                                 a value (-C {0}=<value>)\",\n-                                                key))\n+        let iter = attrs.iter().filter_map(|a| {\n+            if a.name().equiv(&(\"crate_type\")) {\n+                match a.value_str() {\n+                    Some(ref n) if n.equiv(&(\"rlib\")) => Some(config::CrateTypeRlib),\n+                    Some(ref n) if n.equiv(&(\"dylib\")) => Some(config::CrateTypeDylib),\n+                    Some(ref n) if n.equiv(&(\"lib\")) => {\n+                        Some(config::default_lib_output())\n+                    }\n+                    Some(ref n) if n.equiv(&(\"staticlib\")) => {\n+                        Some(config::CrateTypeStaticlib)\n+                    }\n+                    Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n+                    Some(_) => {\n+                        session.add_lint(lint::UnknownCrateType,\n+                                         ast::CRATE_NODE_ID,\n+                                         a.span,\n+                                         \"invalid `crate_type` value\".to_owned());\n+                        None\n+                    }\n+                    _ => {\n+                        session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n+                                        a.span, \"`crate_type` requires a value\".to_owned());\n+                        None\n+                    }\n                 }\n+            } else {\n+                None\n             }\n-            found = true;\n-            break;\n-        }\n-        if !found {\n-            early_error(format!(\"unknown codegen option: `{}`\", key));\n-        }\n-    }\n-    return cg;\n-}\n-\n-pub fn build_session(sopts: session::Options,\n-                     local_crate_source_file: Option<Path>)\n-                     -> Session {\n-    let codemap = codemap::CodeMap::new();\n-    let diagnostic_handler =\n-        diagnostic::default_handler();\n-    let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n-\n-    build_session_(sopts, local_crate_source_file, span_diagnostic_handler)\n-}\n-\n-pub fn build_session_(sopts: session::Options,\n-                      local_crate_source_file: Option<Path>,\n-                      span_diagnostic: diagnostic::SpanHandler)\n-                      -> Session {\n-    let target_cfg = build_target_config(&sopts);\n-    let p_s = parse::new_parse_sess_special_handler(span_diagnostic);\n-    let default_sysroot = match sopts.maybe_sysroot {\n-        Some(_) => None,\n-        None => Some(filesearch::get_or_default_sysroot())\n-    };\n-\n-    // Make the path absolute, if necessary\n-    let local_crate_source_file = local_crate_source_file.map(|path|\n-        if path.is_absolute() {\n-            path.clone()\n-        } else {\n-            os::getcwd().join(path.clone())\n-        }\n-    );\n-\n-    Session {\n-        targ_cfg: target_cfg,\n-        opts: sopts,\n-        cstore: CStore::new(token::get_ident_interner()),\n-        parse_sess: p_s,\n-        // For a library crate, this is always none\n-        entry_fn: RefCell::new(None),\n-        entry_type: Cell::new(None),\n-        macro_registrar_fn: Cell::new(None),\n-        default_sysroot: default_sysroot,\n-        local_crate_source_file: local_crate_source_file,\n-        working_dir: os::getcwd(),\n-        lints: RefCell::new(NodeMap::new()),\n-        node_id: Cell::new(1),\n-        crate_types: RefCell::new(Vec::new()),\n-        features: front::feature_gate::Features::new(),\n-        recursion_limit: Cell::new(64),\n-    }\n-}\n-\n-pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n-    match name {\n-        \"normal\" => PpmNormal,\n-        \"expanded\" => PpmExpanded,\n-        \"typed\" => PpmTyped,\n-        \"expanded,identified\" => PpmExpandedIdentified,\n-        \"identified\" => PpmIdentified,\n-        _ => {\n-            sess.fatal(\"argument to `pretty` must be one of `normal`, \\\n-                        `expanded`, `typed`, `identified`, \\\n-                        or `expanded,identified`\");\n+        });\n+        base.extend(iter);\n+        if base.len() == 0 {\n+            base.push(config::CrateTypeExecutable);\n         }\n+        base.as_mut_slice().sort();\n+        base.dedup();\n+        return base;\n     }\n }\n \n-// rustc command line options\n-pub fn optgroups() -> Vec<getopts::OptGroup> {\n- vec!(\n-  optflag(\"h\", \"help\", \"Display this message\"),\n-  optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n-  optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n-  optmulti(\"\", \"crate-type\", \"Comma separated list of types of crates for the compiler to emit\",\n-           \"[bin|lib|rlib|dylib|staticlib]\"),\n-  optmulti(\"\", \"emit\", \"Comma separated list of types of output for the compiler to emit\",\n-           \"[asm|bc|ir|obj|link]\"),\n-  optflag(\"\", \"crate-id\", \"Output the crate id and exit\"),\n-  optflag(\"\", \"crate-name\", \"Output the crate name and exit\"),\n-  optflag(\"\", \"crate-file-name\", \"Output the file(s) that would be written if compilation \\\n-          continued and exit\"),\n-  optflag(\"g\",  \"\",  \"Equivalent to --debuginfo=2\"),\n-  optopt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n-         0 = no debug info,\n-         1 = line-tables only (for stacktraces and breakpoints),\n-         2 = full debug info with variable and type information (same as -g)\", \"LEVEL\"),\n-  optflag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n-  optflag(\"\", \"no-analysis\",\n-          \"Parse and expand the source, but run no analysis and produce no output\"),\n-  optflag(\"O\", \"\", \"Equivalent to --opt-level=2\"),\n-  optopt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n-  optopt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n-  optopt( \"\",  \"out-dir\", \"Write output to compiler-chosen filename in <dir>\", \"DIR\"),\n-  optflag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, or link\"),\n-  optflagopt(\"\", \"pretty\",\n-             \"Pretty-print the input instead of compiling;\n-              valid types are: normal (un-annotated source),\n-              expanded (crates expanded),\n-              typed (crates expanded, with type annotations),\n-              or identified (fully parenthesized,\n-              AST nodes and blocks with IDs)\", \"TYPE\"),\n-  optflagopt(\"\", \"dep-info\",\n-             \"Output dependency info to <filename> after compiling, \\\n-              in a format suitable for use by Makefiles\", \"FILENAME\"),\n-  optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n-  optflag(\"\", \"test\", \"Build a test harness\"),\n-  optopt(\"\", \"target\", \"Target triple cpu-manufacturer-kernel[-os]\n-                        to compile for (see chapter 3.4 of http://www.sourceware.org/autobook/\n-                        for details)\", \"TRIPLE\"),\n-  optmulti(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n-  optmulti(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n-  optmulti(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n-  optmulti(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n-  optmulti(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n-  optmulti(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-  optflag( \"v\", \"version\", \"Print version info and exit\"))\n-}\n-\n pub struct OutputFilenames {\n     pub out_directory: Path,\n     pub out_filestem: ~str,\n@@ -1209,60 +785,3 @@ pub fn build_output_filenames(input: &Input,\n     }\n }\n \n-pub fn early_error(msg: &str) -> ! {\n-    let mut emitter = diagnostic::EmitterWriter::stderr();\n-    emitter.emit(None, msg, diagnostic::Fatal);\n-    fail!(diagnostic::FatalError);\n-}\n-\n-pub fn list_metadata(sess: &Session, path: &Path,\n-                     out: &mut io::Writer) -> io::IoResult<()> {\n-    metadata::loader::list_file_metadata(\n-        session::sess_os_to_meta_os(sess.targ_cfg.os), path, out)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use driver::driver::{build_configuration, build_session};\n-    use driver::driver::{build_session_options, optgroups};\n-\n-    use getopts::getopts;\n-    use syntax::attr;\n-    use syntax::attr::AttrMetaMethods;\n-\n-    // When the user supplies --test we should implicitly supply --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test() {\n-        let matches =\n-            &match getopts([\"--test\".to_owned()], optgroups().as_slice()) {\n-              Ok(m) => m,\n-              Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n-            };\n-        let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None);\n-        let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n-    }\n-\n-    // When the user supplies --test and --cfg test, don't implicitly add\n-    // another --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        let matches =\n-            &match getopts([\"--test\".to_owned(), \"--cfg=test\".to_owned()],\n-                           optgroups().as_slice()) {\n-              Ok(m) => m,\n-              Err(f) => {\n-                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\",\n-                       f.to_err_msg());\n-              }\n-            };\n-        let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None);\n-        let cfg = build_configuration(&sess);\n-        let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n-        assert!(test_items.next().is_some());\n-        assert!(test_items.next().is_none());\n-    }\n-}"}, {"sha": "ec60e2c3e6fcbf7840313bdae5e17c91c31f7af6", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -10,5 +10,391 @@\n \n pub use syntax::diagnostic;\n \n+use back::link;\n+use driver::driver::{Input, FileInput, StrInput};\n+use driver::session::{Session, build_session};\n+use middle::lint;\n+use metadata;\n+\n+use std::any::AnyRefExt;\n+use std::cmp;\n+use std::io;\n+use std::os;\n+use std::str;\n+use std::task::TaskBuilder;\n+\n+use syntax::ast;\n+use syntax::parse;\n+use syntax::diagnostic::Emitter;\n+\n+use getopts;\n+\n+\n pub mod driver;\n pub mod session;\n+pub mod config;\n+\n+\n+pub fn main_args(args: &[~str]) -> int {\n+    let owned_args = args.to_owned();\n+    monitor(proc() run_compiler(owned_args));\n+    0\n+}\n+\n+static BUG_REPORT_URL: &'static str =\n+    \"http://static.rust-lang.org/doc/master/complement-bugreport.html\";\n+\n+fn run_compiler(args: &[~str]) {\n+    let matches = match handle_options(Vec::from_slice(args)) {\n+        Some(matches) => matches,\n+        None => return\n+    };\n+\n+    let (input, input_file_path) = match matches.free.len() {\n+        0u => early_error(\"no input filename given\"),\n+        1u => {\n+            let ifile = matches.free.get(0).as_slice();\n+            if ifile == \"-\" {\n+                let contents = io::stdin().read_to_end().unwrap();\n+                let src = str::from_utf8(contents.as_slice()).unwrap().to_owned();\n+                (StrInput(src), None)\n+            } else {\n+                (FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n+            }\n+        }\n+        _ => early_error(\"multiple input filenames provided\")\n+    };\n+\n+    let sopts = config::build_session_options(&matches);\n+    let sess = build_session(sopts, input_file_path);\n+    let cfg = config::build_configuration(&sess);\n+    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n+    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n+\n+    let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+        parse_pretty(&sess, a)\n+    });\n+    match pretty {\n+        Some::<PpMode>(ppm) => {\n+            driver::pretty_print_input(sess, cfg, &input, ppm, ofile);\n+            return;\n+        }\n+        None::<PpMode> => {/* continue */ }\n+    }\n+\n+    let r = matches.opt_strs(\"Z\");\n+    if r.contains(&(\"ls\".to_owned())) {\n+        match input {\n+            FileInput(ref ifile) => {\n+                let mut stdout = io::stdout();\n+                list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n+            }\n+            StrInput(_) => {\n+                early_error(\"can not list metadata for stdin\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    if print_crate_info(&sess, &input, &odir, &ofile) {\n+        return;\n+    }\n+\n+    driver::compile_input(sess, cfg, &input, &odir, &ofile);\n+}\n+\n+pub fn version(argv0: &str) {\n+    let vers = match option_env!(\"CFG_VERSION\") {\n+        Some(vers) => vers,\n+        None => \"unknown version\"\n+    };\n+    println!(\"{} {}\", argv0, vers);\n+    println!(\"host: {}\", driver::host_triple());\n+}\n+\n+fn usage(argv0: &str) {\n+    let message = format!(\"Usage: {} [OPTIONS] INPUT\", argv0);\n+    println!(\"{}\\n\\\n+Additional help:\n+    -C help             Print codegen options\n+    -W help             Print 'lint' options and default settings\n+    -Z help             Print internal options for debugging rustc\\n\",\n+              getopts::usage(message, config::optgroups().as_slice()));\n+}\n+\n+fn describe_warnings() {\n+    println!(\"\n+Available lint options:\n+    -W <foo>           Warn about <foo>\n+    -A <foo>           Allow <foo>\n+    -D <foo>           Deny <foo>\n+    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n+\");\n+\n+    let lint_dict = lint::get_lint_dict();\n+    let mut lint_dict = lint_dict.move_iter()\n+                                 .map(|(k, v)| (v, k))\n+                                 .collect::<Vec<(lint::LintSpec, &'static str)> >();\n+    lint_dict.as_mut_slice().sort();\n+\n+    let mut max_key = 0;\n+    for &(_, name) in lint_dict.iter() {\n+        max_key = cmp::max(name.len(), max_key);\n+    }\n+    fn padded(max: uint, s: &str) -> ~str {\n+        \" \".repeat(max - s.len()) + s\n+    }\n+    println!(\"\\nAvailable lint checks:\\n\");\n+    println!(\"    {}  {:7.7s}  {}\",\n+             padded(max_key, \"name\"), \"default\", \"meaning\");\n+    println!(\"    {}  {:7.7s}  {}\\n\",\n+             padded(max_key, \"----\"), \"-------\", \"-------\");\n+    for (spec, name) in lint_dict.move_iter() {\n+        let name = name.replace(\"_\", \"-\");\n+        println!(\"    {}  {:7.7s}  {}\",\n+                 padded(max_key, name),\n+                 lint::level_to_str(spec.default),\n+                 spec.desc);\n+    }\n+    println!(\"\");\n+}\n+\n+fn describe_debug_flags() {\n+    println!(\"\\nAvailable debug options:\\n\");\n+    let r = config::debugging_opts_map();\n+    for tuple in r.iter() {\n+        match *tuple {\n+            (ref name, ref desc, _) => {\n+                println!(\"    -Z {:>20s} -- {}\", *name, *desc);\n+            }\n+        }\n+    }\n+}\n+\n+fn describe_codegen_flags() {\n+    println!(\"\\nAvailable codegen options:\\n\");\n+    let mut cg = config::basic_codegen_options();\n+    for &(name, parser, desc) in config::CG_OPTIONS.iter() {\n+        // we invoke the parser function on `None` to see if this option needs\n+        // an argument or not.\n+        let (width, extra) = if parser(&mut cg, None) {\n+            (25, \"\")\n+        } else {\n+            (21, \"=val\")\n+        };\n+        println!(\"    -C {:>width$s}{} -- {}\", name.replace(\"_\", \"-\"),\n+                 extra, desc, width=width);\n+    }\n+}\n+\n+/// Process command line options. Emits messages as appropirate.If compilation\n+/// should continue, returns a getopts::Matches object parsed from args, otherwise\n+/// returns None.\n+pub fn handle_options(mut args: Vec<~str>) -> Option<getopts::Matches> {\n+    let binary = args.shift().unwrap();\n+\n+    if args.is_empty() { usage(binary); return None; }\n+\n+    let matches =\n+        match getopts::getopts(args.as_slice(), config::optgroups().as_slice()) {\n+            Ok(m) => m,\n+            Err(f) => {\n+                early_error(f.to_err_msg());\n+            }\n+        };\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        usage(binary);\n+        return None;\n+    }\n+\n+    let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n+                                    matches.opt_strs(\"warn\").as_slice());\n+    if lint_flags.iter().any(|x| x == &\"help\".to_owned()) {\n+        describe_warnings();\n+        return None;\n+    }\n+\n+    let r = matches.opt_strs(\"Z\");\n+    if r.iter().any(|x| x == &\"help\".to_owned()) {\n+        describe_debug_flags();\n+        return None;\n+    }\n+\n+    let cg_flags = matches.opt_strs(\"C\");\n+    if cg_flags.iter().any(|x| x == &\"help\".to_owned()) {\n+        describe_codegen_flags();\n+        return None;\n+    }\n+\n+    if cg_flags.contains(&\"passes=list\".to_owned()) {\n+        unsafe { ::lib::llvm::llvm::LLVMRustPrintPasses(); }\n+        return None;\n+    }\n+\n+    if matches.opt_present(\"v\") || matches.opt_present(\"version\") {\n+        version(binary);\n+        return None;\n+    }\n+\n+    Some(matches)\n+}\n+\n+fn print_crate_info(sess: &Session,\n+                    input: &Input,\n+                    odir: &Option<Path>,\n+                    ofile: &Option<Path>)\n+                    -> bool {\n+    let (crate_id, crate_name, crate_file_name) = sess.opts.print_metas;\n+    // these nasty nested conditions are to avoid doing extra work\n+    if crate_id || crate_name || crate_file_name {\n+        let attrs = parse_crate_attrs(sess, input);\n+        let t_outputs = driver::build_output_filenames(input, odir, ofile,\n+                                                       attrs.as_slice(), sess);\n+        let id = link::find_crate_id(attrs.as_slice(), t_outputs.out_filestem);\n+\n+        if crate_id {\n+            println!(\"{}\", id.to_str());\n+        }\n+        if crate_name {\n+            println!(\"{}\", id.name);\n+        }\n+        if crate_file_name {\n+            let crate_types = driver::collect_crate_types(sess, attrs.as_slice());\n+            for &style in crate_types.iter() {\n+                let fname = link::filename_for_input(sess, style, &id,\n+                                                     &t_outputs.with_extension(\"\"));\n+                println!(\"{}\", fname.filename_display());\n+            }\n+        }\n+\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+pub enum PpMode {\n+    PpmNormal,\n+    PpmExpanded,\n+    PpmTyped,\n+    PpmIdentified,\n+    PpmExpandedIdentified\n+}\n+\n+pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n+    match name {\n+        \"normal\" => PpmNormal,\n+        \"expanded\" => PpmExpanded,\n+        \"typed\" => PpmTyped,\n+        \"expanded,identified\" => PpmExpandedIdentified,\n+        \"identified\" => PpmIdentified,\n+        _ => {\n+            sess.fatal(\"argument to `pretty` must be one of `normal`, \\\n+                        `expanded`, `typed`, `identified`, \\\n+                        or `expanded,identified`\");\n+        }\n+    }\n+}\n+\n+fn parse_crate_attrs(sess: &Session, input: &Input) ->\n+                     Vec<ast::Attribute> {\n+    let result = match *input {\n+        FileInput(ref ifile) => {\n+            parse::parse_crate_attrs_from_file(ifile,\n+                                               Vec::new(),\n+                                               &sess.parse_sess)\n+        }\n+        StrInput(ref src) => {\n+            parse::parse_crate_attrs_from_source_str(\n+                driver::anon_src().to_strbuf(),\n+                src.to_strbuf(),\n+                Vec::new(),\n+                &sess.parse_sess)\n+        }\n+    };\n+    result.move_iter().collect()\n+}\n+\n+pub fn early_error(msg: &str) -> ! {\n+    let mut emitter = diagnostic::EmitterWriter::stderr();\n+    emitter.emit(None, msg, diagnostic::Fatal);\n+    fail!(diagnostic::FatalError);\n+}\n+\n+pub fn list_metadata(sess: &Session, path: &Path,\n+                     out: &mut io::Writer) -> io::IoResult<()> {\n+    metadata::loader::list_file_metadata(\n+        config::cfg_os_to_meta_os(sess.targ_cfg.os), path, out)\n+}\n+\n+/// Run a procedure which will detect failures in the compiler and print nicer\n+/// error messages rather than just failing the test.\n+///\n+/// The diagnostic emitter yielded to the procedure should be used for reporting\n+/// errors of the compiler.\n+fn monitor(f: proc():Send) {\n+    // FIXME: This is a hack for newsched since it doesn't support split stacks.\n+    // rustc needs a lot of stack! When optimizations are disabled, it needs\n+    // even *more* stack than usual as well.\n+    #[cfg(rtopt)]\n+    static STACK_SIZE: uint = 6000000;  // 6MB\n+    #[cfg(not(rtopt))]\n+    static STACK_SIZE: uint = 20000000; // 20MB\n+\n+    let mut task_builder = TaskBuilder::new().named(\"rustc\");\n+\n+    // FIXME: Hacks on hacks. If the env is trying to override the stack size\n+    // then *don't* set it explicitly.\n+    if os::getenv(\"RUST_MIN_STACK\").is_none() {\n+        task_builder.opts.stack_size = Some(STACK_SIZE);\n+    }\n+\n+    let (tx, rx) = channel();\n+    let w = io::ChanWriter::new(tx);\n+    let mut r = io::ChanReader::new(rx);\n+\n+    match task_builder.try(proc() {\n+        io::stdio::set_stderr(box w);\n+        f()\n+    }) {\n+        Ok(()) => { /* fallthrough */ }\n+        Err(value) => {\n+            // Task failed without emitting a fatal diagnostic\n+            if !value.is::<diagnostic::FatalError>() {\n+                let mut emitter = diagnostic::EmitterWriter::stderr();\n+\n+                // a .span_bug or .bug call has already printed what\n+                // it wants to print.\n+                if !value.is::<diagnostic::ExplicitBug>() {\n+                    emitter.emit(\n+                        None,\n+                        \"unexpected failure\",\n+                        diagnostic::Bug);\n+                }\n+\n+                let xs = [\n+                    \"the compiler hit an unexpected failure path. this is a bug.\".to_owned(),\n+                    \"we would appreciate a bug report: \" + BUG_REPORT_URL,\n+                    \"run with `RUST_BACKTRACE=1` for a backtrace\".to_owned(),\n+                ];\n+                for note in xs.iter() {\n+                    emitter.emit(None, *note, diagnostic::Note)\n+                }\n+\n+                match r.read_to_str() {\n+                    Ok(s) => println!(\"{}\", s),\n+                    Err(e) => emitter.emit(None,\n+                                           format!(\"failed to read internal stderr: {}\", e),\n+                                           diagnostic::Error),\n+                }\n+            }\n+\n+            // Fail so the process returns a failure code, but don't pollute the\n+            // output with some unnecessary failure messages, we've already\n+            // printed everything that we needed to.\n+            io::stdio::set_stderr(box io::util::NullWriter);\n+            fail!();\n+        }\n+    }\n+}"}, {"sha": "24921efdb782e7c876a07fbcd6f48fbf96e29b3d", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 73, "deletions": 366, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -9,179 +9,34 @@\n // except according to those terms.\n \n \n-use back::target_strs;\n-use back;\n-use driver::driver::host_triple;\n+use driver::config;\n+use driver::driver;\n use front;\n+use metadata::cstore::CStore;\n use metadata::filesearch;\n-use metadata;\n use middle::lint;\n use util::nodemap::NodeMap;\n \n-use syntax::attr::AttrMetaMethods;\n use syntax::ast::NodeId;\n-use syntax::ast::{IntTy, UintTy};\n use syntax::codemap::Span;\n use syntax::diagnostic;\n+use syntax::parse;\n+use syntax::parse::token;\n use syntax::parse::ParseSess;\n-use syntax::{abi, ast, codemap};\n+use syntax::{ast, codemap};\n \n+use std::os;\n use std::cell::{Cell, RefCell};\n-use collections::HashSet;\n \n-pub struct Config {\n-    pub os: abi::Os,\n-    pub arch: abi::Architecture,\n-    pub target_strs: target_strs::t,\n-    pub int_type: IntTy,\n-    pub uint_type: UintTy,\n-}\n-\n-macro_rules! debugging_opts(\n-    ([ $opt:ident ] $cnt:expr ) => (\n-        pub static $opt: u64 = 1 << $cnt;\n-    );\n-    ([ $opt:ident, $($rest:ident),* ] $cnt:expr ) => (\n-        pub static $opt: u64 = 1 << $cnt;\n-        debugging_opts!([ $($rest),* ] $cnt + 1)\n-    )\n-)\n-\n-debugging_opts!(\n-    [\n-        VERBOSE,\n-        TIME_PASSES,\n-        COUNT_LLVM_INSNS,\n-        TIME_LLVM_PASSES,\n-        TRANS_STATS,\n-        ASM_COMMENTS,\n-        NO_VERIFY,\n-        BORROWCK_STATS,\n-        NO_LANDING_PADS,\n-        DEBUG_LLVM,\n-        SHOW_SPAN,\n-        COUNT_TYPE_SIZES,\n-        META_STATS,\n-        NO_OPT,\n-        GC,\n-        PRINT_LINK_ARGS,\n-        PRINT_LLVM_PASSES,\n-        LTO,\n-        AST_JSON,\n-        AST_JSON_NOEXPAND,\n-        LS\n-    ]\n-    0\n-)\n-\n-pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n-    vec!((\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n-     (\"time-passes\", \"measure time of each rustc pass\", TIME_PASSES),\n-     (\"count-llvm-insns\", \"count where LLVM \\\n-                           instrs originate\", COUNT_LLVM_INSNS),\n-     (\"time-llvm-passes\", \"measure time of each LLVM pass\",\n-      TIME_LLVM_PASSES),\n-     (\"trans-stats\", \"gather trans statistics\", TRANS_STATS),\n-     (\"asm-comments\", \"generate comments into the assembly (may change behavior)\",\n-      ASM_COMMENTS),\n-     (\"no-verify\", \"skip LLVM verification\", NO_VERIFY),\n-     (\"borrowck-stats\", \"gather borrowck statistics\",  BORROWCK_STATS),\n-     (\"no-landing-pads\", \"omit landing pads for unwinding\",\n-      NO_LANDING_PADS),\n-     (\"debug-llvm\", \"enable debug output from LLVM\", DEBUG_LLVM),\n-     (\"show-span\", \"show spans for compiler debugging\", SHOW_SPAN),\n-     (\"count-type-sizes\", \"count the sizes of aggregate types\",\n-      COUNT_TYPE_SIZES),\n-     (\"meta-stats\", \"gather metadata statistics\", META_STATS),\n-     (\"no-opt\", \"do not optimize, even if -O is passed\", NO_OPT),\n-     (\"print-link-args\", \"Print the arguments passed to the linker\",\n-      PRINT_LINK_ARGS),\n-     (\"gc\", \"Garbage collect shared data (experimental)\", GC),\n-     (\"print-llvm-passes\",\n-      \"Prints the llvm optimization passes being run\",\n-      PRINT_LLVM_PASSES),\n-     (\"lto\", \"Perform LLVM link-time optimizations\", LTO),\n-     (\"ast-json\", \"Print the AST as JSON and halt\", AST_JSON),\n-     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n-     (\"ls\", \"List the symbols defined by a library crate\", LS))\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum OptLevel {\n-    No, // -O0\n-    Less, // -O1\n-    Default, // -O2\n-    Aggressive // -O3\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum DebugInfoLevel {\n-    NoDebugInfo,\n-    LimitedDebugInfo,\n-    FullDebugInfo,\n-}\n-\n-#[deriving(Clone)]\n-pub struct Options {\n-    // The crate config requested for the session, which may be combined\n-    // with additional crate configurations during the compile process\n-    pub crate_types: Vec<CrateType>,\n-\n-    pub gc: bool,\n-    pub optimize: OptLevel,\n-    pub debuginfo: DebugInfoLevel,\n-    pub lint_opts: Vec<(lint::Lint, lint::level)> ,\n-    pub output_types: Vec<back::link::OutputType> ,\n-    // This was mutable for rustpkg, which updates search paths based on the\n-    // parsed code. It remains mutable in case its replacements wants to use\n-    // this.\n-    pub addl_lib_search_paths: RefCell<HashSet<Path>>,\n-    pub maybe_sysroot: Option<Path>,\n-    pub target_triple: ~str,\n-    // User-specified cfg meta items. The compiler itself will add additional\n-    // items to the crate config, and during parsing the entire crate config\n-    // will be added to the crate AST node.  This should not be used for\n-    // anything except building the full crate config prior to parsing.\n-    pub cfg: ast::CrateConfig,\n-    pub test: bool,\n-    pub parse_only: bool,\n-    pub no_trans: bool,\n-    pub no_analysis: bool,\n-    pub debugging_opts: u64,\n-    /// Whether to write dependency files. It's (enabled, optional filename).\n-    pub write_dependency_info: (bool, Option<Path>),\n-    /// Crate id-related things to maybe print. It's (crate_id, crate_name, crate_file_name).\n-    pub print_metas: (bool, bool, bool),\n-    pub cg: CodegenOptions,\n-}\n-\n-// The type of entry function, so\n-// users can have their own entry\n-// functions that don't start a\n-// scheduler\n-#[deriving(Eq)]\n-pub enum EntryFnType {\n-    EntryMain,\n-    EntryStart,\n-    EntryNone,\n-}\n-\n-#[deriving(Eq, Ord, Clone, TotalOrd, TotalEq, Hash)]\n-pub enum CrateType {\n-    CrateTypeExecutable,\n-    CrateTypeDylib,\n-    CrateTypeRlib,\n-    CrateTypeStaticlib,\n-}\n \n pub struct Session {\n-    pub targ_cfg: Config,\n-    pub opts: Options,\n-    pub cstore: metadata::cstore::CStore,\n+    pub targ_cfg: config::Config,\n+    pub opts: config::Options,\n+    pub cstore: CStore,\n     pub parse_sess: ParseSess,\n     // For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n-    pub entry_type: Cell<Option<EntryFnType>>,\n+    pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub macro_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<Path>,\n     // The name of the root source file of the crate, in the local file system. The path is always\n@@ -190,7 +45,7 @@ pub struct Session {\n     pub working_dir: Path,\n     pub lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, ~str)>>>,\n     pub node_id: Cell<ast::NodeId>,\n-    pub crate_types: RefCell<Vec<CrateType>>,\n+    pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub features: front::feature_gate::Features,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -289,33 +144,33 @@ impl Session {\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, format!(\"impossible case reached: {}\", msg));\n     }\n-    pub fn verbose(&self) -> bool { self.debugging_opt(VERBOSE) }\n-    pub fn time_passes(&self) -> bool { self.debugging_opt(TIME_PASSES) }\n+    pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n+    pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n     pub fn count_llvm_insns(&self) -> bool {\n-        self.debugging_opt(COUNT_LLVM_INSNS)\n+        self.debugging_opt(config::COUNT_LLVM_INSNS)\n     }\n     pub fn count_type_sizes(&self) -> bool {\n-        self.debugging_opt(COUNT_TYPE_SIZES)\n+        self.debugging_opt(config::COUNT_TYPE_SIZES)\n     }\n     pub fn time_llvm_passes(&self) -> bool {\n-        self.debugging_opt(TIME_LLVM_PASSES)\n+        self.debugging_opt(config::TIME_LLVM_PASSES)\n     }\n-    pub fn trans_stats(&self) -> bool { self.debugging_opt(TRANS_STATS) }\n-    pub fn meta_stats(&self) -> bool { self.debugging_opt(META_STATS) }\n-    pub fn asm_comments(&self) -> bool { self.debugging_opt(ASM_COMMENTS) }\n-    pub fn no_verify(&self) -> bool { self.debugging_opt(NO_VERIFY) }\n-    pub fn borrowck_stats(&self) -> bool { self.debugging_opt(BORROWCK_STATS) }\n+    pub fn trans_stats(&self) -> bool { self.debugging_opt(config::TRANS_STATS) }\n+    pub fn meta_stats(&self) -> bool { self.debugging_opt(config::META_STATS) }\n+    pub fn asm_comments(&self) -> bool { self.debugging_opt(config::ASM_COMMENTS) }\n+    pub fn no_verify(&self) -> bool { self.debugging_opt(config::NO_VERIFY) }\n+    pub fn borrowck_stats(&self) -> bool { self.debugging_opt(config::BORROWCK_STATS) }\n     pub fn print_llvm_passes(&self) -> bool {\n-        self.debugging_opt(PRINT_LLVM_PASSES)\n+        self.debugging_opt(config::PRINT_LLVM_PASSES)\n     }\n     pub fn lto(&self) -> bool {\n-        self.debugging_opt(LTO)\n+        self.debugging_opt(config::LTO)\n     }\n     pub fn no_landing_pads(&self) -> bool {\n-        self.debugging_opt(NO_LANDING_PADS)\n+        self.debugging_opt(config::NO_LANDING_PADS)\n     }\n     pub fn show_span(&self) -> bool {\n-        self.debugging_opt(SHOW_SPAN)\n+        self.debugging_opt(config::SHOW_SPAN)\n     }\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n@@ -333,215 +188,67 @@ impl Session {\n     pub fn host_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {\n         filesearch::FileSearch::new(\n             self.sysroot(),\n-            host_triple(),\n+            driver::host_triple(),\n             &self.opts.addl_lib_search_paths)\n     }\n }\n \n-/// Some reasonable defaults\n-pub fn basic_options() -> Options {\n-    Options {\n-        crate_types: Vec::new(),\n-        gc: false,\n-        optimize: No,\n-        debuginfo: NoDebugInfo,\n-        lint_opts: Vec::new(),\n-        output_types: Vec::new(),\n-        addl_lib_search_paths: RefCell::new(HashSet::new()),\n-        maybe_sysroot: None,\n-        target_triple: host_triple().to_owned(),\n-        cfg: Vec::new(),\n-        test: false,\n-        parse_only: false,\n-        no_trans: false,\n-        no_analysis: false,\n-        debugging_opts: 0,\n-        write_dependency_info: (false, None),\n-        print_metas: (false, false, false),\n-        cg: basic_codegen_options(),\n-    }\n-}\n-\n-/// Declare a macro that will define all CodegenOptions fields and parsers all\n-/// at once. The goal of this macro is to define an interface that can be\n-/// programmatically used by the option parser in order to initialize the struct\n-/// without hardcoding field names all over the place.\n-///\n-/// The goal is to invoke this macro once with the correct fields, and then this\n-/// macro generates all necessary code. The main gotcha of this macro is the\n-/// cgsetters module which is a bunch of generated code to parse an option into\n-/// its respective field in the struct. There are a few hand-written parsers for\n-/// parsing specific types of values in this module.\n-macro_rules! cgoptions(\n-    ($($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n-(\n-    #[deriving(Clone)]\n-    pub struct CodegenOptions { $(pub $opt: $t),* }\n-\n-    pub fn basic_codegen_options() -> CodegenOptions {\n-        CodegenOptions { $($opt: $init),* }\n-    }\n-\n-    pub type CodegenSetter = fn(&mut CodegenOptions, v: Option<&str>) -> bool;\n-    pub static CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n-                                      &'static str)] =\n-        &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n-\n-    mod cgsetters {\n-        use super::CodegenOptions;\n-\n-        $(\n-            pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n-                $parse(&mut cg.$opt, v)\n-            }\n-        )*\n+pub fn build_session(sopts: config::Options,\n+                     local_crate_source_file: Option<Path>)\n+                     -> Session {\n+    let codemap = codemap::CodeMap::new();\n+    let diagnostic_handler =\n+        diagnostic::default_handler();\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n-            match v {\n-                Some(..) => false,\n-                None => { *slot = true; true }\n-            }\n-        }\n-\n-        fn parse_opt_string(slot: &mut Option<~str>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(s.to_owned()); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_string(slot: &mut ~str, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.to_owned(); true },\n-                None => false,\n-            }\n-        }\n+    build_session_(sopts, local_crate_source_file, span_diagnostic_handler)\n+}\n \n-        fn parse_list(slot: &mut Vec<~str>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    for s in s.words() {\n-                        slot.push(s.to_owned());\n-                    }\n-                    true\n-                },\n-                None => false,\n-            }\n+pub fn build_session_(sopts: config::Options,\n+                      local_crate_source_file: Option<Path>,\n+                      span_diagnostic: diagnostic::SpanHandler)\n+                      -> Session {\n+    let target_cfg = config::build_target_config(&sopts);\n+    let p_s = parse::new_parse_sess_special_handler(span_diagnostic);\n+    let default_sysroot = match sopts.maybe_sysroot {\n+        Some(_) => None,\n+        None => Some(filesearch::get_or_default_sysroot())\n+    };\n+\n+    // Make the path absolute, if necessary\n+    let local_crate_source_file = local_crate_source_file.map(|path|\n+        if path.is_absolute() {\n+            path.clone()\n+        } else {\n+            os::getcwd().join(path.clone())\n         }\n+    );\n \n+    Session {\n+        targ_cfg: target_cfg,\n+        opts: sopts,\n+        cstore: CStore::new(token::get_ident_interner()),\n+        parse_sess: p_s,\n+        // For a library crate, this is always none\n+        entry_fn: RefCell::new(None),\n+        entry_type: Cell::new(None),\n+        macro_registrar_fn: Cell::new(None),\n+        default_sysroot: default_sysroot,\n+        local_crate_source_file: local_crate_source_file,\n+        working_dir: os::getcwd(),\n+        lints: RefCell::new(NodeMap::new()),\n+        node_id: Cell::new(1),\n+        crate_types: RefCell::new(Vec::new()),\n+        features: front::feature_gate::Features::new(),\n+        recursion_limit: Cell::new(64),\n     }\n-) )\n+}\n \n-cgoptions!(\n-    ar: Option<~str> = (None, parse_opt_string,\n-        \"tool to assemble archives with\"),\n-    linker: Option<~str> = (None, parse_opt_string,\n-        \"system linker to link outputs with\"),\n-    link_args: Vec<~str> = (Vec::new(), parse_list,\n-        \"extra arguments to pass to the linker (space separated)\"),\n-    target_cpu: ~str = (\"generic\".to_owned(), parse_string,\n-        \"select target processor (llc -mcpu=help for details)\"),\n-    target_feature: ~str = (\"\".to_owned(), parse_string,\n-        \"target specific attributes (llc -mattr=help for details)\"),\n-    passes: Vec<~str> = (Vec::new(), parse_list,\n-        \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<~str> = (Vec::new(), parse_list,\n-        \"a list of arguments to pass to llvm (space separated)\"),\n-    save_temps: bool = (false, parse_bool,\n-        \"save all temporary output files during compilation\"),\n-    android_cross_path: Option<~str> = (None, parse_opt_string,\n-        \"the path to the Android NDK\"),\n-    no_rpath: bool = (false, parse_bool,\n-        \"disables setting the rpath in libs/exes\"),\n-    no_prepopulate_passes: bool = (false, parse_bool,\n-        \"don't pre-populate the pass manager with a list of passes\"),\n-    no_vectorize_loops: bool = (false, parse_bool,\n-        \"don't run the loop vectorization optimization passes\"),\n-    no_vectorize_slp: bool = (false, parse_bool,\n-        \"don't run LLVM's SLP vectorization pass\"),\n-    soft_float: bool = (false, parse_bool,\n-        \"generate software floating point library calls\"),\n-    prefer_dynamic: bool = (false, parse_bool,\n-        \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool,\n-        \"use an external assembler rather than LLVM's integrated one\"),\n-    relocation_model: ~str = (\"pic\".to_owned(), parse_string,\n-         \"choose the relocation model to use (llc -relocation-model for details)\"),\n-)\n \n // Seems out of place, but it uses session, so I'm putting it here\n pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> StrBuf)\n               -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n \n-pub fn default_lib_output() -> CrateType {\n-    CrateTypeRlib\n-}\n-\n-pub fn collect_crate_types(session: &Session,\n-                           attrs: &[ast::Attribute]) -> Vec<CrateType> {\n-    // If we're generating a test executable, then ignore all other output\n-    // styles at all other locations\n-    if session.opts.test {\n-        return vec!(CrateTypeExecutable)\n-    }\n-\n-    // Only check command line flags if present. If no types are specified by\n-    // command line, then reuse the empty `base` Vec to hold the types that\n-    // will be found in crate attributes.\n-    let mut base = session.opts.crate_types.clone();\n-    if base.len() > 0 {\n-        return base\n-    } else {\n-        let iter = attrs.iter().filter_map(|a| {\n-            if a.name().equiv(&(\"crate_type\")) {\n-                match a.value_str() {\n-                    Some(ref n) if n.equiv(&(\"rlib\")) => Some(CrateTypeRlib),\n-                    Some(ref n) if n.equiv(&(\"dylib\")) => Some(CrateTypeDylib),\n-                    Some(ref n) if n.equiv(&(\"lib\")) => {\n-                        Some(default_lib_output())\n-                    }\n-                    Some(ref n) if n.equiv(&(\"staticlib\")) => {\n-                        Some(CrateTypeStaticlib)\n-                    }\n-                    Some(ref n) if n.equiv(&(\"bin\")) => Some(CrateTypeExecutable),\n-                    Some(_) => {\n-                        session.add_lint(lint::UnknownCrateType,\n-                                         ast::CRATE_NODE_ID,\n-                                         a.span,\n-                                         \"invalid `crate_type` value\".to_owned());\n-                        None\n-                    }\n-                    _ => {\n-                        session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n-                                        a.span, \"`crate_type` requires a value\".to_owned());\n-                        None\n-                    }\n-                }\n-            } else {\n-                None\n-            }\n-        });\n-        base.extend(iter);\n-        if base.len() == 0 {\n-            base.push(CrateTypeExecutable);\n-        }\n-        base.as_mut_slice().sort();\n-        base.dedup();\n-        return base;\n-    }\n-}\n-\n-pub fn sess_os_to_meta_os(os: abi::Os) -> metadata::loader::Os {\n-    use metadata::loader;\n-\n-    match os {\n-        abi::OsWin32 => loader::OsWin32,\n-        abi::OsLinux => loader::OsLinux,\n-        abi::OsAndroid => loader::OsAndroid,\n-        abi::OsMacos => loader::OsMacos,\n-        abi::OsFreebsd => loader::OsFreebsd\n-    }\n-}"}, {"sha": "da1f7bce89bc98b71184cbb6351779b82a6053ce", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use driver::session;\n+use driver::config;\n use driver::session::Session;\n \n use syntax::ast;\n@@ -87,7 +87,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n         });\n \n         let any_exe = self.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty == session::CrateTypeExecutable\n+            *ty == config::CrateTypeExecutable\n         });\n         if use_start(&krate) && any_exe {\n             vis.push(ast::ViewItem {"}, {"sha": "5b5ec2cdc2157c10458379efff542e4ed0d6f443", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 319, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -44,23 +44,6 @@ extern crate libc;\n #[phase(syntax, link)]\n extern crate log;\n \n-use back::link;\n-use driver::session;\n-use middle::lint;\n-\n-use d = driver::driver;\n-\n-use std::any::AnyRefExt;\n-use std::cmp;\n-use std::io;\n-use std::os;\n-use std::str;\n-use std::task::TaskBuilder;\n-use syntax::ast;\n-use syntax::diagnostic::Emitter;\n-use syntax::diagnostic;\n-use syntax::parse;\n-\n pub mod middle {\n     pub mod trans;\n     pub mod ty;\n@@ -136,309 +119,8 @@ pub mod lib {\n     pub mod llvmdeps;\n }\n \n-static BUG_REPORT_URL: &'static str =\n-    \"http://static.rust-lang.org/doc/master/complement-bugreport.html\";\n-\n-pub fn version(argv0: &str) {\n-    let vers = match option_env!(\"CFG_VERSION\") {\n-        Some(vers) => vers,\n-        None => \"unknown version\"\n-    };\n-    println!(\"{} {}\", argv0, vers);\n-    println!(\"host: {}\", d::host_triple());\n-}\n-\n-pub fn usage(argv0: &str) {\n-    let message = format!(\"Usage: {} [OPTIONS] INPUT\", argv0);\n-    println!(\"{}\\n\\\n-Additional help:\n-    -C help             Print codegen options\n-    -W help             Print 'lint' options and default settings\n-    -Z help             Print internal options for debugging rustc\\n\",\n-              getopts::usage(message, d::optgroups().as_slice()));\n-}\n-\n-pub fn describe_warnings() {\n-    println!(\"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n-\");\n-\n-    let lint_dict = lint::get_lint_dict();\n-    let mut lint_dict = lint_dict.move_iter()\n-                                 .map(|(k, v)| (v, k))\n-                                 .collect::<Vec<(lint::LintSpec, &'static str)> >();\n-    lint_dict.as_mut_slice().sort();\n-\n-    let mut max_key = 0;\n-    for &(_, name) in lint_dict.iter() {\n-        max_key = cmp::max(name.len(), max_key);\n-    }\n-    fn padded(max: uint, s: &str) -> ~str {\n-        \" \".repeat(max - s.len()) + s\n-    }\n-    println!(\"\\nAvailable lint checks:\\n\");\n-    println!(\"    {}  {:7.7s}  {}\",\n-             padded(max_key, \"name\"), \"default\", \"meaning\");\n-    println!(\"    {}  {:7.7s}  {}\\n\",\n-             padded(max_key, \"----\"), \"-------\", \"-------\");\n-    for (spec, name) in lint_dict.move_iter() {\n-        let name = name.replace(\"_\", \"-\");\n-        println!(\"    {}  {:7.7s}  {}\",\n-                 padded(max_key, name),\n-                 lint::level_to_str(spec.default),\n-                 spec.desc);\n-    }\n-    println!(\"\");\n-}\n-\n-pub fn describe_debug_flags() {\n-    println!(\"\\nAvailable debug options:\\n\");\n-    let r = session::debugging_opts_map();\n-    for tuple in r.iter() {\n-        match *tuple {\n-            (ref name, ref desc, _) => {\n-                println!(\"    -Z {:>20s} -- {}\", *name, *desc);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn describe_codegen_flags() {\n-    println!(\"\\nAvailable codegen options:\\n\");\n-    let mut cg = session::basic_codegen_options();\n-    for &(name, parser, desc) in session::CG_OPTIONS.iter() {\n-        // we invoke the parser function on `None` to see if this option needs\n-        // an argument or not.\n-        let (width, extra) = if parser(&mut cg, None) {\n-            (25, \"\")\n-        } else {\n-            (21, \"=val\")\n-        };\n-        println!(\"    -C {:>width$s}{} -- {}\", name.replace(\"_\", \"-\"),\n-                 extra, desc, width=width);\n-    }\n-}\n-\n-pub fn run_compiler(args: &[~str]) {\n-    let mut args = Vec::from_slice(args);\n-    let binary = args.shift().unwrap();\n-\n-    if args.is_empty() { usage(binary); return; }\n-\n-    let matches =\n-        &match getopts::getopts(args.as_slice(), d::optgroups().as_slice()) {\n-          Ok(m) => m,\n-          Err(f) => {\n-            d::early_error(f.to_err_msg());\n-          }\n-        };\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(binary);\n-        return;\n-    }\n-\n-    let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n-                                    matches.opt_strs(\"warn\").as_slice());\n-    if lint_flags.iter().any(|x| x == &\"help\".to_owned()) {\n-        describe_warnings();\n-        return;\n-    }\n-\n-    let r = matches.opt_strs(\"Z\");\n-    if r.iter().any(|x| x == &\"help\".to_owned()) {\n-        describe_debug_flags();\n-        return;\n-    }\n-\n-    let cg_flags = matches.opt_strs(\"C\");\n-    if cg_flags.iter().any(|x| x == &\"help\".to_owned()) {\n-        describe_codegen_flags();\n-        return;\n-    }\n-\n-    if cg_flags.contains(&\"passes=list\".to_owned()) {\n-        unsafe { lib::llvm::llvm::LLVMRustPrintPasses(); }\n-        return;\n-    }\n-\n-    if matches.opt_present(\"v\") || matches.opt_present(\"version\") {\n-        version(binary);\n-        return;\n-    }\n-    let (input, input_file_path) = match matches.free.len() {\n-      0u => d::early_error(\"no input filename given\"),\n-      1u => {\n-        let ifile = matches.free.get(0).as_slice();\n-        if ifile == \"-\" {\n-            let contents = io::stdin().read_to_end().unwrap();\n-            let src = str::from_utf8(contents.as_slice()).unwrap().to_owned();\n-            (d::StrInput(src), None)\n-        } else {\n-            (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n-        }\n-      }\n-      _ => d::early_error(\"multiple input filenames provided\")\n-    };\n-\n-    let sopts = d::build_session_options(matches);\n-    let sess = d::build_session(sopts, input_file_path);\n-    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n-    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n-    let cfg = d::build_configuration(&sess);\n-    let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        d::parse_pretty(&sess, a)\n-    });\n-    match pretty {\n-        Some::<d::PpMode>(ppm) => {\n-            d::pretty_print_input(sess, cfg, &input, ppm, ofile);\n-            return;\n-        }\n-        None::<d::PpMode> => {/* continue */ }\n-    }\n-\n-    if r.contains(&(\"ls\".to_owned())) {\n-        match input {\n-            d::FileInput(ref ifile) => {\n-                let mut stdout = io::stdout();\n-                d::list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n-            }\n-            d::StrInput(_) => {\n-                d::early_error(\"can not list metadata for stdin\");\n-            }\n-        }\n-        return;\n-    }\n-    let (crate_id, crate_name, crate_file_name) = sess.opts.print_metas;\n-    // these nasty nested conditions are to avoid doing extra work\n-    if crate_id || crate_name || crate_file_name {\n-        let attrs = parse_crate_attrs(&sess, &input);\n-        let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n-                                                  attrs.as_slice(), &sess);\n-        let id = link::find_crate_id(attrs.as_slice(), t_outputs.out_filestem);\n-\n-        if crate_id {\n-            println!(\"{}\", id.to_str());\n-        }\n-        if crate_name {\n-            println!(\"{}\", id.name);\n-        }\n-        if crate_file_name {\n-            let crate_types = session::collect_crate_types(&sess,\n-                                                           attrs.as_slice());\n-            for &style in crate_types.iter() {\n-                let fname = link::filename_for_input(&sess, style, &id,\n-                                                     &t_outputs.with_extension(\"\"));\n-                println!(\"{}\", fname.filename_display());\n-            }\n-        }\n-\n-        return;\n-    }\n-\n-    d::compile_input(sess, cfg, &input, &odir, &ofile);\n-}\n-\n-fn parse_crate_attrs(sess: &session::Session, input: &d::Input) ->\n-                     Vec<ast::Attribute> {\n-    let result = match *input {\n-        d::FileInput(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile,\n-                                               Vec::new(),\n-                                               &sess.parse_sess)\n-        }\n-        d::StrInput(ref src) => {\n-            parse::parse_crate_attrs_from_source_str(\n-                d::anon_src().to_strbuf(),\n-                src.to_strbuf(),\n-                Vec::new(),\n-                &sess.parse_sess)\n-        }\n-    };\n-    result.move_iter().collect()\n-}\n-\n-/// Run a procedure which will detect failures in the compiler and print nicer\n-/// error messages rather than just failing the test.\n-///\n-/// The diagnostic emitter yielded to the procedure should be used for reporting\n-/// errors of the compiler.\n-pub fn monitor(f: proc():Send) {\n-    // FIXME: This is a hack for newsched since it doesn't support split stacks.\n-    // rustc needs a lot of stack! When optimizations are disabled, it needs\n-    // even *more* stack than usual as well.\n-    #[cfg(rtopt)]\n-    static STACK_SIZE: uint = 6000000;  // 6MB\n-    #[cfg(not(rtopt))]\n-    static STACK_SIZE: uint = 20000000; // 20MB\n-\n-    let mut task_builder = TaskBuilder::new().named(\"rustc\");\n-\n-    // FIXME: Hacks on hacks. If the env is trying to override the stack size\n-    // then *don't* set it explicitly.\n-    if os::getenv(\"RUST_MIN_STACK\").is_none() {\n-        task_builder.opts.stack_size = Some(STACK_SIZE);\n-    }\n-\n-    let (tx, rx) = channel();\n-    let w = io::ChanWriter::new(tx);\n-    let mut r = io::ChanReader::new(rx);\n-\n-    match task_builder.try(proc() {\n-        io::stdio::set_stderr(box w);\n-        f()\n-    }) {\n-        Ok(()) => { /* fallthrough */ }\n-        Err(value) => {\n-            // Task failed without emitting a fatal diagnostic\n-            if !value.is::<diagnostic::FatalError>() {\n-                let mut emitter = diagnostic::EmitterWriter::stderr();\n-\n-                // a .span_bug or .bug call has already printed what\n-                // it wants to print.\n-                if !value.is::<diagnostic::ExplicitBug>() {\n-                    emitter.emit(\n-                        None,\n-                        \"unexpected failure\",\n-                        diagnostic::Bug);\n-                }\n-\n-                let xs = [\n-                    \"the compiler hit an unexpected failure path. this is a bug.\".to_owned(),\n-                    \"we would appreciate a bug report: \" + BUG_REPORT_URL,\n-                    \"run with `RUST_BACKTRACE=1` for a backtrace\".to_owned(),\n-                ];\n-                for note in xs.iter() {\n-                    emitter.emit(None, *note, diagnostic::Note)\n-                }\n-\n-                match r.read_to_str() {\n-                    Ok(s) => println!(\"{}\", s),\n-                    Err(e) => emitter.emit(None,\n-                                           format!(\"failed to read internal stderr: {}\", e),\n-                                           diagnostic::Error),\n-                }\n-            }\n-\n-            // Fail so the process returns a failure code, but don't pollute the\n-            // output with some unnecessary failure messages, we've already\n-            // printed everything that we needed to.\n-            io::stdio::set_stderr(box io::util::NullWriter);\n-            fail!();\n-        }\n-    }\n-}\n \n pub fn main() {\n-    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n+    std::os::set_exit_status(driver::main_args(std::os::args().as_slice()));\n }\n \n-pub fn main_args(args: &[~str]) -> int {\n-    let owned_args = args.to_owned();\n-    monitor(proc() run_compiler(owned_args));\n-    0\n-}"}, {"sha": "d0b14f9e1302a1a782aa7f51af8fe357ad58b57b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -15,7 +15,7 @@\n use back::link;\n use back::svh::Svh;\n use driver::session::Session;\n-use driver::{driver, session};\n+use driver::{driver, config};\n use metadata::cstore;\n use metadata::cstore::CStore;\n use metadata::decoder;\n@@ -331,7 +331,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 id_hash: id_hash,\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n-                os: session::sess_os_to_meta_os(e.sess.targ_cfg.os),\n+                os: config::cfg_os_to_meta_os(e.sess.targ_cfg.os),\n                 triple: e.sess.targ_cfg.target_strs.target_triple.as_slice(),\n                 root: root,\n                 rejected_via_hash: vec!(),\n@@ -387,7 +387,7 @@ impl<'a> CrateLoader for Loader<'a> {\n         let is_cross = target_triple != driver::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let id_hash = link::crate_id_hash(&info.crate_id);\n-        let os = driver::get_os(driver::host_triple()).unwrap();\n+        let os = config::get_os(driver::host_triple()).unwrap();\n         let mut load_ctxt = loader::Context {\n             sess: self.env.sess,\n             span: krate.span,\n@@ -397,7 +397,7 @@ impl<'a> CrateLoader for Loader<'a> {\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: driver::host_triple(),\n-            os: session::sess_os_to_meta_os(os),\n+            os: config::cfg_os_to_meta_os(os),\n             root: &None,\n             rejected_via_hash: vec!(),\n             rejected_via_triple: vec!(),\n@@ -408,7 +408,7 @@ impl<'a> CrateLoader for Loader<'a> {\n                 // try loading from target crates (only valid if there are\n                 // no syntax extensions)\n                 load_ctxt.triple = target_triple;\n-                load_ctxt.os = session::sess_os_to_meta_os(self.env.sess.targ_cfg.os);\n+                load_ctxt.os = config::cfg_os_to_meta_os(self.env.sess.targ_cfg.os);\n                 load_ctxt.filesearch = self.env.sess.target_filesearch();\n                 let lib = load_ctxt.load_library_crate();\n                 if decoder::get_macro_registrar_fn(lib.metadata.as_slice()).is_some() {"}, {"sha": "10d26922f750fe01dc224d1571c1affcf2b5fc5e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -14,7 +14,7 @@\n #![allow(non_camel_case_types)]\n \n use back::svh::Svh;\n-use driver::session;\n+use driver::config;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n@@ -1697,7 +1697,7 @@ fn encode_crate_triple(ebml_w: &mut Encoder, triple: &str) {\n \n fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n     ebml_w.start_tag(tag_dylib_dependency_formats);\n-    match ecx.tcx.dependency_formats.borrow().find(&session::CrateTypeDylib) {\n+    match ecx.tcx.dependency_formats.borrow().find(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n                 slot.map(|kind| format!(\"{}:{}\", i + 1, match kind {"}, {"sha": "ae88d64e2f0c90bfce7dacb6707fcab5a880c290", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -65,6 +65,7 @@ use collections::HashMap;\n use syntax::ast;\n \n use driver::session;\n+use driver::config;\n use metadata::cstore;\n use metadata::csearch;\n use middle::ty;\n@@ -80,7 +81,7 @@ pub type DependencyList = Vec<Option<cstore::LinkagePreference>>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = HashMap<session::CrateType, DependencyList>;\n+pub type Dependencies = HashMap<config::CrateType, DependencyList>;\n \n pub fn calculate(tcx: &ty::ctxt) {\n     let mut fmts = tcx.dependency_formats.borrow_mut();\n@@ -91,11 +92,11 @@ pub fn calculate(tcx: &ty::ctxt) {\n }\n \n fn calculate_type(sess: &session::Session,\n-                  ty: session::CrateType) -> DependencyList {\n+                  ty: config::CrateType) -> DependencyList {\n     match ty {\n         // If the global prefer_dynamic switch is turned off, first attempt\n         // static linkage (this can fail).\n-        session::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic => {\n+        config::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic => {\n             match attempt_static(sess) {\n                 Some(v) => return v,\n                 None => {}\n@@ -104,11 +105,11 @@ fn calculate_type(sess: &session::Session,\n \n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n-        session::CrateTypeRlib => return Vec::new(),\n+        config::CrateTypeRlib => return Vec::new(),\n \n         // Staticlibs must have all static dependencies. If any fail to be\n         // found, we generate some nice pretty errors.\n-        session::CrateTypeStaticlib => {\n+        config::CrateTypeStaticlib => {\n             match attempt_static(sess) {\n                 Some(v) => return v,\n                 None => {}\n@@ -123,7 +124,7 @@ fn calculate_type(sess: &session::Session,\n         }\n \n         // Everything else falls through below\n-        session::CrateTypeExecutable | session::CrateTypeDylib => {},\n+        config::CrateTypeExecutable | config::CrateTypeDylib => {},\n     }\n \n     let mut formats = HashMap::new();"}, {"sha": "1b7ed90237fd97b57ea3bd47fae57d8c2a591e05", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use driver::session;\n+use driver::config;\n use driver::session::Session;\n use syntax::ast::{Crate, Name, NodeId, Item, ItemFn};\n use syntax::ast_map;\n@@ -49,7 +49,7 @@ impl<'a> Visitor<()> for EntryContext<'a> {\n \n pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map) {\n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n-        *ty == session::CrateTypeExecutable\n+        *ty == config::CrateTypeExecutable\n     });\n     if !any_exe {\n         // No need to find a main function\n@@ -58,7 +58,7 @@ pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map\n \n     // If the user wants no main function at all, then stop here.\n     if attr::contains_name(krate.attrs.as_slice(), \"no_main\") {\n-        session.entry_type.set(Some(session::EntryNone));\n+        session.entry_type.set(Some(config::EntryNone));\n         return\n     }\n \n@@ -127,13 +127,13 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n fn configure_main(this: &mut EntryContext) {\n     if this.start_fn.is_some() {\n         *this.session.entry_fn.borrow_mut() = this.start_fn;\n-        this.session.entry_type.set(Some(session::EntryStart));\n+        this.session.entry_type.set(Some(config::EntryStart));\n     } else if this.attr_main_fn.is_some() {\n         *this.session.entry_fn.borrow_mut() = this.attr_main_fn;\n-        this.session.entry_type.set(Some(session::EntryMain));\n+        this.session.entry_type.set(Some(config::EntryMain));\n     } else if this.main_fn.is_some() {\n         *this.session.entry_fn.borrow_mut() = this.main_fn;\n-        this.session.entry_type.set(Some(session::EntryMain));\n+        this.session.entry_type.set(Some(config::EntryMain));\n     } else {\n         // No main function\n         this.session.err(\"main function not found\");"}, {"sha": "49e607f12406c2da081bb0220a0a87b9152d760d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -15,7 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use driver::session;\n+use driver::config;\n use middle::ty;\n use middle::typeck;\n use middle::privacy;\n@@ -162,7 +162,7 @@ impl<'a> ReachableContext<'a> {\n     // Creates a new reachability computation context.\n     fn new(tcx: &'a ty::ctxt) -> ReachableContext<'a> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty != session::CrateTypeExecutable\n+            *ty != config::CrateTypeExecutable\n         });\n         ReachableContext {\n             tcx: tcx,"}, {"sha": "abb9be62dd8d419aa3860d780c4f3600441a865e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -195,7 +195,7 @@\n #![allow(non_camel_case_types)]\n \n use back::abi;\n-use driver::session::FullDebugInfo;\n+use driver::config::FullDebugInfo;\n use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n use middle::const_eval;\n use middle::lang_items::{UniqStrEqFnLangItem, StrEqFnLangItem};"}, {"sha": "4562f27536fc8f47ff8e739cf8660ef12c7643e3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -27,8 +27,9 @@\n \n use back::link::{mangle_exported_name};\n use back::{link, abi};\n-use driver::session;\n-use driver::session::{Session, NoDebugInfo, FullDebugInfo};\n+use driver::config;\n+use driver::config::{NoDebugInfo, FullDebugInfo};\n+use driver::session::Session;\n use driver::driver::OutputFilenames;\n use driver::driver::{CrateAnalysis, CrateTranslation};\n use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n@@ -1724,11 +1725,11 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                            main_llfn: ValueRef) {\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n-        session::EntryMain => {\n+        config::EntryMain => {\n             create_entry_fn(ccx, main_llfn, true);\n         }\n-        session::EntryStart => create_entry_fn(ccx, main_llfn, false),\n-        session::EntryNone => {}    // Do nothing.\n+        config::EntryStart => create_entry_fn(ccx, main_llfn, false),\n+        config::EntryNone => {}    // Do nothing.\n     }\n \n     fn create_entry_fn(ccx: &CrateContext,\n@@ -2067,7 +2068,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess().crate_types.borrow().iter().any(|ty| {\n-        *ty != session::CrateTypeExecutable\n+        *ty != config::CrateTypeExecutable\n     });\n     if !any_library {\n         return Vec::new()"}, {"sha": "1f4ea02bcc6481e172952c311b16547ee8ef1891", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -11,7 +11,7 @@\n \n use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n-use driver::session::FullDebugInfo;\n+use driver::config::FullDebugInfo;\n use lib::llvm::ValueRef;\n use middle::freevars;\n use middle::lang_items::ClosureExchangeMallocFnLangItem;"}, {"sha": "777c03fa6068b7a4e31da2c8c4acb07b0c399b37", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use driver::session::NoDebugInfo;\n+use driver::config::NoDebugInfo;\n use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};"}, {"sha": "ec43e6e286f7dcadb8dd4af07ec89b15a459cc2c", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use lib::llvm::*;\n-use driver::session::FullDebugInfo;\n+use driver::config::FullDebugInfo;\n use middle::lang_items::{FailFnLangItem, FailBoundsCheckFnLangItem};\n use middle::trans::base::*;\n use middle::trans::build::*;"}, {"sha": "1e56604983f5f6d49fd824bb7cb66730e7111f6a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -125,8 +125,8 @@ is still disabled, so there is no need to do anything special with source locati\n */\n \n \n-use driver::session;\n-use driver::session::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n+use driver::config;\n+use driver::config::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n@@ -748,7 +748,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     true,\n                     scope_line as c_uint,\n                     FlagPrototyped as c_uint,\n-                    cx.sess().opts.optimize != session::No,\n+                    cx.sess().opts.optimize != config::No,\n                     llfn,\n                     template_parameters,\n                     ptr::null())\n@@ -981,7 +981,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                                 compile_unit_name,\n                                 work_dir,\n                                 producer,\n-                                cx.sess().opts.optimize != session::No,\n+                                cx.sess().opts.optimize != config::No,\n                                 flags,\n                                 0,\n                                 split_name);\n@@ -1032,7 +1032,7 @@ fn declare_local(bcx: &Block,\n                         file_metadata,\n                         loc.line as c_uint,\n                         type_metadata,\n-                        cx.sess().opts.optimize != session::No,\n+                        cx.sess().opts.optimize != config::No,\n                         0,\n                         argument_index)\n                 }"}, {"sha": "83300f6dba705ec244f23ae2cb2a3615acd3006d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -61,7 +61,7 @@ independently:\n \n #![allow(non_camel_case_types)]\n \n-use driver::session;\n+use driver::config;\n \n use middle::resolve;\n use middle::ty;\n@@ -414,9 +414,9 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n     match *tcx.sess.entry_fn.borrow() {\n         Some((id, sp)) => match tcx.sess.entry_type.get() {\n-            Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n-            Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),\n-            Some(session::EntryNone) => {}\n+            Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),\n+            Some(config::EntryStart) => check_start_fn_ty(ccx, id, sp),\n+            Some(config::EntryNone) => {}\n             None => tcx.sess.bug(\"entry function without a type\")\n         },\n         None => {}"}, {"sha": "e2684b3be693ed94bf606ff1f53f6aab50a484e8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -60,19 +60,20 @@ pub struct CrateAnalysis {\n fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n                        -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n-    use rustc::driver::driver::{FileInput, build_configuration,\n+    use rustc::driver::driver::{FileInput,\n                                 phase_1_parse_input,\n                                 phase_2_configure_and_expand,\n                                 phase_3_run_analysis_passes};\n+    use rustc::driver::config::build_configuration;\n \n     let input = FileInput(cpath.clone());\n \n-    let sessopts = driver::session::Options {\n+    let sessopts = driver::config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n-        crate_types: vec!(driver::session::CrateTypeDylib),\n+        crate_types: vec!(driver::config::CrateTypeDylib),\n         lint_opts: vec!((lint::Warnings, lint::allow)),\n-        ..rustc::driver::session::basic_options().clone()\n+        ..rustc::driver::config::basic_options().clone()\n     };\n \n \n@@ -81,9 +82,9 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n     let span_diagnostic_handler =\n         syntax::diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = driver::driver::build_session_(sessopts,\n-                                              Some(cpath.clone()),\n-                                              span_diagnostic_handler);\n+    let sess = driver::session::build_session_(sessopts,\n+                                               Some(cpath.clone()),\n+                                               span_diagnostic_handler);\n \n     let mut cfg = build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {"}, {"sha": "3e87a2539c28acc04cc3044ba399ffc78c9b5d80", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -145,7 +145,7 @@ pub fn main_args(args: &[~str]) -> int {\n         usage(args[0]);\n         return 0;\n     } else if matches.opt_present(\"version\") {\n-        rustc::version(args[0]);\n+        rustc::driver::version(args[0]);\n         return 0;\n     }\n "}, {"sha": "8a631fdcdd08cf2b16b2055f84522b140abc6e95", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ca36783c57ad8cce17f3b19fc1016202eb612c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=37ca36783c57ad8cce17f3b19fc1016202eb612c", "patch": "@@ -19,6 +19,7 @@ use std::strbuf::StrBuf;\n use collections::{HashSet, HashMap};\n use testing;\n use rustc::back::link;\n+use rustc::driver::config;\n use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n@@ -43,11 +44,11 @@ pub fn run(input: &str,\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n \n-    let sessopts = session::Options {\n+    let sessopts = config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs.clone()),\n-        crate_types: vec!(session::CrateTypeDylib),\n-        ..session::basic_options().clone()\n+        crate_types: vec!(config::CrateTypeDylib),\n+        ..config::basic_options().clone()\n     };\n \n \n@@ -56,11 +57,11 @@ pub fn run(input: &str,\n     let span_diagnostic_handler =\n     diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = driver::build_session_(sessopts,\n+    let sess = session::build_session_(sessopts,\n                                       Some(input_path.clone()),\n                                       span_diagnostic_handler);\n \n-    let mut cfg = driver::build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.move_iter().map(|cfg_| {\n         let cfg_ = token::intern_and_get_ident(cfg_);\n         @dummy_spanned(ast::MetaWord(cfg_))\n@@ -101,17 +102,17 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let test = maketest(test, cratename, loose_feature_gating);\n     let input = driver::StrInput(test);\n \n-    let sessopts = session::Options {\n+    let sessopts = config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n-        crate_types: vec!(session::CrateTypeExecutable),\n+        crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(link::OutputTypeExe),\n         no_trans: no_run,\n-        cg: session::CodegenOptions {\n+        cg: config::CodegenOptions {\n             prefer_dynamic: true,\n-            .. session::basic_codegen_options()\n+            .. config::basic_codegen_options()\n         },\n-        ..session::basic_options().clone()\n+        ..config::basic_options().clone()\n     };\n \n     // Shuffle around a few input and output handles here. We're going to pass\n@@ -142,13 +143,13 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = driver::build_session_(sessopts,\n+    let sess = session::build_session_(sessopts,\n                                       None,\n                                       span_diagnostic_handler);\n \n     let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().clone());\n-    let cfg = driver::build_configuration(&sess);\n+    let cfg = config::build_configuration(&sess);\n     driver::compile_input(sess, cfg, &input, &out, &None);\n \n     if no_run { return }"}]}