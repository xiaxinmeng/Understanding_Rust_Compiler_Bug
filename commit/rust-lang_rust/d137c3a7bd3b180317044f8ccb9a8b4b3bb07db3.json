{"sha": "d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "node_id": "C_kwDOAAsO6NoAKGQxMzdjM2E3YmQzYjE4MDMxNzA0NGY4Y2NiOWE4YjRiM2JiMDdkYjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T13:02:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T13:02:31Z"}, "message": "Auto merge of #94695 - matthiaskrgr:rollup-5pi3acz, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #94553 (add tests for #94502)\n - #94614 (Remove ordering traits from `rustc_span::hygiene::LocalExpnId`)\n - #94685 (interpret: move saturating_add/sub into (pub) helper method)\n - #94688 (Erase regions when checking for missing Copy predicates)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9d75ddcac7d9dff0929fb5db1cef5dea648f6531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d75ddcac7d9dff0929fb5db1cef5dea648f6531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "html_url": "https://github.com/rust-lang/rust/commit/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "297273c45b205820a4c055082c71677197a40b55", "url": "https://api.github.com/repos/rust-lang/rust/commits/297273c45b205820a4c055082c71677197a40b55", "html_url": "https://github.com/rust-lang/rust/commit/297273c45b205820a4c055082c71677197a40b55"}, {"sha": "c0c452ba9bd66eac4e6bee9508bbf5be273f5b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c452ba9bd66eac4e6bee9508bbf5be273f5b13", "html_url": "https://github.com/rust-lang/rust/commit/c0c452ba9bd66eac4e6bee9508bbf5be273f5b13"}], "stats": {"total": 179, "additions": 138, "deletions": 41}, "files": [{"sha": "2a74e1ce8b1b16ef5f1c3154da41ce475048362d", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -448,8 +448,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 self.mir_hir_id(),\n                                 rustc_infer::traits::ObligationCauseCode::MiscObligation,\n                             );\n-                            fulfill_cx.register_bound(&infcx, self.param_env, ty, copy_did, cause);\n-                            let errors = fulfill_cx.select_where_possible(&infcx);\n+                            fulfill_cx.register_bound(\n+                                &infcx,\n+                                self.param_env,\n+                                // Erase any region vids from the type, which may not be resolved\n+                                infcx.tcx.erase_regions(ty),\n+                                copy_did,\n+                                cause,\n+                            );\n+                            // Select all, including ambiguous predicates\n+                            let errors = fulfill_cx.select_all_or_error(&infcx);\n \n                             // Only emit suggestion if all required predicates are on generic\n                             errors"}, {"sha": "715b174491bcbc524921d082b028a17b3b1cb487", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -219,48 +219,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(&args[0])?;\n                 let r = self.read_immediate(&args[1])?;\n-                let is_add = intrinsic_name == sym::saturating_add;\n-                let (val, overflowed, _ty) = self.overflowing_binary_op(\n-                    if is_add { BinOp::Add } else { BinOp::Sub },\n+                let val = self.saturating_arith(\n+                    if intrinsic_name == sym::saturating_add { BinOp::Add } else { BinOp::Sub },\n                     &l,\n                     &r,\n                 )?;\n-                let val = if overflowed {\n-                    let size = l.layout.size;\n-                    let num_bits = size.bits();\n-                    if l.layout.abi.is_signed() {\n-                        // For signed ints the saturated value depends on the sign of the first\n-                        // term since the sign of the second term can be inferred from this and\n-                        // the fact that the operation has overflowed (if either is 0 no\n-                        // overflow can occur)\n-                        let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n-                        let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n-                        if first_term_positive {\n-                            // Negative overflow not possible since the positive first term\n-                            // can only increase an (in range) negative term for addition\n-                            // or corresponding negated positive term for subtraction\n-                            Scalar::from_uint(\n-                                (1u128 << (num_bits - 1)) - 1, // max positive\n-                                Size::from_bits(num_bits),\n-                            )\n-                        } else {\n-                            // Positive overflow not possible for similar reason\n-                            // max negative\n-                            Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n-                        }\n-                    } else {\n-                        // unsigned\n-                        if is_add {\n-                            // max unsigned\n-                            Scalar::from_uint(size.unsigned_int_max(), Size::from_bits(num_bits))\n-                        } else {\n-                            // underflow to 0\n-                            Scalar::from_uint(0u128, Size::from_bits(num_bits))\n-                        }\n-                    }\n-                } else {\n-                    val\n-                };\n                 self.write_scalar(val, dest)?;\n             }\n             sym::discriminant_value => {\n@@ -508,6 +471,49 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n     }\n \n+    pub fn saturating_arith(\n+        &self,\n+        mir_op: BinOp,\n+        l: &ImmTy<'tcx, M::PointerTag>,\n+        r: &ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        assert!(matches!(mir_op, BinOp::Add | BinOp::Sub));\n+        let (val, overflowed, _ty) = self.overflowing_binary_op(mir_op, l, r)?;\n+        Ok(if overflowed {\n+            let size = l.layout.size;\n+            let num_bits = size.bits();\n+            if l.layout.abi.is_signed() {\n+                // For signed ints the saturated value depends on the sign of the first\n+                // term since the sign of the second term can be inferred from this and\n+                // the fact that the operation has overflowed (if either is 0 no\n+                // overflow can occur)\n+                let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n+                if first_term_positive {\n+                    // Negative overflow not possible since the positive first term\n+                    // can only increase an (in range) negative term for addition\n+                    // or corresponding negated positive term for subtraction\n+                    Scalar::from_int(size.signed_int_max(), size)\n+                } else {\n+                    // Positive overflow not possible for similar reason\n+                    // max negative\n+                    Scalar::from_int(size.signed_int_min(), size)\n+                }\n+            } else {\n+                // unsigned\n+                if matches!(mir_op, BinOp::Add) {\n+                    // max unsigned\n+                    Scalar::from_uint(size.unsigned_int_max(), size)\n+                } else {\n+                    // underflow to 0\n+                    Scalar::from_uint(0u128, size)\n+                }\n+            }\n+        } else {\n+            val\n+        })\n+    }\n+\n     /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its\n     /// allocation. For integer pointers, we consider each of them their own tiny allocation of size\n     /// 0, so offset-by-0 (and only 0) is okay -- except that null cannot be offset by _any_ value."}, {"sha": "86adfa7a18cdf7f5573a7067833566d6c298c847", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -85,10 +85,17 @@ rustc_index::newtype_index! {\n     /// A unique ID associated with a macro invocation and expansion.\n     pub struct LocalExpnId {\n         ENCODABLE = custom\n+        ORD_IMPL = custom\n         DEBUG_FORMAT = \"expn{}\"\n     }\n }\n \n+// To ensure correctness of incremental compilation,\n+// `LocalExpnId` must not implement `Ord` or `PartialOrd`.\n+// See https://github.com/rust-lang/rust/issues/90317.\n+impl !Ord for LocalExpnId {}\n+impl !PartialOrd for LocalExpnId {}\n+\n /// Assert that the provided `HashStableContext` is configured with the 'default'\n /// `HashingControls`. We should always have bailed out before getting to here\n /// with a non-default mode. With this check in place, we can avoid the need"}, {"sha": "dff95283459b604afc09677cba04a6d157c2563a", "filename": "src/test/ui/borrowck/copy-suggestion-region-vid.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fborrowck%2Fcopy-suggestion-region-vid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fborrowck%2Fcopy-suggestion-region-vid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fcopy-suggestion-region-vid.rs?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -0,0 +1,17 @@\n+pub struct DataStruct();\n+\n+pub struct HelperStruct<'n> {\n+    pub helpers: [Vec<&'n i64>; 2],\n+    pub is_empty: bool,\n+}\n+\n+impl DataStruct {\n+    pub fn f(&self) -> HelperStruct {\n+        let helpers = [vec![], vec![]];\n+\n+        HelperStruct { helpers, is_empty: helpers[0].is_empty() }\n+        //~^ ERROR borrow of moved value\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f03cdd84d75f898f7ac3d541451a2963e8adff65", "filename": "src/test/ui/borrowck/copy-suggestion-region-vid.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fborrowck%2Fcopy-suggestion-region-vid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fborrowck%2Fcopy-suggestion-region-vid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fcopy-suggestion-region-vid.stderr?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -0,0 +1,14 @@\n+error[E0382]: borrow of moved value: `helpers`\n+  --> $DIR/copy-suggestion-region-vid.rs:12:43\n+   |\n+LL |         let helpers = [vec![], vec![]];\n+   |             ------- move occurs because `helpers` has type `[Vec<&i64>; 2]`, which does not implement the `Copy` trait\n+LL | \n+LL |         HelperStruct { helpers, is_empty: helpers[0].is_empty() }\n+   |                        -------            ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n+   |                        |\n+   |                        value moved here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "4b4169faadf55d5d309c5440f22932b0c6a75217", "filename": "src/test/ui/nll/lint-no-err.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fnll%2Flint-no-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fnll%2Flint-no-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flint-no-err.rs?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+// mir borrowck previously incorrectly set `tainted_by_errors`\n+// when buffering lints, which resulted in ICE later on,\n+// see #94502.\n+\n+// Errors with `nll` which is already tested in enough other tests,\n+// so we ignore it here.\n+//\n+// ignore-compare-mode-nll\n+\n+struct Repro;\n+impl Repro {\n+    fn get(&self) -> &i32 {\n+        &3\n+    }\n+\n+    fn insert(&mut self, _: i32) {}\n+}\n+\n+fn main() {\n+    let x = &0;\n+    let mut conflict = Repro;\n+    let prev = conflict.get();\n+    conflict.insert(*prev + *x);\n+    //~^ WARN cannot borrow `conflict` as mutable because it is also borrowed as immutable\n+    //~| WARN this borrowing pattern was not meant to be accepted\n+}"}, {"sha": "1e7aecfaa643d925a86de3ba0ada8c91cb10f589", "filename": "src/test/ui/nll/lint-no-err.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fnll%2Flint-no-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3/src%2Ftest%2Fui%2Fnll%2Flint-no-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flint-no-err.stderr?ref=d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "patch": "@@ -0,0 +1,17 @@\n+warning: cannot borrow `conflict` as mutable because it is also borrowed as immutable\n+  --> $DIR/lint-no-err.rs:25:5\n+   |\n+LL |     let prev = conflict.get();\n+   |                -------------- immutable borrow occurs here\n+LL |     conflict.insert(*prev + *x);\n+   |     ^^^^^^^^^^^^^^^^-----^^^^^^\n+   |     |               |\n+   |     |               immutable borrow later used here\n+   |     mutable borrow occurs here\n+   |\n+   = note: `#[warn(mutable_borrow_reservation_conflict)]` on by default\n+   = warning: this borrowing pattern was not meant to be accepted, and may become a hard error in the future\n+   = note: for more information, see issue #59159 <https://github.com/rust-lang/rust/issues/59159>\n+\n+warning: 1 warning emitted\n+"}]}