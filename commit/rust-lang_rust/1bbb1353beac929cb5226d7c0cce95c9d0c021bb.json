{"sha": "1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYmIxMzUzYmVhYzkyOWNiNTIyNmQ3YzBjY2U5NWM5ZDBjMDIxYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-17T00:55:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-17T00:55:01Z"}, "message": "Auto merge of #60898 - Centril:rollup-76o2g8a, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #60685 (Switch to SPDX 2.1 license expression)\n - #60687 (Fix .natvis visualizers.)\n - #60805 (remove compiletest's dependency on `filetime`)\n - #60862 (Get ty from local_decls instead of using Place)\n - #60873 (Parse alternative incorrect uses of await and recover)\n - #60894 (Add entry-like methods to HashSet)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9e1badb00f6b3b89b907801b66d6343e3ef806eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e1badb00f6b3b89b907801b66d6343e3ef806eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "html_url": "https://github.com/rust-lang/rust/commit/1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f53b5c42baf498b0dd8adbe59aae648a2cf6c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f53b5c42baf498b0dd8adbe59aae648a2cf6c14", "html_url": "https://github.com/rust-lang/rust/commit/4f53b5c42baf498b0dd8adbe59aae648a2cf6c14"}, {"sha": "a80a1d0e0d0d9cd47fe6070a7450fa81ccd0856d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a80a1d0e0d0d9cd47fe6070a7450fa81ccd0856d", "html_url": "https://github.com/rust-lang/rust/commit/a80a1d0e0d0d9cd47fe6070a7450fa81ccd0856d"}], "stats": {"total": 1103, "additions": 781, "deletions": 322}, "files": [{"sha": "a4f30d1ebcf82f56b6c4ac6226f8579397cf3379", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -475,7 +475,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "de30b58526a138eef01dd532d0bdb66b0dbd3a8d", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -7,11 +7,11 @@\n       <Item Name=\"[capacity]\" ExcludeView=\"simple\">buf.cap</Item>\n       <ArrayItems>\n         <Size>len</Size>\n-        <ValuePointer>buf.ptr.pointer.__0</ValuePointer>\n+        <ValuePointer>buf.ptr.pointer</ValuePointer>\n       </ArrayItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"alloc::vec_deque::VecDeque&lt;*&gt;\">\n+  <Type Name=\"alloc::collections::vec_deque::VecDeque&lt;*&gt;\">\n     <DisplayString>{{ size={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n@@ -24,19 +24,19 @@\n           <If Condition=\"i == head\">\n             <Break/>\n           </If>\n-          <Item>buf.ptr.pointer.__0 + i</Item>\n+          <Item>buf.ptr.pointer[i]</Item>\n           <Exec>i = (i + 1 == buf.cap ? 0 : i + 1)</Exec>\n         </Loop>\n       </CustomListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"alloc::linked_list::LinkedList&lt;*&gt;\">\n+  <Type Name=\"alloc::collections::linked_list::LinkedList&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <LinkedListItems>\n         <Size>len</Size>\n-        <HeadPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n-        <NextPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n+        <HeadPointer>*(alloc::collections::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n+        <NextPointer>*(alloc::collections::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n         <ValueNode>element</ValueNode>\n       </LinkedListItems>\n     </Expand>"}, {"sha": "0e703b3b9502644e30dd527895736e874ba006bb", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -1,15 +1,15 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n   <Type Name=\"core::ptr::Unique&lt;*&gt;\">\n-    <DisplayString>{{ Unique {*pointer.__0} }}</DisplayString>\n+    <DisplayString>{{ Unique {pointer} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[ptr]\">pointer.__0</Item>\n+      <Item Name=\"[ptr]\">pointer</Item>\n     </Expand>\n   </Type>\n   <Type Name=\"core::ptr::Shared&lt;*&gt;\">\n-    <DisplayString>{{ Shared {*pointer.__0} }}</DisplayString>\n+    <DisplayString>{{ Shared {pointer} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[ptr]\">pointer.__0</Item>\n+      <Item Name=\"[ptr]\">pointer</Item>\n     </Expand>\n   </Type>\n   <Type Name=\"core::option::Option&lt;*&gt;\">"}, {"sha": "3a8b139236ccad97fde64828468dc593664217eb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -97,6 +97,10 @@ pub struct LoweringContext<'a> {\n     is_generator: bool,\n     is_async_body: bool,\n \n+    /// Used to get the current `fn`'s def span to point to when using `await`\n+    /// outside of an `async fn`.\n+    current_item: Option<Span>,\n+\n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n@@ -250,6 +254,7 @@ pub fn lower_crate(\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_async_body: false,\n+        current_item: None,\n         is_in_trait_impl: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n@@ -3116,6 +3121,7 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n                     let mut lower_fn = |decl: &FnDecl| {\n                         // Note: we don't need to change the return type from `T` to\n                         // `impl Future<Output = T>` here because lower_body\n@@ -3654,6 +3660,7 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     lower_method(sig)\n                 };\n+                self.current_item = Some(i.span);\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -4270,6 +4277,7 @@ impl<'a> LoweringContext<'a> {\n                     let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n+                        this.current_item = Some(fn_decl_span);\n                         let mut is_generator = false;\n                         let body_id = this.lower_body(Some(decl), |this| {\n                             let e = this.lower_expr(body);\n@@ -5551,13 +5559,18 @@ impl<'a> LoweringContext<'a> {\n         //     }\n         // }\n         if !self.is_async_body {\n-            span_err!(\n+            let mut err = struct_span_err!(\n                 self.sess,\n                 await_span,\n                 E0728,\n                 \"`await` is only allowed inside `async` functions and blocks\"\n             );\n-            self.sess.abort_if_errors();\n+            err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+            if let Some(item_sp) = self.current_item {\n+                err.span_label(item_sp, \"this is not `async`\");\n+            }\n+            err.emit();\n+            return hir::ExprKind::Err;\n         }\n         let span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,"}, {"sha": "06d7b6c78f14bffa866945f2a03f251030180e73", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -243,9 +243,8 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = mir::Place::Base(mir::PlaceBase::Local(local)).ty(self.fx.mir,\n-                                                                           self.fx.cx.tcx());\n-                let ty = self.fx.monomorphize(&ty.ty);\n+                let ty = self.fx.mir.local_decls[local].ty;\n+                let ty = self.fx.monomorphize(&ty);\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "5d797b756213df77b41fe9edf358ea4f3625037b", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -3,7 +3,7 @@ authors = [\"The Rust Project Developers\"]\n name = \"std\"\n version = \"0.0.0\"\n build = \"build.rs\"\n-license = \"MIT/Apache-2.0\"\n+license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust.git\"\n description = \"The Rust Standard Library\"\n edition = \"2018\""}, {"sha": "403914c070780a4822f14afd9f7056c5c2251532", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -618,6 +618,62 @@ impl<T, S> HashSet<T, S>\n         self.map.get_key_value(value).map(|(k, _)| k)\n     }\n \n+    /// Inserts the given `value` into the set if it is not present, then\n+    /// returns a reference to the value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_set_entry)]\n+    ///\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// assert_eq!(set.len(), 3);\n+    /// assert_eq!(set.get_or_insert(2), &2);\n+    /// assert_eq!(set.get_or_insert(100), &100);\n+    /// assert_eq!(set.len(), 4); // 100 was inserted\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n+    pub fn get_or_insert(&mut self, value: T) -> &T {\n+        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n+        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n+        self.map.raw_entry_mut().from_key(&value).or_insert(value, ()).0\n+    }\n+\n+    /// Inserts a value computed from `f` into the set if the given `value` is\n+    /// not present, then returns a reference to the value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_set_entry)]\n+    ///\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n+    ///     .iter().map(|&pet| pet.to_owned()).collect();\n+    ///\n+    /// assert_eq!(set.len(), 3);\n+    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n+    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n+    ///     assert_eq!(value, pet);\n+    /// }\n+    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n+    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq,\n+              F: FnOnce(&Q) -> T\n+    {\n+        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n+        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n+        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (f(value), ())).0\n+    }\n+\n     /// Returns `true` if `self` has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     ///"}, {"sha": "1a2393be806d55d037f2faef1ef558bcb0fe142b", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 301, "deletions": 3, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -1,14 +1,16 @@\n use crate::ast;\n-use crate::ast::{Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n-use crate::parse::parser::PathStyle;\n+use crate::ast::{BlockCheckMode, Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n+use crate::parse::parser::{BlockMode, PathStyle, TokenType, SemiColonMode};\n use crate::parse::token;\n use crate::parse::PResult;\n use crate::parse::Parser;\n use crate::print::pprust;\n use crate::ptr::P;\n+use crate::symbol::keywords;\n use crate::ThinVec;\n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n+use log::debug;\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -223,4 +225,300 @@ impl<'a> Parser<'a> {\n             false\n         }\n     }\n+\n+    /// Consume alternative await syntaxes like `await <expr>`, `await? <expr>`, `await(<expr>)`\n+    /// and `await { <expr> }`.\n+    crate fn parse_incorrect_await_syntax(\n+        &mut self,\n+        lo: Span,\n+        await_sp: Span,\n+    ) -> PResult<'a, (Span, ExprKind)> {\n+        let is_question = self.eat(&token::Question); // Handle `await? <expr>`.\n+        let expr = if self.token == token::OpenDelim(token::Brace) {\n+            // Handle `await { <expr> }`.\n+            // This needs to be handled separatedly from the next arm to avoid\n+            // interpreting `await { <expr> }?` as `<expr>?.await`.\n+            self.parse_block_expr(\n+                None,\n+                self.span,\n+                BlockCheckMode::Default,\n+                ThinVec::new(),\n+            )\n+        } else {\n+            self.parse_expr()\n+        }.map_err(|mut err| {\n+            err.span_label(await_sp, \"while parsing this incorrect await expression\");\n+            err\n+        })?;\n+        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n+            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+        let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n+        let sp = lo.to(expr.span);\n+        let app = match expr.node {\n+            ExprKind::Try(_) => Applicability::MaybeIncorrect, // `await <expr>?`\n+            _ => Applicability::MachineApplicable,\n+        };\n+        self.struct_span_err(sp, \"incorrect use of `await`\")\n+            .span_suggestion(sp, \"`await` is a postfix operation\", suggestion, app)\n+            .emit();\n+        Ok((sp, ExprKind::Await(ast::AwaitOrigin::FieldLike, expr)))\n+    }\n+\n+    /// If encountering `future.await()`, consume and emit error.\n+    crate fn recover_from_await_method_call(&mut self) {\n+        if self.token == token::OpenDelim(token::Paren) &&\n+            self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n+        {\n+            // future.await()\n+            let lo = self.span;\n+            self.bump(); // (\n+            let sp = lo.to(self.span);\n+            self.bump(); // )\n+            self.struct_span_err(sp, \"incorrect use of `await`\")\n+                .span_suggestion(\n+                    sp,\n+                    \"`await` is not a method call, remove the parentheses\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                ).emit()\n+        }\n+    }\n+\n+    crate fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n+        self.token.is_ident() &&\n+            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n+            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n+            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n+            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n+            self.look_ahead(2, |t| t.is_ident())\n+    }\n+\n+    crate fn bad_type_ascription(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        lhs_span: Span,\n+        cur_op_span: Span,\n+        next_sp: Span,\n+        maybe_path: bool,\n+    ) {\n+        err.span_label(self.span, \"expecting a type here because of type ascription\");\n+        let cm = self.sess.source_map();\n+        let next_pos = cm.lookup_char_pos(next_sp.lo());\n+        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n+        if op_pos.line != next_pos.line {\n+            err.span_suggestion(\n+                cur_op_span,\n+                \"try using a semicolon\",\n+                \";\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            if maybe_path {\n+                err.span_suggestion(\n+                    cur_op_span,\n+                    \"maybe you meant to write a path separator here\",\n+                    \"::\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                err.note(\"type ascription is a nightly-only feature that lets \\\n+                          you annotate an expression with a type: `<expr>: <type>`\")\n+                    .span_note(\n+                        lhs_span,\n+                        \"this expression expects an ascribed type after the colon\",\n+                    )\n+                    .help(\"this might be indicative of a syntax error elsewhere\");\n+            }\n+        }\n+    }\n+\n+    crate fn recover_seq_parse_error(\n+        &mut self,\n+        delim: token::DelimToken,\n+        lo: Span,\n+        result: PResult<'a, P<Expr>>,\n+    ) -> P<Expr> {\n+        match result {\n+            Ok(x) => x,\n+            Err(mut err) => {\n+                err.emit();\n+                // recover from parse error\n+                self.consume_block(delim);\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+            }\n+        }\n+    }\n+\n+    crate fn recover_closing_delimiter(\n+        &mut self,\n+        tokens: &[token::Token],\n+        mut err: DiagnosticBuilder<'a>,\n+    ) -> PResult<'a, bool> {\n+        let mut pos = None;\n+        // we want to use the last closing delim that would apply\n+        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n+            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n+                && Some(self.span) > unmatched.unclosed_span\n+            {\n+                pos = Some(i);\n+            }\n+        }\n+        match pos {\n+            Some(pos) => {\n+                // Recover and assume that the detected unclosed delimiter was meant for\n+                // this location. Emit the diagnostic and act as if the delimiter was\n+                // present for the parser's sake.\n+\n+                 // Don't attempt to recover from this unclosed delimiter more than once.\n+                let unmatched = self.unclosed_delims.remove(pos);\n+                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n+\n+                 // We want to suggest the inclusion of the closing delimiter where it makes\n+                // the most sense, which is immediately after the last token:\n+                //\n+                //  {foo(bar {}}\n+                //      -      ^\n+                //      |      |\n+                //      |      help: `)` may belong here (FIXME: #58270)\n+                //      |\n+                //      unclosed delimiter\n+                if let Some(sp) = unmatched.unclosed_span {\n+                    err.span_label(sp, \"unclosed delimiter\");\n+                }\n+                err.span_suggestion_short(\n+                    self.sess.source_map().next_point(self.prev_span),\n+                    &format!(\"{} may belong here\", delim.to_string()),\n+                    delim.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                self.expected_tokens.clear();  // reduce errors\n+                Ok(true)\n+            }\n+            _ => Err(err),\n+        }\n+    }\n+\n+    /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n+    crate fn eat_bad_pub(&mut self) {\n+        if self.token.is_keyword(keywords::Pub) {\n+            match self.parse_visibility(false) {\n+                Ok(vis) => {\n+                    self.diagnostic()\n+                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\")\n+                        .span_label(vis.span, \"`pub` not permitted here\")\n+                        .emit();\n+                }\n+                Err(mut err) => err.emit(),\n+            }\n+        }\n+    }\n+\n+    // Eat tokens until we can be relatively sure we reached the end of the\n+    // statement. This is something of a best-effort heuristic.\n+    //\n+    // We terminate when we find an unmatched `}` (without consuming it).\n+    crate fn recover_stmt(&mut self) {\n+        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n+    }\n+\n+    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n+    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n+    // approximate - it can mean we break too early due to macros, but that\n+    // should only lead to sub-optimal recovery, not inaccurate parsing).\n+    //\n+    // If `break_on_block` is `Break`, then we will stop consuming tokens\n+    // after finding (and consuming) a brace-delimited block.\n+    crate fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n+        let mut brace_depth = 0;\n+        let mut bracket_depth = 0;\n+        let mut in_block = false;\n+        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n+               break_on_semi, break_on_block);\n+        loop {\n+            debug!(\"recover_stmt_ loop {:?}\", self.token);\n+            match self.token {\n+                token::OpenDelim(token::DelimToken::Brace) => {\n+                    brace_depth += 1;\n+                    self.bump();\n+                    if break_on_block == BlockMode::Break &&\n+                       brace_depth == 1 &&\n+                       bracket_depth == 0 {\n+                        in_block = true;\n+                    }\n+                }\n+                token::OpenDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth += 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Brace) => {\n+                    if brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n+                        break;\n+                    }\n+                    brace_depth -= 1;\n+                    self.bump();\n+                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n+                        break;\n+                    }\n+                }\n+                token::CloseDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth -= 1;\n+                    if bracket_depth < 0 {\n+                        bracket_depth = 0;\n+                    }\n+                    self.bump();\n+                }\n+                token::Eof => {\n+                    debug!(\"recover_stmt_ return - Eof\");\n+                    break;\n+                }\n+                token::Semi => {\n+                    self.bump();\n+                    if break_on_semi == SemiColonMode::Break &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n+                        break;\n+                    }\n+                }\n+                token::Comma if break_on_semi == SemiColonMode::Comma &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 =>\n+                {\n+                    debug!(\"recover_stmt_ return - Semi\");\n+                    break;\n+                }\n+                _ => {\n+                    self.bump()\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn consume_block(&mut self, delim: token::DelimToken) {\n+        let mut brace_depth = 0;\n+        loop {\n+            if self.eat(&token::OpenDelim(delim)) {\n+                brace_depth += 1;\n+            } else if self.eat(&token::CloseDelim(delim)) {\n+                if brace_depth == 0 {\n+                    return;\n+                } else {\n+                    brace_depth -= 1;\n+                    continue;\n+                }\n+            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n+                return;\n+            } else {\n+                self.bump();\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "b1c3e46adc0ecbe8d0271c7729a178bef3ba0518", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 40, "deletions": 256, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -104,14 +104,14 @@ pub enum PathStyle {\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-enum SemiColonMode {\n+crate enum SemiColonMode {\n     Break,\n     Ignore,\n     Comma,\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-enum BlockMode {\n+crate enum BlockMode {\n     Break,\n     Ignore,\n }\n@@ -389,7 +389,7 @@ crate enum TokenType {\n }\n \n impl TokenType {\n-    fn to_string(&self) -> String {\n+    crate fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_to_string(t)),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n@@ -673,56 +673,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn recover_closing_delimiter(\n-        &mut self,\n-        tokens: &[token::Token],\n-        mut err: DiagnosticBuilder<'a>,\n-    ) -> PResult<'a, bool> {\n-        let mut pos = None;\n-        // we want to use the last closing delim that would apply\n-        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n-            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.span) > unmatched.unclosed_span\n-            {\n-                pos = Some(i);\n-            }\n-        }\n-        match pos {\n-            Some(pos) => {\n-                // Recover and assume that the detected unclosed delimiter was meant for\n-                // this location. Emit the diagnostic and act as if the delimiter was\n-                // present for the parser's sake.\n-\n-                 // Don't attempt to recover from this unclosed delimiter more than once.\n-                let unmatched = self.unclosed_delims.remove(pos);\n-                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n-\n-                 // We want to suggest the inclusion of the closing delimiter where it makes\n-                // the most sense, which is immediately after the last token:\n-                //\n-                //  {foo(bar {}}\n-                //      -      ^\n-                //      |      |\n-                //      |      help: `)` may belong here (FIXME: #58270)\n-                //      |\n-                //      unclosed delimiter\n-                if let Some(sp) = unmatched.unclosed_span {\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                }\n-                err.span_suggestion_short(\n-                    self.sess.source_map().next_point(self.prev_span),\n-                    &format!(\"{} may belong here\", delim.to_string()),\n-                    delim.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n-                self.expected_tokens.clear();  // reduce errors\n-                Ok(true)\n-            }\n-            _ => Err(err),\n-        }\n-    }\n-\n     /// Expect next token to be edible or inedible token.  If edible,\n     /// then consume it; if inedible, then return without consuming\n     /// anything.  Signal a fatal error if next token is unexpected.\n@@ -2343,7 +2293,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n     }\n \n@@ -2629,14 +2579,9 @@ impl<'a> Parser<'a> {\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if self.span.rust_2018() && self.eat_keyword(keywords::Await) {\n-                    // FIXME: remove this branch when `await!` is no longer supported\n-                    // https://github.com/rust-lang/rust/issues/60610\n-                    self.expect(&token::Not)?;\n-                    self.expect(&token::OpenDelim(token::Paren))?;\n-                    let expr = self.parse_expr()?;\n-                    self.expect(&token::CloseDelim(token::Paren))?;\n-                    hi = self.prev_span;\n-                    ex = ExprKind::Await(ast::AwaitOrigin::MacroLike, expr);\n+                    let (await_hi, e_kind) = self.parse_await_macro_or_alt(lo, self.prev_span)?;\n+                    hi = await_hi;\n+                    ex = e_kind;\n                 } else if self.token.is_path_start() {\n                     let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -2701,6 +2646,31 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    /// Parse `await!(<expr>)` calls, or alternatively recover from incorrect but reasonable\n+    /// alternative syntaxes `await <expr>`, `await? <expr>`, `await(<expr>)` and\n+    /// `await { <expr> }`.\n+    fn parse_await_macro_or_alt(\n+        &mut self,\n+        lo: Span,\n+        await_sp: Span,\n+    ) -> PResult<'a, (Span, ExprKind)> {\n+        if self.token == token::Not {\n+            // Handle correct `await!(<expr>)`.\n+            // FIXME: make this an error when `await!` is no longer supported\n+            // https://github.com/rust-lang/rust/issues/60610\n+            self.expect(&token::Not)?;\n+            self.expect(&token::OpenDelim(token::Paren))?;\n+            let expr = self.parse_expr().map_err(|mut err| {\n+                err.span_label(await_sp, \"while parsing this await macro call\");\n+                err\n+            })?;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            Ok((self.prev_span, ExprKind::Await(ast::AwaitOrigin::MacroLike, expr)))\n+        } else { // Handle `await <expr>`.\n+            self.parse_incorrect_await_syntax(lo, await_sp)\n+        }\n+    }\n+\n     fn maybe_parse_struct_expr(\n         &mut self,\n         lo: Span,\n@@ -2849,10 +2819,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block or unsafe block.\n-    fn parse_block_expr(&mut self, opt_label: Option<Label>,\n-                            lo: Span, blk_mode: BlockCheckMode,\n-                            outer_attrs: ThinVec<Attribute>)\n-                            -> PResult<'a, P<Expr>> {\n+    crate fn parse_block_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        lo: Span,\n+        blk_mode: BlockCheckMode,\n+        outer_attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n         let mut attrs = outer_attrs;\n@@ -2913,6 +2886,7 @@ impl<'a> Parser<'a> {\n                 ExprKind::Await(ast::AwaitOrigin::FieldLike, self_arg),\n                 ThinVec::new(),\n             );\n+            self.recover_from_await_method_call();\n             return Ok(await_expr);\n         }\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n@@ -3151,23 +3125,6 @@ impl<'a> Parser<'a> {\n         return Ok(e);\n     }\n \n-    fn recover_seq_parse_error(\n-        &mut self,\n-        delim: token::DelimToken,\n-        lo: Span,\n-        result: PResult<'a, P<Expr>>,\n-    ) -> P<Expr> {\n-        match result {\n-            Ok(x) => x,\n-            Err(mut err) => {\n-                err.emit();\n-                // recover from parse error\n-                self.consume_block(delim);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n-            }\n-        }\n-    }\n-\n     crate fn process_potential_macro_variable(&mut self) {\n         let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n@@ -3570,58 +3527,6 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n-    fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n-        self.token.is_ident() &&\n-            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n-            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n-            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n-            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n-            self.look_ahead(2, |t| t.is_ident()) ||\n-            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n-            self.look_ahead(2, |t| t.is_ident()) ||\n-            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n-            self.look_ahead(2, |t| t.is_ident())\n-    }\n-\n-    fn bad_type_ascription(\n-        &self,\n-        err: &mut DiagnosticBuilder<'a>,\n-        lhs_span: Span,\n-        cur_op_span: Span,\n-        next_sp: Span,\n-        maybe_path: bool,\n-    ) {\n-        err.span_label(self.span, \"expecting a type here because of type ascription\");\n-        let cm = self.sess.source_map();\n-        let next_pos = cm.lookup_char_pos(next_sp.lo());\n-        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n-        if op_pos.line != next_pos.line {\n-            err.span_suggestion(\n-                cur_op_span,\n-                \"try using a semicolon\",\n-                \";\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            if maybe_path {\n-                err.span_suggestion(\n-                    cur_op_span,\n-                    \"maybe you meant to write a path separator here\",\n-                    \"::\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.note(\"type ascription is a nightly-only feature that lets \\\n-                          you annotate an expression with a type: `<expr>: <type>`\");\n-                err.span_note(\n-                    lhs_span,\n-                    \"this expression expects an ascribed type after the colon\",\n-                );\n-                err.help(\"this might be indicative of a syntax error elsewhere\");\n-            }\n-        }\n-    }\n-\n     fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n                            expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n                            -> PResult<'a, P<Expr>> {\n@@ -4903,92 +4808,6 @@ impl<'a> Parser<'a> {\n         Ok(self.parse_stmt_(true))\n     }\n \n-    // Eat tokens until we can be relatively sure we reached the end of the\n-    // statement. This is something of a best-effort heuristic.\n-    //\n-    // We terminate when we find an unmatched `}` (without consuming it).\n-    fn recover_stmt(&mut self) {\n-        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n-    }\n-\n-    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n-    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n-    // approximate - it can mean we break too early due to macros, but that\n-    // should only lead to sub-optimal recovery, not inaccurate parsing).\n-    //\n-    // If `break_on_block` is `Break`, then we will stop consuming tokens\n-    // after finding (and consuming) a brace-delimited block.\n-    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n-        let mut brace_depth = 0;\n-        let mut bracket_depth = 0;\n-        let mut in_block = false;\n-        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n-               break_on_semi, break_on_block);\n-        loop {\n-            debug!(\"recover_stmt_ loop {:?}\", self.token);\n-            match self.token {\n-                token::OpenDelim(token::DelimToken::Brace) => {\n-                    brace_depth += 1;\n-                    self.bump();\n-                    if break_on_block == BlockMode::Break &&\n-                       brace_depth == 1 &&\n-                       bracket_depth == 0 {\n-                        in_block = true;\n-                    }\n-                }\n-                token::OpenDelim(token::DelimToken::Bracket) => {\n-                    bracket_depth += 1;\n-                    self.bump();\n-                }\n-                token::CloseDelim(token::DelimToken::Brace) => {\n-                    if brace_depth == 0 {\n-                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n-                        break;\n-                    }\n-                    brace_depth -= 1;\n-                    self.bump();\n-                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n-                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n-                        break;\n-                    }\n-                }\n-                token::CloseDelim(token::DelimToken::Bracket) => {\n-                    bracket_depth -= 1;\n-                    if bracket_depth < 0 {\n-                        bracket_depth = 0;\n-                    }\n-                    self.bump();\n-                }\n-                token::Eof => {\n-                    debug!(\"recover_stmt_ return - Eof\");\n-                    break;\n-                }\n-                token::Semi => {\n-                    self.bump();\n-                    if break_on_semi == SemiColonMode::Break &&\n-                       brace_depth == 0 &&\n-                       bracket_depth == 0 {\n-                        debug!(\"recover_stmt_ return - Semi\");\n-                        break;\n-                    }\n-                }\n-                token::Comma => {\n-                    if break_on_semi == SemiColonMode::Comma &&\n-                       brace_depth == 0 &&\n-                       bracket_depth == 0 {\n-                        debug!(\"recover_stmt_ return - Semi\");\n-                        break;\n-                    } else {\n-                        self.bump();\n-                    }\n-                }\n-                _ => {\n-                    self.bump()\n-                }\n-            }\n-        }\n-    }\n-\n     fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n         self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n             e.emit();\n@@ -6892,26 +6711,6 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics), None))\n     }\n \n-    fn consume_block(&mut self, delim: token::DelimToken) {\n-        let mut brace_depth = 0;\n-        loop {\n-            if self.eat(&token::OpenDelim(delim)) {\n-                brace_depth += 1;\n-            } else if self.eat(&token::CloseDelim(delim)) {\n-                if brace_depth == 0 {\n-                    return;\n-                } else {\n-                    brace_depth -= 1;\n-                    continue;\n-                }\n-            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n-                return;\n-            } else {\n-                self.bump();\n-            }\n-        }\n-    }\n-\n     fn parse_record_struct_body(\n         &mut self,\n     ) -> PResult<'a, (Vec<StructField>, /* recovered */ bool)> {\n@@ -8609,21 +8408,6 @@ impl<'a> Parser<'a> {\n         ).emit();\n     }\n \n-    /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n-    fn eat_bad_pub(&mut self) {\n-        if self.token.is_keyword(keywords::Pub) {\n-            match self.parse_visibility(false) {\n-                Ok(vis) => {\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\");\n-                    err.span_label(vis.span, \"`pub` not permitted here\");\n-                    err.emit();\n-                }\n-                Err(mut err) => err.emit(),\n-            }\n-        }\n-    }\n-\n     /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n     /// into the generated closure so that they are dropped when the future is polled and not when\n     /// it is created."}, {"sha": "f59f1160e703e4bd82eec71654567c737666ee61", "filename": "src/test/ui/await-keyword/2018-edition-error-in-non-macro-position.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -22,6 +22,4 @@ macro_rules! await {\n     () => {}\n }\n \n-fn main() {\n-    match await { await => () } //~ ERROR expected `!`, found `{`\n-}\n+fn main() {}"}, {"sha": "c4b82b29f0270f30da71337f84f335b0be32ec1b", "filename": "src/test/ui/await-keyword/2018-edition-error-in-non-macro-position.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -68,13 +68,5 @@ help: you can escape reserved keywords to use them as identifiers\n LL | macro_rules! r#await {\n    |              ^^^^^^^\n \n-error: expected `!`, found `{`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:26:17\n-   |\n-LL |     match await { await => () }\n-   |     -----       ^ expected `!`\n-   |     |\n-   |     while parsing this match expression\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "d856869684266c1927441a514bafc40f9a27644d", "filename": "src/test/ui/await-keyword/2018-edition-error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -9,6 +9,4 @@ mod outer_mod {\n use self::outer_mod::await::await; //~ ERROR expected identifier\n     //~^ ERROR expected identifier, found reserved keyword `await`\n \n-fn main() {\n-    match await { await => () } //~ ERROR expected `!`, found `{`\n-}\n+fn main() {}"}, {"sha": "8afe5c1a36b36db695f0b341e01795a3a1f96822", "filename": "src/test/ui/await-keyword/2018-edition-error.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -38,13 +38,5 @@ help: you can escape reserved keywords to use them as identifiers\n LL | use self::outer_mod::await::r#await;\n    |                             ^^^^^^^\n \n-error: expected `!`, found `{`\n-  --> $DIR/2018-edition-error.rs:13:17\n-   |\n-LL |     match await { await => () }\n-   |     -----       ^ expected `!`\n-   |     |\n-   |     while parsing this match expression\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "e1e5bdd3d1b9277797af39dbd5626b090879200a", "filename": "src/test/ui/await-keyword/incorrect-syntax-suggestions.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -0,0 +1,111 @@\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn bar() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+async fn foo1() -> Result<(), ()> {\n+    let _ = await bar(); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo2() -> Result<(), ()> {\n+    let _ = await? bar(); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo3() -> Result<(), ()> {\n+    let _ = await bar()?; //~ ERROR incorrect use of `await`\n+    //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    Ok(())\n+}\n+async fn foo21() -> Result<(), ()> {\n+    let _ = await { bar() }; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo22() -> Result<(), ()> {\n+    let _ = await(bar()); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo23() -> Result<(), ()> {\n+    let _ = await { bar() }?; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo4() -> Result<(), ()> {\n+    let _ = (await bar())?; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo5() -> Result<(), ()> {\n+    let _ = bar().await(); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo6() -> Result<(), ()> {\n+    let _ = bar().await()?; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo7() -> Result<(), ()> {\n+    let _ = bar().await; // OK\n+    Ok(())\n+}\n+async fn foo8() -> Result<(), ()> {\n+    let _ = bar().await?; // OK\n+    Ok(())\n+}\n+fn foo9() -> Result<(), ()> {\n+    let _ = await bar(); //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo10() -> Result<(), ()> {\n+    let _ = await? bar(); //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo11() -> Result<(), ()> {\n+    let _ = await bar()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo12() -> Result<(), ()> {\n+    let _ = (await bar())?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo13() -> Result<(), ()> {\n+    let _ = bar().await(); //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo14() -> Result<(), ()> {\n+    let _ = bar().await()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo15() -> Result<(), ()> {\n+    let _ = bar().await; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    Ok(())\n+}\n+fn foo16() -> Result<(), ()> {\n+    let _ = bar().await?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    Ok(())\n+}\n+fn foo24() -> Result<(), ()> {\n+    fn foo() -> Result<(), ()> {\n+        let _ = bar().await?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+        Ok(())\n+    }\n+    foo()\n+}\n+fn foo25() -> Result<(), ()> {\n+    let foo = || {\n+        let _ = bar().await?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+        Ok(())\n+    };\n+    foo()\n+}\n+\n+fn main() {\n+    match await { await => () }\n+    //~^ ERROR expected expression, found `=>`\n+    //~| ERROR incorrect use of `await`\n+} //~ ERROR expected one of `.`, `?`, `{`, or an operator, found `}`"}, {"sha": "380da4448ad323ee0a2853215a212de245aaac21", "filename": "src/test/ui/await-keyword/incorrect-syntax-suggestions.stderr", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -0,0 +1,207 @@\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:10:13\n+   |\n+LL |     let _ = await bar();\n+   |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:14:13\n+   |\n+LL |     let _ = await? bar();\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:18:13\n+   |\n+LL |     let _ = await bar()?;\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:23:13\n+   |\n+LL |     let _ = await { bar() };\n+   |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:27:13\n+   |\n+LL |     let _ = await(bar());\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `(bar()).await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:31:13\n+   |\n+LL |     let _ = await { bar() }?;\n+   |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:35:14\n+   |\n+LL |     let _ = (await bar())?;\n+   |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:39:24\n+   |\n+LL |     let _ = bar().await();\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:43:24\n+   |\n+LL |     let _ = bar().await()?;\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:55:13\n+   |\n+LL |     let _ = await bar();\n+   |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:60:13\n+   |\n+LL |     let _ = await? bar();\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:65:13\n+   |\n+LL |     let _ = await bar()?;\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:70:14\n+   |\n+LL |     let _ = (await bar())?;\n+   |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:75:24\n+   |\n+LL |     let _ = bar().await();\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:80:24\n+   |\n+LL |     let _ = bar().await()?;\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: expected expression, found `=>`\n+  --> $DIR/incorrect-syntax-suggestions.rs:108:25\n+   |\n+LL |     match await { await => () }\n+   |                   ----- ^^ expected expression\n+   |                   |\n+   |                   while parsing this incorrect await expression\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:108:11\n+   |\n+LL |     match await { await => () }\n+   |           ^^^^^^^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ await => () }.await`\n+\n+error: expected one of `.`, `?`, `{`, or an operator, found `}`\n+  --> $DIR/incorrect-syntax-suggestions.rs:111:1\n+   |\n+LL |     match await { await => () }\n+   |     -----                      - expected one of `.`, `?`, `{`, or an operator here\n+   |     |\n+   |     while parsing this match expression\n+...\n+LL | }\n+   | ^ unexpected token\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:55:13\n+   |\n+LL | fn foo9() -> Result<(), ()> {\n+   |    ---- this is not `async`\n+LL |     let _ = await bar();\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:60:13\n+   |\n+LL | fn foo10() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = await? bar();\n+   |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:65:13\n+   |\n+LL | fn foo11() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = await bar()?;\n+   |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:70:14\n+   |\n+LL | fn foo12() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = (await bar())?;\n+   |              ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:75:13\n+   |\n+LL | fn foo13() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await();\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:80:13\n+   |\n+LL | fn foo14() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await()?;\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:85:13\n+   |\n+LL | fn foo15() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await;\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:89:13\n+   |\n+LL | fn foo16() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await?;\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:94:17\n+   |\n+LL |     fn foo() -> Result<(), ()> {\n+   |        --- this is not `async`\n+LL |         let _ = bar().await?;\n+   |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:101:17\n+   |\n+LL |     let foo = || {\n+   |               -- this is not `async`\n+LL |         let _ = bar().await?;\n+   |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/incorrect-syntax-suggestions.rs:18:19\n+   |\n+LL |     let _ = await bar()?;\n+   |                   ^^^^^^ the `?` operator cannot be applied to type `impl std::future::Future`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error: aborting due to 29 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4e525974c2c6fbd521b03e8fbedcbbfc99a5cb7d", "filename": "src/test/ui/await-keyword/post_expansion_error.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -2,7 +2,9 @@ error: expected expression, found `)`\n   --> $DIR/post_expansion_error.rs:8:12\n    |\n LL |     await!()\n-   |            ^ expected expression\n+   |     -----  ^ expected expression\n+   |     |\n+   |     while parsing this await macro call\n \n error: aborting due to previous error\n "}, {"sha": "5966edd0bf09856643ee0d12b73aa2c2104a9b9f", "filename": "src/test/ui/issues/issue-51719.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -9,3 +9,5 @@ async fn foo() {}\n fn make_generator() {\n     let _gen = || foo.await; //~ ERROR `await` is only allowed inside `async` functions and blocks\n }\n+\n+fn main() {}"}, {"sha": "c06165b24468fb97f6b655d597336d699380c0e6", "filename": "src/test/ui/issues/issue-51719.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -2,7 +2,9 @@ error[E0728]: `await` is only allowed inside `async` functions and blocks\n   --> $DIR/issue-51719.rs:10:19\n    |\n LL |     let _gen = || foo.await;\n-   |                   ^^^^^^^^^\n+   |                -- ^^^^^^^^^ only allowed inside `async` functions and blocks\n+   |                |\n+   |                this is not `async`\n \n error: aborting due to previous error\n "}, {"sha": "97b63d1590ec62bdd63511078c9a6f772860a76f", "filename": "src/test/ui/issues/issue-51751.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -1,8 +1,11 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n   --> $DIR/issue-51751.rs:11:20\n    |\n+LL | fn main() {\n+   |    ---- this is not `async`\n+LL |     let result = inc(10000);\n LL |     let finished = result.await;\n-   |                    ^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error: aborting due to previous error\n "}, {"sha": "e759ad1f35dde426d8efd05251d1728c76e5e93c", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -7,7 +7,6 @@ edition = \"2018\"\n [dependencies]\n diff = \"0.1.10\"\n env_logger = { version = \"0.5\", default-features = false }\n-filetime = \"0.2\"\n getopts = \"0.2\"\n log = \"0.4\"\n regex = \"1.0\""}, {"sha": "442e58bfd74e1408c1ff9b9e31c5ed018ff507de", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -9,14 +9,14 @@ use crate::common::CompareMode;\n use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n use crate::common::{Config, TestPaths};\n use crate::common::{DebugInfoBoth, DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n-use filetime::FileTime;\n use getopts::Options;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::time::SystemTime;\n use test::ColorConfig;\n use crate::util::logv;\n use walkdir::WalkDir;\n@@ -752,31 +752,36 @@ fn up_to_date(\n \n #[derive(Debug, PartialEq, PartialOrd, Ord, Eq)]\n struct Stamp {\n-    time: FileTime,\n+    time: SystemTime,\n     file: PathBuf,\n }\n \n impl Stamp {\n     fn from_path(p: &Path) -> Self {\n+        let time = fs::metadata(p)\n+            .and_then(|metadata| metadata.modified())\n+            .unwrap_or(SystemTime::UNIX_EPOCH);\n+\n         Stamp {\n-            time: mtime(&p),\n+            time,\n             file: p.into(),\n         }\n     }\n \n-    fn from_dir(path: &Path) -> impl Iterator<Item=Stamp> {\n+    fn from_dir(path: &Path) -> impl Iterator<Item = Stamp> {\n         WalkDir::new(path)\n             .into_iter()\n             .map(|entry| entry.unwrap())\n             .filter(|entry| entry.file_type().is_file())\n-            .map(|entry| Stamp::from_path(entry.path()))\n-    }\n-}\n+            .map(|entry| {\n+                let time = (|| -> io::Result<_> { entry.metadata()?.modified() })();\n \n-fn mtime(path: &Path) -> FileTime {\n-    fs::metadata(path)\n-        .map(|f| FileTime::from_last_modification_time(&f))\n-        .unwrap_or_else(|_| FileTime::zero())\n+                Stamp {\n+                    time: time.unwrap_or(SystemTime::UNIX_EPOCH),\n+                    file: entry.path().into(),\n+                }\n+            })\n+    }\n }\n \n fn make_test_name("}, {"sha": "1e4deee6bf12e0ebbb3332443ba7bae0897b32fa", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -9,7 +9,6 @@ use crate::common::{Config, TestPaths};\n use crate::common::{Incremental, MirOpt, RunMake, Ui, JsDocTest, Assembly};\n use diff;\n use crate::errors::{self, Error, ErrorKind};\n-use filetime::FileTime;\n use crate::header::TestProps;\n use crate::json;\n use regex::{Captures, Regex};\n@@ -3029,7 +3028,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn check_mir_test_timestamp(&self, test_name: &str, output_file: &Path) {\n-        let t = |file| FileTime::from_last_modification_time(&fs::metadata(file).unwrap());\n+        let t = |file| fs::metadata(file).unwrap().modified().unwrap();\n         let source_file = &self.testpaths.file;\n         let output_time = t(output_file);\n         let source_time = t(source_file);"}, {"sha": "d2b1a7bac60aed0e5cb2326c497370dcb88d4797", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -2,7 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustbook\"\n version = \"0.1.0\"\n-license = \"MIT/Apache-2.0\"\n+license = \"MIT OR Apache-2.0\"\n edition = \"2018\"\n \n [dependencies]"}, {"sha": "05df1fddc7f1c9125b109b8bae41a3e675082174", "filename": "src/tools/rustc-std-workspace-alloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustc-std-workspace-alloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustc-std-workspace-alloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-std-workspace-alloc%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -2,7 +2,7 @@\n name = \"rustc-std-workspace-alloc\"\n version = \"1.0.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n-license = 'MIT/Apache-2.0'\n+license = 'MIT OR Apache-2.0'\n description = \"\"\"\n Hack for the compiler's own build system\n \"\"\""}, {"sha": "38ca56a557be6c2935c62da934f57bf8f3552d62", "filename": "src/tools/rustc-std-workspace-core/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustc-std-workspace-core%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustc-std-workspace-core%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-std-workspace-core%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -2,7 +2,7 @@\n name = \"rustc-std-workspace-core\"\n version = \"1.0.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n-license = 'MIT/Apache-2.0'\n+license = 'MIT OR Apache-2.0'\n description = \"\"\"\n Hack for the compiler's own build system\n \"\"\""}, {"sha": "290c4481c005e552871a44230bd4a898b66effc7", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -2,7 +2,7 @@\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n-license = 'MIT/Apache-2.0'\n+license = 'MIT OR Apache-2.0'\n description = \"\"\"\n Hack for the compiler's own build system\n \"\"\""}, {"sha": "e43e4e6c7cb5ae691bae64ea69a47e5df0a7cb05", "filename": "src/tools/unstable-book-gen/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Funstable-book-gen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1bbb1353beac929cb5226d7c0cce95c9d0c021bb/src%2Ftools%2Funstable-book-gen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funstable-book-gen%2FCargo.toml?ref=1bbb1353beac929cb5226d7c0cce95c9d0c021bb", "patch": "@@ -3,7 +3,7 @@ authors = [\"est31 <MTest31@outlook.com>\",\n            \"The Rust Project Developers\"]\n name = \"unstable-book-gen\"\n version = \"0.1.0\"\n-license = \"MIT/Apache-2.0\"\n+license = \"MIT OR Apache-2.0\"\n edition = \"2018\"\n \n [dependencies]"}]}