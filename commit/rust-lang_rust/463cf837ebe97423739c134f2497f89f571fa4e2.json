{"sha": "463cf837ebe97423739c134f2497f89f571fa4e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2M2NmODM3ZWJlOTc0MjM3MzljMTM0ZjI0OTdmODlmNTcxZmE0ZTI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-13T12:42:29Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-13T15:20:31Z"}, "message": "rustc: Teach trans::alt.rs about exhaustive alts\n\nCloses #1971", "tree": {"sha": "91fee4a107e27ca59da3fe67e532123f65b4202c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91fee4a107e27ca59da3fe67e532123f65b4202c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/463cf837ebe97423739c134f2497f89f571fa4e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/463cf837ebe97423739c134f2497f89f571fa4e2", "html_url": "https://github.com/rust-lang/rust/commit/463cf837ebe97423739c134f2497f89f571fa4e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/463cf837ebe97423739c134f2497f89f571fa4e2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15985277b98e53014b52c1e243eefcfb0335089f", "url": "https://api.github.com/repos/rust-lang/rust/commits/15985277b98e53014b52c1e243eefcfb0335089f", "html_url": "https://github.com/rust-lang/rust/commit/15985277b98e53014b52c1e243eefcfb0335089f"}], "stats": {"total": 154, "additions": 82, "deletions": 72}, "files": [{"sha": "e0b069403d4bd27802d00ee712c901ac9c16868b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 80, "deletions": 70, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/463cf837ebe97423739c134f2497f89f571fa4e2/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463cf837ebe97423739c134f2497f89f571fa4e2/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=463cf837ebe97423739c134f2497f89f571fa4e2", "patch": "@@ -354,10 +354,10 @@ fn pick_col(m: match) -> uint {\n     ret best_col;\n }\n \n-fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n-                    &exits: [exit_node]) {\n+fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n+                    chk: option<mk_fail>, &exits: [exit_node]) {\n     let bcx = bcx, tcx = bcx.tcx(), dm = tcx.def_map;\n-    if m.len() == 0u { Br(bcx, f()); ret; }\n+    if m.len() == 0u { Br(bcx, option::get(chk)()); ret; }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n         alt data.guard {\n@@ -372,7 +372,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n                 trans_temp_expr(bcx, e)\n             };\n             bcx = with_cond(guard_cx, Not(guard_cx, val)) {|bcx|\n-                compile_submatch(bcx, vec::tail(m), vals, f, exits);\n+                compile_submatch(bcx, vec::tail(m), vals, chk, exits);\n                 bcx\n             };\n           }\n@@ -389,13 +389,10 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n     let val = vals[col];\n     let m = if has_nested_bindings(m, col) {\n                 expand_nested_bindings(m, col, val)\n-            } else {\n-                m\n-            };\n+            } else { m };\n \n-    let vals_left =\n-        vec::slice(vals, 0u, col) +\n-            vec::slice(vals, col + 1u, vals.len());\n+    let vals_left = vec::slice(vals, 0u, col) +\n+        vec::slice(vals, col + 1u, vals.len());\n     let ccx = bcx.fcx.ccx;\n     let pat_id = 0;\n     for br: match_branch in m {\n@@ -417,7 +414,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n             bcx = r.bcx;\n         }\n         compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n-                         rec_vals + vals_left, f, exits);\n+                         rec_vals + vals_left, chk, exits);\n         ret;\n     }\n \n@@ -435,7 +432,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n             i += 1u;\n         }\n         compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n-                         tup_vals + vals_left, f, exits);\n+                         tup_vals + vals_left, chk, exits);\n         ret;\n     }\n \n@@ -444,14 +441,14 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n         let box = Load(bcx, val);\n         let unboxed = GEPi(bcx, box, [0, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]\n-                         + vals_left, f, exits);\n+                         + vals_left, chk, exits);\n         ret;\n     }\n \n     if any_uniq_pat(m, col) {\n         let unboxed = Load(bcx, val);\n         compile_submatch(bcx, enter_uniq(dm, m, col, val),\n-                         [unboxed] + vals_left, f, exits);\n+                         [unboxed] + vals_left, chk, exits);\n         ret;\n     }\n \n@@ -499,42 +496,48 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n         Switch(bcx, test_val, else_cx.llbb, opts.len())\n     } else { C_int(ccx, 0) }; // Placeholder for when not using a switch\n \n-     // Compile subtrees for each option\n-    for opt: opt in opts {\n-        let opt_cx = sub_block(bcx, \"match_case\");\n-        alt kind {\n-          single { Br(bcx, opt_cx.llbb); }\n-          switch {\n-            let res = trans_opt(bcx, opt);\n-            alt check res {\n-              single_result(r) {\n-                llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n-                bcx = r.bcx;\n-              }\n-            }\n-          }\n-          compare {\n-            let t = node_id_type(bcx, pat_id);\n-            let {bcx: after_cx, val: matches} =\n-                with_scope_result(bcx, \"compare_scope\") {|bcx|\n-                alt trans_opt(bcx, opt) {\n-                  single_result({bcx, val}) {\n-                    trans_compare(bcx, ast::eq, test_val, t, val, t)\n-                  }\n-                  range_result({val: vbegin, _}, {bcx, val: vend}) {\n-                    let {bcx, val: ge} = trans_compare(bcx, ast::ge, test_val,\n-                                                       t, vbegin, t);\n-                    let {bcx, val: le} = trans_compare(bcx, ast::le, test_val,\n-                                                       t, vend, t);\n-                    {bcx: bcx, val: And(bcx, ge, le)}\n+    let defaults = enter_default(dm, m, col, val);\n+    let exhaustive = option::is_none(chk) && defaults.len() == 0u;\n+    let len = opts.len(), i = 0u;\n+    // Compile subtrees for each option\n+    for opt in opts {\n+        i += 1u;\n+        let opt_cx = else_cx;\n+        if !exhaustive || i < len {\n+            opt_cx = sub_block(bcx, \"match_case\");\n+            alt kind {\n+              single { Br(bcx, opt_cx.llbb); }\n+              switch {\n+                alt check trans_opt(bcx, opt) {\n+                  single_result(r) {\n+                    llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n+                    bcx = r.bcx;\n                   }\n                 }\n-            };\n-            bcx = sub_block(after_cx, \"compare_next\");\n-            CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n-          }\n-          _ { }\n-        }\n+              }\n+              compare {\n+                let t = node_id_type(bcx, pat_id);\n+                let {bcx: after_cx, val: matches} =\n+                    with_scope_result(bcx, \"compare_scope\") {|bcx|\n+                    alt trans_opt(bcx, opt) {\n+                      single_result({bcx, val}) {\n+                        trans_compare(bcx, ast::eq, test_val, t, val, t)\n+                      }\n+                      range_result({val: vbegin, _}, {bcx, val: vend}) {\n+                        let {bcx, val: ge} = trans_compare(\n+                            bcx, ast::ge, test_val, t, vbegin, t);\n+                        let {bcx, val: le} = trans_compare(\n+                            bcx, ast::le, test_val, t, vend, t);\n+                        {bcx: bcx, val: And(bcx, ge, le)}\n+                      }\n+                    }\n+                };\n+                bcx = sub_block(after_cx, \"compare_next\");\n+                CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+              }\n+              _ { }\n+            }\n+        } else if kind == compare { Br(bcx, else_cx.llbb); }\n         let size = 0u;\n         let unpacked = [];\n         alt opt {\n@@ -547,14 +550,15 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n           lit(_) | range(_, _) { }\n         }\n         compile_submatch(opt_cx, enter_opt(tcx, m, opt, col, size, val),\n-                         unpacked + vals_left, f, exits);\n+                         unpacked + vals_left, chk, exits);\n     }\n \n-    // Compile the fall-through case\n-    if kind == compare { Br(bcx, else_cx.llbb); }\n-    if kind != single {\n-        compile_submatch(else_cx, enter_default(dm, m, col, val), vals_left,\n-                         f, exits);\n+    // Compile the fall-through case, if any\n+    if !exhaustive {\n+        if kind == compare { Br(bcx, else_cx.llbb); }\n+        if kind != single {\n+            compile_submatch(else_cx, defaults, vals_left, chk, exits);\n+        }\n     }\n }\n \n@@ -605,12 +609,14 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n }\n \n fn trans_alt(bcx: block, expr: @ast::expr, arms: [ast::arm],\n-             dest: dest) -> block {\n-    with_scope(bcx, \"alt\") {|bcx| trans_alt_inner(bcx, expr, arms, dest)}\n+             mode: ast::alt_mode, dest: dest) -> block {\n+    with_scope(bcx, \"alt\") {|bcx|\n+        trans_alt_inner(bcx, expr, arms, mode, dest)\n+    }\n }\n \n fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n-                   dest: dest) -> block {\n+                   mode: ast::alt_mode, dest: dest) -> block {\n     let bcx = scope_cx, tcx = bcx.tcx();\n     let bodies = [], match = [];\n \n@@ -630,22 +636,26 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n         }\n     }\n \n-    // Cached fail-on-fallthrough block\n-    let fail_cx = @mutable none;\n-    fn mk_fail(bcx: block, sp: span,\n-               done: @mutable option<BasicBlockRef>) -> BasicBlockRef {\n-        alt *done { some(bb) { ret bb; } _ { } }\n-        let fail_cx = sub_block(bcx, \"case_fallthrough\");\n-        trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n-        *done = some(fail_cx.llbb);\n-        ret fail_cx.llbb;\n-    }\n-\n+    let mk_fail = alt mode {\n+      ast::alt_check {\n+        // Cached fail-on-fallthrough block\n+        let fail_cx = @mutable none;\n+        fn mk_fail(bcx: block, sp: span,\n+                   done: @mutable option<BasicBlockRef>) -> BasicBlockRef {\n+            alt *done { some(bb) { ret bb; } _ { } }\n+            let fail_cx = sub_block(bcx, \"case_fallthrough\");\n+            trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n+            *done = some(fail_cx.llbb);\n+            ret fail_cx.llbb;\n+        }\n+        some(bind mk_fail(scope_cx, expr.span, fail_cx))\n+      }\n+      ast::alt_exhaustive { none }\n+    };\n     let exit_map = [];\n     let t = node_id_type(bcx, expr.id);\n     let {bcx, val: spilled} = spill_if_immediate(bcx, val, t);\n-    compile_submatch(bcx, match, [spilled],\n-                     bind mk_fail(scope_cx, expr.span, fail_cx), exit_map);\n+    compile_submatch(bcx, match, [spilled], mk_fail, exit_map);\n \n     let arm_cxs = [], arm_dests = [], i = 0u;\n     for a in arms {"}, {"sha": "c66401e8b6ee1b33ee6aabc3f533d6b032926e61", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/463cf837ebe97423739c134f2497f89f571fa4e2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463cf837ebe97423739c134f2497f89f571fa4e2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=463cf837ebe97423739c134f2497f89f571fa4e2", "patch": "@@ -3141,8 +3141,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n         ret trans_if(bcx, cond, thn, els, dest);\n       }\n-      ast::expr_alt(expr, arms, _) {\n-        ret alt::trans_alt(bcx, expr, arms, dest);\n+      ast::expr_alt(expr, arms, mode) {\n+        ret alt::trans_alt(bcx, expr, arms, mode, dest);\n       }\n       ast::expr_block(blk) {\n         ret with_scope(bcx, \"block-expr body\") {|bcx|"}]}