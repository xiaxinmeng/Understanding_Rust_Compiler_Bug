{"sha": "914421495835380b96e0016763fda6eff31a8179", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNDQyMTQ5NTgzNTM4MGI5NmUwMDE2NzYzZmRhNmVmZjMxYTgxNzk=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-04-15T14:11:32Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-04-21T22:14:58Z"}, "message": "complete_import: add new import resolver infrastructure with some hardcoded importable name.\nChanges complete_scope to support that.", "tree": {"sha": "86b348e13e9272f1320aad0416313c0f6f93a19c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86b348e13e9272f1320aad0416313c0f6f93a19c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/914421495835380b96e0016763fda6eff31a8179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/914421495835380b96e0016763fda6eff31a8179", "html_url": "https://github.com/rust-lang/rust/commit/914421495835380b96e0016763fda6eff31a8179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/914421495835380b96e0016763fda6eff31a8179/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf0eff2e332f46eda4fcecb043854c9c0d710e4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0eff2e332f46eda4fcecb043854c9c0d710e4e", "html_url": "https://github.com/rust-lang/rust/commit/cf0eff2e332f46eda4fcecb043854c9c0d710e4e"}], "stats": {"total": 166, "additions": 155, "deletions": 11}, "files": [{"sha": "173c004cdc87e0083df210f60db6d89531270ec3", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=914421495835380b96e0016763fda6eff31a8179", "patch": "@@ -98,7 +98,7 @@ mod inline_local_variable;\n mod replace_if_let_with_match;\n mod split_import;\n mod remove_dbg;\n-mod auto_import;\n+pub mod auto_import;\n mod add_missing_impl_members;\n \n fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {"}, {"sha": "f156e3f0771e5a54aec14fca228bc6e991a2e503", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=914421495835380b96e0016763fda6eff31a8179", "patch": "@@ -52,7 +52,7 @@ use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n     source_id::{FileAstId, AstId},\n-    resolve::Resolver,\n+    resolve::Resolver, resolve::ImportResolver,\n };\n \n pub use self::{"}, {"sha": "0f866e6c293c9716afa694448eb0409438585ac2", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=914421495835380b96e0016763fda6eff31a8179", "patch": "@@ -3,6 +3,8 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n+use ra_syntax::SmolStr;\n+\n use crate::{\n     ModuleDef,\n     code_model_api::Crate,\n@@ -12,15 +14,25 @@ use crate::{\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n+<<<<<<< HEAD\n     path::Path,\n     Trait\n+=======\n+    path::Path, Trait,\n+>>>>>>> complete_import: add new import resolver infrastructure with some hardcoded importable name.\n };\n \n #[derive(Debug, Clone, Default)]\n pub(crate) struct Resolver {\n     scopes: Vec<Scope>,\n }\n \n+#[derive(Debug, Clone, Default)]\n+pub(crate) struct ImportResolver {\n+    // todo: use fst crate or something like that\n+    dummy_names: Vec<(SmolStr, Vec<SmolStr>)>,\n+}\n+\n // FIXME how to store these best\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n@@ -309,3 +321,56 @@ impl Scope {\n         }\n     }\n }\n+\n+impl ImportResolver {\n+    pub(crate) fn new() -> Self {\n+        let dummy_names = vec![\n+            (SmolStr::new(\"fmt\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\")]),\n+            (SmolStr::new(\"io\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"io\")]),\n+            (SmolStr::new(\"iter\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"iter\")]),\n+            (SmolStr::new(\"hash\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\")]),\n+            (\n+                SmolStr::new(\"Debug\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\"), SmolStr::new(\"Debug\")],\n+            ),\n+            (\n+                SmolStr::new(\"Display\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\"), SmolStr::new(\"Display\")],\n+            ),\n+            (\n+                SmolStr::new(\"Hash\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\"), SmolStr::new(\"Hash\")],\n+            ),\n+            (\n+                SmolStr::new(\"Hasher\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\"), SmolStr::new(\"Hasher\")],\n+            ),\n+            (\n+                SmolStr::new(\"Iterator\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"iter\"), SmolStr::new(\"Iterator\")],\n+            ),\n+        ];\n+\n+        ImportResolver { dummy_names }\n+    }\n+\n+    // Returns a map of importable items filtered by name.\n+    // The map associates item name with its full path.\n+    // todo: should return Resolutions\n+    pub(crate) fn all_names(\n+        &self,\n+        _db: &impl HirDatabase,\n+        name: &Name,\n+    ) -> FxHashMap<SmolStr, Vec<SmolStr>> {\n+        let name = name.to_smolstr();\n+        if name.len() > 1 {\n+            self.dummy_names\n+                .iter()\n+                .filter(|(n, _)| n.as_str().contains(name.as_str()))\n+                .cloned()\n+                .collect()\n+        } else {\n+            FxHashMap::default()\n+        }\n+    }\n+}"}, {"sha": "a6f0ab2896b9c3cced101d84c3be868f9dde976c", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=914421495835380b96e0016763fda6eff31a8179", "patch": "@@ -14,14 +14,19 @@ use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     algo::find_node_at_offset,\n     SyntaxKind::*,\n+    SmolStr,\n };\n \n use crate::{\n     HirDatabase, Function, Struct, Enum, Const, Static, Either, DefWithBody, PerNs, Name,\n+<<<<<<< HEAD\n     AsName, Module, HirFileId, Crate, Trait, Resolver, Ty,\n+=======\n+    AsName, Module, HirFileId, Crate, Trait, Resolver, ImportResolver,\n+>>>>>>> complete_import: add new import resolver infrastructure with some hardcoded importable name.\n     expr::{BodySourceMap, scope::{ScopeId, ExprScopes}},\n     ids::LocationCtx,\n-    expr, AstId\n+    expr, AstId,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -170,6 +175,7 @@ fn def_with_body_from_child_node(\n #[derive(Debug)]\n pub struct SourceAnalyzer {\n     resolver: Resolver,\n+    import_resolver: ImportResolver,\n     body_source_map: Option<Arc<BodySourceMap>>,\n     infer: Option<Arc<crate::ty::InferenceResult>>,\n     scopes: Option<Arc<crate::expr::ExprScopes>>,\n@@ -217,6 +223,7 @@ impl SourceAnalyzer {\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n         let def_with_body = def_with_body_from_child_node(db, file_id, node);\n+        let import_resolver = ImportResolver::new();\n         if let Some(def) = def_with_body {\n             let source_map = def.body_source_map(db);\n             let scopes = db.expr_scopes(def);\n@@ -227,6 +234,7 @@ impl SourceAnalyzer {\n             let resolver = expr::resolver_for_scope(def.body(db), db, scope);\n             SourceAnalyzer {\n                 resolver,\n+                import_resolver,\n                 body_source_map: Some(source_map),\n                 infer: Some(def.infer(db)),\n                 scopes: Some(scopes),\n@@ -237,6 +245,7 @@ impl SourceAnalyzer {\n                     .ancestors()\n                     .find_map(|node| try_get_resolver_for_node(db, file_id, node))\n                     .unwrap_or_default(),\n+                import_resolver,\n                 body_source_map: None,\n                 infer: None,\n                 scopes: None,\n@@ -323,6 +332,14 @@ impl SourceAnalyzer {\n         self.resolver.all_names(db)\n     }\n \n+    pub fn all_import_names(\n+        &self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+    ) -> FxHashMap<SmolStr, Vec<SmolStr>> {\n+        self.import_resolver.all_names(db, name)\n+    }\n+\n     pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n         // FIXME: at least, this should work with any DefWithBody, but ideally\n         // this should be hir-based altogether"}, {"sha": "63d4758230dad5f69c1f8e497a72c377fb51d794", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=914421495835380b96e0016763fda6eff31a8179", "patch": "@@ -1,12 +1,57 @@\n-use crate::completion::{Completions, CompletionContext};\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::SmolStr;\n+use ra_assists::auto_import;\n+use crate::completion::{CompletionItem, Completions, CompletionKind, CompletionContext};\n \n pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path {\n-        return;\n+    if ctx.is_trivial_path {\n+        let names = ctx.analyzer.all_names(ctx.db);\n+        names.into_iter().for_each(|(name, res)| acc.add_resolution(ctx, name.to_string(), &res));\n     }\n-    let names = ctx.analyzer.all_names(ctx.db);\n \n-    names.into_iter().for_each(|(name, res)| acc.add_resolution(ctx, name.to_string(), &res));\n+    if let Some(name) = ctx.path_ident.as_ref() {\n+        let import_names = ctx.analyzer.all_import_names(ctx.db, name);\n+        import_names.into_iter().for_each(|(name, path)| {\n+            let edit = {\n+                let mut builder = TextEditBuilder::default();\n+                builder.replace(ctx.source_range(), name.to_string());\n+                auto_import::auto_import_text_edit(\n+                    ctx.token.parent(),\n+                    ctx.token.parent(),\n+                    &path,\n+                    &mut builder,\n+                );\n+                builder.finish()\n+            };\n+            CompletionItem::new(\n+                CompletionKind::Reference,\n+                ctx.source_range(),\n+                build_import_label(&name, &path),\n+            )\n+            .text_edit(edit)\n+            .add_to(acc)\n+        });\n+    }\n+}\n+\n+fn build_import_label(name: &str, path: &Vec<SmolStr>) -> String {\n+    let mut buf = String::with_capacity(64);\n+    buf.push_str(name);\n+    buf.push_str(\" (\");\n+    fmt_import_path(path, &mut buf);\n+    buf.push_str(\")\");\n+    buf\n+}\n+\n+fn fmt_import_path(path: &Vec<SmolStr>, buf: &mut String) {\n+    let mut segments = path.iter();\n+    if let Some(s) = segments.next() {\n+        buf.push_str(&s);\n+    }\n+    for s in segments {\n+        buf.push_str(\"::\");\n+        buf.push_str(&s);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "ca8f7900d12f7b81e5c9a4d943d8d17beb416374", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914421495835380b96e0016763fda6eff31a8179/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=914421495835380b96e0016763fda6eff31a8179", "patch": "@@ -5,10 +5,10 @@ use ra_syntax::{\n     algo::{find_token_at_offset, find_covering_element, find_node_at_offset},\n     SyntaxKind::*,\n };\n-use hir::source_binder;\n \n-use crate::{db, FilePosition};\n+use hir::{ source_binder, Name };\n \n+use crate::{db, FilePosition};\n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n@@ -27,8 +27,10 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_pat_binding: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n-    /// If not a trivial, path, the prefix (qualifier).\n+    /// If not a trivial path, the prefix (qualifier).\n     pub(super) path_prefix: Option<hir::Path>,\n+    /// If a trivial path, the ident.\n+    pub(super) path_ident: Option<Name>,\n     pub(super) after_if: bool,\n     /// `true` if we are a statement or a last expr in the block.\n     pub(super) can_be_stmt: bool,\n@@ -63,6 +65,7 @@ impl<'a> CompletionContext<'a> {\n             is_pat_binding: false,\n             is_trivial_path: false,\n             path_prefix: None,\n+            path_ident: None,\n             after_if: false,\n             can_be_stmt: false,\n             is_new_item: false,\n@@ -83,6 +86,18 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn fill(&mut self, original_file: &'a SourceFile, offset: TextUnit) {\n+        // We heed the original NameRef before the \"intellijRulezz\" hack\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(original_file.syntax(), offset)\n+        {\n+            if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+                if let Some(path) = hir::Path::from_ast(path) {\n+                    if let Some(ident) = path.as_ident() {\n+                        self.path_ident = Some(ident.clone());\n+                    }\n+                }\n+            }\n+        }\n+\n         // Insert a fake ident to get a valid parse tree. We will use this file\n         // to determine context, though the original_file will be used for\n         // actual completion.\n@@ -151,6 +166,7 @@ impl<'a> CompletionContext<'a> {\n             Some(it) => it,\n             None => return,\n         };\n+\n         if let Some(segment) = ast::PathSegment::cast(parent) {\n             let path = segment.parent_path();\n             self.is_call = path\n@@ -167,6 +183,7 @@ impl<'a> CompletionContext<'a> {\n                     return;\n                 }\n             }\n+\n             if path.qualifier().is_none() {\n                 self.is_trivial_path = true;\n "}]}