{"sha": "3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNGQyNjBiZmMzOWQxMTVmYzJiZjY5YzU3OTZjYzljMjk4OTI2M2E=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-11-27T22:48:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-27T22:48:40Z"}, "message": "Merge pull request #2194 from topecongiro/use-cargo_metadata\n\nUse cargo_metadata", "tree": {"sha": "9c6895bc96dde65a803462a9652fc347ffc21e75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c6895bc96dde65a803462a9652fc347ffc21e75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaHJZICRBK7hj4Ov3rIwAAdHIIACBae0xRRR7N6d0PT5IHVeIX\ntcP3oKsP8tQfVYoR2lud3WKQvAVblgGW9Ola9oQ/hv30sPLJ++mYA4pSPa642trO\n/IFkjiJwUVPrsc63p1gu7vxQFZV6ykDMMbARQ8iE5Z7wHPvP+PlwHJ9wuQ5GzLf4\nbtY6HsN47hY/LKPeTAR6OL0kiP6nmFkT+Jbf6kR9PcqJTtTzteKluA98xumPGihq\nw0XC7L8s8bgwP2va7+HWi5W3mFZIchi50FvAsbeyaUfuETo8aeTDMpkDOfyo3KwA\nNYuVtB6V7LJ9jzxTYJPUID4jCgicDv2GZA1ptUgVUQ5IFHB9BalTEtNyVEssYWM=\n=HCgQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 9c6895bc96dde65a803462a9652fc347ffc21e75\nparent 458eade4a87ea77617f040c9840f0bad1cca351f\nparent f06cb340220d2f594d4532c409183e78ea30bdfe\nauthor Nick Cameron <nrc@ncameron.org> 1511822920 +1300\ncommitter GitHub <noreply@github.com> 1511822920 +1300\n\nMerge pull request #2194 from topecongiro/use-cargo_metadata\n\nUse cargo_metadata"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "html_url": "https://github.com/rust-lang/rust/commit/3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "458eade4a87ea77617f040c9840f0bad1cca351f", "url": "https://api.github.com/repos/rust-lang/rust/commits/458eade4a87ea77617f040c9840f0bad1cca351f", "html_url": "https://github.com/rust-lang/rust/commit/458eade4a87ea77617f040c9840f0bad1cca351f"}, {"sha": "f06cb340220d2f594d4532c409183e78ea30bdfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f06cb340220d2f594d4532c409183e78ea30bdfe", "html_url": "https://github.com/rust-lang/rust/commit/f06cb340220d2f594d4532c409183e78ea30bdfe"}], "stats": {"total": 424, "additions": 234, "deletions": 190}, "files": [{"sha": "160fce6e55d229175760195f7d744b0215b57f0a", "filename": "Cargo.lock", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "patch": "@@ -6,6 +6,60 @@ dependencies = [\n  \"memchr 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace-sys 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"backtrace-sys\"\n+version = \"0.1.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cc 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.3.2\"\n+source = \"git+https://github.com/topecongiro/cargo_metadata#1f5bbc43efdad3dfc1d622174b976982cf1f8bf8\"\n+dependencies = [\n+ \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"dbghelp-sys\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"derive-new\"\n version = \"0.5.0\"\n@@ -34,6 +88,14 @@ dependencies = [\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"getopts\"\n version = \"0.2.15\"\n@@ -103,10 +165,16 @@ name = \"regex-syntax\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustfmt-nightly\"\n version = \"0.2.16\"\n dependencies = [\n+ \"cargo_metadata 0.3.2 (git+https://github.com/topecongiro/cargo_metadata)\",\n  \"derive-new 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -125,6 +193,20 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"semver\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"serde\"\n version = \"1.0.21\"\n@@ -252,10 +334,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n+\"checksum backtrace 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8709cc7ec06f6f0ae6c2c7e12f6ed41540781f72b488d83734978295ceae182e\"\n+\"checksum backtrace-sys 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44585761d6161b0f57afc49482ab6bd067e4edef48c12a152c237eb0203f7661\"\n+\"checksum cargo_metadata 0.3.2 (git+https://github.com/topecongiro/cargo_metadata)\" = \"<none>\"\n+\"checksum cc 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9b13a57efd6b30ecd6598ebdb302cca617930b5470647570468a65d12ef9719\"\n+\"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n+\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n \"checksum derive-new 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"415f627ab054041c3eb748c2e1da0ef751989f5f0c386b63a098e545854a98ba\"\n \"checksum diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n \"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n+\"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"65922871abd2f101a2eb0eaebadc66668e54a87ad9c3dd82520b5f86ede5eff9\"\n \"checksum itoa 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8324a32baf01e2ae060e9de58ed0bc2320c9a2833491ee36cd3b4c414de4db8c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n@@ -267,6 +356,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n+\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n+\"checksum semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bee2bc909ab2d8d60dab26e8cad85b25d795b14603a0dcb627b78b9d30b6454b\"\n+\"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 1.0.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6eda663e865517ee783b0891a3f6eb3a253e0b0dabb46418969ee9635beadd9e\"\n \"checksum serde_derive 1.0.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"652bc323d694dc925829725ec6c890156d8e70ae5202919869cb00fe2eff3788\"\n \"checksum serde_derive_internals 0.17.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"32f1926285523b2db55df263d2aa4eb69ddcfa7a7eade6430323637866b513ab\""}, {"sha": "64036396dc907d61b491d419c4fdb378140b3e12", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "patch": "@@ -44,6 +44,7 @@ log = \"0.3\"\n env_logger = \"0.4\"\n getopts = \"0.2\"\n derive-new = \"0.5\"\n+cargo_metadata = { git = \"https://github.com/topecongiro/cargo_metadata\" }\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2.11\""}, {"sha": "001ffb649c64d4b4949545f125b032964f398eef", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 140, "deletions": 189, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "patch": "@@ -13,19 +13,21 @@\n #![cfg(not(test))]\n #![deny(warnings)]\n \n+extern crate cargo_metadata;\n extern crate getopts;\n extern crate serde_json as json;\n \n use std::env;\n+use std::fs;\n+use std::hash::{Hash, Hasher};\n use std::io::{self, Write};\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::{Command, ExitStatus};\n use std::str;\n use std::collections::HashSet;\n use std::iter::FromIterator;\n \n use getopts::{Matches, Options};\n-use json::Value;\n \n fn main() {\n     let exit_status = execute();\n@@ -50,13 +52,16 @@ fn execute() -> i32 {\n     opts.optflag(\"\", \"all\", \"format all packages (only usable in workspaces)\");\n \n     // If there is any invalid argument passed to `cargo fmt`, return without formatting.\n-    if let Some(arg) = env::args()\n-        .skip(2)\n-        .take_while(|a| a != \"--\")\n-        .find(|a| !a.starts_with('-'))\n-    {\n-        print_usage_to_stderr(&opts, &format!(\"Invalid argument: `{}`.\", arg));\n-        return failure;\n+    let mut is_package_arg = false;\n+    for arg in env::args().skip(2).take_while(|a| a != \"--\") {\n+        if arg.starts_with(\"-\") {\n+            is_package_arg = arg.starts_with(\"--package\");\n+        } else if !is_package_arg {\n+            print_usage_to_stderr(&opts, &format!(\"Invalid argument: `{}`.\", arg));\n+            return failure;\n+        } else {\n+            is_package_arg = false;\n+        }\n     }\n \n     let matches = match opts.parse(env::args().skip(1).take_while(|a| a != \"--\")) {\n@@ -82,9 +87,9 @@ fn execute() -> i32 {\n         return success;\n     }\n \n-    let workspace_hitlist = WorkspaceHitlist::from_matches(&matches);\n+    let strategy = CargoFmtStrategy::from_matches(&matches);\n \n-    match format_crate(verbosity, &workspace_hitlist) {\n+    match format_crate(verbosity, &strategy) {\n         Err(e) => {\n             print_usage_to_stderr(&opts, &e.to_string());\n             failure\n@@ -125,17 +130,16 @@ pub enum Verbosity {\n \n fn format_crate(\n     verbosity: Verbosity,\n-    workspace_hitlist: &WorkspaceHitlist,\n+    strategy: &CargoFmtStrategy,\n ) -> Result<ExitStatus, io::Error> {\n-    let targets = get_targets(workspace_hitlist)?;\n+    let targets = get_targets(strategy)?;\n \n     // Currently only bin and lib files get formatted\n     let files: Vec<_> = targets\n         .into_iter()\n-        .filter(|t| t.kind.should_format())\n         .inspect(|t| {\n             if verbosity == Verbosity::Verbose {\n-                println!(\"[{:?}] {:?}\", t.kind, t.path)\n+                println!(\"[{}] {:?}\", t.kind, t.path)\n             }\n         })\n         .map(|t| t.path)\n@@ -149,226 +153,160 @@ fn get_fmt_args() -> Vec<String> {\n     env::args().skip_while(|a| a != \"--\").skip(1).collect()\n }\n \n+/// Target uses a `path` field for equality and hashing.\n #[derive(Debug)]\n-enum TargetKind {\n-    Lib,         // dylib, staticlib, lib\n-    Bin,         // bin\n-    Example,     // example file\n-    Test,        // test file\n-    Bench,       // bench file\n-    CustomBuild, // build script\n-    ProcMacro,   // a proc macro implementation\n-    Other,       // plugin,...\n+pub struct Target {\n+    /// A path to the main source file of the target.\n+    path: PathBuf,\n+    /// A kind of target (e.g. lib, bin, example, ...).\n+    kind: String,\n }\n \n-impl TargetKind {\n-    fn should_format(&self) -> bool {\n-        match *self {\n-            TargetKind::Lib\n-            | TargetKind::Bin\n-            | TargetKind::Example\n-            | TargetKind::Test\n-            | TargetKind::Bench\n-            | TargetKind::CustomBuild\n-            | TargetKind::ProcMacro => true,\n-            _ => false,\n+impl Target {\n+    pub fn from_target(target: &cargo_metadata::Target) -> Self {\n+        let path = PathBuf::from(&target.src_path);\n+        let canonicalized = fs::canonicalize(&path).unwrap_or(path);\n+\n+        Target {\n+            path: canonicalized,\n+            kind: target.kind[0].clone(),\n         }\n     }\n }\n \n-#[derive(Debug)]\n-pub struct Target {\n-    path: PathBuf,\n-    kind: TargetKind,\n+impl PartialEq for Target {\n+    fn eq(&self, other: &Target) -> bool {\n+        self.path == other.path\n+    }\n }\n \n-impl Target {\n-    pub fn from_json(json_val: &Value) -> Option<Self> {\n-        let jtarget = json_val.as_object()?;\n-        let path = PathBuf::from(jtarget.get(\"src_path\")?.as_str()?);\n-        let kinds = jtarget.get(\"kind\")?.as_array()?;\n-        let kind = match kinds[0].as_str()? {\n-            \"bin\" => TargetKind::Bin,\n-            \"lib\" | \"dylib\" | \"staticlib\" | \"cdylib\" | \"rlib\" => TargetKind::Lib,\n-            \"test\" => TargetKind::Test,\n-            \"example\" => TargetKind::Example,\n-            \"bench\" => TargetKind::Bench,\n-            \"custom-build\" => TargetKind::CustomBuild,\n-            \"proc-macro\" => TargetKind::ProcMacro,\n-            _ => TargetKind::Other,\n-        };\n-\n-        Some(Target {\n-            path: path,\n-            kind: kind,\n-        })\n+impl Eq for Target {}\n+\n+impl Hash for Target {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.path.hash(state);\n     }\n }\n \n #[derive(Debug, PartialEq, Eq)]\n-pub enum WorkspaceHitlist {\n+pub enum CargoFmtStrategy {\n+    /// Format every packages and dependencies.\n     All,\n+    /// Format pacakges that are specified by the command line argument.\n     Some(Vec<String>),\n-    None,\n+    /// Format the root packages only.\n+    Root,\n }\n \n-impl WorkspaceHitlist {\n-    pub fn get_some(&self) -> Option<&[String]> {\n-        if let WorkspaceHitlist::Some(ref hitlist) = *self {\n-            Some(hitlist)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn from_matches(matches: &Matches) -> WorkspaceHitlist {\n+impl CargoFmtStrategy {\n+    pub fn from_matches(matches: &Matches) -> CargoFmtStrategy {\n         match (matches.opt_present(\"all\"), matches.opt_present(\"p\")) {\n-            (false, false) => WorkspaceHitlist::None,\n-            (true, _) => WorkspaceHitlist::All,\n-            (false, true) => WorkspaceHitlist::Some(matches.opt_strs(\"p\")),\n+            (false, false) => CargoFmtStrategy::Root,\n+            (true, _) => CargoFmtStrategy::All,\n+            (false, true) => CargoFmtStrategy::Some(matches.opt_strs(\"p\")),\n         }\n     }\n }\n \n-fn get_cargo_metadata_from_utf8(v: &[u8]) -> Option<Value> {\n-    json::from_str(str::from_utf8(v).ok()?).ok()\n-}\n-\n-fn get_json_array_with<'a>(v: &'a Value, key: &str) -> Option<&'a Vec<Value>> {\n-    v.as_object()?.get(key)?.as_array()\n-}\n-\n-// `cargo metadata --no-deps | jq '.[\"packages\"]'`\n-fn get_packages(v: &[u8]) -> Result<Vec<Value>, io::Error> {\n-    let e = io::Error::new(\n-        io::ErrorKind::NotFound,\n-        String::from(\"`cargo metadata` returned json without a 'packages' key\"),\n-    );\n-    match get_cargo_metadata_from_utf8(v) {\n-        Some(ref json_obj) => get_json_array_with(json_obj, \"packages\").cloned().ok_or(e),\n-        None => Err(e),\n-    }\n-}\n+/// Based on the specified CargoFmtStrategy, returns a set of main source files.\n+fn get_targets(strategy: &CargoFmtStrategy) -> Result<HashSet<Target>, io::Error> {\n+    let mut targets = HashSet::new();\n \n-fn extract_target_from_package(package: &Value) -> Option<Vec<Target>> {\n-    let jtargets = get_json_array_with(package, \"targets\")?;\n-    let mut targets: Vec<Target> = vec![];\n-    for jtarget in jtargets {\n-        targets.push(Target::from_json(jtarget)?);\n+    match *strategy {\n+        CargoFmtStrategy::Root => get_targets_root_only(&mut targets)?,\n+        CargoFmtStrategy::All => get_targets_recursive(None, &mut targets, &mut HashSet::new())?,\n+        CargoFmtStrategy::Some(ref hitlist) => get_targets_with_hitlist(hitlist, &mut targets)?,\n     }\n-    Some(targets)\n-}\n \n-fn filter_packages_with_hitlist(\n-    packages: Vec<Value>,\n-    workspace_hitlist: &WorkspaceHitlist,\n-) -> Result<Vec<Value>, &String> {\n-    let some_hitlist: Option<HashSet<&String>> =\n-        workspace_hitlist.get_some().map(HashSet::from_iter);\n-    if some_hitlist.is_none() {\n-        return Ok(packages);\n-    }\n-    let mut hitlist = some_hitlist.unwrap();\n-    let members: Vec<Value> = packages\n-        .into_iter()\n-        .filter(|member| {\n-            member\n-                .as_object()\n-                .and_then(|member_obj| {\n-                    member_obj\n-                        .get(\"name\")\n-                        .and_then(Value::as_str)\n-                        .map(|member_name| {\n-                            hitlist.take(&member_name.to_string()).is_some()\n-                        })\n-                })\n-                .unwrap_or(false)\n-        })\n-        .collect();\n-    if hitlist.is_empty() {\n-        Ok(members)\n+    if targets.is_empty() {\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            format!(\"Failed to find targets\"),\n+        ))\n     } else {\n-        Err(hitlist.into_iter().next().unwrap())\n+        Ok(targets)\n     }\n }\n \n-fn get_dependencies_from_package(package: &Value) -> Option<Vec<PathBuf>> {\n-    let jdependencies = get_json_array_with(package, \"dependencies\")?;\n-    let root_path = env::current_dir().ok()?;\n-    let mut dependencies: Vec<PathBuf> = vec![];\n-    for jdep in jdependencies {\n-        let jdependency = jdep.as_object()?;\n-        if !jdependency.get(\"source\")?.is_null() {\n-            continue;\n+fn get_targets_root_only(targets: &mut HashSet<Target>) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n+\n+    for package in metadata.packages {\n+        for target in package.targets {\n+            if target.name == package.name {\n+                targets.insert(Target::from_target(&target));\n+            }\n         }\n-        let name = jdependency.get(\"name\")?.as_str()?;\n-        let mut path = root_path.clone();\n-        path.push(&name);\n-        dependencies.push(path);\n     }\n-    Some(dependencies)\n+\n+    Ok(())\n }\n \n-// Returns a vector of local dependencies under this crate\n-fn get_path_to_local_dependencies(packages: &[Value]) -> Vec<PathBuf> {\n-    let mut local_dependencies: Vec<PathBuf> = vec![];\n-    for package in packages {\n-        if let Some(mut d) = get_dependencies_from_package(package) {\n-            local_dependencies.append(&mut d);\n+fn get_targets_recursive(\n+    manifest_path: Option<&Path>,\n+    mut targets: &mut HashSet<Target>,\n+    visited: &mut HashSet<String>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path)?;\n+\n+    for package in metadata.packages {\n+        add_targets(&package.targets, &mut targets);\n+\n+        // Look for local dependencies.\n+        for dependency in package.dependencies {\n+            if dependency.source.is_some() || visited.contains(&dependency.name) {\n+                continue;\n+            }\n+\n+            let mut manifest_path = PathBuf::from(&package.manifest_path);\n+\n+            manifest_path.pop();\n+            manifest_path.push(&dependency.name);\n+            manifest_path.push(\"Cargo.toml\");\n+\n+            if manifest_path.exists() {\n+                visited.insert(dependency.name);\n+                get_targets_recursive(Some(&manifest_path), &mut targets, visited)?;\n+            }\n         }\n     }\n-    local_dependencies\n+\n+    Ok(())\n }\n \n-// Returns a vector of all compile targets of a crate\n-fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, io::Error> {\n-    let output = Command::new(\"cargo\")\n-        .args(&[\"metadata\", \"--no-deps\", \"--format-version=1\"])\n-        .output()?;\n-    if output.status.success() {\n-        let cur_dir = env::current_dir()?;\n-        let mut targets: Vec<Target> = vec![];\n-        let packages = get_packages(&output.stdout)?;\n-\n-        // If we can find any local dependencies, we will try to get targets from those as well.\n-        if *workspace_hitlist == WorkspaceHitlist::All {\n-            for path in get_path_to_local_dependencies(&packages) {\n-                match env::set_current_dir(path) {\n-                    Ok(..) => match get_targets(workspace_hitlist) {\n-                        Ok(ref mut t) => targets.append(t),\n-                        Err(..) => continue,\n-                    },\n-                    Err(..) => continue,\n-                }\n-            }\n-        }\n+fn get_targets_with_hitlist(\n+    hitlist: &[String],\n+    targets: &mut HashSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n \n-        env::set_current_dir(cur_dir)?;\n-        match filter_packages_with_hitlist(packages, workspace_hitlist) {\n-            Ok(packages) => {\n-                for package in packages {\n-                    if let Some(mut target) = extract_target_from_package(&package) {\n-                        targets.append(&mut target);\n-                    }\n-                }\n-                Ok(targets)\n-            }\n-            Err(package) => {\n-                // Mimick cargo of only outputting one <package> spec.\n-                Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    format!(\"package `{}` is not a member of the workspace\", package),\n-                ))\n+    let mut workspace_hitlist: HashSet<&String> = HashSet::from_iter(hitlist);\n+\n+    for package in metadata.packages {\n+        for target in package.targets {\n+            if workspace_hitlist.remove(&target.name) {\n+                targets.insert(Target::from_target(&target));\n             }\n         }\n+    }\n+\n+    if workspace_hitlist.is_empty() {\n+        Ok(())\n     } else {\n+        let package = workspace_hitlist.iter().next().unwrap();\n         Err(io::Error::new(\n-            io::ErrorKind::NotFound,\n-            str::from_utf8(&output.stderr).unwrap(),\n+            io::ErrorKind::InvalidInput,\n+            format!(\"package `{}` is not a member of the workspace\", package),\n         ))\n     }\n }\n \n+fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut HashSet<Target>) {\n+    for target in target_paths {\n+        targets.insert(Target::from_target(&target));\n+    }\n+}\n+\n fn format_files(\n     files: &[PathBuf],\n     fmt_args: &[String],\n@@ -379,6 +317,7 @@ fn format_files(\n     } else {\n         std::process::Stdio::inherit()\n     };\n+\n     if verbosity == Verbosity::Verbose {\n         print!(\"rustfmt\");\n         for a in fmt_args {\n@@ -389,6 +328,7 @@ fn format_files(\n         }\n         println!();\n     }\n+\n     let mut command = Command::new(\"rustfmt\")\n         .stdout(stdout)\n         .args(files)\n@@ -401,5 +341,16 @@ fn format_files(\n             ),\n             _ => e,\n         })?;\n+\n     command.wait()\n }\n+\n+fn get_cargo_metadata(manifest_path: Option<&Path>) -> Result<cargo_metadata::Metadata, io::Error> {\n+    match cargo_metadata::metadata(manifest_path) {\n+        Ok(metadata) => Ok(metadata),\n+        Err(..) => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"`cargo manifest` failed.\",\n+        )),\n+    }\n+}"}, {"sha": "acf86f42565c196f854536808deb29518d39a7f0", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d260bfc39d115fc2bf69c5796cc9c2989263a/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=3c4d260bfc39d115fc2bf69c5796cc9c2989263a", "patch": "@@ -364,7 +364,7 @@ macro_rules! create_config {\n                             self.$i.2 = val;\n                         } else {\n                             println!(\"Warning: can't set some features as unstable \\\n-                                    features are only available in nightly channel.\");\n+                                      features are only available in nightly channel.\");\n                         }\n                     }\n                 }"}]}