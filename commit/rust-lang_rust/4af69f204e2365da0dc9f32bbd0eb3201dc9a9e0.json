{"sha": "4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjY5ZjIwNGUyMzY1ZGEwZGM5ZjMyYmJkMGViMzIwMWRjOWE5ZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-06T12:46:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-06T12:46:38Z"}, "message": "auto merge of #13344 : eddyb/rust/kill-unboxed-vec, r=cmr\n\nRemoves the special `ty_unboxed_vec` type from the type system.\r\nIt was previously used only during translating `~[T]`/`~str` allocation and drop glue.", "tree": {"sha": "203192e4ad78551953590942bb0df3b45c37d27a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/203192e4ad78551953590942bb0df3b45c37d27a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "html_url": "https://github.com/rust-lang/rust/commit/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f50565a1fda0dfd60d89fea65e2328f42cc5e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f50565a1fda0dfd60d89fea65e2328f42cc5e0", "html_url": "https://github.com/rust-lang/rust/commit/f1f50565a1fda0dfd60d89fea65e2328f42cc5e0"}, {"sha": "2d22243b0c582574394da7e3d8aaf8b2abf2c147", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d22243b0c582574394da7e3d8aaf8b2abf2c147", "html_url": "https://github.com/rust-lang/rust/commit/2d22243b0c582574394da7e3d8aaf8b2abf2c147"}], "stats": {"total": 583, "additions": 208, "deletions": 375}, "files": [{"sha": "73fc089d930bfbb3e173a6fd4102c7bcc2744870", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -349,7 +349,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let mt = parse_mt(st, |x,y| conv(x,y));\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n-      'U' => return ty::mk_unboxed_vec(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       'V' => {\n         let mt = parse_mt(st, |x,y| conv(x,y));\n         let v = parse_vstore(st, |x,y| conv(x,y));"}, {"sha": "384c6907aed4fe21fc139fabe72231408298dbe7", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -298,7 +298,6 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n             mywrite!(w, \"v\");\n             enc_vstore(w, cx, v);\n         }\n-        ty::ty_unboxed_vec(mt) => { mywrite!(w, \"U\"); enc_mt(w, cx, mt); }\n         ty::ty_closure(ref f) => {\n             mywrite!(w, \"f\");\n             enc_closure_ty(w, cx, *f);"}, {"sha": "e18f8f530eed340ea358d1f432ee7b6a788068fb", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -191,7 +191,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n                         }\n                     }\n                 }\n-                ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n+                ty::ty_vec(..) => {\n                     match *ctor {\n                         vec(n) => Some(format!(\"vectors of length {}\", n)),\n                         _ => None\n@@ -282,7 +282,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n               ty::ty_vec(_, ty::vstore_fixed(n)) => {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n-              ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n+              ty::ty_vec(..) => {\n                 let max_len = m.iter().rev().fold(0, |max_len, r| {\n                   match r.get(0).node {\n                     PatVec(ref before, _, ref after) => {\n@@ -464,7 +464,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _         => None\n         }\n       }\n-      ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n+      ty::ty_vec(..) => {\n \n         // Find the lengths and slices of all vector patterns.\n         let mut vec_pat_lens = m.iter().filter_map(|r| {\n@@ -529,7 +529,7 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-      ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n+      ty::ty_vec(..) => {\n         match *ctor {\n           vec(n) => n,\n           _ => 0u"}, {"sha": "c4fe5a3ebbba66bc9fe97e8b7b7a5dff19eb7a0a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -1088,7 +1088,8 @@ fn extract_vec_elems<'a>(\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n-    let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n+    let vec_ty = node_id_type(bcx, pat_id);\n+    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n \n     let mut elems = Vec::from_fn(elem_count, |i| {\n         match slice {\n@@ -1681,8 +1682,8 @@ fn compile_submatch_continue<'r,\n                 kind = compare;\n             },\n             vec_len(..) => {\n-                let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n-                let (_, len) = tvec::get_base_and_len(bcx, val, vt.vec_ty);\n+                let vec_ty = node_id_type(bcx, pat_id);\n+                let (_, len) = tvec::get_base_and_len(bcx, val, vec_ty);\n                 test_val = len;\n                 kind = compare_vec_len;\n             }"}, {"sha": "e48b8fc9db4cd2811b4aa72f3f19bac299f13217", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 52, "deletions": 99, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -37,7 +37,6 @@ use lib;\n use metadata::{csearch, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n-use middle::lang_items::{MallocFnLangItem, ClosureExchangeMallocFnLangItem};\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::build::*;\n@@ -336,111 +335,64 @@ pub fn at_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n \n-// malloc_raw_dyn: allocates a box to contain a given type, but with a\n-// potentially dynamic size.\n-pub fn malloc_raw_dyn<'a>(\n-                      bcx: &'a Block<'a>,\n-                      t: ty::t,\n-                      heap: heap,\n-                      size: ValueRef)\n-                      -> Result<'a> {\n-    let _icx = push_ctxt(\"malloc_raw\");\n-    let ccx = bcx.ccx();\n-\n-    fn require_alloc_fn(bcx: &Block, t: ty::t, it: LangItem) -> ast::DefId {\n-        let li = &bcx.tcx().lang_items;\n-        match li.require(it) {\n-            Ok(id) => id,\n-            Err(s) => {\n-                bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n-                                         bcx.ty_to_str(t), s));\n-            }\n+fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n+    match bcx.tcx().lang_items.require(it) {\n+        Ok(id) => id,\n+        Err(s) => {\n+            bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n+                                     bcx.ty_to_str(info_ty), s));\n         }\n     }\n+}\n \n-    if heap == heap_exchange {\n-        let llty_value = type_of::type_of(ccx, t);\n-\n-        // Allocate space:\n-        let r = callee::trans_lang_call(\n-            bcx,\n-            require_alloc_fn(bcx, t, ExchangeMallocFnLangItem),\n-            [size],\n-            None);\n-        rslt(r.bcx, PointerCast(r.bcx, r.val, llty_value.ptr_to()))\n-    } else {\n-        // we treat ~fn as @ here, which isn't ideal\n-        let langcall = match heap {\n-            heap_managed => {\n-                require_alloc_fn(bcx, t, MallocFnLangItem)\n-            }\n-            heap_exchange_closure => {\n-                require_alloc_fn(bcx, t, ClosureExchangeMallocFnLangItem)\n-            }\n-            _ => fail!(\"heap_exchange already handled\")\n-        };\n+// The following malloc_raw_dyn* functions allocate a box to contain\n+// a given type, but with a potentially dynamic size.\n \n-        // Grab the TypeRef type of box_ptr_ty.\n-        let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n-        let llty = type_of(ccx, box_ptr_ty);\n-        let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n-\n-        // Allocate space:\n-        let drop_glue = glue::get_drop_glue(ccx, t);\n-        let r = callee::trans_lang_call(\n-            bcx,\n-            langcall,\n-            [\n-                PointerCast(bcx, drop_glue, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to()),\n-                size,\n-                llalign\n-            ],\n-            None);\n-        rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n-    }\n-}\n-\n-// malloc_raw: expects an unboxed type and returns a pointer to\n-// enough space for a box of that type.  This includes a rust_opaque_box\n-// header.\n-pub fn malloc_raw<'a>(bcx: &'a Block<'a>, t: ty::t, heap: heap)\n-                  -> Result<'a> {\n-    let ty = type_of(bcx.ccx(), t);\n-    let size = llsize_of(bcx.ccx(), ty);\n-    malloc_raw_dyn(bcx, t, heap, size)\n-}\n-\n-pub struct MallocResult<'a> {\n-    pub bcx: &'a Block<'a>,\n-    pub smart_ptr: ValueRef,\n-    pub body: ValueRef\n-}\n-\n-// malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a smart\n-// pointer, and pulls out the body\n-pub fn malloc_general_dyn<'a>(\n-                          bcx: &'a Block<'a>,\n-                          t: ty::t,\n-                          heap: heap,\n+pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n+                          ptr_ty: ty::t,\n                           size: ValueRef)\n-                          -> MallocResult<'a> {\n-    assert!(heap != heap_exchange);\n-    let _icx = push_ctxt(\"malloc_general\");\n-    let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n-    let body = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+                          -> Result<'a> {\n+    let _icx = push_ctxt(\"malloc_raw_exchange\");\n+    let ccx = bcx.ccx();\n \n-    MallocResult {\n-        bcx: bcx,\n-        smart_ptr: llbox,\n-        body: body,\n-    }\n+    // Allocate space:\n+    let r = callee::trans_lang_call(bcx,\n+        require_alloc_fn(bcx, ptr_ty, ExchangeMallocFnLangItem),\n+        [size],\n+        None);\n+\n+    let llty_ptr = type_of::type_of(ccx, ptr_ty);\n+    rslt(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_general<'a>(bcx: &'a Block<'a>, t: ty::t, heap: heap)\n-                      -> MallocResult<'a> {\n-    let ty = type_of(bcx.ccx(), t);\n-    assert!(heap != heap_exchange);\n-    malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n+pub fn malloc_raw_dyn_managed<'a>(\n+                      bcx: &'a Block<'a>,\n+                      t: ty::t,\n+                      alloc_fn: LangItem,\n+                      size: ValueRef)\n+                      -> Result<'a> {\n+    let _icx = push_ctxt(\"malloc_raw_managed\");\n+    let ccx = bcx.ccx();\n+\n+    let langcall = require_alloc_fn(bcx, t, alloc_fn);\n+\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n+    let llty = type_of(ccx, box_ptr_ty);\n+    let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n+\n+    // Allocate space:\n+    let drop_glue = glue::get_drop_glue(ccx, t);\n+    let r = callee::trans_lang_call(\n+        bcx,\n+        langcall,\n+        [\n+            PointerCast(bcx, drop_glue, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to()),\n+            size,\n+            llalign\n+        ],\n+        None);\n+    rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n }\n \n // Type descriptor and type glue stuff\n@@ -708,7 +660,8 @@ pub fn iter_structural_ty<'r,\n       ty::ty_str(ty::vstore_fixed(_)) |\n       ty::ty_vec(_, ty::vstore_fixed(_)) => {\n         let (base, len) = tvec::get_base_and_byte_len(cx, av, t);\n-        cx = tvec::iter_vec_raw(cx, base, t, len, f);\n+        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);"}, {"sha": "1672e1f74eb08dd42b1ac70c29d3e890cfd97467", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -278,7 +278,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n-                           heap: common::heap) {\n+                           heap: Heap) {\n         /*!\n          * Schedules a call to `free(val)`. Note that this is a shallow\n          * operation.\n@@ -814,9 +814,14 @@ impl Cleanup for DropValue {\n     }\n }\n \n+pub enum Heap {\n+    HeapManaged,\n+    HeapExchange\n+}\n+\n pub struct FreeValue {\n     ptr: ValueRef,\n-    heap: common::heap,\n+    heap: Heap,\n }\n \n impl Cleanup for FreeValue {\n@@ -826,10 +831,10 @@ impl Cleanup for FreeValue {\n \n     fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n         match self.heap {\n-            common::heap_managed => {\n+            HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n             }\n-            common::heap_exchange | common::heap_exchange_closure => {\n+            HeapExchange => {\n                 glue::trans_exchange_free(bcx, self.ptr)\n             }\n         }\n@@ -901,7 +906,7 @@ pub trait CleanupMethods<'a> {\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n-                           heap: common::heap);\n+                           heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: ~Cleanup);"}, {"sha": "8fbaa23875407b8d3e8076daf85aec4c96ede034", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -13,13 +13,15 @@ use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use driver::session::FullDebugInfo;\n use lib::llvm::ValueRef;\n+use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n use middle::trans::debuginfo;\n use middle::trans::expr;\n+use middle::trans::machine::llsize_of;\n use middle::trans::type_of::*;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -168,7 +170,10 @@ fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n             tcx.sess.bug(\"trying to trans allocation of @fn\")\n         }\n         ast::OwnedSigil => {\n-            malloc_raw(bcx, cdata_ty, heap_exchange_closure)\n+            let ty = type_of(bcx.ccx(), cdata_ty);\n+            let size = llsize_of(bcx.ccx(), ty);\n+            // we treat proc as @ here, which isn't ideal\n+            malloc_raw_dyn_managed(bcx, cdata_ty, ClosureExchangeMallocFnLangItem, size)\n         }\n         ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);"}, {"sha": "d03b13b1b8fb9230179f1949fea69bfee1a7a113", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -386,14 +386,6 @@ impl<'a> FunctionContext<'a> {\n     }\n }\n \n-// Heap selectors. Indicate which heap something should go on.\n-#[deriving(Eq)]\n-pub enum heap {\n-    heap_managed,\n-    heap_exchange,\n-    heap_exchange_closure\n-}\n-\n // Basic block context.  We create a block context for each basic block\n // (single-entry, single-exit sequence of instructions) we generate from Rust\n // code.  Each basic block we generate is attached to a function, typically"}, {"sha": "95bf2a7f2753ad513a28e6c6af40cf301c2a4cf0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -37,6 +37,7 @@ use back::abi;\n use lib::llvm::{ValueRef, llvm};\n use lib;\n use metadata::csearch;\n+use middle::lang_items::MallocFnLangItem;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -426,8 +427,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             // `trans_rvalue_dps_unadjusted`.)\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, contents);\n-            let heap = heap_exchange;\n-            return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n+            trans_uniq_expr(bcx, box_ty, contents, contents_ty)\n         }\n         ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n         ast::ExprBinary(op, lhs, rhs) => {\n@@ -504,7 +504,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    let vt = tvec::vec_types(bcx, base_datum.ty);\n+    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), base_datum.ty));\n     base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n \n     let (base, len) = base_datum.get_vec_base_and_len(bcx);\n@@ -1175,10 +1175,10 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n         }\n         ast::UnBox => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr), heap_managed)\n+            trans_managed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr))\n         }\n         ast::UnUniq => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr), heap_exchange)\n+            trans_uniq_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr))\n         }\n         ast::UnDeref => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n@@ -1187,42 +1187,52 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_boxed_expr<'a>(bcx: &'a Block<'a>,\n-                        box_ty: ty::t,\n-                        contents: &ast::Expr,\n-                        contents_ty: ty::t,\n-                        heap: heap)\n+fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n+                       box_ty: ty::t,\n+                       contents: &ast::Expr,\n+                       contents_ty: ty::t)\n                         -> DatumBlock<'a, Expr> {\n-    let _icx = push_ctxt(\"trans_boxed_expr\");\n+    let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n-    if heap == heap_exchange {\n-        let llty = type_of::type_of(bcx.ccx(), contents_ty);\n-        let size = llsize_of(bcx.ccx(), llty);\n-        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n-                                                           heap_exchange, size);\n-        // Unique boxes do not allocate for zero-size types. The standard library may assume\n-        // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n-        if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n-            let bcx = trans_into(bcx, contents, SaveIn(val));\n-            immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n-        } else {\n-            let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n-            fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n-                                    val, heap_exchange);\n-            let bcx = trans_into(bcx, contents, SaveIn(val));\n-            fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n-            immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n-        }\n+    let llty = type_of::type_of(bcx.ccx(), contents_ty);\n+    let size = llsize_of(bcx.ccx(), llty);\n+    // We need to a make a pointer type because box_ty is ty_bot\n+    // if content_ty is, e.g. ~fail!().\n+    let real_box_ty = ty::mk_uniq(bcx.tcx(), contents_ty);\n+    let Result { bcx, val } = malloc_raw_dyn(bcx, real_box_ty, size);\n+    // Unique boxes do not allocate for zero-size types. The standard library may assume\n+    // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n+    let bcx = if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n+        trans_into(bcx, contents, SaveIn(val))\n     } else {\n-        let base::MallocResult { bcx, smart_ptr: bx, body } =\n-            base::malloc_general(bcx, contents_ty, heap);\n         let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n         fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n-                                bx, heap);\n-        let bcx = trans_into(bcx, contents, SaveIn(body));\n+                                val, cleanup::HeapExchange);\n+        let bcx = trans_into(bcx, contents, SaveIn(val));\n         fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n-        immediate_rvalue_bcx(bcx, bx, box_ty).to_expr_datumblock()\n-    }\n+        bcx\n+    };\n+    immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n+}\n+\n+fn trans_managed_expr<'a>(bcx: &'a Block<'a>,\n+                          box_ty: ty::t,\n+                          contents: &ast::Expr,\n+                          contents_ty: ty::t)\n+                          -> DatumBlock<'a, Expr> {\n+    let _icx = push_ctxt(\"trans_managed_expr\");\n+    let fcx = bcx.fcx;\n+    let ty = type_of::type_of(bcx.ccx(), contents_ty);\n+    let Result {bcx, val: bx} = malloc_raw_dyn_managed(bcx, contents_ty, MallocFnLangItem,\n+                                                        llsize_of(bcx.ccx(), ty));\n+    let body = GEPi(bcx, bx, [0u, abi::box_field_body]);\n+\n+    let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n+    fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n+                            bx, cleanup::HeapManaged);\n+    let bcx = trans_into(bcx, contents, SaveIn(body));\n+    fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n+    immediate_rvalue_bcx(bcx, bx, box_ty).to_expr_datumblock()\n }\n \n fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n@@ -1243,31 +1253,22 @@ fn trans_gc<'a>(mut bcx: &'a Block<'a>,\n                 -> &'a Block<'a> {\n     let contents_ty = expr_ty(bcx, contents);\n     let box_ty = ty::mk_box(bcx.tcx(), contents_ty);\n-    let expr_ty = expr_ty(bcx, expr);\n \n-    let addr = match dest {\n-        Ignore => {\n-            return trans_boxed_expr(bcx,\n-                                    box_ty,\n-                                    contents,\n-                                    contents_ty,\n-                                    heap_managed).bcx\n-        }\n-        SaveIn(addr) => addr,\n-    };\n+    let contents_datum = unpack_datum!(bcx, trans_managed_expr(bcx,\n+                                                               box_ty,\n+                                                               contents,\n+                                                               contents_ty));\n \n-    let repr = adt::represent_type(bcx.ccx(), expr_ty);\n-    adt::trans_start_init(bcx, repr, addr, 0);\n-    let field_dest = adt::trans_field_ptr(bcx, repr, addr, 0, 0);\n-    let contents_datum = unpack_datum!(bcx, trans_boxed_expr(bcx,\n-                                                             box_ty,\n-                                                             contents,\n-                                                             contents_ty,\n-                                                             heap_managed));\n-    bcx = contents_datum.store_to(bcx, field_dest);\n-\n-    // Next, wrap it up in the struct.\n-    bcx\n+    match dest {\n+        Ignore => bcx,\n+        SaveIn(addr) => {\n+            let expr_ty = expr_ty(bcx, expr);\n+            let repr = adt::represent_type(bcx.ccx(), expr_ty);\n+            adt::trans_start_init(bcx, repr, addr, 0);\n+            let field_dest = adt::trans_field_ptr(bcx, repr, addr, 0, 0);\n+            contents_datum.store_to(bcx, field_dest)\n+        }\n+    }\n }\n \n // Important to get types for both lhs and rhs, because one might be _|_\n@@ -1801,11 +1802,11 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             RvalueExpr(Rvalue { mode: ByRef }) => {\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n                 let ptr = Load(bcx, datum.val);\n-                bcx.fcx.schedule_free_value(scope, ptr, heap_exchange);\n+                bcx.fcx.schedule_free_value(scope, ptr, cleanup::HeapExchange);\n             }\n             RvalueExpr(Rvalue { mode: ByValue }) => {\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n-                bcx.fcx.schedule_free_value(scope, datum.val, heap_exchange);\n+                bcx.fcx.schedule_free_value(scope, datum.val, cleanup::HeapExchange);\n             }\n             LvalueExpr => { }\n         }"}, {"sha": "5aee8b6484809679b11972bf7c55cb7f64e75b0a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -290,10 +290,13 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             })\n         }\n         ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n-            make_drop_glue(bcx, v0, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n-        }\n-        ty::ty_unboxed_vec(_) => {\n-            tvec::make_drop_glue_unboxed(bcx, v0, t)\n+            let llbox = Load(bcx, v0);\n+            let not_null = IsNotNull(bcx, llbox);\n+            with_cond(bcx, not_null, |bcx| {\n+                let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+                let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n+                trans_exchange_free(bcx, llbox)\n+            })\n         }\n         ty::ty_struct(did, ref substs) => {\n             let tcx = bcx.tcx();"}, {"sha": "0cfa4f5f6d538a440e95e82dc095dc2092dbf939", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -163,11 +163,6 @@ impl<'a> Reflector<'a> {\n           ty::ty_float(ast::TyF32) => self.leaf(\"f32\"),\n           ty::ty_float(ast::TyF64) => self.leaf(\"f64\"),\n \n-          ty::ty_unboxed_vec(ref mt) => {\n-              let values = self.c_mt(mt);\n-              self.visit(\"vec\", values.as_slice())\n-          }\n-\n           // Should rename to str_*/vec_*.\n           ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);"}, {"sha": "1f2147b02e55c38e696e3e7c4e27c761436d5460", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 48, "deletions": 111, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -34,22 +34,6 @@ use util::ppaux::ty_to_str;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-// Boxed vector types are in some sense currently a \"shorthand\" for a box\n-// containing an unboxed vector. This expands a boxed vector type into such an\n-// expanded type. It doesn't respect mutability, but that doesn't matter at\n-// this point.\n-pub fn expand_boxed_vec_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n-    let unit_ty = ty::sequence_element_type(tcx, t);\n-    let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n-    match ty::get(t).sty {\n-        ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) => {\n-            ty::mk_uniq(tcx, unboxed_vec_ty)\n-        }\n-        _ => tcx.sess.bug(\"non boxed-vec type \\\n-                           in tvec::expand_boxed_vec_ty\")\n-    }\n-}\n-\n pub fn get_fill(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n@@ -67,66 +51,21 @@ pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn alloc_raw<'a>(\n-                 bcx: &'a Block<'a>,\n-                 unit_ty: ty::t,\n-                 fill: ValueRef,\n-                 alloc: ValueRef,\n-                 heap: heap)\n-                 -> Result<'a> {\n-    let _icx = push_ctxt(\"tvec::alloc_uniq\");\n-    let ccx = bcx.ccx();\n-\n-    let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n-    let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n-\n-    if heap == heap_exchange {\n-        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vecbodyty, heap_exchange, vecsize);\n-        Store(bcx, fill, GEPi(bcx, val, [0u, abi::vec_elt_fill]));\n-        Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n-        return rslt(bcx, val);\n-    } else {\n-        let base::MallocResult {bcx, smart_ptr: bx, body} =\n-            base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n-        Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n-        Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n-        return rslt(bcx, bx);\n-    }\n-}\n-\n-pub fn alloc_uniq_vec<'a>(\n-                 bcx: &'a Block<'a>,\n-                 unit_ty: ty::t,\n-                 elts: uint)\n-                 -> Result<'a> {\n-    let _icx = push_ctxt(\"tvec::alloc_uniq\");\n-    let ccx = bcx.ccx();\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let unit_sz = nonzero_llsize_of(ccx, llunitty);\n-\n-    let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n-    let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n-                else { fill };\n-    let Result {bcx: bcx, val: vptr} =\n-        alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange);\n-    return rslt(bcx, vptr);\n-}\n-\n pub fn make_drop_glue_unboxed<'a>(\n                               bcx: &'a Block<'a>,\n                               vptr: ValueRef,\n-                              vec_ty: ty::t)\n+                              unit_ty: ty::t)\n                               -> &'a Block<'a> {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n-    let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n-        iter_vec_unboxed(bcx, vptr, vec_ty, glue::drop_ty)\n+        let fill = get_fill(bcx, vptr);\n+        let dataptr = get_dataptr(bcx, vptr);\n+        iter_vec_raw(bcx, dataptr, unit_ty, fill, glue::drop_ty)\n     } else { bcx }\n }\n \n pub struct VecTypes {\n-    pub vec_ty: ty::t,\n     pub unit_ty: ty::t,\n     pub llunit_ty: Type,\n     pub llunit_size: ValueRef,\n@@ -135,9 +74,8 @@ pub struct VecTypes {\n \n impl VecTypes {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}, \\\n+        format!(\"VecTypes \\\\{unit_ty={}, llunit_ty={}, llunit_size={}, \\\n                  llunit_alloc_size={}\\\\}\",\n-             ty_to_str(ccx.tcx(), self.vec_ty),\n              ty_to_str(ccx.tcx(), self.unit_ty),\n              ccx.tn.type_to_str(self.llunit_ty),\n              ccx.tn.val_to_str(self.llunit_size),\n@@ -296,17 +234,16 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n \n     debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_str(vstore_expr));\n     let fcx = bcx.fcx;\n+    let ccx = fcx.ccx;\n \n     // Handle ~\"\".\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n-                    let llptrval = C_cstr(bcx.ccx(), (*s).clone(), false);\n-                    let llptrval = PointerCast(bcx,\n-                                               llptrval,\n-                                               Type::i8p(bcx.ccx()));\n-                    let llsizeval = C_uint(bcx.ccx(), s.get().len());\n+                    let llptrval = C_cstr(ccx, (*s).clone(), false);\n+                    let llptrval = PointerCast(bcx, llptrval, Type::i8p(ccx));\n+                    let llsizeval = C_uint(ccx, s.get().len());\n                     let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = rvalue_scratch_datum(bcx,\n                                                          typ,\n@@ -328,15 +265,28 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n         _ => {}\n     }\n \n-    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let vec_ty = node_id_type(bcx, vstore_expr.id);\n+    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n     let count = elements_required(bcx, content_expr);\n \n-    let Result {bcx, val} = alloc_uniq_vec(bcx, vt.unit_ty, count);\n+    let llunitty = type_of::type_of(ccx, vt.unit_ty);\n+    let unit_sz = nonzero_llsize_of(ccx, llunitty);\n+\n+    let fill = Mul(bcx, C_uint(ccx, count), unit_sz);\n+    let alloc = if count < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n+    else { fill };\n+\n+    let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n+\n+    let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vec_ty, vecsize);\n+    Store(bcx, fill, GEPi(bcx, val, [0u, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n \n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_free_value(cleanup::CustomScope(temp_scope), val, heap_exchange);\n+    fcx.schedule_free_value(cleanup::CustomScope(temp_scope),\n+                            val, cleanup::HeapExchange);\n \n     let dataptr = get_dataptr(bcx, val);\n \n@@ -348,7 +298,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n \n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    return immediate_rvalue_bcx(bcx, val, vt.vec_ty).to_expr_datumblock();\n+    immediate_rvalue_bcx(bcx, val, vec_ty).to_expr_datumblock()\n }\n \n pub fn write_content<'a>(\n@@ -456,21 +406,21 @@ pub fn write_content<'a>(\n \n pub fn vec_types_from_expr(bcx: &Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n-    vec_types(bcx, vec_ty)\n+    vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types(bcx: &Block, vec_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: &Block, unit_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n     let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n     let llunit_alloc_size = llsize_of_alloc(ccx, llunit_ty);\n \n-    VecTypes {vec_ty: vec_ty,\n-              unit_ty: unit_ty,\n-              llunit_ty: llunit_ty,\n-              llunit_size: llunit_size,\n-              llunit_alloc_size: llunit_alloc_size}\n+    VecTypes {\n+        unit_ty: unit_ty,\n+        llunit_ty: llunit_ty,\n+        llunit_size: llunit_size,\n+        llunit_alloc_size: llunit_alloc_size\n+    }\n }\n \n pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n@@ -507,11 +457,11 @@ pub fn get_base_and_byte_len(bcx: &Block,\n      */\n \n     let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, vec_ty);\n+    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n \n-    let vstore = match ty::get(vt.vec_ty).sty {\n-      ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n-      _ => ty::vstore_uniq\n+    let vstore = match ty::get(vec_ty).sty {\n+        ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n+        _ => ty::vstore_uniq\n     };\n \n     match vstore {\n@@ -521,14 +471,14 @@ pub fn get_base_and_byte_len(bcx: &Block,\n             (base, len)\n         }\n         ty::vstore_slice(_) => {\n-            assert!(!type_is_immediate(bcx.ccx(), vt.vec_ty));\n+            assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n             let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n             let len = Mul(bcx, count, vt.llunit_size);\n             (base, len)\n         }\n         ty::vstore_uniq => {\n-            assert!(type_is_immediate(bcx.ccx(), vt.vec_ty));\n+            assert!(type_is_immediate(bcx.ccx(), vec_ty));\n             let body = Load(bcx, llval);\n             (get_dataptr(bcx, body), get_fill(bcx, body))\n         }\n@@ -548,11 +498,11 @@ pub fn get_base_and_len(bcx: &Block,\n      */\n \n     let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, vec_ty);\n+    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n \n-    let vstore = match ty::get(vt.vec_ty).sty {\n-      ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n-      _ => ty::vstore_uniq\n+    let vstore = match ty::get(vec_ty).sty {\n+        ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n+        _ => ty::vstore_uniq\n     };\n \n     match vstore {\n@@ -561,13 +511,13 @@ pub fn get_base_and_len(bcx: &Block,\n             (base, C_uint(ccx, n))\n         }\n         ty::vstore_slice(_) => {\n-            assert!(!type_is_immediate(bcx.ccx(), vt.vec_ty));\n+            assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n             let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n             (base, count)\n         }\n         ty::vstore_uniq => {\n-            assert!(type_is_immediate(bcx.ccx(), vt.vec_ty));\n+            assert!(type_is_immediate(bcx.ccx(), vec_ty));\n             let body = Load(bcx, llval);\n             (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n         }\n@@ -639,14 +589,14 @@ pub fn iter_vec_raw<'r,\n                     'b>(\n                     bcx: &'b Block<'b>,\n                     data_ptr: ValueRef,\n-                    vec_ty: ty::t,\n+                    unit_ty: ty::t,\n                     fill: ValueRef,\n                     f: iter_vec_block<'r,'b>)\n                     -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n     let fcx = bcx.fcx;\n \n-    let vt = vec_types(bcx, vec_ty);\n+    let vt = vec_types(bcx, unit_ty);\n     if vt.llunit_alloc_size == 0 {\n         // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n         iter_vec_loop(bcx, data_ptr, &vt, fill, f)\n@@ -675,16 +625,3 @@ pub fn iter_vec_raw<'r,\n         next_bcx\n     }\n }\n-\n-pub fn iter_vec_unboxed<'r,\n-                        'b>(\n-                        bcx: &'b Block<'b>,\n-                        body_ptr: ValueRef,\n-                        vec_ty: ty::t,\n-                        f: iter_vec_block<'r,'b>)\n-                        -> &'b Block<'b> {\n-    let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n-    let fill = get_fill(bcx, body_ptr);\n-    let dataptr = get_dataptr(bcx, body_ptr);\n-    return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n-}"}, {"sha": "5a4cb1a33ef152f01b0d56d564a71b4c42a334fc", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -137,10 +137,6 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n-        ty::ty_unboxed_vec(mt) => {\n-            Type::vec(cx, &sizing_type_of(cx, mt.ty))\n-        }\n-\n         ty::ty_tup(..) | ty::ty_enum(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, repr)\n@@ -224,9 +220,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_vec(ref mt, ty::vstore_uniq) => {\n           Type::vec(cx, &type_of(cx, mt.ty)).ptr_to()\n       }\n-      ty::ty_unboxed_vec(ref mt) => {\n-          Type::vec(cx, &type_of(cx, mt.ty))\n-      }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n "}, {"sha": "a250c6c298ba526808551260075eba516a568034", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -750,9 +750,6 @@ pub enum sty {\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n             // on non-useful type error messages)\n-\n-    // \"Fake\" types, used for trans purposes\n-    ty_unboxed_vec(mt),\n }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n@@ -1214,8 +1211,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_box(tt) | &ty_uniq(tt) => {\n         flags |= get(tt).flags\n       }\n-      &ty_vec(ref m, _) | &ty_ptr(ref m) |\n-      &ty_unboxed_vec(ref m) => {\n+      &ty_vec(ref m, _) | &ty_ptr(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1384,13 +1380,6 @@ pub fn mk_vec(cx: &ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_vec(tm, t))\n }\n \n-pub fn mk_unboxed_vec(cx: &ctxt, tm: mt) -> t {\n-    mk_t(cx, ty_unboxed_vec(tm))\n-}\n-pub fn mk_mut_unboxed_vec(cx: &ctxt, ty: t) -> t {\n-    mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n-}\n-\n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n@@ -1470,8 +1459,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         ty_str(_) | ty_self(_) |\n         ty_infer(_) | ty_param(_) | ty_err => {}\n         ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n-        ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n-        ty_rptr(_, ref tm) => {\n+        ty_vec(ref tm, _) | ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -1625,9 +1613,9 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n \n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n-      ty_str(_) => return mk_mach_uint(ast::TyU8),\n-      ty_vec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n-      _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n+        ty_str(_) => mk_mach_uint(ast::TyU8),\n+        ty_vec(mt, _) => mt.ty,\n+        _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n \n@@ -1913,6 +1901,10 @@ impl TypeContents {\n         self.intersects(TC::InteriorUnsafe)\n     }\n \n+    pub fn interior_unsized(&self) -> bool {\n+        self.intersects(TC::InteriorUnsized)\n+    }\n+\n     pub fn moves_by_default(&self, _: &ctxt) -> bool {\n         self.intersects(TC::Moves)\n     }\n@@ -2167,7 +2159,6 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 // times.\n                 TC::All\n             }\n-            ty_unboxed_vec(mt) => TC::InteriorUnsized | tc_mt(cx, mt, cache),\n \n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n@@ -2354,8 +2345,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_err |\n             ty_param(_) |\n             ty_self(_) |\n-            ty_vec(_, _) |\n-            ty_unboxed_vec(_) => {\n+            ty_vec(_, _) => {\n                 false\n             }\n             ty_box(typ) | ty_uniq(typ) => {\n@@ -3313,7 +3303,6 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> ~str {\n         ty_box(_) => ~\"@-ptr\",\n         ty_uniq(_) => ~\"~-ptr\",\n         ty_vec(_, _) => ~\"vector\",\n-        ty_unboxed_vec(_) => ~\"unboxed vector\",\n         ty_ptr(_) => ~\"*-ptr\",\n         ty_rptr(_, _) => ~\"&-ptr\",\n         ty_bare_fn(_) => ~\"extern fn\",\n@@ -4719,10 +4708,6 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             }\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n-            ty_unboxed_vec(m) => {\n-                byte!(24);\n-                mt(&mut state, m);\n-            }\n         }\n     });\n "}, {"sha": "686452a5e443ca5d54b93eceff13cca1d14e3974", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -148,9 +148,6 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_ptr(ref tm) => {\n             ty::ty_ptr(this.fold_mt(tm))\n         }\n-        ty::ty_unboxed_vec(ref tm) => {\n-            ty::ty_unboxed_vec(this.fold_mt(tm))\n-        }\n         ty::ty_vec(ref tm, vst) => {\n             ty::ty_vec(this.fold_mt(tm), this.fold_vstore(vst))\n         }"}, {"sha": "bcad3a8758264b525bb4a59462fc85ef2492f194", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -637,9 +637,6 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             };\n             (mt, region_var)\n           }\n-          ty::ty_unboxed_vec(mt) => {\n-            (mt, default_region_var)\n-          },\n           _ => {\n               for &elt in before.iter() {\n                   check_pat(pcx, elt, ty::mk_err());"}, {"sha": "991e21ffab8b55fd32e95a01ba3e75fbb809719d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -910,7 +910,7 @@ impl<'a> LookupContext<'a> {\n \n             ty_err => None,\n \n-            ty_unboxed_vec(_) | ty_infer(TyVar(_)) => {\n+            ty_infer(TyVar(_)) => {\n                 self.bug(format!(\"unexpected type: {}\",\n                               self.ty_to_str(self_ty)));\n             }"}, {"sha": "73e1bc78641426561cf354830e4b71a385db20e5", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -24,7 +24,7 @@ use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_unboxed_vec, type_is_ty_var};\n+use middle::ty::type_is_ty_var;\n use middle::subst::Subst;\n use middle::ty;\n use middle::ty::{Impl, Method};\n@@ -81,9 +81,8 @@ fn get_base_type(inference_context: &InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_self(..) |\n-        ty_unboxed_vec(..) | ty_err | ty_box(_) |\n-        ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n+        ty_infer(..) | ty_param(..) | ty_self(..) | ty_err |\n+        ty_box(_) | ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n             None"}, {"sha": "91d9b264a88c95fcce5acb18f502df9a9acc6323", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -707,7 +707,7 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_infer(..) | ty::ty_err | ty::ty_unboxed_vec(..) => {\n+            ty::ty_infer(..) | ty::ty_err => {\n                 self.tcx().sess.bug(\n                     format!(\"unexpected type encountered in \\\n                             variance inference: {}\","}, {"sha": "155ceadf0d829048e9e9431cc34ef22db47fdb57", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_self, ty_tup};\n-use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_unboxed_vec, ty_infer};\n+use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n \n@@ -397,7 +397,6 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n       ty_rptr(r, ref tm) => {\n         region_ptr_to_str(cx, r) + mt_to_str(cx, tm)\n       }\n-      ty_unboxed_vec(ref tm) => { format!(\"unboxed_vec<{}>\", mt_to_str(cx, tm)) }\n       ty_tup(ref elems) => {\n         let strs: Vec<~str> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n         ~\"(\" + strs.connect(\",\") + \")\""}, {"sha": "896ebcd6fb596dca87e2c3e27d58f23e387d78d6", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -108,8 +108,6 @@ pub trait TyVisitor {\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n \n-    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;"}, {"sha": "e64a6b86d0246c847a8fddbfe1ebf0fa9616fe8b", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -18,7 +18,6 @@ Runtime type reflection\n \n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n use mem;\n-use raw;\n \n /**\n  * Trait for visitor that wishes to reflect on data. To use this, create a\n@@ -239,19 +238,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<raw::Vec<()>>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n     fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n         true\n     }"}, {"sha": "a1fa7cb225f11585bb398a53de5979441428060c", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -341,15 +341,6 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n-    // Type no longer exists, vestigial function.\n-    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n-\n-    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<raw::Vec<()>>(|this, b| {\n-            this.write_unboxed_vec_repr(mtbl, b, inner)\n-        })\n-    }\n-\n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n             try!(this, this.writer.write(['@' as u8]));"}, {"sha": "ca0b5fd0703ac930f12dc8d943aa718c9fb49737", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=4af69f204e2365da0dc9f32bbd0eb3201dc9a9e0", "patch": "@@ -73,8 +73,6 @@ impl TyVisitor for MyVisitor {\n     fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.types.push(~\"[\");"}]}