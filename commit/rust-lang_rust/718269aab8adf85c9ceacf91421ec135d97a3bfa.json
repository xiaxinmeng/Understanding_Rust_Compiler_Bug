{"sha": "718269aab8adf85c9ceacf91421ec135d97a3bfa", "node_id": "C_kwDOAAsO6NoAKDcxODI2OWFhYjhhZGY4NWM5Y2VhY2Y5MTQyMWVjMTM1ZDk3YTNiZmE", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-05-27T19:23:29Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-05-27T19:55:44Z"}, "message": "cleanup librustdoc by making parent stack store items", "tree": {"sha": "40faa4acff72907bd18eebabd6d0b5c319c5631b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40faa4acff72907bd18eebabd6d0b5c319c5631b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/718269aab8adf85c9ceacf91421ec135d97a3bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/718269aab8adf85c9ceacf91421ec135d97a3bfa", "html_url": "https://github.com/rust-lang/rust/commit/718269aab8adf85c9ceacf91421ec135d97a3bfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/718269aab8adf85c9ceacf91421ec135d97a3bfa/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "767719cc304e9b025875aea073f66ce248ae2616", "url": "https://api.github.com/repos/rust-lang/rust/commits/767719cc304e9b025875aea073f66ce248ae2616", "html_url": "https://github.com/rust-lang/rust/commit/767719cc304e9b025875aea073f66ce248ae2616"}], "stats": {"total": 174, "additions": 84, "deletions": 90}, "files": [{"sha": "d7276a427c468a49cebd2c22a74bd440cf13d0cb", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 82, "deletions": 75, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/718269aab8adf85c9ceacf91421ec135d97a3bfa/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718269aab8adf85c9ceacf91421ec135d97a3bfa/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=718269aab8adf85c9ceacf91421ec135d97a3bfa", "patch": "@@ -94,10 +94,7 @@ pub(crate) struct Cache {\n \n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<Symbol>,\n-    parent_stack: Vec<DefId>,\n-    impl_generics_stack: Vec<(clean::Type, clean::Generics)>,\n-    parent_is_trait_impl: bool,\n-    parent_is_blanket_or_auto_impl: bool,\n+    parent_stack: Vec<ParentStackItem>,\n     stripped_mod: bool,\n \n     pub(crate) search_index: Vec<IndexItem>,\n@@ -263,7 +260,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::AssocTypeItem(..)\n-                    if self.cache.parent_is_trait_impl =>\n+                    if self\n+                        .cache\n+                        .parent_stack\n+                        .last()\n+                        .map_or(false, |parent| parent.is_trait_impl()) =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n@@ -274,7 +275,14 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.cache.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(\n+                            self.cache\n+                                .parent_stack\n+                                .last()\n+                                .expect(\"parent_stack is empty\")\n+                                .item_id()\n+                                .expect_def_id(),\n+                        ),\n                         Some(&self.cache.stack[..self.cache.stack.len() - 1]),\n                     ),\n                     false,\n@@ -284,16 +292,19 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         ((None, None), false)\n                     } else {\n                         let last = self.cache.parent_stack.last().expect(\"parent_stack is empty 2\");\n-                        let did = *last;\n-                        let path = match self.cache.paths.get(&did) {\n+                        let did = match &*last {\n+                            ParentStackItem::Impl { for_, .. } => for_.def_id(&self.cache),\n+                            ParentStackItem::Type(item_id) => item_id.as_def_id(),\n+                        };\n+                        let path = match did.and_then(|did| self.cache.paths.get(&did)) {\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n                             // information if present.\n                             Some(&(ref fqp, _)) => Some(&fqp[..fqp.len() - 1]),\n                             None => None,\n                         };\n-                        ((Some(*last), path), true)\n+                        ((did, path), true)\n                     }\n                 }\n                 _ => ((None, Some(&*self.cache.stack)), false),\n@@ -320,8 +331,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             search_type: get_function_type_for_search(\n                                 &item,\n                                 self.tcx,\n-                                self.cache.impl_generics_stack.last(),\n-                                self.cache.parent_is_blanket_or_auto_impl,\n+                                clean_impl_generics(self.cache.parent_stack.last()).as_ref(),\n                                 self.cache,\n                             ),\n                             aliases: item.attrs.get_doc_aliases(),\n@@ -331,11 +341,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 (Some(parent), None) if is_inherent_impl_item => {\n                     // We have a parent, but we don't know where they're\n                     // defined yet. Wait for later to index this item.\n+                    let impl_generics = clean_impl_generics(self.cache.parent_stack.last());\n                     self.cache.orphan_impl_items.push(OrphanImplItem {\n                         parent,\n                         item: item.clone(),\n-                        impl_generics: self.cache.impl_generics_stack.last().cloned(),\n-                        parent_is_blanket_or_auto_impl: self.cache.parent_is_blanket_or_auto_impl,\n+                        impl_generics,\n                     });\n                 }\n                 _ => {}\n@@ -411,72 +421,19 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             }\n         }\n \n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.cache.parent_is_trait_impl;\n-        let parent_pushed = match *item.kind {\n+        // Maintain the parent stack.\n+        let (item, parent_pushed) = match *item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n-            | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.item_id.expect_def_id());\n-                self.cache.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.cache.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::Type::Path { ref path } => {\n-                        self.cache.parent_stack.push(path.def_id());\n-                        true\n-                    }\n-                    clean::DynTrait(ref bounds, _)\n-                    | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n-                        self.cache.parent_stack.push(bounds[0].trait_.def_id());\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t\n-                            .primitive_type()\n-                            .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.cache.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false,\n-        };\n-\n-        // When recursing into an impl item, make the generics context visible\n-        // to the child items.\n-        let item = {\n-            let mut item = item;\n-            let mut old_parent_is_blanket_or_auto_impl = false;\n-            if let clean::Item { kind: box clean::ImplItem(ref mut i), .. } = item {\n-                old_parent_is_blanket_or_auto_impl = mem::replace(\n-                    &mut self.cache.parent_is_blanket_or_auto_impl,\n-                    !matches!(i.kind, clean::ImplKind::Normal),\n-                );\n-                self.cache.impl_generics_stack.push((\n-                    mem::replace(&mut i.for_, clean::Type::Infer),\n-                    mem::replace(\n-                        &mut i.generics,\n-                        clean::Generics { params: Vec::new(), where_predicates: Vec::new() },\n-                    ),\n-                ));\n-            }\n-            let mut item = self.fold_item_recur(item);\n-            if let clean::Item { kind: box clean::ImplItem(ref mut i), .. } = item {\n-                self.cache.parent_is_blanket_or_auto_impl = old_parent_is_blanket_or_auto_impl;\n-                (i.for_, i.generics) = self.cache.impl_generics_stack.pop().expect(\"pushed above\");\n+            | clean::VariantItem(..)\n+            | clean::ImplItem(..) => {\n+                self.cache.parent_stack.push(ParentStackItem::new(&item));\n+                (self.fold_item_recur(item), true)\n             }\n-            item\n+            _ => (self.fold_item_recur(item), false),\n         };\n \n         // Once we've recursively found all the generics, hoard off all the\n@@ -549,7 +506,6 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             self.cache.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n         self.cache.stripped_mod = orig_stripped_mod;\n-        self.cache.parent_is_trait_impl = orig_parent_is_trait_impl;\n         ret\n     }\n }\n@@ -558,5 +514,56 @@ pub(crate) struct OrphanImplItem {\n     pub(crate) parent: DefId,\n     pub(crate) item: clean::Item,\n     pub(crate) impl_generics: Option<(clean::Type, clean::Generics)>,\n-    pub(crate) parent_is_blanket_or_auto_impl: bool,\n+}\n+\n+/// Information about trait and type parents is tracked while traversing the item tree to build\n+/// the cache.\n+///\n+/// We don't just store `Item` in there, because `Item` contains the list of children being\n+/// traversed and it would be wasteful to clone all that. We also need the item id, so just\n+/// storing `ItemKind` won't work, either.\n+enum ParentStackItem {\n+    Impl {\n+        for_: clean::Type,\n+        trait_: Option<clean::Path>,\n+        generics: clean::Generics,\n+        kind: clean::ImplKind,\n+        item_id: ItemId,\n+    },\n+    Type(ItemId),\n+}\n+\n+impl ParentStackItem {\n+    fn new(item: &clean::Item) -> Self {\n+        match &*item.kind {\n+            clean::ItemKind::ImplItem(clean::Impl { for_, trait_, generics, kind, .. }) => {\n+                ParentStackItem::Impl {\n+                    for_: for_.clone(),\n+                    trait_: trait_.clone(),\n+                    generics: generics.clone(),\n+                    kind: kind.clone(),\n+                    item_id: item.item_id,\n+                }\n+            }\n+            _ => ParentStackItem::Type(item.item_id),\n+        }\n+    }\n+    fn is_trait_impl(&self) -> bool {\n+        matches!(self, ParentStackItem::Impl { trait_: Some(..), .. })\n+    }\n+    fn item_id(&self) -> ItemId {\n+        match self {\n+            ParentStackItem::Impl { item_id, .. } => *item_id,\n+            ParentStackItem::Type(item_id) => *item_id,\n+        }\n+    }\n+}\n+\n+fn clean_impl_generics(item: Option<&ParentStackItem>) -> Option<(clean::Type, clean::Generics)> {\n+    if let Some(ParentStackItem::Impl { for_, generics, kind: clean::ImplKind::Normal, .. }) = item\n+    {\n+        Some((for_.clone(), generics.clone()))\n+    } else {\n+        None\n+    }\n }"}, {"sha": "25c70f0808c6d1e687b41f4c45df7a6237027a71", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/718269aab8adf85c9ceacf91421ec135d97a3bfa/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718269aab8adf85c9ceacf91421ec135d97a3bfa/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=718269aab8adf85c9ceacf91421ec135d97a3bfa", "patch": "@@ -25,9 +25,7 @@ pub(crate) fn build_index<'tcx>(\n \n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n-    for &OrphanImplItem { parent, ref item, ref impl_generics, parent_is_blanket_or_auto_impl } in\n-        &cache.orphan_impl_items\n-    {\n+    for &OrphanImplItem { parent, ref item, ref impl_generics } in &cache.orphan_impl_items {\n         if let Some(&(ref fqp, _)) = cache.paths.get(&parent) {\n             let desc = item\n                 .doc_value()\n@@ -39,13 +37,7 @@ pub(crate) fn build_index<'tcx>(\n                 desc,\n                 parent: Some(parent),\n                 parent_idx: None,\n-                search_type: get_function_type_for_search(\n-                    item,\n-                    tcx,\n-                    impl_generics.as_ref(),\n-                    parent_is_blanket_or_auto_impl,\n-                    cache,\n-                ),\n+                search_type: get_function_type_for_search(item, tcx, impl_generics.as_ref(), cache),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -201,13 +193,8 @@ pub(crate) fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n     impl_generics: Option<&(clean::Type, clean::Generics)>,\n-    from_blanket_or_auto_impl: bool,\n     cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n-    if from_blanket_or_auto_impl {\n-        return None;\n-    }\n-\n     let (mut inputs, mut output) = match *item.kind {\n         clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx, impl_generics, cache),\n         clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx, impl_generics, cache),"}]}