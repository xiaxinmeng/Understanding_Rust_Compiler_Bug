{"sha": "4f20caa6258d4c74ce6b316fd347e3efe81cf557", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMjBjYWE2MjU4ZDRjNzRjZTZiMzE2ZmQzNDdlM2VmZTgxY2Y1NTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-01T20:52:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-01T20:52:47Z"}, "message": "Auto merge of #82663 - jyn514:rollup-xh3cb0c, r=jyn514\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #81210 (BTreeMap: correct node size test case for choices of B)\n - #82360 (config.toml parsing error improvements)\n - #82428 (Update mdbook)\n - #82480 (Remove `ENABLE_DOWNLOAD_RUSTC` constant)\n - #82578 (Add some diagnostic items for Clippy)\n - #82620 (Apply lint restrictions from renamed lints)\n - #82635 (Fix typos in rustc_infer::infer::nll_relate)\n - #82645 (Clarify that SyncOnceCell::set blocks.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b02c6087e615f61520af2c778e4d366ff9bfa7d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b02c6087e615f61520af2c778e4d366ff9bfa7d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f20caa6258d4c74ce6b316fd347e3efe81cf557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f20caa6258d4c74ce6b316fd347e3efe81cf557", "html_url": "https://github.com/rust-lang/rust/commit/4f20caa6258d4c74ce6b316fd347e3efe81cf557", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f20caa6258d4c74ce6b316fd347e3efe81cf557/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccad218e7f909d7dabdb901437fffc151873b8a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccad218e7f909d7dabdb901437fffc151873b8a1", "html_url": "https://github.com/rust-lang/rust/commit/ccad218e7f909d7dabdb901437fffc151873b8a1"}, {"sha": "9a86a727c5acdf51a3cf062db552a2391da99276", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a86a727c5acdf51a3cf062db552a2391da99276", "html_url": "https://github.com/rust-lang/rust/commit/9a86a727c5acdf51a3cf062db552a2391da99276"}], "stats": {"total": 327, "additions": 164, "deletions": 163}, "files": [{"sha": "87690718dc05b8d6c8bb461e017a9f63851d81cc", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -1767,7 +1767,7 @@ dependencies = [\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n- \"shlex\",\n+ \"shlex 0.1.1\",\n ]\n \n [[package]]\n@@ -2122,9 +2122,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.6\"\n+version = \"0.4.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3d948b64449003363127ed6c6139f03273982c3fe97da4cb3dee933e38ce38f\"\n+checksum = \"28f6a882f3880ec68e96f60d6b543c34941e2f307ad10e2992e4db9acfe96529\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n@@ -2142,7 +2142,7 @@ dependencies = [\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"shlex\",\n+ \"shlex 1.0.0\",\n  \"tempfile\",\n  \"toml\",\n ]\n@@ -4858,6 +4858,12 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fdf1b9db47230893d76faad238fd6097fd6d6a9245cd7a4d90dbd639536bbd2\"\n \n+[[package]]\n+name = \"shlex\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n+\n [[package]]\n name = \"signal-hook-registry\"\n version = \"1.2.1\""}, {"sha": "e5eb771603cd7a32b3b49c5ba2c22eace53ef2a8", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -44,7 +44,7 @@ where\n {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n \n-    /// Callback to use when we deduce an outlives relationship\n+    /// Callback to use when we deduce an outlives relationship.\n     delegate: D,\n \n     /// How are we relating `a` and `b`?\n@@ -768,7 +768,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     }\n }\n \n-/// The \"type generalize\" is used when handling inference variables.\n+/// The \"type generalizer\" is used when handling inference variables.\n ///\n /// The basic strategy for handling a constraint like `?A <: B` is to\n /// apply a \"generalization strategy\" to the type `B` -- this replaces"}, {"sha": "dbcab72ddf2eb6c115823be31d98c8f16f47fb54", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -321,17 +321,18 @@ impl<'s> LintLevelsBuilder<'s> {\n                     None\n                 };\n                 let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n-                match store.check_lint_name(&name.as_str(), tool_name) {\n+                let lint_result = store.check_lint_name(&name.as_str(), tool_name);\n+                match &lint_result {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintLevelSource::Node(name, li.span(), reason);\n-                        for &id in ids {\n+                        for &id in *ids {\n                             self.check_gated_lint(id, attr.span);\n                             self.insert_spec(&mut specs, id, (level, src));\n                         }\n                     }\n \n                     CheckLintNameResult::Tool(result) => {\n-                        match result {\n+                        match *result {\n                             Ok(ids) => {\n                                 let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n                                 let src = LintLevelSource::Node(\n@@ -343,7 +344,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     self.insert_spec(&mut specs, *id, (level, src));\n                                 }\n                             }\n-                            Err((Some(ids), new_lint_name)) => {\n+                            Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                                 let (lvl, src) =\n                                     self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n@@ -392,21 +393,21 @@ impl<'s> LintLevelsBuilder<'s> {\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (level, src) =\n+                        let (renamed_lint_level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n                         struct_lint_level(\n                             self.sess,\n                             lint,\n-                            level,\n+                            renamed_lint_level,\n                             src,\n                             Some(li.span().into()),\n                             |lint| {\n                                 let mut err = lint.build(&msg);\n-                                if let Some(new_name) = renamed {\n+                                if let Some(new_name) = &renamed {\n                                     err.span_suggestion(\n                                         li.span(),\n                                         \"use the new name\",\n-                                        new_name,\n+                                        new_name.to_string(),\n                                         Applicability::MachineApplicable,\n                                     );\n                                 }\n@@ -444,6 +445,22 @@ impl<'s> LintLevelsBuilder<'s> {\n                         );\n                     }\n                 }\n+                // If this lint was renamed, apply the new lint instead of ignoring the attribute.\n+                // This happens outside of the match because the new lint should be applied even if\n+                // we don't warn about the name change.\n+                if let CheckLintNameResult::Warning(_, Some(new_name)) = lint_result {\n+                    // Ignore any errors or warnings that happen because the new name is inaccurate\n+                    if let CheckLintNameResult::Ok(ids) =\n+                        store.check_lint_name(&new_name, tool_name)\n+                    {\n+                        let src =\n+                            LintLevelSource::Node(Symbol::intern(&new_name), li.span(), reason);\n+                        for &id in ids {\n+                            self.check_gated_lint(id, attr.span);\n+                            self.insert_spec(&mut specs, id, (level, src));\n+                        }\n+                    }\n+                }\n             }\n         }\n "}, {"sha": "f87267da9f6c7dfe4df46498f9b3edb6b7e9e059", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -126,6 +126,9 @@ symbols! {\n         Argument,\n         ArgumentV1,\n         Arguments,\n+        BTreeMap,\n+        BTreeSet,\n+        BinaryHeap,\n         C,\n         CString,\n         Center,\n@@ -163,6 +166,7 @@ symbols! {\n         Iterator,\n         Layout,\n         Left,\n+        LinkedList,\n         LintPass,\n         None,\n         Ok,\n@@ -191,6 +195,7 @@ symbols! {\n         RangeToInclusive,\n         Rc,\n         Ready,\n+        Receiver,\n         Result,\n         Return,\n         Right,\n@@ -592,6 +597,8 @@ symbols! {\n         gt,\n         half_open_range_patterns,\n         hash,\n+        hashmap_type,\n+        hashset_type,\n         hexagon_target_feature,\n         hidden,\n         homogeneous_aggregate,\n@@ -1256,6 +1263,7 @@ symbols! {\n         variant_count,\n         vec,\n         vec_type,\n+        vecdeque_type,\n         version,\n         vis,\n         visible_private_types,"}, {"sha": "5c4392acca595813d24154e693be54d99bc50ae4", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -637,7 +637,9 @@ changelog-seen = 2\n # The full path to the musl libdir.\n #musl-libdir = musl-root/lib\n \n-# The root location of the `wasm32-wasi` sysroot.\n+# The root location of the `wasm32-wasi` sysroot. Only used for the\n+# `wasm32-wasi` target. If you are building wasm32-wasi target, make sure to\n+# create a `[target.wasm32-wasi]` section and move this field there.\n #wasi-root = \"...\"\n \n # Used in testing for configuring where the QEMU images are located, you"}, {"sha": "21a0fb844e8c4ebff14a42ccc8351d28487b99dc", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -296,11 +296,6 @@ fn fat_val_map(n: usize) -> BTreeMap<usize, [usize; FAT]> {\n     (0..n).map(|i| (i, [i; FAT])).collect::<BTreeMap<_, _>>()\n }\n \n-// The returned map has large keys and values.\n-fn fat_map(n: usize) -> BTreeMap<[usize; FAT], [usize; FAT]> {\n-    (0..n).map(|i| ([i; FAT], [i; FAT])).collect::<BTreeMap<_, _>>()\n-}\n-\n #[bench]\n pub fn clone_slim_100(b: &mut Bencher) {\n     let src = slim_map(100);\n@@ -513,74 +508,3 @@ pub fn clone_fat_val_100_and_remove_half(b: &mut Bencher) {\n         map\n     })\n }\n-\n-#[bench]\n-pub fn clone_fat_100(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| src.clone())\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_clear(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| src.clone().clear())\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_drain_all(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_drain_half(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| {\n-        let mut map = src.clone();\n-        assert_eq!(map.drain_filter(|i, _| i[0] % 2 == 0).count(), 100 / 2);\n-        assert_eq!(map.len(), 100 / 2);\n-    })\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_into_iter(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| src.clone().into_iter().count())\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_pop_all(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| {\n-        let mut map = src.clone();\n-        while map.pop_first().is_some() {}\n-        map\n-    });\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_remove_all(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| {\n-        let mut map = src.clone();\n-        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n-            let v = map.remove(&elt);\n-            debug_assert!(v.is_some());\n-        }\n-        map\n-    });\n-}\n-\n-#[bench]\n-pub fn clone_fat_100_and_remove_half(b: &mut Bencher) {\n-    let src = fat_map(100);\n-    b.iter(|| {\n-        let mut map = src.clone();\n-        for i in (0..100).step_by(2) {\n-            let v = map.remove(&[i; FAT]);\n-            debug_assert!(v.is_some());\n-        }\n-        assert_eq!(map.len(), 100 / 2);\n-        map\n-    })\n-}"}, {"sha": "4377780e15f4590fb58331e02991730e30ddf4ba", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -247,6 +247,7 @@ use super::SpecExtend;\n /// [peek]: BinaryHeap::peek\n /// [peek\\_mut]: BinaryHeap::peek_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"BinaryHeap\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }"}, {"sha": "783f88f026b8fe1346e67111acd80f4da44a8b51", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -138,6 +138,7 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// *stat += random_stat_buff();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeMap\")]\n pub struct BTreeMap<K, V> {\n     root: Option<Root<K, V>>,\n     length: usize,"}, {"sha": "4e48db7f49305edba67cdd34d7823fa05ea5601a", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -136,8 +136,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n     }\n }\n \n-// Tests our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n-// implementation of insertion, but it's best to be aware of when it does.\n+// Tests our value of MIN_INSERTS_HEIGHT_2. Failure may mean you just need to\n+// adapt that value to match a change in node::CAPACITY or the choices made\n+// during insertion, otherwise other test cases may fail or be less useful.\n #[test]\n fn test_levels() {\n     let mut map = BTreeMap::new();"}, {"sha": "5e4473546228270ebf23cff1b0cde245ee4ebea5", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -95,7 +95,7 @@ fn test_partial_eq() {\n #[cfg(target_arch = \"x86_64\")]\n fn test_sizes() {\n     assert_eq!(core::mem::size_of::<LeafNode<(), ()>>(), 16);\n-    assert_eq!(core::mem::size_of::<LeafNode<i64, i64>>(), 16 + CAPACITY * 8 * 2);\n-    assert_eq!(core::mem::size_of::<InternalNode<(), ()>>(), 112);\n-    assert_eq!(core::mem::size_of::<InternalNode<i64, i64>>(), 112 + CAPACITY * 8 * 2);\n+    assert_eq!(core::mem::size_of::<LeafNode<i64, i64>>(), 16 + CAPACITY * 2 * 8);\n+    assert_eq!(core::mem::size_of::<InternalNode<(), ()>>(), 16 + (CAPACITY + 1) * 8);\n+    assert_eq!(core::mem::size_of::<InternalNode<i64, i64>>(), 16 + (CAPACITY * 3 + 1) * 8);\n }"}, {"sha": "a331b8d8e4bbbe5e87009de2ee5bf539827449f0", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -61,6 +61,7 @@ use super::Recover;\n /// ```\n #[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeSet\")]\n pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }"}, {"sha": "a5481fd175e307cb5e86deb9c0bc00bd974af6b4", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -35,6 +35,7 @@ mod tests;\n /// array-based containers are generally faster,\n /// more memory efficient, and make better use of CPU cache.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"LinkedList\")]\n pub struct LinkedList<T> {\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,"}, {"sha": "974851a8bd634ba1bd364ab2e50bb4b084f0e3e6", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -177,7 +177,10 @@ impl<T> SyncOnceCell<T> {\n \n     /// Sets the contents of this cell to `value`.\n     ///\n-    /// Returns `Ok(())` if the cell's value was updated.\n+    /// May block if another thread is currently attempting to initialize the cell. The cell is\n+    /// guaranteed to contain a value when set returns, though not necessarily the one provided.\n+    ///\n+    /// Returns `Ok(())` if the cell's value was set by this call.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b12e7eeb13814e8472113e2ced9a80bb0cad7975", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -310,6 +310,7 @@ mod cache_aligned;\n /// println!(\"{}\", recv.recv().unwrap()); // Received after 2 seconds\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Receiver\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }"}, {"sha": "2008348ea8d8ec9eeff4c49bd07c23280afc0c54", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -57,14 +57,6 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// `true` here can still be overwritten by `should_run` calling `default_condition`.\n     const DEFAULT: bool = false;\n \n-    /// Whether this step should be run even when `download-rustc` is set.\n-    ///\n-    /// Most steps are not important when the compiler is downloaded, since they will be included in\n-    /// the pre-compiled sysroot. Steps can set this to `true` to be built anyway.\n-    ///\n-    /// When in doubt, set this to `false`.\n-    const ENABLE_DOWNLOAD_RUSTC: bool = false;\n-\n     /// If true, then this rule should be skipped if --target was specified, but --host was not\n     const ONLY_HOSTS: bool = false;\n \n@@ -107,7 +99,6 @@ impl RunConfig<'_> {\n \n struct StepDescription {\n     default: bool,\n-    enable_download_rustc: bool,\n     only_hosts: bool,\n     should_run: fn(ShouldRun<'_>) -> ShouldRun<'_>,\n     make_run: fn(RunConfig<'_>),\n@@ -162,7 +153,6 @@ impl StepDescription {\n     fn from<S: Step>() -> StepDescription {\n         StepDescription {\n             default: S::DEFAULT,\n-            enable_download_rustc: S::ENABLE_DOWNLOAD_RUSTC,\n             only_hosts: S::ONLY_HOSTS,\n             should_run: S::should_run,\n             make_run: S::make_run,\n@@ -179,14 +169,6 @@ impl StepDescription {\n                 \"{:?} not skipped for {:?} -- not in {:?}\",\n                 pathset, self.name, builder.config.exclude\n             );\n-        } else if builder.config.download_rustc && !self.enable_download_rustc {\n-            if !builder.config.dry_run {\n-                eprintln!(\n-                    \"Not running {} because its artifacts have been downloaded from CI (`download-rustc` is set)\",\n-                    self.name\n-                );\n-            }\n-            return;\n         }\n \n         // Determine the targets participating in this rule."}, {"sha": "6626fead774d6b42b4d37819bcf755b2280b51fe", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -62,7 +62,6 @@ fn cargo_subcommand(kind: Kind) -> &'static str {\n impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ENABLE_DOWNLOAD_RUSTC: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"test\")\n@@ -156,7 +155,6 @@ impl Step for Rustc {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n-    const ENABLE_DOWNLOAD_RUSTC: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc-main\")\n@@ -235,7 +233,6 @@ impl Step for CodegenBackend {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n-    const ENABLE_DOWNLOAD_RUSTC: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.paths(&[\"compiler/rustc_codegen_cranelift\", \"rustc_codegen_cranelift\"])\n@@ -293,7 +290,6 @@ macro_rules! tool_check_step {\n             type Output = ();\n             const ONLY_HOSTS: bool = true;\n             const DEFAULT: bool = true;\n-            const ENABLE_DOWNLOAD_RUSTC: bool = true;\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.path($path)"}, {"sha": "24800b7886d943afb7946b910814355e3af5272c", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -63,6 +63,12 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n+        // These artifacts were already copied (in `impl Step for Sysroot`).\n+        // Don't recompile them.\n+        if builder.config.download_rustc {\n+            return;\n+        }\n+\n         if builder.config.keep_stage.contains(&compiler.stage)\n             || builder.config.keep_stage_std.contains(&compiler.stage)\n         {\n@@ -178,7 +184,9 @@ fn copy_self_contained_objects(\n     // To do that we have to distribute musl startup objects as a part of Rust toolchain\n     // and link with them manually in the self-contained mode.\n     if target.contains(\"musl\") {\n-        let srcdir = builder.musl_libdir(target).unwrap();\n+        let srcdir = builder.musl_libdir(target).unwrap_or_else(|| {\n+            panic!(\"Target {:?} does not have a \\\"musl-libdir\\\" key\", target.triple)\n+        });\n         for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n             copy_and_stamp(\n                 builder,\n@@ -196,7 +204,12 @@ fn copy_self_contained_objects(\n             target_deps.push((target, DependencyType::TargetSelfContained));\n         }\n     } else if target.ends_with(\"-wasi\") {\n-        let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n+        let srcdir = builder\n+            .wasi_root(target)\n+            .unwrap_or_else(|| {\n+                panic!(\"Target {:?} does not have a \\\"wasi-root\\\" key\", target.triple)\n+            })\n+            .join(\"lib/wasm32-wasi\");\n         for &obj in &[\"crt1.o\", \"crt1-reactor.o\"] {\n             copy_and_stamp(\n                 builder,\n@@ -500,6 +513,13 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n+        if builder.config.download_rustc {\n+            // Copy the existing artifacts instead of rebuilding them.\n+            // NOTE: this path is only taken for tools linking to rustc-dev.\n+            builder.ensure(Sysroot { compiler });\n+            return;\n+        }\n+\n         builder.ensure(Std { compiler, target });\n \n         if builder.config.keep_stage.contains(&compiler.stage) {"}, {"sha": "3fc3b68fd8681b2deea7e235f9c8af5ecaf4d51c", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -483,7 +483,6 @@ pub struct Rustdoc {\n impl Step for Rustdoc {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ENABLE_DOWNLOAD_RUSTC: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {"}, {"sha": "01cd32536728e3b838a5bb0cecbc05c6c5d9583d", "filename": "src/test/ui/lint/renamed-lints-still-apply.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftest%2Fui%2Flint%2Frenamed-lints-still-apply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftest%2Fui%2Flint%2Frenamed-lints-still-apply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frenamed-lints-still-apply.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: --crate-type lib\n+#![deny(single_use_lifetime)]\n+//~^ WARNING renamed\n+//~| NOTE `#[warn(renamed_and_removed_lints)]` on by default\n+//~| NOTE defined here\n+fn _foo<'a>(_x: &'a u32) {}\n+//~^ ERROR only used once\n+//~| NOTE this lifetime\n+//~| NOTE is used only here"}, {"sha": "33e5a03266e50ec88526f14960c02dd60fa0ed98", "filename": "src/test/ui/lint/renamed-lints-still-apply.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftest%2Fui%2Flint%2Frenamed-lints-still-apply.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftest%2Fui%2Flint%2Frenamed-lints-still-apply.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frenamed-lints-still-apply.stderr?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -0,0 +1,28 @@\n+warning: lint `single_use_lifetime` has been renamed to `single_use_lifetimes`\n+  --> $DIR/renamed-lints-still-apply.rs:2:9\n+   |\n+LL | #![deny(single_use_lifetime)]\n+   |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `single_use_lifetimes`\n+   |\n+   = note: `#[warn(renamed_and_removed_lints)]` on by default\n+\n+error: lifetime parameter `'a` only used once\n+  --> $DIR/renamed-lints-still-apply.rs:6:9\n+   |\n+LL | fn _foo<'a>(_x: &'a u32) {}\n+   |         ^^       -- ...is used only here\n+   |         |\n+   |         this lifetime...\n+   |\n+note: the lint level is defined here\n+  --> $DIR/renamed-lints-still-apply.rs:2:9\n+   |\n+LL | #![deny(single_use_lifetime)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+help: elide the single-use lifetime\n+   |\n+LL | fn _foo(_x: &u32) {}\n+   |       --    --\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "55575969927ba891e35cb2faebb9302622f26df6", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n@@ -111,7 +112,7 @@ fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static\n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))\n             }\n-            else if is_type_diagnostic_item(cx, obj_ty, sym!(hashmap_type)) {\n+            else if is_type_diagnostic_item(cx, obj_ty, sym::hashmap_type) {\n                 Some((\"HashMap\", map, key))\n             }\n             else {"}, {"sha": "63d9b7f8645978aa349996cd99f9d9d1c9d3c185", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -1010,7 +1010,7 @@ fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n         _ => false,\n     };\n \n-    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n }\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n@@ -1908,7 +1908,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n                 _ => arg,\n             };\n \n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP) {\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(\n                     cx,\n                     FOR_KV_MAP,\n@@ -2386,9 +2386,9 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     is_iterable_array(ty, cx) ||\n     is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym::hashmap_type) ||\n+    is_type_diagnostic_item(cx, ty, sym::hashset_type) ||\n+    is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n     match_type(cx, ty, &paths::BINARY_HEAP) ||\n     match_type(cx, ty, &paths::BTREEMAP) ||\n     match_type(cx, ty, &paths::BTREESET)\n@@ -2922,9 +2922,9 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         then {\n             let ty = cx.typeck_results().node_type(ty.hir_id);\n             if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||\n-                is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n+                is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n                 if method.ident.name == sym!(len) {\n                     let span = shorten_needless_collect_span(expr);\n                     span_lint_and_sugg(\n@@ -2992,7 +2992,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n                 if let ty = cx.typeck_results().node_type(ty.hir_id);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     match_type(cx, ty, &paths::LINKED_LIST);\n                 if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n                 if iter_calls.len() == 1;"}, {"sha": "5163074453b5fafdf5f9f03f7c97cafbec66633c", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -24,7 +24,7 @@ use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{sym, SymbolStr};\n+use rustc_span::symbol::{sym, Symbol, SymbolStr};\n use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n@@ -2598,7 +2598,7 @@ fn lint_iter_nth<'tcx>(\n         \"slice\"\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vecdeque_type) {\n         \"VecDeque\"\n     } else {\n         let nth_args = nth_and_iter_args[0];\n@@ -2652,10 +2652,10 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, expr_ty, sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vecdeque_type) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"VecDeque\"\n-    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym!(hashmap_type)) {\n+    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym::hashmap_type) {\n         needs_ref = true;\n         \"HashMap\"\n     } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n@@ -3619,7 +3619,7 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n     }\n }\n \n-fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n+fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(Symbol, &'static str)> {\n     has_iter_method(cx, self_ref_ty).map(|ty_name| {\n         let mutbl = match self_ref_ty.kind() {\n             ty::Ref(_, _, mutbl) => mutbl,"}, {"sha": "9d8a0c248334f582af850002b48f112be4447374", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -199,7 +199,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n                 if matches!(ty.kind(), ty::Slice(_))\n                     || matches!(ty.kind(), ty::Array(_, _))\n                     || is_type_diagnostic_item(cx, ty, sym::vec_type)\n-                    || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+                    || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n                 {\n                     return Slice::Swappable(lhs1, idx1, idx2);\n                 }"}, {"sha": "eb2016db3dc2c5557f9affb75fbabee6fc776860", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -2680,14 +2680,14 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n \n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n \n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) && params_len == 2 {\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n                 Some(ImplicitHasherType::HashMap(\n                     hir_ty.span,\n                     ty,\n                     snippet(cx, params[0].span, \"K\"),\n                     snippet(cx, params[1].span, \"V\"),\n                 ))\n-            } else if is_type_diagnostic_item(cx, ty, sym!(hashset_type)) && params_len == 1 {\n+            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n                 Some(ImplicitHasherType::HashSet(\n                     hir_ty.span,\n                     ty,"}, {"sha": "316b8d820a715adb298edc2b847f8efcfe55cdba", "filename": "src/tools/clippy/clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::ty::{Adt, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_target::abi::LayoutOf as _;\n use rustc_typeck::hir_ty_to_ty;\n+use rustc_span::sym;\n \n use crate::utils::{is_normalizable, is_type_diagnostic_item, match_type, paths, span_lint_and_help};\n \n@@ -47,7 +48,7 @@ impl LateLintPass<'_> for ZeroSizedMapValues {\n             if !hir_ty.span.from_expansion();\n             if !in_trait_impl(cx, hir_ty.hir_id);\n             let ty = ty_from_hir_ty(cx, hir_ty);\n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP);\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP);\n             if let Adt(_, ref substs) = ty.kind();\n             let ty = substs.type_at(1);\n             // Do this to prevent `layout_of` crashing, being unable to fully normalize `ty`."}, {"sha": "81cd99c0558dce7f8f149eab452c72562d06d147", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -18,6 +18,7 @@ use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_span::sym;\n \n /// Is the expr pure (is it free from side-effects)?\n /// This function is named so to stress that it isn't exhaustive and returns FNs.\n@@ -99,7 +100,7 @@ fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, ex\n                 ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n                 ExprKind::Index(obj, _) => {\n                     let ty = self.cx.typeck_results().expr_ty(obj);\n-                    is_type_diagnostic_item(self.cx, ty, sym!(hashmap_type))\n+                    is_type_diagnostic_item(self.cx, ty, sym::hashmap_type)\n                         || match_type(self.cx, ty, &paths::BTREEMAP)\n                 },\n                 ExprKind::MethodCall(..) => true,"}, {"sha": "42512cadfb18dfcebb026ef7cc17559dd748a43e", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -1295,24 +1295,24 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool\n }\n \n /// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n+pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<Symbol> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method.\n-    let into_iter_collections: [&[&str]; 13] = [\n-        &paths::VEC,\n-        &paths::OPTION,\n-        &paths::RESULT,\n-        &paths::BTREESET,\n-        &paths::BTREEMAP,\n-        &paths::VEC_DEQUE,\n-        &paths::LINKED_LIST,\n-        &paths::BINARY_HEAP,\n-        &paths::HASHSET,\n-        &paths::HASHMAP,\n-        &paths::PATH_BUF,\n-        &paths::PATH,\n-        &paths::RECEIVER,\n+    let into_iter_collections: &[Symbol] = &[\n+        sym::vec_type,\n+        sym::option_type,\n+        sym::result_type,\n+        sym::BTreeMap,\n+        sym::BTreeSet,\n+        sym::vecdeque_type,\n+        sym::LinkedList,\n+        sym::BinaryHeap,\n+        sym::hashset_type,\n+        sym::hashmap_type,\n+        sym::PathBuf,\n+        sym::Path,\n+        sym::Receiver,\n     ];\n \n     let ty_to_check = match probably_ref_ty.kind() {\n@@ -1321,15 +1321,15 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n     };\n \n     let def_id = match ty_to_check.kind() {\n-        ty::Array(..) => return Some(\"array\"),\n-        ty::Slice(..) => return Some(\"slice\"),\n+        ty::Array(..) => return Some(sym::array),\n+        ty::Slice(..) => return Some(sym::slice),\n         ty::Adt(adt, _) => adt.did,\n         _ => return None,\n     };\n \n-    for path in &into_iter_collections {\n-        if match_def_path(cx, def_id, path) {\n-            return Some(*path.last().unwrap());\n+    for &name in into_iter_collections {\n+        if cx.tcx.is_diagnostic_item(name, def_id) {\n+            return Some(cx.tcx.item_name(def_id));\n         }\n     }\n     None"}, {"sha": "c2da1f9b7c9f9360c1d15be3e237302d376e82a7", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f20caa6258d4c74ce6b316fd347e3efe81cf557/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=4f20caa6258d4c74ce6b316fd347e3efe81cf557", "patch": "@@ -99,7 +99,6 @@ pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n-pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n@@ -116,7 +115,6 @@ pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n-pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];"}]}