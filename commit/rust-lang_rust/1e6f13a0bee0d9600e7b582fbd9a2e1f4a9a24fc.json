{"sha": "1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNmYxM2EwYmVlMGQ5NjAwZTdiNTgyZmJkOWEyZTFmNGE5YTI0ZmM=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T09:27:53Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T09:27:53Z"}, "message": "support extracting methods; no mut lowering\n\ncurrently mut refernce will *not* be downgraded to shared\nif it is sufficient(see relevant test for example)", "tree": {"sha": "08d6bacb9e2715bdde46bad274bb457aa2fe46d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08d6bacb9e2715bdde46bad274bb457aa2fe46d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc", "html_url": "https://github.com/rust-lang/rust/commit/1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc3ae81a873173346df6cb000e503233d7558d03", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3ae81a873173346df6cb000e503233d7558d03", "html_url": "https://github.com/rust-lang/rust/commit/bc3ae81a873173346df6cb000e503233d7558d03"}], "stats": {"total": 228, "additions": 191, "deletions": 37}, "files": [{"sha": "09c2a9bc7554d82ca22d086394706e60971033f4", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 191, "deletions": 37, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=1e6f13a0bee0d9600e7b582fbd9a2e1f4a9a24fc", "patch": "@@ -68,6 +68,11 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     if body.is_none() && node.kind() == BLOCK_EXPR {\n         body = FunctionBody::from_range(&node, ctx.frange.range);\n     }\n+    if let Some(parent) = node.parent() {\n+        if body.is_none() && parent.kind() == BLOCK_EXPR {\n+            body = FunctionBody::from_range(&parent, ctx.frange.range);\n+        }\n+    }\n     if body.is_none() {\n         body = FunctionBody::from_whole_node(node.clone());\n     }\n@@ -76,10 +81,47 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     }\n     let body = body?;\n \n-    let insert_after = body.scope_for_fn_insertion()?;\n+    let mut self_param = None;\n+    let mut param_pats: Vec<_> = local_variables(&body, &ctx)\n+        .into_iter()\n+        .map(|node| node.source(ctx.db()))\n+        .filter(|src| {\n+            src.file_id.original_file(ctx.db()) == ctx.frange.file_id\n+                && !body.contains_node(&either_syntax(&src.value))\n+        })\n+        .filter_map(|src| match src.value {\n+            Either::Left(pat) => Some(pat),\n+            Either::Right(it) => {\n+                // we filter self param, as there can only be one\n+                self_param = Some(it);\n+                None\n+            }\n+        })\n+        .collect();\n+    deduplicate_params(&mut param_pats);\n \n+    let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n+    let insert_after = body.scope_for_fn_insertion(anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n+    let params = param_pats\n+        .into_iter()\n+        .map(|pat| {\n+            let ty = pat\n+                .pat()\n+                .and_then(|pat| ctx.sema.type_of_pat(&pat))\n+                .and_then(|ty| ty.display_source_code(ctx.db(), module.into()).ok())\n+                .unwrap_or_else(|| \"()\".to_string());\n+\n+            let name = pat.name().unwrap().to_string();\n+\n+            Param { name, ty }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    let self_param =\n+        if let Some(self_param) = self_param { Some(self_param.to_string()) } else { None };\n+\n     let expr = body.tail_expr();\n     let ret_ty = match expr {\n         Some(expr) => {\n@@ -96,36 +138,12 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         FunctionBody::Span { .. } => ctx.frange.range,\n     };\n \n-    let mut params = local_variables(&body, &ctx)\n-        .into_iter()\n-        .map(|node| node.source(ctx.db()))\n-        .filter(|src| src.file_id.original_file(ctx.db()) == ctx.frange.file_id)\n-        .map(|src| match src.value {\n-            Either::Left(pat) => {\n-                (pat.syntax().clone(), pat.name(), ctx.sema.type_of_pat(&pat.into()))\n-            }\n-            Either::Right(it) => (it.syntax().clone(), it.name(), ctx.sema.type_of_self(&it)),\n-        })\n-        .filter(|(node, _, _)| !body.contains_node(node))\n-        .map(|(_, name, ty)| {\n-            let ty = ty\n-                .and_then(|ty| ty.display_source_code(ctx.db(), module.into()).ok())\n-                .unwrap_or_else(|| \"()\".to_string());\n-\n-            let name = name.unwrap().to_string();\n-\n-            Param { name, ty }\n-        })\n-        .collect::<Vec<_>>();\n-    deduplicate_params(&mut params);\n-\n     acc.add(\n         AssistId(\"extract_function\", crate::AssistKind::RefactorExtract),\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n-\n-            let fun = Function { name: \"fun_name\".to_string(), params, ret_ty, body };\n+            let fun = Function { name: \"fun_name\".to_string(), self_param, params, ret_ty, body };\n \n             builder.replace(target_range, format_replacement(&fun));\n \n@@ -140,6 +158,9 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n fn format_replacement(fun: &Function) -> String {\n     let mut buf = String::new();\n+    if fun.self_param.is_some() {\n+        format_to!(buf, \"self.\");\n+    }\n     format_to!(buf, \"{}(\", fun.name);\n     {\n         let mut it = fun.params.iter();\n@@ -161,6 +182,7 @@ fn format_replacement(fun: &Function) -> String {\n \n struct Function {\n     name: String,\n+    self_param: Option<String>,\n     params: Vec<Param>,\n     ret_ty: Option<String>,\n     body: FunctionBody,\n@@ -186,7 +208,9 @@ fn format_function(fun: &Function, indent: IndentLevel) -> String {\n     format_to!(fn_def, \"\\n\\n{}fn $0{}(\", indent, fun.name);\n     {\n         let mut it = fun.params.iter();\n-        if let Some(param) = it.next() {\n+        if let Some(self_param) = &fun.self_param {\n+            format_to!(fn_def, \"{}\", self_param);\n+        } else if let Some(param) = it.next() {\n             format_to!(fn_def, \"{}: {}\", param.name, param.ty);\n         }\n         for param in it {\n@@ -230,6 +254,11 @@ enum FunctionBody {\n     Span { elements: Vec<SyntaxElement>, leading_indent: String },\n }\n \n+enum Anchor {\n+    Freestanding,\n+    Method,\n+}\n+\n impl FunctionBody {\n     fn from_whole_node(node: SyntaxNode) -> Option<Self> {\n         match node.kind() {\n@@ -288,12 +317,12 @@ impl FunctionBody {\n         }\n     }\n \n-    fn scope_for_fn_insertion(&self) -> Option<SyntaxNode> {\n+    fn scope_for_fn_insertion(&self, anchor: Anchor) -> Option<SyntaxNode> {\n         match self {\n-            FunctionBody::Expr(e) => scope_for_fn_insertion(e.syntax()),\n+            FunctionBody::Expr(e) => scope_for_fn_insertion(e.syntax(), anchor),\n             FunctionBody::Span { elements, .. } => {\n                 let node = elements.iter().find_map(|e| e.as_node())?;\n-                scope_for_fn_insertion(&node)\n+                scope_for_fn_insertion(&node, anchor)\n             }\n         }\n     }\n@@ -325,14 +354,25 @@ impl FunctionBody {\n     }\n }\n \n-fn scope_for_fn_insertion(node: &SyntaxNode) -> Option<SyntaxNode> {\n+fn scope_for_fn_insertion(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNode> {\n     let mut ancestors = node.ancestors().peekable();\n     let mut last_ancestor = None;\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n             SyntaxKind::ITEM_LIST => {\n-                if ancestors.peek().map(|a| a.kind()) == Some(SyntaxKind::MODULE) {\n+                if !matches!(anchor, Anchor::Freestanding) {\n+                    continue;\n+                }\n+                if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n+                    break;\n+                }\n+            }\n+            SyntaxKind::ASSOC_ITEM_LIST => {\n+                if !matches!(anchor, Anchor::Method) {\n+                    continue;\n+                }\n+                if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::IMPL) {\n                     break;\n                 }\n             }\n@@ -343,15 +383,21 @@ fn scope_for_fn_insertion(node: &SyntaxNode) -> Option<SyntaxNode> {\n     last_ancestor\n }\n \n-fn deduplicate_params(params: &mut Vec<Param>) {\n+fn deduplicate_params(params: &mut Vec<ast::IdentPat>) {\n     let mut seen_params = FxHashSet::default();\n-    params.retain(|p| seen_params.insert(p.name.clone()));\n+    params.retain(|p| seen_params.insert(p.clone()));\n+}\n+\n+fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n+    match value {\n+        Either::Left(pat) => pat.syntax(),\n+        Either::Right(it) => it.syntax(),\n+    }\n }\n \n /// Returns a vector of local variables that are refferenced in `body`\n fn local_variables(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n-    body\n-        .descendants()\n+    body.descendants()\n         .filter_map(ast::NameRef::cast)\n         .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n         .map(|name_kind| name_kind.referenced(ctx.db()))\n@@ -386,7 +432,7 @@ fn $0fun_name() -> i32 {\n }\"#,\n         );\n     }\n-    \n+\n     #[test]\n     fn no_args_from_binary_expr_in_module() {\n         check_assist(\n@@ -816,4 +862,112 @@ fn $0fun_name() -> u32 {\n     fn return_not_applicable() {\n         check_assist_not_applicable(extract_function, r\"fn foo() { $0return$0; } \");\n     }\n+\n+    #[test]\n+    fn method_to_freestanding() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S;\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        $01+1$0\n+    }\n+}\",\n+            r\"\n+struct S;\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        fun_name()\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    1+1\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_reference() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        $01+self.f$0\n+    }\n+}\",\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&self) -> i32 {\n+        self.fun_name()\n+    }\n+\n+    fn $0fun_name(&self) -> i32 {\n+        1+self.f\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_mut() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&mut self) {\n+        $0self.f += 1;$0\n+    }\n+}\",\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&mut self) {\n+        self.fun_name();\n+    }\n+\n+    fn $0fun_name(&mut self) {\n+        self.f += 1;\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_mut_downgrade_to_shared() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&mut self) -> i32 {\n+        $01+self.f$0\n+    }\n+}\",\n+            r\"\n+struct S { f: i32 };\n+\n+impl S {\n+    fn foo(&mut self) -> i32 {\n+        self.fun_name()\n+    }\n+\n+    fn $0fun_name(&self) -> i32 {\n+        1+self.f\n+    }\n+}\",\n+        );\n+    }\n }"}]}