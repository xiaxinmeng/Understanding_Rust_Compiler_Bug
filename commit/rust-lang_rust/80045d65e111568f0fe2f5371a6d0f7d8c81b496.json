{"sha": "80045d65e111568f0fe2f5371a6d0f7d8c81b496", "node_id": "C_kwDOAAsO6NoAKDgwMDQ1ZDY1ZTExMTU2OGYwZmUyZjUzNzFhNmQwZjdkOGM4MWI0OTY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-28T00:40:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-28T00:40:34Z"}, "message": "Rollup merge of #96421 - nnethercote:less-NoDelim, r=petrochenkov\n\nLess `NoDelim`\n\nCurrently there are several places where `NoDelim` (which really means \"implicit delimiter\" or \"invisible delimiter\") is used to mean \"no delimiter\". The name `NoDelim` is a bit misleading, and may be a cause.\n\nThis PR changes these places, e.g. by changing a `DelimToken` to `Option<DelimToken>` and then using `None` to mean \"no delimiter\". As a result, the *only* place where `NoDelim` values are now produced is within:\n- `Delimiter::to_internal()`, when converting from `Delimiter::None`.\n- `FlattenNonterminals::process_token()`, when converting `TokenKind::Interpolated`.\n\nr? ````@petrochenkov````", "tree": {"sha": "e84585b4e5f58e77dd8ad0239e12d10897dabb0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e84585b4e5f58e77dd8ad0239e12d10897dabb0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80045d65e111568f0fe2f5371a6d0f7d8c81b496", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiaeKCCRBK7hj4Ov3rIwAAYmAIAKRMU8vzLLiYgKpnUVDOfPFg\nviXl/YEMYAaTEGMawplRkcRjTsdD4+Q2WLujDw3sXM+dATgTEZ1TyIhRJxTNQKi5\nqxBUG+iPRb9bCG7DBgS3J6P1v26TrD8eB9eaAfXMxj76g3uYFG5TKH8GLuroPoGw\nilcfKmJmgGqH9YndhEN7id5rhiBayAJ4O3gmg+ivW3WAGNUf7+PG9w6qwPZgOgoe\nxsFYkuXBg+AAPODXUvcRSPhPSQMwu10Pmm1wG+qScd5IK+aKP5ZFi9HG49ZDrKvk\nkf+9UJDoGYjkl1GggB3Q3V5yf1JztrBHMXJoDIoHH21pG1LZMu1/sUspccm91JY=\n=icAr\n-----END PGP SIGNATURE-----\n", "payload": "tree e84585b4e5f58e77dd8ad0239e12d10897dabb0f\nparent c4dd0d3bb70367273db9eee9e5fa6cb323a69547\nparent 86f011704c31f4eb1e7993e1951826bca46fe8f1\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1651106434 +0200\ncommitter GitHub <noreply@github.com> 1651106434 +0200\n\nRollup merge of #96421 - nnethercote:less-NoDelim, r=petrochenkov\n\nLess `NoDelim`\n\nCurrently there are several places where `NoDelim` (which really means \"implicit delimiter\" or \"invisible delimiter\") is used to mean \"no delimiter\". The name `NoDelim` is a bit misleading, and may be a cause.\n\nThis PR changes these places, e.g. by changing a `DelimToken` to `Option<DelimToken>` and then using `None` to mean \"no delimiter\". As a result, the *only* place where `NoDelim` values are now produced is within:\n- `Delimiter::to_internal()`, when converting from `Delimiter::None`.\n- `FlattenNonterminals::process_token()`, when converting `TokenKind::Interpolated`.\n\nr? ````@petrochenkov````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80045d65e111568f0fe2f5371a6d0f7d8c81b496", "html_url": "https://github.com/rust-lang/rust/commit/80045d65e111568f0fe2f5371a6d0f7d8c81b496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80045d65e111568f0fe2f5371a6d0f7d8c81b496/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4dd0d3bb70367273db9eee9e5fa6cb323a69547", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4dd0d3bb70367273db9eee9e5fa6cb323a69547", "html_url": "https://github.com/rust-lang/rust/commit/c4dd0d3bb70367273db9eee9e5fa6cb323a69547"}, {"sha": "86f011704c31f4eb1e7993e1951826bca46fe8f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/86f011704c31f4eb1e7993e1951826bca46fe8f1", "html_url": "https://github.com/rust-lang/rust/commit/86f011704c31f4eb1e7993e1951826bca46fe8f1"}], "stats": {"total": 170, "additions": 86, "deletions": 84}, "files": [{"sha": "4233f7806248ba3efddf1b44415dcbc0d4a4d312", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -1542,10 +1542,10 @@ pub enum MacArgs {\n }\n \n impl MacArgs {\n-    pub fn delim(&self) -> DelimToken {\n+    pub fn delim(&self) -> Option<DelimToken> {\n         match self {\n-            MacArgs::Delimited(_, delim, _) => delim.to_token(),\n-            MacArgs::Empty | MacArgs::Eq(..) => token::NoDelim,\n+            MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n+            MacArgs::Empty | MacArgs::Eq(..) => None,\n         }\n     }\n "}, {"sha": "39824095e86636cdfbd040a219084f735feded7a", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -464,7 +464,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 Some(MacHeader::Path(&item.path)),\n                 false,\n                 None,\n-                delim.to_token(),\n+                Some(delim.to_token()),\n                 tokens,\n                 true,\n                 span,\n@@ -530,7 +530,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     None,\n                     false,\n                     None,\n-                    *delim,\n+                    Some(*delim),\n                     tts,\n                     convert_dollar_crate,\n                     dspan.entire(),\n@@ -556,12 +556,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n         ident: Option<Ident>,\n-        delim: DelimToken,\n+        delim: Option<DelimToken>,\n         tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n-        if delim == DelimToken::Brace {\n+        if delim == Some(DelimToken::Brace) {\n             self.cbox(INDENT_UNIT);\n         }\n         match header {\n@@ -577,31 +577,33 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.print_ident(ident);\n         }\n         match delim {\n-            DelimToken::Brace => {\n+            Some(DelimToken::Brace) => {\n                 if header.is_some() || has_bang || ident.is_some() {\n                     self.nbsp();\n                 }\n                 self.word(\"{\");\n                 if !tts.is_empty() {\n                     self.space();\n                 }\n-            }\n-            _ => {\n-                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n-                self.word(token_str)\n-            }\n-        }\n-        self.ibox(0);\n-        self.print_tts(tts, convert_dollar_crate);\n-        self.end();\n-        match delim {\n-            DelimToken::Brace => {\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n                 let empty = tts.is_empty();\n                 self.bclose(span, empty);\n             }\n-            _ => {\n+            Some(delim) => {\n+                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n+                self.word(token_str);\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n                 let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n-                self.word(token_str)\n+                self.word(token_str);\n+            }\n+            None => {\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n             }\n         }\n     }"}, {"sha": "f3dcdbf93c5f14af8eb472de9f46fc983b1f535f", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -260,16 +260,15 @@ fn generic_extension<'cx, 'tt>(\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                // Ignore the delimiters on the RHS.\n-                let rhs = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(_, delimited) => &delimited.tts,\n+                let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n+                    mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 let arm_span = rhses[i].span();\n \n-                let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n+                let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = match transcribe(cx, &named_matches, &rhs, transparency) {\n+                let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n                     Ok(tts) => tts,\n                     Err(mut err) => {\n                         err.emit();"}, {"sha": "d5b1913e1440cb7138fc51d840a29f0bbe26ec8f", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -29,8 +29,8 @@ impl MutVisitor for Marker {\n enum Frame<'a> {\n     Delimited {\n         tts: &'a [mbe::TokenTree],\n-        delim_token: token::DelimToken,\n         idx: usize,\n+        delim_token: token::DelimToken,\n         span: DelimSpan,\n     },\n     Sequence {\n@@ -42,8 +42,8 @@ enum Frame<'a> {\n \n impl<'a> Frame<'a> {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(tts: &'a [mbe::TokenTree]) -> Frame<'a> {\n-        Frame::Delimited { tts, delim_token: token::NoDelim, idx: 0, span: DelimSpan::dummy() }\n+    fn new(src: &'a mbe::Delimited, span: DelimSpan) -> Frame<'a> {\n+        Frame::Delimited { tts: &src.tts, idx: 0, delim_token: src.delim, span }\n     }\n }\n \n@@ -85,17 +85,18 @@ impl<'a> Iterator for Frame<'a> {\n pub(super) fn transcribe<'a>(\n     cx: &ExtCtxt<'a>,\n     interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n-    src: &[mbe::TokenTree],\n+    src: &mbe::Delimited,\n+    src_span: DelimSpan,\n     transparency: Transparency,\n ) -> PResult<'a, TokenStream> {\n     // Nothing for us to transcribe...\n-    if src.is_empty() {\n+    if src.tts.is_empty() {\n         return Ok(TokenStream::default());\n     }\n \n     // We descend into the RHS (`src`), expanding things as we go. This stack contains the things\n     // we have yet to expand/are still expanding. We start the stack off with the whole RHS.\n-    let mut stack: SmallVec<[Frame<'_>; 1]> = smallvec![Frame::new(&src)];\n+    let mut stack: SmallVec<[Frame<'_>; 1]> = smallvec![Frame::new(&src, src_span)];\n \n     // As we descend in the RHS, we will need to be able to match nested sequences of matchers.\n     // `repeats` keeps track of where we are in matching at each level, with the last element being"}, {"sha": "575b01180df77be00f2cac9899b732f971429863", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::tokenstream::{AttrAnnotatedTokenTree, DelimSpan, LazyTokenStream,\n use rustc_ast::{self as ast};\n use rustc_ast::{AstLike, AttrVec, Attribute};\n use rustc_errors::PResult;\n-use rustc_span::{sym, Span, DUMMY_SP};\n+use rustc_span::{sym, Span};\n \n use std::convert::TryInto;\n use std::ops::Range;\n@@ -400,24 +400,26 @@ fn make_token_stream(\n ) -> AttrAnnotatedTokenStream {\n     #[derive(Debug)]\n     struct FrameData {\n-        open: Span,\n-        open_delim: DelimToken,\n+        // This is `None` for the first frame, `Some` for all others.\n+        open_delim_sp: Option<(DelimToken, Span)>,\n         inner: Vec<(AttrAnnotatedTokenTree, Spacing)>,\n     }\n-    let mut stack =\n-        vec![FrameData { open: DUMMY_SP, open_delim: DelimToken::NoDelim, inner: vec![] }];\n+    let mut stack = vec![FrameData { open_delim_sp: None, inner: vec![] }];\n     let mut token_and_spacing = iter.next();\n     while let Some((token, spacing)) = token_and_spacing {\n         match token {\n             FlatToken::Token(Token { kind: TokenKind::OpenDelim(delim), span }) => {\n-                stack.push(FrameData { open: span, open_delim: delim, inner: vec![] });\n+                stack.push(FrameData { open_delim_sp: Some((delim, span)), inner: vec![] });\n             }\n             FlatToken::Token(Token { kind: TokenKind::CloseDelim(delim), span }) => {\n                 // HACK: If we encounter a mismatched `None` delimiter at the top\n                 // level, just ignore it.\n                 if matches!(delim, DelimToken::NoDelim)\n                     && (stack.len() == 1\n-                        || !matches!(stack.last_mut().unwrap().open_delim, DelimToken::NoDelim))\n+                        || !matches!(\n+                            stack.last_mut().unwrap().open_delim_sp.unwrap().0,\n+                            DelimToken::NoDelim\n+                        ))\n                 {\n                     token_and_spacing = iter.next();\n                     continue;\n@@ -430,7 +432,7 @@ fn make_token_stream(\n                 // merge our current frame with the one above it. That is, transform\n                 // `[ { < first second } third ]` into `[ { first second } third ]`\n                 if !matches!(delim, DelimToken::NoDelim)\n-                    && matches!(frame_data.open_delim, DelimToken::NoDelim)\n+                    && matches!(frame_data.open_delim_sp.unwrap().0, DelimToken::NoDelim)\n                 {\n                     stack.last_mut().unwrap().inner.extend(frame_data.inner);\n                     // Process our closing delimiter again, this time at the previous\n@@ -439,12 +441,13 @@ fn make_token_stream(\n                     continue;\n                 }\n \n+                let (open_delim, open_sp) = frame_data.open_delim_sp.unwrap();\n                 assert_eq!(\n-                    frame_data.open_delim, delim,\n+                    open_delim, delim,\n                     \"Mismatched open/close delims: open={:?} close={:?}\",\n-                    frame_data.open, span\n+                    open_delim, span\n                 );\n-                let dspan = DelimSpan::from_pair(frame_data.open, span);\n+                let dspan = DelimSpan::from_pair(open_sp, span);\n                 let stream = AttrAnnotatedTokenStream::new(frame_data.inner);\n                 let delimited = AttrAnnotatedTokenTree::Delimited(dspan, delim, stream);\n                 stack\n@@ -472,7 +475,7 @@ fn make_token_stream(\n     // HACK: If we don't have a closing `None` delimiter for our last\n     // frame, merge the frame with the top-level frame. That is,\n     // turn `< first second` into `first second`\n-    if stack.len() == 2 && stack[1].open_delim == DelimToken::NoDelim {\n+    if stack.len() == 2 && stack[1].open_delim_sp.unwrap().0 == DelimToken::NoDelim {\n         let temp_buf = stack.pop().unwrap();\n         stack.last_mut().unwrap().inner.extend(temp_buf.inner);\n     }"}, {"sha": "e4370809ebc24023052bbf180083e56d5965c30b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -2043,7 +2043,8 @@ impl<'a> Parser<'a> {\n             self.sess.gated_spans.gate(sym::async_closure, span);\n         }\n \n-        if self.token.kind == TokenKind::Semi && self.token_cursor.frame.delim == DelimToken::Paren\n+        if self.token.kind == TokenKind::Semi\n+            && matches!(self.token_cursor.frame.delim_sp, Some((DelimToken::Paren, _)))\n         {\n             // It is likely that the closure body is a block but where the\n             // braces have been removed. We will recover and eat the next"}, {"sha": "dfe758d0cdf019406876e2f018699dd736c7a774", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -244,14 +244,13 @@ struct TokenCursor {\n \n #[derive(Clone)]\n struct TokenCursorFrame {\n-    delim: token::DelimToken,\n-    span: DelimSpan,\n+    delim_sp: Option<(DelimToken, DelimSpan)>,\n     tree_cursor: tokenstream::Cursor,\n }\n \n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n-        TokenCursorFrame { delim, span, tree_cursor: tts.into_trees() }\n+    fn new(delim_sp: Option<(DelimToken, DelimSpan)>, tts: TokenStream) -> Self {\n+        TokenCursorFrame { delim_sp, tree_cursor: tts.into_trees() }\n     }\n }\n \n@@ -266,7 +265,7 @@ impl TokenCursor {\n         loop {\n             // FIXME: we currently don't return `NoDelim` open/close delims. To fix #67062 we will\n             // need to, whereupon the `delim != DelimToken::NoDelim` conditions below can be\n-            // removed, as well as the loop.\n+            // removed.\n             if let Some((tree, spacing)) = self.frame.tree_cursor.next_with_spacing_ref() {\n                 match tree {\n                     &TokenTree::Token(ref token) => match (desugar_doc_comments, token) {\n@@ -277,7 +276,7 @@ impl TokenCursor {\n                     },\n                     &TokenTree::Delimited(sp, delim, ref tts) => {\n                         // Set `open_delim` to true here because we deal with it immediately.\n-                        let frame = TokenCursorFrame::new(sp, delim, tts.clone());\n+                        let frame = TokenCursorFrame::new(Some((delim, sp)), tts.clone());\n                         self.stack.push(mem::replace(&mut self.frame, frame));\n                         if delim != DelimToken::NoDelim {\n                             return (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone);\n@@ -286,12 +285,11 @@ impl TokenCursor {\n                     }\n                 };\n             } else if let Some(frame) = self.stack.pop() {\n-                let delim = self.frame.delim;\n-                let span = self.frame.span;\n-                self.frame = frame;\n-                if delim != DelimToken::NoDelim {\n+                if let Some((delim, span)) = self.frame.delim_sp && delim != DelimToken::NoDelim {\n+                    self.frame = frame;\n                     return (Token::new(token::CloseDelim(delim), span.close), Spacing::Alone);\n                 }\n+                self.frame = frame;\n                 // No close delimiter to return; continue on to the next iteration.\n             } else {\n                 return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);\n@@ -330,8 +328,7 @@ impl TokenCursor {\n         self.stack.push(mem::replace(\n             &mut self.frame,\n             TokenCursorFrame::new(\n-                delim_span,\n-                token::NoDelim,\n+                None,\n                 if attr_style == AttrStyle::Inner {\n                     [TokenTree::token(token::Pound, span), TokenTree::token(token::Not, span), body]\n                         .iter()\n@@ -431,10 +428,6 @@ impl<'a> Parser<'a> {\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n     ) -> Self {\n-        // Note: because of the way `TokenCursor::inlined_next` is structured, the `span` and\n-        // `delim` arguments here are never used.\n-        let start_frame = TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens);\n-\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n@@ -444,7 +437,7 @@ impl<'a> Parser<'a> {\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n-                frame: start_frame,\n+                frame: TokenCursorFrame::new(None, tokens),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n@@ -1025,7 +1018,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let frame = &self.token_cursor.frame;\n-        if frame.delim != DelimToken::NoDelim {\n+        if let Some((delim, span)) = frame.delim_sp && delim != DelimToken::NoDelim {\n             let all_normal = (0..dist).all(|i| {\n                 let token = frame.tree_cursor.look_ahead(i);\n                 !matches!(token, Some(TokenTree::Delimited(_, DelimToken::NoDelim, _)))\n@@ -1038,7 +1031,7 @@ impl<'a> Parser<'a> {\n                             looker(&Token::new(token::OpenDelim(*delim), dspan.open))\n                         }\n                     },\n-                    None => looker(&Token::new(token::CloseDelim(frame.delim), frame.span.close)),\n+                    None => looker(&Token::new(token::CloseDelim(delim), span.close)),\n                 };\n             }\n         }\n@@ -1198,8 +1191,7 @@ impl<'a> Parser<'a> {\n                 // Grab the tokens from this frame.\n                 let frame = &self.token_cursor.frame;\n                 let stream = frame.tree_cursor.stream.clone();\n-                let span = frame.span;\n-                let delim = frame.delim;\n+                let (delim, span) = frame.delim_sp.unwrap();\n \n                 // Advance the token cursor through the entire delimited\n                 // sequence. After getting the `OpenDelim` we are *within* the"}, {"sha": "14f1208b71f516c339cf72e8e87bb238700ab153", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -164,25 +164,29 @@ impl<'a> Parser<'a> {\n         let delim = args.delim();\n         let hi = self.prev_token.span;\n \n-        let style =\n-            if delim == token::Brace { MacStmtStyle::Braces } else { MacStmtStyle::NoBraces };\n+        let style = match delim {\n+            Some(token::Brace) => MacStmtStyle::Braces,\n+            Some(_) => MacStmtStyle::NoBraces,\n+            None => unreachable!(),\n+        };\n \n         let mac = MacCall { path, args, prior_type_ascription: self.last_type_ascription };\n \n-        let kind =\n-            if (delim == token::Brace && self.token != token::Dot && self.token != token::Question)\n-                || self.token == token::Semi\n-                || self.token == token::Eof\n-            {\n-                StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n-            } else {\n-                // Since none of the above applied, this is an expression statement macro.\n-                let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n-                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n-                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                StmtKind::Expr(e)\n-            };\n+        let kind = if (style == MacStmtStyle::Braces\n+            && self.token != token::Dot\n+            && self.token != token::Question)\n+            || self.token == token::Semi\n+            || self.token == token::Eof\n+        {\n+            StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n+        } else {\n+            // Since none of the above applied, this is an expression statement macro.\n+            let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n+            let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+            let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+            StmtKind::Expr(e)\n+        };\n         Ok(self.mk_stmt(lo.to(hi), kind))\n     }\n "}, {"sha": "cd724373f4d16292d6ff00cd441a7a9067b42b07", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -1325,7 +1325,7 @@ pub(crate) fn can_be_overflowed_expr(\n         }\n         ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim().unwrap()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)"}, {"sha": "92606902c57894fbed9014d1c6f5b263f99effd2", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80045d65e111568f0fe2f5371a6d0f7d8c81b496/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80045d65e111568f0fe2f5371a6d0f7d8c81b496/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=80045d65e111568f0fe2f5371a6d0f7d8c81b496", "patch": "@@ -562,7 +562,7 @@ fn delim_token_to_str(\n                 (\"{ \", \" }\")\n             }\n         }\n-        DelimToken::NoDelim => (\"\", \"\"),\n+        DelimToken::NoDelim => unreachable!(),\n     };\n     if use_multiple_lines {\n         let indent_str = shape.indent.to_string_with_newline(context.config);"}]}