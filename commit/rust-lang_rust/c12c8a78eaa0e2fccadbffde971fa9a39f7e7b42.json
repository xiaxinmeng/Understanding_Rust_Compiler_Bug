{"sha": "c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMmM4YTc4ZWFhMGUyZmNjYWRiZmZkZTk3MWZhOWEzOWY3ZTdiNDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T14:42:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T15:25:58Z"}, "message": "clean up internals of pointer checks; make get_size_and_align also check for fn allocations", "tree": {"sha": "dcdf6bc18d03d77d15abf5a22d9bffe78912bcdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcdf6bc18d03d77d15abf5a22d9bffe78912bcdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "html_url": "https://github.com/rust-lang/rust/commit/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcc8371d4e0eb2bf3151c6bba71dc3b23fd27688", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc8371d4e0eb2bf3151c6bba71dc3b23fd27688", "html_url": "https://github.com/rust-lang/rust/commit/dcc8371d4e0eb2bf3151c6bba71dc3b23fd27688"}], "stats": {"total": 173, "additions": 69, "deletions": 104}, "files": [{"sha": "49ecfec74bb39af45fffdf645972316e88a8ff94", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "patch": "@@ -6,22 +6,13 @@ use super::{\n \n use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n-use std::{iter, fmt::{self, Display}};\n+use std::iter;\n use crate::mir;\n use std::ops::{Range, Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_macros::HashStable;\n use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-/// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n-/// or also inbounds of a *live* allocation.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum InboundsCheck {\n-    Live,\n-    MaybeDead,\n-}\n-\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation."}, {"sha": "1b294250aa3dca3d409e104c0fa685030a3d1845", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "patch": "@@ -17,10 +17,7 @@ pub use self::error::{\n \n pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};\n \n-pub use self::allocation::{\n-    InboundsCheck, Allocation, AllocationExtra,\n-    Relocations, UndefMask,\n-};\n+pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{Pointer, PointerArithmetic, CheckInAllocMsg};\n "}, {"sha": "a17bc1f67283de750c005d46541b6b87aef0aa41", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "patch": "@@ -1,4 +1,4 @@\n-use std::fmt;\n+use std::fmt::{self, Display};\n \n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};"}, {"sha": "197e067f674ff4198b4036a292413828d03d5001", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 65, "deletions": 88, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "patch": "@@ -19,7 +19,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n+    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n     InterpError::ValidationFailure,\n };\n \n@@ -44,6 +44,17 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n     }\n }\n \n+/// Used by `get_size_and_align` to indicate whether the allocation needs to be live.\n+#[derive(Debug, Copy, Clone)]\n+pub enum AllocCheck {\n+    /// Allocation must be live and not a function pointer.\n+    Dereferencable,\n+    /// Allocations needs to be live, but may be a function pointer.\n+    Live,\n+    /// Allocation may be dead.\n+    MaybeDead,\n+}\n+\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -248,66 +259,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Checks that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n-    /// You can pass a scalar, and a `Pointer` does not have to actually still be allocated.\n-    fn check_align(\n-        &self,\n-        ptr: Scalar<M::PointerTag>,\n-        required_align: Align\n-    ) -> InterpResult<'tcx> {\n-        // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr.to_bits_or_ptr(self.pointer_size(), self) {\n-            Err(ptr) => {\n-                // check this is not NULL -- which we can ensure only if this is in-bounds\n-                // of some (potentially dead) allocation.\n-                let align = self.check_ptr_bounds(ptr, InboundsCheck::MaybeDead,\n-                                                  CheckInAllocMsg::NullPointerTest)?;\n-                (ptr.offset.bytes(), align)\n-            }\n-            Ok(data) => {\n-                // check this is not NULL\n-                if data == 0 {\n-                    return err!(InvalidNullPointerUsage);\n-                }\n-                // the \"base address\" is 0 and hence always aligned\n-                (data as u64, required_align)\n-            }\n-        };\n-        // Check alignment\n-        if alloc_align.bytes() < required_align.bytes() {\n-            return err!(AlignmentCheckFailed {\n-                has: alloc_align,\n-                required: required_align,\n-            });\n-        }\n-        if offset % required_align.bytes() == 0 {\n-            Ok(())\n-        } else {\n-            let has = offset % required_align.bytes();\n-            err!(AlignmentCheckFailed {\n-                has: Align::from_bytes(has).unwrap(),\n-                required: required_align,\n-            })\n-        }\n-    }\n-\n-    /// Checks if the pointer is \"in-bounds\" of *some* (live or dead) allocation. Notice that\n-    /// a pointer pointing at the end of an allocation (i.e., at the first *inaccessible* location)\n-    /// *is* considered in-bounds!  This follows C's/LLVM's rules.\n-    /// `liveness` can be used to rule out dead allocations.  Testing in-bounds with a dead\n-    /// allocation is useful e.g. to exclude the possibility of this pointer being NULL.\n-    /// If you want to check bounds before doing a memory access, call `check_ptr_access`.\n-    fn check_ptr_bounds(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        liveness: InboundsCheck,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx, Align> {\n-        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, liveness)?;\n-        ptr.check_in_alloc(allocation_size, msg)?;\n-        Ok(align)\n-    }\n-\n     /// Check if the given scalar is allowed to do a memory access of given `size`\n     /// and `align`.  On success, returns `None` for zero-sized accesses (where\n     /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n@@ -350,18 +301,35 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 None\n             }\n             Err(ptr) => {\n-                // Test bounds.\n-                self.check_ptr_bounds(\n-                    ptr.offset(size, self)?,\n-                    InboundsCheck::Live,\n-                    CheckInAllocMsg::MemoryAccessTest,\n-                )?;\n-                // Test align and non-NULL.\n-                self.check_align(ptr.into(), align)?;\n-                // FIXME: Alignment check is too strict, depending on the base address that\n-                // got picked we might be aligned even if this check fails.\n-                // We instead have to fall back to converting to an integer and checking\n-                // the \"real\" alignment.\n+                let (allocation_size, alloc_align) =\n+                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferencable)?;\n+                // Test bounds. This also ensures non-NULL.\n+                // It is sufficient to check this for the end pointer. The addition\n+                // checks for overflow.\n+                let end_ptr = ptr.offset(size, self)?;\n+                end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                // Test align.  Check this last; if both bounds and alignment are violated\n+                // we want the error to be about the bounds.\n+                if alloc_align.bytes() < align.bytes() {\n+                    // The allocation itself is not aligned enough.\n+                    // FIXME: Alignment check is too strict, depending on the base address that\n+                    // got picked we might be aligned even if this check fails.\n+                    // We instead have to fall back to converting to an integer and checking\n+                    // the \"real\" alignment.\n+                    return err!(AlignmentCheckFailed {\n+                        has: alloc_align,\n+                        required: align,\n+                    });\n+                }\n+                let offset = ptr.offset.bytes();\n+                if offset % align.bytes() != 0 {\n+                    // The offset os not aligned enough.\n+                    let has = offset % align.bytes();\n+                    return err!(AlignmentCheckFailed {\n+                        has: Align::from_bytes(has).unwrap(),\n+                        required: align,\n+                    })\n+                }\n \n                 // We can still be zero-sized in this branch, in which case we have to\n                 // return `None`.\n@@ -375,8 +343,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<M::PointerTag>,\n     ) -> bool {\n-        self.check_ptr_bounds(ptr, InboundsCheck::MaybeDead, CheckInAllocMsg::NullPointerTest)\n-            .is_err()\n+        let (size, _align) = self.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n+            .expect(\"alloc info with MaybeDead cannot fail\");\n+        ptr.check_in_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n     }\n }\n \n@@ -515,13 +484,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Obtain the size and alignment of an allocation, even if that allocation has been deallocated\n+    /// Obtain the size and alignment of an allocation, even if that allocation has\n+    /// been deallocated.\n     ///\n-    /// If `liveness` is `InboundsCheck::MaybeDead`, this function always returns `Ok`\n+    /// If `liveness` is `AllocCheck::MaybeDead`, this function always returns `Ok`.\n     pub fn get_size_and_align(\n         &self,\n         id: AllocId,\n-        liveness: InboundsCheck,\n+        liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n@@ -531,7 +501,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let alloc = self.tcx.alloc_map.lock().get(id);\n         // Could also be a fn ptr or extern static\n         match alloc {\n-            Some(GlobalAlloc::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n+            Some(GlobalAlloc::Function(..)) => {\n+                if let AllocCheck::Dereferencable = liveness {\n+                    // The caller requested no function pointers.\n+                    err!(DerefFunctionPointer)\n+                } else {\n+                    Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+                }\n+            }\n             // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n@@ -545,15 +522,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 if let Ok(alloc) = self.get(id) {\n                     return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n                 }\n-                match liveness {\n-                    InboundsCheck::MaybeDead => {\n-                        // Must be a deallocated pointer\n-                        self.dead_alloc_map.get(&id).cloned().ok_or_else(||\n-                            ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n-                                .into()\n-                        )\n-                    },\n-                    InboundsCheck::Live => err!(DanglingPointerDeref),\n+                if let AllocCheck::MaybeDead = liveness {\n+                    // Deallocated pointers are allowed, we should be able to find\n+                    // them in the map.\n+                    self.dead_alloc_map.get(&id).copied().ok_or_else(||\n+                        ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n+                            .into()\n+                    )\n+                } else {\n+                    err!(DanglingPointerDeref)\n                 }\n             },\n         }"}, {"sha": "259bd6af0d5d4fe68181f01402b457fe172c839f", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "patch": "@@ -24,7 +24,7 @@ pub use self::eval_context::{\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n-pub use self::memory::{Memory, MemoryKind};\n+pub use self::memory::{Memory, MemoryKind, AllocCheck};\n \n pub use self::machine::{Machine, AllocMap, MayLeak};\n "}]}