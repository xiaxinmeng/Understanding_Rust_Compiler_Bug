{"sha": "176207f1e87bb1f2c70529cdbc66ae8c96584b03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NjIwN2YxZTg3YmIxZjJjNzA1MjljZGJjNjZhZThjOTY1ODRiMDM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-03T11:16:39Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-03T11:30:50Z"}, "message": "Extract built-in trait implementations to separate module\n\nThis untangles the builtin logic from the Chalk translation.", "tree": {"sha": "dca2b8617d47a9fb498c153ae291c5eedffe7dd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dca2b8617d47a9fb498c153ae291c5eedffe7dd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/176207f1e87bb1f2c70529cdbc66ae8c96584b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/176207f1e87bb1f2c70529cdbc66ae8c96584b03", "html_url": "https://github.com/rust-lang/rust/commit/176207f1e87bb1f2c70529cdbc66ae8c96584b03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/176207f1e87bb1f2c70529cdbc66ae8c96584b03/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3376c08052a563a5d2db487c458972378edebf44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3376c08052a563a5d2db487c458972378edebf44", "html_url": "https://github.com/rust-lang/rust/commit/3376c08052a563a5d2db487c458972378edebf44"}], "stats": {"total": 346, "additions": 219, "deletions": 127}, "files": [{"sha": "d49f8fb4b12e349a8c3dbee4419dfd660ec90c63", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/176207f1e87bb1f2c70529cdbc66ae8c96584b03/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176207f1e87bb1f2c70529cdbc66ae8c96584b03/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=176207f1e87bb1f2c70529cdbc66ae8c96584b03", "patch": "@@ -15,6 +15,7 @@ use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty,\n use self::chalk::{from_chalk, ToChalk};\n \n pub(crate) mod chalk;\n+mod builtin;\n \n #[derive(Debug, Clone)]\n pub struct TraitSolver {"}, {"sha": "598fd81e318793dcccaeee5778a03c1a7b019258", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/176207f1e87bb1f2c70529cdbc66ae8c96584b03/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176207f1e87bb1f2c70529cdbc66ae8c96584b03/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=176207f1e87bb1f2c70529cdbc66ae8c96584b03", "patch": "@@ -0,0 +1,161 @@\n+//! This module provides the built-in trait implementations, e.g. to make\n+//! closures implement `Fn`.\n+use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n+use hir_expand::name;\n+use ra_db::CrateId;\n+\n+use super::{AssocTyValue, Impl};\n+use crate::{db::HirDatabase, ApplicationTy, Substs, TraitRef, Ty, TypeCtor};\n+\n+pub(super) struct BuiltinImplData {\n+    pub num_vars: usize,\n+    pub trait_ref: TraitRef,\n+    pub where_clauses: Vec<super::GenericPredicate>,\n+    pub assoc_ty_values: Vec<AssocTyValue>,\n+}\n+\n+pub(super) struct BuiltinImplAssocTyValueData {\n+    pub impl_: Impl,\n+    pub assoc_ty_id: TypeAliasId,\n+    pub num_vars: usize,\n+    pub value: Ty,\n+}\n+\n+pub(super) fn get_builtin_impls(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    ty: &Ty,\n+    trait_: TraitId,\n+    mut callback: impl FnMut(Impl),\n+) {\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n+        for &fn_trait in [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n+        {\n+            if let Some(actual_trait) = get_fn_trait(db, krate, fn_trait) {\n+                if trait_ == actual_trait {\n+                    let impl_ = super::ClosureFnTraitImplData { def: *def, expr: *expr, fn_trait };\n+                    callback(Impl::ClosureFnTraitImpl(impl_));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn impl_datum(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    impl_: Impl,\n+) -> Option<BuiltinImplData> {\n+    match impl_ {\n+        Impl::ImplBlock(_) => unreachable!(),\n+        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n+    }\n+}\n+\n+pub(super) fn associated_ty_value(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: AssocTyValue,\n+) -> BuiltinImplAssocTyValueData {\n+    match data {\n+        AssocTyValue::TypeAlias(_) => unreachable!(),\n+        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n+            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n+        }\n+    }\n+}\n+\n+fn closure_fn_trait_impl_datum(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> Option<BuiltinImplData> {\n+    // for some closure |X, Y| -> Z:\n+    // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n+\n+    let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n+\n+    // validate FnOnce trait, since we need it in the assoc ty value definition\n+    // and don't want to return a valid value only to find out later that FnOnce\n+    // is broken\n+    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n+    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n+\n+    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n+        Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let arg_ty = Ty::apply(\n+        TypeCtor::Tuple { cardinality: num_args },\n+        Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n+    );\n+    let sig_ty = Ty::apply(\n+        TypeCtor::FnPtr { num_args },\n+        Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n+    );\n+\n+    let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n+\n+    let trait_ref = TraitRef {\n+        trait_: trait_.into(),\n+        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n+    };\n+\n+    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone());\n+\n+    Some(BuiltinImplData {\n+        num_vars: num_args as usize + 1,\n+        trait_ref,\n+        where_clauses: Vec::new(),\n+        assoc_ty_values: vec![output_ty_id],\n+    })\n+}\n+\n+fn closure_fn_trait_output_assoc_ty_value(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> BuiltinImplAssocTyValueData {\n+    let impl_ = Impl::ClosureFnTraitImpl(data.clone());\n+\n+    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n+        Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let output_ty = Ty::Bound(num_args.into());\n+\n+    let fn_once_trait =\n+        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n+\n+    let output_ty_id = db\n+        .trait_data(fn_once_trait)\n+        .associated_type_by_name(&name::OUTPUT_TYPE)\n+        .expect(\"assoc ty value should not exist\");\n+\n+    BuiltinImplAssocTyValueData {\n+        impl_,\n+        assoc_ty_id: output_ty_id,\n+        num_vars: num_args as usize + 1,\n+        value: output_ty,\n+    }\n+}\n+\n+fn get_fn_trait(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    fn_trait: super::FnTrait,\n+) -> Option<TraitId> {\n+    let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n+    match target {\n+        LangItemTarget::TraitId(t) => Some(t),\n+        _ => None,\n+    }\n+}"}, {"sha": "e3f02fa1563edcc7899ecf02c8c13351767bf3ab", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 57, "deletions": 127, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/176207f1e87bb1f2c70529cdbc66ae8c96584b03/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176207f1e87bb1f2c70529cdbc66ae8c96584b03/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=176207f1e87bb1f2c70529cdbc66ae8c96584b03", "patch": "@@ -8,17 +8,16 @@ use chalk_ir::{\n     TypeName, UniverseIndex,\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n-use ra_db::CrateId;\n \n use hir_def::{\n-    expr::Expr, lang_item::LangItemTarget, AssocItemId, AstItemDef, ContainerId, GenericDefId,\n-    ImplId, Lookup, TraitId, TypeAliasId,\n+    AssocItemId, AstItemDef, ContainerId, GenericDefId, ImplId, Lookup, TraitId, TypeAliasId,\n+};\n+use ra_db::{\n+    salsa::{InternId, InternKey},\n+    CrateId,\n };\n-use hir_expand::name;\n-\n-use ra_db::salsa::{InternId, InternKey};\n \n-use super::{AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n+use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase, display::HirDisplay, ApplicationTy, GenericPredicate, ProjectionTy, Substs,\n     TraitRef, Ty, TypeCtor, TypeWalk,\n@@ -395,6 +394,51 @@ where\n     }\n }\n \n+impl ToChalk for builtin::BuiltinImplData {\n+    type Chalk = chalk_rust_ir::ImplDatum<ChalkIr>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::ImplDatum<ChalkIr> {\n+        let impl_type = chalk_rust_ir::ImplType::External;\n+        let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n+\n+        let impl_datum_bound =\n+            chalk_rust_ir::ImplDatumBound { trait_ref: self.trait_ref.to_chalk(db), where_clauses };\n+        let associated_ty_value_ids =\n+            self.assoc_ty_values.into_iter().map(|v| v.to_chalk(db)).collect();\n+        chalk_rust_ir::ImplDatum {\n+            binders: make_binders(impl_datum_bound, self.num_vars),\n+            impl_type,\n+            polarity: chalk_rust_ir::Polarity::Positive,\n+            associated_ty_value_ids,\n+        }\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, _data: chalk_rust_ir::ImplDatum<ChalkIr>) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n+    type Chalk = chalk_rust_ir::AssociatedTyValue<ChalkIr>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValue<ChalkIr> {\n+        let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: self.value.to_chalk(db) };\n+\n+        chalk_rust_ir::AssociatedTyValue {\n+            associated_ty_id: self.assoc_ty_id.to_chalk(db),\n+            impl_id: self.impl_.to_chalk(db),\n+            value: make_binders(value_bound, self.num_vars),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        _db: &impl HirDatabase,\n+        _data: chalk_rust_ir::AssociatedTyValue<ChalkIr>,\n+    ) -> builtin::BuiltinImplAssocTyValueData {\n+        unimplemented!()\n+    }\n+}\n+\n fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n     chalk_ir::Binders {\n         value,\n@@ -456,18 +500,10 @@ where\n             .collect();\n \n         let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref().clone());\n-        if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n-            for &fn_trait in\n-                [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n-            {\n-                if let Some(actual_trait) = get_fn_trait(self.db, self.krate, fn_trait) {\n-                    if trait_ == actual_trait {\n-                        let impl_ = super::ClosureFnTraitImplData { def, expr, fn_trait };\n-                        result.push(Impl::ClosureFnTraitImpl(impl_).to_chalk(self.db));\n-                    }\n-                }\n-            }\n-        }\n+\n+        builtin::get_builtin_impls(self.db, self.krate, &ty, trait_, |i| {\n+            result.push(i.to_chalk(self.db))\n+        });\n \n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n@@ -619,7 +655,7 @@ pub(crate) fn impl_datum_query(\n     let impl_: Impl = from_chalk(db, impl_id);\n     match impl_ {\n         Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n-        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n+        _ => builtin::impl_datum(db, krate, impl_).map(|d| Arc::new(d.to_chalk(db))),\n     }\n     .unwrap_or_else(invalid_impl_datum)\n }\n@@ -700,63 +736,6 @@ fn invalid_impl_datum() -> Arc<ImplDatum<ChalkIr>> {\n     Arc::new(impl_datum)\n }\n \n-fn closure_fn_trait_impl_datum(\n-    db: &impl HirDatabase,\n-    krate: CrateId,\n-    data: super::ClosureFnTraitImplData,\n-) -> Option<Arc<ImplDatum<ChalkIr>>> {\n-    // for some closure |X, Y| -> Z:\n-    // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n-\n-    let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n-\n-    // validate FnOnce trait, since we need it in the assoc ty value definition\n-    // and don't want to return a valid value only to find out later that FnOnce\n-    // is broken\n-    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n-\n-    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n-        Expr::Lambda { args, .. } => args.len() as u16,\n-        _ => {\n-            log::warn!(\"closure for closure type {:?} not found\", data);\n-            0\n-        }\n-    };\n-\n-    let arg_ty = Ty::apply(\n-        TypeCtor::Tuple { cardinality: num_args },\n-        Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n-    );\n-    let sig_ty = Ty::apply(\n-        TypeCtor::FnPtr { num_args },\n-        Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n-    );\n-\n-    let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n-\n-    let trait_ref = TraitRef {\n-        trait_: trait_.into(),\n-        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n-    };\n-\n-    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone()).to_chalk(db);\n-\n-    let impl_type = chalk_rust_ir::ImplType::External;\n-\n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-        trait_ref: trait_ref.to_chalk(db),\n-        where_clauses: Vec::new(),\n-    };\n-    let impl_datum = ImplDatum {\n-        binders: make_binders(impl_datum_bound, num_args as usize + 1),\n-        impl_type,\n-        polarity: chalk_rust_ir::Polarity::Positive,\n-        associated_ty_value_ids: vec![output_ty_id],\n-    };\n-    Some(Arc::new(impl_datum))\n-}\n-\n pub(crate) fn associated_ty_value_query(\n     db: &impl HirDatabase,\n     krate: CrateId,\n@@ -767,9 +746,7 @@ pub(crate) fn associated_ty_value_query(\n         AssocTyValue::TypeAlias(type_alias) => {\n             type_alias_associated_ty_value(db, krate, type_alias)\n         }\n-        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n-            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n-        }\n+        _ => Arc::new(builtin::associated_ty_value(db, krate, data).to_chalk(db)),\n     }\n }\n \n@@ -802,53 +779,6 @@ fn type_alias_associated_ty_value(\n     Arc::new(value)\n }\n \n-fn closure_fn_trait_output_assoc_ty_value(\n-    db: &impl HirDatabase,\n-    krate: CrateId,\n-    data: super::ClosureFnTraitImplData,\n-) -> Arc<AssociatedTyValue<ChalkIr>> {\n-    let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n-\n-    let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n-        Expr::Lambda { args, .. } => args.len() as u16,\n-        _ => {\n-            log::warn!(\"closure for closure type {:?} not found\", data);\n-            0\n-        }\n-    };\n-\n-    let output_ty = Ty::Bound(num_args.into());\n-\n-    let fn_once_trait =\n-        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n-\n-    let output_ty_id = db\n-        .trait_data(fn_once_trait)\n-        .associated_type_by_name(&name::OUTPUT_TYPE)\n-        .expect(\"assoc ty value should not exist\");\n-\n-    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n-\n-    let value = chalk_rust_ir::AssociatedTyValue {\n-        associated_ty_id: output_ty_id.to_chalk(db),\n-        impl_id,\n-        value: make_binders(value_bound, num_args as usize + 1),\n-    };\n-    Arc::new(value)\n-}\n-\n-fn get_fn_trait(\n-    db: &impl HirDatabase,\n-    krate: CrateId,\n-    fn_trait: super::FnTrait,\n-) -> Option<TraitId> {\n-    let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n-    match target {\n-        LangItemTarget::TraitId(t) => Some(t),\n-        _ => None,\n-    }\n-}\n-\n fn id_from_chalk<T: InternKey>(chalk_id: chalk_ir::RawId) -> T {\n     T::from_intern_id(InternId::from(chalk_id.index))\n }"}]}