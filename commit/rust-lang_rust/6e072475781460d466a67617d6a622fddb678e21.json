{"sha": "6e072475781460d466a67617d6a622fddb678e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMDcyNDc1NzgxNDYwZDQ2NmE2NzYxN2Q2YTYyMmZkZGI2NzhlMjE=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-09-21T13:11:24Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-09-21T13:11:24Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "10b2c3187e055651e98b3e1e35dbb5390f861c56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10b2c3187e055651e98b3e1e35dbb5390f861c56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e072475781460d466a67617d6a622fddb678e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e072475781460d466a67617d6a622fddb678e21", "html_url": "https://github.com/rust-lang/rust/commit/6e072475781460d466a67617d6a622fddb678e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e072475781460d466a67617d6a622fddb678e21/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "141b9c28901fd80da028a984eca2af4e7218a09a", "url": "https://api.github.com/repos/rust-lang/rust/commits/141b9c28901fd80da028a984eca2af4e7218a09a", "html_url": "https://github.com/rust-lang/rust/commit/141b9c28901fd80da028a984eca2af4e7218a09a"}, {"sha": "d88b9b7543756afef81dcb2e2c37a11603d513d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d88b9b7543756afef81dcb2e2c37a11603d513d5", "html_url": "https://github.com/rust-lang/rust/commit/d88b9b7543756afef81dcb2e2c37a11603d513d5"}], "stats": {"total": 3381, "additions": 2744, "deletions": 637}, "files": [{"sha": "5a84333d6db5915940b8e038d43bf278769a5ad6", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1672,10 +1672,12 @@ Released 2018-09-13\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n+[`map_err_ignore`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_err_ignore\n [`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n [`map_identity`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_identity\n [`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or\n@@ -1755,6 +1757,7 @@ Released 2018-09-13\n [`out_of_bounds_indexing`]: https://rust-lang.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional\n [`panic`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic\n+[`panic_in_result_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_in_result_fn\n [`panic_params`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_params\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl"}, {"sha": "100c9edb367241450780bd3fc27bb1d234db97f4", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -8,7 +8,7 @@ something. We appreciate any sort of contributions, and don't want a wall of rul\n \n Clippy welcomes contributions from everyone. There are many ways to contribute to Clippy and the following document\n explains how you can contribute and how to get started.  If you have any questions about contributing or need help with\n-anything, feel free to ask questions on issues or visit the `#clippy` on [Discord].\n+anything, feel free to ask questions on issues or visit the `#clippy` on [Zulip].\n \n All contributors are expected to follow the [Rust Code of Conduct].\n \n@@ -23,7 +23,7 @@ All contributors are expected to follow the [Rust Code of Conduct].\n   - [Bors and Homu](#bors-and-homu)\n   - [Contributions](#contributions)\n \n-[Discord]: https://discord.gg/rust-lang\n+[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/clippy\n [Rust Code of Conduct]: https://www.rust-lang.org/policies/code-of-conduct\n \n ## Getting started\n@@ -242,7 +242,7 @@ to be run inside the `rust` directory):\n     ```\n 3. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n    accelerate the process ping the `@rust-lang/clippy` team in your PR and/or\n-   ~~annoy~~ ask them in the [Discord] channel.)\n+   ~~annoy~~ ask them in the [Zulip] stream.)\n    \n ### Syncing back changes in Clippy to [`rust-lang/rust`]\n "}, {"sha": "c67efc10f15783d28e3ad5e3443e48a96a33a2b6", "filename": "clippy_dev/src/ra_setup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_dev%2Fsrc%2Fra_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_dev%2Fsrc%2Fra_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fra_setup.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -14,7 +14,7 @@ pub fn run(rustc_path: Option<&str>) {\n     // we can unwrap here because the arg is required here\n     let rustc_path = PathBuf::from(rustc_path.unwrap());\n     assert!(rustc_path.is_dir(), \"path is not a directory\");\n-    let rustc_source_basedir = rustc_path.join(\"src\");\n+    let rustc_source_basedir = rustc_path.join(\"compiler\");\n     assert!(\n         rustc_source_basedir.is_dir(),\n         \"are you sure the path leads to a rustc repo?\"\n@@ -61,7 +61,7 @@ fn inject_deps_into_manifest(\n     let new_deps = extern_crates.map(|dep| {\n         // format the dependencies that are going to be put inside the Cargo.toml\n         format!(\n-            \"{dep} = {{ path = \\\"{source_path}/lib{dep}\\\" }}\\n\",\n+            \"{dep} = {{ path = \\\"{source_path}/{dep}\\\" }}\\n\",\n             dep = dep,\n             source_path = rustc_source_dir.display()\n         )"}, {"sha": "341d9e601ee6fe656946bda93fbc367b5a2bf1f4", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -21,7 +21,7 @@ cargo_metadata = \"0.11.1\"\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n lazy_static = \"1.0.2\"\n-pulldown-cmark = { version = \"0.7.1\", default-features = false }\n+pulldown-cmark = { version = \"0.8\", default-features = false }\n quine-mc_cluskey = \"0.2.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "703d8a6f62bb1f07ab305dfec36e32097d10f070", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 100, "deletions": 6, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -8,7 +8,8 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of invalid atomic\n-    /// ordering in atomic loads/stores and memory fences.\n+    /// ordering in atomic loads/stores/exchanges/updates and\n+    /// memory fences.\n     ///\n     /// **Why is this bad?** Using an invalid atomic ordering\n     /// will cause a panic at run-time.\n@@ -17,22 +18,35 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,no_run\n-    /// # use std::sync::atomic::{self, AtomicBool, Ordering};\n+    /// # use std::sync::atomic::{self, AtomicU8, Ordering};\n     ///\n-    /// let x = AtomicBool::new(true);\n+    /// let x = AtomicU8::new(0);\n     ///\n+    /// // Bad: `Release` and `AcqRel` cannot be used for `load`.\n     /// let _ = x.load(Ordering::Release);\n     /// let _ = x.load(Ordering::AcqRel);\n     ///\n-    /// x.store(false, Ordering::Acquire);\n-    /// x.store(false, Ordering::AcqRel);\n+    /// // Bad: `Acquire` and `AcqRel` cannot be used for `store`.\n+    /// x.store(1, Ordering::Acquire);\n+    /// x.store(2, Ordering::AcqRel);\n     ///\n+    /// // Bad: `Relaxed` cannot be used as a fence's ordering.\n     /// atomic::fence(Ordering::Relaxed);\n     /// atomic::compiler_fence(Ordering::Relaxed);\n+    ///\n+    /// // Bad: `Release` and `AcqRel` are both always invalid\n+    /// // for the failure ordering (the last arg).\n+    /// let _ = x.compare_exchange(1, 2, Ordering::SeqCst, Ordering::Release);\n+    /// let _ = x.compare_exchange_weak(2, 3, Ordering::AcqRel, Ordering::AcqRel);\n+    ///\n+    /// // Bad: The failure ordering is not allowed to be\n+    /// // stronger than the success order, and `SeqCst` is\n+    /// // stronger than `Relaxed`.\n+    /// let _ = x.fetch_update(Ordering::Relaxed, Ordering::SeqCst, |val| Some(val + val));\n     /// ```\n     pub INVALID_ATOMIC_ORDERING,\n     correctness,\n-    \"usage of invalid atomic ordering in atomic loads/stores and memory fences\"\n+    \"usage of invalid atomic ordering in atomic operations and memory fences\"\n }\n \n declare_lint_pass!(AtomicOrdering => [INVALID_ATOMIC_ORDERING]);\n@@ -127,9 +141,89 @@ fn check_memory_fence(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n }\n \n+fn opt_ordering_defid(cx: &LateContext<'_>, ord_arg: &Expr<'_>) -> Option<DefId> {\n+    if let ExprKind::Path(ref ord_qpath) = ord_arg.kind {\n+        cx.qpath_res(ord_qpath, ord_arg.hir_id).opt_def_id()\n+    } else {\n+        None\n+    }\n+}\n+\n+fn check_atomic_compare_exchange(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n+        let method = method_path.ident.name.as_str();\n+        if type_is_atomic(cx, &args[0]);\n+        if method == \"compare_exchange\" || method == \"compare_exchange_weak\" || method == \"fetch_update\";\n+        let (success_order_arg, failure_order_arg) = if method == \"fetch_update\" {\n+            (&args[1], &args[2])\n+        } else {\n+            (&args[3], &args[4])\n+        };\n+        if let Some(fail_ordering_def_id) = opt_ordering_defid(cx, failure_order_arg);\n+        then {\n+            // Helper type holding on to some checking and error reporting data. Has\n+            // - (success ordering name,\n+            // - list of failure orderings forbidden by the success order,\n+            // - suggestion message)\n+            type OrdLintInfo = (&'static str, &'static [&'static str], &'static str);\n+            let relaxed: OrdLintInfo = (\"Relaxed\", &[\"SeqCst\", \"Acquire\"], \"ordering mode `Relaxed`\");\n+            let acquire: OrdLintInfo = (\"Acquire\", &[\"SeqCst\"], \"ordering modes `Acquire` or `Relaxed`\");\n+            let seq_cst: OrdLintInfo = (\"SeqCst\", &[], \"ordering modes `Acquire`, `SeqCst` or `Relaxed`\");\n+            let release = (\"Release\", relaxed.1, relaxed.2);\n+            let acqrel = (\"AcqRel\", acquire.1, acquire.2);\n+            let search = [relaxed, acquire, seq_cst, release, acqrel];\n+\n+            let success_lint_info = opt_ordering_defid(cx, success_order_arg)\n+                .and_then(|success_ord_def_id| -> Option<OrdLintInfo> {\n+                    search\n+                        .iter()\n+                        .find(|(ordering, ..)| {\n+                            match_def_path(cx, success_ord_def_id,\n+                                &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering])\n+                        })\n+                        .copied()\n+                });\n+\n+            if match_ordering_def_path(cx, fail_ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n+                // If we don't know the success order is, use what we'd suggest\n+                // if it were maximally permissive.\n+                let suggested = success_lint_info.unwrap_or(seq_cst).2;\n+                span_lint_and_help(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    failure_order_arg.span,\n+                    &format!(\n+                        \"{}'s failure ordering may not be `Release` or `AcqRel`\",\n+                        method,\n+                    ),\n+                    None,\n+                    &format!(\"consider using {} instead\", suggested),\n+                );\n+            } else if let Some((success_ord_name, bad_ords_given_success, suggested)) = success_lint_info {\n+                if match_ordering_def_path(cx, fail_ordering_def_id, bad_ords_given_success) {\n+                    span_lint_and_help(\n+                        cx,\n+                        INVALID_ATOMIC_ORDERING,\n+                        failure_order_arg.span,\n+                        &format!(\n+                            \"{}'s failure ordering may not be stronger than the success ordering of `{}`\",\n+                            method,\n+                            success_ord_name,\n+                        ),\n+                        None,\n+                        &format!(\"consider using {} instead\", suggested),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for AtomicOrdering {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         check_atomic_load_store(cx, expr);\n         check_memory_fence(cx, expr);\n+        check_atomic_compare_exchange(cx, expr);\n     }\n }"}, {"sha": "367534499fd020665de7e1efda36a2d0742d3005", "filename": "clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -10,7 +10,7 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for calls to await while holding a\n     /// non-async-aware MutexGuard.\n     ///\n-    /// **Why is this bad?** The Mutex types found in syd::sync and parking_lot\n+    /// **Why is this bad?** The Mutex types found in std::sync and parking_lot\n     /// are not designed to operate in an async context across await points.\n     ///\n     /// There are two potential solutions. One is to use an asynx-aware Mutex"}, {"sha": "a4ee54076ee98fc74b41f5fe67aa7d21e5dfcfed", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -90,7 +90,7 @@ declare_clippy_lint! {\n     /// if x & 0b1111 == 0 { }\n     /// ```\n     pub VERBOSE_BIT_MASK,\n-    style,\n+    pedantic,\n     \"expressions where a bit mask is less readable than the corresponding method call\"\n }\n "}, {"sha": "d7d02ebf985c81ae602d8c6e78eaf5fc1bb94b8d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,6 +1,5 @@\n use crate::utils::{\n-    contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability,\n-    span_lint_and_sugg, walk_ptrs_ty,\n+    contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::UintTy;\n@@ -53,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                     if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n                     if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n-                               walk_ptrs_ty(cx.typeck_results().expr_ty(&filter_args[0])),\n+                               cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n                                &paths::SLICE_ITER);\n                     then {\n                         let needle = match get_path_name(l) {\n@@ -63,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != *walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind() {\n+                        if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) ="}, {"sha": "62bb70af06e937e2e4522b6886d5d411706c670e", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -534,7 +534,7 @@ fn check_word(cx: &LateContext<'_>, word: &str, span: Span) {\n             return false;\n         }\n \n-        let s = if s.ends_with('s') { &s[..s.len() - 1] } else { s };\n+        let s = s.strip_suffix('s').unwrap_or(s);\n \n         s.chars().all(char::is_alphanumeric)\n             && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1"}, {"sha": "c0529a34cc411ed5fca26c63b8e4e0eefcca2b5d", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Spanned;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n-            if match_type(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0])), &paths::DURATION);\n+            if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {"}, {"sha": "35a5d00f4aa5ae6764c4501af5f52ce3afff05d1", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::SpanlessEq;\n use crate::utils::{get_item_name, higher, is_type_diagnostic_item, match_type, paths, snippet, snippet_opt};\n-use crate::utils::{snippet_with_applicability, span_lint_and_then, walk_ptrs_ty};\n+use crate::utils::{snippet_with_applicability, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n@@ -106,7 +106,7 @@ fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n         then {\n             let map = &params[0];\n-            let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(map));\n+            let obj_ty = cx.typeck_results().expr_ty(map).peel_refs();\n \n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))"}, {"sha": "a9e05fddbe7625dc7dc98d74dd39679c034982bf", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,7 +1,5 @@\n use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT};\n-use crate::utils::{\n-    is_expn_of, is_type_diagnostic_item, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty,\n-};\n+use crate::utils::{is_expn_of, is_type_diagnostic_item, match_def_path, method_chain_args, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -96,7 +94,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+                let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n                 if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n                     || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n                 {"}, {"sha": "d6541010bca2326691b8b3e961f14f2bdb77db3f", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::paths;\n use crate::utils::{\n     is_expn_of, is_type_diagnostic_item, last_path_segment, match_def_path, match_function_call, snippet,\n-    span_lint_and_then, walk_ptrs_ty,\n+    span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -90,7 +90,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n-            let ty = walk_ptrs_ty(cx.typeck_results().pat_ty(&pats[0]));\n+            let ty = cx.typeck_results().pat_ty(&pats[0]).peel_refs();\n             if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n                 return None;\n             }"}, {"sha": "741195f3b10d5eee8f1da6577ec18919b95574b3", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n-            let ty = cx.typeck_results().expr_ty(array);\n+            let ty = cx.typeck_results().expr_ty(array).peel_refs();\n             if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind() {"}, {"sha": "0877b44d90138a3bbfe0bbf0b4d7bbfa82a3dc13", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -5,7 +5,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::{\n     get_trait_def_id, implements_trait, is_type_diagnostic_item, paths, return_ty, span_lint_and_help,\n-    trait_ref_of_method, walk_ptrs_ty,\n+    trait_ref_of_method,\n };\n \n declare_clippy_lint! {\n@@ -125,7 +125,7 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n     // Get the real type of 'self'\n     let fn_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n     let self_type = cx.tcx.fn_sig(fn_def_id).input(0);\n-    let self_type = walk_ptrs_ty(self_type.skip_binder());\n+    let self_type = self_type.skip_binder().peel_refs();\n \n     // Emit either a warning or an error\n     if implements_trait(cx, self_type, display_trait_id, &[]) {"}, {"sha": "c9c4891bb08acf67f4161184424f50b4ac486ea8", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg};\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -285,7 +285,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         })\n     }\n \n-    let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n+    let ty = &cx.typeck_results().expr_ty(expr).peel_refs();\n     match ty.kind() {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx"}, {"sha": "a6313127f6911171cf7950e8caa0fe5685efc4fb", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -230,7 +230,9 @@ mod macro_use;\n mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n+mod manual_strip;\n mod map_clone;\n+mod map_err_ignore;\n mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n@@ -269,6 +271,7 @@ mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n mod overflow_check_conditional;\n+mod panic_in_result_fn;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n mod path_buf_push_overwrite;\n@@ -625,7 +628,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &main_recursion::MAIN_RECURSION,\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n+        &manual_strip::MANUAL_STRIP,\n         &map_clone::MAP_CLONE,\n+        &map_err_ignore::MAP_ERR_IGNORE,\n         &map_identity::MAP_IDENTITY,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -751,6 +756,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &option_env_unwrap::OPTION_ENV_UNWRAP,\n         &option_if_let_else::OPTION_IF_LET_ELSE,\n         &overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n+        &panic_in_result_fn::PANIC_IN_RESULT_FN,\n         &panic_unimplemented::PANIC,\n         &panic_unimplemented::PANIC_PARAMS,\n         &panic_unimplemented::TODO,\n@@ -863,6 +869,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n         &utils::internal_lints::DEFAULT_LINT,\n         &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+        &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n         &utils::internal_lints::PRODUCE_ICE,\n         &vec::USELESS_VEC,\n@@ -918,6 +925,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n     store.register_late_pass(|| box methods::Methods);\n     store.register_late_pass(|| box map_clone::MapClone);\n+    store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n     store.register_late_pass(|| box shadow::Shadow);\n     store.register_late_pass(|| box types::LetUnitValue);\n     store.register_late_pass(|| box types::UnitCmp);\n@@ -1091,6 +1099,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n     store.register_early_pass(|| box redundant_field_names::RedundantFieldNames);\n     store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n+    store.register_late_pass(|| box panic_in_result_fn::PanicInResultFn);\n+\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold,\n@@ -1105,6 +1115,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n+    store.register_late_pass(|| box manual_strip::ManualStrip);\n+    store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1135,6 +1147,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n         LintId::of(&missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n         LintId::of(&modulo_arithmetic::MODULO_ARITHMETIC),\n+        LintId::of(&panic_in_result_fn::PANIC_IN_RESULT_FN),\n         LintId::of(&panic_unimplemented::PANIC),\n         LintId::of(&panic_unimplemented::TODO),\n         LintId::of(&panic_unimplemented::UNIMPLEMENTED),\n@@ -1152,6 +1165,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n         LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n+        LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n@@ -1180,6 +1194,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_INTO_ITER_LOOP),\n         LintId::of(&loops::EXPLICIT_ITER_LOOP),\n         LintId::of(&macro_use::MACRO_USE_IMPORTS),\n+        LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n@@ -1230,6 +1245,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n+        LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n         LintId::of(&utils::internal_lints::PRODUCE_ICE),\n     ]);\n@@ -1249,7 +1265,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n-        LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&booleans::LOGIC_BUG),\n@@ -1330,6 +1345,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n+        LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n@@ -1507,7 +1523,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n         LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n-        LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n@@ -1622,6 +1637,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::WHILE_LET_LOOP),\n+        LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),"}, {"sha": "3410341a1e3c5056aacfc16bffd2344bcf98e23b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1114,7 +1114,7 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n             if let Some(self_expr) = args.get(0);\n             if let Some(pushed_item) = args.get(1);\n             // Check that the method being called is push() on a Vec\n-            if match_type(cx, cx.typeck_results().expr_ty(self_expr), &paths::VEC);\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym!(vec_type));\n             if path.ident.name.as_str() == \"push\";\n             then {\n                 return Some((self_expr, pushed_item))\n@@ -2601,11 +2601,9 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         |diag| {\n-                            let (arg, pred) = if contains_arg.starts_with('&') {\n-                                (\"x\", &contains_arg[1..])\n-                            } else {\n-                                (\"&x\", &*contains_arg)\n-                            };\n+                            let (arg, pred) = contains_arg\n+                                    .strip_prefix('&')\n+                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n                             diag.span_suggestion(\n                                 span,\n                                 \"replace with\","}, {"sha": "4afb0ab3badb06a1a20e4d6678153192a17855d1", "filename": "clippy_lints/src/manual_strip.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,245 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{\n+    eq_expr_value, higher, match_def_path, multispan_sugg, paths, qpath_res, snippet, span_lint_and_then,\n+};\n+\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::BinOpKind;\n+use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing using\n+    /// the pattern's length.\n+    ///\n+    /// **Why is this bad?**\n+    /// Using `str:strip_{prefix,suffix}` is safer and may have better performance as there is no\n+    /// slicing which may panic and the compiler does not need to insert this panic code. It is\n+    /// also sometimes more readable as it removes the need for duplicating or storing the pattern\n+    /// used by `str::{starts,ends}_with` and in the slicing.\n+    ///\n+    /// **Known problems:**\n+    /// None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let s = \"hello, world!\";\n+    /// if s.starts_with(\"hello, \") {\n+    ///     assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let s = \"hello, world!\";\n+    /// if let Some(end) = s.strip_prefix(\"hello, \") {\n+    ///     assert_eq!(end.to_uppercase(), \"WORLD!\");\n+    /// }\n+    /// ```\n+    pub MANUAL_STRIP,\n+    complexity,\n+    \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\"\n+}\n+\n+declare_lint_pass!(ManualStrip => [MANUAL_STRIP]);\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+enum StripKind {\n+    Prefix,\n+    Suffix,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let Some((cond, then, _)) = higher::if_block(&expr);\n+            if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n+            if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n+            if let ExprKind::Path(target_path) = &target_arg.kind;\n+            then {\n+                let strip_kind = if match_def_path(cx, method_def_id, &paths::STR_STARTS_WITH) {\n+                    StripKind::Prefix\n+                } else if match_def_path(cx, method_def_id, &paths::STR_ENDS_WITH) {\n+                    StripKind::Suffix\n+                } else {\n+                    return;\n+                };\n+                let target_res = qpath_res(cx, &target_path, target_arg.hir_id);\n+                if target_res == Res::Err {\n+                    return;\n+                };\n+\n+                if_chain! {\n+                    if let Res::Local(hir_id) = target_res;\n+                    if let Some(used_mutably) = mutated_variables(then, cx);\n+                    if used_mutably.contains(&hir_id);\n+                    then {\n+                        return;\n+                    }\n+                }\n+\n+                let strippings = find_stripping(cx, strip_kind, target_res, pattern, then);\n+                if !strippings.is_empty() {\n+\n+                    let kind_word = match strip_kind {\n+                        StripKind::Prefix => \"prefix\",\n+                        StripKind::Suffix => \"suffix\",\n+                    };\n+\n+                    let test_span = expr.span.until(then.span);\n+                    span_lint_and_then(cx, MANUAL_STRIP, strippings[0], &format!(\"stripping a {} manually\", kind_word), |diag| {\n+                        diag.span_note(test_span, &format!(\"the {} was tested here\", kind_word));\n+                        multispan_sugg(\n+                            diag,\n+                            &format!(\"try using the `strip_{}` method\", kind_word),\n+                            vec![(test_span,\n+                                  format!(\"if let Some(<stripped>) = {}.strip_{}({}) \",\n+                                          snippet(cx, target_arg.span, \"..\"),\n+                                          kind_word,\n+                                          snippet(cx, pattern.span, \"..\")))]\n+                            .into_iter().chain(strippings.into_iter().map(|span| (span, \"<stripped>\".into()))),\n+                        )\n+                    });\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns `Some(arg)` if `expr` matches `arg.len()` and `None` otherwise.\n+fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, [arg], _) = expr.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if match_def_path(cx, method_def_id, &paths::STR_LEN);\n+        then {\n+            Some(arg)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Returns the length of the `expr` if it's a constant string or char.\n+fn constant_length(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n+    let (value, _) = constant(cx, cx.typeck_results(), expr)?;\n+    match value {\n+        Constant::Str(value) => Some(value.len() as u128),\n+        Constant::Char(value) => Some(value.len_utf8() as u128),\n+        _ => None,\n+    }\n+}\n+\n+// Tests if `expr` equals the length of the pattern.\n+fn eq_pattern_length<'tcx>(cx: &LateContext<'tcx>, pattern: &Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+    if let ExprKind::Lit(Spanned {\n+        node: LitKind::Int(n, _),\n+        ..\n+    }) = expr.kind\n+    {\n+        constant_length(cx, pattern).map_or(false, |length| length == n)\n+    } else {\n+        len_arg(cx, expr).map_or(false, |arg| eq_expr_value(cx, pattern, arg))\n+    }\n+}\n+\n+// Tests if `expr` is a `&str`.\n+fn is_ref_str(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    match cx.typeck_results().expr_ty_adjusted(&expr).kind() {\n+        ty::Ref(_, ty, _) => ty.is_str(),\n+        _ => false,\n+    }\n+}\n+\n+// Removes the outer `AddrOf` expression if needed.\n+fn peel_ref<'a>(expr: &'a Expr<'_>) -> &'a Expr<'a> {\n+    if let ExprKind::AddrOf(BorrowKind::Ref, _, unref) = &expr.kind {\n+        unref\n+    } else {\n+        expr\n+    }\n+}\n+\n+// Find expressions where `target` is stripped using the length of `pattern`.\n+// We'll suggest replacing these expressions with the result of the `strip_{prefix,suffix}`\n+// method.\n+fn find_stripping<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    strip_kind: StripKind,\n+    target: Res,\n+    pattern: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> Vec<Span> {\n+    struct StrippingFinder<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        strip_kind: StripKind,\n+        target: Res,\n+        pattern: &'tcx Expr<'tcx>,\n+        results: Vec<Span>,\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'tcx> for StrippingFinder<'a, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+            if_chain! {\n+                if is_ref_str(self.cx, ex);\n+                let unref = peel_ref(ex);\n+                if let ExprKind::Index(indexed, index) = &unref.kind;\n+                if let Some(range) = higher::range(index);\n+                if let higher::Range { start, end, .. } = range;\n+                if let ExprKind::Path(path) = &indexed.kind;\n+                if qpath_res(self.cx, path, ex.hir_id) == self.target;\n+                then {\n+                    match (self.strip_kind, start, end) {\n+                        (StripKind::Prefix, Some(start), None) => {\n+                            if eq_pattern_length(self.cx, self.pattern, start) {\n+                                self.results.push(ex.span);\n+                                return;\n+                            }\n+                        },\n+                        (StripKind::Suffix, None, Some(end)) => {\n+                            if_chain! {\n+                                if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, left, right) = end.kind;\n+                                if let Some(left_arg) = len_arg(self.cx, left);\n+                                if let ExprKind::Path(left_path) = &left_arg.kind;\n+                                if qpath_res(self.cx, left_path, left_arg.hir_id) == self.target;\n+                                if eq_pattern_length(self.cx, self.pattern, right);\n+                                then {\n+                                    self.results.push(ex.span);\n+                                    return;\n+                                }\n+                            }\n+                        },\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            walk_expr(self, ex);\n+        }\n+    }\n+\n+    let mut finder = StrippingFinder {\n+        cx,\n+        strip_kind,\n+        target,\n+        pattern,\n+        results: vec![],\n+    };\n+    walk_expr(&mut finder, expr);\n+    finder.results\n+}"}, {"sha": "5298e16a04d9b7d3578edc82c111fb3984cfbf9b", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,147 @@\n+use crate::utils::span_lint_and_help;\n+\n+use rustc_hir::{CaptureBy, Expr, ExprKind, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map_err(|_| Some::Enum)`\n+    ///\n+    /// **Why is this bad?** This map_err throws away the original error rather than allowing the enum to contain and report the cause of the error\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Before:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible,\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {}\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(|_| Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    ///  ```\n+    ///\n+    ///  After:\n+    ///  ```rust\n+    /// use std::{fmt, num::ParseIntError};\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible(ParseIntError),\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {\n+    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+    ///         match self {\n+    ///             Error::Indivisible(source) => Some(source),\n+    ///             _ => None,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    /// ```\n+    pub MAP_ERR_IGNORE,\n+    pedantic,\n+    \"`map_err` should not ignore the original error\"\n+}\n+\n+declare_lint_pass!(MapErrIgnore => [MAP_ERR_IGNORE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n+    // do not try to lint if this is from a macro or desugaring\n+    fn check_expr(&mut self, cx: &LateContext<'_>, e: &Expr<'_>) {\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+\n+        // check if this is a method call (e.g. x.foo())\n+        if let ExprKind::MethodCall(ref method, _t_span, ref args, _) = e.kind {\n+            // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n+            // Enum::Variant[2]))\n+            if method.ident.as_str() == \"map_err\" && args.len() == 2 {\n+                // make sure the first argument is a closure, and grab the CaptureRef, body_id, and body_span fields\n+                if let ExprKind::Closure(capture, _, body_id, body_span, _) = args[1].kind {\n+                    // check if this is by Reference (meaning there's no move statement)\n+                    if capture == CaptureBy::Ref {\n+                        // Get the closure body to check the parameters and values\n+                        let closure_body = cx.tcx.hir().body(body_id);\n+                        // make sure there's only one parameter (`|_|`)\n+                        if closure_body.params.len() == 1 {\n+                            // make sure that parameter is the wild token (`_`)\n+                            if let PatKind::Wild = closure_body.params[0].pat.kind {\n+                                // span the area of the closure capture and warn that the\n+                                // original error will be thrown away\n+                                span_lint_and_help(\n+                                    cx,\n+                                    MAP_ERR_IGNORE,\n+                                    body_span,\n+                                    \"`map_err(|_|...` ignores the original error\",\n+                                    None,\n+                                    \"Consider wrapping the error in an enum variant\",\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "331b6c6c34a9447ab8d08c63f53fe51c239456fb", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::walk_ptrs_ty;\n use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -90,12 +89,12 @@ fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Opti\n \n fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    let ty = walk_ptrs_ty(ty);\n+    let ty = ty.peel_refs();\n     is_type_diagnostic_item(cx, ty, sym!(vec_type))\n }\n \n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    let ty = walk_ptrs_ty(ty);\n+    let ty = ty.peel_refs();\n     is_type_lang_item(cx, ty, LangItem::RangeFull)\n }"}, {"sha": "6f47687c41088e7ba9586cd12a921576f4e8d2e6", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -6,7 +6,7 @@ use crate::utils::{\n     expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n     is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, multispan_sugg, remove_blocks, snippet,\n     snippet_block, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n-    span_lint_and_then, walk_ptrs_ty,\n+    span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -794,7 +794,7 @@ fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms\n }\n \n fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ex_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(ex));\n+    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n     if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {"}, {"sha": "ae37942e55a1bbf65cf77a47d1925cb4b141dc5e", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::hir::map::Map;\n use rustc_span::Span;\n \n pub(crate) struct OptionAndThenSome;\n+\n impl BindInsteadOfMap for OptionAndThenSome {\n     const TYPE_NAME: &'static str = \"Option\";\n     const TYPE_QPATH: &'static [&'static str] = &paths::OPTION;\n@@ -24,6 +25,7 @@ impl BindInsteadOfMap for OptionAndThenSome {\n }\n \n pub(crate) struct ResultAndThenOk;\n+\n impl BindInsteadOfMap for ResultAndThenOk {\n     const TYPE_NAME: &'static str = \"Result\";\n     const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n@@ -36,6 +38,7 @@ impl BindInsteadOfMap for ResultAndThenOk {\n }\n \n pub(crate) struct ResultOrElseErrInfo;\n+\n impl BindInsteadOfMap for ResultOrElseErrInfo {\n     const TYPE_NAME: &'static str = \"Result\";\n     const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n@@ -120,9 +123,9 @@ pub(crate) trait BindInsteadOfMap {\n         }\n     }\n \n-    fn lint_closure(cx: &LateContext<'_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) {\n+    fn lint_closure(cx: &LateContext<'_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) -> bool {\n         let mut suggs = Vec::new();\n-        let can_sugg = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n+        let can_sugg: bool = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n                 if let hir::ExprKind::Call(ref func_path, ref args) = ret_expr.kind;\n@@ -153,21 +156,24 @@ pub(crate) trait BindInsteadOfMap {\n                 )\n             });\n         }\n+        can_sugg\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n         if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n-            return;\n+            return false;\n         }\n \n         match args[1].kind {\n             hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 let closure_expr = remove_blocks(&closure_body.value);\n \n-                if !Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n-                    Self::lint_closure(cx, expr, closure_expr);\n+                if Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n+                    true\n+                } else {\n+                    Self::lint_closure(cx, expr, closure_expr)\n                 }\n             },\n             // `_.and_then(Some)` case, which is no-op.\n@@ -181,8 +187,9 @@ pub(crate) trait BindInsteadOfMap {\n                     snippet(cx, args[0].span, \"..\").into(),\n                     Applicability::MachineApplicable,\n                 );\n+                true\n             },\n-            _ => {},\n+            _ => false,\n         }\n     }\n }"}, {"sha": "dadd0f8ebb7c85992fde8064b4805f50201f7a77", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 30, "deletions": 58, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -25,14 +25,15 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n \n use crate::consts::{constant, Constant};\n+use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro,\n-    is_copy, is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats,\n-    last_path_segment, match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls,\n-    method_chain_args, paths, remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n-    span_lint_and_then, sugg, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n+    match_trait_method, match_type, match_var, method_calls, method_chain_args, paths, remove_blocks, return_ty,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty_depth,\n+    SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1454,18 +1455,21 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n                 if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n-                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\");\n                 }\n             },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n-                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"and\");\n-                bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n-                bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n+                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n+                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n+                if !biom_option_linted && !biom_result_linted {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"and\");\n+                }\n             },\n             [\"or_else\", ..] => {\n-                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"or\");\n-                bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n+                if !bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]) {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"or\");\n+                }\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => lint_skip_while_next(cx, expr, arg_lists[1]),\n@@ -1508,9 +1512,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n-            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n-            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n-            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"ok_or\"),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"ok_or\"),\n             _ => {},\n         }\n \n@@ -1714,37 +1718,6 @@ fn lint_or_fun_call<'tcx>(\n     name: &str,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n-    // Searches an expression for method calls or function calls that aren't ctors\n-    struct FunCallFinder<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        found: bool,\n-    }\n-\n-    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            let call_found = match &expr.kind {\n-                // ignore enum and struct constructors\n-                hir::ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n-                hir::ExprKind::MethodCall(..) => true,\n-                _ => false,\n-            };\n-\n-            if call_found {\n-                self.found |= true;\n-            }\n-\n-            if !self.found {\n-                intravisit::walk_expr(self, expr);\n-            }\n-        }\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n     /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_>,\n@@ -1801,14 +1774,14 @@ fn lint_or_fun_call<'tcx>(\n     ) {\n         if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n-                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n+                let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n \n                 match ty.kind() {\n                     ty::Slice(_) | ty::Array(_, _) => return,\n                     _ => (),\n                 }\n \n-                if match_type(cx, ty, &paths::VEC) {\n+                if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n                     return;\n                 }\n             }\n@@ -1825,8 +1798,7 @@ fn lint_or_fun_call<'tcx>(\n         if_chain! {\n             if know_types.iter().any(|k| k.2.contains(&name));\n \n-            let mut finder = FunCallFinder { cx: &cx, found: false };\n-            if { finder.visit_expr(&arg); finder.found };\n+            if is_lazyness_candidate(cx, arg);\n             if !contains_return(&arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n@@ -1909,7 +1881,7 @@ fn lint_expect_fun_call(\n                         && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n                         && {\n                             let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n-                            let base_type = walk_ptrs_ty(arg_type);\n+                            let base_type = arg_type.peel_refs();\n                             *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n                         }\n                     {\n@@ -2170,7 +2142,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n }\n \n fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(arg));\n+    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -2201,7 +2173,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n-        let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(target));\n+        let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n             \"\"\n         } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n@@ -2229,7 +2201,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n }\n \n fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n+    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n     if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n         lint_string_extend(cx, expr, args);\n     }\n@@ -2412,7 +2384,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         }\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n         || matches!(\n-            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind(),\n+            &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n             ty::Array(_, _)\n         )\n     {\n@@ -2615,7 +2587,7 @@ fn derefs_to_slice<'tcx>(\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&unwrap_args[0]));\n+    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))\n@@ -2643,7 +2615,7 @@ fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::E\n \n /// lint use of `expect()` for `Option`s and `Result`s\n fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&expect_args[0]));\n+    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))\n@@ -3162,7 +3134,7 @@ fn lint_chars_cmp(\n         if segment.ident.name == sym!(Some);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty_adjusted(&args[0][0]));\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n \n             if *self_ty.kind() != ty::Str {\n                 return false;\n@@ -3374,7 +3346,7 @@ fn lint_into_iter(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_\n             INTO_ITER_ON_REF,\n             method_span,\n             &format!(\n-                \"this `.into_iter()` call is equivalent to `.{}()` and will not move the `{}`\",\n+                \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n                 method_name, kind,\n             ),\n             \"call directly\","}, {"sha": "08b3eab9b7cdfe3f631b2471c91968a4219184b6", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 9, "deletions": 67, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,78 +1,17 @@\n-use crate::utils::{is_type_diagnostic_item, match_qpath, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n+use crate::utils::{eager_or_lazy, usage};\n+use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n \n use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n-// Return true if the expression is an accessor of any of the arguments\n-fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n-    params.iter().any(|arg| {\n-        if_chain! {\n-            if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n-            if let [p, ..] = path.segments;\n-            then {\n-                ident.name == p.ident.name\n-            } else {\n-                false\n-            }\n-        }\n-    })\n-}\n-\n-fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n-    paths.iter().any(|candidate| match_qpath(path, candidate))\n-}\n-\n-fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n-    match expr.kind {\n-        // Closures returning literals can be unconditionally simplified\n-        hir::ExprKind::Lit(_) => true,\n-\n-        hir::ExprKind::Index(ref object, ref index) => {\n-            // arguments are not being indexed into\n-            if expr_uses_argument(object, params) {\n-                false\n-            } else {\n-                // arguments are not used as index\n-                !expr_uses_argument(index, params)\n-            }\n-        },\n-\n-        // Reading fields can be simplified if the object is not an argument of the closure\n-        hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n-\n-        // Paths can be simplified if the root is not the argument, this also covers None\n-        hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n-\n-        // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n-        hir::ExprKind::Call(ref func, ref args) => if_chain! {\n-            if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n-            if let hir::ExprKind::Path(ref path) = func.kind;\n-            if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n-            then {\n-                // Recursively check all arguments\n-                args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n-            } else {\n-                false\n-            }\n-        },\n-\n-        // For anything more complex than the above, a closure is probably the right solution,\n-        // or the case is handled by an other lint\n-        _ => false,\n-    }\n-}\n-\n /// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n /// replaced with `<fn>(return value of simple closure)`\n pub(super) fn lint<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n-    allow_variant_calls: bool,\n     simplify_using: &str,\n ) {\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n@@ -81,10 +20,13 @@ pub(super) fn lint<'tcx>(\n     if is_option || is_result {\n         if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n             let body = cx.tcx.hir().body(eid);\n-            let ex = &body.value;\n-            let params = &body.params;\n+            let body_expr = &body.value;\n+\n+            if usage::BindingUsageFinder::are_params_used(cx, body) {\n+                return;\n+            }\n \n-            if can_simplify(ex, params, allow_variant_calls) {\n+            if eager_or_lazy::is_eagerness_candidate(cx, body_expr) {\n                 let msg = if is_option {\n                     \"unnecessary closure used to substitute value for `Option::None`\"\n                 } else {\n@@ -101,7 +43,7 @@ pub(super) fn lint<'tcx>(\n                         \"{0}.{1}({2})\",\n                         snippet(cx, args[0].span, \"..\"),\n                         simplify_using,\n-                        snippet(cx, ex.span, \"..\"),\n+                        snippet(cx, body_expr.span, \"..\"),\n                     ),\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "909e79f661a6d83959d765c57ebbe7a7a7caa514", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -17,7 +17,7 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{\n     get_item_name, get_parent_expr, higher, implements_trait, in_constant, is_integer_const, iter_input_pats,\n     last_path_segment, match_qpath, match_trait_method, paths, snippet, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, span_lint_hir_and_then, walk_ptrs_ty, SpanlessEq,\n+    span_lint_and_then, span_lint_hir_and_then, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -99,11 +99,11 @@ declare_clippy_lint! {\n     /// if y != x {} // where both are floats\n     ///\n     /// // Good\n-    /// let error = f64::EPSILON; // Use an epsilon for comparison\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n     /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error = std::f64::EPSILON;\n-    /// if (y - 1.23f64).abs() < error { }\n-    /// if (y - x).abs() > error { }\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (y - 1.23f64).abs() < error_margin { }\n+    /// if (y - x).abs() > error_margin { }\n     /// ```\n     pub FLOAT_CMP,\n     correctness,\n@@ -242,10 +242,10 @@ declare_clippy_lint! {\n     /// if x == ONE { } // where both are floats\n     ///\n     /// // Good\n-    /// let error = f64::EPSILON; // Use an epsilon for comparison\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n     /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error = std::f64::EPSILON;\n-    /// if (x - ONE).abs() < error { }\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (x - ONE).abs() < error_margin { }\n     /// ```\n     pub FLOAT_CMP_CONST,\n     restriction,\n@@ -411,16 +411,16 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                         if !is_comparing_arrays {\n                             diag.span_suggestion(\n                                 expr.span,\n-                                \"consider comparing them within some error\",\n+                                \"consider comparing them within some margin of error\",\n                                 format!(\n-                                    \"({}).abs() {} error\",\n+                                    \"({}).abs() {} error_margin\",\n                                     lhs - rhs,\n                                     if op == BinOpKind::Eq { '<' } else { '>' }\n                                 ),\n                                 Applicability::HasPlaceholders, // snippet\n                             );\n                         }\n-                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error`\");\n+                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n                     });\n                 } else if op == BinOpKind::Rem && is_integer_const(cx, right, 1) {\n                     span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n@@ -561,7 +561,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind();\n+    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n \n     if let ty::Array(arr_ty, _) = value {\n         return matches!(arr_ty.kind(), ty::Float(_));\n@@ -571,7 +571,7 @@ fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind(), ty::Array(_, _))\n+    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n }\n \n fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {"}, {"sha": "9cb1cfb915d5796734b2f94b6167709a53a93ea3", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -377,16 +377,16 @@ impl EarlyLintPass for MiscEarlyLints {\n             if let PatKind::Ident(_, ident, None) = arg.pat.kind {\n                 let arg_name = ident.to_string();\n \n-                if arg_name.starts_with('_') {\n-                    if let Some(correspondence) = registered_names.get(&arg_name[1..]) {\n+                if let Some(arg_name) = arg_name.strip_prefix('_') {\n+                    if let Some(correspondence) = registered_names.get(arg_name) {\n                         span_lint(\n                             cx,\n                             DUPLICATE_UNDERSCORE_ARGUMENT,\n                             *correspondence,\n                             &format!(\n                                 \"`{}` already exists, having another argument having almost the same \\\n                                  name makes code comprehension and documentation more difficult\",\n-                                arg_name[1..].to_owned()\n+                                arg_name\n                             ),\n                         );\n                     }"}, {"sha": "8a2dbdc50eaea36af1fa272d37b8a098d2b88963", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, span_lint, trait_ref_of_method, walk_ptrs_ty};\n+use crate::utils::{match_def_path, paths, span_lint, trait_ref_of_method};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{Adt, Array, RawPtr, Ref, Slice, Tuple, Ty, TypeAndMut};\n@@ -12,8 +12,10 @@ declare_clippy_lint! {\n     /// `BtreeSet` rely on either the hash or the order of keys be unchanging,\n     /// so having types with interior mutability is a bad idea.\n     ///\n-    /// **Known problems:** We don't currently account for `Rc` or `Arc`, so\n-    /// this may yield false positives.\n+    /// **Known problems:** It's correct to use a struct, that contains interior mutability\n+    /// as a key, when its `Hash` implementation doesn't access any of the interior mutable types.\n+    /// However, this lint is unable to recognize this, so it causes a false positive in theses cases.\n+    /// The `bytes` crate is a great example of this.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -96,7 +98,7 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n // We want to lint 1. sets or maps with 2. not immutable key types and 3. no unerased\n // generics (because the compiler cannot ensure immutability for unknown types).\n fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n-    let ty = walk_ptrs_ty(ty);\n+    let ty = ty.peel_refs();\n     if let Adt(def, substs) = ty.kind() {\n         if [&paths::HASHMAP, &paths::BTREEMAP, &paths::HASHSET, &paths::BTREESET]\n             .iter()"}, {"sha": "bb44eeb6adc51b30b056e80306b4448479161427", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -6,14 +6,16 @@ use std::ptr;\n \n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp};\n+use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{Ty, TypeFlags};\n+use rustc_middle::ty::{AssocKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{in_constant, is_copy, qpath_res, span_lint_and_then};\n+use crate::utils::{in_constant, qpath_res, span_lint_and_then};\n+use if_chain::if_chain;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for declaration of `const` items which is interior\n@@ -83,11 +85,10 @@ declare_clippy_lint! {\n     \"referencing `const` with interior mutability\"\n }\n \n-#[allow(dead_code)]\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n-    Assoc { item: Span, ty: Span },\n+    Assoc { item: Span },\n     Expr { expr: Span },\n }\n \n@@ -110,10 +111,15 @@ impl Source {\n }\n \n fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n-    if ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) || is_copy(cx, ty) {\n-        // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n-        // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`\n-        // as well.\n+    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n+    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n+    // 'unfrozen'. However, this code causes a false negative in which\n+    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n+    // since it works when a pointer indirection involves (`Cell<*const T>`).\n+    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n+    // but I'm not sure whether it's a decent way, if possible.\n+    if cx.tcx.layout_of(cx.param_env.and(ty)).is_err() || ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) {\n         return;\n     }\n \n@@ -127,11 +133,7 @@ fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n                 let const_kw_span = span.from_inner(InnerSpan::new(0, 5));\n                 diag.span_label(const_kw_span, \"make this a static item (maybe with lazy_static)\");\n             },\n-            Source::Assoc { ty: ty_span, .. } => {\n-                if ty.flags().intersects(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n-                    diag.span_label(ty_span, &format!(\"consider requiring `{}` to be `Copy`\", ty));\n-                }\n-            },\n+            Source::Assoc { .. } => (),\n             Source::Expr { .. } => {\n                 diag.help(\"assign this const to a local or static variable, and use the variable here\");\n             },\n@@ -152,32 +154,61 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            verify_ty_bound(\n-                cx,\n-                ty,\n-                Source::Assoc {\n-                    ty: hir_ty.span,\n-                    item: trait_item.span,\n-                },\n-            );\n+            // Normalize assoc types because ones originated from generic params\n+            // bounded other traits could have their bound.\n+            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+            verify_ty_bound(cx, normalized, Source::Assoc { item: trait_item.span });\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n-            // Ensure the impl is an inherent impl.\n-            if let ItemKind::Impl { of_trait: None, .. } = item.kind {\n-                let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-                verify_ty_bound(\n-                    cx,\n-                    ty,\n-                    Source::Assoc {\n-                        ty: hir_ty.span,\n-                        item: impl_item.span,\n-                    },\n-                );\n+\n+            match &item.kind {\n+                ItemKind::Impl {\n+                    of_trait: Some(of_trait_ref),\n+                    ..\n+                } => {\n+                    if_chain! {\n+                        // Lint a trait impl item only when the definition is a generic type,\n+                        // assuming a assoc const is not meant to be a interior mutable type.\n+                        if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n+                        if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n+                            .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);\n+                        if cx\n+                            .tcx\n+                            .layout_of(cx.tcx.param_env(of_trait_def_id).and(\n+                                // Normalize assoc types because ones originated from generic params\n+                                // bounded other traits could have their bound at the trait defs;\n+                                // and, in that case, the definition is *not* generic.\n+                                cx.tcx.normalize_erasing_regions(\n+                                    cx.tcx.param_env(of_trait_def_id),\n+                                    cx.tcx.type_of(of_assoc_item.def_id),\n+                                ),\n+                            ))\n+                            .is_err();\n+                        then {\n+                            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                            verify_ty_bound(\n+                                cx,\n+                                normalized,\n+                                Source::Assoc {\n+                                    item: impl_item.span,\n+                                },\n+                            );\n+                        }\n+                    }\n+                },\n+                ItemKind::Impl { of_trait: None, .. } => {\n+                    let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                    // Normalize assoc types originated from generic params.\n+                    let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                    verify_ty_bound(cx, normalized, Source::Assoc { item: impl_item.span });\n+                },\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "73a99a3a2f870a3f7351ee1a3da2cc6828ad121b", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_type, paths, span_lint, walk_ptrs_ty};\n+use crate::utils::{match_type, paths, span_lint};\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -30,7 +30,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n-            let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&arguments[0]));\n+            let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n@@ -58,7 +58,7 @@ enum OpenOption {\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n-        let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&arguments[0]));\n+        let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {"}, {"sha": "4a3eb9c983a11617114d4231a2b58e74133b1279", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,6 +1,7 @@\n use crate::utils;\n+use crate::utils::eager_or_lazy;\n use crate::utils::sugg::Sugg;\n-use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use crate::utils::{is_type_diagnostic_item, paths, span_lint_and_sugg};\n use if_chain::if_chain;\n \n use rustc_errors::Applicability;\n@@ -13,22 +14,16 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:**\n     /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n-    /// idiomatically done with `Option::map_or` (if the else bit is a simple\n-    /// expression) or `Option::map_or_else` (if the else bit is a longer\n-    /// block).\n+    /// idiomatically done with `Option::map_or` (if the else bit is a pure\n+    /// expression) or `Option::map_or_else` (if the else bit is an impure\n+    /// expresion).\n     ///\n     /// **Why is this bad?**\n     /// Using the dedicated functions of the Option type is clearer and\n     /// more concise than an if let expression.\n     ///\n     /// **Known problems:**\n-    /// This lint uses whether the block is just an expression or if it has\n-    /// more statements to decide whether to use `Option::map_or` or\n-    /// `Option::map_or_else`. If you have a single expression which calls\n-    /// an expensive function, then it would be more efficient to use\n-    /// `Option::map_or_else`, but this lint would suggest `Option::map_or`.\n-    ///\n-    /// Also, this lint uses a deliberately conservative metric for checking\n+    /// This lint uses a deliberately conservative metric for checking\n     /// if the inside of either body contains breaks or continues which will\n     /// cause it to not suggest a fix if either block contains a loop with\n     /// continues or breaks contained within the loop.\n@@ -73,7 +68,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n         path.ident.name.to_ident_string() == \"ok\"\n-            && match_type(cx, &cx.typeck_results().expr_ty(&receiver), &paths::RESULT)\n+            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym!(result_type))\n     } else {\n         false\n     }\n@@ -92,13 +87,15 @@ struct OptionIfLetElseOccurence {\n struct ReturnBreakContinueMacroVisitor {\n     seen_return_break_continue: bool,\n }\n+\n impl ReturnBreakContinueMacroVisitor {\n     fn new() -> ReturnBreakContinueMacroVisitor {\n         ReturnBreakContinueMacroVisitor {\n             seen_return_break_continue: false,\n         }\n     }\n }\n+\n impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n     type Map = Map<'tcx>;\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -157,7 +154,7 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n }\n \n /// If this is the else body of an if/else expression, then we need to wrap\n-/// it in curcly braces. Otherwise, we don't.\n+/// it in curly braces. Otherwise, we don't.\n fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n         if let Some(Expr {\n@@ -199,7 +196,10 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n /// If this expression is the option if let/else construct we're detecting, then\n /// this function returns an `OptionIfLetElseOccurence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OptionIfLetElseOccurence> {\n+fn detect_option_if_let_else<'tcx>(\n+    cx: &'_ LateContext<'tcx>,\n+    expr: &'_ Expr<'tcx>,\n+) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !utils::in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n         if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n@@ -214,10 +214,7 @@ fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Op\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_arm(&arms[0])?;\n             let none_body = extract_body_from_arm(&arms[1])?;\n-            let method_sugg = match &none_body.kind {\n-                ExprKind::Block(..) => \"map_or_else\",\n-                _ => \"map_or\",\n-            };\n+            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let wrap_braces = should_wrap_in_braces(cx, expr);\n             let (as_ref, as_mut) = match &cond_expr.kind {\n@@ -243,8 +240,8 @@ fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Op\n     }\n }\n \n-impl<'a> LateLintPass<'a> for OptionIfLetElse {\n-    fn check_expr(&mut self, cx: &LateContext<'a>, expr: &Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for OptionIfLetElse {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n         if let Some(detection) = detect_option_if_let_else(cx, expr) {\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "4077aba6ef17dabb99ca7f14b75f3e4d2d2efc28", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,90 @@\n+use crate::utils::{is_expn_of, is_type_diagnostic_item, return_ty, span_lint_and_then};\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::Expr;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!` or `unreachable!` in a function of type result.\n+    ///\n+    /// **Why is this bad?** For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence unimplemented, panic and unreachable should be avoided.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn result_with_panic() -> Result<bool, String>\n+    /// {\n+    ///     panic!(\"error\");\n+    /// }\n+    /// ```\n+    pub PANIC_IN_RESULT_FN,\n+    restriction,\n+    \"functions of type `Result<..>` that contain `panic!()`, `todo!()` or `unreachable()` or `unimplemented()` \"\n+}\n+\n+declare_lint_pass!(PanicInResultFn  => [PANIC_IN_RESULT_FN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        fn_kind: FnKind<'tcx>,\n+        _: &'tcx hir::FnDecl<'tcx>,\n+        body: &'tcx hir::Body<'tcx>,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        if !matches!(fn_kind, FnKind::Closure(_))\n+            && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type))\n+        {\n+            lint_impl_body(cx, span, body);\n+        }\n+    }\n+}\n+\n+struct FindPanicUnimplementedUnreachable {\n+    result: Vec<Span>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for FindPanicUnimplementedUnreachable {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if [\"unimplemented\", \"unreachable\", \"panic\", \"todo\"]\n+            .iter()\n+            .any(|fun| is_expn_of(expr.span, fun).is_some())\n+        {\n+            self.result.push(expr.span);\n+        }\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n+    let mut panics = FindPanicUnimplementedUnreachable { result: Vec::new() };\n+    panics.visit_expr(&body.value);\n+    if !panics.result.is_empty() {\n+        span_lint_and_then(\n+            cx,\n+            PANIC_IN_RESULT_FN,\n+            impl_span,\n+            \"used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\",\n+            move |diag| {\n+                diag.help(\n+                    \"`unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\",\n+                );\n+                diag.span_note(panics.result, \"return Err() instead of panicking\");\n+            },\n+        );\n+    }\n+}"}, {"sha": "6eeb031d383c856e1e195e865415abe4fd367cb8", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_type, paths, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{match_type, paths, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n-            if match_type(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0])), &paths::PATH_BUF);\n+            if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::PATH_BUF);\n             if let Some(get_index_arg) = args.get(1);\n             if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n             if let LitKind::Str(ref path_lit, _) = lit.node;"}, {"sha": "1a7f36fbdadbb65cb43fb2042e3c6e024901ed87", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -239,10 +239,9 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                         );\n                         let mut app = Applicability::MaybeIncorrect;\n \n-                        let mut call_snip = &snip[dot + 1..];\n+                        let call_snip = &snip[dot + 1..];\n                         // Machine applicable when `call_snip` looks like `foobar()`\n-                        if call_snip.ends_with(\"()\") {\n-                            call_snip = call_snip[..call_snip.len()-2].trim();\n+                        if let Some(call_snip) = call_snip.strip_suffix(\"()\").map(str::trim) {\n                             if call_snip.as_bytes().iter().all(|b| b.is_ascii_alphabetic() || *b == b'_') {\n                                 app = Applicability::MachineApplicable;\n                             }"}, {"sha": "ae6013530091e23716caadc26a3bc0df5144be44", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant_context, Constant};\n-use crate::utils::{in_macro, is_type_diagnostic_item, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{in_macro, is_type_diagnostic_item, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n             if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&count);\n             if !in_macro(receiver.span);\n             then {\n-                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&receiver));\n+                let ty = cx.typeck_results().expr_ty(&receiver).peel_refs();\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "225fe58906f739f90419e0b88f2054018daafec4", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -25,7 +25,6 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # let x = 1;\n-    ///\n     /// // Bad\n     /// let x = &x;\n     ///\n@@ -75,7 +74,9 @@ declare_clippy_lint! {\n     /// names to bindings or introducing more scopes to contain the bindings.\n     ///\n     /// **Known problems:** This lint, as the other shadowing related lints,\n-    /// currently only catches very simple patterns.\n+    /// currently only catches very simple patterns. Note that\n+    /// `allow`/`warn`/`deny`/`forbid` attributes only work on the function level\n+    /// for this lint.\n     ///\n     /// **Example:**\n     /// ```rust"}, {"sha": "15b66684eab702b4f1c74874fa9f52540cbf81bc", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -8,7 +8,7 @@ use rustc_span::source_map::Spanned;\n use if_chain::if_chain;\n \n use crate::utils::SpanlessEq;\n-use crate::utils::{get_parent_expr, is_allowed, is_type_diagnostic_item, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_parent_expr, is_allowed, is_type_diagnostic_item, span_lint, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for string appends of the form `x = x + y` (without\n@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(e)), sym!(string_type))\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym!(string_type))\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {"}, {"sha": "54b38d9f4ced2142e3201034c82fce78d54ed9f5", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,7 +1,6 @@\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n     differing_macro_contexts, eq_expr_value, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then,\n-    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -194,7 +193,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n             if eq_expr_value(cx, lhs1, lhs2) {\n-                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n+                let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n \n                 if matches!(ty.kind(), ty::Slice(_))\n                     || matches!(ty.kind(), ty::Array(_, _))"}, {"sha": "b6d405cca770dd2ca77a4b72477bac980f810cd1", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -321,14 +321,15 @@ impl Types {\n                 if let Some(def_id) = res.opt_def_id() {\n                     if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                         if let Some(span) = match_borrows_parameter(cx, qpath) {\n+                            let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Box<&T>`\",\n                                 \"try\",\n-                                snippet(cx, span, \"..\").to_string(),\n-                                Applicability::MachineApplicable,\n+                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                                applicability,\n                             );\n                             return; // don't recurse into the type\n                         }\n@@ -345,14 +346,15 @@ impl Types {\n                         }\n                     } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n                         if let Some(span) = match_type_parameter(cx, qpath, &paths::RC) {\n+                            let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Rc<Rc<T>>`\",\n                                 \"try\",\n-                                snippet(cx, span, \"..\").to_string(),\n-                                Applicability::MachineApplicable,\n+                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                                applicability,\n                             );\n                             return; // don't recurse into the type\n                         }\n@@ -368,26 +370,31 @@ impl Types {\n                                 GenericArg::Type(ty) => ty.span,\n                                 _ => return,\n                             };\n+                            let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Rc<Box<T>>`\",\n                                 \"try\",\n-                                format!(\"Rc<{}>\", snippet(cx, inner_span, \"..\")),\n-                                Applicability::MachineApplicable,\n+                                format!(\n+                                    \"Rc<{}>\",\n+                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                                ),\n+                                applicability,\n                             );\n                             return; // don't recurse into the type\n                         }\n                         if let Some(span) = match_borrows_parameter(cx, qpath) {\n+                            let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Rc<&T>`\",\n                                 \"try\",\n-                                snippet(cx, span, \"..\").to_string(),\n-                                Applicability::MachineApplicable,\n+                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                                applicability,\n                             );\n                             return; // don't recurse into the type\n                         }\n@@ -546,7 +553,6 @@ impl Types {\n                             // details.\n                             return;\n                         }\n-                        let mut applicability = Applicability::MachineApplicable;\n                         span_lint_and_sugg(\n                             cx,\n                             BORROWED_BOX,\n@@ -556,8 +562,12 @@ impl Types {\n                             format!(\n                                 \"&{}{}\",\n                                 ltopt,\n-                                &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)\n+                                &snippet(cx, inner.span, \"..\")\n                             ),\n+                            // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n+                            // because the trait impls of it will break otherwise;\n+                            // and there may be other cases that result in invalid code.\n+                            // For example, type coercion doesn't work nicely.\n                             Applicability::Unspecified,\n                         );\n                         return; // don't recurse into the type"}, {"sha": "0f8797243eca316ae24c9512246239b8c376fccd", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_type_diagnostic_item, method_chain_args, return_ty, span_lint_and_then, walk_ptrs_ty};\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, return_ty, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -81,7 +81,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n             if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n                 || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n             {\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n             if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n                 || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n             {"}, {"sha": "4e4a206a583a2d12c85c7ed55f9365fe25306b1e", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            \"useless conversion to the same type\",\n+                            &format!(\"useless conversion to the same type: `{}`\", b),\n                             \"consider removing `.into()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -95,7 +95,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            \"useless conversion to the same type\",\n+                            &format!(\"useless conversion to the same type: `{}`\", b),\n                             \"consider removing `.into_iter()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -116,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                 cx,\n                                 USELESS_CONVERSION,\n                                 e.span,\n-                                \"useless conversion to the same type\",\n+                                &format!(\"useless conversion to the same type: `{}`\", b),\n                                 None,\n                                 \"consider removing `.try_into()`\",\n                             );\n@@ -147,7 +147,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     cx,\n                                     USELESS_CONVERSION,\n                                     e.span,\n-                                    \"useless conversion to the same type\",\n+                                    &format!(\"useless conversion to the same type: `{}`\", b),\n                                     None,\n                                     &hint,\n                                 );\n@@ -166,7 +166,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     cx,\n                                     USELESS_CONVERSION,\n                                     e.span,\n-                                    \"useless conversion to the same type\",\n+                                    &format!(\"useless conversion to the same type: `{}`\", b),\n                                     &sugg_msg,\n                                     sugg.to_string(),\n                                     Applicability::MachineApplicable, // snippet"}, {"sha": "0a58231558ede21304bf1ecc9f4b7cd1e60d29b5", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -51,6 +51,8 @@ pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: impl Into<Mult\n ///\n /// The `help` message can be optionally attached to a `Span`.\n ///\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n+///\n /// # Example\n ///\n /// ```ignore\n@@ -87,6 +89,8 @@ pub fn span_lint_and_help<'a, T: LintContext>(\n /// The `note` message is presented separately from the main lint message\n /// and is attached to a specific span:\n ///\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n+///\n /// # Example\n ///\n /// ```ignore\n@@ -126,6 +130,7 @@ pub fn span_lint_and_note<'a, T: LintContext>(\n /// Like `span_lint` but allows to add notes, help and suggestions using a closure.\n ///\n /// If you need to customize your lint output a lot, use this function.\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n where\n     F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n@@ -168,6 +173,10 @@ pub fn span_lint_hir_and_then(\n /// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x >\n /// 2)\"`.\n ///\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n+///\n+/// # Example\n+///\n /// ```ignore\n /// error: This `.fold` can be more succinctly expressed as `.any`\n /// --> $DIR/methods.rs:390:13"}, {"sha": "6938d9971d96d0d8dc97bcac113d0e54a3a27c8d", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,128 @@\n+//! Utilities for evaluating whether eagerly evaluated expressions can be made lazy and vice versa.\n+//!\n+//! Things to consider:\n+//!  - has the expression side-effects?\n+//!  - is the expression computationally expensive?\n+//!\n+//! See lints:\n+//!  - unnecessary-lazy-evaluations\n+//!  - or-fun-call\n+//!  - option-if-let-else\n+\n+use crate::utils::is_ctor_or_promotable_const_function;\n+use rustc_hir::def::{DefKind, Res};\n+\n+use rustc_hir::intravisit;\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+\n+use rustc_hir::{Block, Expr, ExprKind, Path, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+\n+/// Is the expr pure (is it free from side-effects)?\n+/// This function is named so to stress that it isn't exhaustive and returns FNs.\n+fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Lit(..) | ExprKind::Path(..) | ExprKind::Field(..) => true,\n+        ExprKind::AddrOf(_, _, addr_of_expr) => identify_some_pure_patterns(addr_of_expr),\n+        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ExprKind::Struct(_, fields, expr) => {\n+            fields.iter().all(|f| identify_some_pure_patterns(f.expr))\n+                && expr.map_or(true, |e| identify_some_pure_patterns(e))\n+        },\n+        ExprKind::Call(\n+            &Expr {\n+                kind:\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        Path {\n+                            res: Res::Def(DefKind::Ctor(..) | DefKind::Variant, ..),\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            },\n+            args,\n+        ) => args.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ExprKind::Block(\n+            &Block {\n+                stmts,\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) => stmts.is_empty() && identify_some_pure_patterns(expr),\n+        ExprKind::Box(..)\n+        | ExprKind::Array(..)\n+        | ExprKind::Call(..)\n+        | ExprKind::MethodCall(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Cast(..)\n+        | ExprKind::Type(..)\n+        | ExprKind::DropTemps(..)\n+        | ExprKind::Loop(..)\n+        | ExprKind::Match(..)\n+        | ExprKind::Closure(..)\n+        | ExprKind::Block(..)\n+        | ExprKind::Assign(..)\n+        | ExprKind::AssignOp(..)\n+        | ExprKind::Index(..)\n+        | ExprKind::Break(..)\n+        | ExprKind::Continue(..)\n+        | ExprKind::Ret(..)\n+        | ExprKind::InlineAsm(..)\n+        | ExprKind::LlvmInlineAsm(..)\n+        | ExprKind::Repeat(..)\n+        | ExprKind::Yield(..)\n+        | ExprKind::Err => false,\n+    }\n+}\n+\n+/// Identify some potentially computationally expensive patterns.\n+/// This function is named so to stress that its implementation is non-exhaustive.\n+/// It returns FNs and FPs.\n+fn identify_some_potentially_expensive_patterns<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    // Searches an expression for method calls or function calls that aren't ctors\n+    struct FunCallFinder<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        found: bool,\n+    }\n+\n+    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            let call_found = match &expr.kind {\n+                // ignore enum and struct constructors\n+                ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n+                ExprKind::MethodCall(..) => true,\n+                _ => false,\n+            };\n+\n+            if call_found {\n+                self.found |= true;\n+            }\n+\n+            if !self.found {\n+                intravisit::walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+\n+    let mut finder = FunCallFinder { cx, found: false };\n+    finder.visit_expr(expr);\n+    finder.found\n+}\n+\n+pub fn is_eagerness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    !identify_some_potentially_expensive_patterns(cx, expr) && identify_some_pure_patterns(expr)\n+}\n+\n+pub fn is_lazyness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    identify_some_potentially_expensive_patterns(cx, expr)\n+}"}, {"sha": "bfe426a25eb893e9520e28bb7b22d46bda17dd2c", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 114, "deletions": 5, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n+    is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, qpath_res, run_lints,\n+    snippet, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Path, StmtKind, Ty, TyKind};\n+use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n@@ -206,6 +206,29 @@ declare_clippy_lint! {\n     \"found collapsible `span_lint_and_then` calls\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `utils::match_type()` on a type diagnostic item\n+    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    ///\n+    /// **Why is this bad?** `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// utils::match_type(cx, ty, &paths::VEC)\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    /// ```\n+    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    internal,\n+    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -404,7 +427,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n-            let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n+            let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n             if match_type(cx, ty, &paths::EARLY_CONTEXT)\n                 || match_type(cx, ty, &paths::LATE_CONTEXT);\n             then {\n@@ -437,7 +460,7 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n             let args = arg_lists[1];\n             if args.len() == 1;\n             let self_arg = &args[0];\n-            let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(self_arg));\n+            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {\n                 span_lint_and_sugg(\n@@ -652,3 +675,89 @@ fn suggest_note(\n         Applicability::MachineApplicable,\n     );\n }\n+\n+declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if !run_lints(cx, &[MATCH_TYPE_ON_DIAGNOSTIC_ITEM], expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            // Check if this is a call to utils::match_type()\n+            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n+            if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n+            if match_qpath(&fn_qpath, &[\"utils\", \"match_type\"]);\n+            // Extract the path to the matched type\n+            if let Some(segments) = path_to_matched_type(cx, ty_path);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(ty_did) = path_to_res(cx, &segments[..]).and_then(|res| res.opt_def_id());\n+            // Check if the matched type is a diagnostic item\n+            let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n+            if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n+            then {\n+                let cx_snippet = snippet(cx, context.span, \"_\");\n+                let ty_snippet = snippet(cx, ty.span, \"_\");\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    expr.span,\n+                    \"usage of `utils::match_type()` on a type diagnostic item\",\n+                    \"try\",\n+                    format!(\"utils::is_type_diagnostic_item({}, {}, sym!({}))\", cx_snippet, ty_snippet, item_name),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<SymbolStr>> {\n+    use rustc_hir::ItemKind;\n+\n+    match &expr.kind {\n+        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n+        ExprKind::Path(qpath) => match qpath_res(cx, qpath, expr.hir_id) {\n+            Res::Local(hir_id) => {\n+                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n+                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n+                    if let Some(init) = local.init {\n+                        return path_to_matched_type(cx, init);\n+                    }\n+                }\n+            },\n+            Res::Def(DefKind::Const | DefKind::Static, def_id) => {\n+                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n+                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n+                        let body = cx.tcx.hir().body(body_id);\n+                        return path_to_matched_type(cx, &body.value);\n+                    }\n+                }\n+            },\n+            _ => {},\n+        },\n+        ExprKind::Array(exprs) => {\n+            let segments: Vec<SymbolStr> = exprs\n+                .iter()\n+                .filter_map(|expr| {\n+                    if let ExprKind::Lit(lit) = &expr.kind {\n+                        if let LitKind::Str(sym, _) = lit.node {\n+                            return Some(sym.as_str());\n+                        }\n+                    }\n+\n+                    None\n+                })\n+                .collect();\n+\n+            if segments.len() == exprs.len() {\n+                return Some(segments);\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    None\n+}"}, {"sha": "ea52741b7cc42ffc5197dfeb75a7fba08039936b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -10,6 +10,7 @@ pub mod comparisons;\n pub mod conf;\n pub mod constants;\n mod diagnostics;\n+pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n pub mod inspector;\n@@ -130,6 +131,9 @@ pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n+///\n+/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n@@ -138,6 +142,8 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n }\n \n /// Checks if the type is equal to a diagnostic item\n+///\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n@@ -748,14 +754,6 @@ pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n     }\n }\n \n-/// Returns the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n-    match ty.kind() {\n-        ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n-        _ => ty,\n-    }\n-}\n-\n /// Returns the base type for references and raw pointers, and count reference\n /// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {"}, {"sha": "8736121c3b439f03708b07a171bd767c2b762954", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -115,6 +115,9 @@ pub const STD_MEM_TRANSMUTE: [&str; 3] = [\"std\", \"mem\", \"transmute\"];\n pub const STD_PTR_NULL: [&str; 3] = [\"std\", \"ptr\", \"null\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n+pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n+pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n+pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_with\"];\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];"}, {"sha": "ec8b7e59b597633cf3cb19a4c725e26a34e522f0", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -49,7 +49,7 @@ impl<'a> Sugg<'a> {\n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n     pub fn hir(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n-        Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n+        Self::hir_opt(cx, expr).unwrap_or(Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n     /// Same as `hir`, but it adapts the applicability level by following rules:"}, {"sha": "ea1dc3be29ba027a95695f5d7c039901e252343e", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,6 +1,8 @@\n use crate::utils::match_var;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_hir::intravisit;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -108,3 +110,67 @@ pub fn is_unused<'tcx>(ident: &'tcx Ident, body: &'tcx Expr<'_>) -> bool {\n     walk_expr(&mut visitor, body);\n     !visitor.used\n }\n+\n+pub struct ParamBindingIdCollector {\n+    binding_hir_ids: Vec<hir::HirId>,\n+}\n+impl<'tcx> ParamBindingIdCollector {\n+    fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {\n+        let mut finder = ParamBindingIdCollector {\n+            binding_hir_ids: Vec::new(),\n+        };\n+        finder.visit_body(body);\n+        finder.binding_hir_ids\n+    }\n+}\n+impl<'tcx> intravisit::Visitor<'tcx> for ParamBindingIdCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = param.pat.kind {\n+            self.binding_hir_ids.push(hir_id);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+pub struct BindingUsageFinder<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    binding_ids: Vec<hir::HirId>,\n+    usage_found: bool,\n+}\n+impl<'a, 'tcx> BindingUsageFinder<'a, 'tcx> {\n+    pub fn are_params_used(cx: &'a LateContext<'tcx>, body: &'tcx hir::Body<'tcx>) -> bool {\n+        let mut finder = BindingUsageFinder {\n+            cx,\n+            binding_ids: ParamBindingIdCollector::collect_binding_hir_ids(body),\n+            usage_found: false,\n+        };\n+        finder.visit_body(body);\n+        finder.usage_found\n+    }\n+}\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n+        if !self.usage_found {\n+            intravisit::walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n+        if let hir::def::Res::Local(id) = path.res {\n+            if self.binding_ids.contains(&id) {\n+                self.usage_found = true;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "fac63bcb9937838cb2020409275ec7f889d44db5", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -322,11 +322,15 @@ impl EarlyLintPass for Write {\n }\n \n /// Given a format string that ends in a newline and its span, calculates the span of the\n-/// newline.\n+/// newline, or the format string itself if the format string consists solely of a newline.\n fn newline_span(fmtstr: &StrLit) -> Span {\n     let sp = fmtstr.span;\n     let contents = &fmtstr.symbol.as_str();\n \n+    if *contents == r\"\\n\" {\n+        return sp;\n+    }\n+\n     let newline_sp_hi = sp.hi()\n         - match fmtstr.style {\n             StrStyle::Cooked => BytePos(1),"}, {"sha": "21e0f6f4fc76668547332cffb78bc4a1f1d93a2d", "filename": "doc/adding_lints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -488,7 +488,7 @@ For `LateLintPass` lints:\n While most of Clippy's lint utils are documented, most of rustc's internals lack\n documentation currently. This is unfortunate, but in most cases you can probably\n get away with copying things from existing similar lints. If you are stuck,\n-don't hesitate to ask on [Discord] or in the issue/PR.\n+don't hesitate to ask on [Zulip] or in the issue/PR.\n \n [utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/mod.rs\n [if_chain]: https://docs.rs/if_chain/*/if_chain/\n@@ -500,4 +500,4 @@ don't hesitate to ask on [Discord] or in the issue/PR.\n [nightly_docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n [ast]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html\n [ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/index.html\n-[Discord]: https://discord.gg/rust-lang\n+[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/clippy"}, {"sha": "53c3d084dbc98624bbe114172cf5f44ff7e82441", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -60,7 +60,7 @@ impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             // Check our expr is calling a method\n-            if let hir::ExprKind::MethodCall(path, _, _args) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(path, _, _args, _) = &expr.kind;\n             // Check the name of this method is `some_method`\n             if path.ident.name == sym!(some_method);\n             then {"}, {"sha": "2718b14e291f2ba4aa2b0836b802169c7609fac3", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -930,7 +930,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"invalid_atomic_ordering\",\n         group: \"correctness\",\n-        desc: \"usage of invalid atomic ordering in atomic loads/stores and memory fences\",\n+        desc: \"usage of invalid atomic ordering in atomic operations and memory fences\",\n         deprecation: None,\n         module: \"atomic_ordering\",\n     },\n@@ -1144,6 +1144,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"manual_strip\",\n+        group: \"complexity\",\n+        desc: \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\",\n+        deprecation: None,\n+        module: \"manual_strip\",\n+    },\n     Lint {\n         name: \"manual_swap\",\n         group: \"complexity\",\n@@ -1172,6 +1179,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"entry\",\n     },\n+    Lint {\n+        name: \"map_err_ignore\",\n+        group: \"pedantic\",\n+        desc: \"`map_err` should not ignore the original error\",\n+        deprecation: None,\n+        module: \"map_err_ignore\",\n+    },\n     Lint {\n         name: \"map_flatten\",\n         group: \"pedantic\",\n@@ -1718,6 +1732,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"panic_unimplemented\",\n     },\n+    Lint {\n+        name: \"panic_in_result_fn\",\n+        group: \"restriction\",\n+        desc: \"functions of type `Result<..>` that contain `panic!()`, `todo!()` or `unreachable()` or `unimplemented()` \",\n+        deprecation: None,\n+        module: \"panic_in_result_fn\",\n+    },\n     Lint {\n         name: \"panic_params\",\n         group: \"style\",\n@@ -2630,7 +2651,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"verbose_bit_mask\",\n-        group: \"style\",\n+        group: \"pedantic\",\n         desc: \"expressions where a bit mask is less readable than the corresponding method call\",\n         deprecation: None,\n         module: \"bit_mask\","}, {"sha": "1ddc12f9ab21341b5c93998a2ab12136a09b6e9a", "filename": "tests/ui/atomic_ordering_exchange.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,45 @@\n+#![warn(clippy::invalid_atomic_ordering)]\n+\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+fn main() {\n+    // `compare_exchange` (not weak) testing\n+    let x = AtomicUsize::new(0);\n+\n+    // Allowed ordering combos\n+    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Relaxed);\n+    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Acquire);\n+    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Relaxed);\n+    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Relaxed);\n+    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Acquire);\n+    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Relaxed);\n+    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Relaxed);\n+    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Acquire);\n+    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::SeqCst);\n+\n+    // AcqRel is always forbidden as a failure ordering\n+    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::AcqRel);\n+    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::AcqRel);\n+    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::AcqRel);\n+    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::AcqRel);\n+    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::AcqRel);\n+\n+    // Release is always forbidden as a failure ordering\n+    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Release);\n+    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Release);\n+    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Release);\n+    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Release);\n+    let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Release);\n+\n+    // Release success order forbids failure order of Acquire or SeqCst\n+    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Acquire);\n+    let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::SeqCst);\n+\n+    // Relaxed success order also forbids failure order of Acquire or SeqCst\n+    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::SeqCst);\n+    let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Acquire);\n+\n+    // Acquire/AcqRel forbids failure order of SeqCst\n+    let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::SeqCst);\n+    let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::SeqCst);\n+}"}, {"sha": "4b9bfef79748ce66008ee19963669a5c943c7c17", "filename": "tests/ui/atomic_ordering_exchange.stderr", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,131 @@\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:21:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::AcqRel);\n+   |                                                         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:22:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::AcqRel);\n+   |                                                         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:23:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::AcqRel);\n+   |                                                         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:24:56\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::AcqRel);\n+   |                                                        ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:25:56\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::AcqRel);\n+   |                                                        ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:28:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Release);\n+   |                                                         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:29:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::Release);\n+   |                                                         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:30:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Release);\n+   |                                                         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:31:56\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::Release);\n+   |                                                        ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:32:56\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::SeqCst, Ordering::Release);\n+   |                                                        ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be stronger than the success ordering of `Release`\n+  --> $DIR/atomic_ordering_exchange.rs:35:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::Acquire);\n+   |                                                         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be stronger than the success ordering of `Release`\n+  --> $DIR/atomic_ordering_exchange.rs:36:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Release, Ordering::SeqCst);\n+   |                                                         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be stronger than the success ordering of `Relaxed`\n+  --> $DIR/atomic_ordering_exchange.rs:39:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::SeqCst);\n+   |                                                         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be stronger than the success ordering of `Relaxed`\n+  --> $DIR/atomic_ordering_exchange.rs:40:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Relaxed, Ordering::Acquire);\n+   |                                                         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be stronger than the success ordering of `Acquire`\n+  --> $DIR/atomic_ordering_exchange.rs:43:57\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::Acquire, Ordering::SeqCst);\n+   |                                                         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange's failure ordering may not be stronger than the success ordering of `AcqRel`\n+  --> $DIR/atomic_ordering_exchange.rs:44:56\n+   |\n+LL |     let _ = x.compare_exchange(0, 0, Ordering::AcqRel, Ordering::SeqCst);\n+   |                                                        ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: aborting due to 16 previous errors\n+"}, {"sha": "5906990250728851196101c3da284ba9c7faedd0", "filename": "tests/ui/atomic_ordering_exchange_weak.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange_weak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange_weak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange_weak.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,47 @@\n+#![warn(clippy::invalid_atomic_ordering)]\n+\n+use std::sync::atomic::{AtomicPtr, Ordering};\n+\n+fn main() {\n+    let ptr = &mut 5;\n+    let ptr2 = &mut 10;\n+    // `compare_exchange_weak` testing\n+    let x = AtomicPtr::new(ptr);\n+\n+    // Allowed ordering combos\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Relaxed);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Acquire);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Relaxed);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Release, Ordering::Relaxed);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Acquire);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Relaxed);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Relaxed);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Acquire);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::SeqCst);\n+\n+    // AcqRel is always forbidden as a failure ordering\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Relaxed, Ordering::AcqRel);\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::AcqRel);\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::AcqRel);\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::AcqRel);\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::SeqCst, Ordering::AcqRel);\n+\n+    // Release is always forbidden as a failure ordering\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Release);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Release);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Release, Ordering::Release);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Release);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Release);\n+\n+    // Release success order forbids failure order of Acquire or SeqCst\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::Acquire);\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::SeqCst);\n+\n+    // Relaxed success order also forbids failure order of Acquire or SeqCst\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::SeqCst);\n+    let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Acquire);\n+\n+    // Acquire/AcqRel forbids failure order of SeqCst\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::SeqCst);\n+    let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::SeqCst);\n+}"}, {"sha": "de7026f3ffafa1ecdc9c1bc7ddcfdd1ae445a3da", "filename": "tests/ui/atomic_ordering_exchange_weak.stderr", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange_weak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_exchange_weak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_exchange_weak.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,131 @@\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:23:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Relaxed, Ordering::AcqRel);\n+   |                                                                   ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:24:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::AcqRel);\n+   |                                                                   ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:25:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::AcqRel);\n+   |                                                                   ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:26:66\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::AcqRel);\n+   |                                                                  ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:27:66\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::SeqCst, Ordering::AcqRel);\n+   |                                                                  ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:30:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Release);\n+   |                                                                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:31:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Acquire, Ordering::Release);\n+   |                                                                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:32:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Release, Ordering::Release);\n+   |                                                                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:33:66\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::AcqRel, Ordering::Release);\n+   |                                                                  ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:34:66\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::SeqCst, Ordering::Release);\n+   |                                                                  ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Release`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:37:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::Acquire);\n+   |                                                                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Release`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:38:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Release, Ordering::SeqCst);\n+   |                                                                   ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Relaxed`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:41:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::SeqCst);\n+   |                                                                   ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Relaxed`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:42:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr, ptr2, Ordering::Relaxed, Ordering::Acquire);\n+   |                                                                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `Acquire`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:45:67\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::Acquire, Ordering::SeqCst);\n+   |                                                                   ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: compare_exchange_weak's failure ordering may not be stronger than the success ordering of `AcqRel`\n+  --> $DIR/atomic_ordering_exchange_weak.rs:46:66\n+   |\n+LL |     let _ = x.compare_exchange_weak(ptr2, ptr, Ordering::AcqRel, Ordering::SeqCst);\n+   |                                                                  ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: aborting due to 16 previous errors\n+"}, {"sha": "550bdb001e4cd1270b3bc6d32fd5e53c04f28bfe", "filename": "tests/ui/atomic_ordering_fetch_update.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_fetch_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_fetch_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fetch_update.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,45 @@\n+#![warn(clippy::invalid_atomic_ordering)]\n+\n+use std::sync::atomic::{AtomicIsize, Ordering};\n+\n+fn main() {\n+    // `fetch_update` testing\n+    let x = AtomicIsize::new(0);\n+\n+    // Allowed ordering combos\n+    let _ = x.fetch_update(Ordering::Relaxed, Ordering::Relaxed, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Acquire, Ordering::Acquire, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Acquire, Ordering::Relaxed, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Release, Ordering::Relaxed, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::AcqRel, Ordering::Acquire, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::AcqRel, Ordering::Relaxed, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::SeqCst, Ordering::Relaxed, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::SeqCst, Ordering::Acquire, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |old| Some(old + 1));\n+\n+    // AcqRel is always forbidden as a failure ordering\n+    let _ = x.fetch_update(Ordering::Relaxed, Ordering::AcqRel, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Acquire, Ordering::AcqRel, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Release, Ordering::AcqRel, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::AcqRel, Ordering::AcqRel, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::SeqCst, Ordering::AcqRel, |old| Some(old + 1));\n+\n+    // Release is always forbidden as a failure ordering\n+    let _ = x.fetch_update(Ordering::Relaxed, Ordering::Release, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Acquire, Ordering::Release, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Release, Ordering::Release, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::AcqRel, Ordering::Release, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::SeqCst, Ordering::Release, |old| Some(old + 1));\n+\n+    // Release success order forbids failure order of Acquire or SeqCst\n+    let _ = x.fetch_update(Ordering::Release, Ordering::Acquire, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Release, Ordering::SeqCst, |old| Some(old + 1));\n+\n+    // Relaxed success order also forbids failure order of Acquire or SeqCst\n+    let _ = x.fetch_update(Ordering::Relaxed, Ordering::SeqCst, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::Relaxed, Ordering::Acquire, |old| Some(old + 1));\n+\n+    // Acquire/AcqRel forbids failure order of SeqCst\n+    let _ = x.fetch_update(Ordering::Acquire, Ordering::SeqCst, |old| Some(old + 1));\n+    let _ = x.fetch_update(Ordering::AcqRel, Ordering::SeqCst, |old| Some(old + 1));\n+}"}, {"sha": "694548ece97b250b52d756ee143437646e1a7353", "filename": "tests/ui/atomic_ordering_fetch_update.stderr", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_fetch_update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fatomic_ordering_fetch_update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fetch_update.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,131 @@\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:21:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::AcqRel, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:22:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Acquire, Ordering::AcqRel, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:23:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Release, Ordering::AcqRel, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:24:46\n+   |\n+LL |     let _ = x.fetch_update(Ordering::AcqRel, Ordering::AcqRel, |old| Some(old + 1));\n+   |                                              ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:25:46\n+   |\n+LL |     let _ = x.fetch_update(Ordering::SeqCst, Ordering::AcqRel, |old| Some(old + 1));\n+   |                                              ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:28:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::Release, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:29:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Acquire, Ordering::Release, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:30:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Release, Ordering::Release, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:31:46\n+   |\n+LL |     let _ = x.fetch_update(Ordering::AcqRel, Ordering::Release, |old| Some(old + 1));\n+   |                                              ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be `Release` or `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:32:46\n+   |\n+LL |     let _ = x.fetch_update(Ordering::SeqCst, Ordering::Release, |old| Some(old + 1));\n+   |                                              ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be stronger than the success ordering of `Release`\n+  --> $DIR/atomic_ordering_fetch_update.rs:35:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Release, Ordering::Acquire, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be stronger than the success ordering of `Release`\n+  --> $DIR/atomic_ordering_fetch_update.rs:36:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Release, Ordering::SeqCst, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be stronger than the success ordering of `Relaxed`\n+  --> $DIR/atomic_ordering_fetch_update.rs:39:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::SeqCst, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be stronger than the success ordering of `Relaxed`\n+  --> $DIR/atomic_ordering_fetch_update.rs:40:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Relaxed, Ordering::Acquire, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering mode `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be stronger than the success ordering of `Acquire`\n+  --> $DIR/atomic_ordering_fetch_update.rs:43:47\n+   |\n+LL |     let _ = x.fetch_update(Ordering::Acquire, Ordering::SeqCst, |old| Some(old + 1));\n+   |                                               ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: fetch_update's failure ordering may not be stronger than the success ordering of `AcqRel`\n+  --> $DIR/atomic_ordering_fetch_update.rs:44:46\n+   |\n+LL |     let _ = x.fetch_update(Ordering::AcqRel, Ordering::SeqCst, |old| Some(old + 1));\n+   |                                              ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire` or `Relaxed` instead\n+\n+error: aborting due to 16 previous errors\n+"}, {"sha": "9fcc9ece49bb7e78840a34078d960e342e466329", "filename": "tests/ui/borrow_interior_mutable_const.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fborrow_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fborrow_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -19,16 +19,30 @@ const NO_ANN: &dyn Display = &70;\n static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T>: Copy {\n-    type NonCopyType;\n+trait Trait<T> {\n+    type AssocType;\n \n     const ATOMIC: AtomicUsize;\n+    const INPUT: T;\n+    const ASSOC: Self::AssocType;\n+\n+    fn function() {\n+        let _ = &Self::INPUT;\n+        let _ = &Self::ASSOC;\n+    }\n }\n \n impl Trait<u32> for u64 {\n-    type NonCopyType = u16;\n+    type AssocType = AtomicUsize;\n \n     const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const INPUT: u32 = 10;\n+    const ASSOC: Self::AssocType = AtomicUsize::new(11);\n+\n+    fn function() {\n+        let _ = &Self::INPUT;\n+        let _ = &Self::ASSOC; //~ ERROR interior mutability\n+    }\n }\n \n // This is just a pointer that can be safely dereferended,"}, {"sha": "ed726a6b46e64b9e4b62cab9bc18f1c93baf93ba", "filename": "tests/ui/borrow_interior_mutable_const.stderr", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,131 +1,139 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:66:5\n+  --> $DIR/borrow_interior_mutable_const.rs:44:18\n+   |\n+LL |         let _ = &Self::ASSOC; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/borrow_interior_mutable_const.rs:80:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n    |\n-   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:67:16\n+  --> $DIR/borrow_interior_mutable_const.rs:81:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:70:22\n+  --> $DIR/borrow_interior_mutable_const.rs:84:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:71:25\n+  --> $DIR/borrow_interior_mutable_const.rs:85:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:72:27\n+  --> $DIR/borrow_interior_mutable_const.rs:86:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:73:26\n+  --> $DIR/borrow_interior_mutable_const.rs:87:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:84:14\n+  --> $DIR/borrow_interior_mutable_const.rs:98:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:85:14\n+  --> $DIR/borrow_interior_mutable_const.rs:99:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:86:19\n+  --> $DIR/borrow_interior_mutable_const.rs:100:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:87:14\n+  --> $DIR/borrow_interior_mutable_const.rs:101:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:88:13\n+  --> $DIR/borrow_interior_mutable_const.rs:102:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:94:13\n+  --> $DIR/borrow_interior_mutable_const.rs:108:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:99:5\n+  --> $DIR/borrow_interior_mutable_const.rs:113:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:100:16\n+  --> $DIR/borrow_interior_mutable_const.rs:114:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:113:5\n+  --> $DIR/borrow_interior_mutable_const.rs:127:5\n    |\n LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:114:16\n+  --> $DIR/borrow_interior_mutable_const.rs:128:16\n    |\n LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n    |                ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "3afcdca2f04dd165b03f7fb7fcdf0e12d0867073", "filename": "tests/ui/declare_interior_mutable_const.rs", "status": "modified", "additions": 121, "deletions": 40, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdeclare_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdeclare_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -34,60 +34,141 @@ static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n #[allow(clippy::declare_interior_mutable_const)]\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T>: Copy {\n-    type NonCopyType;\n-\n+// a constant whose type is a concrete type should be linted at the definition site.\n+trait ConcreteTypes {\n     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n     const INTEGER: u64;\n     const STRING: String;\n-    const SELF: Self; // (no error)\n-    const INPUT: T;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `T` to be `Copy`\n-    const ASSOC: Self::NonCopyType;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+    declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR interior mutable\n+}\n \n-    const AN_INPUT: T = Self::INPUT;\n-    //~^ ERROR interior mutable\n-    //~| ERROR consider requiring `T` to be `Copy`\n-    declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n+impl ConcreteTypes for u64 {\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const INTEGER: u64 = 10;\n+    const STRING: String = String::new();\n }\n \n-trait Trait2 {\n-    type CopyType: Copy;\n+// a helper trait used below\n+trait ConstDefault {\n+    const DEFAULT: Self;\n+}\n+\n+// a constant whose type is a generic type should be linted at the implementation site.\n+trait GenericTypes<T, U> {\n+    const TO_REMAIN_GENERIC: T;\n+    const TO_BE_CONCRETE: U;\n \n-    const SELF_2: Self;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `Self` to be `Copy`\n-    const ASSOC_2: Self::CopyType; // (no error)\n+    const HAVING_DEFAULT: T = Self::TO_REMAIN_GENERIC;\n+    declare_const!(IN_MACRO: T = Self::TO_REMAIN_GENERIC);\n }\n \n-// we don't lint impl of traits, because an impl has no power to change the interface.\n-impl Trait<u32> for u64 {\n-    type NonCopyType = u16;\n+impl<T: ConstDefault> GenericTypes<T, AtomicUsize> for u64 {\n+    const TO_REMAIN_GENERIC: T = T::DEFAULT;\n+    const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11); //~ ERROR interior mutable\n+}\n \n-    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n-    const INTEGER: u64 = 10;\n-    const STRING: String = String::new();\n-    const SELF: Self = 11;\n-    const INPUT: u32 = 12;\n-    const ASSOC: Self::NonCopyType = 13;\n+// a helper type used below\n+struct Wrapper<T>(T);\n+\n+// a constant whose type is an associated type should be linted at the implementation site, too.\n+trait AssocTypes {\n+    type ToBeFrozen;\n+    type ToBeUnfrozen;\n+    type ToBeGenericParam;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen;\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen>;\n+    // to ensure it can handle things when a generic type remains after normalization.\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam>;\n }\n \n-struct Local<T, U>(T, U);\n+impl<T: ConstDefault> AssocTypes for Vec<T> {\n+    type ToBeFrozen = u16;\n+    type ToBeUnfrozen = AtomicUsize;\n+    type ToBeGenericParam = T;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen = 12;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13); //~ ERROR interior mutable\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14)); //~ ERROR interior mutable\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam> = Wrapper(T::DEFAULT);\n+}\n+\n+// a helper trait used below\n+trait AssocTypesHelper {\n+    type NotToBeBounded;\n+    type ToBeBounded;\n+\n+    const NOT_TO_BE_BOUNDED: Self::NotToBeBounded;\n+}\n \n-impl<T: Trait2 + Trait<u32>, U: Trait2> Local<T, U> {\n-    const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n+// a constant whose type is an assoc type originated from a generic param bounded at the definition\n+// site should be linted at there.\n+trait AssocTypesFromGenericParam<T>\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const NOT_BOUNDED: T::NotToBeBounded;\n+    const BOUNDED: T::ToBeBounded; //~ ERROR interior mutable\n+}\n+\n+impl<T> AssocTypesFromGenericParam<T> for u64\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    // an associated type could remain unknown in a trait impl.\n+    const NOT_BOUNDED: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED: T::ToBeBounded = AtomicUsize::new(15);\n+}\n+\n+// a constant whose type is `Self` should be linted at the implementation site as well.\n+// (`Option` requires `Sized` bound.)\n+trait SelfType: Sized {\n+    const SELF: Self;\n+    // this was the one in the original issue (#5050).\n+    const WRAPPED_SELF: Option<Self>;\n+}\n+\n+impl SelfType for u64 {\n+    const SELF: Self = 16;\n+    const WRAPPED_SELF: Option<Self> = Some(20);\n+}\n+\n+impl SelfType for AtomicUsize {\n+    // this (interior mutable `Self` const) exists in `parking_lot`.\n+    // `const_trait_impl` will replace it in the future, hopefully.\n+    const SELF: Self = AtomicUsize::new(17); //~ ERROR interior mutable\n+    const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n+}\n+\n+// Even though a constant contains a generic type, if it also have a interior mutable type,\n+// it should be linted at the definition site.\n+trait BothOfCellAndGeneric<T> {\n+    // this is a false negative in the current implementation.\n+    const DIRECT: Cell<T>;\n+    const INDIRECT: Cell<*const T>; //~ ERROR interior mutable\n+}\n+\n+impl<T: ConstDefault> BothOfCellAndGeneric<T> for u64 {\n+    const DIRECT: Cell<T> = Cell::new(T::DEFAULT);\n+    const INDIRECT: Cell<*const T> = Cell::new(std::ptr::null());\n+}\n+\n+struct Local<T>(T);\n+\n+// a constant in an inherent impl are essentially the same as a normal const item\n+// except there can be a generic or associated type.\n+impl<T> Local<T>\n+where\n+    T: ConstDefault + AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(18); //~ ERROR interior mutable\n     const COW: Cow<'static, str> = Cow::Borrowed(\"tuvwxy\");\n-    const T_SELF: T = T::SELF_2;\n-    const U_SELF: U = U::SELF_2;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `U` to be `Copy`\n-    const T_ASSOC: T::NonCopyType = T::ASSOC;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n-    const U_ASSOC: U::CopyType = U::ASSOC_2;\n+\n+    const GENERIC_TYPE: T = T::DEFAULT;\n+\n+    const ASSOC_TYPE: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19); //~ ERROR interior mutable\n }\n \n fn main() {}"}, {"sha": "5cb10be88d89cde900cfaa62c2861852dd7bde8a", "filename": "tests/ui/declare_interior_mutable_const.stderr", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdeclare_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdeclare_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -36,75 +36,75 @@ LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:40:5\n+  --> $DIR/declare_interior_mutable_const.rs:39:5\n    |\n LL |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:44:5\n+  --> $DIR/declare_interior_mutable_const.rs:16:9\n+   |\n+LL |         const $name: $ty = $e;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR interior mutable\n+   |     ----------------------------------------------------------- in this macro invocation\n    |\n-LL |     const INPUT: T;\n-   |     ^^^^^^^^^^^^^-^\n-   |                  |\n-   |                  consider requiring `T` to be `Copy`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:47:5\n+  --> $DIR/declare_interior_mutable_const.rs:67:5\n    |\n-LL |     const ASSOC: Self::NonCopyType;\n-   |     ^^^^^^^^^^^^^-----------------^\n-   |                  |\n-   |                  consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+LL |     const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:51:5\n+  --> $DIR/declare_interior_mutable_const.rs:92:5\n    |\n-LL |     const AN_INPUT: T = Self::INPUT;\n-   |     ^^^^^^^^^^^^^^^^-^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     consider requiring `T` to be `Copy`\n+LL |     const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:16:9\n+  --> $DIR/declare_interior_mutable_const.rs:93:5\n    |\n-LL |         const $name: $ty = $e;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL |     declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n-   |     ----------------------------------------------- in this macro invocation\n+LL |     const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/declare_interior_mutable_const.rs:112:5\n    |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |     const BOUNDED: T::ToBeBounded; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/declare_interior_mutable_const.rs:140:5\n+   |\n+LL |     const SELF: Self = AtomicUsize::new(17); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:60:5\n+  --> $DIR/declare_interior_mutable_const.rs:141:5\n    |\n-LL |     const SELF_2: Self;\n-   |     ^^^^^^^^^^^^^^----^\n-   |                   |\n-   |                   consider requiring `Self` to be `Copy`\n+LL |     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:81:5\n+  --> $DIR/declare_interior_mutable_const.rs:149:5\n    |\n-LL |     const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const INDIRECT: Cell<*const T>; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:84:5\n+  --> $DIR/declare_interior_mutable_const.rs:165:5\n    |\n-LL |     const U_SELF: U = U::SELF_2;\n-   |     ^^^^^^^^^^^^^^-^^^^^^^^^^^^^\n-   |                   |\n-   |                   consider requiring `U` to be `Copy`\n+LL |     const ATOMIC: AtomicUsize = AtomicUsize::new(18); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:87:5\n+  --> $DIR/declare_interior_mutable_const.rs:171:5\n    |\n-LL |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n-   |     ^^^^^^^^^^^^^^^--------------^^^^^^^^^^^^\n-   |                    |\n-   |                    consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n+LL |     const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "6b5bcdaa78e2762cd82fc68130cdb4405d217e03", "filename": "tests/ui/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_ref.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,6 @@\n #![warn(clippy::drop_ref)]\n #![allow(clippy::toplevel_ref_arg)]\n+#![allow(clippy::map_err_ignore)]\n \n use std::mem::drop;\n "}, {"sha": "7974bf56d44cf582e1b80e98ecf4c31c4aeb226e", "filename": "tests/ui/drop_ref.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdrop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fdrop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_ref.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,108 +1,108 @@\n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:9:5\n+  --> $DIR/drop_ref.rs:10:5\n    |\n LL |     drop(&SomeStruct);\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::drop-ref` implied by `-D warnings`\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:9:10\n+  --> $DIR/drop_ref.rs:10:10\n    |\n LL |     drop(&SomeStruct);\n    |          ^^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:12:5\n+  --> $DIR/drop_ref.rs:13:5\n    |\n LL |     drop(&owned1);\n    |     ^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:12:10\n+  --> $DIR/drop_ref.rs:13:10\n    |\n LL |     drop(&owned1);\n    |          ^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:13:5\n+  --> $DIR/drop_ref.rs:14:5\n    |\n LL |     drop(&&owned1);\n    |     ^^^^^^^^^^^^^^\n    |\n note: argument has type `&&SomeStruct`\n-  --> $DIR/drop_ref.rs:13:10\n+  --> $DIR/drop_ref.rs:14:10\n    |\n LL |     drop(&&owned1);\n    |          ^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:14:5\n+  --> $DIR/drop_ref.rs:15:5\n    |\n LL |     drop(&mut owned1);\n    |     ^^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&mut SomeStruct`\n-  --> $DIR/drop_ref.rs:14:10\n+  --> $DIR/drop_ref.rs:15:10\n    |\n LL |     drop(&mut owned1);\n    |          ^^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:18:5\n+  --> $DIR/drop_ref.rs:19:5\n    |\n LL |     drop(reference1);\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:18:10\n+  --> $DIR/drop_ref.rs:19:10\n    |\n LL |     drop(reference1);\n    |          ^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:21:5\n+  --> $DIR/drop_ref.rs:22:5\n    |\n LL |     drop(reference2);\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&mut SomeStruct`\n-  --> $DIR/drop_ref.rs:21:10\n+  --> $DIR/drop_ref.rs:22:10\n    |\n LL |     drop(reference2);\n    |          ^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:24:5\n+  --> $DIR/drop_ref.rs:25:5\n    |\n LL |     drop(reference3);\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:24:10\n+  --> $DIR/drop_ref.rs:25:10\n    |\n LL |     drop(reference3);\n    |          ^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:29:5\n+  --> $DIR/drop_ref.rs:30:5\n    |\n LL |     drop(&val);\n    |     ^^^^^^^^^^\n    |\n note: argument has type `&T`\n-  --> $DIR/drop_ref.rs:29:10\n+  --> $DIR/drop_ref.rs:30:10\n    |\n LL |     drop(&val);\n    |          ^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:37:5\n+  --> $DIR/drop_ref.rs:38:5\n    |\n LL |     std::mem::drop(&SomeStruct);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:37:20\n+  --> $DIR/drop_ref.rs:38:20\n    |\n LL |     std::mem::drop(&SomeStruct);\n    |                    ^^^^^^^^^^^"}, {"sha": "f7c380fc915c06a14f595c6b3a9ce66c16382ce5", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -2,50 +2,50 @@ error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:65:5\n    |\n LL |     ONE as f64 != 2.0;\n-   |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE as f64 - 2.0).abs() > error`\n+   |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE as f64 - 2.0).abs() > error_margin`\n    |\n    = note: `-D clippy::float-cmp` implied by `-D warnings`\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:70:5\n    |\n LL |     x == 1.0;\n-   |     ^^^^^^^^ help: consider comparing them within some error: `(x - 1.0).abs() < error`\n+   |     ^^^^^^^^ help: consider comparing them within some margin of error: `(x - 1.0).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:73:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(twice(x) - twice(ONE as f64)).abs() > error`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(twice(x) - twice(ONE as f64)).abs() > error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:93:5\n    |\n LL |     NON_ZERO_ARRAY[i] == NON_ZERO_ARRAY[j];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` arrays\n   --> $DIR/float_cmp.rs:98:5\n    |\n LL |     a1 == a2;\n    |     ^^^^^^^^\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:99:5\n    |\n LL |     a1[0] == a2[0];\n-   |     ^^^^^^^^^^^^^^ help: consider comparing them within some error: `(a1[0] - a2[0]).abs() < error`\n+   |     ^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(a1[0] - a2[0]).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "5d0455363e8e02dc2167dfe6833902751267876f", "filename": "tests/ui/float_cmp_const.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ffloat_cmp_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ffloat_cmp_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp_const.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -2,66 +2,66 @@ error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:20:5\n    |\n LL |     1f32 == ONE;\n-   |     ^^^^^^^^^^^ help: consider comparing them within some error: `(1f32 - ONE).abs() < error`\n+   |     ^^^^^^^^^^^ help: consider comparing them within some margin of error: `(1f32 - ONE).abs() < error_margin`\n    |\n    = note: `-D clippy::float-cmp-const` implied by `-D warnings`\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:21:5\n    |\n LL |     TWO == ONE;\n-   |     ^^^^^^^^^^ help: consider comparing them within some error: `(TWO - ONE).abs() < error`\n+   |     ^^^^^^^^^^ help: consider comparing them within some margin of error: `(TWO - ONE).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:22:5\n    |\n LL |     TWO != ONE;\n-   |     ^^^^^^^^^^ help: consider comparing them within some error: `(TWO - ONE).abs() > error`\n+   |     ^^^^^^^^^^ help: consider comparing them within some margin of error: `(TWO - ONE).abs() > error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:23:5\n    |\n LL |     ONE + ONE == TWO;\n-   |     ^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE + ONE - TWO).abs() < error`\n+   |     ^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE + ONE - TWO).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:25:5\n    |\n LL |     x as f32 == ONE;\n-   |     ^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(x as f32 - ONE).abs() < error`\n+   |     ^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(x as f32 - ONE).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:28:5\n    |\n LL |     v == ONE;\n-   |     ^^^^^^^^ help: consider comparing them within some error: `(v - ONE).abs() < error`\n+   |     ^^^^^^^^ help: consider comparing them within some margin of error: `(v - ONE).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:29:5\n    |\n LL |     v != ONE;\n-   |     ^^^^^^^^ help: consider comparing them within some error: `(v - ONE).abs() > error`\n+   |     ^^^^^^^^ help: consider comparing them within some margin of error: `(v - ONE).abs() > error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant arrays\n   --> $DIR/float_cmp_const.rs:61:5\n    |\n LL |     NON_ZERO_ARRAY == NON_ZERO_ARRAY2;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "ca8ca53c80c3f436956fef359df23a0778ebd111", "filename": "tests/ui/indexing_slicing_index.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Findexing_slicing_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Findexing_slicing_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_index.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -15,7 +15,8 @@ fn main() {\n     x[3]; // Ok, should not produce stderr.\n \n     let y = &x;\n-    y[0];\n+    y[0]; // Ok, referencing shouldn't affect this lint. See the issue 6021\n+    y[4]; // Ok, rustc will handle references too.\n \n     let v = vec![0; 5];\n     v[0];"}, {"sha": "2f6c9e2f4e5a09c4f4d38913515f255c19850d08", "filename": "tests/ui/indexing_slicing_index.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Findexing_slicing_index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Findexing_slicing_index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_index.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -8,52 +8,44 @@ LL |     x[index];\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n error: indexing may panic.\n-  --> $DIR/indexing_slicing_index.rs:18:5\n-   |\n-LL |     y[0];\n-   |     ^^^^\n-   |\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n-\n-error: indexing may panic.\n-  --> $DIR/indexing_slicing_index.rs:21:5\n+  --> $DIR/indexing_slicing_index.rs:22:5\n    |\n LL |     v[0];\n    |     ^^^^\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n error: indexing may panic.\n-  --> $DIR/indexing_slicing_index.rs:22:5\n+  --> $DIR/indexing_slicing_index.rs:23:5\n    |\n LL |     v[10];\n    |     ^^^^^\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n error: indexing may panic.\n-  --> $DIR/indexing_slicing_index.rs:23:5\n+  --> $DIR/indexing_slicing_index.rs:24:5\n    |\n LL |     v[1 << 3];\n    |     ^^^^^^^^^\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n error: indexing may panic.\n-  --> $DIR/indexing_slicing_index.rs:29:5\n+  --> $DIR/indexing_slicing_index.rs:30:5\n    |\n LL |     v[N];\n    |     ^^^^\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n error: indexing may panic.\n-  --> $DIR/indexing_slicing_index.rs:30:5\n+  --> $DIR/indexing_slicing_index.rs:31:5\n    |\n LL |     v[M];\n    |     ^^^^\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "2231deee833ee362be885eaaf0a7ed3d321209a2", "filename": "tests/ui/indexing_slicing_slice.stderr", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Findexing_slicing_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Findexing_slicing_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_slice.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -71,29 +71,17 @@ LL |     &x[1..][..5];\n    |\n    = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n \n-error: slicing may panic.\n-  --> $DIR/indexing_slicing_slice.rs:24:6\n-   |\n-LL |     &y[1..2];\n-   |      ^^^^^^^\n-   |\n-   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n-\n-error: slicing may panic.\n-  --> $DIR/indexing_slicing_slice.rs:25:6\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing_slice.rs:25:12\n    |\n LL |     &y[0..=4];\n-   |      ^^^^^^^^\n-   |\n-   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+   |            ^\n \n-error: slicing may panic.\n-  --> $DIR/indexing_slicing_slice.rs:26:6\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing_slice.rs:26:11\n    |\n LL |     &y[..=4];\n-   |      ^^^^^^^\n-   |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   |           ^\n \n error: slicing may panic.\n   --> $DIR/indexing_slicing_slice.rs:31:6\n@@ -133,5 +121,5 @@ LL |     &v[..100];\n    |\n    = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "28003b365bbd50f675dd7fb11bf4759a3badb243", "filename": "tests/ui/into_iter_on_ref.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Finto_iter_on_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Finto_iter_on_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,162 +1,162 @@\n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `Vec`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `Vec`\n   --> $DIR/into_iter_on_ref.rs:14:30\n    |\n LL |     let _ = (&vec![1, 2, 3]).into_iter(); //~ WARN equivalent to .iter()\n    |                              ^^^^^^^^^ help: call directly: `iter`\n    |\n    = note: `-D clippy::into-iter-on-ref` implied by `-D warnings`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `slice`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `slice`\n   --> $DIR/into_iter_on_ref.rs:15:46\n    |\n LL |     let _ = vec![1, 2, 3].into_boxed_slice().into_iter(); //~ WARN equivalent to .iter()\n    |                                              ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `slice`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `slice`\n   --> $DIR/into_iter_on_ref.rs:16:41\n    |\n LL |     let _ = std::rc::Rc::from(&[X][..]).into_iter(); //~ WARN equivalent to .iter()\n    |                                         ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `slice`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `slice`\n   --> $DIR/into_iter_on_ref.rs:17:44\n    |\n LL |     let _ = std::sync::Arc::from(&[X][..]).into_iter(); //~ WARN equivalent to .iter()\n    |                                            ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `array`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `array`\n   --> $DIR/into_iter_on_ref.rs:19:32\n    |\n LL |     let _ = (&&&&&&&[1, 2, 3]).into_iter(); //~ ERROR equivalent to .iter()\n    |                                ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `array`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `array`\n   --> $DIR/into_iter_on_ref.rs:20:36\n    |\n LL |     let _ = (&&&&mut &&&[1, 2, 3]).into_iter(); //~ ERROR equivalent to .iter()\n    |                                    ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `array`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `array`\n   --> $DIR/into_iter_on_ref.rs:21:40\n    |\n LL |     let _ = (&mut &mut &mut [1, 2, 3]).into_iter(); //~ ERROR equivalent to .iter_mut()\n    |                                        ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `Option`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `Option`\n   --> $DIR/into_iter_on_ref.rs:23:24\n    |\n LL |     let _ = (&Some(4)).into_iter(); //~ WARN equivalent to .iter()\n    |                        ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `Option`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `Option`\n   --> $DIR/into_iter_on_ref.rs:24:28\n    |\n LL |     let _ = (&mut Some(5)).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                            ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `Result`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `Result`\n   --> $DIR/into_iter_on_ref.rs:25:32\n    |\n LL |     let _ = (&Ok::<_, i32>(6)).into_iter(); //~ WARN equivalent to .iter()\n    |                                ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `Result`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `Result`\n   --> $DIR/into_iter_on_ref.rs:26:37\n    |\n LL |     let _ = (&mut Err::<i32, _>(7)).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                                     ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `Vec`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `Vec`\n   --> $DIR/into_iter_on_ref.rs:27:34\n    |\n LL |     let _ = (&Vec::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                  ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `Vec`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `Vec`\n   --> $DIR/into_iter_on_ref.rs:28:38\n    |\n LL |     let _ = (&mut Vec::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                                      ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `BTreeMap`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `BTreeMap`\n   --> $DIR/into_iter_on_ref.rs:29:44\n    |\n LL |     let _ = (&BTreeMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                            ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `BTreeMap`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `BTreeMap`\n   --> $DIR/into_iter_on_ref.rs:30:48\n    |\n LL |     let _ = (&mut BTreeMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                                                ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `VecDeque`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `VecDeque`\n   --> $DIR/into_iter_on_ref.rs:31:39\n    |\n LL |     let _ = (&VecDeque::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                       ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `VecDeque`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `VecDeque`\n   --> $DIR/into_iter_on_ref.rs:32:43\n    |\n LL |     let _ = (&mut VecDeque::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                                           ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `LinkedList`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `LinkedList`\n   --> $DIR/into_iter_on_ref.rs:33:41\n    |\n LL |     let _ = (&LinkedList::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                         ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `LinkedList`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `LinkedList`\n   --> $DIR/into_iter_on_ref.rs:34:45\n    |\n LL |     let _ = (&mut LinkedList::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                                             ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `HashMap`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `HashMap`\n   --> $DIR/into_iter_on_ref.rs:35:43\n    |\n LL |     let _ = (&HashMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                           ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not move the `HashMap`\n+error: this `.into_iter()` call is equivalent to `.iter_mut()` and will not consume the `HashMap`\n   --> $DIR/into_iter_on_ref.rs:36:47\n    |\n LL |     let _ = (&mut HashMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n    |                                               ^^^^^^^^^ help: call directly: `iter_mut`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `BTreeSet`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `BTreeSet`\n   --> $DIR/into_iter_on_ref.rs:38:39\n    |\n LL |     let _ = (&BTreeSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                       ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `BinaryHeap`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `BinaryHeap`\n   --> $DIR/into_iter_on_ref.rs:39:41\n    |\n LL |     let _ = (&BinaryHeap::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                         ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `HashSet`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `HashSet`\n   --> $DIR/into_iter_on_ref.rs:40:38\n    |\n LL |     let _ = (&HashSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n    |                                      ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `Path`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `Path`\n   --> $DIR/into_iter_on_ref.rs:41:43\n    |\n LL |     let _ = std::path::Path::new(\"12/34\").into_iter(); //~ WARN equivalent to .iter()\n    |                                           ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `PathBuf`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `PathBuf`\n   --> $DIR/into_iter_on_ref.rs:42:47\n    |\n LL |     let _ = std::path::PathBuf::from(\"12/34\").into_iter(); //~ ERROR equivalent to .iter()\n    |                                               ^^^^^^^^^ help: call directly: `iter`\n \n-error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `array`\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not consume the `array`\n   --> $DIR/into_iter_on_ref.rs:44:26\n    |\n LL |     let _ = (&[1, 2, 3]).into_iter().next(); //~ WARN equivalent to .iter()"}, {"sha": "32a67f181df435ed1157c5d00f6196495509668a", "filename": "tests/ui/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_if_seq.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -33,6 +33,7 @@ fn issue985_alt() -> i32 {\n     x\n }\n \n+#[allow(clippy::manual_strip)]\n fn issue975() -> String {\n     let mut udn = \"dummy\".to_string();\n     if udn.starts_with(\"uuid:\") {"}, {"sha": "7de560c73486bf7e622523d4af6036b8ac4b5163", "filename": "tests/ui/let_if_seq.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Flet_if_seq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Flet_if_seq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_if_seq.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,5 @@\n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:63:5\n+  --> $DIR/let_if_seq.rs:64:5\n    |\n LL | /     let mut foo = 0;\n LL | |     if f() {\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: you might not need `mut` at all\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:68:5\n+  --> $DIR/let_if_seq.rs:69:5\n    |\n LL | /     let mut bar = 0;\n LL | |     if f() {\n@@ -25,7 +25,7 @@ LL | |     }\n    = note: you might not need `mut` at all\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:76:5\n+  --> $DIR/let_if_seq.rs:77:5\n    |\n LL | /     let quz;\n LL | |     if f() {\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^ help: it is more idiomatic to write: `let quz = if f() { 42 } else { 0 };`\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:105:5\n+  --> $DIR/let_if_seq.rs:106:5\n    |\n LL | /     let mut baz = 0;\n LL | |     if f() {"}, {"sha": "cbb84eb5c7e3709411156d5c5483cdf1020fe567", "filename": "tests/ui/manual_strip.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_strip.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,66 @@\n+#![warn(clippy::manual_strip)]\n+\n+fn main() {\n+    let s = \"abc\";\n+\n+    if s.starts_with(\"ab\") {\n+        str::to_string(&s[\"ab\".len()..]);\n+        s[\"ab\".len()..].to_string();\n+\n+        str::to_string(&s[2..]);\n+        s[2..].to_string();\n+    }\n+\n+    if s.ends_with(\"bc\") {\n+        str::to_string(&s[..s.len() - \"bc\".len()]);\n+        s[..s.len() - \"bc\".len()].to_string();\n+\n+        str::to_string(&s[..s.len() - 2]);\n+        s[..s.len() - 2].to_string();\n+    }\n+\n+    // Character patterns\n+    if s.starts_with('a') {\n+        str::to_string(&s[1..]);\n+        s[1..].to_string();\n+    }\n+\n+    // Variable prefix\n+    let prefix = \"ab\";\n+    if s.starts_with(prefix) {\n+        str::to_string(&s[prefix.len()..]);\n+    }\n+\n+    // Constant prefix\n+    const PREFIX: &str = \"ab\";\n+    if s.starts_with(PREFIX) {\n+        str::to_string(&s[PREFIX.len()..]);\n+        str::to_string(&s[2..]);\n+    }\n+\n+    // Constant target\n+    const TARGET: &str = \"abc\";\n+    if TARGET.starts_with(prefix) {\n+        str::to_string(&TARGET[prefix.len()..]);\n+    }\n+\n+    // String target - not mutated.\n+    let s1: String = \"abc\".into();\n+    if s1.starts_with(\"ab\") {\n+        s1[2..].to_uppercase();\n+    }\n+\n+    // String target - mutated. (Don't lint.)\n+    let mut s2: String = \"abc\".into();\n+    if s2.starts_with(\"ab\") {\n+        s2.push('d');\n+        s2[2..].to_uppercase();\n+    }\n+\n+    // Target not stripped. (Don't lint.)\n+    let s3 = String::from(\"abcd\");\n+    let s4 = String::from(\"efgh\");\n+    if s3.starts_with(\"ab\") {\n+        s4[2..].to_string();\n+    }\n+}"}, {"sha": "1352a8713d4f8d31ef98b3ec74b9b8ebbf88667b", "filename": "tests/ui/manual_strip.stderr", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmanual_strip.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmanual_strip.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_strip.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,132 @@\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:7:24\n+   |\n+LL |         str::to_string(&s[\"ab\".len()..]);\n+   |                        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-strip` implied by `-D warnings`\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:6:5\n+   |\n+LL |     if s.starts_with(\"ab\") {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix(\"ab\") {\n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+LL | \n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+   |\n+\n+error: stripping a suffix manually\n+  --> $DIR/manual_strip.rs:15:24\n+   |\n+LL |         str::to_string(&s[..s.len() - \"bc\".len()]);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the suffix was tested here\n+  --> $DIR/manual_strip.rs:14:5\n+   |\n+LL |     if s.ends_with(\"bc\") {\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_suffix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_suffix(\"bc\") {\n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+LL | \n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:24:24\n+   |\n+LL |         str::to_string(&s[1..]);\n+   |                        ^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:23:5\n+   |\n+LL |     if s.starts_with('a') {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix('a') {\n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:31:24\n+   |\n+LL |         str::to_string(&s[prefix.len()..]);\n+   |                        ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:30:5\n+   |\n+LL |     if s.starts_with(prefix) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix(prefix) {\n+LL |         str::to_string(<stripped>);\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:37:24\n+   |\n+LL |         str::to_string(&s[PREFIX.len()..]);\n+   |                        ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:36:5\n+   |\n+LL |     if s.starts_with(PREFIX) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix(PREFIX) {\n+LL |         str::to_string(<stripped>);\n+LL |         str::to_string(<stripped>);\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:44:24\n+   |\n+LL |         str::to_string(&TARGET[prefix.len()..]);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:43:5\n+   |\n+LL |     if TARGET.starts_with(prefix) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = TARGET.strip_prefix(prefix) {\n+LL |         str::to_string(<stripped>);\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:50:9\n+   |\n+LL |         s1[2..].to_uppercase();\n+   |         ^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:49:5\n+   |\n+LL |     if s1.starts_with(\"ab\") {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s1.strip_prefix(\"ab\") {\n+LL |         <stripped>.to_uppercase();\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "617b6422872645362a68e406fdf92490f78b94b5", "filename": "tests/ui/map_err.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmap_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmap_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_err.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,25 @@\n+#![warn(clippy::map_err_ignore)]\n+use std::convert::TryFrom;\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+enum Errors {\n+    Ignored,\n+}\n+\n+impl Error for Errors {}\n+\n+impl fmt::Display for Errors {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Error\")\n+    }\n+}\n+\n+fn main() -> Result<(), Errors> {\n+    let x = u32::try_from(-123_i32);\n+\n+    println!(\"{:?}\", x.map_err(|_| Errors::Ignored));\n+\n+    Ok(())\n+}"}, {"sha": "7273f4603807865c42ff29e87d7878c12bceaaaa", "filename": "tests/ui/map_err.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmap_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmap_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_err.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,11 @@\n+error: `map_err(|_|...` ignores the original error\n+  --> $DIR/map_err.rs:22:32\n+   |\n+LL |     println!(\"{:?}\", x.map_err(|_| Errors::Ignored));\n+   |                                ^^^\n+   |\n+   = note: `-D clippy::map-err-ignore` implied by `-D warnings`\n+   = help: Consider wrapping the error in an enum variant\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe950b0aa7c7004c729c33cc7b6dab3392d1260a", "filename": "tests/ui/match_type_on_diag_item.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,50 @@\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+#[macro_use]\n+extern crate rustc_session;\n+use rustc_hir::Expr;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+\n+mod paths {\n+    pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n+}\n+\n+mod utils {\n+    use super::*;\n+\n+    pub fn match_type(_cx: &LateContext<'_>, _ty: Ty<'_>, _path: &[&str]) -> bool {\n+        false\n+    }\n+}\n+\n+use utils::match_type;\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Warn,\n+    \"\"\n+}\n+\n+declare_lint_pass!(Pass => [TEST_LINT]);\n+\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n+        let ty = cx.typeck_results().expr_ty(expr);\n+\n+        let _ = match_type(cx, ty, &paths::VEC);\n+        let _ = match_type(cx, ty, &OPTION);\n+        let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+\n+        let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+        let _ = utils::match_type(cx, ty, rc_path);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5e5fe9e3a3e73c494873f3c06cc126ae43989944", "filename": "tests/ui/match_type_on_diag_item.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,33 @@\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:41:17\n+   |\n+LL |         let _ = match_type(cx, ty, &paths::VEC);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/match_type_on_diag_item.rs:1:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n+\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:42:17\n+   |\n+LL |         let _ = match_type(cx, ty, &OPTION);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(option_type))`\n+\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:43:17\n+   |\n+LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(result_type))`\n+\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:46:17\n+   |\n+LL |         let _ = utils::match_type(cx, ty, rc_path);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(Rc))`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a7fb00a270577d64f9e3c9fa24cb2b96f6ffba38", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n+#![allow(clippy::redundant_closure)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     string.map_or((false, \"hello\"), |x| (true, x))\n@@ -36,6 +37,14 @@ fn longer_body(arg: Option<u32>) -> u32 {\n     })\n }\n \n+fn impure_else(arg: Option<i32>) {\n+    let side_effect = || {\n+        println!(\"return 1\");\n+        1\n+    };\n+    let _ = arg.map_or_else(|| side_effect(), |x| x);\n+}\n+\n fn test_map_or_else(arg: Option<u32>) {\n     let _ = arg.map_or_else(|| {\n         let mut y = 1;\n@@ -71,4 +80,5 @@ fn main() {\n     let _ = longer_body(None);\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n+    let _ = impure_else(None);\n }"}, {"sha": "895fd86321faf01fe60fa80213d1c6a62df59bca", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n+#![allow(clippy::redundant_closure)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     if let Some(x) = string {\n@@ -52,6 +53,19 @@ fn longer_body(arg: Option<u32>) -> u32 {\n     }\n }\n \n+fn impure_else(arg: Option<i32>) {\n+    let side_effect = || {\n+        println!(\"return 1\");\n+        1\n+    };\n+    let _ = if let Some(x) = arg {\n+        x\n+    } else {\n+        // map_or_else must be suggested\n+        side_effect()\n+    };\n+}\n+\n fn test_map_or_else(arg: Option<u32>) {\n     let _ = if let Some(x) = arg {\n         x * x * x * x\n@@ -89,4 +103,5 @@ fn main() {\n     let _ = longer_body(None);\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n+    let _ = impure_else(None);\n }"}, {"sha": "b69fe7676827058f6cbda555238c035ca29e71a3", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:5:5\n+  --> $DIR/option_if_let_else.rs:6:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:15:12\n+  --> $DIR/option_if_let_else.rs:16:12\n    |\n LL |       } else if let Some(x) = string {\n    |  ____________^\n@@ -22,19 +22,19 @@ LL | |     }\n    | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:23:13\n+  --> $DIR/option_if_let_else.rs:24:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:24:13\n+  --> $DIR/option_if_let_else.rs:25:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -54,13 +54,13 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:31:13\n+  --> $DIR/option_if_let_else.rs:32:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:32:13\n+  --> $DIR/option_if_let_else.rs:33:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -80,7 +80,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:38:13\n+  --> $DIR/option_if_let_else.rs:39:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -100,7 +100,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:47:5\n+  --> $DIR/option_if_let_else.rs:48:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -119,7 +119,19 @@ LL |     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:56:13\n+  --> $DIR/option_if_let_else.rs:61:13\n+   |\n+LL |       let _ = if let Some(x) = arg {\n+   |  _____________^\n+LL | |         x\n+LL | |     } else {\n+LL | |         // map_or_else must be suggested\n+LL | |         side_effect()\n+LL | |     };\n+   | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:70:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -142,10 +154,10 @@ LL |     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:85:13\n+  --> $DIR/option_if_let_else.rs:99:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "287726f7a2d4e99e827784da54e9a805e47bba14", "filename": "tests/ui/panic_in_result_fn.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,70 @@\n+#![warn(clippy::panic_in_result_fn)]\n+\n+struct A;\n+\n+impl A {\n+    fn result_with_panic() -> Result<bool, String> // should emit lint\n+    {\n+        panic!(\"error\");\n+    }\n+\n+    fn result_with_unimplemented() -> Result<bool, String> // should emit lint\n+    {\n+        unimplemented!();\n+    }\n+\n+    fn result_with_unreachable() -> Result<bool, String> // should emit lint\n+    {\n+        unreachable!();\n+    }\n+\n+    fn result_with_todo() -> Result<bool, String> // should emit lint\n+    {\n+        todo!(\"Finish this\");\n+    }\n+\n+    fn other_with_panic() // should not emit lint\n+    {\n+        panic!(\"\");\n+    }\n+\n+    fn other_with_unreachable() // should not emit lint\n+    {\n+        unreachable!();\n+    }\n+\n+    fn other_with_unimplemented() // should not emit lint\n+    {\n+        unimplemented!();\n+    }\n+\n+    fn other_with_todo() // should not emit lint\n+    {\n+        todo!(\"finish this\")\n+    }\n+\n+    fn result_without_banned_functions() -> Result<bool, String> // should not emit lint\n+    {\n+        Ok(true)\n+    }\n+}\n+\n+fn function_result_with_panic() -> Result<bool, String> // should emit lint\n+{\n+    panic!(\"error\");\n+}\n+\n+fn todo() {\n+    println!(\"something\");\n+}\n+\n+fn function_result_with_custom_todo() -> Result<bool, String> // should not emit lint\n+{\n+    todo();\n+    Ok(true)\n+}\n+\n+fn main() -> Result<(), String> {\n+    todo!(\"finish main method\");\n+    Ok(())\n+}"}, {"sha": "c6936fd86923cfab412f794ce9aea9e47a2a43b0", "filename": "tests/ui/panic_in_result_fn.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fpanic_in_result_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fpanic_in_result_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -0,0 +1,105 @@\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn.rs:6:5\n+   |\n+LL | /     fn result_with_panic() -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         panic!(\"error\");\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn.rs:8:9\n+   |\n+LL |         panic!(\"error\");\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn.rs:11:5\n+   |\n+LL | /     fn result_with_unimplemented() -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         unimplemented!();\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn.rs:13:9\n+   |\n+LL |         unimplemented!();\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn.rs:16:5\n+   |\n+LL | /     fn result_with_unreachable() -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         unreachable!();\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn.rs:18:9\n+   |\n+LL |         unreachable!();\n+   |         ^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn.rs:21:5\n+   |\n+LL | /     fn result_with_todo() -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         todo!(\"Finish this\");\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn.rs:23:9\n+   |\n+LL |         todo!(\"Finish this\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn.rs:52:1\n+   |\n+LL | / fn function_result_with_panic() -> Result<bool, String> // should emit lint\n+LL | | {\n+LL | |     panic!(\"error\");\n+LL | | }\n+   | |_^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn.rs:54:5\n+   |\n+LL |     panic!(\"error\");\n+   |     ^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn.rs:67:1\n+   |\n+LL | / fn main() -> Result<(), String> {\n+LL | |     todo!(\"finish main method\");\n+LL | |     Ok(())\n+LL | | }\n+   | |_^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn.rs:68:5\n+   |\n+LL |     todo!(\"finish main method\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a43a1fc4f5241c33a5ebe6416196793ad2b057cf", "filename": "tests/ui/print_with_newline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -9,6 +9,7 @@ fn main() {\n     print!(\"Hello {}\\n\", \"world\");\n     print!(\"Hello {} {}\\n\", \"world\", \"#2\");\n     print!(\"{}\\n\", 1265);\n+    print!(\"\\n\");\n \n     // these are all fine\n     print!(\"\");"}, {"sha": "54b3ad75b31e83bb9a893ee910257a29de946fcd", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -44,7 +44,18 @@ LL |     println!(\"{}\", 1265);\n    |     ^^^^^^^    --\n \n error: using `print!()` with a format string that ends in a single newline\n-  --> $DIR/print_with_newline.rs:30:5\n+  --> $DIR/print_with_newline.rs:12:5\n+   |\n+LL |     print!(\"/n\");\n+   |     ^^^^^^^^^^^^\n+   |\n+help: use `println!` instead\n+   |\n+LL |     println!();\n+   |     ^^^^^^^ --\n+\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:31:5\n    |\n LL |     print!(\"//n\"); // should fail\n    |     ^^^^^^^^^^^^^^\n@@ -55,7 +66,7 @@ LL |     println!(\"/\"); // should fail\n    |     ^^^^^^^    --\n \n error: using `print!()` with a format string that ends in a single newline\n-  --> $DIR/print_with_newline.rs:37:5\n+  --> $DIR/print_with_newline.rs:38:5\n    |\n LL | /     print!(\n LL | |         \"\n@@ -70,7 +81,7 @@ LL |         \"\"\n    |\n \n error: using `print!()` with a format string that ends in a single newline\n-  --> $DIR/print_with_newline.rs:41:5\n+  --> $DIR/print_with_newline.rs:42:5\n    |\n LL | /     print!(\n LL | |         r\"\n@@ -85,7 +96,7 @@ LL |         r\"\"\n    |\n \n error: using `print!()` with a format string that ends in a single newline\n-  --> $DIR/print_with_newline.rs:49:5\n+  --> $DIR/print_with_newline.rs:50:5\n    |\n LL |     print!(\"/r/n\"); //~ ERROR\n    |     ^^^^^^^^^^^^^^^\n@@ -96,7 +107,7 @@ LL |     println!(\"/r\"); //~ ERROR\n    |     ^^^^^^^     --\n \n error: using `print!()` with a format string that ends in a single newline\n-  --> $DIR/print_with_newline.rs:50:5\n+  --> $DIR/print_with_newline.rs:51:5\n    |\n LL |     print!(\"foo/rbar/n\") // ~ ERROR\n    |     ^^^^^^^^^^^^^^^^^^^^\n@@ -106,5 +117,5 @@ help: use `println!` instead\n LL |     println!(\"foo/rbar\") // ~ ERROR\n    |     ^^^^^^^          --\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "fbdc977b769a413587a80c87dd8393c1116fe8fd", "filename": "tests/ui/trailing_zeros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftrailing_zeros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftrailing_zeros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,5 @@\n #![allow(unused_parens)]\n+#![warn(clippy::verbose_bit_mask)]\n \n fn main() {\n     let x: i32 = 42;"}, {"sha": "798551118309e01650118c0beb29ca398b2bb5ae", "filename": "tests/ui/trailing_zeros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftrailing_zeros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Ftrailing_zeros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,13 +1,13 @@\n error: bit mask could be simplified with a call to `trailing_zeros`\n-  --> $DIR/trailing_zeros.rs:5:13\n+  --> $DIR/trailing_zeros.rs:6:13\n    |\n LL |     let _ = (x & 0b1111 == 0); // suggest trailing_zeros\n    |             ^^^^^^^^^^^^^^^^^ help: try: `x.trailing_zeros() >= 4`\n    |\n    = note: `-D clippy::verbose-bit-mask` implied by `-D warnings`\n \n error: bit mask could be simplified with a call to `trailing_zeros`\n-  --> $DIR/trailing_zeros.rs:6:13\n+  --> $DIR/trailing_zeros.rs:7:13\n    |\n LL |     let _ = x & 0b1_1111 == 0; // suggest trailing_zeros\n    |             ^^^^^^^^^^^^^^^^^ help: try: `x.trailing_zeros() >= 5`"}, {"sha": "4ba2a0a5dbcc1d5dd07beca432d67f708e11e4b8", "filename": "tests/ui/unnecessary_lazy_eval.fixed", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.fixed?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::unnecessary_lazy_evaluations)]\n #![allow(clippy::redundant_closure)]\n #![allow(clippy::bind_instead_of_map)]\n+#![allow(clippy::map_identity)]\n \n struct Deep(Option<usize>);\n \n@@ -34,13 +35,13 @@ fn main() {\n     let _ = opt.unwrap_or(2);\n     let _ = opt.unwrap_or(astronomers_pi);\n     let _ = opt.unwrap_or(ext_str.some_field);\n-    let _ = opt.unwrap_or(ext_arr[0]);\n+    let _ = opt.unwrap_or_else(|| ext_arr[0]);\n     let _ = opt.and(ext_opt);\n     let _ = opt.or(ext_opt);\n     let _ = opt.or(None);\n     let _ = opt.get_or_insert(2);\n     let _ = opt.ok_or(2);\n-    let _ = opt.ok_or(ext_arr[0]);\n+    let _ = nested_tuple_opt.unwrap_or(Some((1, 2)));\n \n     // Cases when unwrap is not called on a simple variable\n     let _ = Some(10).unwrap_or(2);\n@@ -60,7 +61,6 @@ fn main() {\n     // Should not lint - Option\n     let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n     let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n-    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n     let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n     let _ = opt.or_else(some_call);\n     let _ = opt.or_else(|| some_call());\n@@ -69,13 +69,16 @@ fn main() {\n     let _ = deep.0.get_or_insert_with(|| some_call());\n     let _ = deep.0.or_else(some_call);\n     let _ = deep.0.or_else(|| some_call());\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n \n-    // These are handled by bind_instead_of_map\n+    // should not lint, bind_instead_of_map takes priority\n     let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n     let _ = Some(10).and_then(|idx| Some(idx));\n-    let _: Option<usize> = None.or_else(|| Some(3));\n-    let _ = deep.0.or_else(|| Some(3));\n-    let _ = opt.or_else(|| Some(3));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n+    let _: Option<usize> = None.or(Some(3));\n+    let _ = deep.0.or(Some(3));\n+    let _ = opt.or(Some(3));\n \n     // Should lint - Result\n     let res: Result<usize, usize> = Err(5);\n@@ -92,26 +95,28 @@ fn main() {\n     let _ = res2.unwrap_or_else(|err| err.return_some_field());\n     let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n \n+    // should not lint, bind_instead_of_map takes priority\n     let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n-    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n-\n-    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n     let _: Result<usize, usize> = res.or_else(|err| Err(err));\n \n-    // These are handled by bind_instead_of_map\n     let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n \n-    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n-    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n-    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n-\n-    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n-    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n-    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n-\n     let _: Result<usize, usize> = res.or_else(|_| Err(2));\n     let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n     let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n+    let _: Result<usize, usize> = res.and(Err(2));\n+    let _: Result<usize, usize> = res.and(Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and(Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or(Ok(2));\n+    let _: Result<usize, usize> = res.or(Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or(Ok(ext_str.some_field));\n+\n+    // neither bind_instead_of_map nor unnecessary_lazy_eval applies here\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n }"}, {"sha": "466915217e42e9dc94cf983efe4d2b70b29fed0c", "filename": "tests/ui/unnecessary_lazy_eval.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::unnecessary_lazy_evaluations)]\n #![allow(clippy::redundant_closure)]\n #![allow(clippy::bind_instead_of_map)]\n+#![allow(clippy::map_identity)]\n \n struct Deep(Option<usize>);\n \n@@ -40,7 +41,7 @@ fn main() {\n     let _ = opt.or_else(|| None);\n     let _ = opt.get_or_insert_with(|| 2);\n     let _ = opt.ok_or_else(|| 2);\n-    let _ = opt.ok_or_else(|| ext_arr[0]);\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n \n     // Cases when unwrap is not called on a simple variable\n     let _ = Some(10).unwrap_or_else(|| 2);\n@@ -60,7 +61,6 @@ fn main() {\n     // Should not lint - Option\n     let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n     let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n-    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n     let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n     let _ = opt.or_else(some_call);\n     let _ = opt.or_else(|| some_call());\n@@ -69,10 +69,13 @@ fn main() {\n     let _ = deep.0.get_or_insert_with(|| some_call());\n     let _ = deep.0.or_else(some_call);\n     let _ = deep.0.or_else(|| some_call());\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n \n-    // These are handled by bind_instead_of_map\n+    // should not lint, bind_instead_of_map takes priority\n     let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n     let _ = Some(10).and_then(|idx| Some(idx));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n     let _: Option<usize> = None.or_else(|| Some(3));\n     let _ = deep.0.or_else(|| Some(3));\n     let _ = opt.or_else(|| Some(3));\n@@ -92,17 +95,19 @@ fn main() {\n     let _ = res2.unwrap_or_else(|err| err.return_some_field());\n     let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n \n+    // should not lint, bind_instead_of_map takes priority\n     let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n-    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n-\n-    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n     let _: Result<usize, usize> = res.or_else(|err| Err(err));\n \n-    // These are handled by bind_instead_of_map\n     let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n \n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n     let _: Result<usize, usize> = res.and_then(|_| Err(2));\n     let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n     let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n@@ -111,7 +116,7 @@ fn main() {\n     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n \n-    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n-    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n-    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+    // neither bind_instead_of_map nor unnecessary_lazy_eval applies here\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n }"}, {"sha": "44dcd0cafbb6e7614579eff586b9f87b83a444ed", "filename": "tests/ui/unnecessary_lazy_eval.stderr", "status": "modified", "additions": 80, "deletions": 32, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,148 +1,196 @@\n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:34:13\n+  --> $DIR/unnecessary_lazy_eval.rs:35:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n    |\n    = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:35:13\n+  --> $DIR/unnecessary_lazy_eval.rs:36:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:36:13\n+  --> $DIR/unnecessary_lazy_eval.rs:37:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:37:13\n-   |\n-LL |     let _ = opt.unwrap_or_else(|| ext_arr[0]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_arr[0])`\n-\n-error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:38:13\n+  --> $DIR/unnecessary_lazy_eval.rs:39:13\n    |\n LL |     let _ = opt.and_then(|_| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:39:13\n+  --> $DIR/unnecessary_lazy_eval.rs:40:13\n    |\n LL |     let _ = opt.or_else(|| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:40:13\n+  --> $DIR/unnecessary_lazy_eval.rs:41:13\n    |\n LL |     let _ = opt.or_else(|| None);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:41:13\n+  --> $DIR/unnecessary_lazy_eval.rs:42:13\n    |\n LL |     let _ = opt.get_or_insert_with(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:42:13\n+  --> $DIR/unnecessary_lazy_eval.rs:43:13\n    |\n LL |     let _ = opt.ok_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:43:13\n+  --> $DIR/unnecessary_lazy_eval.rs:44:13\n    |\n-LL |     let _ = opt.ok_or_else(|| ext_arr[0]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(ext_arr[0])`\n+LL |     let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `nested_tuple_opt.unwrap_or(Some((1, 2)))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:46:13\n+  --> $DIR/unnecessary_lazy_eval.rs:47:13\n    |\n LL |     let _ = Some(10).unwrap_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:47:13\n+  --> $DIR/unnecessary_lazy_eval.rs:48:13\n    |\n LL |     let _ = Some(10).and_then(|_| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:48:28\n+  --> $DIR/unnecessary_lazy_eval.rs:49:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:49:13\n+  --> $DIR/unnecessary_lazy_eval.rs:50:13\n    |\n LL |     let _ = None.get_or_insert_with(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:50:35\n+  --> $DIR/unnecessary_lazy_eval.rs:51:35\n    |\n LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n    |                                   ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:51:28\n+  --> $DIR/unnecessary_lazy_eval.rs:52:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| None);\n    |                            ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:54:13\n+  --> $DIR/unnecessary_lazy_eval.rs:55:13\n    |\n LL |     let _ = deep.0.unwrap_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:55:13\n+  --> $DIR/unnecessary_lazy_eval.rs:56:13\n    |\n LL |     let _ = deep.0.and_then(|_| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:56:13\n+  --> $DIR/unnecessary_lazy_eval.rs:57:13\n    |\n LL |     let _ = deep.0.or_else(|| None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:57:13\n+  --> $DIR/unnecessary_lazy_eval.rs:58:13\n    |\n LL |     let _ = deep.0.get_or_insert_with(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:58:13\n+  --> $DIR/unnecessary_lazy_eval.rs:59:13\n    |\n LL |     let _ = deep.0.ok_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n \n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:79:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| Some(3));\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(Some(3))`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:80:13\n+   |\n+LL |     let _ = deep.0.or_else(|| Some(3));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(Some(3))`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:81:13\n+   |\n+LL |     let _ = opt.or_else(|| Some(3));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(Some(3))`\n+\n error: unnecessary closure used to substitute value for `Result::Err`\n-  --> $DIR/unnecessary_lazy_eval.rs:84:13\n+  --> $DIR/unnecessary_lazy_eval.rs:87:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n-  --> $DIR/unnecessary_lazy_eval.rs:85:13\n+  --> $DIR/unnecessary_lazy_eval.rs:88:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n-  --> $DIR/unnecessary_lazy_eval.rs:86:13\n+  --> $DIR/unnecessary_lazy_eval.rs:89:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n \n-error: aborting due to 24 previous errors\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:111:35\n+   |\n+LL |     let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(2))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:112:35\n+   |\n+LL |     let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(astronomers_pi))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:113:35\n+   |\n+LL |     let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(ext_str.some_field))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:115:35\n+   |\n+LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(2))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:116:35\n+   |\n+LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(astronomers_pi))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:117:35\n+   |\n+LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(ext_str.some_field))`\n+\n+error: aborting due to 32 previous errors\n "}, {"sha": "11c6efb25cceace746742c0bf5677c2c21b5043d", "filename": "tests/ui/useless_conversion.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fuseless_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fuseless_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-error: useless conversion to the same type\n+error: useless conversion to the same type: `T`\n   --> $DIR/useless_conversion.rs:6:13\n    |\n LL |     let _ = T::from(val);\n@@ -10,61 +10,61 @@ note: the lint level is defined here\n LL | #![deny(clippy::useless_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `T`\n   --> $DIR/useless_conversion.rs:7:5\n    |\n LL |     val.into()\n    |     ^^^^^^^^^^ help: consider removing `.into()`: `val`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `i32`\n   --> $DIR/useless_conversion.rs:19:22\n    |\n LL |         let _: i32 = 0i32.into();\n    |                      ^^^^^^^^^^^ help: consider removing `.into()`: `0i32`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion.rs:60:21\n    |\n LL |     let _: String = \"foo\".to_string().into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `\"foo\".to_string()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion.rs:61:21\n    |\n LL |     let _: String = From::from(\"foo\".to_string());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `From::from()`: `\"foo\".to_string()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion.rs:62:13\n    |\n LL |     let _ = String::from(\"foo\".to_string());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `\"foo\".to_string()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion.rs:63:13\n    |\n LL |     let _ = String::from(format!(\"A: {:04}\", 123));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `format!(\"A: {:04}\", 123)`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::str::Lines`\n   --> $DIR/useless_conversion.rs:64:13\n    |\n LL |     let _ = \"\".lines().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `\"\".lines()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::vec::IntoIter<i32>`\n   --> $DIR/useless_conversion.rs:65:13\n    |\n LL |     let _ = vec![1, 2, 3].into_iter().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `vec![1, 2, 3].into_iter()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion.rs:66:21\n    |\n LL |     let _: String = format!(\"Hello {}\", \"world\").into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `format!(\"Hello {}\", \"world\")`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `i32`\n   --> $DIR/useless_conversion.rs:71:13\n    |\n LL |     let _ = i32::from(a + b) * 3;"}, {"sha": "2e0d9129bfb3064735077e7ff5a6c23ede5390c6", "filename": "tests/ui/useless_conversion_try.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fuseless_conversion_try.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fuseless_conversion_try.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion_try.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,4 +1,4 @@\n-error: useless conversion to the same type\n+error: useless conversion to the same type: `T`\n   --> $DIR/useless_conversion_try.rs:6:13\n    |\n LL |     let _ = T::try_from(val).unwrap();\n@@ -11,63 +11,63 @@ LL | #![deny(clippy::useless_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider removing `T::try_from()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `T`\n   --> $DIR/useless_conversion_try.rs:7:5\n    |\n LL |     val.try_into().unwrap()\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider removing `.try_into()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:29:21\n    |\n LL |     let _: String = \"foo\".to_string().try_into().unwrap();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `.try_into()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:30:21\n    |\n LL |     let _: String = TryFrom::try_from(\"foo\".to_string()).unwrap();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `TryFrom::try_from()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:31:13\n    |\n LL |     let _ = String::try_from(\"foo\".to_string()).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `String::try_from()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:32:13\n    |\n LL |     let _ = String::try_from(format!(\"A: {:04}\", 123)).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `String::try_from()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:33:21\n    |\n LL |     let _: String = format!(\"Hello {}\", \"world\").try_into().unwrap();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `.try_into()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:34:21\n    |\n LL |     let _: String = \"\".to_owned().try_into().unwrap();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `.try_into()`\n \n-error: useless conversion to the same type\n+error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:35:27\n    |\n LL |     let _: String = match String::from(\"_\").try_into() {"}, {"sha": "1c1b1b58402e830393a9f2e57a43918d414f6f85", "filename": "tests/ui/write_with_newline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.rs?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -14,6 +14,7 @@ fn main() {\n     write!(&mut v, \"Hello {}\\n\", \"world\");\n     write!(&mut v, \"Hello {} {}\\n\", \"world\", \"#2\");\n     write!(&mut v, \"{}\\n\", 1265);\n+    write!(&mut v, \"\\n\");\n \n     // These should be fine\n     write!(&mut v, \"\");"}, {"sha": "a14e86122ee5d0b54c64d4d0aa48b7a0e0389da6", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -44,7 +44,18 @@ LL |     writeln!(&mut v, \"{}\", 1265);\n    |     ^^^^^^^            --\n \n error: using `write!()` with a format string that ends in a single newline\n-  --> $DIR/write_with_newline.rs:35:5\n+  --> $DIR/write_with_newline.rs:17:5\n+   |\n+LL |     write!(&mut v, \"/n\");\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(&mut v, );\n+   |     ^^^^^^^         --\n+\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:36:5\n    |\n LL |     write!(&mut v, \"//n\"); // should fail\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -55,7 +66,7 @@ LL |     writeln!(&mut v, \"/\"); // should fail\n    |     ^^^^^^^            --\n \n error: using `write!()` with a format string that ends in a single newline\n-  --> $DIR/write_with_newline.rs:42:5\n+  --> $DIR/write_with_newline.rs:43:5\n    |\n LL | /     write!(\n LL | |         &mut v,\n@@ -72,7 +83,7 @@ LL |         \"\"\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n-  --> $DIR/write_with_newline.rs:47:5\n+  --> $DIR/write_with_newline.rs:48:5\n    |\n LL | /     write!(\n LL | |         &mut v,\n@@ -89,7 +100,7 @@ LL |         r\"\"\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n-  --> $DIR/write_with_newline.rs:56:5\n+  --> $DIR/write_with_newline.rs:57:5\n    |\n LL |     write!(&mut v, \"/r/n\"); //~ ERROR\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +111,7 @@ LL |     writeln!(&mut v, \"/r\"); //~ ERROR\n    |     ^^^^^^^             --\n \n error: using `write!()` with a format string that ends in a single newline\n-  --> $DIR/write_with_newline.rs:57:5\n+  --> $DIR/write_with_newline.rs:58:5\n    |\n LL |     write!(&mut v, \"foo/rbar/n\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -110,5 +121,5 @@ help: use `writeln!()` instead\n LL |     writeln!(&mut v, \"foo/rbar\");\n    |     ^^^^^^^                  --\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "ed3c83af616d7da8e8de1ca6dd103477a9da656b", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e072475781460d466a67617d6a622fddb678e21/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6e072475781460d466a67617d6a622fddb678e21/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=6e072475781460d466a67617d6a622fddb678e21", "patch": "@@ -1,6 +1,6 @@\n [relabel]\n allow-unauthenticated = [\n-    \"C-*\", \"A-*\", \"E-*\", \"L-*\", \"M-*\", \"O-*\",\n+    \"C-*\", \"A-*\", \"E-*\", \"L-*\", \"M-*\", \"O-*\", \"S-*\",\n     \"good first issue\", \"needs test\"\n ]\n "}, {"sha": "319de217e0d90170c1bcf7545aef25e1caff11d5", "filename": "util/dev", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/141b9c28901fd80da028a984eca2af4e7218a09a/util%2Fdev", "raw_url": "https://github.com/rust-lang/rust/raw/141b9c28901fd80da028a984eca2af4e7218a09a/util%2Fdev", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fdev?ref=141b9c28901fd80da028a984eca2af4e7218a09a", "patch": "@@ -1,7 +0,0 @@\n-#!/bin/sh\n-CARGO_TARGET_DIR=$(pwd)/target/\n-export CARGO_TARGET_DIR\n-\n-echo 'Deprecated! `util/dev` usage is deprecated, please use `cargo dev` instead.'\n-\n-cd clippy_dev && cargo run -- \"$@\""}]}