{"sha": "6fccb152b4646877e38dc29dce1b0cd826eb6908", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmY2NiMTUyYjQ2NDY4NzdlMzhkYzI5ZGNlMWIwY2Q4MjZlYjY5MDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-06T21:53:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-06T21:53:05Z"}, "message": "Merge #8746\n\n8746: Don't store call-site text offsets in hygiene info r=matklad a=jonas-schievink\n\nThis threads a lot more database references around in order to avoid storing a bare `TextOffset` in the hygiene info. This `TextOffset` made hygiene info and `ItemTree`s more volatile than they should be, leading to excessive recomputation of `ItemTree`s.\r\n\r\nThe incremental test added in https://github.com/rust-analyzer/rust-analyzer/pull/8721 is now passing with these changes.\r\n\r\ncloses https://github.com/rust-analyzer/rust-analyzer/pull/8721\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "361153338ec7c32866a5477b3e7681d05a4b0b7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/361153338ec7c32866a5477b3e7681d05a4b0b7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fccb152b4646877e38dc29dce1b0cd826eb6908", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJglGVBCRBK7hj4Ov3rIwAAJIsIAHS/XR5zmR5qMxWkf2SxfHpG\nPYm3NS1B6Td1axlG+F5N5YYpoXtKIMvlmdz0Ct5hMW2inyPZ0gQcX1yWpm/cq6Mc\nceCPKAh4akEDMwZ4JGfsWNTj2a4IGaN0Vv/yga1j9QVTYQNQt3QwRQIJmpdVedLG\n2+RRmxM25d1CDh7ozNPkMHaQwHVnZvA8xxxBzuxruGid227W+oC4hdbQ7Lj9Maqq\ns/i50pn7U5F5LwR5iaAKgwGA0WjkUJJeSAlNtfrzJdJX7fMK6bzS/eBX4h8wvXZ1\nOxZLtlWmy4H6N/qcRRXZpijx/Pjvfvq/5frp15wDfVI+VwSZj1ZU+PFcgt/GwZ4=\n=oE03\n-----END PGP SIGNATURE-----\n", "payload": "tree 361153338ec7c32866a5477b3e7681d05a4b0b7c\nparent b37b709459a4ff881a91965ebf0c39e3a449c304\nparent 20ae41c1a12963e938cb3bd4c7c84007412d6fa6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620337985 +0000\ncommitter GitHub <noreply@github.com> 1620337985 +0000\n\nMerge #8746\n\n8746: Don't store call-site text offsets in hygiene info r=matklad a=jonas-schievink\n\nThis threads a lot more database references around in order to avoid storing a bare `TextOffset` in the hygiene info. This `TextOffset` made hygiene info and `ItemTree`s more volatile than they should be, leading to excessive recomputation of `ItemTree`s.\r\n\r\nThe incremental test added in https://github.com/rust-analyzer/rust-analyzer/pull/8721 is now passing with these changes.\r\n\r\ncloses https://github.com/rust-analyzer/rust-analyzer/pull/8721\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fccb152b4646877e38dc29dce1b0cd826eb6908", "html_url": "https://github.com/rust-lang/rust/commit/6fccb152b4646877e38dc29dce1b0cd826eb6908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fccb152b4646877e38dc29dce1b0cd826eb6908/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b37b709459a4ff881a91965ebf0c39e3a449c304", "url": "https://api.github.com/repos/rust-lang/rust/commits/b37b709459a4ff881a91965ebf0c39e3a449c304", "html_url": "https://github.com/rust-lang/rust/commit/b37b709459a4ff881a91965ebf0c39e3a449c304"}, {"sha": "20ae41c1a12963e938cb3bd4c7c84007412d6fa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/20ae41c1a12963e938cb3bd4c7c84007412d6fa6", "html_url": "https://github.com/rust-lang/rust/commit/20ae41c1a12963e938cb3bd4c7c84007412d6fa6"}], "stats": {"total": 261, "additions": 180, "deletions": 81}, "files": [{"sha": "d34251fc010d55e470ff5e11bc7d79576f0c3bf9", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -27,3 +27,5 @@ debug = 0 # Set this to 1 or 2 to get more useful backtraces in debugger.\n # chalk-recursive = { path = \"../chalk/chalk-recursive\" }\n \n # ungrammar = { path = \"../ungrammar\" }\n+\n+# salsa = { path = \"../salsa\" }"}, {"sha": "e8fa3c56eca4f51b4732143b6d25f9a211644226", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -112,7 +112,7 @@ fn resolve_doc_path(\n         AttrDefId::MacroDefId(_) => return None,\n     };\n     let path = ast::Path::parse(link).ok()?;\n-    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n+    let modpath = ModPath::from_src(db.upcast(), path, &Hygiene::new_unhygienic()).unwrap();\n     let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n     if resolved == PerNs::none() {\n         if let Some(trait_id) = resolver.resolve_module_path_in_trait_items(db.upcast(), &modpath) {"}, {"sha": "f876339decbd0b7f08d499da91e6d958255f2c52", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -1666,7 +1666,7 @@ impl Impl {\n             .value\n             .attrs()\n             .filter_map(|it| {\n-                let path = ModPath::from_src(it.path()?, &hygenic)?;\n+                let path = ModPath::from_src(db.upcast(), it.path()?, &hygenic)?;\n                 if path.as_ident()?.to_string() == \"derive\" {\n                     Some(it)\n                 } else {"}, {"sha": "b5c65808e60a9f9ba22597051e95f84eaf089b07", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -283,7 +283,7 @@ impl SourceAnalyzer {\n \n         // This must be a normal source file rather than macro file.\n         let hygiene = Hygiene::new(db.upcast(), self.file_id);\n-        let ctx = body::LowerCtx::with_hygiene(&hygiene);\n+        let ctx = body::LowerCtx::with_hygiene(db.upcast(), &hygiene);\n         let hir_path = Path::from_src(path.clone(), &ctx)?;\n \n         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we"}, {"sha": "a2479016e57ea1466ceb28afbe6e2a341b037427", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -95,13 +95,17 @@ impl ops::Deref for AttrsWithOwner {\n impl RawAttrs {\n     pub(crate) const EMPTY: Self = Self { entries: None };\n \n-    pub(crate) fn new(owner: &dyn ast::AttrsOwner, hygiene: &Hygiene) -> Self {\n+    pub(crate) fn new(\n+        db: &dyn DefDatabase,\n+        owner: &dyn ast::AttrsOwner,\n+        hygiene: &Hygiene,\n+    ) -> Self {\n         let entries = collect_attrs(owner)\n             .enumerate()\n             .flat_map(|(i, attr)| {\n                 let index = AttrId(i as u32);\n                 match attr {\n-                    Either::Left(attr) => Attr::from_src(attr, hygiene, index),\n+                    Either::Left(attr) => Attr::from_src(db, attr, hygiene, index),\n                     Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n                         id: index,\n                         input: Some(AttrInput::Literal(SmolStr::new(doc))),\n@@ -116,7 +120,7 @@ impl RawAttrs {\n \n     fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn ast::AttrsOwner>) -> Self {\n         let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n-        Self::new(owner.value, &hygiene)\n+        Self::new(db, owner.value, &hygiene)\n     }\n \n     pub(crate) fn merge(&self, other: Self) -> Self {\n@@ -170,7 +174,7 @@ impl RawAttrs {\n                     let attr = ast::Attr::parse(&format!(\"#[{}]\", tree)).ok()?;\n                     // FIXME hygiene\n                     let hygiene = Hygiene::new_unhygienic();\n-                    Attr::from_src(attr, &hygiene, index)\n+                    Attr::from_src(db, attr, &hygiene, index)\n                 });\n \n                 let cfg_options = &crate_graph[krate].cfg_options;\n@@ -627,8 +631,13 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    fn from_src(ast: ast::Attr, hygiene: &Hygiene, id: AttrId) -> Option<Attr> {\n-        let path = Interned::new(ModPath::from_src(ast.path()?, hygiene)?);\n+    fn from_src(\n+        db: &dyn DefDatabase,\n+        ast: ast::Attr,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let path = Interned::new(ModPath::from_src(db, ast.path()?, hygiene)?);\n         let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n             let value = match lit.kind() {\n                 ast::LiteralKind::String(string) => string.value()?.into(),"}, {"sha": "8360426f139ef33fb40f2c8ffe83b824271961d5", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -72,7 +72,7 @@ impl CfgExpander {\n     }\n \n     pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::AttrsOwner) -> Attrs {\n-        RawAttrs::new(owner, &self.hygiene).filter(db, self.krate)\n+        RawAttrs::new(db, owner, &self.hygiene).filter(db, self.krate)\n     }\n \n     pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::AttrsOwner) -> bool {\n@@ -192,8 +192,8 @@ impl Expander {\n         self.current_file_id\n     }\n \n-    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        let ctx = LowerCtx::with_hygiene(&self.cfg_expander.hygiene);\n+    fn parse_path(&mut self, db: &dyn DefDatabase, path: ast::Path) -> Option<Path> {\n+        let ctx = LowerCtx::with_hygiene(db, &self.cfg_expander.hygiene);\n         Path::from_src(path, &ctx)\n     }\n "}, {"sha": "75dc19c117aed9bfef72dc260ba8737416ebe899", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -40,23 +40,25 @@ use crate::{\n \n use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n \n-pub struct LowerCtx {\n+pub struct LowerCtx<'a> {\n+    pub db: &'a dyn DefDatabase,\n     hygiene: Hygiene,\n     file_id: Option<HirFileId>,\n     source_ast_id_map: Option<Arc<AstIdMap>>,\n }\n \n-impl LowerCtx {\n-    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n+impl<'a> LowerCtx<'a> {\n+    pub fn new(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n         LowerCtx {\n+            db,\n             hygiene: Hygiene::new(db.upcast(), file_id),\n             file_id: Some(file_id),\n             source_ast_id_map: Some(db.ast_id_map(file_id)),\n         }\n     }\n \n-    pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n-        LowerCtx { hygiene: hygiene.clone(), file_id: None, source_ast_id_map: None }\n+    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), file_id: None, source_ast_id_map: None }\n     }\n \n     pub(crate) fn hygiene(&self) -> &Hygiene {\n@@ -145,7 +147,7 @@ impl ExprCollector<'_> {\n         (self.body, self.source_map)\n     }\n \n-    fn ctx(&self) -> LowerCtx {\n+    fn ctx(&self) -> LowerCtx<'_> {\n         LowerCtx::new(self.db, self.expander.current_file_id)\n     }\n \n@@ -376,7 +378,7 @@ impl ExprCollector<'_> {\n             ast::Expr::PathExpr(e) => {\n                 let path = e\n                     .path()\n-                    .and_then(|path| self.expander.parse_path(path))\n+                    .and_then(|path| self.expander.parse_path(self.db, path))\n                     .map(Expr::Path)\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n@@ -408,7 +410,8 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordExpr(e) => {\n-                let path = e.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n+                let path =\n+                    e.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n                 let record_lit = if let Some(nfl) = e.record_expr_field_list() {\n                     let fields = nfl\n                         .fields()\n@@ -791,7 +794,8 @@ impl ExprCollector<'_> {\n                 }\n             }\n             ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n+                let path =\n+                    p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n                 let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n@@ -801,7 +805,8 @@ impl ExprCollector<'_> {\n                 Pat::Ref { pat, mutability }\n             }\n             ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n+                let path =\n+                    p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n@@ -815,7 +820,8 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n+                let path =\n+                    p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n                 let args: Vec<_> = p\n                     .record_pat_field_list()\n                     .expect(\"every struct should have a field list\")"}, {"sha": "858e880381072566d8e0bf325a3d706935179321", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -386,7 +386,7 @@ mod tests {\n         let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n         let ast_path =\n             parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();\n-        let mod_path = ModPath::from_src(ast_path, &Hygiene::new_unhygienic()).unwrap();\n+        let mod_path = ModPath::from_src(&db, ast_path, &Hygiene::new_unhygienic()).unwrap();\n \n         let def_map = module.def_map(&db);\n         let resolved = def_map"}, {"sha": "8d13c7e047ab6fa65a2cfa21230a2a4072964291", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -88,7 +88,7 @@ impl ItemTree {\n         let mut item_tree = match_ast! {\n             match syntax {\n                 ast::SourceFile(file) => {\n-                    top_attrs = Some(RawAttrs::new(&file, &hygiene));\n+                    top_attrs = Some(RawAttrs::new(db, &file, &hygiene));\n                     ctx.lower_module_items(&file)\n                 },\n                 ast::MacroItems(items) => {"}, {"sha": "5743b3386265e456f477b963528055f76884ecba", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -31,18 +31,20 @@ where\n     }\n }\n \n-pub(super) struct Ctx {\n+pub(super) struct Ctx<'a> {\n+    db: &'a dyn DefDatabase,\n     tree: ItemTree,\n     hygiene: Hygiene,\n     file: HirFileId,\n     source_ast_id_map: Arc<AstIdMap>,\n-    body_ctx: crate::body::LowerCtx,\n+    body_ctx: crate::body::LowerCtx<'a>,\n     forced_visibility: Option<RawVisibilityId>,\n }\n \n-impl Ctx {\n-    pub(super) fn new(db: &dyn DefDatabase, hygiene: Hygiene, file: HirFileId) -> Self {\n+impl<'a> Ctx<'a> {\n+    pub(super) fn new(db: &'a dyn DefDatabase, hygiene: Hygiene, file: HirFileId) -> Self {\n         Self {\n+            db,\n             tree: ItemTree::default(),\n             hygiene,\n             file,\n@@ -126,7 +128,7 @@ impl Ctx {\n             | ast::Item::MacroDef(_) => {}\n         };\n \n-        let attrs = RawAttrs::new(item, &self.hygiene);\n+        let attrs = RawAttrs::new(self.db, item, &self.hygiene);\n         let items = match item {\n             ast::Item::Struct(ast) => self.lower_struct(ast).map(Into::into),\n             ast::Item::Union(ast) => self.lower_union(ast).map(Into::into),\n@@ -256,7 +258,7 @@ impl Ctx {\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n                 let idx = self.data().fields.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(&field, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, &self.hygiene));\n             }\n         }\n         let end = self.next_field_idx();\n@@ -276,7 +278,7 @@ impl Ctx {\n         for (i, field) in fields.fields().enumerate() {\n             let data = self.lower_tuple_field(i, &field);\n             let idx = self.data().fields.alloc(data);\n-            self.add_attrs(idx.into(), RawAttrs::new(&field, &self.hygiene));\n+            self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, &self.hygiene));\n         }\n         let end = self.next_field_idx();\n         IdRange::new(start..end)\n@@ -321,7 +323,7 @@ impl Ctx {\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n                 let idx = self.data().variants.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(&variant, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &variant, &self.hygiene));\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -364,7 +366,7 @@ impl Ctx {\n                 };\n                 let ty = Interned::new(self_type);\n                 let idx = self.data().params.alloc(Param::Normal(ty));\n-                self.add_attrs(idx.into(), RawAttrs::new(&self_param, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &self_param, &self.hygiene));\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n@@ -376,7 +378,7 @@ impl Ctx {\n                         self.data().params.alloc(Param::Normal(ty))\n                     }\n                 };\n-                self.add_attrs(idx.into(), RawAttrs::new(&param, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &param, &self.hygiene));\n             }\n         }\n         let end_param = self.next_param_idx();\n@@ -522,10 +524,11 @@ impl Ctx {\n         let is_unsafe = trait_def.unsafe_token().is_some();\n         let bounds = self.lower_type_bounds(trait_def);\n         let items = trait_def.assoc_item_list().map(|list| {\n+            let db = self.db;\n             self.with_inherited_visibility(visibility, |this| {\n                 list.assoc_items()\n                     .filter_map(|item| {\n-                        let attrs = RawAttrs::new(&item, &this.hygiene);\n+                        let attrs = RawAttrs::new(db, &item, &this.hygiene);\n                         this.collect_inner_items(item.syntax());\n                         this.lower_assoc_item(&item).map(|item| {\n                             this.add_attrs(ModItem::from(item).into(), attrs);\n@@ -567,7 +570,7 @@ impl Ctx {\n             .filter_map(|item| {\n                 self.collect_inner_items(item.syntax());\n                 let assoc = self.lower_assoc_item(&item)?;\n-                let attrs = RawAttrs::new(&item, &self.hygiene);\n+                let attrs = RawAttrs::new(self.db, &item, &self.hygiene);\n                 self.add_attrs(ModItem::from(assoc).into(), attrs);\n                 Some(assoc)\n             })\n@@ -585,6 +588,7 @@ impl Ctx {\n         let mut imports = Vec::new();\n         let tree = self.tree.data_mut();\n         ModPath::expand_use_item(\n+            self.db,\n             InFile::new(self.file, use_item.clone()),\n             &self.hygiene,\n             |path, _use_tree, is_glob, alias| {\n@@ -618,7 +622,7 @@ impl Ctx {\n     }\n \n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n-        let path = Interned::new(ModPath::from_src(m.path()?, &self.hygiene)?);\n+        let path = Interned::new(ModPath::from_src(self.db, m.path()?, &self.hygiene)?);\n         let ast_id = self.source_ast_id_map.ast_id(m);\n         let res = MacroCall { path, ast_id };\n         Some(id(self.data().macro_calls.alloc(res)))\n@@ -647,7 +651,7 @@ impl Ctx {\n             list.extern_items()\n                 .filter_map(|item| {\n                     self.collect_inner_items(item.syntax());\n-                    let attrs = RawAttrs::new(&item, &self.hygiene);\n+                    let attrs = RawAttrs::new(self.db, &item, &self.hygiene);\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => {\n                             let func_id = self.lower_function(&ast)?;\n@@ -755,7 +759,7 @@ impl Ctx {\n     fn lower_visibility(&mut self, item: &impl ast::VisibilityOwner) -> RawVisibilityId {\n         let vis = match self.forced_visibility {\n             Some(vis) => return vis,\n-            None => RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene),\n+            None => RawVisibility::from_ast_with_hygiene(self.db, item.visibility(), &self.hygiene),\n         };\n \n         self.data().vis.alloc(vis)"}, {"sha": "da46f16f7a1952a34dd0ad4f2d6a4727c9f1b7df", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -654,7 +654,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n     ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n-        let path = self.value.path().and_then(|path| path::ModPath::from_src(path, &h));\n+        let path = self.value.path().and_then(|path| path::ModPath::from_src(db, path, &h));\n \n         let path = match error_sink\n             .option(path, || mbe::ExpandError::Other(\"malformed macro invocation\".into()))\n@@ -712,7 +712,7 @@ fn macro_call_as_call_id(\n             krate,\n             macro_call,\n             def,\n-            &|path: ast::Path| resolver(path::ModPath::from_src(path, &hygiene)?),\n+            &|path: ast::Path| resolver(path::ModPath::from_src(db, path, &hygiene)?),\n             error_sink,\n         )\n         .map(MacroCallId::from)"}, {"sha": "1bc72ec1f05d61d201818fefea598b568e30ecd0", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -599,6 +599,7 @@ mod diagnostics {\n                     let mut cur = 0;\n                     let mut tree = None;\n                     ModPath::expand_use_item(\n+                        db,\n                         InFile::new(ast.file_id, use_item),\n                         &hygiene,\n                         |_mod_path, use_tree, _is_glob, _alias| {"}, {"sha": "227ecd162f6ca6f01a4cc16496318ef068541b60", "filename": "crates/hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -105,3 +105,55 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n }\n+\n+#[test]\n+fn typing_inside_a_function_should_not_invalidate_expansions() {\n+    let (mut db, pos) = TestDB::with_position(\n+        r#\"\n+//- /lib.rs\n+macro_rules! m {\n+    ($ident:ident) => {\n+        fn $ident() { };\n+    }\n+}\n+mod foo;\n+\n+//- /foo/mod.rs\n+pub mod bar;\n+\n+//- /foo/bar.rs\n+m!(X);\n+fn quux() { 1$0 }\n+m!(Y);\n+m!(Z);\n+\"#,\n+    );\n+    let krate = db.test_crate();\n+    {\n+        let events = db.log_executed(|| {\n+            let crate_def_map = db.crate_def_map(krate);\n+            let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n+            assert_eq!(module_data.scope.resolutions().count(), 4);\n+        });\n+        let n_recalculated_item_trees = events.iter().filter(|it| it.contains(\"item_tree\")).count();\n+        assert_eq!(n_recalculated_item_trees, 6);\n+    }\n+\n+    let new_text = r#\"\n+m!(X);\n+fn quux() { 92 }\n+m!(Y);\n+m!(Z);\n+\"#;\n+    db.set_file_text(pos.file_id, Arc::new(new_text.to_string()));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            let crate_def_map = db.crate_def_map(krate);\n+            let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n+            assert_eq!(module_data.scope.resolutions().count(), 4);\n+        });\n+        let n_recalculated_item_trees = events.iter().filter(|it| it.contains(\"item_tree\")).count();\n+        assert_eq!(n_recalculated_item_trees, 1);\n+    }\n+}"}, {"sha": "a43441b1c2ca4ca363be0c506fc12b77189c398c", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -7,7 +7,7 @@ use std::{\n     sync::Arc,\n };\n \n-use crate::{body::LowerCtx, intern::Interned, type_ref::LifetimeRef};\n+use crate::{body::LowerCtx, db::DefDatabase, intern::Interned, type_ref::LifetimeRef};\n use base_db::CrateId;\n use hir_expand::{\n     hygiene::Hygiene,\n@@ -47,8 +47,8 @@ pub enum ImportAlias {\n }\n \n impl ModPath {\n-    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n-        let ctx = LowerCtx::with_hygiene(hygiene);\n+    pub fn from_src(db: &dyn DefDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+        let ctx = LowerCtx::with_hygiene(db, hygiene);\n         lower::lower_path(path, &ctx).map(|it| (*it.mod_path).clone())\n     }\n \n@@ -64,12 +64,13 @@ impl ModPath {\n \n     /// Calls `cb` with all paths, represented by this use item.\n     pub(crate) fn expand_use_item(\n+        db: &dyn DefDatabase,\n         item_src: InFile<ast::Use>,\n         hygiene: &Hygiene,\n         mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<ImportAlias>),\n     ) {\n         if let Some(tree) = item_src.value.use_tree() {\n-            lower::lower_use_tree(None, tree, hygiene, &mut cb);\n+            lower::lower_use_tree(db, None, tree, hygiene, &mut cb);\n         }\n     }\n "}, {"sha": "a873325b24ba8d8266b7dd251a6bfef78eafc019", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -36,7 +36,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n         match segment.kind()? {\n             ast::PathSegmentKind::Name(name_ref) => {\n                 // FIXME: this should just return name\n-                match hygiene.name_ref_to_name(name_ref) {\n+                match hygiene.name_ref_to_name(ctx.db.upcast(), name_ref) {\n                     Either::Left(name) => {\n                         let args = segment\n                             .generic_arg_list()\n@@ -133,7 +133,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n     // We follow what it did anyway :)\n     if segments.len() == 1 && kind == PathKind::Plain {\n         if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n-            if let Some(crate_id) = hygiene.local_inner_macros(path) {\n+            if let Some(crate_id) = hygiene.local_inner_macros(ctx.db.upcast(), path) {\n                 kind = PathKind::DollarCrate(crate_id);\n             }\n         }"}, {"sha": "ee80e3df3ca65c2d0bb4f74863e0cf792d7865eb", "filename": "crates/hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -7,9 +7,13 @@ use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName};\n use syntax::ast::{self, NameOwner};\n \n-use crate::path::{ImportAlias, ModPath, PathKind};\n+use crate::{\n+    db::DefDatabase,\n+    path::{ImportAlias, ModPath, PathKind},\n+};\n \n pub(crate) fn lower_use_tree(\n+    db: &dyn DefDatabase,\n     prefix: Option<ModPath>,\n     tree: ast::UseTree,\n     hygiene: &Hygiene,\n@@ -21,13 +25,13 @@ pub(crate) fn lower_use_tree(\n             None => prefix,\n             // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n             // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path, hygiene) {\n+            Some(path) => match convert_path(db, prefix, path, hygiene) {\n                 Some(it) => Some(it),\n                 None => return, // FIXME: report errors somewhere\n             },\n         };\n         for child_tree in use_tree_list.use_trees() {\n-            lower_use_tree(prefix.clone(), child_tree, hygiene, cb);\n+            lower_use_tree(db, prefix.clone(), child_tree, hygiene, cb);\n         }\n     } else {\n         let alias = tree.rename().map(|a| {\n@@ -47,7 +51,7 @@ pub(crate) fn lower_use_tree(\n                     }\n                 }\n             }\n-            if let Some(path) = convert_path(prefix, ast_path, hygiene) {\n+            if let Some(path) = convert_path(db, prefix, ast_path, hygiene) {\n                 cb(path, &tree, is_glob, alias)\n             }\n         // FIXME: report errors somewhere\n@@ -61,17 +65,22 @@ pub(crate) fn lower_use_tree(\n     }\n }\n \n-fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+fn convert_path(\n+    db: &dyn DefDatabase,\n+    prefix: Option<ModPath>,\n+    path: ast::Path,\n+    hygiene: &Hygiene,\n+) -> Option<ModPath> {\n     let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual, hygiene)?)\n+        Some(convert_path(db, prefix, qual, hygiene)?)\n     } else {\n         prefix\n     };\n \n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n         ast::PathSegmentKind::Name(name_ref) => {\n-            match hygiene.name_ref_to_name(name_ref) {\n+            match hygiene.name_ref_to_name(db.upcast(), name_ref) {\n                 Either::Left(name) => {\n                     // no type args in use\n                     let mut res = prefix.unwrap_or_else(|| {"}, {"sha": "83500f54ee3b99e6363bbc385eae1249e3c33b9c", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -33,17 +33,19 @@ impl RawVisibility {\n         db: &dyn DefDatabase,\n         node: InFile<Option<ast::Visibility>>,\n     ) -> RawVisibility {\n-        Self::from_ast_with_hygiene(node.value, &Hygiene::new(db.upcast(), node.file_id))\n+        Self::from_ast_with_hygiene(db, node.value, &Hygiene::new(db.upcast(), node.file_id))\n     }\n \n     pub(crate) fn from_ast_with_hygiene(\n+        db: &dyn DefDatabase,\n         node: Option<ast::Visibility>,\n         hygiene: &Hygiene,\n     ) -> RawVisibility {\n-        Self::from_ast_with_hygiene_and_default(node, RawVisibility::private(), hygiene)\n+        Self::from_ast_with_hygiene_and_default(db, node, RawVisibility::private(), hygiene)\n     }\n \n     pub(crate) fn from_ast_with_hygiene_and_default(\n+        db: &dyn DefDatabase,\n         node: Option<ast::Visibility>,\n         default: RawVisibility,\n         hygiene: &Hygiene,\n@@ -54,7 +56,7 @@ impl RawVisibility {\n         };\n         match node.kind() {\n             ast::VisibilityKind::In(path) => {\n-                let path = ModPath::from_src(path, hygiene);\n+                let path = ModPath::from_src(db, path, hygiene);\n                 let path = match path {\n                     None => return RawVisibility::private(),\n                     Some(path) => path,"}, {"sha": "aca69e35abfc9560f1ddc83a0fd9e09587d99dff", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -32,10 +32,14 @@ impl Hygiene {\n     }\n \n     // FIXME: this should just return name\n-    pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n+    pub fn name_ref_to_name(\n+        &self,\n+        db: &dyn AstDatabase,\n+        name_ref: ast::NameRef,\n+    ) -> Either<Name, CrateId> {\n         if let Some(frames) = &self.frames {\n             if name_ref.text() == \"$crate\" {\n-                if let Some(krate) = frames.root_crate(name_ref.syntax()) {\n+                if let Some(krate) = frames.root_crate(db, name_ref.syntax()) {\n                     return Either::Right(krate);\n                 }\n             }\n@@ -44,15 +48,19 @@ impl Hygiene {\n         Either::Left(name_ref.as_name())\n     }\n \n-    pub fn local_inner_macros(&self, path: ast::Path) -> Option<CrateId> {\n+    pub fn local_inner_macros(&self, db: &dyn AstDatabase, path: ast::Path) -> Option<CrateId> {\n         let mut token = path.syntax().first_token()?.text_range();\n         let frames = self.frames.as_ref()?;\n         let mut current = frames.0.clone();\n \n         loop {\n-            let (mapped, origin) = current.expansion.as_ref()?.map_ident_up(token)?;\n+            let (mapped, origin) = current.expansion.as_ref()?.map_ident_up(db, token)?;\n             if origin == Origin::Def {\n-                return if current.local_inner { frames.root_crate(path.syntax()) } else { None };\n+                return if current.local_inner {\n+                    frames.root_crate(db, path.syntax())\n+                } else {\n+                    None\n+                };\n             }\n             current = current.call_site.as_ref()?.clone();\n             token = mapped.value;\n@@ -82,13 +90,13 @@ impl HygieneFrames {\n         HygieneFrames(Arc::new(HygieneFrame::new(db, file_id)))\n     }\n \n-    fn root_crate(&self, node: &SyntaxNode) -> Option<CrateId> {\n+    fn root_crate(&self, db: &dyn AstDatabase, node: &SyntaxNode) -> Option<CrateId> {\n         let mut token = node.first_token()?.text_range();\n         let mut result = self.0.krate;\n         let mut current = self.0.clone();\n \n         while let Some((mapped, origin)) =\n-            current.expansion.as_ref().and_then(|it| it.map_ident_up(token))\n+            current.expansion.as_ref().and_then(|it| it.map_ident_up(db, token))\n         {\n             result = current.krate;\n \n@@ -112,7 +120,7 @@ impl HygieneFrames {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n struct HygieneInfo {\n-    arg_start: InFile<TextSize>,\n+    file: MacroFile,\n     /// The `macro_rules!` arguments.\n     def_start: Option<InFile<TextSize>>,\n \n@@ -122,12 +130,24 @@ struct HygieneInfo {\n }\n \n impl HygieneInfo {\n-    fn map_ident_up(&self, token: TextRange) -> Option<(InFile<TextRange>, Origin)> {\n+    fn map_ident_up(\n+        &self,\n+        db: &dyn AstDatabase,\n+        token: TextRange,\n+    ) -> Option<(InFile<TextRange>, Origin)> {\n         let token_id = self.exp_map.token_by_range(token)?;\n \n         let (token_id, origin) = self.macro_def.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n-            mbe::Origin::Call => (&self.macro_arg.1, self.arg_start),\n+            mbe::Origin::Call => {\n+                let call_id = match self.file.macro_call_id {\n+                    MacroCallId::LazyMacro(lazy) => lazy,\n+                    MacroCallId::EagerMacro(_) => unreachable!(),\n+                };\n+                let loc: MacroCallLoc = db.lookup_intern_macro(call_id);\n+                let arg_start = loc.kind.arg(db)?.text_range().start();\n+                (&self.macro_arg.1, InFile::new(loc.kind.file_id(), arg_start))\n+            }\n             mbe::Origin::Def => match (&*self.macro_def, self.def_start) {\n                 (TokenExpander::MacroDef { def_site_token_map, .. }, Some(tt))\n                 | (TokenExpander::MacroRules { def_site_token_map, .. }, Some(tt)) => {\n@@ -147,8 +167,6 @@ fn make_hygiene_info(\n     macro_file: MacroFile,\n     loc: &MacroCallLoc,\n ) -> Option<HygieneInfo> {\n-    let arg_tt = loc.kind.arg(db)?;\n-\n     let def_offset = loc.def.ast_id().left().and_then(|id| {\n         let def_tt = match id.to_node(db) {\n             ast::Macro::MacroRules(mac) => mac.token_tree()?.syntax().text_range().start(),\n@@ -161,13 +179,7 @@ fn make_hygiene_info(\n     let (_, exp_map) = db.parse_macro_expansion(macro_file).value?;\n     let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n \n-    Some(HygieneInfo {\n-        arg_start: InFile::new(loc.kind.file_id(), arg_tt.text_range().start()),\n-        def_start: def_offset,\n-        macro_arg,\n-        macro_def,\n-        exp_map,\n-    })\n+    Some(HygieneInfo { file: macro_file, def_start: def_offset, macro_arg, macro_def, exp_map })\n }\n \n impl HygieneFrame {\n@@ -178,7 +190,8 @@ impl HygieneFrame {\n                 MacroCallId::EagerMacro(_id) => (None, None, false),\n                 MacroCallId::LazyMacro(id) => {\n                     let loc = db.lookup_intern_macro(id);\n-                    let info = make_hygiene_info(db, macro_file, &loc);\n+                    let info = make_hygiene_info(db, macro_file, &loc)\n+                        .map(|info| (loc.kind.file_id(), info));\n                     match loc.def.kind {\n                         MacroDefKind::Declarative(_) => {\n                             (info, Some(loc.def.krate), loc.def.local_inner)\n@@ -192,7 +205,7 @@ impl HygieneFrame {\n             },\n         };\n \n-        let info = match info {\n+        let (calling_file, info) = match info {\n             None => {\n                 return HygieneFrame {\n                     expansion: None,\n@@ -206,7 +219,7 @@ impl HygieneFrame {\n         };\n \n         let def_site = info.def_start.map(|it| db.hygiene_frame(it.file_id));\n-        let call_site = Some(db.hygiene_frame(info.arg_start.file_id));\n+        let call_site = Some(db.hygiene_frame(calling_file));\n \n         HygieneFrame { expansion: Some(info), local_inner, krate, call_site, def_site }\n     }"}, {"sha": "1f6edf7a28b81c1a0f45941814eb89bad5f19381", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fccb152b4646877e38dc29dce1b0cd826eb6908/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=6fccb152b4646877e38dc29dce1b0cd826eb6908", "patch": "@@ -1000,7 +1000,7 @@ impl HirDisplay for TypeRef {\n             }\n             TypeRef::Macro(macro_call) => {\n                 let macro_call = macro_call.to_node(f.db.upcast());\n-                let ctx = body::LowerCtx::with_hygiene(&Hygiene::new_unhygienic());\n+                let ctx = body::LowerCtx::with_hygiene(f.db.upcast(), &Hygiene::new_unhygienic());\n                 match macro_call.path() {\n                     Some(path) => match Path::from_src(path, &ctx) {\n                         Some(path) => path.hir_fmt(f)?,"}]}