{"sha": "9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "node_id": "C_kwDOAAsO6NoAKDllYzM2ZjU2Njg0Y2JkMGZhOTBhYjJkYTNjNTA4NDgxMWY3YTM5ODk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-12T06:25:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-12T06:25:50Z"}, "message": "Rollup merge of #106739 - WaffleLapkin:astconv, r=estebank\n\nRemove `<dyn AstConv<'tcx>>::fun(c, ...)` calls in favour of `c.astconv().fun(...)`\n\nThis removes the need for <>><><><<>> dances and makes the code a bit nicer.\n\nNot sure if `astconv` is the best name though, maybe someone has a better idea?", "tree": {"sha": "d4840b8d2ff11a21bc8772c2b505c3ac2b24f23d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4840b8d2ff11a21bc8772c2b505c3ac2b24f23d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjv6fuCRBK7hj4Ov3rIwAA+TMIABZxO7ajgCmhztxrbv1PJvPC\nWzYNEZWVNRIqzWaAn/0kaYuVSioYHkusAkllzTR/0nlsPYYEY6g1brg4mpR9+2c2\n6U3hhC/ethi2uAGApNjcsRPf4tpga45x4A5+Jp8Wg/QD1KAVKDynJMA7l0fKV7gm\nTVR5z2LC/2B5hywqX+qSppLJ8Cynl2kmuF7Kh2Ttd7yH1hQsejwEDzNYQNLEn5Gu\nGFTc/13+cNViKqpq2ZgoOzr+bW8lzrXLdxeik5HOcUW7CsUn0ws8J5AdmxtyXOWG\njAD+h9BUoK9Nrrzse7mKIsvXYBzMnQnto4dlLC0mrG1D0BJdUc4TlGC6C13J/kY=\n=d/5X\n-----END PGP SIGNATURE-----\n", "payload": "tree d4840b8d2ff11a21bc8772c2b505c3ac2b24f23d\nparent d7113948d31010758ed8d88e2d9290dafbb2d40d\nparent d642781708801d1227bb76deca803fda43ff8b37\nauthor Michael Goulet <michael@errs.io> 1673504750 -0800\ncommitter GitHub <noreply@github.com> 1673504750 -0800\n\nRollup merge of #106739 - WaffleLapkin:astconv, r=estebank\n\nRemove `<dyn AstConv<'tcx>>::fun(c, ...)` calls in favour of `c.astconv().fun(...)`\n\nThis removes the need for <>><><><<>> dances and makes the code a bit nicer.\n\nNot sure if `astconv` is the best name though, maybe someone has a better idea?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "html_url": "https://github.com/rust-lang/rust/commit/9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7113948d31010758ed8d88e2d9290dafbb2d40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7113948d31010758ed8d88e2d9290dafbb2d40d", "html_url": "https://github.com/rust-lang/rust/commit/d7113948d31010758ed8d88e2d9290dafbb2d40d"}, {"sha": "d642781708801d1227bb76deca803fda43ff8b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/d642781708801d1227bb76deca803fda43ff8b37", "html_url": "https://github.com/rust-lang/rust/commit/d642781708801d1227bb76deca803fda43ff8b37"}], "stats": {"total": 1292, "additions": 628, "deletions": 664}, "files": [{"sha": "ce3682a8f2d5cda48084a4566eb84e76ccb4e9c4", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 558, "deletions": 576, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -1,6 +1,6 @@\n use super::IsMethodCall;\n use crate::astconv::{\n-    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, GenericArgPosition,\n };\n use crate::errors::AssocTypeBindingNotAllowed;\n@@ -18,642 +18,624 @@ use rustc_session::lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS;\n use rustc_span::{symbol::kw, Span};\n use smallvec::SmallVec;\n \n-impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n-    /// Report an error that a generic argument did not match the generic parameter that was\n-    /// expected.\n-    fn generic_arg_mismatch_err(\n-        tcx: TyCtxt<'_>,\n-        arg: &GenericArg<'_>,\n-        param: &GenericParamDef,\n-        possible_ordering_error: bool,\n-        help: Option<&str>,\n-    ) {\n-        let sess = tcx.sess;\n-        let mut err = struct_span_err!(\n-            sess,\n-            arg.span(),\n-            E0747,\n-            \"{} provided when a {} was expected\",\n-            arg.descr(),\n-            param.kind.descr(),\n-        );\n-\n-        if let GenericParamDefKind::Const { .. } = param.kind {\n-            if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n-                err.help(\"const arguments cannot yet be inferred with `_`\");\n-                if sess.is_nightly_build() {\n-                    err.help(\n-                        \"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\",\n-                    );\n-                }\n+/// Report an error that a generic argument did not match the generic parameter that was\n+/// expected.\n+fn generic_arg_mismatch_err(\n+    tcx: TyCtxt<'_>,\n+    arg: &GenericArg<'_>,\n+    param: &GenericParamDef,\n+    possible_ordering_error: bool,\n+    help: Option<&str>,\n+) {\n+    let sess = tcx.sess;\n+    let mut err = struct_span_err!(\n+        sess,\n+        arg.span(),\n+        E0747,\n+        \"{} provided when a {} was expected\",\n+        arg.descr(),\n+        param.kind.descr(),\n+    );\n+\n+    if let GenericParamDefKind::Const { .. } = param.kind {\n+        if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n+            err.help(\"const arguments cannot yet be inferred with `_`\");\n+            if sess.is_nightly_build() {\n+                err.help(\"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\");\n             }\n         }\n+    }\n \n-        let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n-            let suggestions = vec![\n-                (arg.span().shrink_to_lo(), String::from(\"{ \")),\n-                (arg.span().shrink_to_hi(), String::from(\" }\")),\n-            ];\n-            err.multipart_suggestion(\n-                \"if this generic argument was intended as a const parameter, \\\n+    let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n+        let suggestions = vec![\n+            (arg.span().shrink_to_lo(), String::from(\"{ \")),\n+            (arg.span().shrink_to_hi(), String::from(\" }\")),\n+        ];\n+        err.multipart_suggestion(\n+            \"if this generic argument was intended as a const parameter, \\\n                  surround it with braces\",\n-                suggestions,\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-\n-        // Specific suggestion set for diagnostics\n-        match (arg, &param.kind) {\n-            (\n-                GenericArg::Type(hir::Ty {\n-                    kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n-                    ..\n-                }),\n-                GenericParamDefKind::Const { .. },\n-            ) => match path.res {\n-                Res::Err => {\n-                    add_braces_suggestion(arg, &mut err);\n-                    err.set_primary_message(\n-                        \"unresolved item provided when a constant was expected\",\n-                    )\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+\n+    // Specific suggestion set for diagnostics\n+    match (arg, &param.kind) {\n+        (\n+            GenericArg::Type(hir::Ty {\n+                kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n+                ..\n+            }),\n+            GenericParamDefKind::Const { .. },\n+        ) => match path.res {\n+            Res::Err => {\n+                add_braces_suggestion(arg, &mut err);\n+                err.set_primary_message(\"unresolved item provided when a constant was expected\")\n                     .emit();\n-                    return;\n-                }\n-                Res::Def(DefKind::TyParam, src_def_id) => {\n-                    if let Some(param_local_id) = param.def_id.as_local() {\n-                        let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.type_of(param.def_id);\n-                        if param_type.is_suggestable(tcx, false) {\n-                            err.span_suggestion(\n-                                tcx.def_span(src_def_id),\n-                                \"consider changing this type parameter to be a `const` generic\",\n-                                format!(\"const {}: {}\", param_name, param_type),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        };\n-                    }\n-                }\n-                _ => add_braces_suggestion(arg, &mut err),\n-            },\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) => add_braces_suggestion(arg, &mut err),\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n-                let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n-                if let Ok(snippet) = snippet {\n-                    err.span_suggestion(\n-                        arg.span(),\n-                        \"array type provided where a `usize` was expected, try\",\n-                        format!(\"{{ {} }}\", snippet),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                return;\n+            }\n+            Res::Def(DefKind::TyParam, src_def_id) => {\n+                if let Some(param_local_id) = param.def_id.as_local() {\n+                    let param_name = tcx.hir().ty_param_name(param_local_id);\n+                    let param_type = tcx.type_of(param.def_id);\n+                    if param_type.is_suggestable(tcx, false) {\n+                        err.span_suggestion(\n+                            tcx.def_span(src_def_id),\n+                            \"consider changing this type parameter to be a `const` generic\",\n+                            format!(\"const {}: {}\", param_name, param_type),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    };\n                 }\n             }\n-            (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n-                let body = tcx.hir().body(cnst.value.body);\n-                if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) =\n-                    body.value.kind\n-                {\n-                    if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n-                        err.help(&format!(\n-                            \"`{}` is a function item, not a type\",\n-                            tcx.item_name(id)\n-                        ));\n-                        err.help(\"function item types cannot be named directly\");\n-                    }\n+            _ => add_braces_suggestion(arg, &mut err),\n+        },\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) => add_braces_suggestion(arg, &mut err),\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n+            let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n+            if let Ok(snippet) = snippet {\n+                err.span_suggestion(\n+                    arg.span(),\n+                    \"array type provided where a `usize` was expected, try\",\n+                    format!(\"{{ {} }}\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n+            let body = tcx.hir().body(cnst.value.body);\n+            if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) = body.value.kind\n+            {\n+                if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n+                    err.help(&format!(\"`{}` is a function item, not a type\", tcx.item_name(id)));\n+                    err.help(\"function item types cannot be named directly\");\n                 }\n             }\n-            _ => {}\n         }\n+        _ => {}\n+    }\n \n-        let kind_ord = param.kind.to_ord();\n-        let arg_ord = arg.to_ord();\n+    let kind_ord = param.kind.to_ord();\n+    let arg_ord = arg.to_ord();\n \n-        // This note is only true when generic parameters are strictly ordered by their kind.\n-        if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n-            let (first, last) = if kind_ord < arg_ord {\n-                (param.kind.descr(), arg.descr())\n-            } else {\n-                (arg.descr(), param.kind.descr())\n-            };\n-            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-            if let Some(help) = help {\n-                err.help(help);\n-            }\n+    // This note is only true when generic parameters are strictly ordered by their kind.\n+    if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+        let (first, last) = if kind_ord < arg_ord {\n+            (param.kind.descr(), arg.descr())\n+        } else {\n+            (arg.descr(), param.kind.descr())\n+        };\n+        err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+        if let Some(help) = help {\n+            err.help(help);\n         }\n+    }\n+\n+    err.emit();\n+}\n \n-        err.emit();\n+/// Creates the relevant generic argument substitutions\n+/// corresponding to a set of generic parameters. This is a\n+/// rather complex function. Let us try to explain the role\n+/// of each of its parameters:\n+///\n+/// To start, we are given the `def_id` of the thing we are\n+/// creating the substitutions for, and a partial set of\n+/// substitutions `parent_substs`. In general, the substitutions\n+/// for an item begin with substitutions for all the \"parents\" of\n+/// that item -- e.g., for a method it might include the\n+/// parameters from the impl.\n+///\n+/// Therefore, the method begins by walking down these parents,\n+/// starting with the outermost parent and proceed inwards until\n+/// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n+/// first to see if the parent's substitutions are listed in there. If so,\n+/// we can append those and move on. Otherwise, it invokes the\n+/// three callback functions:\n+///\n+/// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n+///   generic arguments that were given to that parent from within\n+///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n+///   might refer to the trait `Foo`, and the arguments might be\n+///   `[T]`. The boolean value indicates whether to infer values\n+///   for arguments whose values were not explicitly provided.\n+/// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n+///   instantiate a `GenericArg`.\n+/// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n+///   creates a suitable inference variable.\n+pub fn create_substs_for_generic_args<'tcx, 'a>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    parent_substs: &[subst::GenericArg<'tcx>],\n+    has_self: bool,\n+    self_ty: Option<Ty<'tcx>>,\n+    arg_count: &GenericArgCountResult,\n+    ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n+) -> SubstsRef<'tcx> {\n+    // Collect the segments of the path; we need to substitute arguments\n+    // for parameters throughout the entire path (wherever there are\n+    // generic parameters).\n+    let mut parent_defs = tcx.generics_of(def_id);\n+    let count = parent_defs.count();\n+    let mut stack = vec![(def_id, parent_defs)];\n+    while let Some(def_id) = parent_defs.parent {\n+        parent_defs = tcx.generics_of(def_id);\n+        stack.push((def_id, parent_defs));\n     }\n \n-    /// Creates the relevant generic argument substitutions\n-    /// corresponding to a set of generic parameters. This is a\n-    /// rather complex function. Let us try to explain the role\n-    /// of each of its parameters:\n-    ///\n-    /// To start, we are given the `def_id` of the thing we are\n-    /// creating the substitutions for, and a partial set of\n-    /// substitutions `parent_substs`. In general, the substitutions\n-    /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- e.g., for a method it might include the\n-    /// parameters from the impl.\n-    ///\n-    /// Therefore, the method begins by walking down these parents,\n-    /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n-    /// first to see if the parent's substitutions are listed in there. If so,\n-    /// we can append those and move on. Otherwise, it invokes the\n-    /// three callback functions:\n-    ///\n-    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n-    ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n-    ///   might refer to the trait `Foo`, and the arguments might be\n-    ///   `[T]`. The boolean value indicates whether to infer values\n-    ///   for arguments whose values were not explicitly provided.\n-    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `GenericArg`.\n-    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n-    ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'a>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        parent_substs: &[subst::GenericArg<'tcx>],\n-        has_self: bool,\n-        self_ty: Option<Ty<'tcx>>,\n-        arg_count: &GenericArgCountResult,\n-        ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n-    ) -> SubstsRef<'tcx> {\n-        // Collect the segments of the path; we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n+    // We manually build up the substitution, rather than using convenience\n+    // methods in `subst.rs`, so that we can iterate over the arguments and\n+    // parameters in lock-step linearly, instead of trying to match each pair.\n+    let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n+    // Iterate over each segment of the path.\n+    while let Some((def_id, defs)) = stack.pop() {\n+        let mut params = defs.params.iter().peekable();\n+\n+        // If we have already computed substitutions for parents, we can use those directly.\n+        while let Some(&param) = params.peek() {\n+            if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                substs.push(kind);\n+                params.next();\n+            } else {\n+                break;\n+            }\n         }\n \n-        // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs`, so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter().peekable();\n-\n-            // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(&param) = params.peek() {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    substs.push(kind);\n-                    params.next();\n-                } else {\n-                    break;\n+        // `Self` is handled first, unless it's been handled in `parent_substs`.\n+        if has_self {\n+            if let Some(&param) = params.peek() {\n+                if param.index == 0 {\n+                    if let GenericParamDefKind::Type { .. } = param.kind {\n+                        substs.push(\n+                            self_ty\n+                                .map(|ty| ty.into())\n+                                .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n+                        );\n+                        params.next();\n+                    }\n                 }\n             }\n+        }\n \n-            // `Self` is handled first, unless it's been handled in `parent_substs`.\n-            if has_self {\n-                if let Some(&param) = params.peek() {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            substs.push(\n-                                self_ty\n-                                    .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n-                            );\n+        // Check whether this segment takes generic arguments and the user has provided any.\n+        let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n+\n+        let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n+        let mut args = args_iter.clone().peekable();\n+\n+        // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+        // If we later encounter a lifetime, we know that the arguments were provided in the\n+        // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+        // inferred, so we can use it for diagnostics later.\n+        let mut force_infer_lt = None;\n+\n+        loop {\n+            // We're going to iterate through the generic arguments that the user\n+            // provided, matching them with the generic parameters we expect.\n+            // Mismatches can occur as a result of elided lifetimes, or for malformed\n+            // input. We try to handle both sensibly.\n+            match (args.peek(), params.peek()) {\n+                (Some(&arg), Some(&param)) => {\n+                    match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                        (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                        | (\n+                            GenericArg::Type(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Type { .. },\n+                            _,\n+                        )\n+                        | (\n+                            GenericArg::Const(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Const { .. },\n+                            _,\n+                        ) => {\n+                            substs.push(ctx.provided_kind(param, arg));\n+                            args.next();\n                             params.next();\n                         }\n-                    }\n-                }\n-            }\n-\n-            // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n-\n-            let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n-            let mut args = args_iter.clone().peekable();\n-\n-            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n-            // If we later encounter a lifetime, we know that the arguments were provided in the\n-            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n-            // inferred, so we can use it for diagnostics later.\n-            let mut force_infer_lt = None;\n-\n-            loop {\n-                // We're going to iterate through the generic arguments that the user\n-                // provided, matching them with the generic parameters we expect.\n-                // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                // input. We try to handle both sensibly.\n-                match (args.peek(), params.peek()) {\n-                    (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n-                            | (\n-                                GenericArg::Type(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Type { .. },\n-                                _,\n-                            )\n-                            | (\n-                                GenericArg::Const(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Const { .. },\n-                                _,\n-                            ) => {\n-                                substs.push(ctx.provided_kind(param, arg));\n-                                args.next();\n-                                params.next();\n-                            }\n-                            (\n-                                GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n-                                GenericParamDefKind::Lifetime,\n-                                _,\n-                            ) => {\n-                                // We expected a lifetime argument, but got a type or const\n-                                // argument. That means we're inferring the lifetimes.\n-                                substs.push(ctx.inferred_kind(None, param, infer_args));\n-                                force_infer_lt = Some((arg, param));\n-                                params.next();\n-                            }\n-                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n-                                // We've come across a lifetime when we expected something else in\n-                                // the presence of explicit late bounds. This is most likely\n-                                // due to the presence of the explicit bound so we're just going to\n-                                // ignore it.\n-                                args.next();\n-                            }\n-                            (_, _, _) => {\n-                                // We expected one kind of parameter, but the user provided\n-                                // another. This is an error. However, if we already know that\n-                                // the arguments don't match up with the parameters, we won't issue\n-                                // an additional error, as the user already knows what's wrong.\n-                                if arg_count.correct.is_ok() {\n-                                    // We're going to iterate over the parameters to sort them out, and\n-                                    // show that order to the user as a possible order for the parameters\n-                                    let mut param_types_present = defs\n-                                        .params\n-                                        .iter()\n-                                        .map(|param| (param.kind.to_ord(), param.clone()))\n-                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n-                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n-                                    let (mut param_types_present, ordered_params): (\n-                                        Vec<ParamKindOrd>,\n-                                        Vec<GenericParamDef>,\n-                                    ) = param_types_present.into_iter().unzip();\n-                                    param_types_present.dedup();\n-\n-                                    Self::generic_arg_mismatch_err(\n-                                        tcx,\n-                                        arg,\n-                                        param,\n-                                        !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n-                                        Some(&format!(\n-                                            \"reorder the arguments: {}: `<{}>`\",\n-                                            param_types_present\n-                                                .into_iter()\n-                                                .map(|ord| format!(\"{}s\", ord))\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", then \"),\n-                                            ordered_params\n-                                                .into_iter()\n-                                                .filter_map(|param| {\n-                                                    if param.name == kw::SelfUpper {\n-                                                        None\n-                                                    } else {\n-                                                        Some(param.name.to_string())\n-                                                    }\n-                                                })\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", \")\n-                                        )),\n-                                    );\n-                                }\n-\n-                                // We've reported the error, but we want to make sure that this\n-                                // problem doesn't bubble down and create additional, irrelevant\n-                                // errors. In this case, we're simply going to ignore the argument\n-                                // and any following arguments. The rest of the parameters will be\n-                                // inferred.\n-                                while args.next().is_some() {}\n-                            }\n+                        (\n+                            GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n+                            GenericParamDefKind::Lifetime,\n+                            _,\n+                        ) => {\n+                            // We expected a lifetime argument, but got a type or const\n+                            // argument. That means we're inferring the lifetimes.\n+                            substs.push(ctx.inferred_kind(None, param, infer_args));\n+                            force_infer_lt = Some((arg, param));\n+                            params.next();\n                         }\n-                    }\n-\n-                    (Some(&arg), None) => {\n-                        // We should never be able to reach this point with well-formed input.\n-                        // There are three situations in which we can encounter this issue.\n-                        //\n-                        //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it.\n-                        //  2.  There are late-bound lifetime parameters present, yet the\n-                        //      lifetime arguments have also been explicitly specified by the\n-                        //      user.\n-                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                        //      after a type or const). We want to throw an error in this case.\n-\n-                        if arg_count.correct.is_ok()\n-                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                        {\n-                            let kind = arg.descr();\n-                            assert_eq!(kind, \"lifetime\");\n-                            let (provided_arg, param) =\n-                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n+                        (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                            // We've come across a lifetime when we expected something else in\n+                            // the presence of explicit late bounds. This is most likely\n+                            // due to the presence of the explicit bound so we're just going to\n+                            // ignore it.\n+                            args.next();\n                         }\n+                        (_, _, _) => {\n+                            // We expected one kind of parameter, but the user provided\n+                            // another. This is an error. However, if we already know that\n+                            // the arguments don't match up with the parameters, we won't issue\n+                            // an additional error, as the user already knows what's wrong.\n+                            if arg_count.correct.is_ok() {\n+                                // We're going to iterate over the parameters to sort them out, and\n+                                // show that order to the user as a possible order for the parameters\n+                                let mut param_types_present = defs\n+                                    .params\n+                                    .iter()\n+                                    .map(|param| (param.kind.to_ord(), param.clone()))\n+                                    .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                let (mut param_types_present, ordered_params): (\n+                                    Vec<ParamKindOrd>,\n+                                    Vec<GenericParamDef>,\n+                                ) = param_types_present.into_iter().unzip();\n+                                param_types_present.dedup();\n+\n+                                generic_arg_mismatch_err(\n+                                    tcx,\n+                                    arg,\n+                                    param,\n+                                    !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n+                                    Some(&format!(\n+                                        \"reorder the arguments: {}: `<{}>`\",\n+                                        param_types_present\n+                                            .into_iter()\n+                                            .map(|ord| format!(\"{}s\", ord))\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", then \"),\n+                                        ordered_params\n+                                            .into_iter()\n+                                            .filter_map(|param| {\n+                                                if param.name == kw::SelfUpper {\n+                                                    None\n+                                                } else {\n+                                                    Some(param.name.to_string())\n+                                                }\n+                                            })\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", \")\n+                                    )),\n+                                );\n+                            }\n \n-                        break;\n+                            // We've reported the error, but we want to make sure that this\n+                            // problem doesn't bubble down and create additional, irrelevant\n+                            // errors. In this case, we're simply going to ignore the argument\n+                            // and any following arguments. The rest of the parameters will be\n+                            // inferred.\n+                            while args.next().is_some() {}\n+                        }\n                     }\n+                }\n \n-                    (None, Some(&param)) => {\n-                        // If there are fewer arguments than parameters, it means\n-                        // we're inferring the remaining arguments.\n-                        substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n-                        params.next();\n+                (Some(&arg), None) => {\n+                    // We should never be able to reach this point with well-formed input.\n+                    // There are three situations in which we can encounter this issue.\n+                    //\n+                    //  1.  The number of arguments is incorrect. In this case, an error\n+                    //      will already have been emitted, and we can ignore it.\n+                    //  2.  There are late-bound lifetime parameters present, yet the\n+                    //      lifetime arguments have also been explicitly specified by the\n+                    //      user.\n+                    //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n+                    //      after a type or const). We want to throw an error in this case.\n+\n+                    if arg_count.correct.is_ok()\n+                        && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                    {\n+                        let kind = arg.descr();\n+                        assert_eq!(kind, \"lifetime\");\n+                        let (provided_arg, param) =\n+                            force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                        generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n                     }\n \n-                    (None, None) => break,\n+                    break;\n+                }\n+\n+                (None, Some(&param)) => {\n+                    // If there are fewer arguments than parameters, it means\n+                    // we're inferring the remaining arguments.\n+                    substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n+                    params.next();\n                 }\n+\n+                (None, None) => break,\n             }\n         }\n-\n-        tcx.intern_substs(&substs)\n     }\n \n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// Used specifically for function calls.\n-    pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        generics: &ty::Generics,\n-        seg: &hir::PathSegment<'_>,\n-        is_method_call: IsMethodCall,\n-    ) -> GenericArgCountResult {\n-        let empty_args = hir::GenericArgs::none();\n-        let gen_args = seg.args.unwrap_or(&empty_args);\n-        let gen_pos = if is_method_call == IsMethodCall::Yes {\n-            GenericArgPosition::MethodCall\n+    tcx.intern_substs(&substs)\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// Used specifically for function calls.\n+pub fn check_generic_arg_count_for_call(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    generics: &ty::Generics,\n+    seg: &hir::PathSegment<'_>,\n+    is_method_call: IsMethodCall,\n+) -> GenericArgCountResult {\n+    let empty_args = hir::GenericArgs::none();\n+    let gen_args = seg.args.unwrap_or(&empty_args);\n+    let gen_pos = if is_method_call == IsMethodCall::Yes {\n+        GenericArgPosition::MethodCall\n+    } else {\n+        GenericArgPosition::Value\n+    };\n+    let has_self = generics.parent.is_none() && generics.has_self;\n+\n+    check_generic_arg_count(\n+        tcx,\n+        span,\n+        def_id,\n+        seg,\n+        generics,\n+        gen_args,\n+        gen_pos,\n+        has_self,\n+        seg.infer_args,\n+    )\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// This is used both for datatypes and function calls.\n+#[instrument(skip(tcx, gen_pos), level = \"debug\")]\n+pub(crate) fn check_generic_arg_count(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    seg: &hir::PathSegment<'_>,\n+    gen_params: &ty::Generics,\n+    gen_args: &hir::GenericArgs<'_>,\n+    gen_pos: GenericArgPosition,\n+    has_self: bool,\n+    infer_args: bool,\n+) -> GenericArgCountResult {\n+    let default_counts = gen_params.own_defaults();\n+    let param_counts = gen_params.own_counts();\n+\n+    // Subtracting from param count to ensure type params synthesized from `impl Trait`\n+    // cannot be explicitly specified.\n+    let synth_type_param_count = gen_params\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. }))\n+        .count();\n+    let named_type_param_count = param_counts.types - has_self as usize - synth_type_param_count;\n+    let infer_lifetimes =\n+        (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n+\n+    if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n+            prohibit_assoc_ty_binding(tcx, b.span);\n+        }\n+\n+    let explicit_late_bound =\n+        prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n+\n+    let mut invalid_args = vec![];\n+\n+    let mut check_lifetime_args = |min_expected_args: usize,\n+                                   max_expected_args: usize,\n+                                   provided_args: usize,\n+                                   late_bounds_ignore: bool| {\n+        if (min_expected_args..=max_expected_args).contains(&provided_args) {\n+            return Ok(());\n+        }\n+\n+        if late_bounds_ignore {\n+            return Ok(());\n+        }\n+\n+        if provided_args > max_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[max_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+        };\n+\n+        let gen_args_info = if provided_args > min_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[min_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided_args - min_expected_args;\n+            GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n         } else {\n-            GenericArgPosition::Value\n+            let num_missing_args = min_expected_args - provided_args;\n+            GenericArgsInfo::MissingLifetimes { num_missing_args }\n         };\n-        let has_self = generics.parent.is_none() && generics.has_self;\n \n-        Self::check_generic_arg_count(\n+        let reported = WrongNumberOfGenericArgs::new(\n             tcx,\n-            span,\n-            def_id,\n+            gen_args_info,\n             seg,\n-            generics,\n+            gen_params,\n+            has_self as usize,\n             gen_args,\n-            gen_pos,\n-            has_self,\n-            seg.infer_args,\n+            def_id,\n         )\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// This is used both for datatypes and function calls.\n-    #[instrument(skip(tcx, gen_pos), level = \"debug\")]\n-    pub(crate) fn check_generic_arg_count(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        seg: &hir::PathSegment<'_>,\n-        gen_params: &ty::Generics,\n-        gen_args: &hir::GenericArgs<'_>,\n-        gen_pos: GenericArgPosition,\n-        has_self: bool,\n-        infer_args: bool,\n-    ) -> GenericArgCountResult {\n-        let default_counts = gen_params.own_defaults();\n-        let param_counts = gen_params.own_counts();\n-\n-        // Subtracting from param count to ensure type params synthesized from `impl Trait`\n-        // cannot be explicitly specified.\n-        let synth_type_param_count = gen_params\n-            .params\n-            .iter()\n-            .filter(|param| {\n-                matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. })\n-            })\n-            .count();\n-        let named_type_param_count =\n-            param_counts.types - has_self as usize - synth_type_param_count;\n-        let infer_lifetimes =\n-            (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n-\n-        if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n-            Self::prohibit_assoc_ty_binding(tcx, b.span);\n+        .diagnostic()\n+        .emit();\n+\n+        Err(reported)\n+    };\n+\n+    let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n+    let max_expected_lifetime_args = param_counts.lifetimes;\n+    let num_provided_lifetime_args = gen_args.num_lifetime_params();\n+\n+    let lifetimes_correct = check_lifetime_args(\n+        min_expected_lifetime_args,\n+        max_expected_lifetime_args,\n+        num_provided_lifetime_args,\n+        explicit_late_bound == ExplicitLateBound::Yes,\n+    );\n+\n+    let mut check_types_and_consts = |expected_min,\n+                                      expected_max,\n+                                      expected_max_with_synth,\n+                                      provided,\n+                                      params_offset,\n+                                      args_offset| {\n+        debug!(\n+            ?expected_min,\n+            ?expected_max,\n+            ?provided,\n+            ?params_offset,\n+            ?args_offset,\n+            \"check_types_and_consts\"\n+        );\n+        if (expected_min..=expected_max).contains(&provided) {\n+            return Ok(());\n         }\n \n-        let explicit_late_bound =\n-            Self::prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n-\n-        let mut invalid_args = vec![];\n+        let num_default_params = expected_max - expected_min;\n \n-        let mut check_lifetime_args =\n-            |min_expected_args: usize,\n-             max_expected_args: usize,\n-             provided_args: usize,\n-             late_bounds_ignore: bool| {\n-                if (min_expected_args..=max_expected_args).contains(&provided_args) {\n-                    return Ok(());\n-                }\n-\n-                if late_bounds_ignore {\n-                    return Ok(());\n-                }\n+        let gen_args_info = if provided > expected_max {\n+            invalid_args.extend(\n+                gen_args.args[args_offset + expected_max..args_offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided - expected_max;\n \n-                if provided_args > max_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[max_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                };\n-\n-                let gen_args_info = if provided_args > min_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[min_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                    let num_redundant_args = provided_args - min_expected_args;\n-                    GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n-                } else {\n-                    let num_missing_args = min_expected_args - provided_args;\n-                    GenericArgsInfo::MissingLifetimes { num_missing_args }\n-                };\n-\n-                let reported = WrongNumberOfGenericArgs::new(\n-                    tcx,\n-                    gen_args_info,\n-                    seg,\n-                    gen_params,\n-                    has_self as usize,\n-                    gen_args,\n-                    def_id,\n-                )\n-                .diagnostic()\n-                .emit();\n-\n-                Err(reported)\n-            };\n-\n-        let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n-        let max_expected_lifetime_args = param_counts.lifetimes;\n-        let num_provided_lifetime_args = gen_args.num_lifetime_params();\n-\n-        let lifetimes_correct = check_lifetime_args(\n-            min_expected_lifetime_args,\n-            max_expected_lifetime_args,\n-            num_provided_lifetime_args,\n-            explicit_late_bound == ExplicitLateBound::Yes,\n-        );\n+            // Provide extra note if synthetic arguments like `impl Trait` are specified.\n+            let synth_provided = provided <= expected_max_with_synth;\n \n-        let mut check_types_and_consts = |expected_min,\n-                                          expected_max,\n-                                          expected_max_with_synth,\n-                                          provided,\n-                                          params_offset,\n-                                          args_offset| {\n-            debug!(\n-                ?expected_min,\n-                ?expected_max,\n-                ?provided,\n-                ?params_offset,\n-                ?args_offset,\n-                \"check_types_and_consts\"\n-            );\n-            if (expected_min..=expected_max).contains(&provided) {\n-                return Ok(());\n+            GenericArgsInfo::ExcessTypesOrConsts {\n+                num_redundant_args,\n+                num_default_params,\n+                args_offset,\n+                synth_provided,\n             }\n+        } else {\n+            let num_missing_args = expected_max - provided;\n \n-            let num_default_params = expected_max - expected_min;\n-\n-            let gen_args_info = if provided > expected_max {\n-                invalid_args.extend(\n-                    gen_args.args[args_offset + expected_max..args_offset + provided]\n-                        .iter()\n-                        .map(|arg| arg.span()),\n-                );\n-                let num_redundant_args = provided - expected_max;\n+            GenericArgsInfo::MissingTypesOrConsts {\n+                num_missing_args,\n+                num_default_params,\n+                args_offset,\n+            }\n+        };\n \n-                // Provide extra note if synthetic arguments like `impl Trait` are specified.\n-                let synth_provided = provided <= expected_max_with_synth;\n+        debug!(?gen_args_info);\n \n-                GenericArgsInfo::ExcessTypesOrConsts {\n-                    num_redundant_args,\n-                    num_default_params,\n-                    args_offset,\n-                    synth_provided,\n-                }\n-            } else {\n-                let num_missing_args = expected_max - provided;\n+        let reported = WrongNumberOfGenericArgs::new(\n+            tcx,\n+            gen_args_info,\n+            seg,\n+            gen_params,\n+            params_offset,\n+            gen_args,\n+            def_id,\n+        )\n+        .diagnostic()\n+        .emit_unless(gen_args.has_err());\n \n-                GenericArgsInfo::MissingTypesOrConsts {\n-                    num_missing_args,\n-                    num_default_params,\n-                    args_offset,\n-                }\n-            };\n-\n-            debug!(?gen_args_info);\n-\n-            let reported = WrongNumberOfGenericArgs::new(\n-                tcx,\n-                gen_args_info,\n-                seg,\n-                gen_params,\n-                params_offset,\n-                gen_args,\n-                def_id,\n-            )\n-            .diagnostic()\n-            .emit_unless(gen_args.has_err());\n-\n-            Err(reported)\n-        };\n+        Err(reported)\n+    };\n \n-        let args_correct = {\n-            let expected_min = if infer_args {\n-                0\n-            } else {\n-                param_counts.consts + named_type_param_count\n-                    - default_counts.types\n-                    - default_counts.consts\n-            };\n-            debug!(?expected_min);\n-            debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n-\n-            check_types_and_consts(\n-                expected_min,\n-                param_counts.consts + named_type_param_count,\n-                param_counts.consts + named_type_param_count + synth_type_param_count,\n-                gen_args.num_generic_params(),\n-                param_counts.lifetimes + has_self as usize,\n-                gen_args.num_lifetime_params(),\n-            )\n+    let args_correct = {\n+        let expected_min = if infer_args {\n+            0\n+        } else {\n+            param_counts.consts + named_type_param_count\n+                - default_counts.types\n+                - default_counts.consts\n         };\n+        debug!(?expected_min);\n+        debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n+\n+        check_types_and_consts(\n+            expected_min,\n+            param_counts.consts + named_type_param_count,\n+            param_counts.consts + named_type_param_count + synth_type_param_count,\n+            gen_args.num_generic_params(),\n+            param_counts.lifetimes + has_self as usize,\n+            gen_args.num_lifetime_params(),\n+        )\n+    };\n \n-        GenericArgCountResult {\n-            explicit_late_bound,\n-            correct: lifetimes_correct.and(args_correct).map_err(|reported| {\n-                GenericArgCountMismatch { reported: Some(reported), invalid_args }\n-            }),\n-        }\n+    GenericArgCountResult {\n+        explicit_late_bound,\n+        correct: lifetimes_correct\n+            .and(args_correct)\n+            .map_err(|reported| GenericArgCountMismatch { reported: Some(reported), invalid_args }),\n     }\n+}\n \n-    /// Emits an error regarding forbidden type binding associations\n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n-    }\n+/// Emits an error regarding forbidden type binding associations\n+pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n+}\n \n-    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n-    /// are present. This is used both for datatypes and function calls.\n-    pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n-        tcx: TyCtxt<'_>,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-    ) -> ExplicitLateBound {\n-        let param_counts = def.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n-\n-        if infer_lifetimes {\n-            return ExplicitLateBound::No;\n-        }\n+/// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+/// are present. This is used both for datatypes and function calls.\n+pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n+    tcx: TyCtxt<'_>,\n+    def: &ty::Generics,\n+    args: &hir::GenericArgs<'_>,\n+    position: GenericArgPosition,\n+) -> ExplicitLateBound {\n+    let param_counts = def.own_counts();\n+    let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n+\n+    if infer_lifetimes {\n+        return ExplicitLateBound::No;\n+    }\n \n-        if let Some(span_late) = def.has_late_bound_regions {\n-            let msg = \"cannot specify lifetime arguments explicitly \\\n+    if let Some(span_late) = def.has_late_bound_regions {\n+        let msg = \"cannot specify lifetime arguments explicitly \\\n                        if late bound lifetime parameters are present\";\n-            let note = \"the late bound lifetime parameter is introduced here\";\n-            let span = args.args[0].span();\n-\n-            if position == GenericArgPosition::Value\n-                && args.num_lifetime_params() != param_counts.lifetimes\n-            {\n-                let mut err = tcx.sess.struct_span_err(span, msg);\n-                err.span_note(span_late, note);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(span);\n-                multispan.push_span_label(span_late, note);\n-                tcx.struct_span_lint_hir(\n-                    LATE_BOUND_LIFETIME_ARGUMENTS,\n-                    args.args[0].hir_id(),\n-                    multispan,\n-                    msg,\n-                    |lint| lint,\n-                );\n-            }\n-\n-            ExplicitLateBound::Yes\n+        let note = \"the late bound lifetime parameter is introduced here\";\n+        let span = args.args[0].span();\n+\n+        if position == GenericArgPosition::Value\n+            && args.num_lifetime_params() != param_counts.lifetimes\n+        {\n+            let mut err = tcx.sess.struct_span_err(span, msg);\n+            err.span_note(span_late, note);\n+            err.emit();\n         } else {\n-            ExplicitLateBound::No\n+            let mut multispan = MultiSpan::from_span(span);\n+            multispan.push_span_label(span_late, note);\n+            tcx.struct_span_lint_hir(\n+                LATE_BOUND_LIFETIME_ARGUMENTS,\n+                args.args[0].hir_id(),\n+                multispan,\n+                msg,\n+                |lint| lint,\n+            );\n         }\n+\n+        ExplicitLateBound::Yes\n+    } else {\n+        ExplicitLateBound::No\n     }\n }"}, {"sha": "9fa0e6e8eaa646d396ca2049b9fc69c59587862e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -3,8 +3,11 @@\n //! instance of `AstConv`.\n \n mod errors;\n-mod generics;\n+pub mod generics;\n \n+use crate::astconv::generics::{\n+    check_generic_arg_count, create_substs_for_generic_args, prohibit_assoc_ty_binding,\n+};\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n@@ -120,6 +123,13 @@ pub trait AstConv<'tcx> {\n     fn set_tainted_by_errors(&self, e: ErrorGuaranteed);\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n+\n+    fn astconv(&self) -> &dyn AstConv<'tcx>\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n }\n \n #[derive(Debug)]\n@@ -279,7 +289,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         substs\n@@ -349,7 +359,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none());\n         }\n \n-        let arg_count = Self::check_generic_arg_count(\n+        let arg_count = check_generic_arg_count(\n             tcx,\n             span,\n             def_id,\n@@ -524,7 +534,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             inferred_params: vec![],\n             infer_args,\n         };\n-        let substs = Self::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             tcx,\n             def_id,\n             parent_substs,\n@@ -610,7 +620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         args\n@@ -804,7 +814,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n@@ -2301,7 +2311,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let Some(b) = segment.args().bindings.first() {\n-                Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+                prohibit_assoc_ty_binding(self.tcx(), b.span);\n                 return true;\n             }\n         }"}, {"sha": "cd745ee8cab69929e714c78fa546108a30b8ca1e", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -351,7 +351,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n-        <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_ty)\n+        self.astconv().ast_ty_to_ty(ast_ty)\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n@@ -413,8 +413,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n-            let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n-                self,\n+            let item_substs = self.astconv().create_substs_for_associated_item(\n                 span,\n                 item_def_id,\n                 item_segment,\n@@ -1112,8 +1111,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                 tcx.hir().get_parent(hir_id)\n                 && i.of_trait.is_some()\n             {\n-                <dyn AstConv<'_>>::ty_of_fn(\n-                    &icx,\n+                icx.astconv().ty_of_fn(\n                     hir_id,\n                     sig.header.unsafety,\n                     sig.header.abi,\n@@ -1130,15 +1128,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             kind: TraitItemKind::Fn(FnSig { header, decl, span: _ }, _),\n             generics,\n             ..\n-        }) => <dyn AstConv<'_>>::ty_of_fn(\n-            &icx,\n-            hir_id,\n-            header.unsafety,\n-            header.abi,\n-            decl,\n-            Some(generics),\n-            None,\n-        ),\n+        }) => {\n+            icx.astconv().ty_of_fn(hir_id, header.unsafety, header.abi, decl, Some(generics), None)\n+        }\n \n         ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n@@ -1244,8 +1236,7 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n             ty::Binder::dummy(fn_sig)\n         }\n-        None => <dyn AstConv<'_>>::ty_of_fn(\n-            icx,\n+        None => icx.astconv().ty_of_fn(\n             hir_id,\n             sig.header.unsafety,\n             sig.header.abi,\n@@ -1354,8 +1345,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     match item.kind {\n         hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n-            <dyn AstConv<'_>>::instantiate_mono_trait_ref(\n-                &icx,\n+            icx.astconv().instantiate_mono_trait_ref(\n                 ast_trait_ref,\n                 selfty,\n                 check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n@@ -1485,15 +1475,8 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         hir::Unsafety::Unsafe\n     };\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let fty = <dyn AstConv<'_>>::ty_of_fn(\n-        &ItemCtxt::new(tcx, def_id),\n-        hir_id,\n-        unsafety,\n-        abi,\n-        decl,\n-        None,\n-        None,\n-    );\n+    let fty =\n+        ItemCtxt::new(tcx, def_id).astconv().ty_of_fn(hir_id, unsafety, abi, decl, None, None);\n \n     // Feature gate SIMD types in FFI, since I am not sure that the\n     // ABIs are handled at all correctly. -huonw"}, {"sha": "62eef710ba48f0542079996933b500f5b5643304", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -26,9 +26,9 @@ fn associated_type_bounds<'tcx>(\n     );\n \n     let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n-    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n+    let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n-    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n+    icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n \n     let trait_def_id = tcx.parent(assoc_item_def_id);\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -70,9 +70,9 @@ fn opaque_type_bounds<'tcx>(\n         };\n \n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n-        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n+        let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n-        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n+        icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n         debug!(?bounds);\n \n         tcx.arena.alloc_from_iter(bounds.predicates())"}, {"sha": "234253556845bf264283ec24fedcfbd8c7549a86", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -162,8 +162,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n                 let mut bounds = Bounds::default();\n                 // Params are implicitly sized unless a `?Sized` bound is found\n-                <dyn AstConv<'_>>::add_implicitly_sized(\n-                    &icx,\n+                icx.astconv().add_implicitly_sized(\n                     &mut bounds,\n                     param_ty,\n                     &[],\n@@ -211,22 +210,16 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 }\n \n                 let mut bounds = Bounds::default();\n-                <dyn AstConv<'_>>::add_bounds(\n-                    &icx,\n-                    ty,\n-                    bound_pred.bounds.iter(),\n-                    &mut bounds,\n-                    bound_vars,\n-                );\n+                icx.astconv().add_bounds(ty, bound_pred.bounds.iter(), &mut bounds, bound_vars);\n                 predicates.extend(bounds.predicates());\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n-                let r1 = <dyn AstConv<'_>>::ast_region_to_region(&icx, &region_pred.lifetime, None);\n+                let r1 = icx.astconv().ast_region_to_region(&region_pred.lifetime, None);\n                 predicates.extend(region_pred.bounds.iter().map(|bound| {\n                     let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n-                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.ident.span)\n+                            (icx.astconv().ast_region_to_region(lt, None), lt.ident.span)\n                         }\n                         _ => bug!(),\n                     };\n@@ -279,7 +272,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         debug!(?lifetimes);\n         for (arg, duplicate) in std::iter::zip(lifetimes, ast_generics.params) {\n             let hir::GenericArg::Lifetime(arg) = arg else { bug!() };\n-            let orig_region = <dyn AstConv<'_>>::ast_region_to_region(&icx, &arg, None);\n+            let orig_region = icx.astconv().ast_region_to_region(&arg, None);\n             if !matches!(orig_region.kind(), ty::ReEarlyBound(..)) {\n                 // Only early-bound regions can point to the original generic parameter.\n                 continue;\n@@ -527,14 +520,9 @@ pub(super) fn super_predicates_that_define_assoc_type(\n         // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n         let self_param_ty = tcx.types.self_param;\n         let superbounds1 = if let Some(assoc_name) = assoc_name {\n-            <dyn AstConv<'_>>::compute_bounds_that_match_assoc_type(\n-                &icx,\n-                self_param_ty,\n-                bounds,\n-                assoc_name,\n-            )\n+            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n         } else {\n-            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n+            icx.astconv().compute_bounds(self_param_ty, bounds)\n         };\n \n         let superbounds1 = superbounds1.predicates();"}, {"sha": "ddc5b7668812668e9e6f923956ba85bd0a2cb484", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -545,7 +545,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n-    <dyn AstConv<'_>>::ast_ty_to_ty(&item_cx, hir_ty)\n+    item_cx.astconv().ast_ty_to_ty(hir_ty)\n }\n \n pub fn hir_trait_to_predicates<'tcx>(\n@@ -559,8 +559,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     let env_def_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n-    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n-        &item_cx,\n+    let _ = &item_cx.astconv().instantiate_poly_trait_ref(\n         hir_trait,\n         DUMMY_SP,\n         ty::BoundConstness::NotConst,"}, {"sha": "7e1c0faa453a26f08b87472f77d09cc51b237a2e", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -1807,7 +1807,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             // Get the return type.\n             && let hir::TyKind::OpaqueDef(..) = ty.kind\n         {\n-            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n+            let ty = fcx.astconv().ast_ty_to_ty( ty);\n             // Get the `impl Trait`'s `DefId`.\n             if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind()\n                 // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n@@ -1866,7 +1866,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     fn is_return_ty_unsized<'a>(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n         if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id)\n             && let hir::FnRetTy::Return(ty) = fn_decl.output\n-            && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n+            && let ty = fcx.astconv().ast_ty_to_ty( ty)\n             && let ty::Dynamic(..) = ty.kind()\n         {\n             return true;"}, {"sha": "8570715b41e59060d6ad2cbbb6e6aec20162c267", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -10,6 +10,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{\n     AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, IsMethodCall, PathSeg,\n@@ -374,7 +377,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> RawTy<'tcx> {\n-        let t = <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_t);\n+        let t = self.astconv().ast_ty_to_ty(ast_t);\n         self.register_wf_obligation(t.into(), ast_t.span, traits::WellFormed(None));\n         self.handle_raw_ty(ast_t.span, t)\n     }\n@@ -777,7 +780,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // to be object-safe.\n                 // We manually call `register_wf_obligation` in the success path\n                 // below.\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself);\n+                let ty = self.astconv().ast_ty_to_ty_in_path(qself);\n                 (self.handle_raw_ty(span, ty), qself, segment)\n             }\n             QPath::LangItem(..) => {\n@@ -975,8 +978,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let path_segs = match res {\n             Res::Local(_) | Res::SelfCtor(_) => vec![],\n-            Res::Def(kind, def_id) => <dyn AstConv<'_>>::def_ids_for_value_path_segments(\n-                self,\n+            Res::Def(kind, def_id) => self.astconv().def_ids_for_value_path_segments(\n                 segments,\n                 self_ty.map(|ty| ty.raw),\n                 kind,\n@@ -1027,8 +1029,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n \n         let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n-        let generics_has_err = <dyn AstConv<'_>>::prohibit_generics(\n-            self,\n+        let generics_has_err = self.astconv().prohibit_generics(\n             segments.iter().enumerate().filter_map(|(index, seg)| {\n                 if !generic_segs.contains(&index) || is_alias_variant_ctor {\n                     Some(seg)\n@@ -1069,7 +1070,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            let arg_count = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+            let arg_count = check_generic_arg_count_for_call(\n                 tcx,\n                 span,\n                 def_id,\n@@ -1177,7 +1178,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) -> ty::GenericArg<'tcx> {\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        <dyn AstConv<'_>>::ast_region_to_region(self.fcx, lt, Some(param)).into()\n+                        self.fcx.astconv().ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.fcx.to_ty(ty).raw.into()\n@@ -1235,7 +1236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let substs_raw = self_ctor_substs.unwrap_or_else(|| {\n-            <dyn AstConv<'_>>::create_substs_for_generic_args(\n+            create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[],"}, {"sha": "b9e13fd20092421554e9d9d3ce9899334f100d74", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -1664,15 +1664,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n-                let ty = <dyn AstConv<'_>>::res_to_ty(self, self_ty, path, true);\n+                let ty = self.astconv().res_to_ty(self_ty, path, true);\n                 (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty.raw, qself, segment, true,\n-                );\n+                let result = self\n+                    .astconv()\n+                    .associated_path_to_ty(hir_id, path_span, ty.raw, qself, segment, true);\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));"}, {"sha": "428fde642bc0901bff4a7fb92c8c6cb6c589c100", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -294,8 +294,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             poly_trait_ref,\n         );\n \n-        let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n-            self,\n+        let item_substs = self.astconv().create_substs_for_associated_item(\n             span,\n             item_def_id,\n             item_segment,"}, {"sha": "005bd164065d80f612a6075c2f886957796a6bef", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -793,7 +793,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n                 let span = ty.span;\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                let ty = self.astconv().ast_ty_to_ty(ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 let bound_vars = self.tcx.late_bound_vars(fn_id);\n@@ -864,7 +864,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ..\n                 }) => {\n                     // FIXME: Maybe these calls to `ast_ty_to_ty` can be removed (and the ones below)\n-                    let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, bounded_ty);\n+                    let ty = self.astconv().ast_ty_to_ty(bounded_ty);\n                     Some((ty, bounds))\n                 }\n                 _ => None,\n@@ -902,7 +902,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_bounds_str = all_matching_bounds_strs.join(\" + \");\n \n         let ty_param_used_in_fn_params = fn_parameters.iter().any(|param| {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, param);\n+                let ty = self.astconv().ast_ty_to_ty( param);\n                 matches!(ty.kind(), ty::Param(fn_param_ty_param) if expected_ty_as_param == fn_param_ty_param)\n             });\n \n@@ -956,7 +956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+            let ty = self.astconv().ast_ty_to_ty(ty);\n             let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n@@ -1349,7 +1349,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::Path { segments: [segment], .. },\n             ))\n             | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n-                let self_ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                let self_ty = self.astconv().ast_ty_to_ty(ty);\n                 if let Ok(pick) = self.probe_for_name(\n                     Mode::Path,\n                     Ident::new(capitalized_name, segment.ident.span),"}, {"sha": "7ddf9eaa4d8995463fa730d5ad653c536b174d2b", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -205,7 +205,7 @@ fn typeck_with_fallback<'tcx>(\n \n         if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n+                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n             } else {\n                 tcx.fn_sig(def_id)\n             };\n@@ -220,7 +220,7 @@ fn typeck_with_fallback<'tcx>(\n         } else {\n             let expected_type = body_ty\n                 .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n+                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n                     _ => None,\n                 })\n                 .unwrap_or_else(|| match tcx.hir().get(id) {"}, {"sha": "4a33a791e1b7f3b12db9c6e54ca541ab93b5c0fa", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec36f56684cbd0fa90ab2da3c5084811f7a3989/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "patch": "@@ -4,6 +4,9 @@ use crate::{callee, FnCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n@@ -331,7 +334,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // variables.\n         let generics = self.tcx.generics_of(pick.item.def_id);\n \n-        let arg_count_correct = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+        let arg_count_correct = check_generic_arg_count_for_call(\n             self.tcx,\n             self.span,\n             pick.item.def_id,\n@@ -369,8 +372,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             ) -> subst::GenericArg<'tcx> {\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        <dyn AstConv<'_>>::ast_region_to_region(self.cfcx.fcx, lt, Some(param))\n-                            .into()\n+                        self.cfcx.fcx.astconv().ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.cfcx.to_ty(ty).raw.into()\n@@ -399,7 +401,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             }\n         }\n \n-        let substs = <dyn AstConv<'_>>::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,"}]}