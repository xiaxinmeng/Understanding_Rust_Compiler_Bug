{"sha": "7efef989011307bb9bb1679c9022c17bffecd2f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZmVmOTg5MDExMzA3YmI5YmIxNjc5YzkwMjJjMTdiZmZlY2QyZjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-14T14:23:11Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T10:46:57Z"}, "message": "Make uses of self in impls compile\n\nGet rid of expr_self_call, introduces def_self. `self` is now,\nsyntactically, simply a variable. A method implicitly brings a `self`\nbinding into scope.\n\nIssue #1227", "tree": {"sha": "9d7138daf99bb6171809ccb1258fb770bac2edcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d7138daf99bb6171809ccb1258fb770bac2edcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7efef989011307bb9bb1679c9022c17bffecd2f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7efef989011307bb9bb1679c9022c17bffecd2f6", "html_url": "https://github.com/rust-lang/rust/commit/7efef989011307bb9bb1679c9022c17bffecd2f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7efef989011307bb9bb1679c9022c17bffecd2f6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64", "html_url": "https://github.com/rust-lang/rust/commit/1dd2f1ec03f41e9ce15fdfe2c729b74f74df2e64"}], "stats": {"total": 340, "additions": 137, "deletions": 203}, "files": [{"sha": "8f15e10c3d0edacdf8beef68be7c4d898b68e03c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -240,7 +240,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     }\n     let f_may_close =\n         alt f.node {\n-          ast::expr_path(_) { def_is_local(cx.tcx.def_map.get(f.id), true) }\n+          ast::expr_path(_) { def_is_local(cx.tcx.def_map.get(f.id)) }\n           _ { true }\n         };\n     if f_may_close {\n@@ -374,7 +374,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n fn check_var(cx: ctx, ex: @ast::expr, p: @ast::path, id: ast::node_id,\n              assign: bool, sc: scope) {\n     let def = cx.tcx.def_map.get(id);\n-    if !def_is_local(def, false) { ret; }\n+    if !def_is_local(def) { ret; }\n     let my_defnum = ast_util::def_id_of_def(def).node;\n     let my_local_id = local_id_of_node(cx, my_defnum);\n     let var_t = ty::expr_ty(cx.tcx, ex);\n@@ -529,20 +529,19 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n     ret helper(cx.tcx, needle, haystack, mut);\n }\n \n-fn def_is_local(d: ast::def, objfields_count: bool) -> bool {\n-    ret alt d {\n-          ast::def_local(_, _) | ast::def_arg(_, _) | ast::def_binding(_) |\n-          ast::def_upvar(_, _, _) | ast::def_self(_) {\n-            true\n-          }\n-          ast::def_obj_field(_, _) { objfields_count }\n-          _ { false }\n-        };\n+fn def_is_local(d: ast::def) -> bool {\n+    alt d {\n+      ast::def_local(_, _) | ast::def_arg(_, _) | ast::def_binding(_) |\n+      ast::def_upvar(_, _, _) | ast::def_self(_) |\n+      ast::def_obj_field(_, _) { true }\n+      _ { false }\n+    }\n }\n \n fn local_id_of_node(cx: ctx, id: node_id) -> uint {\n-    alt cx.tcx.items.get(id) {\n-      ast_map::node_arg(_, id) | ast_map::node_local(id) { id }\n+    alt cx.tcx.items.find(id) {\n+      some(ast_map::node_arg(_, id)) | some(ast_map::node_local(id)) { id }\n+      _ { 0u }\n     }\n }\n "}, {"sha": "d3856f4bd2d2c23daa160033e8a39c766ad791c9", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -203,6 +203,9 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n           def_obj_field(_, _) {\n             mk_err(cx, src.span, msg_move_out, \"object field\");\n           }\n+          def_self(_) {\n+            mk_err(cx, src.span, msg_move_out, \"method self\");\n+          }\n           _ { }\n         }\n         check_lval(cx, src, msg_move_out);"}, {"sha": "19d74e11cd8fd5129b19096e56fc08483d15f38d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -37,6 +37,7 @@ tag scope {\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n     scope_block(ast::blk, @mutable uint, @mutable uint);\n     scope_arm(ast::arm);\n+    scope_self(ast::node_id);\n }\n \n type scopes = list<scope>;\n@@ -437,6 +438,9 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n         v.visit_local(decl, new_sc, v);\n         v.visit_block(blk, new_sc, v);\n       }\n+      ast::expr_anon_obj(_) {\n+        visit::visit_expr(x, cons(scope_self(x.id), @sc), v);\n+      }\n       _ { visit::visit_expr(x, sc, v); }\n     }\n }\n@@ -723,7 +727,10 @@ fn def_is_local(d: def) -> bool {\n }\n \n fn def_is_obj_field(d: def) -> bool {\n-    ret alt d { ast::def_obj_field(_, _) { true } _ { false } };\n+    alt d {\n+      ast::def_obj_field(_, _) | ast::def_self(_) { true }\n+      _ { false }\n+    }\n }\n \n fn def_is_ty_arg(d: def) -> bool {\n@@ -741,7 +748,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n           scope_item(it) {\n             alt it.node {\n               ast::item_obj(ob, ty_params, _) {\n-                ret lookup_in_obj(name, ob, ty_params, ns);\n+                ret lookup_in_obj(name, ob, ty_params, ns, it.id);\n               }\n               ast::item_impl(_, _, _) {\n                 if (name == \"self\" && ns == ns_value) {\n@@ -763,6 +770,11 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               _ { }\n             }\n           }\n+          scope_self(id) {\n+            if (name == \"self\" && ns == ns_value) {\n+                ret some(ast::def_self(local_def(id)));\n+            }\n+          }\n           scope_native_item(it) {\n             alt it.node {\n               ast::native_item_fn(decl, ty_params) {\n@@ -881,9 +893,10 @@ fn lookup_in_fn(name: ident, decl: ast::fn_decl, ty_params: [ast::ty_param],\n }\n \n fn lookup_in_obj(name: ident, ob: ast::_obj, ty_params: [ast::ty_param],\n-                 ns: namespace) -> option::t<def> {\n+                 ns: namespace, id: node_id) -> option::t<def> {\n     alt ns {\n       ns_value. {\n+        if name == \"self\" { ret some(ast::def_self(local_def(id))); }\n         for f: ast::obj_field in ob.fields {\n             if str::eq(f.ident, name) {\n                 ret some(ast::def_obj_field(local_def(f.id), f.mut));\n@@ -1295,23 +1308,17 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n \n // External lookups\n fn ns_for_def(d: def) -> namespace {\n-    ret alt d {\n-          ast::def_fn(_, _) { ns_value }\n-          ast::def_obj_field(_, _) { ns_value }\n-          ast::def_mod(_) { ns_module }\n-          ast::def_native_mod(_) { ns_module }\n-          ast::def_const(_) { ns_value }\n-          ast::def_arg(_, _) { ns_value }\n-          ast::def_local(_, _) { ns_value }\n-          ast::def_upvar(_, _, _) { ns_value }\n-          ast::def_variant(_, _) { ns_value }\n-          ast::def_ty(_) { ns_type }\n-          ast::def_binding(_) { ns_type }\n-          ast::def_use(_) { ns_module }\n-          ast::def_native_ty(_) { ns_type }\n-          ast::def_native_fn(_, _) { ns_value }\n-          ast::def_self(_) { ns_value }\n-        };\n+    alt d {\n+      ast::def_fn(_, _) | ast::def_obj_field(_, _) | ast::def_self(_) |\n+      ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n+      ast::def_upvar(_, _, _) | ast::def_variant(_, _) |\n+      ast::def_native_fn(_, _) | ast::def_self(_) { ns_value }\n+\n+      ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n+\n+      ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n+      ast::def_native_ty(_) { ns_type }\n+    }\n }\n \n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->"}, {"sha": "2c724ba8fca7a77d07e765445ece55cf83784568", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -2678,7 +2678,9 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n         ret { val: cx.fcx.llobjfields.get(did.node), kind: owned };\n       }\n       ast::def_self(did) {\n-        ret lval_owned(cx, cx.fcx.llenv);\n+        let slf = option::get(cx.fcx.llself);\n+        let ptr = PointerCast(cx, slf.v, T_ptr(type_of_or_i8(cx, slf.t)));\n+        ret {val: ptr, kind: owned};\n       }\n       _ {\n         bcx_ccx(cx).sess.span_unimpl\n@@ -2832,21 +2834,29 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     ret lval_owned(next_cx, elt);\n }\n \n+fn expr_is_lval(bcx: @block_ctxt, e: @ast::expr) -> bool {\n+    let ccx = bcx_ccx(bcx);\n+    ty::expr_is_lval(ccx.method_map, ccx.tcx, e)\n+}\n+\n // This is for impl methods, not obj methods.\n fn trans_method_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n                        did: ast::def_id) -> lval_maybe_callee {\n-    let bcx = trans_expr(bcx, base, ignore); // FIXME pass self\n-    lval_static_fn(bcx, did, e.id)\n+    let tz = [], tr = [];\n+    let basety = ty::expr_ty(bcx_tcx(bcx), base);\n+    let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n+                                    type_of_or_i8(bcx, basety), tz, tr, base);\n+    let val = PointerCast(bcx, val, T_opaque_boxed_closure_ptr(bcx_ccx(bcx)));\n+    {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n }\n \n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n       ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n       ast::expr_field(base, ident) {\n-        let method_map = bcx_ccx(bcx).method_map;\n         // Lval means this is a record field, so not a method\n-        if !ty::expr_is_lval(method_map, bcx_tcx(bcx), e) {\n-            alt method_map.find(e.id) {\n+        if !expr_is_lval(bcx, e) {\n+            alt bcx_ccx(bcx).method_map.find(e.id) {\n               some(did) { // An impl method\n                 ret trans_method_callee(bcx, e, base, did);\n               }\n@@ -2858,15 +2868,6 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n             }\n         }\n       }\n-      ast::expr_self_method(ident) {\n-        alt bcx.fcx.llself {\n-          some(pair) {\n-            let fld = trans_object_field_inner(bcx, pair.v, ident, pair.t);\n-            ret {bcx: fld.bcx, val: fld.mthptr, kind: owned,\n-                 env: obj_env(fld.objptr), generic: none};\n-          }\n-        }\n-      }\n       _ {}\n     }\n     let lv = trans_temp_lval(bcx, e);\n@@ -3475,7 +3476,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     let bcx = bcx;\n-    if ty::expr_is_lval(bcx_ccx(bcx).method_map, bcx_tcx(bcx), e) {\n+    if expr_is_lval(bcx, e) {\n         ret trans_lval(bcx, e);\n     } else {\n         let tcx = bcx_tcx(bcx);\n@@ -3513,7 +3514,7 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n-    if ty::expr_is_lval(bcx_ccx(bcx).method_map, tcx, e) {\n+    if expr_is_lval(bcx, e) {\n         ret lval_to_dps(bcx, e, dest);\n     }\n \n@@ -3555,7 +3556,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_closure::trans_bind(bcx, f, args, e.id, dest);\n       }\n       ast::expr_copy(a) {\n-        if !ty::expr_is_lval(bcx_ccx(bcx).method_map, tcx, a) {\n+        if !expr_is_lval(bcx, a) {\n             ret trans_expr(bcx, a, dest);\n         }\n         else { ret lval_to_dps(bcx, a, dest); }\n@@ -3957,9 +3958,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let bcx = bcx;\n     alt local.node.init {\n       some(init) {\n-        if init.op == ast::init_assign ||\n-           !ty::expr_is_lval(bcx_ccx(bcx).method_map, bcx_tcx(bcx),\n-                             init.expr) {\n+        if init.op == ast::init_assign || !expr_is_lval(bcx, init.expr) {\n             bcx = trans_expr_save_in(bcx, init.expr, llptr);\n         } else { // This is a move from an lval, must perform an actual move\n             let sub = trans_lval(bcx, init.expr);\n@@ -4347,15 +4346,15 @@ fn new_fn_ctxt(cx: @local_ctxt, sp: span, llfndecl: ValueRef) -> @fn_ctxt {\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: option::t<ty::t>,\n+fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n                              args: [ast::arg], ty_params: [ast::ty_param]) {\n     // Skip the implicit arguments 0, and 1.  TODO: Pull out 2u and define\n     // it as a constant, since we're using it in several places in trans this\n     // way.\n     let arg_n = 2u;\n     alt ty_self {\n-      some(tt) { cx.llself = some::<val_self_pair>({v: cx.llenv, t: tt}); }\n-      none. {\n+      obj_self(tt) | impl_self(tt) { cx.llself = some({v: cx.llenv, t: tt}); }\n+      no_self. {\n         let i = 0u;\n         for tp: ast::ty_param in ty_params {\n             let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n@@ -4473,19 +4472,23 @@ fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n     RetVoid(ret_cx);\n }\n \n+tag self_arg { obj_self(ty::t); impl_self(ty::t); no_self; }\n+\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n-                 ty_self: option::t<ty::t>, ty_params: [ast::ty_param],\n+                 ty_self: self_arg, ty_params: [ast::ty_param],\n                  id: ast::node_id, maybe_load_env: block(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(cx, sp, llfndecl, id, f.decl.cf);\n     create_llargs_for_fn_args(fcx, ty_self, f.decl.inputs, ty_params);\n-    alt fcx.llself {\n-      some(llself) { populate_fn_ctxt_from_llself(fcx, llself); }\n+    alt ty_self {\n+      obj_self(_) {\n+          populate_fn_ctxt_from_llself(fcx, option::get(fcx.llself));\n+      }\n       _ { }\n     }\n \n@@ -4526,7 +4529,7 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n-            ty_self: option::t<ty::t>, ty_params: [ast::ty_param],\n+            ty_self: self_arg, ty_params: [ast::ty_param],\n             id: ast::node_id) {\n     let do_time = cx.ccx.sess.get_opts().stats;\n     let start = do_time ? time::get_time() : {sec: 0u32, usec: 0u32};\n@@ -4549,7 +4552,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n-    create_llargs_for_fn_args(fcx, none, dtor.decl.inputs, ty_params);\n+    create_llargs_for_fn_args(fcx, no_self, dtor.decl.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     let arg_t = arg_tys_of_fn(ccx, ctor_id)[0].ty;\n@@ -4608,7 +4611,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n       }\n     }\n     let fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n-    create_llargs_for_fn_args(fcx, none, fn_args, ty_params);\n+    create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n     for tp: ast::ty_param in ty_params {\n@@ -4655,13 +4658,15 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method]) {\n+fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n+              id: ast::node_id) {\n     let sub_cx = extend_path(cx, name);\n     for m in methods {\n         alt cx.ccx.item_ids.find(m.node.id) {\n-          some(llfndecl) {\n+          some(llfn) {\n             trans_fn(extend_path(sub_cx, m.node.ident), m.span, m.node.meth,\n-                     llfndecl, none, [], m.node.id);\n+                     llfn, impl_self(ty::node_id_to_monotype(cx.ccx.tcx, id)),\n+                     [], m.node.id);\n           }\n         }\n     }\n@@ -4961,7 +4966,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n         let sub_cx = extend_path(cx, item.ident);\n         alt cx.ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n-            trans_fn(sub_cx, item.span, f, llfndecl, none, tps, item.id);\n+            trans_fn(sub_cx, item.span, f, llfndecl, no_self, tps, item.id);\n           }\n           _ {\n             cx.ccx.sess.span_fatal(item.span,\n@@ -4975,14 +4980,14 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(_, _, ms) { trans_impl(cx, item.ident, ms); }\n+      ast::item_impl(_, _, ms) { trans_impl(cx, item.ident, ms, item.id); }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n         trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n \n         // Create a function for the destructor\n         alt cx.ccx.item_ids.find(item.id) {\n           some(lldtor_decl) {\n-            trans_fn(cx, item.span, dtor, lldtor_decl, none, tps, dtor_id);\n+            trans_fn(cx, item.span, dtor, lldtor_decl, no_self, tps, dtor_id);\n           }\n           _ {\n             cx.ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");"}, {"sha": "d3a905d70df278f8801fcb0dbcd624464c918812", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -339,7 +339,7 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n     let trans_closure_env = lambda(ck: ty::closure_kind) -> ValueRef {\n         let upvars = get_freevars(ccx.tcx, id);\n         let {llbox, box_ty, bcx} = build_closure(bcx, upvars, ck);\n-        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n+        trans_closure(sub_cx, sp, f, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, box_ty, upvars, ck);\n         });\n         llbox\n@@ -351,7 +351,7 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n       ast::proto_send. { trans_closure_env(ty::closure_send) }\n       ast::proto_bare. {\n         let closure = C_null(T_opaque_boxed_closure_ptr(ccx));\n-        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n+        trans_closure(sub_cx, sp, f, llfn, no_self, [], id, {|_fcx|});\n         closure\n       }\n     };"}, {"sha": "d6ede4eba313bcc0a3abacfe336b2d535dfb29d9", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -52,7 +52,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n     let lltop = bcx.llbb;\n \n     // Both regular arguments and type parameters are handled here.\n-    create_llargs_for_fn_args(fcx, none::<ty::t>, fn_args, ty_params);\n+    create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n@@ -893,7 +893,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     // method's definition will be in the executable.\n     ccx.item_ids.insert(m.node.id, llfn);\n     ccx.item_symbols.insert(m.node.id, s);\n-    trans_fn(mcx, m.span, m.node.meth, llfn, some(self_ty), ty_params,\n+    trans_fn(mcx, m.span, m.node.meth, llfn, obj_self(self_ty), ty_params,\n              m.node.id);\n \n     ret llfn;"}, {"sha": "384353c2800b2b52b132a548cbbe09e9439aa4d0", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -335,7 +335,6 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         clear_pp(rslt);\n         handle_var(fcx, rslt, e.id, path_to_ident(fcx.ccx.tcx, p));\n       }\n-      expr_self_method(v) { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_log(_, arg) {\n         find_pre_post_expr(fcx, arg);\n         copy_pre_post(fcx.ccx, e.id, arg);"}, {"sha": "db020ec1bb07a23926c94e3af5e503e7394994b3", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -592,7 +592,6 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_break. { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_cont. { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_self_method(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_anon_obj(anon_obj) {\n         alt anon_obj.inner_obj {\n           some(wt) { ret find_pre_post_state_sub(fcx, pres, wt, e.id, none); }"}, {"sha": "8c413376f14665e98124deb62d597418a8ba8289", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -90,6 +90,7 @@ export mk_uint;\n export mk_uniq;\n export mk_var;\n export mk_opaque_closure;\n+export gen_ty;\n export mode;\n export mt;\n export node_type_table;"}, {"sha": "d697421bde4653f071e97f2262ca6542a1ce6fa5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 45, "deletions": 101, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -8,7 +8,7 @@ import util::common::*;\n import syntax::codemap::span;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, bind_params_in_type, block_ty,\n-                    expr_ty, field, node_type_table,\n+                    expr_ty, field, node_type_table, mk_nil,\n                     ty_param_substs_opt_and_ty, ty_param_kinds_and_ty};\n import util::ppaux::ty_to_str;\n import middle::ty::unify::{ures_ok, ures_err, fix_ok, fix_err};\n@@ -25,17 +25,12 @@ type method_map = hashmap<ast::node_id, ast::def_id>;\n type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an object.\n-tag obj_info {\n-\n-    // Regular objects have a node_id at compile time.\n-    regular_obj([ast::obj_field], ast::node_id);\n-\n-    // Anonymous objects only have a type at compile time.  It's optional\n-    // because not all anonymous objects have a inner_obj to attach to.\n-    anon_obj([ast::obj_field], option::t<ty::sty>);\n+tag self_info {\n+    self_obj([ast::obj_field], ty::t);\n+    self_impl(ty::t);\n }\n \n-type crate_ctxt = {mutable obj_infos: [obj_info],\n+type crate_ctxt = {mutable self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n                    method_map: method_map,\n                    tcx: ty::ctxt};\n@@ -93,7 +88,13 @@ fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n         ret {kinds: [], ty: typ};\n       }\n-      ast::def_self(id) { fail \"FIXME[impl]\"; }\n+      ast::def_self(id) {\n+        alt get_self_info(fcx.ccx) {\n+          some(self_obj(_, obj_t)) | some(self_impl(obj_t)) {\n+            ret {kinds: [], ty: obj_t};\n+          }\n+        }\n+      }\n       ast::def_fn(id, _) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n       ast::def_native_fn(id, _) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n       ast::def_const(id) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n@@ -696,14 +697,16 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, local_def(it.id), variants, ty_params);\n           }\n-          ast::item_impl(_, _, ms) {\n+          ast::item_impl(_, selfty, ms) {\n             for m in ms {\n                 let ty = ty::method_ty_to_fn_ty(\n                     cx.tcx, ty_of_method(cx.tcx, m_collect, m));\n                 cx.tcx.tcache.insert(local_def(m.node.id),\n                                      {kinds: [], ty: ty});\n                 write::ty_only(cx.tcx, m.node.id, ty);\n             }\n+            write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n+                                                       selfty));\n           }\n           ast::item_obj(object, ty_params, ctor_id) {\n             // Now we need to call ty_of_obj_ctor(); this is the type that\n@@ -1115,19 +1118,13 @@ fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n         };\n \n     // Add object fields, if any.\n-    let obj_fields = [];\n-    alt get_obj_info(ccx) {\n-      some(oinfo) {\n-        alt oinfo {\n-          regular_obj(ofs, _) { obj_fields = ofs; }\n-          anon_obj(ofs, _) { obj_fields = ofs; }\n+    alt get_self_info(ccx) {\n+      some(self_obj(ofs, _)) {\n+        for f in ofs {\n+            assign(f.id, some(ty::node_id_to_type(ccx.tcx, f.id)));\n         }\n       }\n-      none. {/* no fields */ }\n-    }\n-    for f: ast::obj_field in obj_fields {\n-        let field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n-        assign(f.id, some(field_ty));\n+      _ {}\n     }\n \n     // Add formal parameters.\n@@ -1992,60 +1989,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_call(f, args, _) {\n         bot = check_call_full(fcx, expr.span, f, args, expr.id);\n       }\n-      ast::expr_self_method(ident) {\n-        let t = ty::mk_nil(tcx);\n-        let this_obj_sty: option::t<ty::sty> =\n-            some(structure_of(fcx, expr.span, ty::mk_nil(tcx)));\n-        let this_obj_info: option::t<obj_info> = get_obj_info(fcx.ccx);\n-        alt this_obj_info {\n-          some(oinfo) {\n-            alt oinfo {\n-              regular_obj(_, obj_id) {\n-                let did = local_def(obj_id);\n-\n-                // Try looking up the current object in the type\n-                // cache.\n-                alt tcx.tcache.find(did) {\n-                  some(tpt) {\n-                    // If we're typechecking a self-method on\n-                    // a regular object, this lookup should\n-                    // succeed.\n-                    this_obj_sty = some(structure_of(fcx, expr.span, tpt.ty));\n-                  }\n-                  none. {\n-                    tcx.sess.bug(\"didn't find \" + int::str(did.node) +\n-                                     \" in type cache\");\n-                  }\n-                }\n-              }\n-              anon_obj(_, obj_sty) { this_obj_sty = obj_sty; }\n-            }\n-          }\n-          none. {\n-            // Shouldn't happen.\n-            tcx.sess.span_err(expr.span, \"self-call in non-object context\");\n-          }\n-        }\n-\n-        // Grab this method's type out of the current object type.\n-        alt this_obj_sty {\n-          some(sty) {\n-            alt sty {\n-              ty::ty_obj(methods) {\n-                for method: ty::method in methods {\n-                    if method.ident == ident {\n-                        t = ty::method_ty_to_fn_ty(tcx, method);\n-                    }\n-                }\n-              }\n-              _ { fail; }\n-            }\n-          }\n-          none. { }\n-        }\n-        write::ty_only_fixup(fcx, id, t);\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n-      }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n@@ -2172,15 +2115,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n             result\n         }\n+\n         bot |= check_expr(fcx, base);\n         let base_t = expr_ty(tcx, base);\n         let iscope = fcx.ccx.impl_map.get(expr.id);\n         alt lookup_method(fcx, iscope, field, base_t) {\n           some(method) {\n             let mt = ty_of_method(fcx.ccx.tcx, m_check, method);\n-            let f_ty = ty::mk_fn(fcx.ccx.tcx, mt.proto, mt.inputs,\n-                                 mt.output, mt.cf, mt.constrs);\n-            write::ty_only_fixup(fcx, id, f_ty);\n+            let fty = ty::mk_fn(fcx.ccx.tcx, mt.proto, mt.inputs,\n+                                mt.output, mt.cf, mt.constrs);\n+            write::ty_only_fixup(fcx, id, fty);\n             fcx.ccx.method_map.insert(id, local_def(method.node.id));\n           }\n           _ {\n@@ -2255,15 +2199,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             // Typecheck 'inner_obj'.  If it exists, it had better have object\n             // type.\n             let inner_obj_methods: [ty::method] = [];\n-            let inner_obj_ty: ty::t = ty::mk_nil(tcx);\n             let inner_obj_sty: option::t<ty::sty> = none;\n             alt ao.inner_obj {\n               none. { }\n               some(e) {\n-                // If there's a inner_obj, we push it onto the obj_infos stack\n-                // so that self-calls can be checked within its context later.\n+                // If there's a inner_obj, we push it onto the self_infos\n+                // stack so that self-calls can be checked within its context\n+                // later.\n                 bot |= check_expr(fcx, e);\n-                inner_obj_ty = expr_ty(tcx, e);\n+                let inner_obj_ty = expr_ty(tcx, e);\n                 inner_obj_sty = some(structure_of(fcx, e.span, inner_obj_ty));\n \n                 alt inner_obj_sty {\n@@ -2283,10 +2227,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               }\n             }\n \n-            fcx.ccx.obj_infos +=\n-                [anon_obj(vec::map(ast_util::obj_field_from_anon_obj_field,\n-                                   fields), inner_obj_sty)];\n-\n             // Whenever an outer method overrides an inner, we need to remove\n             // that inner from the type.  Filter inner_obj_methods to remove\n             // any methods that share a name with an outer method.\n@@ -2311,9 +2251,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n \n             let f = bind filtering_fn(fcx.ccx, _, ao.methods);\n-            inner_obj_methods =\n-                vec::filter_map::<ty::method,\n-                                       ty::method>(f, inner_obj_methods);\n+            inner_obj_methods = vec::filter_map(f, inner_obj_methods);\n \n             method_types += inner_obj_methods;\n         }\n@@ -2325,19 +2263,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // Write the methods into the node type table.  (This happens in\n         // collect::convert for regular objects.)\n         let i = 0u;\n-        while i < vec::len::<@ast::method>(ao.methods) {\n+        while i < vec::len(ao.methods) {\n             write::ty_only(tcx, ao.methods[i].node.id,\n                            ty::method_ty_to_fn_ty(tcx, method_types[i]));\n             i += 1u;\n         }\n \n+        fcx.ccx.self_infos +=\n+            [self_obj(vec::map(ast_util::obj_field_from_anon_obj_field,\n+                               fields), ot)];\n         // Typecheck the methods.\n         for method: @ast::method in ao.methods {\n             check_method(fcx.ccx, method);\n         }\n \n         // Now remove the info from the stack.\n-        vec::pop::<obj_info>(fcx.ccx.obj_infos);\n+        vec::pop(fcx.ccx.self_infos);\n       }\n       _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n@@ -2357,8 +2298,8 @@ fn next_ty_var(fcx: @fn_ctxt) -> ty::t {\n     ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n }\n \n-fn get_obj_info(ccx: @crate_ctxt) -> option::t<obj_info> {\n-    ret vec::last::<obj_info>(ccx.obj_infos);\n+fn get_self_info(ccx: @crate_ctxt) -> option::t<self_info> {\n+    ret vec::last(ccx.self_infos);\n }\n \n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n@@ -2639,13 +2580,18 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_res(f, dtor_id, _, _) { check_fn(ccx, f, dtor_id, none); }\n       ast::item_obj(ob, _, _) {\n         // We're entering an object, so gather up the info we need.\n-        ccx.obj_infos += [regular_obj(ob.fields, it.id)];\n+        ccx.self_infos += [self_obj(ob.fields,\n+                                    ccx.tcx.tcache.get(local_def(it.id)).ty)];\n         // Typecheck the methods.\n         for method: @ast::method in ob.methods { check_method(ccx, method); }\n         // Now remove the info from the stack.\n-        vec::pop::<obj_info>(ccx.obj_infos);\n+        vec::pop(ccx.self_infos);\n+      }\n+      ast::item_impl(_, ty, ms) {\n+        ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n+        for m in ms { check_method(ccx, m); }\n+        vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(_, _, ms) { for m in ms { check_method(ccx, m); } }\n       _ {/* nothing to do */ }\n     }\n }\n@@ -2701,9 +2647,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                crate: @ast::crate) -> method_map {\n     collect::collect_item_types(tcx, crate);\n \n-    let obj_infos: [obj_info] = [];\n-\n-    let ccx = @{mutable obj_infos: obj_infos,\n+    let ccx = @{mutable self_infos: [],\n                 impl_map: impl_map,\n                 method_map: std::map::new_int_hash(),\n                 tcx: tcx};"}, {"sha": "8fb6d41c0a8aef6d893b1dcc252844dd98b58bb4", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -28,13 +28,13 @@ type ty_param = {ident: ident, kind: kind};\n tag def {\n     def_fn(def_id, purity);\n     def_obj_field(def_id, mutability);\n+    def_self(def_id);\n     def_mod(def_id);\n     def_native_mod(def_id);\n     def_const(def_id);\n     def_arg(def_id, mode);\n     def_local(def_id, let_style);\n     def_variant(def_id /* tag */, def_id /* variant */);\n-    def_self(def_id);\n     def_ty(def_id);\n     def_ty_param(uint, kind);\n     def_binding(def_id);\n@@ -214,7 +214,6 @@ tag expr_ {\n     expr_rec([field], option::t<@expr>);\n     expr_call(@expr, [@expr], bool);\n     expr_tup([@expr]);\n-    expr_self_method(ident);\n     expr_bind(@expr, [option::t<@expr>]);\n     expr_binary(binop, @expr, @expr);\n     expr_unary(unop, @expr);"}, {"sha": "6bb95f0cfc04956dc300ea72aaa5bb46fd5dce91", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -353,7 +353,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args),\n                       blk)\n           }\n-          expr_self_method(id) { expr_self_method(fld.fold_ident(id)) }\n           expr_bind(f, args) {\n             let opt_map_se = bind option::map(fld.fold_expr, _);\n             expr_bind(fld.fold_expr(f), vec::map(opt_map_se, args))"}, {"sha": "94a7c3e01b2947491512fea627359008ebd0e3a9", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -155,8 +155,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"cont\", \"ret\", \"be\", \"fail\", \"type\", \"resource\", \"check\",\n                  \"assert\", \"claim\", \"native\", \"fn\", \"lambda\", \"pure\",\n                  \"unsafe\", \"block\", \"import\", \"export\", \"let\", \"const\",\n-                 \"log\", \"log_err\", \"tag\", \"obj\", \"self\", \"copy\", \"sendfn\",\n-                 \"impl\"] {\n+                 \"log\", \"log_err\", \"tag\", \"obj\", \"copy\", \"sendfn\", \"impl\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -942,15 +941,6 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n         hi = e.span.hi;\n-    } else if is_word(p, \"self\") && p.look_ahead(1u) == token::DOT {\n-        p.bump(); p.bump();\n-        // The rest is a call expression.\n-        let f: @ast::expr = parse_self_method(p);\n-        let es =\n-            parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n-                      parse_expr, p);\n-        hi = es.span.hi;\n-        ex = ast::expr_call(f, es.node, false);\n     } else if p.peek() == token::MOD_SEP ||\n                   is_ident(p.peek()) && !is_word(p, \"true\") &&\n                       !is_word(p, \"false\") {\n@@ -998,12 +988,6 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n     ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, e, none));\n }\n \n-fn parse_self_method(p: parser) -> @ast::expr {\n-    let sp = p.get_span();\n-    let f_name: ast::ident = parse_ident(p);\n-    ret mk_expr(p, sp.lo, sp.hi, ast::expr_self_method(f_name));\n-}\n-\n fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n     let b = parse_bottom_expr(p);\n     if expr_has_value(b) { parse_dot_or_call_expr_with(p, b) }"}, {"sha": "25ba7e082f3d91d9dff95679720392b57099af23", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -736,10 +736,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             print_expr(s, option::get(blk));\n         }\n       }\n-      ast::expr_self_method(ident) {\n-        word(s.s, \"self.\");\n-        print_ident(s, ident);\n-      }\n       ast::expr_bind(func, args) {\n         fn print_opt(s: ps, expr: option::t<@ast::expr>) {\n             alt expr {"}, {"sha": "c3e8c65b15a111540c1c08aa823f127854f42fca", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -251,7 +251,6 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         visit_exprs(args, e, v);\n         v.visit_expr(callee, e, v);\n       }\n-      expr_self_method(_) { }\n       expr_bind(callee, args) {\n         v.visit_expr(callee, e, v);\n         for eo: option::t<@expr> in args { visit_expr_opt(eo, e, v); }"}, {"sha": "8de59268482c0b0368836e2391d6a5268f840337", "filename": "src/test/compile-fail/self-call-non-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:self-call in non-object context\n+// error-pattern:unresolved name: self\n \n // Fix for issue #707.\n fn main() {"}, {"sha": "b9c7086f6e7bf5ff5c402b2e06b862e494d2de89", "filename": "src/test/compile-fail/self-missing-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efef989011307bb9bb1679c9022c17bffecd2f6/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs?ref=7efef989011307bb9bb1679c9022c17bffecd2f6", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:expecting ., found (\n+// error-pattern:attempted field access on type fn\n fn main() {\n \n   obj foo() {"}]}