{"sha": "4efc7e92fa29f550f0825f290c048a55515ce98f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZmM3ZTkyZmEyOWY1NTBmMDgyNWYyOTBjMDQ4YTU1NTE1Y2U5OGY=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-08T03:49:51Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-09T19:25:22Z"}, "message": "rustc_mir_build: use IndexMap in TestKind::SwitchInt", "tree": {"sha": "24ac3d996d4710746fc5730ac9d4a1a2f5abcbc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ac3d996d4710746fc5730ac9d4a1a2f5abcbc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4efc7e92fa29f550f0825f290c048a55515ce98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4efc7e92fa29f550f0825f290c048a55515ce98f", "html_url": "https://github.com/rust-lang/rust/commit/4efc7e92fa29f550f0825f290c048a55515ce98f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4efc7e92fa29f550f0825f290c048a55515ce98f/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c61f1c8bfa49cdaeb0ee8a8360e0d70a0fbd0b7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c61f1c8bfa49cdaeb0ee8a8360e0d70a0fbd0b7b", "html_url": "https://github.com/rust-lang/rust/commit/c61f1c8bfa49cdaeb0ee8a8360e0d70a0fbd0b7b"}], "stats": {"total": 40, "additions": 17, "deletions": 23}, "files": [{"sha": "5f87cb364b891de29159e869aed9739529ee79d7", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4efc7e92fa29f550f0825f290c048a55515ce98f/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efc7e92fa29f550f0825f290c048a55515ce98f/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=4efc7e92fa29f550f0825f290c048a55515ce98f", "patch": "@@ -11,7 +11,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::thir::{self, *};\n use rustc_data_structures::{\n-    fx::{FxHashMap, FxHashSet},\n+    fx::{FxHashSet, FxIndexMap},\n     stack::ensure_sufficient_stack,\n };\n use rustc_hir::HirId;\n@@ -817,9 +817,7 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: Vec<u128>,\n-        /// Reverse map used to ensure that the values in `options` are unique.\n-        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n@@ -1396,14 +1394,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+            TestKind::SwitchInt { switch_ty, ref mut options } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(\n                         &match_place,\n                         candidate,\n                         switch_ty,\n                         options,\n-                        indices,\n                     ) {\n                         break;\n                     }"}, {"sha": "87977d6fe8904e84a7996150c9ec992c82960e92", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4efc7e92fa29f550f0825f290c048a55515ce98f/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4efc7e92fa29f550f0825f290c048a55515ce98f/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=4efc7e92fa29f550f0825f290c048a55515ce98f", "patch": "@@ -9,7 +9,7 @@ use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n use crate::thir::*;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::RangeEnd;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n@@ -44,8 +44,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                         // these maps are empty to start; cases are\n                         // added below in add_cases_to_switch\n-                        options: vec![],\n-                        indices: Default::default(),\n+                        options: Default::default(),\n                     },\n                 }\n             }\n@@ -83,8 +82,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut Vec<u128>,\n-        indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> bool {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n             Some(match_pair) => match_pair,\n@@ -95,9 +93,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n-                indices.entry(value).or_insert_with(|| {\n-                    options.push(value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty));\n-                    options.len() - 1\n+                options.entry(value).or_insert_with(|| {\n+                    value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty)\n                 });\n                 true\n             }\n@@ -106,7 +103,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             PatKind::Range(range) => {\n                 // Check that none of the switch values are in the range.\n-                self.values_not_contained_in_range(range, indices).unwrap_or(false)\n+                self.values_not_contained_in_range(range, options).unwrap_or(false)\n             }\n             PatKind::Slice { .. }\n             | PatKind::Array { .. }\n@@ -216,7 +213,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n             }\n \n-            TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n+            TestKind::SwitchInt { switch_ty, ref options } => {\n                 let target_blocks = make_target_blocks(self);\n                 let terminator = if switch_ty.kind == ty::Bool {\n                     assert!(!options.is_empty() && options.len() <= 2);\n@@ -236,7 +233,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place),\n                         switch_ty,\n-                        values: options.clone().into(),\n+                        values: options.values().copied().collect(),\n                         targets: target_blocks,\n                     }\n                 };\n@@ -532,20 +529,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n             (\n-                &TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n+                &TestKind::SwitchInt { switch_ty: _, ref options },\n                 &PatKind::Constant { ref value },\n             ) if is_switch_ty(match_pair.pattern.ty) => {\n-                let index = indices[value];\n+                let index = options.get_index_of(value).unwrap();\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n             (\n-                &TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n+                &TestKind::SwitchInt { switch_ty: _, ref options },\n                 &PatKind::Range(range),\n             ) => {\n                 let not_contained =\n-                    self.values_not_contained_in_range(range, indices).unwrap_or(false);\n+                    self.values_not_contained_in_range(range, options).unwrap_or(false);\n \n                 if not_contained {\n                     // No switch values are contained in the pattern range,\n@@ -777,9 +774,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: &FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> Option<bool> {\n-        for &val in indices.keys() {\n+        for &val in options.keys() {\n             if self.const_range_contains(range, val)? {\n                 return Some(false);\n             }"}]}