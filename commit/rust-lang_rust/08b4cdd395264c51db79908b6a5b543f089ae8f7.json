{"sha": "08b4cdd395264c51db79908b6a5b543f089ae8f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YjRjZGQzOTUyNjRjNTFkYjc5OTA4YjZhNWI1NDNmMDg5YWU4Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T22:10:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T22:10:48Z"}, "message": "auto merge of #6499 : dotdash/rust/static_keywords, r=thestinger", "tree": {"sha": "cdaafac53c9ab1cfbac4d3647bc1f0b3ea9d4b57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdaafac53c9ab1cfbac4d3647bc1f0b3ea9d4b57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08b4cdd395264c51db79908b6a5b543f089ae8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08b4cdd395264c51db79908b6a5b543f089ae8f7", "html_url": "https://github.com/rust-lang/rust/commit/08b4cdd395264c51db79908b6a5b543f089ae8f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08b4cdd395264c51db79908b6a5b543f089ae8f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "html_url": "https://github.com/rust-lang/rust/commit/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff"}, {"sha": "109bb7c78ba64462a02c6a2653243e063113dcb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/109bb7c78ba64462a02c6a2653243e063113dcb6", "html_url": "https://github.com/rust-lang/rust/commit/109bb7c78ba64462a02c6a2653243e063113dcb6"}], "stats": {"total": 258, "additions": 131, "deletions": 127}, "files": [{"sha": "7418239f765b4584470c1ff52c6e591ee41aaa20", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=08b4cdd395264c51db79908b6a5b543f089ae8f7", "patch": "@@ -825,6 +825,10 @@ pub impl <T:Hash + Eq> HashSet<T> {\n     fn consume(&mut self, f: &fn(T)) {\n         self.map.consume(|k, _| f(k))\n     }\n+\n+    fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n+      self.map.contains_key_equiv(value)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "1bb4080814226716ef4ea6ff74472f18344c777d", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=08b4cdd395264c51db79908b6a5b543f089ae8f7", "patch": "@@ -34,9 +34,9 @@ pub fn expand_trace_macros(cx: @ext_ctxt,\n         rdr.dup()\n     );\n \n-    if rust_parser.is_keyword(&~\"true\") {\n+    if rust_parser.is_keyword(\"true\") {\n         cx.set_trace_macros(true);\n-    } else if rust_parser.is_keyword(&~\"false\") {\n+    } else if rust_parser.is_keyword(\"false\") {\n         cx.set_trace_macros(false);\n     } else {\n         cx.span_fatal(sp, ~\"trace_macros! only accepts `true` or `false`\")"}, {"sha": "6595343654f11405d12344e7e0dfe68ab9189e01", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=08b4cdd395264c51db79908b6a5b543f089ae8f7", "patch": "@@ -137,27 +137,27 @@ pub impl Parser {\n \n     // A sanity check that the word we are asking for is a known keyword\n     // NOTE: this could be done statically....\n-    fn require_keyword(&self, word: &~str) {\n-        if !self.keywords.contains(word) {\n-            self.bug(fmt!(\"unknown keyword: %s\", *word));\n+    fn require_keyword(&self, word: &str) {\n+        if !self.keywords.contains_equiv(&word) {\n+            self.bug(fmt!(\"unknown keyword: %s\", word));\n         }\n     }\n \n     // return true when this token represents the given string, and is not\n     // followed immediately by :: .\n-    fn token_is_word(&self, word: &~str, tok: &token::Token) -> bool {\n+    fn token_is_word(&self, word: &str, tok: &token::Token) -> bool {\n         match *tok {\n-            token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n+            token::IDENT(sid, false) => { word == *self.id_to_str(sid) }\n              _ => { false }\n         }\n     }\n \n-    fn token_is_keyword(&self, word: &~str, tok: &token::Token) -> bool {\n+    fn token_is_keyword(&self, word: &str, tok: &token::Token) -> bool {\n         self.require_keyword(word);\n         self.token_is_word(word, tok)\n     }\n \n-    fn is_keyword(&self, word: &~str) -> bool {\n+    fn is_keyword(&self, word: &str) -> bool {\n         self.token_is_keyword(word, &copy *self.token)\n     }\n \n@@ -177,10 +177,10 @@ pub impl Parser {\n     // if the given word is not a keyword, signal an error.\n     // if the next token is the given keyword, eat it and return\n     // true. Otherwise, return false.\n-    fn eat_keyword(&self, word: &~str) -> bool {\n+    fn eat_keyword(&self, word: &str) -> bool {\n         self.require_keyword(word);\n         let is_kw = match *self.token {\n-            token::IDENT(sid, false) => *word == *self.id_to_str(sid),\n+            token::IDENT(sid, false) => word == *self.id_to_str(sid),\n             _ => false\n         };\n         if is_kw { self.bump() }\n@@ -190,63 +190,63 @@ pub impl Parser {\n     // if the given word is not a keyword, signal an error.\n     // if the next token is not the given word, signal an error.\n     // otherwise, eat it.\n-    fn expect_keyword(&self, word: &~str) {\n+    fn expect_keyword(&self, word: &str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n             self.fatal(\n                 fmt!(\n                     \"expected `%s`, found `%s`\",\n-                    *word,\n+                    word,\n                     self.this_token_to_str()\n                 )\n             );\n         }\n     }\n \n     // return true if the given string is a strict keyword\n-    fn is_strict_keyword(&self, word: &~str) -> bool {\n-        self.strict_keywords.contains(word)\n+    fn is_strict_keyword(&self, word: &str) -> bool {\n+        self.strict_keywords.contains_equiv(&word)\n     }\n \n     // signal an error if the current token is a strict keyword\n     fn check_strict_keywords(&self) {\n         match *self.token {\n             token::IDENT(_, false) => {\n                 let w = token_to_str(self.reader, &copy *self.token);\n-                self.check_strict_keywords_(&w);\n+                self.check_strict_keywords_(w);\n             }\n             _ => ()\n         }\n     }\n \n     // signal an error if the given string is a strict keyword\n-    fn check_strict_keywords_(&self, w: &~str) {\n+    fn check_strict_keywords_(&self, w: &str) {\n         if self.is_strict_keyword(w) {\n             self.span_err(*self.last_span,\n-                          fmt!(\"found `%s` in ident position\", *w));\n+                          fmt!(\"found `%s` in ident position\", w));\n         }\n     }\n \n     // return true if this is a reserved keyword\n-    fn is_reserved_keyword(&self, word: &~str) -> bool {\n-        self.reserved_keywords.contains(word)\n+    fn is_reserved_keyword(&self, word: &str) -> bool {\n+        self.reserved_keywords.contains_equiv(&word)\n     }\n \n     // signal an error if the current token is a reserved keyword\n     fn check_reserved_keywords(&self) {\n         match *self.token {\n             token::IDENT(_, false) => {\n                 let w = token_to_str(self.reader, &copy *self.token);\n-                self.check_reserved_keywords_(&w);\n+                self.check_reserved_keywords_(w);\n             }\n             _ => ()\n         }\n     }\n \n     // signal an error if the given string is a reserved keyword\n-    fn check_reserved_keywords_(&self, w: &~str) {\n+    fn check_reserved_keywords_(&self, w: &str) {\n         if self.is_reserved_keyword(w) {\n-            self.fatal(fmt!(\"`%s` is a reserved keyword\", *w));\n+            self.fatal(fmt!(\"`%s` is a reserved keyword\", w));\n         }\n     }\n "}, {"sha": "859fde90e29984ebd97449f5976307bbb148922e", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=08b4cdd395264c51db79908b6a5b543f089ae8f7", "patch": "@@ -302,9 +302,9 @@ pub impl Parser {\n     }\n \n     fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool {\n-        if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n+        if self.is_keyword(\"priv\") && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n-            self.eat_keyword(&~\"priv\");\n+            self.eat_keyword(\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n                 self.parse_single_struct_field(ast::private, attrs.to_owned());"}, {"sha": "ce9bbe7e17a73892c993b723dc2724d9a351b690", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 102, "deletions": 102, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b4cdd395264c51db79908b6a5b543f089ae8f7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=08b4cdd395264c51db79908b6a5b543f089ae8f7", "patch": "@@ -338,10 +338,10 @@ pub impl Parser {\n \n     // is this one of the keywords that signals a closure type?\n     fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n-        self.token_is_keyword(&~\"pure\", tok) ||\n-            self.token_is_keyword(&~\"unsafe\", tok) ||\n-            self.token_is_keyword(&~\"once\", tok) ||\n-            self.token_is_keyword(&~\"fn\", tok)\n+        self.token_is_keyword(\"pure\", tok) ||\n+            self.token_is_keyword(\"unsafe\", tok) ||\n+            self.token_is_keyword(\"once\", tok) ||\n+            self.token_is_keyword(\"fn\", tok)\n     }\n \n     fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n@@ -378,7 +378,7 @@ pub impl Parser {\n         let opt_abis = self.parse_opt_abis();\n         let abis = opt_abis.get_or_default(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n-        self.expect_keyword(&~\"fn\");\n+        self.expect_keyword(\"fn\");\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n         return ty_bare_fn(@TyBareFn {\n             abis: abis,\n@@ -413,7 +413,7 @@ pub impl Parser {\n \n         let purity = self.parse_unsafety();\n         let onceness = parse_onceness(self);\n-        self.expect_keyword(&~\"fn\");\n+        self.expect_keyword(\"fn\");\n \n         if self.parse_fn_ty_sigil().is_some() {\n             self.obsolete(*self.span, ObsoletePostFnTySigil);\n@@ -431,7 +431,7 @@ pub impl Parser {\n         });\n \n         fn parse_onceness(this: &Parser) -> Onceness {\n-            if this.eat_keyword(&~\"once\") {\n+            if this.eat_keyword(~\"once\") {\n                 Once\n             } else {\n                 Many\n@@ -441,10 +441,10 @@ pub impl Parser {\n \n     // looks like this should be called parse_unsafety\n     fn parse_unsafety(&self) -> purity {\n-        if self.eat_keyword(&~\"pure\") {\n+        if self.eat_keyword(\"pure\") {\n             self.obsolete(*self.last_span, ObsoletePurity);\n             return impure_fn;\n-        } else if self.eat_keyword(&~\"unsafe\") {\n+        } else if self.eat_keyword(\"unsafe\") {\n             return unsafe_fn;\n         } else {\n             return impure_fn;\n@@ -699,7 +699,7 @@ pub impl Parser {\n             // BORROWED POINTER\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.eat_keyword(&~\"extern\") {\n+        } else if self.eat_keyword(\"extern\") {\n             // EXTERN FUNCTION\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword(&copy *self.token) {\n@@ -823,7 +823,7 @@ pub impl Parser {\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n             self.parse_arg_mode();\n-            is_mutbl = self.eat_keyword(&~\"mut\");\n+            is_mutbl = self.eat_keyword(\"mut\");\n             let pat = self.parse_pat(false);\n             self.expect(&token::COLON);\n             pat\n@@ -851,7 +851,7 @@ pub impl Parser {\n     // parse an argument in a lambda header e.g. |arg, arg|\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         self.parse_arg_mode();\n-        let is_mutbl = self.eat_keyword(&~\"mut\");\n+        let is_mutbl = self.eat_keyword(\"mut\");\n         let pat = self.parse_pat(false);\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n@@ -902,9 +902,9 @@ pub impl Parser {\n     // matches lit = true | false | token_lit\n     fn parse_lit(&self) -> lit {\n         let lo = self.span.lo;\n-        let lit = if self.eat_keyword(&~\"true\") {\n+        let lit = if self.eat_keyword(\"true\") {\n             lit_bool(true)\n-        } else if self.eat_keyword(&~\"false\") {\n+        } else if self.eat_keyword(\"false\") {\n             lit_bool(false)\n         } else {\n             // XXX: This is a really bad copy!\n@@ -1140,15 +1140,15 @@ pub impl Parser {\n     }\n \n     fn token_is_mutability(&self, tok: &token::Token) -> bool {\n-        self.token_is_keyword(&~\"mut\", tok) ||\n-        self.token_is_keyword(&~\"const\", tok)\n+        self.token_is_keyword(\"mut\", tok) ||\n+        self.token_is_keyword(\"const\", tok)\n     }\n \n     // parse mutability declaration (mut/const/imm)\n     fn parse_mutability(&self) -> mutability {\n-        if self.eat_keyword(&~\"mut\") {\n+        if self.eat_keyword(\"mut\") {\n             m_mutbl\n-        } else if self.eat_keyword(&~\"const\") {\n+        } else if self.eat_keyword(\"const\") {\n             m_const\n         } else {\n             m_imm\n@@ -1246,30 +1246,30 @@ pub impl Parser {\n                                  expr_block(blk));\n         } else if token::is_bar(&*self.token) {\n             return self.parse_lambda_expr();\n-        } else if self.eat_keyword(&~\"self\") {\n+        } else if self.eat_keyword(\"self\") {\n             ex = expr_self;\n             hi = self.span.hi;\n-        } else if self.eat_keyword(&~\"if\") {\n+        } else if self.eat_keyword(\"if\") {\n             return self.parse_if_expr();\n-        } else if self.eat_keyword(&~\"for\") {\n+        } else if self.eat_keyword(\"for\") {\n             return self.parse_sugary_call_expr(~\"for\", ForSugar,\n                                                expr_loop_body);\n-        } else if self.eat_keyword(&~\"do\") {\n+        } else if self.eat_keyword(\"do\") {\n             return self.parse_sugary_call_expr(~\"do\", DoSugar,\n                                                expr_do_body);\n-        } else if self.eat_keyword(&~\"while\") {\n+        } else if self.eat_keyword(\"while\") {\n             return self.parse_while_expr();\n         } else if self.token_is_lifetime(&*self.token) {\n             let lifetime = self.get_lifetime(&*self.token);\n             self.bump();\n             self.expect(&token::COLON);\n-            self.expect_keyword(&~\"loop\");\n+            self.expect_keyword(\"loop\");\n             return self.parse_loop_expr(Some(lifetime));\n-        } else if self.eat_keyword(&~\"loop\") {\n+        } else if self.eat_keyword(\"loop\") {\n             return self.parse_loop_expr(None);\n-        } else if self.eat_keyword(&~\"match\") {\n+        } else if self.eat_keyword(\"match\") {\n             return self.parse_match_expr();\n-        } else if self.eat_keyword(&~\"unsafe\") {\n+        } else if self.eat_keyword(\"unsafe\") {\n             return self.parse_block_expr(lo, unsafe_blk);\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n@@ -1309,7 +1309,7 @@ pub impl Parser {\n                 }\n             }\n             hi = self.span.hi;\n-        } else if self.eat_keyword(&~\"__log\") {\n+        } else if self.eat_keyword(\"__log\") {\n             // LOG expression\n             self.expect(&token::LPAREN);\n             let lvl = self.parse_expr();\n@@ -1318,14 +1318,14 @@ pub impl Parser {\n             ex = expr_log(lvl, e);\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n-        } else if self.eat_keyword(&~\"return\") {\n+        } else if self.eat_keyword(\"return\") {\n             // RETURN expression\n             if can_begin_expr(&*self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_ret(Some(e));\n             } else { ex = expr_ret(None); }\n-        } else if self.eat_keyword(&~\"break\") {\n+        } else if self.eat_keyword(\"break\") {\n             // BREAK expression\n             if self.token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n@@ -1335,14 +1335,14 @@ pub impl Parser {\n                 ex = expr_break(None);\n             }\n             hi = self.span.hi;\n-        } else if self.eat_keyword(&~\"copy\") {\n+        } else if self.eat_keyword(\"copy\") {\n             // COPY expression\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n         } else if *self.token == token::MOD_SEP ||\n-                is_ident(&*self.token) && !self.is_keyword(&~\"true\") &&\n-                !self.is_keyword(&~\"false\") {\n+                is_ident(&*self.token) && !self.is_keyword(\"true\") &&\n+                !self.is_keyword(\"false\") {\n             let pth = self.parse_path_with_tps(true);\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n@@ -1822,7 +1822,7 @@ pub impl Parser {\n                     }\n                 }\n                 None => {\n-                    if as_prec > min_prec && self.eat_keyword(&~\"as\") {\n+                    if as_prec > min_prec && self.eat_keyword(\"as\") {\n                         let rhs = self.parse_ty(true);\n                         let _as = self.mk_expr(lhs.span.lo,\n                                                rhs.span.hi,\n@@ -1896,7 +1896,7 @@ pub impl Parser {\n         let thn = self.parse_block();\n         let mut els: Option<@expr> = None;\n         let mut hi = thn.span.hi;\n-        if self.eat_keyword(&~\"else\") {\n+        if self.eat_keyword(\"else\") {\n             let elexpr = self.parse_else_expr();\n             els = Some(elexpr);\n             hi = elexpr.span.hi;\n@@ -1963,7 +1963,7 @@ pub impl Parser {\n     }\n \n     fn parse_else_expr(&self) -> @expr {\n-        if self.eat_keyword(&~\"if\") {\n+        if self.eat_keyword(\"if\") {\n             return self.parse_if_expr();\n         } else {\n             let blk = self.parse_block();\n@@ -2077,7 +2077,7 @@ pub impl Parser {\n     fn looking_at_record_literal(&self) -> bool {\n         let lookahead = self.look_ahead(1);\n         *self.token == token::LBRACE &&\n-            (self.token_is_keyword(&~\"mut\", &lookahead) ||\n+            (self.token_is_keyword(\"mut\", &lookahead) ||\n              (is_plain_ident(&lookahead) &&\n               self.look_ahead(2) == token::COLON))\n     }\n@@ -2090,7 +2090,7 @@ pub impl Parser {\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n-            if self.eat_keyword(&~\"if\") { guard = Some(self.parse_expr()); }\n+            if self.eat_keyword(\"if\") { guard = Some(self.parse_expr()); }\n             self.expect(&token::FAT_ARROW);\n             let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n@@ -2379,8 +2379,8 @@ pub impl Parser {\n           }\n           ref tok => {\n             if !is_ident_or_path(tok)\n-                || self.is_keyword(&~\"true\")\n-                || self.is_keyword(&~\"false\")\n+                || self.is_keyword(\"true\")\n+                || self.is_keyword(\"false\")\n             {\n                 // Parse an expression pattern or exp .. exp.\n                 //\n@@ -2399,11 +2399,11 @@ pub impl Parser {\n                 } else {\n                     pat = pat_lit(val);\n                 }\n-            } else if self.eat_keyword(&~\"ref\") {\n+            } else if self.eat_keyword(\"ref\") {\n                 // parse ref pat\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n-            } else if self.eat_keyword(&~\"copy\") {\n+            } else if self.eat_keyword(\"copy\") {\n                 // parse copy pat\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n@@ -2552,7 +2552,7 @@ pub impl Parser {\n \n     // parse a \"let\" stmt\n     fn parse_let(&self) -> @decl {\n-        let is_mutbl = self.eat_keyword(&~\"mut\");\n+        let is_mutbl = self.eat_keyword(\"mut\");\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl)];\n         while self.eat(&token::COMMA) {\n@@ -2566,7 +2566,7 @@ pub impl Parser {\n                          pr: visibility,\n                          attrs: ~[attribute]) -> @struct_field {\n         let lo = self.span.lo;\n-        if self.eat_keyword(&~\"mut\") {\n+        if self.eat_keyword(\"mut\") {\n             // Do nothing, for backwards compatibility.\n             // XXX: Remove after snapshot.\n         }\n@@ -2596,9 +2596,9 @@ pub impl Parser {\n         }\n \n         let lo = self.span.lo;\n-        if self.is_keyword(&~\"let\") {\n+        if self.is_keyword(\"let\") {\n             check_expected_item(self, first_item_attrs);\n-            self.expect_keyword(&~\"let\");\n+            self.expect_keyword(\"let\");\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(&*self.token)\n@@ -2685,7 +2685,7 @@ pub impl Parser {\n         maybe_whole!(self, nt_block);\n \n         let lo = self.span.lo;\n-        if self.eat_keyword(&~\"unsafe\") {\n+        if self.eat_keyword(\"unsafe\") {\n             self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n@@ -2700,7 +2700,7 @@ pub impl Parser {\n         maybe_whole!(pair_empty self, nt_block);\n \n         let lo = self.span.lo;\n-        if self.eat_keyword(&~\"unsafe\") {\n+        if self.eat_keyword(\"unsafe\") {\n             self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n@@ -2834,18 +2834,18 @@ pub impl Parser {\n     }\n \n     fn parse_optional_purity(&self) -> ast::purity {\n-        if self.eat_keyword(&~\"pure\") {\n+        if self.eat_keyword(\"pure\") {\n             self.obsolete(*self.last_span, ObsoletePurity);\n             ast::impure_fn\n-        } else if self.eat_keyword(&~\"unsafe\") {\n+        } else if self.eat_keyword(\"unsafe\") {\n             ast::unsafe_fn\n         } else {\n             ast::impure_fn\n         }\n     }\n \n     fn parse_optional_onceness(&self) -> ast::Onceness {\n-        if self.eat_keyword(&~\"once\") { ast::Once } else { ast::Many }\n+        if self.eat_keyword(\"once\") { ast::Once } else { ast::Many }\n     }\n \n     // matches optbounds = ( ( : ( boundseq )? )? )\n@@ -3008,10 +3008,10 @@ pub impl Parser {\n             p: &Parser\n         ) -> ast::explicit_self_ {\n             // We need to make sure it isn't a mode or a type\n-            if p.token_is_keyword(&~\"self\", &p.look_ahead(1)) ||\n-                ((p.token_is_keyword(&~\"const\", &p.look_ahead(1)) ||\n-                  p.token_is_keyword(&~\"mut\", &p.look_ahead(1))) &&\n-                 p.token_is_keyword(&~\"self\", &p.look_ahead(2))) {\n+            if p.token_is_keyword(\"self\", &p.look_ahead(1)) ||\n+                ((p.token_is_keyword(\"const\", &p.look_ahead(1)) ||\n+                  p.token_is_keyword(\"mut\", &p.look_ahead(1))) &&\n+                 p.token_is_keyword(\"self\", &p.look_ahead(2))) {\n \n                 p.bump();\n                 let mutability = p.parse_mutability();\n@@ -3032,25 +3032,25 @@ pub impl Parser {\n             //\n             // We already know that the current token is `&`.\n \n-            if (this.token_is_keyword(&~\"self\", &this.look_ahead(1))) {\n+            if (this.token_is_keyword(\"self\", &this.look_ahead(1))) {\n                 this.bump();\n                 this.expect_self_ident();\n                 sty_region(None, m_imm)\n             } else if (this.token_is_mutability(&this.look_ahead(1)) &&\n-                       this.token_is_keyword(&~\"self\", &this.look_ahead(2))) {\n+                       this.token_is_keyword(\"self\", &this.look_ahead(2))) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(None, mutability)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n-                       this.token_is_keyword(&~\"self\", &this.look_ahead(2))) {\n+                       this.token_is_keyword(\"self\", &this.look_ahead(2))) {\n                 this.bump();\n                 let lifetime = @this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        this.token_is_mutability(&this.look_ahead(2)) &&\n-                       this.token_is_keyword(&~\"self\", &this.look_ahead(3))) {\n+                       this.token_is_keyword(\"self\", &this.look_ahead(3))) {\n                 this.bump();\n                 let lifetime = @this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n@@ -3259,7 +3259,7 @@ pub impl Parser {\n         let mut ty = self.parse_ty(false);\n \n         // Parse traits, if necessary.\n-        let opt_trait = if could_be_trait && self.eat_keyword(&~\"for\") {\n+        let opt_trait = if could_be_trait && self.eat_keyword(\"for\") {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n                 ty_path(path, node_id) => {\n@@ -3434,11 +3434,11 @@ pub impl Parser {\n             return ~[];\n         }\n \n-        if self.eat_keyword(&~\"priv\") {\n+        if self.eat_keyword(\"priv\") {\n             return ~[self.parse_single_struct_field(private, attrs)]\n         }\n \n-        if self.eat_keyword(&~\"pub\") {\n+        if self.eat_keyword(\"pub\") {\n            return ~[self.parse_single_struct_field(public, attrs)];\n         }\n \n@@ -3451,13 +3451,13 @@ pub impl Parser {\n \n     // parse visiility: PUB, PRIV, or nothing\n     fn parse_visibility(&self) -> visibility {\n-        if self.eat_keyword(&~\"pub\") { public }\n-        else if self.eat_keyword(&~\"priv\") { private }\n+        if self.eat_keyword(\"pub\") { public }\n+        else if self.eat_keyword(\"priv\") { private }\n         else { inherited }\n     }\n \n     fn parse_staticness(&self) -> bool {\n-        if self.eat_keyword(&~\"static\") {\n+        if self.eat_keyword(\"static\") {\n             self.obsolete(*self.last_span, ObsoleteStaticMethod);\n             true\n         } else {\n@@ -3677,10 +3677,10 @@ pub impl Parser {\n         let lo = self.span.lo;\n \n         // XXX: Obsolete; remove after snap.\n-        if self.eat_keyword(&~\"const\") {\n+        if self.eat_keyword(\"const\") {\n             self.obsolete(*self.last_span, ObsoleteConstItem);\n         } else {\n-            self.expect_keyword(&~\"static\");\n+            self.expect_keyword(\"static\");\n         }\n \n         let ident = self.parse_ident();\n@@ -3698,14 +3698,14 @@ pub impl Parser {\n \n     // parse safe/unsafe and fn\n     fn parse_fn_purity(&self) -> purity {\n-        if self.eat_keyword(&~\"fn\") { impure_fn }\n-        else if self.eat_keyword(&~\"pure\") {\n+        if self.eat_keyword(\"fn\") { impure_fn }\n+        else if self.eat_keyword(\"pure\") {\n             self.obsolete(*self.last_span, ObsoletePurity);\n-            self.expect_keyword(&~\"fn\");\n+            self.expect_keyword(\"fn\");\n             // NB: We parse this as impure for bootstrapping purposes.\n             impure_fn\n-        } else if self.eat_keyword(&~\"unsafe\") {\n-            self.expect_keyword(&~\"fn\");\n+        } else if self.eat_keyword(\"unsafe\") {\n+            self.expect_keyword(\"fn\");\n             unsafe_fn\n         }\n         else { self.unexpected(); }\n@@ -3743,9 +3743,9 @@ pub impl Parser {\n                               items_allowed: bool)\n                               -> item_or_view_item {\n         let mut must_be_named_mod = false;\n-        if self.is_keyword(&~\"mod\") {\n+        if self.is_keyword(\"mod\") {\n             must_be_named_mod = true;\n-            self.expect_keyword(&~\"mod\");\n+            self.expect_keyword(\"mod\");\n         } else if *self.token != token::LBRACE {\n             self.span_fatal(\n                 copy *self.span,\n@@ -4030,7 +4030,7 @@ pub impl Parser {\n         let visibility = self.parse_visibility();\n \n         // must be a view item:\n-        if self.eat_keyword(&~\"use\") {\n+        if self.eat_keyword(\"use\") {\n             // USE ITEM (iovi_view_item)\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n@@ -4042,10 +4042,10 @@ pub impl Parser {\n             });\n         }\n         // either a view item or an item:\n-        if self.eat_keyword(&~\"extern\") {\n+        if self.eat_keyword(\"extern\") {\n             let opt_abis = self.parse_opt_abis();\n \n-            if self.eat_keyword(&~\"fn\") {\n+            if self.eat_keyword(\"fn\") {\n                 // EXTERN FUNCTION ITEM\n                 let abis = opt_abis.get_or_default(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n@@ -4061,11 +4061,11 @@ pub impl Parser {\n             }\n         }\n         // the rest are all guaranteed to be items:\n-        if (self.is_keyword(&~\"const\") ||\n-            (self.is_keyword(&~\"static\") &&\n-             !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n+        if (self.is_keyword(\"const\") ||\n+            (self.is_keyword(\"static\") &&\n+             !self.token_is_keyword(\"fn\", &self.look_ahead(1)))) {\n             // CONST / STATIC ITEM\n-            if self.is_keyword(&~\"const\") {\n+            if self.is_keyword(\"const\") {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n             }\n             self.bump();\n@@ -4074,7 +4074,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.is_keyword(&~\"fn\") &&\n+        if self.is_keyword(\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             // FUNCTION ITEM\n             self.bump();\n@@ -4084,65 +4084,65 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"pure\") {\n+        if self.eat_keyword(\"pure\") {\n             // PURE FUNCTION ITEM (obsolete)\n             self.obsolete(*self.last_span, ObsoletePurity);\n-            self.expect_keyword(&~\"fn\");\n+            self.expect_keyword(\"fn\");\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(impure_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.is_keyword(&~\"unsafe\")\n+        if self.is_keyword(\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n-            self.expect_keyword(&~\"fn\");\n+            self.expect_keyword(\"fn\");\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafe_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"mod\") {\n+        if self.eat_keyword(\"mod\") {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(/*bad*/ copy attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"type\") {\n+        if self.eat_keyword(\"type\") {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"enum\") {\n+        if self.eat_keyword(\"enum\") {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"trait\") {\n+        if self.eat_keyword(\"trait\") {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"impl\") {\n+        if self.eat_keyword(\"impl\") {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"struct\") {\n+        if self.eat_keyword(\"struct\") {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -4163,13 +4163,13 @@ pub impl Parser {\n \n         let visibility = self.parse_visibility();\n \n-        if (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n+        if (self.is_keyword(\"const\") || self.is_keyword(\"static\")) {\n             // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         }\n-        if (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n-             self.is_keyword(&~\"unsafe\")) {\n+        if (self.is_keyword(\"fn\") || self.is_keyword(\"pure\") ||\n+             self.is_keyword(\"unsafe\")) {\n             // FOREIGN FUNCTION ITEM\n                 let item = self.parse_item_foreign_fn(attrs);\n                 return iovi_foreign_item(item);\n@@ -4360,16 +4360,16 @@ pub impl Parser {\n \n     fn is_view_item(&self) -> bool {\n         let tok, next_tok;\n-        if !self.is_keyword(&~\"pub\") && !self.is_keyword(&~\"priv\") {\n+        if !self.is_keyword(\"pub\") && !self.is_keyword(\"priv\") {\n             tok = copy *self.token;\n             next_tok = self.look_ahead(1);\n         } else {\n             tok = self.look_ahead(1);\n             next_tok = self.look_ahead(2);\n         };\n-        self.token_is_keyword(&~\"use\", &tok)\n-            || (self.token_is_keyword(&~\"extern\", &tok) &&\n-                self.token_is_keyword(&~\"mod\", &next_tok))\n+        self.token_is_keyword(\"use\", &tok)\n+            || (self.token_is_keyword(\"extern\", &tok) &&\n+                self.token_is_keyword(\"mod\", &next_tok))\n     }\n \n     // parse a view item.\n@@ -4379,10 +4379,10 @@ pub impl Parser {\n         vis: visibility\n     ) -> @view_item {\n         let lo = self.span.lo;\n-        let node = if self.eat_keyword(&~\"use\") {\n+        let node = if self.eat_keyword(\"use\") {\n             self.parse_use()\n-        } else if self.eat_keyword(&~\"extern\") {\n-            self.expect_keyword(&~\"mod\");\n+        } else if self.eat_keyword(\"extern\") {\n+            self.expect_keyword(\"mod\");\n             let ident = self.parse_ident();\n             let metadata = self.parse_optional_meta();\n             view_item_extern_mod(ident, metadata, self.get_id())"}]}