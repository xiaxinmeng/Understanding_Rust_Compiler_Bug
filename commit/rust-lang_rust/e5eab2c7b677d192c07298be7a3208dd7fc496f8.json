{"sha": "e5eab2c7b677d192c07298be7a3208dd7fc496f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZWFiMmM3YjY3N2QxOTJjMDcyOThiZTdhMzIwOGRkN2ZjNDk2Zjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T11:21:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T11:21:40Z"}, "message": "auto merge of #11321 : huonw/rust/treemap-mut, r=alexcrichton\n\nThis requires a single `*mut` pointer to implement; I've justified its existence & correctness in the code.\r\n\r\nAlso, converts the mutable and immutable iterators to share code with some macro ~~madness~~ manipulation.", "tree": {"sha": "962690d195231005eaf05244f88534b1dea0f055", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/962690d195231005eaf05244f88534b1dea0f055"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5eab2c7b677d192c07298be7a3208dd7fc496f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5eab2c7b677d192c07298be7a3208dd7fc496f8", "html_url": "https://github.com/rust-lang/rust/commit/e5eab2c7b677d192c07298be7a3208dd7fc496f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5eab2c7b677d192c07298be7a3208dd7fc496f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e622becdc5fb4e07f95550c3a59fd909b97e5bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e622becdc5fb4e07f95550c3a59fd909b97e5bb", "html_url": "https://github.com/rust-lang/rust/commit/4e622becdc5fb4e07f95550c3a59fd909b97e5bb"}, {"sha": "a9a348f2fbb9f69d2378850de39797e516c5c77b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a348f2fbb9f69d2378850de39797e516c5c77b", "html_url": "https://github.com/rust-lang/rust/commit/a9a348f2fbb9f69d2378850de39797e516c5c77b"}], "stats": {"total": 498, "additions": 343, "deletions": 155}, "files": [{"sha": "f4fd81437fc6eaf4bad91ec78541d024564abfc5", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 343, "deletions": 155, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/e5eab2c7b677d192c07298be7a3208dd7fc496f8/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5eab2c7b677d192c07298be7a3208dd7fc496f8/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=e5eab2c7b677d192c07298be7a3208dd7fc496f8", "patch": "@@ -12,10 +12,10 @@\n //! trees. The only requirement for the types is that the key implements\n //! `TotalOrd`.\n \n-\n use std::util::{swap, replace};\n use std::iter::{Peekable};\n use std::cmp::Ordering;\n+use std::ptr;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -135,11 +135,6 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Iterate over the map and mutate the contained values\n-    pub fn mutate_values(&mut self, f: |&K, &mut V| -> bool) -> bool {\n-        mutate_values(&mut self.root, f)\n-    }\n-\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n@@ -157,8 +152,74 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n         TreeMapRevIterator{iter: self.iter()}\n     }\n \n+    /// Get a lazy forward iterator over the key-value pairs in the\n+    /// map, with the values being mutable.\n+    pub fn mut_iter<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n+        TreeMapMutIterator {\n+            stack: ~[],\n+            node: mut_deref(&mut self.root),\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n+    /// Get a lazy reverse iterator over the key-value pairs in the\n+    /// map, with the values being mutable.\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> TreeMapMutRevIterator<'a, K, V> {\n+        TreeMapMutRevIterator{iter: self.mut_iter()}\n+    }\n+\n+\n+    /// Get a lazy iterator that consumes the treemap.\n+    pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n+        let TreeMap { root: root, length: length } = self;\n+        let stk = match root {\n+            None => ~[],\n+            Some(~tn) => ~[tn]\n+        };\n+        TreeMapMoveIterator {\n+            stack: stk,\n+            remaining: length\n+        }\n+    }\n+}\n+\n+// range iterators.\n+\n+macro_rules! bound_setup {\n+    // initialiser of the iterator to manipulate\n+    ($iter:expr,\n+     // whether we are looking for the lower or upper bound.\n+     $is_lower_bound:expr) => {\n+        {\n+            let mut iter = $iter;\n+            loop {\n+                if !iter.node.is_null() {\n+                    let node_k = unsafe {&(*iter.node).key};\n+                    match k.cmp(node_k) {\n+                        Less => iter.traverse_left(),\n+                        Greater => iter.traverse_right(),\n+                        Equal => {\n+                            if $is_lower_bound {\n+                                iter.traverse_complete();\n+                                return iter;\n+                            } else {\n+                                iter.traverse_right()\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    iter.traverse_complete();\n+                    return iter;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Get a lazy iterator that should be initialized using\n-    /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n+    /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n         TreeMapIterator {\n             stack: ~[],\n@@ -171,175 +232,257 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n     pub fn lower_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n-        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n-        loop {\n-            match iter.node {\n-              Some(r) => {\n-                match k.cmp(&r.key) {\n-                  Less => iter_traverse_left(&mut iter),\n-                  Greater => iter_traverse_right(&mut iter),\n-                  Equal => {\n-                    iter_traverse_complete(&mut iter);\n-                    return iter;\n-                  }\n-                }\n-              }\n-              None => {\n-                iter_traverse_complete(&mut iter);\n-                return iter;\n-              }\n-            }\n-        }\n+        bound_setup!(self.iter_for_traversal(), true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are not greater than `k` an empty iterator is returned.\n     pub fn upper_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n-        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n-        loop {\n-            match iter.node {\n-              Some(r) => {\n-                match k.cmp(&r.key) {\n-                  Less => iter_traverse_left(&mut iter),\n-                  Greater => iter_traverse_right(&mut iter),\n-                  Equal => iter_traverse_right(&mut iter)\n-                }\n-              }\n-              None => {\n-                iter_traverse_complete(&mut iter);\n-                return iter;\n-              }\n-            }\n-        }\n+        bound_setup!(self.iter_for_traversal(), false)\n     }\n \n-    /// Get a lazy iterator that consumes the treemap.\n-    pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n-        let TreeMap { root: root, length: length } = self;\n-        let stk = match root {\n-            None => ~[],\n-            Some(~tn) => ~[tn]\n-        };\n-        TreeMapMoveIterator {\n-            stack: stk,\n-            remaining: length\n+    /// Get a lazy iterator that should be initialized using\n+    /// `traverse_left`/`traverse_right`/`traverse_complete`.\n+    fn mut_iter_for_traversal<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n+        TreeMapMutIterator {\n+            stack: ~[],\n+            node: mut_deref(&mut self.root),\n+            remaining_min: 0,\n+            remaining_max: self.length\n         }\n     }\n+\n+    /// Return a lazy value iterator to the first key-value pair (with\n+    /// the value being mutable) whose key is not less than `k`.\n+    ///\n+    /// If all keys in map are less than `k` an empty iterator is\n+    /// returned.\n+    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n+        bound_setup!(self.mut_iter_for_traversal(), true)\n+    }\n+\n+    /// Return a lazy iterator to the first key-value pair (with the\n+    /// value being mutable) whose key is greater than `k`.\n+    ///\n+    /// If all keys in map are not greater than `k` an empty iterator\n+    /// is returned.\n+    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n+        bound_setup!(self.mut_iter_for_traversal(), false)\n+    }\n }\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<'a, K, V> {\n     priv stack: ~[&'a TreeNode<K, V>],\n-    priv node: Option<&'a TreeNode<K, V>>,\n+    // See the comment on TreeMapMutIterator; this is just to allow\n+    // code-sharing (for this immutable-values iterator it *could* very\n+    // well be Option<&'a TreeNode<K,V>>).\n+    priv node: *TreeNode<K, V>,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n \n-fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> Option<&'a TreeNode<K, V>> {\n-    match *node {\n-        Some(ref n) => {\n-            let n: &TreeNode<K, V> = *n;\n-            Some(n)\n-        }\n-        None => None\n-    }\n+/// Lazy backward iterator over a map\n+pub struct TreeMapRevIterator<'a, K, V> {\n+    priv iter: TreeMapIterator<'a, K, V>,\n }\n \n-impl<'a, K, V> TreeMapIterator<'a, K, V> {\n-    #[inline(always)]\n-    fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a V)> {\n-        while !self.stack.is_empty() || self.node.is_some() {\n-            match self.node {\n-              Some(x) => {\n-                self.stack.push(x);\n-                self.node = deref(if forward { &x.left } else { &x.right });\n-              }\n-              None => {\n-                let res = self.stack.pop();\n-                self.node = deref(if forward { &res.right } else { &res.left });\n-                self.remaining_max -= 1;\n-                if self.remaining_min > 0 {\n-                    self.remaining_min -= 1;\n+/// Lazy forward iterator over a map that allows for the mutation of\n+/// the values.\n+pub struct TreeMapMutIterator<'a, K, V> {\n+    priv stack: ~[&'a mut TreeNode<K, V>],\n+    // Unfortunately, we require some unsafe-ness to get around the\n+    // fact that we would be storing a reference *into* one of the\n+    // nodes in the stack.\n+    //\n+    // As far as the compiler knows, this would let us invalidate the\n+    // reference by assigning a new value to this node's position in\n+    // its parent, which would cause this current one to be\n+    // deallocated so this reference would be invalid. (i.e. the\n+    // compilers complaints are 100% correct.)\n+    //\n+    // However, as far as you humans reading this code know (or are\n+    // about to know, if you haven't read far enough down yet), we are\n+    // only reading from the TreeNode.{left,right} fields. the only\n+    // thing that is ever mutated is the .value field (although any\n+    // actual mutation that happens is done externally, by the\n+    // iterator consumer). So, don't be so concerned, rustc, we've got\n+    // it under control.\n+    //\n+    // (This field can legitimately be null.)\n+    priv node: *mut TreeNode<K, V>,\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n+}\n+\n+/// Lazy backward iterator over a map\n+pub struct TreeMapMutRevIterator<'a, K, V> {\n+    priv iter: TreeMapMutIterator<'a, K, V>,\n+}\n+\n+\n+// FIXME #5846 we want to be able to choose between &x and &mut x\n+// (with many different `x`) below, so we need to optionally pass mut\n+// as a tt, but the only thing we can do with a `tt` is pass them to\n+// other macros, so this takes the `& <mutability> <operand>` token\n+// sequence and forces their evalutation as an expression.\n+macro_rules! addr { ($e:expr) => { $e }}\n+\n+macro_rules! define_iterator {\n+    ($name:ident,\n+     $rev_name:ident,\n+     // the type of the values of the treemap in the return value of\n+     // the iterator (i.e. &V or &mut V). This is non-hygienic in the\n+     // name of the lifetime.\n+     value_type = $value_type:ty,\n+\n+     // the function to go from &m Option<~TreeNode> to *m TreeNode\n+     deref = $deref:ident,\n+\n+     // see comment on `addr!`, this is just an optional `mut`, but\n+     // there's no support for 0-or-1 repeats.\n+     addr_mut = $($addr_mut:tt)*\n+     ) => {\n+        // private methods on the forward iterator\n+        impl<'a, K, V> $name<'a, K, V> {\n+            #[inline(always)]\n+            fn next_(&mut self, forward: bool) -> Option<(&'a K, $value_type)> {\n+                while !self.stack.is_empty() || !self.node.is_null() {\n+                    if !self.node.is_null() {\n+                        let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n+                        {\n+                            let next_node = if forward {\n+                                addr!(& $($addr_mut)* node.left)\n+                            } else {\n+                                addr!(& $($addr_mut)* node.right)\n+                            };\n+                            self.node = $deref(next_node);\n+                        }\n+                        self.stack.push(node);\n+                    } else {\n+                        let node = self.stack.pop();\n+                        let next_node = if forward {\n+                            addr!(& $($addr_mut)* node.right)\n+                        } else {\n+                            addr!(& $($addr_mut)* node.left)\n+                        };\n+                        self.node = $deref(next_node);\n+                        self.remaining_max -= 1;\n+                        if self.remaining_min > 0 {\n+                            self.remaining_min -= 1;\n+                        }\n+                        return Some((&node.key, addr!(& $($addr_mut)* node.value)));\n+                    }\n+                }\n+                None\n+            }\n+\n+            /// traverse_left, traverse_right and traverse_complete are\n+            /// used to initialize TreeMapIterator/TreeMapMutIterator\n+            /// pointing to element inside tree structure.\n+            ///\n+            /// They should be used in following manner:\n+            ///   - create iterator using TreeMap::[mut_]iter_for_traversal\n+            ///   - find required node using `traverse_left`/`traverse_right`\n+            ///     (current node is `TreeMapIterator::node` field)\n+            ///   - complete initialization with `traverse_complete`\n+            ///\n+            /// After this, iteration will start from `self.node`.  If\n+            /// `self.node` is None iteration will start from last\n+            /// node from which we traversed left.\n+            #[inline]\n+            fn traverse_left(&mut self) {\n+                let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n+                self.node = $deref(addr!(& $($addr_mut)* node.left));\n+                self.stack.push(node);\n+            }\n+\n+            #[inline]\n+            fn traverse_right(&mut self) {\n+                let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n+                self.node = $deref(addr!(& $($addr_mut)* node.right));\n+            }\n+\n+            #[inline]\n+            fn traverse_complete(&mut self) {\n+                if !self.node.is_null() {\n+                    unsafe {\n+                        self.stack.push(addr!(& $($addr_mut)* *self.node));\n+                    }\n+                    self.node = ptr::RawPtr::null();\n                 }\n-                return Some((&res.key, &res.value));\n-              }\n             }\n         }\n-        None\n-    }\n-}\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for TreeMapIterator<'a, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.next_(true)\n-    }\n+        // the forward Iterator impl.\n+        impl<'a, K, V> Iterator<(&'a K, $value_type)> for $name<'a, K, V> {\n+            /// Advance the iterator to the next node (in order) and return a\n+            /// tuple with a reference to the key and value. If there are no\n+            /// more nodes, return `None`.\n+            fn next(&mut self) -> Option<(&'a K, $value_type)> {\n+                self.next_(true)\n+            }\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining_min, Some(self.remaining_max))\n-    }\n-}\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                (self.remaining_min, Some(self.remaining_max))\n+            }\n+        }\n \n-/// Lazy backward iterator over a map\n-pub struct TreeMapRevIterator<'a, K, V> {\n-    priv iter: TreeMapIterator<'a, K, V>,\n-}\n+        // the reverse Iterator impl.\n+        impl<'a, K, V> Iterator<(&'a K, $value_type)> for $rev_name<'a, K, V> {\n+            fn next(&mut self) -> Option<(&'a K, $value_type)> {\n+                self.iter.next_(false)\n+            }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for TreeMapRevIterator<'a, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.iter.next_(false)\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.iter.size_hint()\n+            }\n+        }\n     }\n+} // end of define_iterator\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n+define_iterator! {\n+    TreeMapIterator,\n+    TreeMapRevIterator,\n+    value_type = &'a V,\n+    deref = deref,\n+\n+    // immutable, so no mut\n+    addr_mut =\n }\n+define_iterator! {\n+    TreeMapMutIterator,\n+    TreeMapMutRevIterator,\n+    value_type = &'a mut V,\n+    deref = mut_deref,\n \n-/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n-/// initialize TreeMapIterator pointing to element inside tree structure.\n-///\n-/// They should be used in following manner:\n-///   - create iterator using TreeMap::iter_for_traversal\n-///   - find required node using `iter_traverse_left`/`iter_traverse_right`\n-///     (current node is `TreeMapIterator::node` field)\n-///   - complete initialization with `iter_traverse_complete`\n-#[inline]\n-fn iter_traverse_left<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n-    let node = it.node.unwrap();\n-    it.stack.push(node);\n-    it.node = deref(&node.left);\n+    addr_mut = mut\n }\n \n-#[inline]\n-fn iter_traverse_right<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n-    it.node = deref(&it.node.get_ref().right);\n+fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> *TreeNode<K, V> {\n+    match *node {\n+        Some(ref n) => {\n+            let n: &TreeNode<K, V> = *n;\n+            n as *TreeNode<K, V>\n+        }\n+        None => ptr::null()\n+    }\n }\n \n-/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n-/// initialize TreeMapIterator pointing to element inside tree structure.\n-///\n-/// Completes traversal. Should be called before using iterator.\n-/// Iteration will start from `self.node`.\n-/// If `self.node` is None iteration will start from last node from which we\n-/// traversed left.\n-#[inline]\n-fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n-    match it.node {\n-        Some(n) => {\n-            it.stack.push(n);\n-            it.node = None;\n+fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n+    match *x {\n+        Some(ref mut n) => {\n+            let n: &mut TreeNode<K, V> = *n;\n+            n as *mut TreeNode<K, V>\n         }\n-        None => ()\n+        None => ptr::mut_null()\n     }\n }\n \n+\n+\n /// Lazy forward iterator over a map that consumes the map while iterating\n pub struct TreeMapMoveIterator<K, V> {\n     priv stack: ~[TreeNode<K, V>],\n@@ -678,24 +821,6 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-fn mutate_values<'r,\n-                 K:TotalOrd,\n-                 V>(\n-                 node: &'r mut Option<~TreeNode<K,V>>,\n-                 f: |&'r K, &'r mut V| -> bool)\n-                 -> bool {\n-    match *node {\n-      Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n-                     right: ref mut right, ..}) => {\n-        if !mutate_values(left,  |k,v| f(k,v)) { return false }\n-        if !f(key, value) { return false }\n-        if !mutate_values(right, |k,v| f(k,v)) { return false }\n-      }\n-      None => return false\n-    }\n-    true\n-}\n-\n // Remove left horizontal link by rotating right\n fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.as_ref().map_default(false, |x| x.level == node.level) {\n@@ -1129,6 +1254,69 @@ mod test_treemap {\n         }\n     }\n \n+    #[test]\n+    fn test_mut_iter() {\n+        let mut m = TreeMap::new();\n+        for i in range(0u, 10) {\n+            assert!(m.insert(i, 100 * i));\n+        }\n+\n+        for (i, (&k, v)) in m.mut_iter().enumerate() {\n+            *v += k * 10 + i; // 000 + 00 + 0, 100 + 10 + 1, ...\n+        }\n+\n+        for (&k, &v) in m.iter() {\n+            assert_eq!(v, 111 * k);\n+        }\n+    }\n+    #[test]\n+    fn test_mut_rev_iter() {\n+        let mut m = TreeMap::new();\n+        for i in range(0u, 10) {\n+            assert!(m.insert(i, 100 * i));\n+        }\n+\n+        for (i, (&k, v)) in m.mut_rev_iter().enumerate() {\n+            *v += k * 10 + (9 - i); // 900 + 90 + (9 - 0), 800 + 80 + (9 - 1), ...\n+        }\n+\n+        for (&k, &v) in m.iter() {\n+            assert_eq!(v, 111 * k);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mut_interval_iter() {\n+        let mut m_lower = TreeMap::new();\n+        let mut m_upper = TreeMap::new();\n+        for i in range(1, 100) {\n+            assert!(m_lower.insert(i * 2, i * 4));\n+            assert!(m_upper.insert(i * 2, i * 4));\n+        }\n+\n+        for i in range(1, 199) {\n+            let mut lb_it = m_lower.mut_lower_bound(&i);\n+            let (&k, v) = lb_it.next().unwrap();\n+            let lb = i + i % 2;\n+            assert_eq!(lb, k);\n+            *v -= k;\n+        }\n+        for i in range(0, 198) {\n+            let mut ub_it = m_upper.mut_upper_bound(&i);\n+            let (&k, v) = ub_it.next().unwrap();\n+            let ub = i + 2 - i % 2;\n+            assert_eq!(ub, k);\n+            *v -= k;\n+        }\n+\n+        assert!(m_lower.mut_lower_bound(&199).next().is_none());\n+\n+        assert!(m_upper.mut_upper_bound(&198).next().is_none());\n+\n+        assert!(m_lower.iter().all(|(_, &x)| x == 0));\n+        assert!(m_upper.iter().all(|(_, &x)| x == 0));\n+    }\n+\n     #[test]\n     fn test_eq() {\n         let mut a = TreeMap::new();"}]}