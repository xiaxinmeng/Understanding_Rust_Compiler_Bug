{"sha": "ec164fbb68a4252ef56497ba95501c0f4417ef4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMTY0ZmJiNjhhNDI1MmVmNTY0OTdiYTk1NTAxYzBmNDQxN2VmNGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-01T11:13:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-01T11:13:25Z"}, "message": "Merge #2455\n\n2455: Add BuiltinShadowMode r=flodiebold a=edwin0cheng\n\nThis PR try to fix #1905 by introduce an `BuiltinShadowMode` in name resolving functions. \r\n\r\ncc @flodiebold \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "904a0248de4794e650898c00be116fcec36c19e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/904a0248de4794e650898c00be116fcec36c19e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec164fbb68a4252ef56497ba95501c0f4417ef4e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd46BVCRBK7hj4Ov3rIwAAdHIIAA298y6dBw2QIYbafnrUYBa8\n6nYCbbG+QgyMMtumTVqnoxH2usQiMht/TFL/uNLflL05nhhOMV4zgDihg997ro3V\nTG9pMEgqD/163JFl5lr2n3qboB4hpzN3kgXYP429q0hfIuss/w1jGlk+8eEkJ2nx\nAXwDzdqgfecEc8joabr4v6hDbXPnaLBZMXZ91fIGdHhuzEiAUaK8dt9znsVSm4rk\nTciopTD58Rn7ItQAtHI6hUkRBjnCc1zipLNvajYI0NLbketRwlJ6+VpG3D+u14XS\nP8eI/owkpi8P/U3lwo+i4eyTBVjVeK+ql8T1NJZ13xeOqkRv8I9ZGpXgDtuJjOQ=\n=dbnv\n-----END PGP SIGNATURE-----\n", "payload": "tree 904a0248de4794e650898c00be116fcec36c19e0\nparent 780f476b4f438d473bc2e2299c2b8bf0a6fb9257\nparent cfc6e9e36646aa3b961018be875a7c3474aa7577\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575198805 +0000\ncommitter GitHub <noreply@github.com> 1575198805 +0000\n\nMerge #2455\n\n2455: Add BuiltinShadowMode r=flodiebold a=edwin0cheng\n\nThis PR try to fix #1905 by introduce an `BuiltinShadowMode` in name resolving functions. \r\n\r\ncc @flodiebold \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec164fbb68a4252ef56497ba95501c0f4417ef4e", "html_url": "https://github.com/rust-lang/rust/commit/ec164fbb68a4252ef56497ba95501c0f4417ef4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec164fbb68a4252ef56497ba95501c0f4417ef4e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780f476b4f438d473bc2e2299c2b8bf0a6fb9257", "url": "https://api.github.com/repos/rust-lang/rust/commits/780f476b4f438d473bc2e2299c2b8bf0a6fb9257", "html_url": "https://github.com/rust-lang/rust/commit/780f476b4f438d473bc2e2299c2b8bf0a6fb9257"}, {"sha": "cfc6e9e36646aa3b961018be875a7c3474aa7577", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc6e9e36646aa3b961018be875a7c3474aa7577", "html_url": "https://github.com/rust-lang/rust/commit/cfc6e9e36646aa3b961018be875a7c3474aa7577"}], "stats": {"total": 171, "additions": 139, "deletions": 32}, "files": [{"sha": "0df7a7cb49750f5a50eeb0effc066b6197340921", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -286,7 +286,7 @@ impl SourceAnalyzer {\n \n         let items = self\n             .resolver\n-            .resolve_module_path(db, &path)\n+            .resolve_module_path_in_items(db, &path)\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {"}, {"sha": "239f35229ae28bd6976efd1d77f5609a09035563", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -15,7 +15,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n-    nameres::CrateDefMap,\n+    nameres::{BuiltinShadowMode, CrateDefMap},\n     path::Path,\n     src::HasSource,\n     DefWithBodyId, HasModule, Lookup, ModuleId,\n@@ -83,7 +83,10 @@ impl Expander {\n     }\n \n     fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n-        self.crate_def_map.resolve_path(db, self.module.local_id, path).0.take_macros()\n+        self.crate_def_map\n+            .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n+            .0\n+            .take_macros()\n     }\n }\n "}, {"sha": "3e152187046b09d0a7c01ef7ee488141db11d1f4", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -149,6 +149,15 @@ static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n         .collect()\n });\n \n+/// Shadow mode for builtin type which can be shadowed by module.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum BuiltinShadowMode {\n+    // Prefer Module\n+    Module,\n+    // Prefer Other Types\n+    Other,\n+}\n+\n /// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ModuleScope {\n@@ -178,8 +187,20 @@ impl ModuleScope {\n     }\n \n     /// Get a name from current module scope, legacy macros are not included\n-    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n-        self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n+    pub fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n+        match shadow {\n+            BuiltinShadowMode::Module => self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n+            BuiltinShadowMode::Other => {\n+                let item = self.items.get(name);\n+                if let Some(res) = item {\n+                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n+                        return BUILTIN_SCOPE.get(name).or(item);\n+                    }\n+                }\n+\n+                item.or_else(|| BUILTIN_SCOPE.get(name))\n+            }\n+        }\n     }\n \n     pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n@@ -250,8 +271,10 @@ impl CrateDefMap {\n         db: &impl DefDatabase,\n         original_module: LocalModuleId,\n         path: &Path,\n+        shadow: BuiltinShadowMode,\n     ) -> (PerNs, Option<usize>) {\n-        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n+        let res =\n+            self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path, shadow);\n         (res.resolved_def, res.segment_index)\n     }\n }"}, {"sha": "d4bfcae1d2698cebcd6749e9e1c76f6b485059ac", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     db::DefDatabase,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n+        raw, BuiltinShadowMode, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n     per_ns::PerNs,\n@@ -299,6 +299,7 @@ where\n                 ResolveMode::Import,\n                 module_id,\n                 &import.path,\n+                BuiltinShadowMode::Module,\n             );\n \n             (res.resolved_def, res.reached_fixedpoint)\n@@ -477,6 +478,7 @@ where\n                 ResolveMode::Other,\n                 *module_id,\n                 path,\n+                BuiltinShadowMode::Module,\n             );\n \n             if let Some(def) = resolved_res.resolved_def.take_macros() {"}, {"sha": "42a75226ba5185d1bc76126cddb33983928c1609", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -16,7 +16,7 @@ use test_utils::tested_by;\n \n use crate::{\n     db::DefDatabase,\n-    nameres::CrateDefMap,\n+    nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{Path, PathKind},\n     per_ns::PerNs,\n     AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n@@ -68,7 +68,17 @@ impl CrateDefMap {\n         mode: ResolveMode,\n         original_module: LocalModuleId,\n         path: &Path,\n+        shadow: BuiltinShadowMode,\n     ) -> ResolvePathResult {\n+        // if it is not the last segment, we prefer the module to the builtin\n+        let prefer_module = |index| {\n+            if index == path.segments.len() - 1 {\n+                shadow\n+            } else {\n+                BuiltinShadowMode::Module\n+            }\n+        };\n+\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n@@ -96,20 +106,20 @@ impl CrateDefMap {\n                 if self.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n             {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n+                let (idx, segment) = match segments.next() {\n+                    Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name, prefer_module(idx))\n             }\n             PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n+                let (idx, segment) = match segments.next() {\n+                    Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n+                self.resolve_name_in_module(db, original_module, &segment.name, prefer_module(idx))\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n@@ -160,7 +170,7 @@ impl CrateDefMap {\n                             Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path);\n+                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -169,7 +179,7 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.local_id].scope.get(&segment.name) {\n+                    match self[module.local_id].scope.get(&segment.name, prefer_module(i)) {\n                         Some(res) => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -212,6 +222,7 @@ impl CrateDefMap {\n                 }\n             };\n         }\n+\n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n \n@@ -220,6 +231,7 @@ impl CrateDefMap {\n         db: &impl DefDatabase,\n         module: LocalModuleId,\n         name: &Name,\n+        shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         // Resolve in:\n         //  - legacy scope of macro\n@@ -228,23 +240,33 @@ impl CrateDefMap {\n         //  - std prelude\n         let from_legacy_macro =\n             self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_scope =\n+            self[module].scope.get(name, shadow).map_or_else(PerNs::none, |res| res.def);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n+        let from_prelude = self.resolve_in_prelude(db, name, shadow);\n \n         from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n     }\n \n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n+    fn resolve_name_in_crate_root_or_extern_prelude(\n+        &self,\n+        name: &Name,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n         let from_crate_root =\n-            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+            self[self.root].scope.get(name, shadow).map_or_else(PerNs::none, |res| res.def);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n+    fn resolve_in_prelude(\n+        &self,\n+        db: &impl DefDatabase,\n+        name: &Name,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n             let def_map = if prelude.krate == self.krate {\n@@ -254,7 +276,10 @@ impl CrateDefMap {\n                 keep = db.crate_def_map(prelude.krate);\n                 &keep\n             };\n-            def_map[prelude.local_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.local_id]\n+                .scope\n+                .get(name, shadow)\n+                .map_or_else(PerNs::none, |res| res.def)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "7d4df222e3ead53da10f90257c527cee79359bf6", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n-    nameres::CrateDefMap,\n+    nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{Path, PathKind},\n     per_ns::PerNs,\n     AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n@@ -91,7 +91,7 @@ pub enum ValueNs {\n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n     pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &Path) -> Option<TraitId> {\n-        let res = self.resolve_module_path(db, path).take_types()?;\n+        let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::TraitId(it) => Some(it),\n             _ => None,\n@@ -100,7 +100,7 @@ impl Resolver {\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n     pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &Path) -> Option<StructId> {\n-        let res = self.resolve_module_path(db, path).take_types()?;\n+        let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n             _ => None,\n@@ -109,26 +109,34 @@ impl Resolver {\n \n     /// Resolve known enum from std, like `std::result::Result`\n     pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &Path) -> Option<EnumId> {\n-        let res = self.resolve_module_path(db, path).take_types()?;\n+        let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n-    /// pub only for source-binder\n-    pub fn resolve_module_path(&self, db: &impl DefDatabase, path: &Path) -> PerNs {\n+    fn resolve_module_path(\n+        &self,\n+        db: &impl DefDatabase,\n+        path: &Path,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n         let (item_map, module) = match self.module() {\n             Some(it) => it,\n             None => return PerNs::none(),\n         };\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n         if segment_index.is_some() {\n             return PerNs::none();\n         }\n         module_res\n     }\n \n+    pub fn resolve_module_path_in_items(&self, db: &impl DefDatabase, path: &Path) -> PerNs {\n+        self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n+    }\n+\n     pub fn resolve_path_in_type_ns(\n         &self,\n         db: &impl DefDatabase,\n@@ -163,7 +171,12 @@ impl Resolver {\n                     }\n                 }\n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n+                    let (module_def, idx) = m.crate_def_map.resolve_path(\n+                        db,\n+                        m.module_id,\n+                        path,\n+                        BuiltinShadowMode::Other,\n+                    );\n                     let res = match module_def.take_types()? {\n                         ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n                         ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n@@ -256,7 +269,12 @@ impl Resolver {\n                 Scope::ImplBlockScope(_) | Scope::AdtScope(_) => continue,\n \n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n+                    let (module_def, idx) = m.crate_def_map.resolve_path(\n+                        db,\n+                        m.module_id,\n+                        path,\n+                        BuiltinShadowMode::Other,\n+                    );\n                     return match idx {\n                         None => {\n                             let value = match module_def.take_values()? {\n@@ -310,7 +328,7 @@ impl Resolver {\n \n     pub fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.take_macros()\n+        item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n     pub fn process_all_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {"}, {"sha": "a3cc5cf9579953b60f4631504e9f2e5447a8a721", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec164fbb68a4252ef56497ba95501c0f4417ef4e/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=ec164fbb68a4252ef56497ba95501c0f4417ef4e", "patch": "@@ -3693,6 +3693,42 @@ fn main() {\n     assert_eq!(t, \"Foo\");\n }\n \n+#[test]\n+fn not_shadowing_primitive_by_module() {\n+    let t = type_at(\n+        r#\"\n+//- /str.rs\n+fn foo() {}\n+\n+//- /main.rs\n+mod str;\n+fn foo() -> &'static str { \"\" }\n+\n+fn main() {\n+    foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"&str\");\n+}\n+\n+#[test]\n+fn not_shadowing_module_by_primitive() {\n+    let t = type_at(\n+        r#\"\n+//- /str.rs\n+fn foo() -> u32 {0}\n+\n+//- /main.rs\n+mod str;\n+fn foo() -> &'static str { \"\" }\n+\n+fn main() {\n+    str::foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n #[test]\n fn deref_trait() {\n     let t = type_at("}]}