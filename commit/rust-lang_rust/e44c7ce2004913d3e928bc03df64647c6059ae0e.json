{"sha": "e44c7ce2004913d3e928bc03df64647c6059ae0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NGM3Y2UyMDA0OTEzZDNlOTI4YmMwM2RmNjQ2NDdjNjA1OWFlMGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-09T11:27:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-11T07:48:46Z"}, "message": "remove last traces of source roots from hir", "tree": {"sha": "7dcb578a8a93a67ec985cc2c8b046f18f3ceb4c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dcb578a8a93a67ec985cc2c8b046f18f3ceb4c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e44c7ce2004913d3e928bc03df64647c6059ae0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e44c7ce2004913d3e928bc03df64647c6059ae0e", "html_url": "https://github.com/rust-lang/rust/commit/e44c7ce2004913d3e928bc03df64647c6059ae0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e44c7ce2004913d3e928bc03df64647c6059ae0e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b4c506f338d03a633419459bb32daf331153d5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4c506f338d03a633419459bb32daf331153d5e", "html_url": "https://github.com/rust-lang/rust/commit/3b4c506f338d03a633419459bb32daf331153d5e"}], "stats": {"total": 119, "additions": 71, "deletions": 48}, "files": [{"sha": "4d3a9c03628a2865cfa977ba2652936b8eca2079", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=e44c7ce2004913d3e928bc03df64647c6059ae0e", "patch": "@@ -6,7 +6,7 @@ use std::{panic, sync::Arc};\n \n use ra_prof::profile;\n use ra_syntax::{ast, Parse, SourceFile, TextRange, TextUnit};\n-use relative_path::RelativePathBuf;\n+use relative_path::{RelativePath, RelativePathBuf};\n \n pub use crate::{\n     cancellation::Canceled,\n@@ -71,6 +71,11 @@ pub trait SourceDatabase: CheckCanceled + std::fmt::Debug {\n     /// Text of the file.\n     #[salsa::input]\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n+\n+    #[salsa::transparent]\n+    fn resolve_relative_path(&self, anchor: FileId, relative_path: &RelativePath)\n+        -> Option<FileId>;\n+\n     // Parses the file into the syntax tree.\n     #[salsa::invoke(parse_query)]\n     fn parse(&self, file_id: FileId) -> Parse<ast::SourceFile>;\n@@ -89,6 +94,25 @@ pub trait SourceDatabase: CheckCanceled + std::fmt::Debug {\n     fn crate_graph(&self) -> Arc<CrateGraph>;\n }\n \n+fn resolve_relative_path(\n+    db: &impl SourceDatabase,\n+    anchor: FileId,\n+    relative_path: &RelativePath,\n+) -> Option<FileId> {\n+    let path = {\n+        let mut path = db.file_relative_path(anchor);\n+        // Workaround for relative path API: turn `lib.rs` into ``.\n+        if !path.pop() {\n+            path = RelativePathBuf::default();\n+        }\n+        path.push(relative_path);\n+        path.normalize()\n+    };\n+    let source_root = db.file_source_root(anchor);\n+    let source_root = db.source_root(source_root);\n+    source_root.file_by_relative_path(&path)\n+}\n+\n fn source_root_crates(db: &impl SourceDatabase, id: SourceRootId) -> Arc<Vec<CrateId>> {\n     let root = db.source_root(id);\n     let graph = db.crate_graph();"}, {"sha": "48b69000bcdc8ff25d60c108bf5144bd46d7efe9", "filename": "crates/ra_hir/src/debug.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdebug.rs?ref=e44c7ce2004913d3e928bc03df64647c6059ae0e", "patch": "@@ -22,7 +22,7 @@ use std::fmt;\n \n use ra_db::{CrateId, FileId};\n \n-use crate::{db::HirDatabase, Crate, Module, Name};\n+use crate::{db::HirDatabase, Crate, HirFileId, Module, Name};\n \n impl Crate {\n     pub fn debug(self, db: &impl HirDebugDatabase) -> impl fmt::Debug + '_ {\n@@ -36,6 +36,12 @@ impl Module {\n     }\n }\n \n+impl HirFileId {\n+    pub fn debug(self, db: &impl HirDebugDatabase) -> impl fmt::Debug + '_ {\n+        debug_fn(move |fmt| db.debug_hir_file_id(self, fmt))\n+    }\n+}\n+\n pub trait HirDebugHelper: HirDatabase {\n     fn crate_name(&self, _krate: CrateId) -> Option<String> {\n         None\n@@ -48,6 +54,7 @@ pub trait HirDebugHelper: HirDatabase {\n pub trait HirDebugDatabase {\n     fn debug_crate(&self, krate: Crate, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;\n     fn debug_module(&self, module: Module, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;\n+    fn debug_hir_file_id(&self, file_id: HirFileId, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;\n }\n \n impl<DB: HirDebugHelper> HirDebugDatabase for DB {\n@@ -62,12 +69,19 @@ impl<DB: HirDebugHelper> HirDebugDatabase for DB {\n \n     fn debug_module(&self, module: Module, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let file_id = module.definition_source(self).file_id.original_file(self);\n-        let path = self.file_path(file_id);\n+        let path = self.file_path(file_id).unwrap_or_else(|| \"N/A\".to_string());\n         fmt.debug_struct(\"Module\")\n             .field(\"name\", &module.name(self).unwrap_or_else(Name::missing))\n-            .field(\"path\", &path.unwrap_or_else(|| \"N/A\".to_string()))\n+            .field(\"path\", &path)\n             .finish()\n     }\n+\n+    fn debug_hir_file_id(&self, file_id: HirFileId, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let original = file_id.original_file(self);\n+        let path = self.file_path(original).unwrap_or_else(|| \"N/A\".to_string());\n+        let is_macro = file_id != original.into();\n+        fmt.debug_struct(\"HirFileId\").field(\"path\", &path).field(\"macro\", &is_macro).finish()\n+    }\n }\n \n fn debug_fn(f: impl Fn(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Debug {"}, {"sha": "b5fe16bfa4d439528df6519cf212b52dbecc5ae5", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=e44c7ce2004913d3e928bc03df64647c6059ae0e", "patch": "@@ -584,7 +584,7 @@ where\n             // out of line module, resolve, parse and recurse\n             raw::ModuleData::Declaration { name, ast_id } => {\n                 let ast_id = ast_id.with_file_id(self.file_id);\n-                match self.mod_dir.resolve_submodule(\n+                match self.mod_dir.resolve_declaration(\n                     self.def_collector.db,\n                     self.file_id,\n                     name,"}, {"sha": "e8b8085142c702365cb0c904d18763a9bffe0cb5", "filename": "crates/ra_hir/src/nameres/mod_resolution.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=e44c7ce2004913d3e928bc03df64647c6059ae0e", "patch": "@@ -1,9 +1,7 @@\n //! This module resolves `mod foo;` declaration to file.\n-use std::borrow::Cow;\n-\n use ra_db::FileId;\n use ra_syntax::SmolStr;\n-use relative_path::{RelativePath, RelativePathBuf};\n+use relative_path::RelativePathBuf;\n \n use crate::{db::DefDatabase, HirFileId, Name};\n \n@@ -28,23 +26,22 @@ impl ModDir {\n         attr_path: Option<&SmolStr>,\n     ) -> ModDir {\n         let mut path = self.path.clone();\n-        match attr_path {\n+        match attr_to_path(attr_path) {\n             None => path.push(&name.to_string()),\n             Some(attr_path) => {\n                 if self.root_non_dir_owner {\n-                    path = path\n-                        .parent()\n-                        .map(|it| it.to_relative_path_buf())\n-                        .unwrap_or_else(RelativePathBuf::new);\n+                    // Workaround for relative path API: turn `lib.rs` into ``.\n+                    if !path.pop() {\n+                        path = RelativePathBuf::default();\n+                    }\n                 }\n-                let attr_path = &*normalize_attribute_path(attr_path);\n-                path.push(RelativePath::new(attr_path));\n+                path.push(attr_path);\n             }\n         }\n         ModDir { path, root_non_dir_owner: false }\n     }\n \n-    pub(super) fn resolve_submodule(\n+    pub(super) fn resolve_declaration(\n         &self,\n         db: &impl DefDatabase,\n         file_id: HirFileId,\n@@ -53,32 +50,25 @@ impl ModDir {\n     ) -> Result<(FileId, ModDir), RelativePathBuf> {\n         let empty_path = RelativePathBuf::default();\n         let file_id = file_id.original_file(db);\n-        let base_dir = {\n-            let path = db.file_relative_path(file_id);\n-            path.parent().unwrap_or(&empty_path).join(&self.path)\n-        };\n \n         let mut candidate_files = Vec::new();\n-        match attr_path {\n-            Some(attr) => {\n+        match attr_to_path(attr_path) {\n+            Some(attr_path) => {\n                 let base = if self.root_non_dir_owner {\n-                    base_dir.parent().unwrap_or(&empty_path)\n+                    self.path.parent().unwrap_or(&empty_path)\n                 } else {\n-                    &base_dir\n+                    &self.path\n                 };\n-                candidate_files.push(base.join(&*normalize_attribute_path(attr)))\n+                candidate_files.push(base.join(attr_path))\n             }\n             None => {\n-                candidate_files.push(base_dir.join(&format!(\"{}.rs\", name)));\n-                candidate_files.push(base_dir.join(&format!(\"{}/mod.rs\", name)));\n+                candidate_files.push(self.path.join(&format!(\"{}.rs\", name)));\n+                candidate_files.push(self.path.join(&format!(\"{}/mod.rs\", name)));\n             }\n         };\n \n-        let source_root_id = db.file_source_root(file_id);\n-        let source_root = db.source_root(source_root_id);\n         for candidate in candidate_files.iter() {\n-            let candidate = candidate.normalize();\n-            if let Some(file_id) = source_root.file_by_relative_path(&candidate) {\n+            if let Some(file_id) = db.resolve_relative_path(file_id, candidate) {\n                 let mut root_non_dir_owner = false;\n                 let mut mod_path = RelativePathBuf::new();\n                 if !(candidate.ends_with(\"mod.rs\") || attr_path.is_some()) {\n@@ -88,22 +78,10 @@ impl ModDir {\n                 return Ok((file_id, ModDir { path: mod_path, root_non_dir_owner }));\n             }\n         }\n-        let suggestion = candidate_files.first().unwrap();\n-        Err(base_dir.join(suggestion))\n+        Err(candidate_files.remove(0))\n     }\n }\n \n-fn normalize_attribute_path(file_path: &str) -> Cow<str> {\n-    let current_dir = \"./\";\n-    let windows_path_separator = r#\"\\\"#;\n-    let current_dir_normalize = if file_path.starts_with(current_dir) {\n-        &file_path[current_dir.len()..]\n-    } else {\n-        file_path\n-    };\n-    if current_dir_normalize.contains(windows_path_separator) {\n-        Cow::Owned(current_dir_normalize.replace(windows_path_separator, \"/\"))\n-    } else {\n-        Cow::Borrowed(current_dir_normalize)\n-    }\n+fn attr_to_path(attr: Option<&SmolStr>) -> Option<RelativePathBuf> {\n+    attr.and_then(|it| RelativePathBuf::from_path(&it.replace(\"\\\\\", \"/\")).ok())\n }"}, {"sha": "65f061443aee4aa2172559ef611de8732d26667f", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44c7ce2004913d3e928bc03df64647c6059ae0e/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=e44c7ce2004913d3e928bc03df64647c6059ae0e", "patch": "@@ -12,6 +12,7 @@ use ra_syntax::{\n     Location, SyntaxNode, TextRange, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n+use relative_path::RelativePath;\n \n use crate::{db::RootDatabase, Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit};\n \n@@ -47,8 +48,14 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         })\n     })\n     .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n-        let source_root = db.file_source_root(d.source().file_id.original_file(db));\n-        let create_file = FileSystemEdit::CreateFile { source_root, path: d.candidate.clone() };\n+        let original_file = d.source().file_id.original_file(db);\n+        let source_root = db.file_source_root(original_file);\n+        let path = db\n+            .file_relative_path(original_file)\n+            .parent()\n+            .unwrap_or_else(|| RelativePath::new(\"\"))\n+            .join(&d.candidate);\n+        let create_file = FileSystemEdit::CreateFile { source_root, path };\n         let fix = SourceChange::file_system_edit(\"create module\", create_file);\n         res.borrow_mut().push(Diagnostic {\n             range: d.highlight_range(),"}]}