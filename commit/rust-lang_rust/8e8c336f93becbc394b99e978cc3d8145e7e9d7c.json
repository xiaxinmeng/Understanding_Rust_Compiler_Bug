{"sha": "8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOGMzMzZmOTNiZWNiYzM5NGI5OWU5NzhjYzNkODE0NWU3ZTlkN2M=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-10T04:14:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-10T04:14:19Z"}, "message": "Implement deep structural comparison through boxes and sequences.", "tree": {"sha": "b08227e7d271db47d1b428bd0a31a3c736718b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b08227e7d271db47d1b428bd0a31a3c736718b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "html_url": "https://github.com/rust-lang/rust/commit/8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb246e4e478b487da3a0ad36583217b32f483116", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb246e4e478b487da3a0ad36583217b32f483116", "html_url": "https://github.com/rust-lang/rust/commit/fb246e4e478b487da3a0ad36583217b32f483116"}], "stats": {"total": 235, "additions": 167, "deletions": 68}, "files": [{"sha": "0bddc0de41579cd1f85d998761c2e68099c9d824", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "patch": "@@ -402,6 +402,7 @@ TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     $(NOMINAL_TAG_XFAILS) \\\n                     $(CONST_TAG_XFAILS) \\\n                     test/run-pass/arith-unsigned.rs \\\n+                    test/run-pass/box-compare.rs \\\n                     test/run-pass/child-outlives-parent.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n                     test/run-pass/constrained-type.rs \\\n@@ -416,6 +417,7 @@ TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     test/run-pass/lib-io.rs \\\n                     test/run-pass/mlist-cycle.rs \\\n                     test/run-pass/obj-as.rs \\\n+                    test/run-pass/seq-compare.rs \\\n                     test/run-pass/task-comm.rs \\\n                     test/run-pass/task-comm-3.rs \\\n                     test/run-pass/vec-slice.rs \\"}, {"sha": "172f731be65f7ff1ab238077de291b973b1cc81c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 137, "deletions": 68, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "patch": "@@ -890,6 +890,11 @@ fn umax(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n     ret cx.build.Select(cond, b, a);\n }\n \n+fn umin(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n+    auto cond = cx.build.ICmp(lib.llvm.LLVMIntULT, a, b);\n+    ret cx.build.Select(cond, a, b);\n+}\n+\n fn align_to(@block_ctxt cx, ValueRef off, ValueRef align) -> ValueRef {\n     auto mask = cx.build.Sub(align, C_int(1));\n     auto bumped = cx.build.Add(off, mask);\n@@ -1774,7 +1779,7 @@ fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n }\n \n \n-type val_fn = fn(@block_ctxt cx, ValueRef v) -> result;\n+type val_pair_fn = fn(@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n \n@@ -1987,13 +1992,15 @@ fn iter_structural_ty_full(@block_ctxt cx,\n \n // Iterates through a pointer range, until the src* hits the src_lim*.\n fn iter_sequence_raw(@block_ctxt cx,\n+                     ValueRef dst,     // elt*\n                      ValueRef src,     // elt*\n                      ValueRef src_lim, // elt*\n                      ValueRef elt_sz,\n-                     val_fn f) -> result {\n+                     val_pair_fn f) -> result {\n \n     auto bcx = cx;\n \n+    let ValueRef dst_int = vp2i(bcx, dst);\n     let ValueRef src_int = vp2i(bcx, src);\n     let ValueRef src_lim_int = vp2i(bcx, src_lim);\n \n@@ -2003,6 +2010,8 @@ fn iter_sequence_raw(@block_ctxt cx,\n \n     bcx.build.Br(cond_cx.llbb);\n \n+    let ValueRef dst_curr = cond_cx.build.Phi(T_int(),\n+                                              vec(dst_int), vec(bcx.llbb));\n     let ValueRef src_curr = cond_cx.build.Phi(T_int(),\n                                               vec(src_int), vec(bcx.llbb));\n \n@@ -2011,14 +2020,18 @@ fn iter_sequence_raw(@block_ctxt cx,\n \n     cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n \n+    auto dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(T_i8()));\n     auto src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(T_i8()));\n \n-    auto body_res = f(body_cx, src_curr_ptr);\n+    auto body_res = f(body_cx, dst_curr_ptr, src_curr_ptr);\n     body_cx = body_res.bcx;\n \n+    auto dst_next = body_cx.build.Add(dst_curr, elt_sz);\n     auto src_next = body_cx.build.Add(src_curr, elt_sz);\n     body_cx.build.Br(cond_cx.llbb);\n \n+    cond_cx.build.AddIncomingToPhi(dst_curr, vec(dst_next),\n+                                   vec(body_cx.llbb));\n     cond_cx.build.AddIncomingToPhi(src_curr, vec(src_next),\n                                    vec(body_cx.llbb));\n \n@@ -2034,15 +2047,16 @@ fn iter_sequence_inner(@block_ctxt cx,\n     fn adaptor_fn(val_and_ty_fn f,\n                   @ty.t elt_ty,\n                   @block_ctxt cx,\n-                  ValueRef v) -> result {\n+                  ValueRef dst,\n+                  ValueRef src) -> result {\n         auto llty = type_of(cx.fcx.ccx, elt_ty);\n-        auto p = cx.build.PointerCast(v, T_ptr(llty));\n+        auto p = cx.build.PointerCast(src, T_ptr(llty));\n         ret f(cx, load_scalar_or_boxed(cx, p, elt_ty), elt_ty);\n     }\n \n     auto elt_sz = size_of(cx, elt_ty);\n-    be iter_sequence_raw(elt_sz.bcx, src, src_lim, elt_sz.val,\n-                         bind adaptor_fn(f, elt_ty, _, _));\n+    be iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n+                         bind adaptor_fn(f, elt_ty, _, _, _));\n }\n \n \n@@ -2378,13 +2392,27 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n-fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n-                 ValueRef lhs, ValueRef rhs) -> result {\n+fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n+                 ValueRef lhs0, ValueRef rhs0) -> result {\n+\n+    auto cx = cx0;\n+\n+    auto lhs_r = autoderef(cx, lhs0, t0);\n+    auto lhs = lhs_r.val;\n+    cx = lhs_r.bcx;\n+\n+    auto rhs_r = autoderef(cx, rhs0, t0);\n+    auto rhs = rhs_r.val;\n+    cx = rhs_r.bcx;\n+\n+    auto t = autoderefed_ty(t0);\n \n     if (ty.type_is_scalar(t)) {\n         ret res(cx, trans_scalar_compare(cx, op, t, lhs, rhs));\n \n-    } else if (ty.type_is_structural(t)) {\n+    } else if (ty.type_is_structural(t)\n+               || ty.type_is_sequence(t)) {\n+\n         auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n         auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n         cx.build.Br(scx.llbb);\n@@ -2415,28 +2443,52 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n \n         auto flag = scx.build.Alloca(T_i1());\n \n-        alt (op) {\n-            // ==, <= and >= default to true if they find == all the way.\n-            case (ast.eq) { scx.build.Store(C_integral(1, T_i1()), flag); }\n-            case (ast.le) { scx.build.Store(C_integral(1, T_i1()), flag); }\n-            case (ast.ge) { scx.build.Store(C_integral(1, T_i1()), flag); }\n-            case (_) {\n-                // ==, <= and >= default to false if they find == all the way.\n-                scx.build.Store(C_integral(0, T_i1()), flag);\n+        if (ty.type_is_sequence(t)) {\n+\n+            // If we hit == all the way through the minimum-shared-length\n+            // section, default to judging the relative sequence lengths.\n+            auto len_cmp =\n+                trans_integral_compare(scx, op, plain_ty(ty.ty_uint),\n+                                       vec_fill(scx, lhs),\n+                                       vec_fill(scx, rhs));\n+            scx.build.Store(len_cmp, flag);\n+\n+        } else {\n+            auto T = C_integral(1, T_i1());\n+            auto F = C_integral(0, T_i1());\n+\n+            alt (op) {\n+                // ==, <= and >= default to true if they find == all the way.\n+                case (ast.eq) { scx.build.Store(T, flag); }\n+                case (ast.le) { scx.build.Store(T, flag); }\n+                case (ast.ge) { scx.build.Store(T, flag); }\n+                case (_) {\n+                    // < > default to false if they find == all the way.\n+                    scx.build.Store(F, flag);\n+                }\n+\n             }\n         }\n \n         fn inner(@block_ctxt last_cx,\n+                 bool load_inner,\n                  ValueRef flag,\n                  ast.binop op,\n                  @block_ctxt cx,\n-                 ValueRef av,\n-                 ValueRef bv,\n+                 ValueRef av0,\n+                 ValueRef bv0,\n                  @ty.t t) -> result {\n \n             auto cnt_cx = new_sub_block_ctxt(cx, \"continue comparison\");\n             auto stop_cx = new_sub_block_ctxt(cx, \"stop comparison\");\n \n+            auto av = av0;\n+            auto bv = bv0;\n+            if (load_inner) {\n+                av = load_scalar_or_boxed(cx, av, t);\n+                bv = load_scalar_or_boxed(cx, bv, t);\n+            }\n+\n             // First 'eq' comparison: if so, continue to next elts.\n             auto eq_r = trans_compare(cx, ast.eq, t, av, bv);\n             eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n@@ -2448,16 +2500,32 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n             ret res(cnt_cx, C_nil());\n         }\n \n-        auto r = iter_structural_ty_full(scx, lhs, rhs, t,\n-                                         bind inner(next, flag, op,\n-                                                    _, _, _, _));\n+        auto r;\n+        if (ty.type_is_structural(t)) {\n+            r = iter_structural_ty_full(scx, lhs, rhs, t,\n+                                        bind inner(next, false, flag, op,\n+                                                   _, _, _, _));\n+        } else {\n+            auto lhs_p0 = vec_p0(scx, lhs);\n+            auto rhs_p0 = vec_p0(scx, rhs);\n+            auto min_len = umin(scx, vec_fill(scx, lhs), vec_fill(scx, rhs));\n+            auto rhs_lim = scx.build.GEP(rhs_p0, vec(min_len));\n+            auto elt_ty = ty.sequence_element_type(t);\n+            auto elt_llsz_r = size_of(scx, elt_ty);\n+            scx = elt_llsz_r.bcx;\n+            r = iter_sequence_raw(scx, lhs, rhs, rhs_lim,\n+                                  elt_llsz_r.val,\n+                                  bind inner(next, true, flag, op,\n+                                             _, _, _, elt_ty));\n+        }\n \n         r.bcx.build.Br(next.llbb);\n         auto v = next.build.Load(flag);\n         ret res(next, v);\n \n+\n     } else {\n-        // FIXME: compare vec, str, box?\n+        // FIXME: compare obj, fn by pointer?\n         cx.fcx.ccx.sess.unimpl(\"type in trans_compare\");\n         ret res(cx, C_bool(false));\n     }\n@@ -5670,6 +5738,45 @@ fn make_vec_append_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n     ret llfn;\n }\n \n+\n+fn vec_fill(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+    ret bcx.build.Load(bcx.build.GEP(v, vec(C_int(0),\n+                                            C_int(abi.vec_elt_fill))));\n+}\n+\n+fn put_vec_fill(@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n+    ret bcx.build.Store(fill,\n+                        bcx.build.GEP(v,\n+                                      vec(C_int(0),\n+                                          C_int(abi.vec_elt_fill))));\n+}\n+\n+fn vec_fill_adjusted(@block_ctxt bcx, ValueRef v,\n+                     ValueRef skipnull) -> ValueRef {\n+    auto f = bcx.build.Load(bcx.build.GEP(v,\n+                                          vec(C_int(0),\n+                                              C_int(abi.vec_elt_fill))));\n+    ret bcx.build.Select(skipnull, bcx.build.Sub(f, C_int(1)), f);\n+}\n+\n+fn vec_p0(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+    auto p = bcx.build.GEP(v, vec(C_int(0),\n+                                  C_int(abi.vec_elt_data)));\n+    ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n+}\n+\n+\n+fn vec_p1(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+    auto len = vec_fill(bcx, v);\n+    ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n+}\n+\n+fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n+                   ValueRef skipnull) -> ValueRef {\n+    auto len = vec_fill_adjusted(bcx, v, skipnull);\n+    ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n+}\n+\n fn trans_vec_append_glue(@crate_ctxt cx) {\n \n     auto llfn = cx.glues.vec_append_glue;\n@@ -5700,45 +5807,6 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     // First the dst vec needs to grow to accommodate the src vec.\n     // To do this we have to figure out how many bytes to add.\n \n-    fn vec_fill(@block_ctxt bcx, ValueRef v) -> ValueRef {\n-        ret bcx.build.Load(bcx.build.GEP(v, vec(C_int(0),\n-                                                C_int(abi.vec_elt_fill))));\n-    }\n-\n-    fn put_vec_fill(@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n-        ret bcx.build.Store(fill,\n-                            bcx.build.GEP(v,\n-                                          vec(C_int(0),\n-                                              C_int(abi.vec_elt_fill))));\n-    }\n-\n-    fn vec_fill_adjusted(@block_ctxt bcx, ValueRef v,\n-                         ValueRef skipnull) -> ValueRef {\n-        auto f = bcx.build.Load(bcx.build.GEP(v,\n-                                              vec(C_int(0),\n-                                                  C_int(abi.vec_elt_fill))));\n-        ret bcx.build.Select(skipnull, bcx.build.Sub(f, C_int(1)), f);\n-    }\n-\n-    fn vec_p0(@block_ctxt bcx, ValueRef v) -> ValueRef {\n-        auto p = bcx.build.GEP(v, vec(C_int(0),\n-                                      C_int(abi.vec_elt_data)));\n-        ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n-    }\n-\n-\n-    fn vec_p1(@block_ctxt bcx, ValueRef v) -> ValueRef {\n-        auto len = vec_fill(bcx, v);\n-        ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n-    }\n-\n-    fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n-                       ValueRef skipnull) -> ValueRef {\n-        auto len = vec_fill_adjusted(bcx, v, skipnull);\n-        ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n-    }\n-\n-\n     auto llcopy_dst_ptr = bcx.build.Alloca(T_int());\n     auto llnew_vec_res =\n         trans_upcall(bcx, \"upcall_vec_grow\",\n@@ -5780,16 +5848,17 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                                            C_int(abi.tydesc_field_size))));\n \n         fn take_one(ValueRef elt_tydesc,\n-                    @block_ctxt cx, ValueRef v) -> result {\n-            call_tydesc_glue_full(cx, v,\n+                    @block_ctxt cx,\n+                    ValueRef dst, ValueRef src) -> result {\n+            call_tydesc_glue_full(cx, src,\n                                   elt_tydesc,\n                                   abi.tydesc_field_take_glue_off);\n-            ret res(cx, v);\n+            ret res(cx, src);\n         }\n \n-        auto bcx = iter_sequence_raw(cx, src, src_lim,\n+        auto bcx = iter_sequence_raw(cx, dst, src, src_lim,\n                                      elt_llsz, bind take_one(elt_tydesc,\n-                                                             _, _)).bcx;\n+                                                             _, _, _)).bcx;\n \n         ret call_memcpy(bcx, dst, src, n_bytes);\n     }"}, {"sha": "bd3e3263820b8d65dd83ad3abdbb1921596837f0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "patch": "@@ -373,6 +373,14 @@ fn get_element_type(@t ty, uint i) -> @t {\n     fail;\n }\n \n+fn type_is_box(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_box(_)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n fn type_is_boxed(@t ty) -> bool {\n     alt (ty.struct) {\n         case (ty_str) { ret true; }"}, {"sha": "5115d5109a9da01b987b1940cacc72397dff7a78", "filename": "src/test/run-pass/box-compare.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+  check (@1 < @3);\n+  check (@@\"hello \" > @@\"hello\");\n+  check (@@@\"hello\" != @@@\"there\");\n+}\n\\ No newline at end of file"}, {"sha": "b3fe570193d6b2fa3607499bca56fef6ec092c11", "filename": "src/test/run-pass/seq-compare.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e8c336f93becbc394b99e978cc3d8145e7e9d7c/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=8e8c336f93becbc394b99e978cc3d8145e7e9d7c", "patch": "@@ -0,0 +1,15 @@\n+fn main() {\n+  check (\"hello\" < \"hellr\");\n+  check (\"hello \" > \"hello\");\n+  check (\"hello\" != \"there\");\n+\n+  check (vec(1,2,3,4) > vec(1,2,3));\n+  check (vec(1,2,3) < vec(1,2,3,4));\n+  check (vec(1,2,4,4) > vec(1,2,3,4));\n+  check (vec(1,2,3,4) < vec(1,2,4,4));\n+  check (vec(1,2,3) <= vec(1,2,3));\n+  check (vec(1,2,3) <= vec(1,2,3,3));\n+  check (vec(1,2,3,4) > vec(1,2,3));\n+  check (vec(1,2,3) == vec(1,2,3));\n+  check (vec(1,2,3) != vec(1,1,3));\n+}\n\\ No newline at end of file"}]}