{"sha": "4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZjNkYzE5YTFlNTlmZmRlYmUzZDhjYTEwNmU1YjdmMmQ2ZDIxMmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T02:24:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T02:24:20Z"}, "message": "Auto merge of #76017 - JulianKnodt:fmt_fast, r=nagisa\n\nUse less divisions in display u128/i128\n\nThis PR is an absolute mess, and I need to test if it improves the speed of fmt::Display for u128/i128, but I think it's correct.\nIt hopefully is more efficient by cutting u128 into at most 2 u64s, and also chunks by 1e16 instead of just 1e4.\n\nAlso I specialized the implementations for uints to always be non-false because it bothered me that it was checked at all\n\nDo not merge until I benchmark it and also clean up the god awful mess of spaghetti.\nBased on prior work in #44583\n\ncc: `@Dylan-DPC`\n\nDue to work on `itoa` and suggestion in original issue:\nr? `@dtolnay`", "tree": {"sha": "8068ed3b1d21fa469768c5b1f57526be140ffac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8068ed3b1d21fa469768c5b1f57526be140ffac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e", "html_url": "https://github.com/rust-lang/rust/commit/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad9ad06c00141114900c41750e961574f2ecc15", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad9ad06c00141114900c41750e961574f2ecc15", "html_url": "https://github.com/rust-lang/rust/commit/bad9ad06c00141114900c41750e961574f2ecc15"}, {"sha": "3f1d2aadd19c3cb71f1d88fb0b0c565808a3c040", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1d2aadd19c3cb71f1d88fb0b0c565808a3c040", "html_url": "https://github.com/rust-lang/rust/commit/3f1d2aadd19c3cb71f1d88fb0b0c565808a3c040"}], "stats": {"total": 342, "additions": 283, "deletions": 59}, "files": [{"sha": "2792181acc352ca8a37e713dd52ab8375fb2d06a", "filename": "library/core/benches/fmt.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e/library%2Fcore%2Fbenches%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e/library%2Fcore%2Fbenches%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Ffmt.rs?ref=4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e", "patch": "@@ -108,3 +108,32 @@ fn write_str_macro_debug(bh: &mut Bencher) {\n         }\n     });\n }\n+\n+#[bench]\n+fn write_u128_max(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        std::hint::black_box(format!(\"{}\", u128::MAX));\n+    });\n+}\n+\n+#[bench]\n+fn write_u128_min(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let s = format!(\"{}\", 0u128);\n+        std::hint::black_box(s);\n+    });\n+}\n+\n+#[bench]\n+fn write_u64_max(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        std::hint::black_box(format!(\"{}\", u64::MAX));\n+    });\n+}\n+\n+#[bench]\n+fn write_u64_min(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        std::hint::black_box(format!(\"{}\", 0u64));\n+    });\n+}"}, {"sha": "795cbf5fbbd44431f5bbb21566284bce642d2aa2", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 254, "deletions": 59, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=4cf3dc19a1e59ffdebe3d8ca106e5b7f2d6d212e", "patch": "@@ -9,7 +9,7 @@ use crate::slice;\n use crate::str;\n \n #[doc(hidden)]\n-trait Int:\n+trait DisplayInt:\n     PartialEq + PartialOrd + Div<Output = Self> + Rem<Output = Self> + Sub<Output = Self> + Copy\n {\n     fn zero() -> Self;\n@@ -21,22 +21,39 @@ trait Int:\n     fn to_u128(&self) -> u128;\n }\n \n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl Int for $t {\n-        fn zero() -> Self { 0 }\n-        fn from_u8(u: u8) -> Self { u as Self }\n-        fn to_u8(&self) -> u8 { *self as u8 }\n-        fn to_u16(&self) -> u16 { *self as u16 }\n-        fn to_u32(&self) -> u32 { *self as u32 }\n-        fn to_u64(&self) -> u64 { *self as u64 }\n-        fn to_u128(&self) -> u128 { *self as u128 }\n-    })*)\n+macro_rules! impl_int {\n+    ($($t:ident)*) => (\n+      $(impl DisplayInt for $t {\n+          fn zero() -> Self { 0 }\n+          fn from_u8(u: u8) -> Self { u as Self }\n+          fn to_u8(&self) -> u8 { *self as u8 }\n+          fn to_u16(&self) -> u16 { *self as u16 }\n+          fn to_u32(&self) -> u32 { *self as u32 }\n+          fn to_u64(&self) -> u64 { *self as u64 }\n+          fn to_u128(&self) -> u128 { *self as u128 }\n+      })*\n+    )\n }\n-doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n+macro_rules! impl_uint {\n+    ($($t:ident)*) => (\n+      $(impl DisplayInt for $t {\n+          fn zero() -> Self { 0 }\n+          fn from_u8(u: u8) -> Self { u as Self }\n+          fn to_u8(&self) -> u8 { *self as u8 }\n+          fn to_u16(&self) -> u16 { *self as u16 }\n+          fn to_u32(&self) -> u32 { *self as u32 }\n+          fn to_u64(&self) -> u64 { *self as u64 }\n+          fn to_u128(&self) -> u128 { *self as u128 }\n+      })*\n+    )\n+}\n+\n+impl_int! { i8 i16 i32 i64 i128 isize }\n+impl_uint! { u8 u16 u32 u64 u128 usize }\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n-trait GenericRadix {\n+trait GenericRadix: Sized {\n     /// The number of digits.\n     const BASE: u8;\n \n@@ -47,7 +64,7 @@ trait GenericRadix {\n     fn digit(x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n-    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    fn fmt_int<T: DisplayInt>(&self, mut x: T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 128\n         // characters for a base 2 number.\n         let zero = T::zero();\n@@ -127,13 +144,11 @@ macro_rules! radix {\n \n radix! { Binary,    2, \"0b\", x @  0 ..=  1 => b'0' + x }\n radix! { Octal,     8, \"0o\", x @  0 ..=  7 => b'0' + x }\n-radix! { LowerHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x,\n-x @ 10 ..= 15 => b'a' + (x - 10) }\n-radix! { UpperHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x,\n-x @ 10 ..= 15 => b'A' + (x - 10) }\n+radix! { LowerHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x, x @ 10 ..= 15 => b'a' + (x - 10) }\n+radix! { UpperHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x, x @ 10 ..= 15 => b'A' + (x - 10) }\n \n macro_rules! int_base {\n-    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+    (fmt::$Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::$Trait for $T {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -143,8 +158,27 @@ macro_rules! int_base {\n     };\n }\n \n+macro_rules! integer {\n+    ($Int:ident, $Uint:ident) => {\n+        int_base! { fmt::Binary   for $Int as $Uint  -> Binary }\n+        int_base! { fmt::Octal    for $Int as $Uint  -> Octal }\n+        int_base! { fmt::LowerHex for $Int as $Uint  -> LowerHex }\n+        int_base! { fmt::UpperHex for $Int as $Uint  -> UpperHex }\n+\n+        int_base! { fmt::Binary   for $Uint as $Uint -> Binary }\n+        int_base! { fmt::Octal    for $Uint as $Uint -> Octal }\n+        int_base! { fmt::LowerHex for $Uint as $Uint -> LowerHex }\n+        int_base! { fmt::UpperHex for $Uint as $Uint -> UpperHex }\n+    };\n+}\n+integer! { isize, usize }\n+integer! { i8, u8 }\n+integer! { i16, u16 }\n+integer! { i32, u32 }\n+integer! { i64, u64 }\n+integer! { i128, u128 }\n macro_rules! debug {\n-    ($T:ident) => {\n+    ($($T:ident)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::Debug for $T {\n             #[inline]\n@@ -158,31 +192,14 @@ macro_rules! debug {\n                 }\n             }\n         }\n-    };\n+    )*};\n }\n-\n-macro_rules! integer {\n-    ($Int:ident, $Uint:ident) => {\n-        int_base! { Binary   for $Int as $Uint  -> Binary }\n-        int_base! { Octal    for $Int as $Uint  -> Octal }\n-        int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n-        int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n-        debug! { $Int }\n-\n-        int_base! { Binary   for $Uint as $Uint -> Binary }\n-        int_base! { Octal    for $Uint as $Uint -> Octal }\n-        int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n-        int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n-        debug! { $Uint }\n-    };\n+debug! {\n+  i8 i16 i32 i64 i128 isize\n+  u8 u16 u32 u64 u128 usize\n }\n-integer! { isize, usize }\n-integer! { i8, u8 }\n-integer! { i16, u16 }\n-integer! { i32, u32 }\n-integer! { i64, u64 }\n-integer! { i128, u128 }\n \n+// 2 digit decimal look up table\n static DEC_DIGITS_LUT: &[u8; 200] = b\"0001020304050607080910111213141516171819\\\n       2021222324252627282930313233343536373839\\\n       4041424344454647484950515253545556575859\\\n@@ -256,21 +273,20 @@ macro_rules! impl_Display {\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n \n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl fmt::Display for $t {\n-                #[allow(unused_comparisons)]\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    let is_nonnegative = *self >= 0;\n-                    let n = if is_nonnegative {\n-                        self.$conv_fn()\n-                    } else {\n-                        // convert the negative num to positive by summing 1 to it's 2 complement\n-                        (!self.$conv_fn()).wrapping_add(1)\n-                    };\n-                    $name(n, is_nonnegative, f)\n-                }\n-            })*\n+        $(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::Display for $t {\n+            #[allow(unused_comparisons)]\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let is_nonnegative = *self >= 0;\n+                let n = if is_nonnegative {\n+                    self.$conv_fn()\n+                } else {\n+                    // convert the negative num to positive by summing 1 to it's 2 complement\n+                    (!self.$conv_fn()).wrapping_add(1)\n+                };\n+                $name(n, is_nonnegative, f)\n+            }\n+        })*\n     };\n }\n \n@@ -461,6 +477,185 @@ mod imp {\n     impl_Exp!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named exp_u32);\n     impl_Exp!(i64, u64 as u64 via to_u64 named exp_u64);\n }\n-\n-impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\n impl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n+\n+/// Helper function for writing a u64 into `buf` going from last to first, with `curr`.\n+fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut isize) {\n+    let buf_ptr = MaybeUninit::slice_as_mut_ptr(buf);\n+    let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n+    assert!(*curr > 19);\n+\n+    // SAFETY:\n+    // Writes at most 19 characters into the buffer. Guaranteed that any ptr into LUT is at most\n+    // 198, so will never OOB. There is a check above that there are at least 19 characters\n+    // remaining.\n+    unsafe {\n+        if n >= 1e16 as u64 {\n+            let to_parse = n % 1e16 as u64;\n+            n /= 1e16 as u64;\n+\n+            // Some of these are nops but it looks more elegant this way.\n+            let d1 = ((to_parse / 1e14 as u64) % 100) << 1;\n+            let d2 = ((to_parse / 1e12 as u64) % 100) << 1;\n+            let d3 = ((to_parse / 1e10 as u64) % 100) << 1;\n+            let d4 = ((to_parse / 1e8 as u64) % 100) << 1;\n+            let d5 = ((to_parse / 1e6 as u64) % 100) << 1;\n+            let d6 = ((to_parse / 1e4 as u64) % 100) << 1;\n+            let d7 = ((to_parse / 1e2 as u64) % 100) << 1;\n+            let d8 = ((to_parse / 1e0 as u64) % 100) << 1;\n+\n+            *curr -= 16;\n+\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d5 as isize), buf_ptr.offset(*curr + 8), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d6 as isize), buf_ptr.offset(*curr + 10), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d7 as isize), buf_ptr.offset(*curr + 12), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d8 as isize), buf_ptr.offset(*curr + 14), 2);\n+        }\n+        if n >= 1e8 as u64 {\n+            let to_parse = n % 1e8 as u64;\n+            n /= 1e8 as u64;\n+\n+            // Some of these are nops but it looks more elegant this way.\n+            let d1 = ((to_parse / 1e6 as u64) % 100) << 1;\n+            let d2 = ((to_parse / 1e4 as u64) % 100) << 1;\n+            let d3 = ((to_parse / 1e2 as u64) % 100) << 1;\n+            let d4 = ((to_parse / 1e0 as u64) % 100) << 1;\n+            *curr -= 8;\n+\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n+        }\n+        // `n` < 1e8 < (1 << 32)\n+        let mut n = n as u32;\n+        if n >= 1e4 as u32 {\n+            let to_parse = n % 1e4 as u32;\n+            n /= 1e4 as u32;\n+\n+            let d1 = (to_parse / 100) << 1;\n+            let d2 = (to_parse % 100) << 1;\n+            *curr -= 4;\n+\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n+        }\n+\n+        // `n` < 1e4 < (1 << 16)\n+        let mut n = n as u16;\n+        if n >= 100 {\n+            let d1 = (n % 100) << 1;\n+            n /= 100;\n+            *curr -= 2;\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+        }\n+\n+        // decode last 1 or 2 chars\n+        if n < 10 {\n+            *curr -= 1;\n+            *buf_ptr.offset(*curr) = (n as u8) + b'0';\n+        } else {\n+            let d1 = n << 1;\n+            *curr -= 2;\n+            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for u128 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt_u128(*self, true, f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for i128 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let is_nonnegative = *self >= 0;\n+        let n = if is_nonnegative {\n+            self.to_u128()\n+        } else {\n+            // convert the negative num to positive by summing 1 to it's 2 complement\n+            (!self.to_u128()).wrapping_add(1)\n+        };\n+        fmt_u128(n, is_nonnegative, f)\n+    }\n+}\n+\n+/// Specialized optimization for u128. Instead of taking two items at a time, it splits\n+/// into at most 2 u64s, and then chunks by 10e16, 10e8, 10e4, 10e2, and then 10e1.\n+/// It also has to handle 1 last item, as 10^40 > 2^128 > 10^39, whereas\n+/// 10^20 > 2^64 > 10^19.\n+fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n+    let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n+    let mut curr = buf.len() as isize;\n+    let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n+\n+    let (n, rem) = udiv_1e19(n);\n+    parse_u64_into(rem, &mut buf, &mut curr);\n+\n+    if n != 0 {\n+        // 0 pad up to point\n+        let target = (buf.len() - 19) as isize;\n+        // SAFETY: Guaranteed that we wrote at most 19 bytes, and there must be space\n+        // remaining since it has length 39\n+        unsafe {\n+            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n+        }\n+        curr = target;\n+\n+        let (n, rem) = udiv_1e19(n);\n+        parse_u64_into(rem, &mut buf, &mut curr);\n+        // Should this following branch be annotated with unlikely?\n+        if n != 0 {\n+            let target = (buf.len() - 38) as isize;\n+            // SAFETY: At this point we wrote at most 38 bytes, pad up to that point,\n+            // There can only be at most 1 digit remaining.\n+            unsafe {\n+                ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n+                curr = target - 1;\n+                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+            }\n+        }\n+    }\n+\n+    // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n+    // UTF-8 since `DEC_DIGITS_LUT` is\n+    let buf_slice = unsafe {\n+        str::from_utf8_unchecked(slice::from_raw_parts(\n+            buf_ptr.offset(curr),\n+            buf.len() - curr as usize,\n+        ))\n+    };\n+    f.pad_integral(is_nonnegative, \"\", buf_slice)\n+}\n+\n+/// Partition of `n` into n > 1e19 and rem <= 1e19\n+fn udiv_1e19(n: u128) -> (u128, u64) {\n+    const DIV: u64 = 1e19 as u64;\n+    let high = (n >> 64) as u64;\n+    if high == 0 {\n+        let low = n as u64;\n+        return ((low / DIV) as u128, low % DIV);\n+    }\n+    let sr = 65 - high.leading_zeros();\n+    let mut q = n << (128 - sr);\n+    let mut r = n >> sr;\n+    let mut carry = 0;\n+\n+    for _ in 0..sr {\n+        r = (r << 1) | (q >> 127);\n+        q = (q << 1) | carry as u128;\n+\n+        let s = (DIV as u128).wrapping_sub(r).wrapping_sub(1) as i128 >> 127;\n+        carry = (s & 1) as u64;\n+        r -= (DIV as u128) & s as u128;\n+    }\n+    ((q << 1) | carry as u128, r as u64)\n+}"}]}