{"sha": "59b0058c0cb875e539052a91ff9ccf355f0427a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YjAwNThjMGNiODc1ZTUzOTA1MmE5MWZmOWNjZjM1NWYwNDI3YTg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-16T12:16:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-16T12:16:30Z"}, "message": "Rollup merge of #67335 - ecstatic-morse:qualif-refactor, r=eddyb\n\nRefactor the `Qualif` trait\n\nThis PR attempts to preserve the existing semantics of the `Qualif` trait while reducing its API to two significant methods with descriptive names, `in_any_value_of_ty` and `in_adt_inherently`. The other `in_*` methods have been made into free functions, since they should never be overloaded. Finally, I changed the bounds on the `in_local` argument to be less restrictive (`FnMut` instead of `Fn`), which addresses a FIXME in the const-checker.\n\nr? @eddyb\ncc @pnkfelix @oli-obk", "tree": {"sha": "96635e9ac259145fb49bf88d908d66cb69ad32cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96635e9ac259145fb49bf88d908d66cb69ad32cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59b0058c0cb875e539052a91ff9ccf355f0427a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeb24eCRBK7hj4Ov3rIwAAdHIIABtOFQGqWnxkMB1fjT3IOoV7\naxnUPHckp4BfS6bEjSfPuryYelEX47442fd205OjwTgrboiljkvcg1vA5Aa2IcTz\nP29jHCQpt7+0lkpO3uwBi4SWeJO9r66/6YeIHgbXrfoDXAfOUPK7yRRKtC10tPC8\nEJHytvKImB0tyqSn8N8aITa5khiJQ3hE/Yfy3Qzd2Z01rummBt283+ZOvyj8gtUw\nLh2eVjc4uiCxKyxMfNMBgp2kWdJffX7RCAWGHqWJxSCinmhEaEdXsDaWo7bQxQkU\nRMLFLn6EqJqy6WGdGm/Lepk9DdrPNqcJ3fia65NxJMZ8gqtYdq7i9z9S2BSR8uI=\n=6usD\n-----END PGP SIGNATURE-----\n", "payload": "tree 96635e9ac259145fb49bf88d908d66cb69ad32cf\nparent 8e6de3244cd62cbde367c206bc9972daded5281d\nparent 6f75d3fcc04e6da1f10424e29da978a81698e81b\nauthor Dylan DPC <dylan.dpc@gmail.com> 1584360990 +0100\ncommitter GitHub <noreply@github.com> 1584360990 +0100\n\nRollup merge of #67335 - ecstatic-morse:qualif-refactor, r=eddyb\n\nRefactor the `Qualif` trait\n\nThis PR attempts to preserve the existing semantics of the `Qualif` trait while reducing its API to two significant methods with descriptive names, `in_any_value_of_ty` and `in_adt_inherently`. The other `in_*` methods have been made into free functions, since they should never be overloaded. Finally, I changed the bounds on the `in_local` argument to be less restrictive (`FnMut` instead of `Fn`), which addresses a FIXME in the const-checker.\n\nr? @eddyb\ncc @pnkfelix @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59b0058c0cb875e539052a91ff9ccf355f0427a8", "html_url": "https://github.com/rust-lang/rust/commit/59b0058c0cb875e539052a91ff9ccf355f0427a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59b0058c0cb875e539052a91ff9ccf355f0427a8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6de3244cd62cbde367c206bc9972daded5281d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6de3244cd62cbde367c206bc9972daded5281d", "html_url": "https://github.com/rust-lang/rust/commit/8e6de3244cd62cbde367c206bc9972daded5281d"}, {"sha": "6f75d3fcc04e6da1f10424e29da978a81698e81b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f75d3fcc04e6da1f10424e29da978a81698e81b", "html_url": "https://github.com/rust-lang/rust/commit/6f75d3fcc04e6da1f10424e29da978a81698e81b"}], "stats": {"total": 380, "additions": 178, "deletions": 202}, "files": [{"sha": "9359ec16533a580f54e26220187a981aa45e154f", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 152, "deletions": 183, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=59b0058c0cb875e539052a91ff9ccf355f0427a8", "patch": "@@ -1,7 +1,9 @@\n-//! A copy of the `Qualif` trait in `qualify_consts.rs` that is suitable for the new validator.\n+//! Structural const qualification.\n+//!\n+//! See the `Qualif` trait for more info.\n \n use rustc::mir::*;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n \n use super::Item as ConstCx;\n@@ -14,169 +16,44 @@ pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs\n }\n \n /// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n-/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n-/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n-/// definitely cannot find anything bad anywhere.\n+/// code for promotion or prevent it from evaluating at compile time.\n ///\n-/// The default implementations proceed structurally.\n+/// Normally, we would determine what qualifications apply to each type and error when an illegal\n+/// operation is performed on such a type. However, this was found to be too imprecise, especially\n+/// in the presence of `enum`s. If only a single variant of an enum has a certain qualification, we\n+/// needn't reject code unless it actually constructs and operates on the qualifed variant.\n+///\n+/// To accomplish this, const-checking and promotion use a value-based analysis (as opposed to a\n+/// type-based one). Qualifications propagate structurally across variables: If a local (or a\n+/// projection of a local) is assigned a qualifed value, that local itself becomes qualifed.\n pub trait Qualif {\n     /// The name of the file used to debug the dataflow analysis that computes this qualif.\n     const ANALYSIS_NAME: &'static str;\n \n     /// Whether this `Qualif` is cleared when a local is moved from.\n     const IS_CLEARED_ON_MOVE: bool = false;\n \n+    /// Extracts the field of `ConstQualifs` that corresponds to this `Qualif`.\n     fn in_qualifs(qualifs: &ConstQualifs) -> bool;\n \n-    /// Return the qualification that is (conservatively) correct for any value\n-    /// of the type.\n-    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n-\n-    fn in_projection_structurally(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif = Self::in_place(\n-                cx,\n-                per_local,\n-                PlaceRef { local: place.local, projection: proj_base },\n-            );\n-            let qualif = base_qualif\n-                && Self::in_any_value_of_ty(\n-                    cx,\n-                    Place::ty_from(place.local, proj_base, *cx.body, cx.tcx)\n-                        .projection_ty(cx.tcx, elem)\n-                        .ty,\n-                );\n-            match elem {\n-                ProjectionElem::Deref\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Field(..)\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Downcast(..) => qualif,\n-\n-                ProjectionElem::Index(local) => qualif || per_local(*local),\n-            }\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'tcx>,\n-    ) -> bool {\n-        Self::in_projection_structurally(cx, per_local, place)\n-    }\n-\n-    fn in_place(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'tcx>,\n-    ) -> bool {\n-        match place {\n-            PlaceRef { local, projection: [] } => per_local(local),\n-            PlaceRef { local: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n-        }\n-    }\n-\n-    fn in_operand(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        operand: &Operand<'tcx>,\n-    ) -> bool {\n-        match *operand {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => {\n-                Self::in_place(cx, per_local, place.as_ref())\n-            }\n-\n-            Operand::Constant(ref constant) => {\n-                // Check the qualifs of the value of `const` items.\n-                if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val {\n-                    assert!(promoted.is_none());\n-                    // Don't peek inside trait associated constants.\n-                    if cx.tcx.trait_of_item(def_id).is_none() {\n-                        let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n-                        if !Self::in_qualifs(&qualifs) {\n-                            return false;\n-                        }\n-\n-                        // Just in case the type is more specific than\n-                        // the definition, e.g., impl associated const\n-                        // with type parameters, take it into account.\n-                    }\n-                }\n-                // Otherwise use the qualifs of the type.\n-                Self::in_any_value_of_ty(cx, constant.literal.ty)\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue_structurally(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        match *rvalue {\n-            Rvalue::NullaryOp(..) => false,\n-\n-            Rvalue::Discriminant(ref place) | Rvalue::Len(ref place) => {\n-                Self::in_place(cx, per_local, place.as_ref())\n-            }\n-\n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_, ref operand)\n-            | Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, per_local, operand),\n-\n-            Rvalue::BinaryOp(_, ref lhs, ref rhs)\n-            | Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n-                Self::in_operand(cx, per_local, lhs) || Self::in_operand(cx, per_local, rhs)\n-            }\n-\n-            Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n-                // Special-case reborrows to be more like a copy of the reference.\n-                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        return Self::in_place(\n-                            cx,\n-                            per_local,\n-                            PlaceRef { local: place.local, projection: proj_base },\n-                        );\n-                    }\n-                }\n-\n-                Self::in_place(cx, per_local, place.as_ref())\n-            }\n-\n-            Rvalue::Aggregate(_, ref operands) => {\n-                operands.iter().any(|o| Self::in_operand(cx, per_local, o))\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        Self::in_rvalue_structurally(cx, per_local, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        _per_local: &mut impl FnMut(Local) -> bool,\n-        _callee: &Operand<'tcx>,\n-        _args: &[Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        // Be conservative about the returned value of a const fn.\n-        Self::in_any_value_of_ty(cx, return_ty)\n-    }\n+    /// Returns `true` if *any* value of the given type could possibly have this `Qualif`.\n+    ///\n+    /// This function determines `Qualif`s when we cannot do a value-based analysis. Since qualif\n+    /// propagation is context-insenstive, this includes function arguments and values returned\n+    /// from a call to another function.\n+    ///\n+    /// It also determines the `Qualif`s for primitive types.\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool;\n+\n+    /// Returns `true` if this `Qualif` is inherent to the given struct or enum.\n+    ///\n+    /// By default, `Qualif`s propagate into ADTs in a structural way: An ADT only becomes\n+    /// qualified if part of it is assigned a value with that `Qualif`. However, some ADTs *always*\n+    /// have a certain `Qualif`, regardless of whether their fields have it. For example, a type\n+    /// with a custom `Drop` impl is inherently `NeedsDrop`.\n+    ///\n+    /// Returning `true` for `in_adt_inherently` but `false` for `in_any_value_of_ty` is unsound.\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool;\n }\n \n /// Constant containing interior mutability (`UnsafeCell<T>`).\n@@ -197,26 +74,10 @@ impl Qualif for HasMutInterior {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n     }\n \n-    fn in_rvalue(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        match *rvalue {\n-            Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(*cx.body, cx.tcx);\n-                        assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool {\n+        // Exactly one type, `UnsafeCell`, has the `HasMutInterior` qualif inherently.\n+        // It arises structurally for all other types.\n+        Some(adt.did) == cx.tcx.lang_items().unsafe_cell_type()\n     }\n }\n \n@@ -238,19 +99,127 @@ impl Qualif for NeedsDrop {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }\n \n-    fn in_rvalue(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool {\n+        adt.has_dtor(cx.tcx)\n+    }\n+}\n+\n+// FIXME: Use `mir::visit::Visitor` for the `in_*` functions if/when it supports early return.\n+\n+/// Returns `true` if this `Rvalue` contains qualif `Q`.\n+pub fn in_rvalue<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, rvalue: &Rvalue<'tcx>) -> bool\n+where\n+    Q: Qualif,\n+    F: FnMut(Local) -> bool,\n+{\n+    match rvalue {\n+        Rvalue::NullaryOp(..) => Q::in_any_value_of_ty(cx, rvalue.ty(*cx.body, cx.tcx)),\n+\n+        Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n+            in_place::<Q, _>(cx, in_local, place.as_ref())\n+        }\n+\n+        Rvalue::Use(operand)\n+        | Rvalue::Repeat(operand, _)\n+        | Rvalue::UnaryOp(_, operand)\n+        | Rvalue::Cast(_, operand, _) => in_operand::<Q, _>(cx, in_local, operand),\n+\n+        Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+            in_operand::<Q, _>(cx, in_local, lhs) || in_operand::<Q, _>(cx, in_local, rhs)\n+        }\n+\n+        Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+            // Special-case reborrows to be more like a copy of the reference.\n+            if let &[ref proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n+                let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n+                if let ty::Ref(..) = base_ty.kind {\n+                    return in_place::<Q, _>(\n+                        cx,\n+                        in_local,\n+                        PlaceRef { local: place.local, projection: proj_base },\n+                    );\n+                }\n+            }\n+\n+            in_place::<Q, _>(cx, in_local, place.as_ref())\n+        }\n+\n+        Rvalue::Aggregate(kind, operands) => {\n+            // Return early if we know that the struct or enum being constructed is always\n+            // qualified.\n             if let AggregateKind::Adt(def, ..) = **kind {\n-                if def.has_dtor(cx.tcx) {\n+                if Q::in_adt_inherently(cx, def) {\n                     return true;\n                 }\n             }\n+\n+            // Otherwise, proceed structurally...\n+            operands.iter().any(|o| in_operand::<Q, _>(cx, in_local, o))\n         }\n+    }\n+}\n \n-        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+/// Returns `true` if this `Place` contains qualif `Q`.\n+pub fn in_place<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, place: PlaceRef<'tcx>) -> bool\n+where\n+    Q: Qualif,\n+    F: FnMut(Local) -> bool,\n+{\n+    let mut projection = place.projection;\n+    while let [ref proj_base @ .., proj_elem] = projection {\n+        match *proj_elem {\n+            ProjectionElem::Index(index) if in_local(index) => return true,\n+\n+            ProjectionElem::Deref\n+            | ProjectionElem::Field(_, _)\n+            | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Downcast(_, _)\n+            | ProjectionElem::Index(_) => {}\n+        }\n+\n+        let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx);\n+        let proj_ty = base_ty.projection_ty(cx.tcx, proj_elem).ty;\n+        if !Q::in_any_value_of_ty(cx, proj_ty) {\n+            return false;\n+        }\n+\n+        projection = proj_base;\n+    }\n+\n+    assert!(projection.is_empty());\n+    in_local(place.local)\n+}\n+\n+/// Returns `true` if this `Operand` contains qualif `Q`.\n+pub fn in_operand<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, operand: &Operand<'tcx>) -> bool\n+where\n+    Q: Qualif,\n+    F: FnMut(Local) -> bool,\n+{\n+    let constant = match operand {\n+        Operand::Copy(place) | Operand::Move(place) => {\n+            return in_place::<Q, _>(cx, in_local, place.as_ref());\n+        }\n+\n+        Operand::Constant(c) => c,\n+    };\n+\n+    // Check the qualifs of the value of `const` items.\n+    if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val {\n+        assert!(promoted.is_none());\n+        // Don't peek inside trait associated constants.\n+        if cx.tcx.trait_of_item(def_id).is_none() {\n+            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+            if !Q::in_qualifs(&qualifs) {\n+                return false;\n+            }\n+\n+            // Just in case the type is more specific than\n+            // the definition, e.g., impl associated const\n+            // with type parameters, take it into account.\n+        }\n     }\n+    // Otherwise use the qualifs of the type.\n+    Q::in_any_value_of_ty(cx, constant.literal.ty)\n }"}, {"sha": "e42f64b5c7384adaeba81508f28224324cff8486", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=59b0058c0cb875e539052a91ff9ccf355f0427a8", "patch": "@@ -8,7 +8,7 @@ use rustc_index::bit_set::BitSet;\n \n use std::marker::PhantomData;\n \n-use super::{Item, Qualif};\n+use super::{qualifs, Item, Qualif};\n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n@@ -66,18 +66,15 @@ where\n     fn apply_call_return_effect(\n         &mut self,\n         _block: BasicBlock,\n-        func: &mir::Operand<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n+        // We cannot reason about another function's internals, so use conservative type-based\n+        // qualification for the result of a function call.\n         let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_call(\n-            self.item,\n-            &mut |l| self.qualifs_per_local.contains(l),\n-            func,\n-            args,\n-            return_ty,\n-        );\n+        let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n+\n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(return_place, qualif);\n         }\n@@ -110,7 +107,11 @@ where\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n-        let qualif = Q::in_rvalue(self.item, &mut |l| self.qualifs_per_local.contains(l), rvalue);\n+        let qualif = qualifs::in_rvalue::<Q, _>(\n+            self.item,\n+            &mut |l| self.qualifs_per_local.contains(l),\n+            rvalue,\n+        );\n         if !place.is_indirect() {\n             self.assign_qualif_direct(place, qualif);\n         }\n@@ -125,8 +126,12 @@ where\n         // here; that occurs in `apply_call_return_effect`.\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n-            let qualif =\n-                Q::in_operand(self.item, &mut |l| self.qualifs_per_local.contains(l), value);\n+            let qualif = qualifs::in_operand::<Q, _>(\n+                self.item,\n+                &mut |l| self.qualifs_per_local.contains(l),\n+                value,\n+            );\n+\n             if !dest.is_indirect() {\n                 self.assign_qualif_direct(dest, qualif);\n             }"}, {"sha": "be461c0e03d8635767f5d007db2f39f5458bf6fa", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=59b0058c0cb875e539052a91ff9ccf355f0427a8", "patch": "@@ -344,7 +344,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Ref(_, BorrowKind::Shared, ref place)\n             | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n-                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+                let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.item,\n                     &mut |local| self.qualifs.has_mut_interior(local, location),\n                     place.as_ref(),"}, {"sha": "1336206e18626734d8e72090e8cabd217ad5c033", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0058c0cb875e539052a91ff9ccf355f0427a8/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=59b0058c0cb875e539052a91ff9ccf355f0427a8", "patch": "@@ -407,15 +407,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     // FIXME(eddyb) maybe cache this?\n     fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n-        let per_local = &mut |l| self.qualif_local::<Q>(l);\n-\n         if let TempState::Defined { location: loc, .. } = self.temps[local] {\n             let num_stmts = self.body[loc.block].statements.len();\n \n             if loc.statement_index < num_stmts {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n-                    StatementKind::Assign(box (_, rhs)) => Q::in_rvalue(&self.item, per_local, rhs),\n+                    StatementKind::Assign(box (_, rhs)) => qualifs::in_rvalue::<Q, _>(\n+                        &self.item,\n+                        &mut |l| self.qualif_local::<Q>(l),\n+                        rhs,\n+                    ),\n                     _ => {\n                         span_bug!(\n                             statement.source_info.span,\n@@ -427,9 +429,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n             } else {\n                 let terminator = self.body[loc.block].terminator();\n                 match &terminator.kind {\n-                    TerminatorKind::Call { func, args, .. } => {\n+                    TerminatorKind::Call { .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_call(&self.item, per_local, func, args, return_ty)\n+                        Q::in_any_value_of_ty(&self.item, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);"}]}