{"sha": "f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzU5YmQ2MDM1NjhmZTNjOGQxZWQxZDNjNDFiNTU2ZWM3M2ExNDU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-07T12:46:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-07T12:46:55Z"}, "message": "Rollup merge of #70762 - RalfJung:miri-leak-check, r=oli-obk\n\nMiri leak check: memory reachable through globals is not leaked\n\nAlso make Miri memory dump prettier by sharing more code with MIR dumping, and fix a bug where the Miri memory dump would print some allocations twice.\n\nr? @oli-obk\n\nMiri PR: https://github.com/rust-lang/miri/pull/1301", "tree": {"sha": "df7f16968174b52b6e69cb2e0080b117edf6435e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df7f16968174b52b6e69cb2e0080b117edf6435e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejHY/CRBK7hj4Ov3rIwAAdHIIAIzHVouNa7QH3vOF2KyHr8TU\nY5CI7u9ukQa4xz+2DjhbCQLtKzRKxgD4iR8X5mAEIXbiIWRNsux1QQMtGJDsiqTB\nrOCo6lEtsMZhhUUw6VJpUqK1P517WqKw8mbrMi6b04MCgvB/nFF+vffYL49VfFXm\nUo5FJmkTDUaXhkYzQUXEqq/kpez4vpD9wzMhVSujK+/oNUo1jGWC4pQfa63tbrZI\ndgTU+Pgog1OPTpmTPrjKIyIDy5aj5+ywk5VEv+Obe+xd5i6kjSJVixR/myt2XG9m\nhxieyxot/bOaLc1HA9lKVw+PcGReRkZnX2oJHnHkZkHhDUgBCMcAHCFNwggOeg4=\n=pBCO\n-----END PGP SIGNATURE-----\n", "payload": "tree df7f16968174b52b6e69cb2e0080b117edf6435e\nparent 795bc2ccff5672389c1e9d2481f25bdcdfee299b\nparent 1f3e2478b2e7267034d30a76ef4d28791a57d925\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586263615 +0200\ncommitter GitHub <noreply@github.com> 1586263615 +0200\n\nRollup merge of #70762 - RalfJung:miri-leak-check, r=oli-obk\n\nMiri leak check: memory reachable through globals is not leaked\n\nAlso make Miri memory dump prettier by sharing more code with MIR dumping, and fix a bug where the Miri memory dump would print some allocations twice.\n\nr? @oli-obk\n\nMiri PR: https://github.com/rust-lang/miri/pull/1301\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "html_url": "https://github.com/rust-lang/rust/commit/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "795bc2ccff5672389c1e9d2481f25bdcdfee299b", "url": "https://api.github.com/repos/rust-lang/rust/commits/795bc2ccff5672389c1e9d2481f25bdcdfee299b", "html_url": "https://github.com/rust-lang/rust/commit/795bc2ccff5672389c1e9d2481f25bdcdfee299b"}, {"sha": "1f3e2478b2e7267034d30a76ef4d28791a57d925", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f3e2478b2e7267034d30a76ef4d28791a57d925", "html_url": "https://github.com/rust-lang/rust/commit/1f3e2478b2e7267034d30a76ef4d28791a57d925"}], "stats": {"total": 192, "additions": 116, "deletions": 76}, "files": [{"sha": "23e39f433f53b1ffcef60a091f32804b3f8974a6", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "patch": "@@ -51,7 +51,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n     where\n         K: Borrow<Q>;\n \n-    /// Returns data based the keys and values in the map.\n+    /// Returns data based on the keys and values in the map.\n     fn filter_map_collect<T>(&self, f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T>;\n \n     /// Returns a reference to entry `k`. If no such entry exists, call\n@@ -79,7 +79,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n /// and some use case dependent behaviour can instead be applied.\n pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKind: ::std::fmt::Debug + MayLeak + Eq + 'static;\n+    type MemoryKind: ::std::fmt::Debug + ::std::fmt::Display + MayLeak + Eq + 'static;\n \n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>."}, {"sha": "c16c59715e40c4992979552b19e9570a885c23ac", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "patch": "@@ -9,6 +9,7 @@\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::convert::TryFrom;\n+use std::fmt;\n use std::ptr;\n \n use rustc_ast::ast::Mutability;\n@@ -20,6 +21,7 @@ use super::{\n     AllocId, AllocMap, Allocation, AllocationExtra, CheckInAllocMsg, ErrorHandled, GlobalAlloc,\n     GlobalId, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Scalar,\n };\n+use crate::util::pretty;\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n@@ -45,6 +47,17 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n     }\n }\n \n+impl<T: fmt::Display> fmt::Display for MemoryKind<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            MemoryKind::Stack => write!(f, \"stack variable\"),\n+            MemoryKind::Vtable => write!(f, \"vtable\"),\n+            MemoryKind::CallerLocation => write!(f, \"caller location\"),\n+            MemoryKind::Machine(m) => write!(f, \"{}\", m),\n+        }\n+    }\n+}\n+\n /// Used by `get_size_and_align` to indicate whether the allocation needs to be live.\n #[derive(Debug, Copy, Clone)]\n pub enum AllocCheck {\n@@ -258,7 +271,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         if alloc_kind != kind {\n             throw_ub_format!(\n-                \"deallocating `{:?}` memory using `{:?}` deallocation operation\",\n+                \"deallocating {} memory using {} deallocation operation\",\n                 alloc_kind,\n                 kind\n             );\n@@ -644,81 +657,90 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.dump_allocs(vec![id]);\n     }\n \n-    fn dump_alloc_helper<Tag, Extra>(\n-        &self,\n-        allocs_seen: &mut FxHashSet<AllocId>,\n-        allocs_to_print: &mut VecDeque<AllocId>,\n-        alloc: &Allocation<Tag, Extra>,\n-    ) {\n-        for &(_, (_, target_id)) in alloc.relocations().iter() {\n-            if allocs_seen.insert(target_id) {\n-                allocs_to_print.push_back(target_id);\n-            }\n-        }\n-        crate::util::pretty::write_allocation(self.tcx.tcx, alloc, &mut std::io::stderr(), \"\")\n-            .unwrap();\n-    }\n-\n     /// Print a list of allocations and all allocations they point to, recursively.\n     /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n     /// control for this.\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n+        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Tag, Extra>(\n+            tcx: TyCtxtAt<'tcx>,\n+            allocs_to_print: &mut VecDeque<AllocId>,\n+            alloc: &Allocation<Tag, Extra>,\n+        ) {\n+            for &(_, target_id) in alloc.relocations().values() {\n+                allocs_to_print.push_back(target_id);\n+            }\n+            pretty::write_allocation(tcx.tcx, alloc, &mut std::io::stderr()).unwrap();\n+        }\n+\n         allocs.sort();\n         allocs.dedup();\n         let mut allocs_to_print = VecDeque::from(allocs);\n-        let mut allocs_seen = FxHashSet::default();\n+        // `allocs_printed` contains all allocations that we have already printed.\n+        let mut allocs_printed = FxHashSet::default();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            eprint!(\"Alloc {:<5}: \", id);\n-            fn msg<Tag, Extra>(alloc: &Allocation<Tag, Extra>, extra: &str) {\n-                eprintln!(\n-                    \"({} bytes, alignment {}){}\",\n-                    alloc.size.bytes(),\n-                    alloc.align.bytes(),\n-                    extra\n-                )\n-            };\n+            if !allocs_printed.insert(id) {\n+                // Already printed, so skip this.\n+                continue;\n+            }\n \n-            // normal alloc?\n-            match self.alloc_map.get_or(id, || Err(())) {\n-                Ok((kind, alloc)) => {\n-                    match kind {\n-                        MemoryKind::Stack => msg(alloc, \" (stack)\"),\n-                        MemoryKind::Vtable => msg(alloc, \" (vtable)\"),\n-                        MemoryKind::CallerLocation => msg(alloc, \" (caller_location)\"),\n-                        MemoryKind::Machine(m) => msg(alloc, &format!(\" ({:?})\", m)),\n-                    };\n-                    self.dump_alloc_helper(&mut allocs_seen, &mut allocs_to_print, alloc);\n+            eprint!(\"{}\", id);\n+            match self.alloc_map.get(id) {\n+                Some(&(kind, ref alloc)) => {\n+                    // normal alloc\n+                    eprint!(\" ({}, \", kind);\n+                    write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n                 }\n-                Err(()) => {\n-                    // global alloc?\n+                None => {\n+                    // global alloc\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            msg(alloc, \" (immutable)\");\n-                            self.dump_alloc_helper(&mut allocs_seen, &mut allocs_to_print, alloc);\n+                            eprint!(\" (unchanged global, \");\n+                            write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n                         }\n                         Some(GlobalAlloc::Function(func)) => {\n-                            eprintln!(\"{}\", func);\n+                            eprint!(\" (fn: {})\", func);\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n-                            eprintln!(\"{:?}\", did);\n+                            eprint!(\" (static: {})\", self.tcx.def_path_str(did));\n                         }\n                         None => {\n-                            eprintln!(\"(deallocated)\");\n+                            eprint!(\" (deallocated)\");\n                         }\n                     }\n                 }\n-            };\n+            }\n+            eprintln!();\n         }\n     }\n \n     pub fn leak_report(&self) -> usize {\n-        let leaks: Vec<_> = self\n-            .alloc_map\n-            .filter_map_collect(|&id, &(kind, _)| if kind.may_leak() { None } else { Some(id) });\n+        // Collect the set of allocations that are *reachable* from `Global` allocations.\n+        let reachable = {\n+            let mut reachable = FxHashSet::default();\n+            let global_kind = M::GLOBAL_KIND.map(MemoryKind::Machine);\n+            let mut todo: Vec<_> = self.alloc_map.filter_map_collect(move |&id, &(kind, _)| {\n+                if Some(kind) == global_kind { Some(id) } else { None }\n+            });\n+            while let Some(id) = todo.pop() {\n+                if reachable.insert(id) {\n+                    // This is a new allocation, add its relocations to `todo`.\n+                    if let Some((_, alloc)) = self.alloc_map.get(id) {\n+                        todo.extend(alloc.relocations().values().map(|&(_, target_id)| target_id));\n+                    }\n+                }\n+            }\n+            reachable\n+        };\n+\n+        // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n+        let leaks: Vec<_> = self.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n+            if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n+        });\n         let n = leaks.len();\n         if n > 0 {\n-            eprintln!(\"### LEAK REPORT ###\");\n+            eprintln!(\"The following memory was leaked:\");\n             self.dump_allocs(leaks);\n         }\n         n"}, {"sha": "64221c41bffe4f56f1b373f99eced4b42d48d152", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c59bd603568fe3c8d1ed1d3c41b556ec73a145/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=f2c59bd603568fe3c8d1ed1d3c41b556ec73a145", "patch": "@@ -567,26 +567,21 @@ pub fn write_allocations<'tcx>(\n     }\n     let mut visitor = CollectAllocIds(Default::default());\n     body.visit_with(&mut visitor);\n+    // `seen` contains all seen allocations, including the ones we have *not* printed yet.\n+    // The protocol is to first `insert` into `seen`, and only if that returns `true`\n+    // then push to `todo`.\n     let mut seen = visitor.0;\n     let mut todo: Vec<_> = seen.iter().copied().collect();\n     while let Some(id) = todo.pop() {\n-        let mut write_header_and_allocation =\n+        let mut write_allocation_track_relocs =\n             |w: &mut dyn Write, alloc: &Allocation| -> io::Result<()> {\n-                write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n-                if alloc.size == Size::ZERO {\n-                    write!(w, \" {{}}\")?;\n-                } else {\n-                    writeln!(w, \" {{\")?;\n-                    write_allocation(tcx, alloc, w, \"    \")?;\n-                    write!(w, \"}}\")?;\n-                    // `.rev()` because we are popping them from the back of the `todo` vector.\n-                    for id in alloc_ids_from_alloc(alloc).rev() {\n-                        if seen.insert(id) {\n-                            todo.push(id);\n-                        }\n+                // `.rev()` because we are popping them from the back of the `todo` vector.\n+                for id in alloc_ids_from_alloc(alloc).rev() {\n+                    if seen.insert(id) {\n+                        todo.push(id);\n                     }\n                 }\n-                Ok(())\n+                write_allocation(tcx, alloc, w)\n             };\n         write!(w, \"\\n{}\", id)?;\n         let alloc = tcx.alloc_map.lock().get(id);\n@@ -599,7 +594,7 @@ pub fn write_allocations<'tcx>(\n                 match tcx.const_eval_poly(did) {\n                     Ok(ConstValue::ByRef { alloc, .. }) => {\n                         write!(w, \" (static: {}, \", tcx.def_path_str(did))?;\n-                        write_header_and_allocation(w, alloc)?;\n+                        write_allocation_track_relocs(w, alloc)?;\n                     }\n                     Ok(_) => {\n                         span_bug!(tcx.def_span(did), \" static item without `ByRef` initializer\")\n@@ -616,15 +611,46 @@ pub fn write_allocations<'tcx>(\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {\n                 write!(w, \" (\")?;\n-                write_header_and_allocation(w, alloc)?\n+                write_allocation_track_relocs(w, alloc)?\n             }\n         }\n-\n         writeln!(w)?;\n     }\n     Ok(())\n }\n \n+/// Dumps the size and metadata and content of an allocation to the given writer.\n+/// The expectation is that the caller first prints other relevant metadata, so the exact\n+/// format of this function is (*without* leading or trailing newline):\n+/// ```\n+/// size: {}, align: {}) {\n+///     <bytes>\n+/// }\n+/// ```\n+///\n+/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n+/// the start of the line, followed by all bytes in hex format (space separated).\n+/// If the allocation is small enough to fit into a single line, no start address is given.\n+/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n+/// characters or characters whose value is larger than 127) with a `.`\n+/// This also prints relocations adequately.\n+pub fn write_allocation<Tag, Extra>(\n+    tcx: TyCtxt<'tcx>,\n+    alloc: &Allocation<Tag, Extra>,\n+    w: &mut dyn Write,\n+) -> io::Result<()> {\n+    write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n+    if alloc.size == Size::ZERO {\n+        // We are done.\n+        return write!(w, \" {{}}\");\n+    }\n+    // Write allocation bytes.\n+    writeln!(w, \" {{\")?;\n+    write_allocation_bytes(tcx, alloc, w, \"    \")?;\n+    write!(w, \"}}\")?;\n+    Ok(())\n+}\n+\n fn write_allocation_endline(w: &mut dyn Write, ascii: &str) -> io::Result<()> {\n     for _ in 0..(BYTES_PER_LINE - ascii.chars().count()) {\n         write!(w, \"   \")?;\n@@ -649,18 +675,10 @@ fn write_allocation_newline(\n     Ok(line_start)\n }\n \n-/// Dumps the bytes of an allocation to the given writer. This also prints relocations instead of\n-/// the raw bytes where applicable.\n-/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n-/// the start of the line, followed by all bytes in hex format (space separated).\n-/// If the allocation is small enough to fit into a single line, no start address is given.\n-/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n-/// characters or characters whose value is larger than 127) with a `.`\n-///\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-pub fn write_allocation<Tag, Extra>(\n+fn write_allocation_bytes<Tag, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Tag, Extra>,\n     w: &mut dyn Write,"}]}