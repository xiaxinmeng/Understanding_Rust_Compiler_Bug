{"sha": "a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExN2M3ZTRmMmMwY2ZkODAwY2U4NzNiODMzMzRlOGIxN2JlZjJmNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T02:21:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T02:21:17Z"}, "message": "auto merge of #8637 : alexcrichton/rust/ifmt-less-hax, r=graydon\n\nRecent improvements to `&mut Trait` have made this work possible, and it solidifies that `ifmt` doesn't always have to return a string, but rather it's based around writers.", "tree": {"sha": "dcc5745a47c06dcbed739a2f80ee02cd91cfebea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcc5745a47c06dcbed739a2f80ee02cd91cfebea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "html_url": "https://github.com/rust-lang/rust/commit/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f1d896497b10cb56389730e784aff6e513b0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f1d896497b10cb56389730e784aff6e513b0e8", "html_url": "https://github.com/rust-lang/rust/commit/f7f1d896497b10cb56389730e784aff6e513b0e8"}, {"sha": "a3e39b945402475dbe0eae91833981dad4622cb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3e39b945402475dbe0eae91833981dad4622cb7", "html_url": "https://github.com/rust-lang/rust/commit/a3e39b945402475dbe0eae91833981dad4622cb7"}], "stats": {"total": 701, "additions": 409, "deletions": 292}, "files": [{"sha": "daf8c4afb0774d4169d56b6a2b8c7a3659b98325", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -12,33 +12,33 @@\n \n # The Formatting Module\n \n-This module contains the runtime support for the `ifmt!` syntax extension. This\n+This module contains the runtime support for the `format!` syntax extension. This\n macro is implemented in the compiler to emit calls to this module in order to\n format arguments at runtime into strings and streams.\n \n The functions contained in this module should not normally be used in everyday\n-use cases of `ifmt!`. The assumptions made by these functions are unsafe for all\n+use cases of `format!`. The assumptions made by these functions are unsafe for all\n inputs, and the compiler performs a large amount of validation on the arguments\n-to `ifmt!` in order to ensure safety at runtime. While it is possible to call\n+to `format!` in order to ensure safety at runtime. While it is possible to call\n these functions directly, it is not recommended to do so in the general case.\n \n ## Usage\n \n-The `ifmt!` macro is intended to be familiar to those coming from C's\n-printf/sprintf functions or Python's `str.format` function. In its current\n-revision, the `ifmt!` macro returns a `~str` type which is the result of the\n+The `format!` macro is intended to be familiar to those coming from C's\n+printf/fprintf functions or Python's `str.format` function. In its current\n+revision, the `format!` macro returns a `~str` type which is the result of the\n formatting. In the future it will also be able to pass in a stream to format\n arguments directly while performing minimal allocations.\n \n-Some examples of the `ifmt!` extension are:\n+Some examples of the `format!` extension are:\n \n ~~~{.rust}\n-ifmt!(\"Hello\")                  // => ~\"Hello\"\n-ifmt!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n-ifmt!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n-ifmt!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n-ifmt!(\"{value}\", value=4)       // => ~\"4\"\n-ifmt!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n+format!(\"Hello\")                  // => ~\"Hello\"\n+format!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n+format!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n+format!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n+format!(\"{value}\", value=4)       // => ~\"4\"\n+format!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n ~~~\n \n From these, you can see that the first argument is a format string. It is\n@@ -62,7 +62,7 @@ format string, although it must always be referred to with the same type.\n ### Named parameters\n \n Rust itself does not have a Python-like equivalent of named parameters to a\n-function, but the `ifmt!` macro is a syntax extension which allows it to\n+function, but the `format!` macro is a syntax extension which allows it to\n leverage named parameters. Named parameters are listed at the end of the\n argument list and have the syntax:\n \n@@ -146,7 +146,7 @@ helper methods.\n \n ## Internationalization\n \n-The formatting syntax supported by the `ifmt!` extension supports\n+The formatting syntax supported by the `format!` extension supports\n internationalization by providing \"methods\" which execute various different\n outputs depending on the input. The syntax and methods provided are similar to\n other internationalization systems, so again nothing should seem alien.\n@@ -164,7 +164,7 @@ to reference the string value of the argument which was selected upon. As an\n example:\n \n ~~~\n-ifmt!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n+format!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n ~~~\n \n This example is the equivalent of `{0:s}` essentially.\n@@ -399,7 +399,44 @@ pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n #[allow(missing_doc)]\n pub trait Float { fn fmt(&Self, &mut Formatter); }\n \n-/// The sprintf function takes a precompiled format string and a list of\n+/// The `write` function takes an output stream, a precompiled format string,\n+/// and a list of arguments. The arguments will be formatted according to the\n+/// specified format string into the output stream provided.\n+///\n+/// See the documentation for `format` for why this function is unsafe and care\n+/// should be taken if calling it manually.\n+///\n+/// Thankfully the rust compiler provides the macro `fmtf!` which will perform\n+/// all of this validation at compile-time and provides a safe interface for\n+/// invoking this function.\n+///\n+/// # Arguments\n+///\n+///   * output - the buffer to write output to\n+///   * fmts - the precompiled format string to emit\n+///   * args - the list of arguments to the format string. These are only the\n+///            positional arguments (not named)\n+///\n+/// Note that this function assumes that there are enough arguments for the\n+/// format string.\n+pub unsafe fn write(output: &mut io::Writer,\n+                    fmt: &[rt::Piece], args: &[Argument]) {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: parse::AlignUnknown,\n+        fill: ' ',\n+        args: args,\n+        curarg: args.iter(),\n+    };\n+    for piece in fmt.iter() {\n+        formatter.run(piece, None);\n+    }\n+}\n+\n+/// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n /// This is currently an unsafe function because the types of all arguments\n@@ -409,7 +446,7 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n /// for formatting the right type value. Because of this, the function is marked\n /// as `unsafe` if this is being called manually.\n ///\n-/// Thankfully the rust compiler provides the macro `ifmt!` which will perform\n+/// Thankfully the rust compiler provides the macro `format!` which will perform\n /// all of this validation at compile-time and provides a safe interface for\n /// invoking this function.\n ///\n@@ -421,32 +458,17 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n ///\n /// Note that this function assumes that there are enough arguments for the\n /// format string.\n-pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n-    let output = MemWriter::new();\n-    {\n-        let mut formatter = Formatter {\n-            flags: 0,\n-            width: None,\n-            precision: None,\n-            // FIXME(#8248): shouldn't need a transmute\n-            buf: cast::transmute(&output as &io::Writer),\n-            align: parse::AlignUnknown,\n-            fill: ' ',\n-            args: args,\n-            curarg: args.iter(),\n-        };\n-        for piece in fmt.iter() {\n-            formatter.run(piece, None);\n-        }\n-    }\n+pub unsafe fn format(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n+    let mut output = MemWriter::new();\n+    write(&mut output as &mut io::Writer, fmt, args);\n     return str::from_bytes_owned(output.inner());\n }\n \n impl<'self> Formatter<'self> {\n \n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n-    // the ifmt! syntax extension.\n+    // the format! syntax extension.\n \n     fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n         let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n@@ -710,7 +732,7 @@ impl<'self> Formatter<'self> {\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `sprintf` function.\n+/// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)]\n pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n                        t: &'a T) -> Argument<'a> {"}, {"sha": "6f9585652bd6852a78ffc6e5475633cb3dc9bee2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -139,8 +139,12 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(intern(&\"ifmt\"),\n-                            builtin_normal_tt(ext::ifmt::expand_syntax_ext));\n+    syntax_expanders.insert(intern(&\"format\"),\n+                            builtin_normal_tt(ext::ifmt::expand_format));\n+    syntax_expanders.insert(intern(&\"write\"),\n+                            builtin_normal_tt(ext::ifmt::expand_write));\n+    syntax_expanders.insert(intern(&\"writeln\"),\n+                            builtin_normal_tt(ext::ifmt::expand_writeln));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "7b493e11ef70903af2fe9f62a5661f3fde888e40", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -758,32 +758,32 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n-    // conditionally define debug!, but keep it type checking even\n-    // in non-debug builds.\n-    macro_rules! __debug (\n+    macro_rules! debug (\n         ($arg:expr) => (\n-            __log(4u32, fmt!( \\\"%?\\\", $arg ))\n+            if cfg!(debug) { __log(4u32, fmt!( \\\"%?\\\", $arg )) }\n         );\n         ($( $arg:expr ),+) => (\n-            __log(4u32, fmt!( $($arg),+ ))\n+            if cfg!(debug) { __log(4u32, fmt!( $($arg),+ )) }\n         )\n     )\n \n-    #[cfg(debug)]\n-    #[macro_escape]\n-    mod debug_macro {\n-        macro_rules! debug (($($arg:expr),*) => {\n-            __debug!($($arg),*)\n-        })\n-    }\n+    macro_rules! error2 (\n+        ($($arg:tt)*) => ( __log(1u32, format!($($arg)*)))\n+    )\n \n-    #[cfg(not(debug))]\n-    #[macro_escape]\n-    mod debug_macro {\n-        macro_rules! debug (($($arg:expr),*) => {\n-            if false { __debug!($($arg),*) }\n-        })\n-    }\n+    macro_rules! warn2 (\n+        ($($arg:tt)*) => ( __log(2u32, format!($($arg)*)))\n+    )\n+\n+    macro_rules! info2 (\n+        ($($arg:tt)*) => ( __log(3u32, format!($($arg)*)))\n+    )\n+\n+    macro_rules! debug2 (\n+        ($($arg:tt)*) => (\n+            if cfg!(debug) { __log(4u32, format!($($arg)*)) }\n+        )\n+    )\n \n     macro_rules! fail(\n         () => (\n@@ -797,6 +797,15 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    macro_rules! fail2(\n+        () => (\n+            fail!(\\\"explicit failure\\\")\n+        );\n+        ($($arg:tt)+) => (\n+            ::std::sys::FailWithCause::fail_with(format!($($arg)+), file!(), line!())\n+        )\n+    )\n+\n     macro_rules! assert(\n         ($cond:expr) => {\n             if !$cond {\n@@ -940,6 +949,7 @@ pub fn std_macros() -> @str {\n         );\n     )\n \n+    // NOTE(acrichto): start removing this after the next snapshot\n     macro_rules! printf (\n         ($arg:expr) => (\n             print(fmt!(\\\"%?\\\", $arg))\n@@ -949,6 +959,7 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    // NOTE(acrichto): start removing this after the next snapshot\n     macro_rules! printfln (\n         ($arg:expr) => (\n             println(fmt!(\\\"%?\\\", $arg))\n@@ -958,6 +969,19 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n+    //              allocation but should rather delegate to an invocation of\n+    //              write! instead of format!\n+    macro_rules! print (\n+        ($($arg:tt)+) => ( ::std::io::print(format!($($arg)+)))\n+    )\n+\n+    // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n+    //              allocation but should rather delegate to an io::Writer\n+    macro_rules! println (\n+        ($($arg:tt)+) => ({ print!($($arg)+); ::std::io::println(\\\"\\\"); })\n+    )\n+\n     // NOTE: use this after a snapshot lands to abstract the details\n     // of the TLS interface.\n     macro_rules! local_data_key ("}, {"sha": "d4274746a4eda838318c0189b35321f37dc0226e", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -54,20 +54,32 @@ impl Context {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other fmt! expressions.\n     fn parse_args(&mut self, sp: span,\n-                  tts: &[ast::token_tree]) -> Option<@ast::expr> {\n+                  leading_expr: bool,\n+                  tts: &[ast::token_tree]) -> (Option<@ast::expr>,\n+                                               Option<@ast::expr>) {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                              self.ecx.cfg(),\n                                              tts.to_owned());\n+        // If we want a leading expression (for ifmtf), parse it here\n+        let extra = if leading_expr {\n+            let e = Some(p.parse_expr());\n+            if !p.eat(&token::COMMA) {\n+                self.ecx.span_err(sp, \"expected token: `,`\");\n+                return (e, None);\n+            }\n+            e\n+        } else { None };\n+\n         if *p.token == token::EOF {\n-            self.ecx.span_err(sp, \"ifmt! expects at least one argument\");\n-            return None;\n+            self.ecx.span_err(sp, \"requires at least a format string argument\");\n+            return (extra, None);\n         }\n         let fmtstr = p.parse_expr();\n         let mut named = false;\n         while *p.token != token::EOF {\n             if !p.eat(&token::COMMA) {\n                 self.ecx.span_err(sp, \"expected token: `,`\");\n-                return None;\n+                return (extra, None);\n             }\n             if named || (token::is_ident(p.token) &&\n                          p.look_ahead(1, |t| *t == token::EQ)) {\n@@ -81,14 +93,14 @@ impl Context {\n                         self.ecx.span_err(*p.span,\n                                           \"expected ident, positional arguments \\\n                                            cannot follow named arguments\");\n-                        return None;\n+                        return (extra, None);\n                     }\n                     _ => {\n                         self.ecx.span_err(*p.span,\n                                           fmt!(\"expected ident for named \\\n                                                 argument, but found `%s`\",\n                                                p.this_token_to_str()));\n-                        return None;\n+                        return (extra, None);\n                     }\n                 };\n                 let name = self.ecx.str_of(ident);\n@@ -110,7 +122,7 @@ impl Context {\n                 self.arg_types.push(None);\n             }\n         }\n-        return Some(fmtstr);\n+        return (extra, Some(fmtstr));\n     }\n \n     /// Verifies one piece of a parse string. All errors are not emitted as\n@@ -530,7 +542,7 @@ impl Context {\n \n     /// Actually builds the expression which the ifmt! block will be expanded\n     /// to\n-    fn to_expr(&self) -> @ast::expr {\n+    fn to_expr(&self, extra: Option<@ast::expr>, f: &str) -> @ast::expr {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n@@ -596,15 +608,18 @@ impl Context {\n         let args = names.move_iter().map(|a| a.unwrap());\n         let mut args = locals.move_iter().chain(args);\n \n-        // Next, build up the actual call to the sprintf function.\n+        let mut fmt_args = match extra {\n+            Some(e) => ~[e], None => ~[]\n+        };\n+        fmt_args.push(self.ecx.expr_ident(self.fmtsp, static_name));\n+        fmt_args.push(self.ecx.expr_vec(self.fmtsp, args.collect()));\n+\n+        // Next, build up the actual call to the {s,f}printf function.\n         let result = self.ecx.expr_call_global(self.fmtsp, ~[\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"sprintf\"),\n-            ], ~[\n-                self.ecx.expr_ident(self.fmtsp, static_name),\n-                self.ecx.expr_vec(self.fmtsp, args.collect()),\n-            ]);\n+                self.ecx.ident_of(f),\n+            ], fmt_args);\n \n         // sprintf is unsafe, but we just went through a lot of work to\n         // validate that our call is save, so inject the unsafe block for the\n@@ -682,8 +697,24 @@ impl Context {\n     }\n }\n \n-pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_format(ecx: @ExtCtxt, sp: span,\n+                     tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, false, false, \"format\")\n+}\n+\n+pub fn expand_write(ecx: @ExtCtxt, sp: span,\n+                    tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, true, false, \"write\")\n+}\n+\n+pub fn expand_writeln(ecx: @ExtCtxt, sp: span,\n+                      tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, true, true, \"write\")\n+}\n+\n+fn expand_ifmt(ecx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n+               leading_arg: bool, append_newline: bool,\n+               function: &str) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],\n@@ -697,13 +728,14 @@ pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n         method_statics: ~[],\n         fmtsp: sp,\n     };\n-    let efmt = match cx.parse_args(sp, tts) {\n-        Some(e) => e,\n-        None => { return MRExpr(ecx.expr_uint(sp, 2)); }\n+    let (extra, efmt) = match cx.parse_args(sp, leading_arg, tts) {\n+        (extra, Some(e)) => (extra, e),\n+        (_, None) => { return MRExpr(ecx.expr_uint(sp, 2)); }\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = expr_to_str(ecx, efmt,\n-                          \"first argument to ifmt! must be a string literal.\");\n+                          \"format argument must be a string literal.\");\n+    let fmt = if append_newline { fmt + \"\\n\" } else { fmt.to_owned() };\n \n     let mut err = false;\n     do parse::parse_error::cond.trap(|m| {\n@@ -734,5 +766,5 @@ pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n         }\n     }\n \n-    MRExpr(cx.to_expr())\n+    MRExpr(cx.to_expr(extra, function))\n }"}, {"sha": "273394794a9965e69e5ce12a6670cd70db6ba91b", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -9,66 +9,66 @@\n // except according to those terms.\n \n fn main() {\n-    // bad arguments to the ifmt! call\n+    // bad arguments to the format! call\n \n-    ifmt!();                //~ ERROR: expects at least one\n-    ifmt!(\"{}\");            //~ ERROR: invalid reference to argument\n+    format!();                //~ ERROR: requires at least a format string\n+    format!(\"{}\");            //~ ERROR: invalid reference to argument\n \n-    ifmt!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n+    format!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n                             //~^ ERROR: argument never used\n-    ifmt!(\"{foo}\");         //~ ERROR: no argument named `foo`\n+    format!(\"{foo}\");         //~ ERROR: no argument named `foo`\n \n-    ifmt!(\"{}\", 1, 2);               //~ ERROR: argument never used\n-    ifmt!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n-    ifmt!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n-    ifmt!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n-    ifmt!(\"\", foo=2);                //~ ERROR: named argument never used\n+    format!(\"{}\", 1, 2);               //~ ERROR: argument never used\n+    format!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n+    format!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n+    format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n+    format!(\"\", foo=2);                //~ ERROR: named argument never used\n \n-    ifmt!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n-    ifmt!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n+    format!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n+    format!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n \n-    ifmt!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n-    ifmt!(\"#\");                      //~ ERROR: `#` reference used\n-    ifmt!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n-    ifmt!(\"\" 1);                     //~ ERROR: expected token: `,`\n-    ifmt!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n+    format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n+    format!(\"#\");                      //~ ERROR: `#` reference used\n+    format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n+    format!(\"\" 1);                     //~ ERROR: expected token: `,`\n+    format!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n \n-    ifmt!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n-    ifmt!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n-    ifmt!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n+    format!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n+    format!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n+    format!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n \n     // bad syntax of the format string\n \n-    ifmt!(\"{\"); //~ ERROR: unterminated format string\n-    ifmt!(\"\\\\ \"); //~ ERROR: invalid escape\n-    ifmt!(\"\\\\\"); //~ ERROR: expected an escape\n+    format!(\"{\"); //~ ERROR: unterminated format string\n+    format!(\"\\\\ \"); //~ ERROR: invalid escape\n+    format!(\"\\\\\"); //~ ERROR: expected an escape\n \n-    ifmt!(\"{0, }\", 1); //~ ERROR: expected method\n-    ifmt!(\"{0, foo}\", 1); //~ ERROR: unknown method\n-    ifmt!(\"{0, select}\", \"a\"); //~ ERROR: must be followed by\n-    ifmt!(\"{0, plural}\", 1); //~ ERROR: must be followed by\n+    format!(\"{0, }\", 1); //~ ERROR: expected method\n+    format!(\"{0, foo}\", 1); //~ ERROR: unknown method\n+    format!(\"{0, select}\", \"a\"); //~ ERROR: must be followed by\n+    format!(\"{0, plural}\", 1); //~ ERROR: must be followed by\n \n-    ifmt!(\"{0, select, a{{}\", 1); //~ ERROR: must be terminated\n-    ifmt!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n-    ifmt!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n-    ifmt!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n-    ifmt!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: be followed by `:`\n-    ifmt!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n-    ifmt!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n-    ifmt!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n-    ifmt!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n+    format!(\"{0, select, a{{}\", 1); //~ ERROR: must be terminated\n+    format!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n+    format!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n+    format!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n+    format!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: be followed by `:`\n+    format!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n+    format!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n+    format!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n+    format!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n \n-    ifmt!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n-    ifmt!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n-    ifmt!(\"{0, select, other{}} \\\n-           {0, plural, other{}}\", \"a\");\n+    format!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n+    format!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n+    format!(\"{0, select, other{}} \\\n+             {0, plural, other{}}\", \"a\");\n     //~^ ERROR: declared with multiple formats\n \n     // It should be illegal to use implicit placement arguments nested inside of\n     // format strings because otherwise the \"internal pointer of which argument\n     // is next\" would be invalidated if different cases had different numbers of\n     // arguments.\n-    ifmt!(\"{0, select, other{{}}}\", \"a\"); //~ ERROR: cannot use implicit\n-    ifmt!(\"{0, plural, other{{}}}\", 1); //~ ERROR: cannot use implicit\n-    ifmt!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n+    format!(\"{0, select, other{{}}}\", \"a\"); //~ ERROR: cannot use implicit\n+    format!(\"{0, plural, other{{}}}\", 1); //~ ERROR: cannot use implicit\n+    format!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n }"}, {"sha": "21c2d4b5934df5e950506145b4d4fb6b0b1fb027", "filename": "src/test/compile-fail/ifmt-bad-plural.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{0, plural, other{}}\", \"a\");\n+    format!(\"{0, plural, other{}}\", \"a\");\n     //~^ ERROR: expected uint but found\n }"}, {"sha": "8a72b7920d7d2b8b189c4190c47fc104ff247eda", "filename": "src/test/compile-fail/ifmt-bad-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{0, select, other{}}\", 2);\n+    format!(\"{0, select, other{}}\", 2);\n     //~^ ERROR: expected &str but found integral\n }"}, {"sha": "830b041bbc7156c365629386042e245a24815346", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{:d}\", \"3\");\n+    format!(\"{:d}\", \"3\");\n     //~^ ERROR: failed to find an implementation of trait std::fmt::Signed\n }"}, {"sha": "d90b3d3cf81df865054166f3d22b0f02b82978af", "filename": "src/test/compile-fail/ifmt-unknown-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{:notimplemented}\", \"3\");\n+    format!(\"{:notimplemented}\", \"3\");\n     //~^ ERROR: unknown format trait `notimplemented`\n }"}, {"sha": "7bf9d004ee069d3c7613ec2dbf77f761e6c545b2", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 200, "deletions": 165, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "patch": "@@ -21,193 +21,228 @@ impl fmt::Signed for B {\n     fn fmt(_: &B, f: &mut fmt::Formatter) { f.buf.write(\"adios\".as_bytes()); }\n }\n \n+macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n+\n pub fn main() {\n-    macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n     // Make sure there's a poly formatter that takes anything\n-    t!(ifmt!(\"{:?}\", 1), \"1\");\n-    t!(ifmt!(\"{:?}\", A), \"{}\");\n-    t!(ifmt!(\"{:?}\", ()), \"()\");\n-    t!(ifmt!(\"{:?}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+    t!(format!(\"{:?}\", 1), \"1\");\n+    t!(format!(\"{:?}\", A), \"{}\");\n+    t!(format!(\"{:?}\", ()), \"()\");\n+    t!(format!(\"{:?}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n \n     // Various edge cases without formats\n-    t!(ifmt!(\"\"), \"\");\n-    t!(ifmt!(\"hello\"), \"hello\");\n-    t!(ifmt!(\"hello \\\\{\"), \"hello {\");\n+    t!(format!(\"\"), \"\");\n+    t!(format!(\"hello\"), \"hello\");\n+    t!(format!(\"hello \\\\{\"), \"hello {\");\n \n     // default formatters should work\n-    t!(ifmt!(\"{}\", 1i), \"1\");\n-    t!(ifmt!(\"{}\", 1i8), \"1\");\n-    t!(ifmt!(\"{}\", 1i16), \"1\");\n-    t!(ifmt!(\"{}\", 1i32), \"1\");\n-    t!(ifmt!(\"{}\", 1i64), \"1\");\n-    t!(ifmt!(\"{}\", 1u), \"1\");\n-    t!(ifmt!(\"{}\", 1u8), \"1\");\n-    t!(ifmt!(\"{}\", 1u16), \"1\");\n-    t!(ifmt!(\"{}\", 1u32), \"1\");\n-    t!(ifmt!(\"{}\", 1u64), \"1\");\n-    t!(ifmt!(\"{}\", 1.0f), \"1\");\n-    t!(ifmt!(\"{}\", 1.0f32), \"1\");\n-    t!(ifmt!(\"{}\", 1.0f64), \"1\");\n-    t!(ifmt!(\"{}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{}\", ~\"a\"), \"a\");\n-    t!(ifmt!(\"{}\", @\"a\"), \"a\");\n-    t!(ifmt!(\"{}\", false), \"false\");\n-    t!(ifmt!(\"{}\", 'a'), \"a\");\n+    t!(format!(\"{}\", 1i), \"1\");\n+    t!(format!(\"{}\", 1i8), \"1\");\n+    t!(format!(\"{}\", 1i16), \"1\");\n+    t!(format!(\"{}\", 1i32), \"1\");\n+    t!(format!(\"{}\", 1i64), \"1\");\n+    t!(format!(\"{}\", 1u), \"1\");\n+    t!(format!(\"{}\", 1u8), \"1\");\n+    t!(format!(\"{}\", 1u16), \"1\");\n+    t!(format!(\"{}\", 1u32), \"1\");\n+    t!(format!(\"{}\", 1u64), \"1\");\n+    t!(format!(\"{}\", 1.0f), \"1\");\n+    t!(format!(\"{}\", 1.0f32), \"1\");\n+    t!(format!(\"{}\", 1.0f64), \"1\");\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{}\", ~\"a\"), \"a\");\n+    t!(format!(\"{}\", @\"a\"), \"a\");\n+    t!(format!(\"{}\", false), \"false\");\n+    t!(format!(\"{}\", 'a'), \"a\");\n \n     // At least exercise all the formats\n-    t!(ifmt!(\"{:b}\", true), \"true\");\n-    t!(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n-    t!(ifmt!(\"{:d}\", 10), \"10\");\n-    t!(ifmt!(\"{:i}\", 10), \"10\");\n-    t!(ifmt!(\"{:u}\", 10u), \"10\");\n-    t!(ifmt!(\"{:o}\", 10u), \"12\");\n-    t!(ifmt!(\"{:x}\", 10u), \"a\");\n-    t!(ifmt!(\"{:X}\", 10u), \"A\");\n-    t!(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n-    t!(ifmt!(\"{:s}\", ~\"foo\"), \"foo\");\n-    t!(ifmt!(\"{:s}\", @\"foo\"), \"foo\");\n-    t!(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n-    t!(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n-    t!(ifmt!(\"{:d}\", A), \"aloha\");\n-    t!(ifmt!(\"{:d}\", B), \"adios\");\n-    t!(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t!(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t!(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t!(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n-    t!(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n-    t!(ifmt!(\"{} {0}\", \"a\"), \"a a\");\n+    t!(format!(\"{:b}\", true), \"true\");\n+    t!(format!(\"{:c}\", '\u2603'), \"\u2603\");\n+    t!(format!(\"{:d}\", 10), \"10\");\n+    t!(format!(\"{:i}\", 10), \"10\");\n+    t!(format!(\"{:u}\", 10u), \"10\");\n+    t!(format!(\"{:o}\", 10u), \"12\");\n+    t!(format!(\"{:x}\", 10u), \"a\");\n+    t!(format!(\"{:X}\", 10u), \"A\");\n+    t!(format!(\"{:s}\", \"foo\"), \"foo\");\n+    t!(format!(\"{:s}\", ~\"foo\"), \"foo\");\n+    t!(format!(\"{:s}\", @\"foo\"), \"foo\");\n+    t!(format!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n+    t!(format!(\"{:d}\", A), \"aloha\");\n+    t!(format!(\"{:d}\", B), \"adios\");\n+    t!(format!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t!(format!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n+    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t!(format!(\"{} {0:s}\", \"a\"), \"a a\");\n+    t!(format!(\"{} {0}\", \"a\"), \"a a\");\n \n     // Methods should probably work\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n-    t!(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n-    t!(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n+    t!(format!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n+    t!(format!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n \n     // Formatting strings and their arguments\n-    t!(ifmt!(\"{:s}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{:4s}\", \"a\"), \"a   \");\n-    t!(ifmt!(\"{:>4s}\", \"a\"), \"   a\");\n-    t!(ifmt!(\"{:<4s}\", \"a\"), \"a   \");\n-    t!(ifmt!(\"{:.4s}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{:4.4s}\", \"a\"), \"a   \");\n-    t!(ifmt!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aa\"), \"aa\");\n-    t!(ifmt!(\"{:2.4s}\", \"a\"), \"a \");\n-    t!(ifmt!(\"{:0>2s}\", \"a\"), \"0a\");\n-    t!(ifmt!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n-    t!(ifmt!(\"{:1$s}\", \"a\", 4), \"a   \");\n-    t!(ifmt!(\"{:-#s}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{:+#s}\", \"a\"), \"a\");\n+    t!(format!(\"{:s}\", \"a\"), \"a\");\n+    t!(format!(\"{:4s}\", \"a\"), \"a   \");\n+    t!(format!(\"{:>4s}\", \"a\"), \"   a\");\n+    t!(format!(\"{:<4s}\", \"a\"), \"a   \");\n+    t!(format!(\"{:.4s}\", \"a\"), \"a\");\n+    t!(format!(\"{:4.4s}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n+    t!(format!(\"{:2.4s}\", \"aa\"), \"aa\");\n+    t!(format!(\"{:2.4s}\", \"a\"), \"a \");\n+    t!(format!(\"{:0>2s}\", \"a\"), \"0a\");\n+    t!(format!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:1$s}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{:-#s}\", \"a\"), \"a\");\n+    t!(format!(\"{:+#s}\", \"a\"), \"a\");\n \n     // Formatting integers should select the right implementation based off the\n     // type of the argument. Also, hex/octal/binary should be defined for\n     // integers, but they shouldn't emit the negative sign.\n-    t!(ifmt!(\"{:d}\", -1i), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i8), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i16), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i32), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i64), \"-1\");\n-    t!(ifmt!(\"{:t}\", 1i), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i64), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i64), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i64), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i64), \"1\");\n-\n-    t!(ifmt!(\"{:u}\", 1u), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u64), \"1\");\n+    t!(format!(\"{:d}\", -1i), \"-1\");\n+    t!(format!(\"{:d}\", -1i8), \"-1\");\n+    t!(format!(\"{:d}\", -1i16), \"-1\");\n+    t!(format!(\"{:d}\", -1i32), \"-1\");\n+    t!(format!(\"{:d}\", -1i64), \"-1\");\n+    t!(format!(\"{:t}\", 1i), \"1\");\n+    t!(format!(\"{:t}\", 1i8), \"1\");\n+    t!(format!(\"{:t}\", 1i16), \"1\");\n+    t!(format!(\"{:t}\", 1i32), \"1\");\n+    t!(format!(\"{:t}\", 1i64), \"1\");\n+    t!(format!(\"{:x}\", 1i), \"1\");\n+    t!(format!(\"{:x}\", 1i8), \"1\");\n+    t!(format!(\"{:x}\", 1i16), \"1\");\n+    t!(format!(\"{:x}\", 1i32), \"1\");\n+    t!(format!(\"{:x}\", 1i64), \"1\");\n+    t!(format!(\"{:X}\", 1i), \"1\");\n+    t!(format!(\"{:X}\", 1i8), \"1\");\n+    t!(format!(\"{:X}\", 1i16), \"1\");\n+    t!(format!(\"{:X}\", 1i32), \"1\");\n+    t!(format!(\"{:X}\", 1i64), \"1\");\n+    t!(format!(\"{:o}\", 1i), \"1\");\n+    t!(format!(\"{:o}\", 1i8), \"1\");\n+    t!(format!(\"{:o}\", 1i16), \"1\");\n+    t!(format!(\"{:o}\", 1i32), \"1\");\n+    t!(format!(\"{:o}\", 1i64), \"1\");\n+\n+    t!(format!(\"{:u}\", 1u), \"1\");\n+    t!(format!(\"{:u}\", 1u8), \"1\");\n+    t!(format!(\"{:u}\", 1u16), \"1\");\n+    t!(format!(\"{:u}\", 1u32), \"1\");\n+    t!(format!(\"{:u}\", 1u64), \"1\");\n+    t!(format!(\"{:t}\", 1u), \"1\");\n+    t!(format!(\"{:t}\", 1u8), \"1\");\n+    t!(format!(\"{:t}\", 1u16), \"1\");\n+    t!(format!(\"{:t}\", 1u32), \"1\");\n+    t!(format!(\"{:t}\", 1u64), \"1\");\n+    t!(format!(\"{:x}\", 1u), \"1\");\n+    t!(format!(\"{:x}\", 1u8), \"1\");\n+    t!(format!(\"{:x}\", 1u16), \"1\");\n+    t!(format!(\"{:x}\", 1u32), \"1\");\n+    t!(format!(\"{:x}\", 1u64), \"1\");\n+    t!(format!(\"{:X}\", 1u), \"1\");\n+    t!(format!(\"{:X}\", 1u8), \"1\");\n+    t!(format!(\"{:X}\", 1u16), \"1\");\n+    t!(format!(\"{:X}\", 1u32), \"1\");\n+    t!(format!(\"{:X}\", 1u64), \"1\");\n+    t!(format!(\"{:o}\", 1u), \"1\");\n+    t!(format!(\"{:o}\", 1u8), \"1\");\n+    t!(format!(\"{:o}\", 1u16), \"1\");\n+    t!(format!(\"{:o}\", 1u32), \"1\");\n+    t!(format!(\"{:o}\", 1u64), \"1\");\n \n     // Test the flags for formatting integers\n-    t!(ifmt!(\"{:3d}\", 1),  \"  1\");\n-    t!(ifmt!(\"{:>3d}\", 1),  \"  1\");\n-    t!(ifmt!(\"{:>+3d}\", 1), \" +1\");\n-    t!(ifmt!(\"{:<3d}\", 1), \"1  \");\n-    t!(ifmt!(\"{:#d}\", 1), \"1\");\n-    t!(ifmt!(\"{:#x}\", 10), \"0xa\");\n-    t!(ifmt!(\"{:#X}\", 10), \"0xA\");\n-    t!(ifmt!(\"{:#5x}\", 10), \"  0xa\");\n-    t!(ifmt!(\"{:#o}\", 10), \"0o12\");\n-    t!(ifmt!(\"{:08x}\", 10),  \"0000000a\");\n-    t!(ifmt!(\"{:8x}\", 10),   \"       a\");\n-    t!(ifmt!(\"{:<8x}\", 10),  \"a       \");\n-    t!(ifmt!(\"{:>8x}\", 10),  \"       a\");\n-    t!(ifmt!(\"{:#08x}\", 10), \"0x00000a\");\n-    t!(ifmt!(\"{:08d}\", -10), \"-0000010\");\n-    t!(ifmt!(\"{:x}\", -1u8), \"ff\");\n-    t!(ifmt!(\"{:X}\", -1u8), \"FF\");\n-    t!(ifmt!(\"{:t}\", -1u8), \"11111111\");\n-    t!(ifmt!(\"{:o}\", -1u8), \"377\");\n-    t!(ifmt!(\"{:#x}\", -1u8), \"0xff\");\n-    t!(ifmt!(\"{:#X}\", -1u8), \"0xFF\");\n-    t!(ifmt!(\"{:#t}\", -1u8), \"0b11111111\");\n-    t!(ifmt!(\"{:#o}\", -1u8), \"0o377\");\n+    t!(format!(\"{:3d}\", 1),  \"  1\");\n+    t!(format!(\"{:>3d}\", 1),  \"  1\");\n+    t!(format!(\"{:>+3d}\", 1), \" +1\");\n+    t!(format!(\"{:<3d}\", 1), \"1  \");\n+    t!(format!(\"{:#d}\", 1), \"1\");\n+    t!(format!(\"{:#x}\", 10), \"0xa\");\n+    t!(format!(\"{:#X}\", 10), \"0xA\");\n+    t!(format!(\"{:#5x}\", 10), \"  0xa\");\n+    t!(format!(\"{:#o}\", 10), \"0o12\");\n+    t!(format!(\"{:08x}\", 10),  \"0000000a\");\n+    t!(format!(\"{:8x}\", 10),   \"       a\");\n+    t!(format!(\"{:<8x}\", 10),  \"a       \");\n+    t!(format!(\"{:>8x}\", 10),  \"       a\");\n+    t!(format!(\"{:#08x}\", 10), \"0x00000a\");\n+    t!(format!(\"{:08d}\", -10), \"-0000010\");\n+    t!(format!(\"{:x}\", -1u8), \"ff\");\n+    t!(format!(\"{:X}\", -1u8), \"FF\");\n+    t!(format!(\"{:t}\", -1u8), \"11111111\");\n+    t!(format!(\"{:o}\", -1u8), \"377\");\n+    t!(format!(\"{:#x}\", -1u8), \"0xff\");\n+    t!(format!(\"{:#X}\", -1u8), \"0xFF\");\n+    t!(format!(\"{:#t}\", -1u8), \"0b11111111\");\n+    t!(format!(\"{:#o}\", -1u8), \"0o377\");\n \n     // Signed combinations\n-    t!(ifmt!(\"{:+5d}\", 1),  \"   +1\");\n-    t!(ifmt!(\"{:+5d}\", -1), \"   -1\");\n-    t!(ifmt!(\"{:05d}\", 1),   \"00001\");\n-    t!(ifmt!(\"{:05d}\", -1),  \"-0001\");\n-    t!(ifmt!(\"{:+05d}\", 1),  \"+0001\");\n-    t!(ifmt!(\"{:+05d}\", -1), \"-0001\");\n+    t!(format!(\"{:+5d}\", 1),  \"   +1\");\n+    t!(format!(\"{:+5d}\", -1), \"   -1\");\n+    t!(format!(\"{:05d}\", 1),   \"00001\");\n+    t!(format!(\"{:05d}\", -1),  \"-0001\");\n+    t!(format!(\"{:+05d}\", 1),  \"+0001\");\n+    t!(format!(\"{:+05d}\", -1), \"-0001\");\n \n     // Some float stuff\n-    t!(ifmt!(\"{:f}\", 1.0f), \"1\");\n-    t!(ifmt!(\"{:f}\", 1.0f32), \"1\");\n-    t!(ifmt!(\"{:f}\", 1.0f64), \"1\");\n-    t!(ifmt!(\"{:.3f}\", 1.0f), \"1.000\");\n-    t!(ifmt!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n-    t!(ifmt!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n-    t!(ifmt!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n+    t!(format!(\"{:f}\", 1.0f), \"1\");\n+    t!(format!(\"{:f}\", 1.0f32), \"1\");\n+    t!(format!(\"{:f}\", 1.0f64), \"1\");\n+    t!(format!(\"{:.3f}\", 1.0f), \"1.000\");\n+    t!(format!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n+    t!(format!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n+    t!(format!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n+\n+    test_write();\n+    test_print();\n+}\n+\n+// Basic test to make sure that we can invoke the `write!` macro with an\n+// io::Writer instance.\n+fn test_write() {\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n+    use std::rt::io;\n+    use std::str;\n+\n+    let mut buf = MemWriter::new();\n+    write!(&mut buf as &mut io::Writer, \"{}\", 3);\n+    {\n+        let w = &mut buf as &mut io::Writer;\n+        write!(w, \"{foo}\", foo=4);\n+        write!(w, \"{:s}\", \"hello\");\n+        writeln!(w, \"{}\", \"line\");\n+        writeln!(w, \"{foo}\", foo=\"bar\");\n+    }\n+\n+    let s = str::from_bytes_owned(buf.inner());\n+    t!(s, \"34helloline\\nbar\\n\");\n }\n \n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+fn test_print() {\n+    print!(\"hi\");\n+    print!(\"{:?}\", ~[0u8]);\n+    println!(\"hello\");\n+    println!(\"this is a {}\", \"test\");\n+    println!(\"{foo}\", foo=\"bar\");\n+}"}]}