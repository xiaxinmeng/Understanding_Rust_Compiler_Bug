{"sha": "35756fbcf6572d588929fde64fb4027f47e9d0af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NzU2ZmJjZjY1NzJkNTg4OTI5ZmRlNjRmYjQwMjdmNDdlOWQwYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-16T18:47:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:57Z"}, "message": "Move rt::io::stdio from FileStream to a TTY\n\nWe get a little more functionality from libuv for these kinds of streams (things\nlike terminal dimentions), and it also appears to more gracefully handle the\nstream being a window. Beforehand, if you used stdio and hit CTRL+d on a\nprocess, libuv would continually return 0-length successful reads instead of\ninterpreting that the stream was closed.\n\nI was hoping to be able to write tests for this, but currently the testing\ninfrastructure doesn't allow tests with a stdin and a stdout, but this has been\nmanually tested! (not that it means much)", "tree": {"sha": "8a2f0ec01c2eb26f5db34887b8b2335a844d5b9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a2f0ec01c2eb26f5db34887b8b2335a844d5b9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35756fbcf6572d588929fde64fb4027f47e9d0af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35756fbcf6572d588929fde64fb4027f47e9d0af", "html_url": "https://github.com/rust-lang/rust/commit/35756fbcf6572d588929fde64fb4027f47e9d0af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35756fbcf6572d588929fde64fb4027f47e9d0af/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32b07c6a40bd7e1874244096f413096a6e059a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/32b07c6a40bd7e1874244096f413096a6e059a29", "html_url": "https://github.com/rust-lang/rust/commit/32b07c6a40bd7e1874244096f413096a6e059a29"}], "stats": {"total": 469, "additions": 307, "deletions": 162}, "files": [{"sha": "0bc87c77a9c7b0338aee334247bcff87000a3557", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 88, "deletions": 14, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -13,7 +13,7 @@ use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::local::Local;\n-use rt::rtio::{RtioFileStream, IoFactoryObject, IoFactory};\n+use rt::rtio::{IoFactoryObject, IoFactory, RtioTTYObject, RtioTTY};\n use super::{Reader, Writer, io_error};\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n@@ -22,8 +22,8 @@ use super::{Reader, Writer, io_error};\n pub fn stdin() -> StdReader {\n     let stream = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_from_raw_fd(libc::STDIN_FILENO, false)\n-    };\n+        (*io).tty_open(libc::STDIN_FILENO, true, false)\n+    }.unwrap();\n     StdReader { inner: stream }\n }\n \n@@ -36,8 +36,8 @@ pub fn stdin() -> StdReader {\n pub fn stdout() -> StdWriter {\n     let stream = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_from_raw_fd(libc::STDOUT_FILENO, false)\n-    };\n+        (*io).tty_open(libc::STDOUT_FILENO, false, false)\n+    }.unwrap();\n     StdWriter { inner: stream }\n }\n \n@@ -47,8 +47,8 @@ pub fn stdout() -> StdWriter {\n pub fn stderr() -> StdWriter {\n     let stream = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_from_raw_fd(libc::STDERR_FILENO, false)\n-    };\n+        (*io).tty_open(libc::STDERR_FILENO, false, false)\n+    }.unwrap();\n     StdWriter { inner: stream }\n }\n \n@@ -87,7 +87,30 @@ pub fn println_args(fmt: &fmt::Arguments) {\n \n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n-    priv inner: ~RtioFileStream\n+    priv inner: ~RtioTTYObject\n+}\n+\n+impl StdReader {\n+    /// Controls whether this output stream is a \"raw stream\" or simply a normal\n+    /// stream.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if an error\n+    /// happens.\n+    pub fn set_raw(&mut self, raw: bool) {\n+        match self.inner.set_raw(raw) {\n+            Ok(()) => {},\n+            Err(e) => io_error::cond.raise(e),\n+        }\n+    }\n+\n+    /// Resets the mode of this stream back to its original state.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function cannot fail.\n+    pub fn reset_mode(&mut self) { self.inner.reset_mode(); }\n }\n \n impl Reader for StdReader {\n@@ -106,7 +129,50 @@ impl Reader for StdReader {\n \n /// Representation of a writer to a standard output stream\n pub struct StdWriter {\n-    priv inner: ~RtioFileStream\n+    priv inner: ~RtioTTYObject\n+}\n+\n+impl StdWriter {\n+    /// Gets the size of this output window, if possible. This is typically used\n+    /// when the writer is attached to something like a terminal, this is used\n+    /// to fetch the dimensions of the terminal.\n+    ///\n+    /// If successful, returns Some((width, height)).\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if an error\n+    /// happens.\n+    pub fn winsize(&mut self) -> Option<(int, int)> {\n+        match self.inner.get_winsize() {\n+            Ok(p) => Some(p),\n+            Err(e) => {\n+                io_error::cond.raise(e);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Controls whether this output stream is a \"raw stream\" or simply a normal\n+    /// stream.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if an error\n+    /// happens.\n+    pub fn set_raw(&mut self, raw: bool) {\n+        match self.inner.set_raw(raw) {\n+            Ok(()) => {},\n+            Err(e) => io_error::cond.raise(e),\n+        }\n+    }\n+\n+    /// Resets the mode of this stream back to its original state.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function cannot fail.\n+    pub fn reset_mode(&mut self) { self.inner.reset_mode(); }\n }\n \n impl Writer for StdWriter {\n@@ -117,10 +183,18 @@ impl Writer for StdWriter {\n         }\n     }\n \n-    fn flush(&mut self) {\n-        match self.inner.flush() {\n-            Ok(()) => {}\n-            Err(e) => io_error::cond.raise(e)\n-        }\n+    fn flush(&mut self) { /* nothing to do */ }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn smoke() {\n+        // Just make sure we can acquire handles\n+        stdin();\n+        stdout();\n+        stderr();\n     }\n }"}, {"sha": "3c513e263f1670bfaeee7e59990095cd53179d34", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -38,6 +38,7 @@ pub type RtioPipeObject = uvio::UvPipeStream;\n pub type RtioProcessObject = uvio::UvProcess;\n pub type RtioUnixListenerObject = uvio::UvUnixListener;\n pub type RtioUnixAcceptorObject = uvio::UvUnixAcceptor;\n+pub type RtioTTYObject = uvio::UvTTY;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -94,6 +95,8 @@ pub trait IoFactory {\n         Result<~RtioUnixListenerObject, IoError>;\n     fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n         Result<~RtioPipeObject, IoError>;\n+    fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n+            -> Result<~RtioTTYObject, IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -171,3 +174,11 @@ pub trait RtioUnixAcceptor {\n     fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n+\n+pub trait RtioTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError>;\n+    fn reset_mode(&mut self);\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError>;\n+}"}, {"sha": "108aef43c3c9ab8c2ef57351cf2124eb19583181", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{c_int, c_void};\n+use libc::c_int;\n use option::Some;\n use rt::uv::uvll;\n use rt::uv::uvll::UV_ASYNC;\n-use rt::uv::{Watcher, Loop, NativeHandle, AsyncCallback, NullCallback};\n+use rt::uv::{Watcher, Loop, NativeHandle, AsyncCallback};\n use rt::uv::WatcherInterop;\n use rt::uv::status_to_maybe_uv_error;\n \n@@ -47,27 +47,6 @@ impl AsyncWatcher {\n             uvll::async_send(handle);\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        let mut this = self;\n-        let data = this.get_watcher_data();\n-        assert!(data.close_cb.is_none());\n-        data.close_cb = Some(cb);\n-\n-        unsafe {\n-            uvll::close(self.native_handle(), close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_stream_t) {\n-            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = watcher.get_watcher_data();\n-                data.close_cb.take_unwrap()();\n-            }\n-            watcher.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *c_void); }\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_async_t> for AsyncWatcher {"}, {"sha": "9d392583b9e122a2a5312a3becbe39fb9dd24ee9", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -11,7 +11,7 @@\n use libc::c_int;\n use option::Some;\n use rt::uv::uvll;\n-use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback, NullCallback};\n+use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback};\n use rt::uv::status_to_maybe_uv_error;\n \n pub struct IdleWatcher(*uvll::uv_idle_t);\n@@ -71,29 +71,6 @@ impl IdleWatcher {\n             assert!(0 == uvll::idle_stop(self.native_handle()));\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            unsafe {\n-                let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-                {\n-                    let data = idle_watcher.get_watcher_data();\n-                    data.close_cb.take_unwrap()();\n-                }\n-                idle_watcher.drop_watcher_data();\n-                uvll::idle_delete(handle);\n-            }\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {"}, {"sha": "a03264af7e1e9456408bdd4df5ba846813f3c3e3", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -75,6 +75,7 @@ pub mod async;\n pub mod addrinfo;\n pub mod process;\n pub mod pipe;\n+pub mod tty;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -83,6 +84,14 @@ pub struct Loop {\n     priv handle: *uvll::uv_loop_t\n }\n \n+pub struct Handle(*uvll::uv_handle_t);\n+\n+impl Watcher for Handle {}\n+impl NativeHandle<*uvll::uv_handle_t> for Handle {\n+    fn from_native_handle(h: *uvll::uv_handle_t) -> Handle { Handle(h) }\n+    fn native_handle(&self) -> *uvll::uv_handle_t { **self }\n+}\n+\n /// The trait implemented by uv 'watchers' (handles). Watchers are\n /// non-owning wrappers around the uv handles and are not completely\n /// safe - there may be multiple instances for a single underlying\n@@ -160,6 +169,7 @@ pub trait WatcherInterop {\n     fn install_watcher_data(&mut self);\n     fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n     fn drop_watcher_data(&mut self);\n+    fn close(self, cb: NullCallback);\n }\n \n impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n@@ -207,6 +217,24 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n             uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n         }\n     }\n+\n+    fn close(self, cb: NullCallback) {\n+        let mut this = self;\n+        {\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(this.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let mut h: Handle = NativeHandle::from_native_handle(handle);\n+            h.get_watcher_data().close_cb.take_unwrap()();\n+            h.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void) }\n+        }\n+    }\n }\n \n // XXX: Need to define the error constants like EOF so they can be"}, {"sha": "3ab0655071acb7f225f52e94294783f6b1a988fc", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -13,7 +13,7 @@ use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n-use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n+use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle,\n              status_to_maybe_uv_error, vec_to_uv_buf};\n use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec;\n@@ -184,24 +184,6 @@ impl StreamWatcher {\n         }\n     }\n \n-    pub fn close(self, cb: NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_stream_t) {\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = stream_watcher.get_watcher_data().close_cb.take_unwrap();\n-            stream_watcher.drop_watcher_data();\n-            unsafe { free_handle(handle as *c_void) }\n-            cb();\n-        }\n-    }\n \n     pub fn listen(&mut self, cb: ConnectionCallback) -> Result<(), UvError> {\n         {\n@@ -413,25 +395,6 @@ impl UdpWatcher {\n             cb(udp_watcher, status);\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_udp_t) {\n-            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = udp_watcher.get_watcher_data().close_cb.take_unwrap();\n-            udp_watcher.drop_watcher_data();\n-            unsafe { free_handle(handle as *c_void) }\n-            cb();\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {"}, {"sha": "2ad5079e5d546dd7bf65126b492b1081bccb5e5f", "filename": "src/libstd/rt/uv/pipe.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -86,23 +86,6 @@ impl Pipe {\n         }\n     }\n \n-    pub fn close(self, cb: uv::NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern \"C\" fn close_cb(handle: *uvll::uv_pipe_t) {\n-            let mut process: Pipe = uv::NativeHandle::from_native_handle(handle);\n-            process.get_watcher_data().close_cb.take_unwrap()();\n-            process.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *libc::c_void) }\n-        }\n-    }\n }\n \n impl uv::NativeHandle<*uvll::uv_pipe_t> for Pipe {"}, {"sha": "c3417109645d47e57a4887c6d06a2cc890da7327", "filename": "src/libstd/rt/uv/process.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -123,25 +123,6 @@ impl Process {\n     pub fn pid(&self) -> libc::pid_t {\n         unsafe { uvll::process_pid(**self) as libc::pid_t }\n     }\n-\n-    /// Closes this handle, invoking the specified callback once closed\n-    pub fn close(self, cb: uv::NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_process_t) {\n-            let mut process: Process = uv::NativeHandle::from_native_handle(handle);\n-            process.get_watcher_data().close_cb.take_unwrap()();\n-            process.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *libc::c_void) }\n-        }\n-    }\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,"}, {"sha": "fb3c84df39f9b83ddb1bcde12837ecafd304320e", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{c_void, c_int};\n+use libc::c_int;\n use option::Some;\n use rt::uv::uvll;\n-use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback, NullCallback};\n+use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback};\n use rt::uv::status_to_maybe_uv_error;\n \n pub struct TimerWatcher(*uvll::uv_timer_t);\n@@ -53,31 +53,6 @@ impl TimerWatcher {\n             uvll::timer_stop(self.native_handle());\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        let mut watcher = self;\n-        {\n-            let data = watcher.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            uvll::close(watcher.native_handle(), close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_timer_t) {\n-            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = watcher.get_watcher_data();\n-                data.close_cb.take_unwrap()();\n-            }\n-            watcher.drop_watcher_data();\n-            unsafe {\n-                uvll::free_handle(handle as *c_void);\n-            }\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {"}, {"sha": "4c9a08f95bf84974332045d3fe55c4518559063e", "filename": "src/libstd/rt/uv/tty.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftty.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc;\n+\n+use rt::uv;\n+use rt::uv::net;\n+use rt::uv::uvll;\n+\n+/// A process wraps the handle of the underlying uv_process_t.\n+pub struct TTY(*uvll::uv_tty_t);\n+\n+impl uv::Watcher for TTY {}\n+\n+impl TTY {\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn new(loop_: &uv::Loop, fd: libc::c_int, readable: bool) ->\n+            Result<TTY, uv::UvError>\n+    {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TTY) };\n+        assert!(handle.is_not_null());\n+\n+        let ret = unsafe {\n+            uvll::uv_tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n+                              readable as libc::c_int)\n+        };\n+        match ret {\n+            0 => {\n+                let mut ret: TTY = uv::NativeHandle::from_native_handle(handle);\n+                ret.install_watcher_data();\n+                Ok(ret)\n+            }\n+            n => {\n+                unsafe { uvll::free_handle(handle); }\n+                Err(uv::UvError(n))\n+            }\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> net::StreamWatcher {\n+        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn set_mode(&self, raw: bool) -> Result<(), uv::UvError> {\n+        let raw = raw as libc::c_int;\n+        match unsafe { uvll::uv_tty_set_mode(self.native_handle(), raw) } {\n+            0 => Ok(()),\n+            n => Err(uv::UvError(n))\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn reset_mode(&self) {\n+        unsafe { uvll::uv_tty_reset_mode(self.native_handle()) }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)] #[allow(unused_mut)]\n+    pub fn get_winsize(&self) -> Result<(int, int), uv::UvError> {\n+        let mut width: libc::c_int = 0;\n+        let mut height: libc::c_int = 0;\n+        let widthptr: *libc::c_int = &width;\n+        let heightptr: *libc::c_int = &width;\n+\n+        match unsafe { uvll::uv_tty_get_winsize(self.native_handle(),\n+                                                widthptr, heightptr) } {\n+            0 => Ok((width as int, height as int)),\n+            n => Err(uv::UvError(n))\n+        }\n+    }\n+}\n+\n+impl uv::NativeHandle<*uvll::uv_tty_t> for TTY {\n+    fn from_native_handle(handle: *uvll::uv_tty_t) -> TTY {\n+        TTY(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_tty_t {\n+        match self { &TTY(ptr) => ptr }\n+    }\n+}\n+"}, {"sha": "f1a5916ee1389af781c7f9d49ce180e396e1aa65", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -869,6 +869,18 @@ impl IoFactory for UvIoFactory {\n         }\n         return ret;\n     }\n+\n+    fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n+            -> Result<~RtioTTYObject, IoError> {\n+        match tty::TTY::new(self.uv_loop(), fd, readable) {\n+            Ok(tty) => Ok(~UvTTY {\n+                home: get_handle_to_current_scheduler!(),\n+                tty: tty,\n+                close_on_drop: close_on_drop,\n+            }),\n+            Err(e) => Err(uv_error_to_io_error(e))\n+        }\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -1734,6 +1746,34 @@ impl RtioUnixListener for UvUnixListener {\n     }\n }\n \n+pub struct UvTTY {\n+    tty: tty::TTY,\n+    home: SchedHandle,\n+    close_on_drop: bool,\n+}\n+\n+impl HomingIO for UvTTY {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvTTY {\n+    fn drop(&mut self) {\n+        if self.close_on_drop {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                do self.tty.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        } else {\n+            self.tty.drop_watcher_data();\n+            unsafe { uvll::free_handle(self.tty.native_handle()) }\n+        }\n+    }\n+}\n+\n pub struct UvUnixAcceptor {\n     listener: UvUnixListener,\n     incoming: Tube<Result<~RtioPipeObject, IoError>>,\n@@ -1769,6 +1809,40 @@ impl RtioUnixAcceptor for UvUnixAcceptor {\n     }\n }\n \n+impl RtioTTY for UvTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.set_mode(raw) {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn reset_mode(&mut self) {\n+        do self.home_for_io |self_| { self_.tty.reset_mode() }\n+    }\n+\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.get_winsize() {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_mt_newsched_task {"}, {"sha": "8ef1d1768b8c430261962579def0b3b07f2f530d", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -131,6 +131,7 @@ pub type uv_udp_send_t = c_void;\n pub type uv_getaddrinfo_t = c_void;\n pub type uv_process_t = c_void;\n pub type uv_pipe_t = c_void;\n+pub type uv_tty_t = c_void;\n \n pub struct uv_timespec_t {\n     tv_sec: libc::c_long,\n@@ -1107,6 +1108,12 @@ extern {\n     pub fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n     pub fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n                            name: *c_char, cb: uv_connect_cb);\n+    pub fn uv_tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                       readable: c_int) -> c_int;\n+    pub fn uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n+    pub fn uv_tty_reset_mode(tty: *uv_tty_t);\n+    pub fn uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                              height: *c_int) -> c_int;\n \n     // These should all really be constants...\n     #[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;"}, {"sha": "5945fdc3e59b15b24f6ef4b6d5c3248786c5388e", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/35756fbcf6572d588929fde64fb4027f47e9d0af/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=35756fbcf6572d588929fde64fb4027f47e9d0af", "patch": "@@ -214,3 +214,7 @@ rust_AI_V4MAPPED\n uv_pipe_open\n uv_pipe_bind\n uv_pipe_connect\n+uv_tty_init\n+uv_tty_set_mode\n+uv_tty_reset_mode\n+uv_tty_get_winsize"}]}