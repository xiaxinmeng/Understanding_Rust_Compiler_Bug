{"sha": "9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZWNiYTRkYmY4ZTE4ZGRiOWY3ZjkwNmFmNDY4ZTM1YTExZDI4YTQ=", "commit": {"author": {"name": "John Renner", "email": "john@jrenner.net", "date": "2021-02-24T19:25:10Z"}, "committer": {"name": "John Renner", "email": "john@jrenner.net", "date": "2021-02-25T01:13:00Z"}, "message": "Implement line<->block comment assist", "tree": {"sha": "622bbdcad744b43cbc162bf280ca9daf71a9d87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/622bbdcad744b43cbc162bf280ca9daf71a9d87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "html_url": "https://github.com/rust-lang/rust/commit/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/comments", "author": {"login": "djrenren", "id": 634666, "node_id": "MDQ6VXNlcjYzNDY2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/634666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/djrenren", "html_url": "https://github.com/djrenren", "followers_url": "https://api.github.com/users/djrenren/followers", "following_url": "https://api.github.com/users/djrenren/following{/other_user}", "gists_url": "https://api.github.com/users/djrenren/gists{/gist_id}", "starred_url": "https://api.github.com/users/djrenren/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/djrenren/subscriptions", "organizations_url": "https://api.github.com/users/djrenren/orgs", "repos_url": "https://api.github.com/users/djrenren/repos", "events_url": "https://api.github.com/users/djrenren/events{/privacy}", "received_events_url": "https://api.github.com/users/djrenren/received_events", "type": "User", "site_admin": false}, "committer": {"login": "djrenren", "id": 634666, "node_id": "MDQ6VXNlcjYzNDY2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/634666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/djrenren", "html_url": "https://github.com/djrenren", "followers_url": "https://api.github.com/users/djrenren/followers", "following_url": "https://api.github.com/users/djrenren/following{/other_user}", "gists_url": "https://api.github.com/users/djrenren/gists{/gist_id}", "starred_url": "https://api.github.com/users/djrenren/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/djrenren/subscriptions", "organizations_url": "https://api.github.com/users/djrenren/orgs", "repos_url": "https://api.github.com/users/djrenren/repos", "events_url": "https://api.github.com/users/djrenren/events{/privacy}", "received_events_url": "https://api.github.com/users/djrenren/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a307e4f31f3a66797628cee0645a38216398d9bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a307e4f31f3a66797628cee0645a38216398d9bd", "html_url": "https://github.com/rust-lang/rust/commit/a307e4f31f3a66797628cee0645a38216398d9bd"}], "stats": {"total": 432, "additions": 427, "deletions": 5}, "files": [{"sha": "7cf5f3643cd2aec535ef84208e3c85d5e97c6edc", "filename": "crates/ide_assists/src/handlers/convert_comment_block.rs", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "patch": "@@ -0,0 +1,416 @@\n+use ast::{Comment, CommentShape};\n+use itertools::Itertools;\n+use std::convert::identity;\n+use syntax::{\n+    ast::{self, edit::IndentLevel, CommentKind, Whitespace},\n+    AstToken, Direction, SyntaxElement, TextRange,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+/// Assist: line_to_block\n+///\n+/// Converts comments between block and single-line form\n+///\n+/// ```\n+///    // Multi-line\n+///    // comment\n+/// ```\n+/// ->\n+/// ```\n+///   /**\n+///   Multi-line\n+///   comment\n+///   */\n+/// ```\n+pub(crate) fn convert_comment_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    if let Some(comment) = ctx.find_token_at_offset::<ast::Comment>() {\n+        // Only allow comments which are alone on their line\n+        if let Some(prev) = comment.syntax().prev_token() {\n+            if Whitespace::cast(prev).filter(|w| w.text().contains('\\n')).is_none() {\n+                return None;\n+            }\n+        }\n+\n+        return match comment.kind().shape {\n+            ast::CommentShape::Block => block_to_line(acc, comment),\n+            ast::CommentShape::Line => line_to_block(acc, comment),\n+        };\n+    }\n+\n+    return None;\n+}\n+\n+fn block_to_line(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n+    let indentation = IndentLevel::from_token(comment.syntax());\n+    let line_prefix =\n+        comment_kind_prefix(CommentKind { shape: CommentShape::Line, ..comment.kind() });\n+\n+    let text = comment.text();\n+    let text = &text[comment.prefix().len()..(text.len() - \"*/\".len())].trim();\n+\n+    let lines = text.lines().peekable();\n+\n+    let indent_spaces = indentation.to_string();\n+    let output = lines\n+        .map(|l| l.trim_start_matches(&indent_spaces))\n+        .map(|l| {\n+            // Don't introduce trailing whitespace\n+            if l.is_empty() {\n+                line_prefix.to_string()\n+            } else {\n+                format!(\"{} {}\", line_prefix, l.trim_start_matches(&indent_spaces))\n+            }\n+        })\n+        .join(&format!(\"\\n{}\", indent_spaces));\n+\n+    let target = comment.syntax().text_range();\n+    acc.add(\n+        AssistId(\"block_to_line\", AssistKind::RefactorRewrite),\n+        \"Replace block comment with line comments\",\n+        target,\n+        |edit| edit.replace(target, output),\n+    )\n+}\n+\n+fn line_to_block(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n+    // Find all the comments we'll be collapsing into a block\n+    let comments = relevant_line_comments(&comment);\n+\n+    // Establish the target of our edit based on the comments we found\n+    let target = TextRange::new(\n+        comments[0].syntax().text_range().start(),\n+        comments.last().unwrap().syntax().text_range().end(),\n+    );\n+\n+    // We pick a single indentation level for the whole block comment based on the\n+    // comment where the assist was invoked. This will be prepended to the\n+    // contents of each line comment when they're put into the block comment.\n+    let indentation = IndentLevel::from_token(&comment.syntax());\n+\n+    let block_comment_body =\n+        comments.into_iter().map(|c| line_comment_text(indentation, c)).join(\"\\n\");\n+\n+    let block_prefix =\n+        comment_kind_prefix(CommentKind { shape: CommentShape::Block, ..comment.kind() });\n+\n+    let output = format!(\"{}\\n{}\\n{}*/\", block_prefix, block_comment_body, indentation.to_string());\n+\n+    acc.add(\n+        AssistId(\"line_to_block\", AssistKind::RefactorRewrite),\n+        \"Replace line comments with a single block comment\",\n+        target,\n+        |edit| edit.replace(target, output),\n+    )\n+}\n+\n+/// The line -> block assist can  be invoked from anywhere within a sequence of line comments.\n+/// relevant_line_comments crawls backwards and forwards finding the complete sequence of comments that will\n+/// be joined.\n+fn relevant_line_comments(comment: &ast::Comment) -> Vec<Comment> {\n+    // The prefix identifies the kind of comment we're dealing with\n+    let prefix = comment.prefix();\n+    let same_prefix = |c: &ast::Comment| c.prefix() == prefix;\n+\n+    // These tokens are allowed to exist between comments\n+    let skippable = |not: &SyntaxElement| {\n+        not.clone()\n+            .into_token()\n+            .and_then(Whitespace::cast)\n+            .map(|w| !w.spans_multiple_lines())\n+            .unwrap_or(false)\n+    };\n+\n+    // Find all preceding comments (in reverse order) that have the same prefix\n+    let prev_comments = comment\n+        .syntax()\n+        .siblings_with_tokens(Direction::Prev)\n+        .filter(|s| !skippable(s))\n+        .map(|not| not.into_token().and_then(Comment::cast).filter(same_prefix))\n+        .take_while(|opt_com| opt_com.is_some())\n+        .filter_map(identity)\n+        .skip(1); // skip the first element so we don't duplicate it in next_comments\n+\n+    let next_comments = comment\n+        .syntax()\n+        .siblings_with_tokens(Direction::Next)\n+        .filter(|s| !skippable(s))\n+        .map(|not| not.into_token().and_then(Comment::cast).filter(same_prefix))\n+        .take_while(|opt_com| opt_com.is_some())\n+        .filter_map(identity);\n+\n+    let mut comments: Vec<_> = prev_comments.collect();\n+    comments.reverse();\n+    comments.extend(next_comments);\n+    comments\n+}\n+\n+// Line comments usually begin with a single space character following the prefix as seen here:\n+//^\n+// But comments can also include indented text:\n+//    > Hello there\n+//\n+// We handle this by stripping *AT MOST* one space character from the start of the line\n+// This has its own problems because it can cause alignment issues:\n+//\n+//              /*\n+// a      ----> a\n+//b       ----> b\n+//              */\n+//\n+// But since such comments aren't idiomatic we're okay with this.\n+fn line_comment_text(indentation: IndentLevel, comm: ast::Comment) -> String {\n+    let contents = trim_one(comm.text().strip_prefix(comm.prefix()).unwrap()).to_owned();\n+\n+    // Don't add the indentation if the line is empty\n+    if contents.is_empty() {\n+        contents\n+    } else {\n+        indentation.to_string() + &contents\n+    }\n+}\n+\n+fn trim_one(text: &str) -> &str {\n+    if text.starts_with(' ') {\n+        &text[1..]\n+    } else {\n+        text\n+    }\n+}\n+\n+fn comment_kind_prefix(ck: ast::CommentKind) -> &'static str {\n+    use ast::CommentPlacement::{Inner, Outer};\n+    use ast::CommentShape::{Block, Line};\n+    match (ck.shape, ck.doc) {\n+        (Line, Some(Inner)) => \"//!\",\n+        (Line, Some(Outer)) => \"///\",\n+        (Line, None) => \"//\",\n+        (Block, Some(Inner)) => \"/*!\",\n+        (Block, Some(Outer)) => \"/**\",\n+        (Block, None) => \"/*\",\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn single_line_to_block() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+// line$0 comment\n+fn main() {\n+    foo();\n+}\n+\"#,\n+            r#\"\n+/*\n+line comment\n+*/\n+fn main() {\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_to_block_indented() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    // line$0 comment\n+    foo();\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    /*\n+    line comment\n+    */\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn multiline_to_block() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    // above\n+    // line$0 comment\n+    //\n+    // below\n+    foo();\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    /*\n+    above\n+    line comment\n+\n+    below\n+    */\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn end_of_line_to_block() {\n+        check_assist_not_applicable(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    foo(); // end-of-line$0 comment\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_different_kinds() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    /// different prefix\n+    // line$0 comment\n+    // below\n+    foo();\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    /// different prefix\n+    /*\n+    line comment\n+    below\n+    */\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_separate_chunks() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    // different chunk\n+\n+    // line$0 comment\n+    // below\n+    foo();\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    // different chunk\n+\n+    /*\n+    line comment\n+    below\n+    */\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn doc_block_comment_to_lines() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+/**\n+ hi$0 there\n+*/\n+\"#,\n+            r#\"\n+/// hi there\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn block_comment_to_lines() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+/*\n+ hi$0 there\n+*/\n+\"#,\n+            r#\"\n+// hi there\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inner_doc_block_to_lines() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+/*!\n+ hi$0 there\n+*/\n+\"#,\n+            r#\"\n+//! hi there\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn block_to_lines_indent() {\n+        check_assist(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    /*!\n+    hi$0 there\n+\n+    ```\n+      code_sample\n+    ```\n+    */\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    //! hi there\n+    //!\n+    //! ```\n+    //!   code_sample\n+    //! ```\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn end_of_line_block_to_line() {\n+        check_assist_not_applicable(\n+            convert_comment_block,\n+            r#\"\n+fn main() {\n+    foo(); /* end-of-line$0 comment */\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "b9799b9d5aaf8156434ba51942e23429e0e81fd6", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "patch": "@@ -115,6 +115,7 @@ mod handlers {\n     mod auto_import;\n     mod change_visibility;\n     mod convert_integer_literal;\n+    mod convert_comment_block;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_function;\n@@ -176,6 +177,7 @@ mod handlers {\n             auto_import::auto_import,\n             change_visibility::change_visibility,\n             convert_integer_literal::convert_integer_literal,\n+            convert_comment_block::convert_comment_block,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             move_module_to_file::move_module_to_file,"}, {"sha": "0b3b76d4a7daa149623e0041c1fe5b713da5c341", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "patch": "@@ -595,11 +595,14 @@ impl ops::Add<u8> for IndentLevel {\n \n impl IndentLevel {\n     pub fn from_node(node: &SyntaxNode) -> IndentLevel {\n-        let first_token = match node.first_token() {\n-            Some(it) => it,\n+        match node.first_token() {\n+            Some(it) => Self::from_token(&it),\n             None => return IndentLevel(0),\n-        };\n-        for ws in prev_tokens(first_token).filter_map(ast::Whitespace::cast) {\n+        }\n+    }\n+\n+    pub fn from_token(token: &SyntaxToken) -> IndentLevel {\n+        for ws in prev_tokens(token.clone()).filter_map(ast::Whitespace::cast) {\n             let text = ws.syntax().text();\n             if let Some(pos) = text.rfind('\\n') {\n                 let level = text[pos + 1..].chars().count() / 4;"}, {"sha": "977eb818199a3a6aa42acadd3c5e16b0918fc19b", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eecba4dbf8e18ddb9f7f906af468e35a11d28a4/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=9eecba4dbf8e18ddb9f7f906af468e35a11d28a4", "patch": "@@ -85,8 +85,9 @@ pub enum CommentPlacement {\n }\n \n impl CommentKind {\n-    const BY_PREFIX: [(&'static str, CommentKind); 8] = [\n+    const BY_PREFIX: [(&'static str, CommentKind); 9] = [\n         (\"/**/\", CommentKind { shape: CommentShape::Block, doc: None }),\n+        (\"/***\", CommentKind { shape: CommentShape::Block, doc: None }),\n         (\"////\", CommentKind { shape: CommentShape::Line, doc: None }),\n         (\"///\", CommentKind { shape: CommentShape::Line, doc: Some(CommentPlacement::Outer) }),\n         (\"//!\", CommentKind { shape: CommentShape::Line, doc: Some(CommentPlacement::Inner) }),"}]}