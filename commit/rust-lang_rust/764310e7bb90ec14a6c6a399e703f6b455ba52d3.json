{"sha": "764310e7bb90ec14a6c6a399e703f6b455ba52d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NDMxMGU3YmI5MGVjMTRhNmM2YTM5OWU3MDNmNmI0NTViYTUyZDM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-20T19:13:36Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-06T11:16:56Z"}, "message": "introduce an ADTDef struct for struct/enum definitions", "tree": {"sha": "fbb64878f078b667dd1163109787883216196afb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbb64878f078b667dd1163109787883216196afb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/764310e7bb90ec14a6c6a399e703f6b455ba52d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/764310e7bb90ec14a6c6a399e703f6b455ba52d3", "html_url": "https://github.com/rust-lang/rust/commit/764310e7bb90ec14a6c6a399e703f6b455ba52d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/764310e7bb90ec14a6c6a399e703f6b455ba52d3/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03ee3f5c204cb9b20c58a5cd2d61dc792727dad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/03ee3f5c204cb9b20c58a5cd2d61dc792727dad7", "html_url": "https://github.com/rust-lang/rust/commit/03ee3f5c204cb9b20c58a5cd2d61dc792727dad7"}], "stats": {"total": 1204, "additions": 654, "deletions": 550}, "files": [{"sha": "b54e7707f6315bf2eaa9d095ac9e68cc3492255d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -222,6 +222,12 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n+pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> &'tcx ty::ADTDef<'tcx> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_adt_def(&*cdata, def.node, tcx)\n+}\n+\n pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n                             -> ty::GenericPredicates<'tcx>\n {"}, {"sha": "7e955ad7338c14fd32ffdc1d6ca55534351d7ce9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -390,6 +390,13 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn get_adt_def<'tcx>(cdata: Cmd,\n+                         item_id: ast::NodeId,\n+                         tcx: &ty::ctxt<'tcx>) -> &'tcx ty::ADTDef<'tcx>\n+{\n+    tcx.intern_adt_def(ast::DefId { krate: cdata.cnum, node: item_id })\n+}\n+\n pub fn get_predicates<'tcx>(cdata: Cmd,\n                             item_id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)"}, {"sha": "679213874f9646da6b33f6b263dc85ffa82b89a8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -468,9 +468,10 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'c' => return tcx.types.char,\n       't' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def_(st, NominalType, conv);\n+        let did = parse_def_(st, NominalType, conv);\n         let substs = parse_substs_(st, conv);\n         assert_eq!(next(st), ']');\n+        let def = st.tcx.lookup_adt_def(did);\n         return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n@@ -558,7 +559,8 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           let did = parse_def_(st, NominalType, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return st.tcx.mk_struct(did, st.tcx.mk_substs(substs));\n+          let def = st.tcx.lookup_adt_def(did);\n+          return st.tcx.mk_struct(def, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');"}, {"sha": "88666be6c2cc2598f254861b4b50299b121a7db9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -86,7 +86,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             }\n         }\n         ty::TyEnum(def, substs) => {\n-            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n+            mywrite!(w, \"t[{}|\", (cx.ds)(def.did));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n@@ -138,7 +138,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n         }\n         ty::TyStruct(def, substs) => {\n-            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n+            mywrite!(w, \"a[{}|\", (cx.ds)(def.did));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }"}, {"sha": "4ee8f403e428274f9ce7d0c1ebd96b5bb6de1ca5", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -546,8 +546,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n-        ty::TyStruct(did, _) |\n-        ty::TyEnum(did, _) if v.tcx.has_dtor(did) => {\n+        ty::TyStruct(def, _) |\n+        ty::TyEnum(def, _) if def.has_dtor(v.tcx) => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,"}, {"sha": "e7a349265ba985374155df79e07c1797a2b474c4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -234,10 +234,10 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n-                if let ty::TyEnum(def_id, _) = pat_ty.sty {\n+                if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n-                        if cx.tcx.enum_variants(def_id).iter().any(|variant|\n+                        if cx.tcx.enum_variants(edef.did).iter().any(|variant|\n                             variant.name == ident.node.name\n                                 && variant.args.is_empty()\n                         ) {\n@@ -501,8 +501,8 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n ///\n /// left_ty: struct X { a: (bool, &'static str), b: usize}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n-                     pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n+fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n+                              pats: Vec<&Pat>, left_ty: Ty<'tcx>) -> P<Pat> {\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n@@ -511,9 +511,9 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n                 &Variant(vid) =>\n-                    (vid, cx.tcx.enum_variant_with_id(cid, vid).arg_names.is_some()),\n+                    (vid, cx.tcx.enum_variant_with_id(cid.did, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid, !cx.tcx.is_tuple_struct(cid))\n+                    (cid.did, !cid.is_tuple_struct(cx.tcx))\n             };\n             if is_structure {\n                 let fields = cx.tcx.lookup_struct_fields(vid);\n@@ -606,8 +606,8 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n             _ => vec!(Single)\n         },\n \n-        ty::TyEnum(eid, _) =>\n-            cx.tcx.enum_variants(eid)\n+        ty::TyEnum(edef, _) =>\n+            cx.tcx.enum_variants(edef.did)\n                 .iter()\n                 .map(|va| Variant(va.id))\n                 .collect(),\n@@ -817,13 +817,13 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n             ty::TyStr => 0,\n             _ => 1\n         },\n-        ty::TyEnum(eid, _) => {\n+        ty::TyEnum(edef, _) => {\n             match *ctor {\n-                Variant(id) => cx.tcx.enum_variant_with_id(eid, id).args.len(),\n+                Variant(id) => cx.tcx.enum_variant_with_id(edef.did, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n-        ty::TyStruct(cid, _) => cx.tcx.lookup_struct_fields(cid).len(),\n+        ty::TyStruct(cdef, _) => cx.tcx.lookup_struct_fields(cdef.did).len(),\n         ty::TyArray(_, n) => n,\n         _ => 0\n     }"}, {"sha": "7899f928e9d153f4985417de405c6e0cefc5575f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -101,8 +101,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n         match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(id, _) => {\n-                let fields = self.tcx.lookup_struct_fields(id);\n+            ty::TyStruct(def, _) => {\n+                let fields = self.tcx.lookup_struct_fields(def.did);\n                 let field_id = fields.iter()\n                     .find(|field| field.name == name).unwrap().id;\n                 self.live_symbols.insert(field_id.node);\n@@ -113,8 +113,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n         match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(id, _) => {\n-                let fields = self.tcx.lookup_struct_fields(id);\n+            ty::TyStruct(def, _) => {\n+                let fields = self.tcx.lookup_struct_fields(def.did);\n                 let field_id = fields[idx].id;\n                 self.live_symbols.insert(field_id.node);\n             },"}, {"sha": "8f63aca0dd69a31588fb0c7e50060c4d2043187d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -695,8 +695,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // Select just those fields of the `with`\n         // expression that will actually be used\n         let with_fields = match with_cmt.ty.sty {\n-            ty::TyStruct(did, substs) => {\n-                self.tcx().struct_fields(did, substs)\n+            ty::TyStruct(def, substs) => {\n+                self.tcx().struct_fields(def.did, substs)\n             }\n             _ => {\n                 // the base expression should always evaluate to a\n@@ -708,7 +708,6 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         with_expr.span,\n                         \"with expression doesn't evaluate to a struct\");\n                 }\n-                assert!(self.tcx().sess.has_errors());\n                 vec!()\n             }\n         };"}, {"sha": "8ff81635416a4b65df7e83eda7de7bf03315d968", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -53,15 +53,15 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n         ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n         ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::TyEnum(def_id, _) => Some(EnumSimplifiedType(def_id)),\n+        ty::TyEnum(def, _) => Some(EnumSimplifiedType(def.did)),\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(VecSimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n         ty::TyTrait(ref trait_info) => {\n             Some(TraitSimplifiedType(trait_info.principal_def_id()))\n         }\n-        ty::TyStruct(def_id, _) => {\n-            Some(StructSimplifiedType(def_id))\n+        ty::TyStruct(def, _) => {\n+            Some(StructSimplifiedType(def.did))\n         }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we"}, {"sha": "84fc2f7b2e5401e9ebfd6d3225174be6570d72a3", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -144,10 +144,10 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n-            ty::TyEnum(def_id, substs) |\n-            ty::TyStruct(def_id, substs) => {\n-                let item_scheme = self.tcx().lookup_item_type(def_id);\n-                self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n+            ty::TyEnum(def, substs) |\n+            ty::TyStruct(def, substs) => {\n+                let item_scheme = def.type_scheme(self.tcx());\n+                self.accumulate_from_adt(ty, def.did, &item_scheme.generics, substs)\n             }\n \n             ty::TyArray(t, _) |"}, {"sha": "1261f10aaffee1ea6cbacf22cdc2f37e515d57c0", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -415,8 +415,8 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(did, _) => {\n-                    tcx.lookup_struct_fields(did)\n+                ty::TyStruct(def, _) => {\n+                    tcx.lookup_struct_fields(def.did)\n                         .iter()\n                         .find(|f| f.name == field.node.name)\n                         .unwrap_or_else(|| {\n@@ -432,8 +432,8 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(did, _) => {\n-                    tcx.lookup_struct_fields(did)\n+                ty::TyStruct(def, _) => {\n+                    tcx.lookup_struct_fields(def.did)\n                         .get(field.node)\n                         .unwrap_or_else(|| {\n                             tcx.sess.span_bug(field.span,\n@@ -450,8 +450,8 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprStruct(_, ref expr_fields, _) => {\n             let type_ = tcx.expr_ty(e);\n             match type_.sty {\n-                ty::TyStruct(did, _) => {\n-                    let struct_fields = tcx.lookup_struct_fields(did);\n+                ty::TyStruct(def, _) => {\n+                    let struct_fields = tcx.lookup_struct_fields(def.did);\n                     // check the stability of each field that appears\n                     // in the construction expression.\n                     for field in expr_fields {\n@@ -505,11 +505,11 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let did = match tcx.pat_ty_opt(pat) {\n-        Some(&ty::TyS { sty: ty::TyStruct(did, _), .. }) => did,\n+    let def = match tcx.pat_ty_opt(pat) {\n+        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) => def,\n         Some(_) | None => return,\n     };\n-    let struct_fields = tcx.lookup_struct_fields(did);\n+    let struct_fields = tcx.lookup_struct_fields(def.did);\n     match pat.node {\n         // Foo(a, b, c)\n         ast::PatEnum(_, Some(ref pat_fields)) => {"}, {"sha": "e9bd6304fcad460ae57b14112d8fd095331831e3", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -278,8 +278,8 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) =>\n-            tcx.has_attr(def_id, \"fundamental\"),\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.is_fundamental()\n+            ,\n         ty::TyTrait(ref data) =>\n             tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n         _ =>\n@@ -316,9 +316,9 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n             infer_is_local.0\n         }\n \n-        ty::TyEnum(def_id, _) |\n-        ty::TyStruct(def_id, _) => {\n-            def_id.krate == ast::LOCAL_CRATE\n+        ty::TyEnum(def, _) |\n+        ty::TyStruct(def, _) => {\n+            def.did.krate == ast::LOCAL_CRATE\n         }\n \n         ty::TyBox(_) => { // Box<T>"}, {"sha": "fee1c83ba2cce8694a1d16fdeaeba81961807a7a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1721,17 +1721,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ok_if(substs.upvar_tys.clone())\n             }\n \n-            ty::TyStruct(def_id, substs) => {\n+            ty::TyStruct(def, substs) => {\n                 let types: Vec<Ty> =\n-                    self.tcx().struct_fields(def_id, substs).iter()\n-                                                                 .map(|f| f.mt.ty)\n-                                                                 .collect();\n+                    self.tcx().struct_fields(def.did, substs).iter()\n+                                                             .map(|f| f.mt.ty)\n+                                                             .collect();\n                 nominal(bound, types)\n             }\n \n-            ty::TyEnum(def_id, substs) => {\n+            ty::TyEnum(def, substs) => {\n                 let types: Vec<Ty> =\n-                    self.tcx().substd_enum_variants(def_id, substs)\n+                    self.tcx().substd_enum_variants(def.did, substs)\n                     .iter()\n                     .flat_map(|variant| &variant.args)\n                     .cloned()\n@@ -1861,25 +1861,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::TyStruct(def_id, substs)\n-                if Some(def_id) == self.tcx().lang_items.phantom_data() =>\n-            {\n+            ty::TyStruct(def, substs) if def.is_phantom_data() => {\n                 substs.types.get_slice(TypeSpace).to_vec()\n             }\n \n-            ty::TyStruct(def_id, substs) => {\n-                self.tcx().struct_fields(def_id, substs)\n+            ty::TyStruct(def, substs) => {\n+                self.tcx().struct_fields(def.did, substs)\n                           .iter()\n                           .map(|f| f.mt.ty)\n                           .collect()\n             }\n \n-            ty::TyEnum(def_id, substs) => {\n-                self.tcx().substd_enum_variants(def_id, substs)\n-                          .iter()\n-                          .flat_map(|variant| &variant.args)\n-                          .map(|&ty| ty)\n-                          .collect()\n+            ty::TyEnum(def, substs) => {\n+                self.tcx().substd_enum_variants(def.did, substs)\n+                    .iter()\n+                    .flat_map(|variant| &variant.args)\n+                    .map(|&ty| ty)\n+                    .collect()\n             }\n         }\n     }\n@@ -2523,9 +2521,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyStruct(def_id, substs_a), &ty::TyStruct(_, substs_b)) => {\n-                let fields = tcx.lookup_struct_fields(def_id).iter().map(|f| {\n-                    tcx.lookup_field_type_unsubstituted(def_id, f.id)\n+            (&ty::TyStruct(def, substs_a), &ty::TyStruct(_, substs_b)) => {\n+                let fields = tcx.lookup_struct_fields(def.did).iter().map(|f| {\n+                    tcx.lookup_field_type_unsubstituted(def.did, f.id)\n                 }).collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n@@ -2572,7 +2570,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let param_b = *substs_b.types.get(TypeSpace, i);\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n                 }\n-                let new_struct = tcx.mk_struct(def_id, tcx.mk_substs(new_substs));\n+                let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n                     return Err(Unimplemented);"}, {"sha": "9b5943e7d3035568b8033ccbeac3c44b790d734f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 268, "deletions": 85, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -721,6 +721,7 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     trait_defs: TypedArena<TraitDef<'tcx>>,\n+    adt_defs: TypedArena<ADTDef<'tcx>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -732,7 +733,8 @@ impl<'tcx> CtxtArenas<'tcx> {\n             region: TypedArena::new(),\n             stability: TypedArena::new(),\n \n-            trait_defs: TypedArena::new()\n+            trait_defs: TypedArena::new(),\n+            adt_defs: TypedArena::new()\n         }\n     }\n }\n@@ -847,6 +849,7 @@ pub struct ctxt<'tcx> {\n \n     pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n+    pub adt_defs: RefCell<DefIdMap<&'tcx ADTDef<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n@@ -1017,6 +1020,13 @@ impl<'tcx> ctxt<'tcx> {\n         interned\n     }\n \n+    pub fn intern_adt_def(&self, did: DefId) -> &'tcx ADTDef<'tcx> {\n+        let def = ADTDef::new(self, did);\n+        let interned = self.arenas.adt_defs.alloc(def);\n+        self.adt_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n     pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n         if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n@@ -1761,12 +1771,12 @@ pub enum TypeVariants<'tcx> {\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n     /// well.\n-    TyEnum(DefId, &'tcx Substs<'tcx>),\n+    TyEnum(&'tcx ADTDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// A structure type, defined with `struct`.\n     ///\n     /// See warning about substitutions for enumerated types.\n-    TyStruct(DefId, &'tcx Substs<'tcx>),\n+    TyStruct(&'tcx ADTDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -2984,18 +2994,18 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         // FIXME: (@jroesch) float this code up\n         let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n \n-        let did = match self_type.sty {\n-            ty::TyStruct(struct_did, substs) => {\n-                let fields = tcx.struct_fields(struct_did, substs);\n+        let adt = match self_type.sty {\n+            ty::TyStruct(struct_def, substs) => {\n+                let fields = tcx.struct_fields(struct_def.did, substs);\n                 for field in &fields {\n                     if infcx.type_moves_by_default(field.mt.ty, span) {\n                         return Err(FieldDoesNotImplementCopy(field.name))\n                     }\n                 }\n-                struct_did\n+                struct_def\n             }\n-            ty::TyEnum(enum_did, substs) => {\n-                let enum_variants = tcx.enum_variants(enum_did);\n+            ty::TyEnum(enum_def, substs) => {\n+                let enum_variants = tcx.enum_variants(enum_def.did);\n                 for variant in enum_variants.iter() {\n                     for variant_arg_type in &variant.args {\n                         let substd_arg_type =\n@@ -3005,12 +3015,12 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                enum_did\n+                enum_def\n             }\n             _ => return Err(TypeIsStructural),\n         };\n \n-        if tcx.has_dtor(did) {\n+        if adt.has_dtor(tcx) {\n             return Err(TypeHasDestructor)\n         }\n \n@@ -3193,6 +3203,100 @@ impl<'tcx> TraitDef<'tcx> {\n \n }\n \n+bitflags! {\n+    flags ADTFlags: u32 {\n+        const NO_ADT_FLAGS        = 0,\n+        const IS_FUNDAMENTAL      = 1 << 0,\n+        const IS_PHANTOM_DATA     = 1 << 1,\n+        const IS_DTORCK           = 1 << 2, // is this a dtorck type?\n+        const IS_DTORCK_VALID     = 1 << 3,\n+    }\n+}\n+\n+/// The definition of an abstract data type - a struct or enum.\n+pub struct ADTDef<'tcx> {\n+    pub did: DefId,\n+    flags: Cell<ADTFlags>,\n+    marker: ::std::marker::PhantomData<&'tcx ()>,\n+}\n+\n+impl<'tcx> PartialEq for ADTDef<'tcx> {\n+    // ADTDef are always interned and this is part of TyS equality\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n+}\n+\n+impl<'tcx> Eq for ADTDef<'tcx> {}\n+\n+impl<'tcx> Hash for ADTDef<'tcx> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const ADTDef).hash(s)\n+    }\n+}\n+\n+impl<'tcx> ADTDef<'tcx> {\n+    fn new(tcx: &ctxt<'tcx>, did: DefId) -> Self {\n+        let mut flags = ADTFlags::NO_ADT_FLAGS;\n+        if tcx.has_attr(did, \"fundamental\") {\n+            flags = flags | ADTFlags::IS_FUNDAMENTAL;\n+        }\n+        if Some(did) == tcx.lang_items.phantom_data() {\n+            flags = flags | ADTFlags::IS_PHANTOM_DATA;\n+        }\n+        ADTDef {\n+            did: did,\n+            flags: Cell::new(flags),\n+            marker: ::std::marker::PhantomData\n+        }\n+    }\n+\n+    fn calculate_dtorck(&'tcx self, tcx: &ctxt<'tcx>) {\n+        if tcx.is_adt_dtorck(self) {\n+            self.flags.set(self.flags.get() | ADTFlags::IS_DTORCK);\n+        }\n+        self.flags.set(self.flags.get() | ADTFlags::IS_DTORCK_VALID)\n+    }\n+\n+    #[inline]\n+    pub fn is_dtorck(&'tcx self, tcx: &ctxt<'tcx>) -> bool {\n+        if !self.flags.get().intersects(ADTFlags::IS_DTORCK_VALID) {\n+            self.calculate_dtorck(tcx)\n+        }\n+        self.flags.get().intersects(ADTFlags::IS_DTORCK)\n+    }\n+\n+    #[inline]\n+    pub fn is_fundamental(&self) -> bool {\n+        self.flags.get().intersects(ADTFlags::IS_FUNDAMENTAL)\n+    }\n+\n+    #[inline]\n+    pub fn is_phantom_data(&self) -> bool {\n+        self.flags.get().intersects(ADTFlags::IS_PHANTOM_DATA)\n+    }\n+\n+    #[inline(never)]\n+    pub fn has_dtor(&self, tcx: &ctxt<'tcx>) -> bool {\n+        tcx.destructor_for_type.borrow().contains_key(&self.did)\n+    }\n+\n+    pub fn is_tuple_struct(&self, tcx: &ctxt<'tcx>) -> bool {\n+        let fields = tcx.lookup_struct_fields(self.did);\n+        !fields.is_empty() && fields.iter().all(|f| f.name == token::special_names::unnamed_field)\n+    }\n+\n+    #[inline]\n+    pub fn type_scheme(&self, tcx: &ctxt<'tcx>) -> TypeScheme<'tcx> {\n+        tcx.lookup_item_type(self.did)\n+    }\n+\n+    #[inline]\n+    pub fn predicates(&self, tcx: &ctxt<'tcx>) -> GenericPredicates<'tcx> {\n+        tcx.lookup_predicates(self.did)\n+    }\n+}\n+\n /// Records the substitutions used to translate the polytype for an\n /// item into the monotype of an item reference.\n #[derive(Clone)]\n@@ -3498,6 +3602,7 @@ impl<'tcx> ctxt<'tcx> {\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DefIdMap()),\n             trait_defs: RefCell::new(DefIdMap()),\n+            adt_defs: RefCell::new(DefIdMap()),\n             predicates: RefCell::new(DefIdMap()),\n             super_predicates: RefCell::new(DefIdMap()),\n             fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n@@ -3679,9 +3784,9 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(&self, did: ast::DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_enum(&self, def: &'tcx ADTDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyEnum(did, substs))\n+        self.mk_ty(TyEnum(def, substs))\n     }\n \n     pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -3781,10 +3886,9 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(&self, struct_id: ast::DefId,\n-                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_struct(&self, def: &'tcx ADTDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyStruct(struct_id, substs))\n+        self.mk_ty(TyStruct(def, substs))\n     }\n \n     pub fn mk_closure(&self,\n@@ -3946,7 +4050,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_empty(&self, cx: &ctxt) -> bool {\n         match self.sty {\n-            TyEnum(did, _) => cx.enum_variants(did).is_empty(),\n+            TyEnum(def, _) => cx.enum_variants(def.did).is_empty(),\n             _ => false\n         }\n     }\n@@ -3987,7 +4091,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_simd(&self, cx: &ctxt) -> bool {\n         match self.sty {\n-            TyStruct(did, _) => cx.lookup_simd(did),\n+            TyStruct(def, _) => cx.lookup_simd(def.did),\n             _ => false\n         }\n     }\n@@ -4003,18 +4107,18 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn simd_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyStruct(did, substs) => {\n-                let fields = cx.lookup_struct_fields(did);\n-                cx.lookup_field_type(did, fields[0].id, substs)\n+            TyStruct(def, substs) => {\n+                let fields = cx.lookup_struct_fields(def.did);\n+                cx.lookup_field_type(def.did, fields[0].id, substs)\n             }\n             _ => panic!(\"simd_type called on invalid type\")\n         }\n     }\n \n     pub fn simd_size(&self, cx: &ctxt) -> usize {\n         match self.sty {\n-            TyStruct(did, _) => {\n-                cx.lookup_struct_fields(did).len()\n+            TyStruct(def, _) => {\n+                cx.lookup_struct_fields(def.did).len()\n             }\n             _ => panic!(\"simd_size called on invalid type\")\n         }\n@@ -4067,8 +4171,8 @@ impl<'tcx> TyS<'tcx> {\n     pub fn ty_to_def_id(&self) -> Option<ast::DefId> {\n         match self.sty {\n             TyTrait(ref tt) => Some(tt.principal_def_id()),\n-            TyStruct(id, _) |\n-            TyEnum(id, _) |\n+            TyStruct(def, _) |\n+            TyEnum(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n         }\n@@ -4275,16 +4379,16 @@ impl<'tcx> TyS<'tcx> {\n                 }\n                 TyStr => TC::None,\n \n-                TyStruct(did, substs) => {\n-                    let flds = cx.struct_fields(did, substs);\n+                TyStruct(def, substs) => {\n+                    let flds = cx.struct_fields(def.did, substs);\n                     let mut res =\n                         TypeContents::union(&flds[..],\n                                             |f| tc_ty(cx, f.mt.ty, cache));\n \n-                    if cx.has_dtor(did) {\n+                    if def.has_dtor(cx) {\n                         res = res | TC::OwnsDtor;\n                     }\n-                    apply_lang_items(cx, did, res)\n+                    apply_lang_items(cx, def.did, res)\n                 }\n \n                 TyClosure(_, ref substs) => {\n@@ -4296,8 +4400,8 @@ impl<'tcx> TyS<'tcx> {\n                                         |ty| tc_ty(cx, *ty, cache))\n                 }\n \n-                TyEnum(did, substs) => {\n-                    let variants = cx.substd_enum_variants(did, substs);\n+                TyEnum(def, substs) => {\n+                    let variants = cx.substd_enum_variants(def.did, substs);\n                     let mut res =\n                         TypeContents::union(&variants[..], |variant| {\n                             TypeContents::union(&variant.args,\n@@ -4306,11 +4410,11 @@ impl<'tcx> TyS<'tcx> {\n                             })\n                         });\n \n-                    if cx.has_dtor(did) {\n+                    if def.has_dtor(cx) {\n                         res = res | TC::OwnsDtor;\n                     }\n \n-                    apply_lang_items(cx, did, res)\n+                    apply_lang_items(cx, def.did, res)\n                 }\n \n                 TyProjection(..) |\n@@ -4431,7 +4535,7 @@ impl<'tcx> TyS<'tcx> {\n \n     // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n     pub fn is_instantiable(&'tcx self, cx: &ctxt<'tcx>) -> bool {\n-        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n+        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<&'tcx ADTDef<'tcx>>,\n                                r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n             debug!(\"type_requires({:?}, {:?})?\",\n                    r_ty, ty);\n@@ -4443,7 +4547,7 @@ impl<'tcx> TyS<'tcx> {\n             return r;\n         }\n \n-        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n+        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<&'tcx ADTDef<'tcx>>,\n                                   r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n             debug!(\"subtypes_require({:?}, {:?})?\",\n                    r_ty, ty);\n@@ -4486,9 +4590,9 @@ impl<'tcx> TyS<'tcx> {\n                     false\n                 }\n \n-                TyStruct(did, substs) => {\n-                    seen.push(did);\n-                    let fields = cx.struct_fields(did, substs);\n+                TyStruct(def, substs) => {\n+                    seen.push(def);\n+                    let fields = cx.struct_fields(def.did, substs);\n                     let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n                     seen.pop().unwrap();\n                     r\n@@ -4506,13 +4610,13 @@ impl<'tcx> TyS<'tcx> {\n                     ts.iter().any(|ty| type_requires(cx, seen, r_ty, *ty))\n                 }\n \n-                TyEnum(ref did, _) if seen.contains(did) => {\n+                TyEnum(ref def, _) if seen.contains(def) => {\n                     false\n                 }\n \n-                TyEnum(did, substs) => {\n-                    seen.push(did);\n-                    let vs = cx.enum_variants(did);\n+                TyEnum(def, substs) => {\n+                    seen.push(def);\n+                    let vs = cx.enum_variants(def.did);\n                     let r = !vs.is_empty() && vs.iter().all(|variant| {\n                         variant.args.iter().any(|aty| {\n                             let sty = aty.subst(cx, substs);\n@@ -4576,12 +4680,12 @@ impl<'tcx> TyS<'tcx> {\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(cx, sp, seen, ty)\n                 }\n-                TyStruct(did, substs) => {\n-                    let fields = cx.struct_fields(did, substs);\n+                TyStruct(def, substs) => {\n+                    let fields = cx.struct_fields(def.did, substs);\n                     find_nonrepresentable(cx, sp, seen, fields.iter().map(|f| f.mt.ty))\n                 }\n-                TyEnum(did, substs) => {\n-                    let vs = cx.enum_variants(did);\n+                TyEnum(def, substs) => {\n+                    let vs = cx.enum_variants(def.did);\n                     let iter = vs.iter()\n                         .flat_map(|variant| &variant.args)\n                         .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n@@ -4597,10 +4701,10 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n \n-        fn same_struct_or_enum_def_id(ty: Ty, did: DefId) -> bool {\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ADTDef<'tcx>) -> bool {\n             match ty.sty {\n-                TyStruct(ty_did, _) | TyEnum(ty_did, _) => {\n-                     ty_did == did\n+                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n+                     ty_def == def\n                 }\n                 _ => false\n             }\n@@ -4635,7 +4739,7 @@ impl<'tcx> TyS<'tcx> {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {\n-                TyStruct(did, _) | TyEnum(did, _) => {\n+                TyStruct(def, _) | TyEnum(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();\n@@ -4650,7 +4754,7 @@ impl<'tcx> TyS<'tcx> {\n \n                         match iter.next() {\n                             Some(&seen_type) => {\n-                                if same_struct_or_enum_def_id(seen_type, did) {\n+                                if same_struct_or_enum(seen_type, def) {\n                                     debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                            seen_type,\n                                            ty);\n@@ -4786,8 +4890,8 @@ impl<'tcx> TyS<'tcx> {\n     // constructors\n     pub fn is_c_like_enum(&self, cx: &ctxt) -> bool {\n         match self.sty {\n-            TyEnum(did, _) => {\n-                let variants = cx.enum_variants(did);\n+            TyEnum(def, _) => {\n+                let variants = cx.enum_variants(def.did);\n                 if variants.is_empty() {\n                     false\n                 } else {\n@@ -4959,7 +5063,7 @@ impl<'tcx> TyS<'tcx> {\n             TyUint(_) | TyFloat(_) | TyStr => self.to_string(),\n             TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            TyEnum(id, _) => format!(\"enum `{}`\", cx.item_path_str(id)),\n+            TyEnum(def, _) => format!(\"enum `{}`\", cx.item_path_str(def.did)),\n             TyBox(_) => \"box\".to_string(),\n             TyArray(_, n) => format!(\"array of {} elements\", n),\n             TySlice(_) => \"slice\".to_string(),\n@@ -4970,8 +5074,8 @@ impl<'tcx> TyS<'tcx> {\n             TyTrait(ref inner) => {\n                 format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n             }\n-            TyStruct(id, _) => {\n-                format!(\"struct `{}`\", cx.item_path_str(id))\n+            TyStruct(def, _) => {\n+                format!(\"struct `{}`\", cx.item_path_str(def.did))\n             }\n             TyClosure(..) => \"closure\".to_string(),\n             TyTuple(_) => \"tuple\".to_string(),\n@@ -5201,18 +5305,18 @@ impl<'tcx> ctxt<'tcx> {\n             (&TyTuple(ref v), None) => v.get(i).cloned(),\n \n \n-            (&TyStruct(def_id, substs), None) => self.lookup_struct_fields(def_id)\n+            (&TyStruct(def, substs), None) => self.lookup_struct_fields(def.did)\n                 .get(i)\n                 .map(|&t| self.lookup_item_type(t.id).ty.subst(self, substs)),\n \n-            (&TyEnum(def_id, substs), Some(variant_def_id)) => {\n-                let variant_info = self.enum_variant_with_id(def_id, variant_def_id);\n+            (&TyEnum(def, substs), Some(variant_def_id)) => {\n+                let variant_info = self.enum_variant_with_id(def.did, variant_def_id);\n                 variant_info.args.get(i).map(|t|t.subst(self, substs))\n             }\n \n-            (&TyEnum(def_id, substs), None) => {\n-                assert!(self.enum_is_univariant(def_id));\n-                let enum_variants = self.enum_variants(def_id);\n+            (&TyEnum(def, substs), None) => {\n+                assert!(self.enum_is_univariant(def.did));\n+                let enum_variants = self.enum_variants(def.did);\n                 let variant_info = &enum_variants[0];\n                 variant_info.args.get(i).map(|t|t.subst(self, substs))\n             }\n@@ -5229,13 +5333,13 @@ impl<'tcx> ctxt<'tcx> {\n                             variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n         match (&ty.sty, variant) {\n-            (&TyStruct(def_id, substs), None) => {\n-                let r = self.lookup_struct_fields(def_id);\n+            (&TyStruct(def, substs), None) => {\n+                let r = self.lookup_struct_fields(def.did);\n                 r.iter().find(|f| f.name == n)\n-                    .map(|&f| self.lookup_field_type(def_id, f.id, substs))\n+                    .map(|&f| self.lookup_field_type(def.did, f.id, substs))\n             }\n-            (&TyEnum(def_id, substs), Some(variant_def_id)) => {\n-                let variant_info = self.enum_variant_with_id(def_id, variant_def_id);\n+            (&TyEnum(def, substs), Some(variant_def_id)) => {\n+                let variant_info = self.enum_variant_with_id(def.did, variant_def_id);\n                 variant_info.arg_names.as_ref()\n                     .expect(\"must have struct enum variant if accessing a named fields\")\n                     .iter().zip(&variant_info.args)\n@@ -5744,10 +5848,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn has_dtor(&self, struct_id: DefId) -> bool {\n-        self.destructor_for_type.borrow().contains_key(&struct_id)\n-    }\n-\n     pub fn with_path<T, F>(&self, id: ast::DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n@@ -5938,6 +6038,14 @@ impl<'tcx> ctxt<'tcx> {\n         )\n     }\n \n+    /// Given the did of a trait, returns its canonical trait ref.\n+    pub fn lookup_adt_def(&self, did: ast::DefId) -> &'tcx ADTDef<'tcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"adt_defs\", did, &self.adt_defs,\n+            || csearch::get_adt_def(self, did)\n+        )\n+    }\n+\n     /// Given the did of an item, returns its full set of predicates.\n     pub fn lookup_predicates(&self, did: ast::DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n@@ -5978,6 +6086,7 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n+        // TODO: remove\n         memoized(&self.repr_hint_cache, did, |did: DefId| {\n             Rc::new(if did.krate == LOCAL_CRATE {\n                 self.get_attrs(did).iter().flat_map(|meta| {\n@@ -6013,7 +6122,7 @@ impl<'tcx> ctxt<'tcx> {\n         self.lookup_field_type_unsubstituted(struct_id, id).subst(self, substs)\n     }\n \n-    // Look up the list of field names and IDs for a given struct.\n+    // Look up the list of field names and IDs for a given struct or struct-variant.\n     // Panics if the id is not bound to a struct.\n     pub fn lookup_struct_fields(&self, did: ast::DefId) -> Vec<FieldTy> {\n         if did.krate == ast::LOCAL_CRATE {\n@@ -6031,11 +6140,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn is_tuple_struct(&self, did: ast::DefId) -> bool {\n-        let fields = self.lookup_struct_fields(did);\n-        !fields.is_empty() && fields.iter().all(|f| f.name == token::special_names::unnamed_field)\n-    }\n-\n     // Returns a list of fields corresponding to the struct's items. trans uses\n     // this. Takes a list of substs with which to instantiate field types.\n     pub fn struct_fields(&self, did: ast::DefId, substs: &Substs<'tcx>)\n@@ -6055,8 +6159,8 @@ impl<'tcx> ctxt<'tcx> {\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        while let TyStruct(def_id, substs) = ty.sty {\n-            match self.struct_fields(def_id, substs).last() {\n+        while let TyStruct(def, substs) = ty.sty {\n+            match self.struct_fields(def.did, substs).last() {\n                 Some(f) => ty = f.mt.ty,\n                 None => break\n             }\n@@ -6074,12 +6178,12 @@ impl<'tcx> ctxt<'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyStruct(a_did, a_substs), &TyStruct(b_did, b_substs)) = (&a.sty, &b.sty) {\n-            if a_did != b_did {\n+        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n+            if a_def != b_def {\n                 break;\n             }\n-            if let Some(a_f) = self.struct_fields(a_did, a_substs).last() {\n-                if let Some(b_f) = self.struct_fields(b_did, b_substs).last() {\n+            if let Some(a_f) = self.struct_fields(a_def.did, a_substs).last() {\n+                if let Some(b_f) = self.struct_fields(b_def.did, b_substs).last() {\n                     a = a_f.mt.ty;\n                     b = b_f.mt.ty;\n                 } else {\n@@ -6452,7 +6556,7 @@ impl<'tcx> ctxt<'tcx> {\n                     }\n                     TyEnum(d, _) => {\n                         byte!(8);\n-                        did(state, d);\n+                        did(state, d.did);\n                     }\n                     TyBox(_) => {\n                         byte!(9);\n@@ -6495,7 +6599,7 @@ impl<'tcx> ctxt<'tcx> {\n                     }\n                     TyStruct(d, _) => {\n                         byte!(18);\n-                        did(state, d);\n+                        did(state, d.did);\n                     }\n                     TyTuple(ref inner) => {\n                         byte!(19);\n@@ -6633,6 +6737,85 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n+\n+\n+    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n+    /// safe for destruction requires it to be alive\n+    fn is_adt_dtorck(&self, adt: &'tcx ADTDef<'tcx>) -> bool {\n+        let dtor_method = match self.destructor_for_type.borrow().get(&adt.did) {\n+            Some(dtor) => *dtor,\n+            None => return false\n+        };\n+        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n+            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n+        });\n+        let generics = adt.type_scheme(self).generics;\n+\n+        // In `impl<'a> Drop ...`, we automatically assume\n+        // `'a` is meaningful and thus represents a bound\n+        // through which we could reach borrowed data.\n+        //\n+        // FIXME (pnkfelix): In the future it would be good to\n+        // extend the language to allow the user to express,\n+        // in the impl signature, that a lifetime is not\n+        // actually used (something like `where 'a: ?Live`).\n+        if generics.has_region_params(subst::TypeSpace) {\n+            debug!(\"typ: {:?} has interesting dtor due to region params\",\n+                   adt);\n+            return true;\n+        }\n+\n+        let mut seen_items = Vec::new();\n+        let mut items_to_inspect = vec![impl_did];\n+        while let Some(item_def_id) = items_to_inspect.pop() {\n+            if seen_items.contains(&item_def_id) {\n+                continue;\n+            }\n+\n+            for pred in self.lookup_predicates(item_def_id).predicates {\n+                let result = match pred {\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        // For now, assume all these where-clauses\n+                        // may give drop implementation capabilty\n+                        // to access borrowed data.\n+                        true\n+                    }\n+\n+                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                        let def_id = t_pred.trait_ref.def_id;\n+                        if self.trait_items(def_id).len() != 0 {\n+                            // If trait has items, assume it adds\n+                            // capability to access borrowed data.\n+                            true\n+                        } else {\n+                            // Trait without items is itself\n+                            // uninteresting from POV of dropck.\n+                            //\n+                            // However, may have parent w/ items;\n+                            // so schedule checking of predicates,\n+                            items_to_inspect.push(def_id);\n+                            // and say \"no capability found\" for now.\n+                            false\n+                        }\n+                    }\n+                };\n+\n+                if result {\n+                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                           adt, pred);\n+                    return true;\n+                }\n+            }\n+\n+            seen_items.push(item_def_id);\n+        }\n+\n+        debug!(\"typ: {:?} is dtorck-safe\", adt);\n+        false\n+    }\n }\n \n /// The category of explicit self."}, {"sha": "05b08b356efdf12ef198f1faf5a1fc16bdd5389a", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -485,11 +485,11 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(a)\n         }\n \n-        (&ty::TyEnum(a_id, a_substs), &ty::TyEnum(b_id, b_substs))\n-            if a_id == b_id =>\n+        (&ty::TyEnum(a_def, a_substs), &ty::TyEnum(b_def, b_substs))\n+            if a_def == b_def =>\n         {\n-            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(tcx.mk_enum(a_id, tcx.mk_substs(substs)))\n+            let substs = try!(relate_item_substs(relation, a_def.did, a_substs, b_substs));\n+            Ok(tcx.mk_enum(a_def, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n@@ -499,11 +499,11 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(tcx.mk_trait(principal, bounds))\n         }\n \n-        (&ty::TyStruct(a_id, a_substs), &ty::TyStruct(b_id, b_substs))\n-            if a_id == b_id =>\n+        (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))\n+            if a_def == b_def =>\n         {\n-            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(tcx.mk_struct(a_id, tcx.mk_substs(substs)))\n+            let substs = try!(relate_item_substs(relation, a_def.did, a_substs, b_substs));\n+            Ok(tcx.mk_struct(a_def, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyClosure(a_id, ref a_substs),"}, {"sha": "24e18099d8b8f392671db422d2325605b141a399", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -366,6 +366,14 @@ impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::ADTDef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            write!(f, \"{}\", tcx.item_path_str(self.did))\n+        })\n+    }\n+}\n+\n impl fmt::Display for ty::BoundRegion {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -648,14 +656,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyEnum(did, substs) | TyStruct(did, substs) => {\n+            TyEnum(def, substs) | TyStruct(def, substs) => {\n                 ty::tls::with(|tcx| {\n-                    if did.krate == ast::LOCAL_CRATE &&\n-                          !tcx.tcache.borrow().contains_key(&did) {\n-                        write!(f, \"{}<..>\", tcx.item_path_str(did))\n+                    if def.did.krate == ast::LOCAL_CRATE &&\n+                          !tcx.tcache.borrow().contains_key(&def.did) {\n+                        write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(f, substs, did, &[],\n-                                      |tcx| tcx.lookup_item_type(did).generics)\n+                        parameterized(f, substs, def.did, &[],\n+                                      |tcx| tcx.lookup_item_type(def.did).generics)\n                     }\n                 })\n             }"}, {"sha": "62cb1f73cf8536d98ebf001e743b39b0969c76eb", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -746,24 +746,22 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyStruct(def_id, _) | ty::TyEnum(def_id, _) => {\n-                        if self.tcx().has_dtor(def_id) {\n-                            // In the case where the owner implements drop, then\n-                            // the path must be initialized to prevent a case of\n-                            // partial reinitialization\n-                            //\n-                            // FIXME (22079): could refactor via hypothetical\n-                            // generalized check_if_path_is_moved\n-                            let loan_path = owned_ptr_base_path_rc(lp_base);\n-                            self.move_data.each_move_of(id, &loan_path, |_, _| {\n-                                self.bccx\n-                                    .report_partial_reinitialization_of_uninitialized_structure(\n-                                        span,\n-                                        &*loan_path);\n-                                false\n-                            });\n-                            return;\n-                        }\n+                    ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor(self.tcx()) => {\n+                        // In the case where the owner implements drop, then\n+                        // the path must be initialized to prevent a case of\n+                        // partial reinitialization\n+                        //\n+                        // FIXME (22079): could refactor via hypothetical\n+                        // generalized check_if_path_is_moved\n+                        let loan_path = owned_ptr_base_path_rc(lp_base);\n+                        self.move_data.each_move_of(id, &loan_path, |_, _| {\n+                            self.bccx\n+                                .report_partial_reinitialization_of_uninitialized_structure(\n+                                    span,\n+                                    &*loan_path);\n+                            false\n+                        });\n+                        return;\n                     },\n                     _ => {},\n                 }"}, {"sha": "b398b6817f7327f4d3eba84a16c704be9b812cf9", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -438,8 +438,8 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyStruct(def_id, ref _substs), None) => {\n-            let fields = tcx.lookup_struct_fields(def_id);\n+        (&ty::TyStruct(def, ref _substs), None) => {\n+            let fields = tcx.lookup_struct_fields(def.did);\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n                     for f in &fields {\n@@ -462,9 +462,9 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyEnum(enum_def_id, substs), ref enum_variant_info) => {\n+        (&ty::TyEnum(enum_def, substs), ref enum_variant_info) => {\n             let variant_info = {\n-                let mut variants = tcx.substd_enum_variants(enum_def_id, substs);\n+                let mut variants = tcx.substd_enum_variants(enum_def.did, substs);\n                 match *enum_variant_info {\n                     Some((variant_def_id, ref _lp2)) =>\n                         variants.iter()"}, {"sha": "308ae42c16f07ec858af34bd18226bebee456f5e", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -179,8 +179,8 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorField(_)) |\n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n-                ty::TyStruct(did, _) | ty::TyEnum(did, _) => {\n-                    if bccx.tcx.has_dtor(did) {\n+                ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+                    if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "1246449327d963db147a34ab73683eecc5c3a5a1", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -136,8 +136,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyStruct(did, _) |\n-                ty::TyEnum(did, _) if bccx.tcx.has_dtor(did) => {\n+                ty::TyStruct(def, _) |\n+                ty::TyEnum(def, _) if def.has_dtor(bccx.tcx) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\"}, {"sha": "3ed359cbc3d0a6591d1043a4e1e6d0e299b93799", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -463,8 +463,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyStruct(did, substs) => {\n-                if !cx.lookup_repr_hints(did).contains(&attr::ReprExtern) {\n+            ty::TyStruct(def, substs) => {\n+                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n                     return FfiUnsafe(\n                         \"found struct without foreign-function-safe \\\n                          representation annotation in foreign module, \\\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                 // We can't completely trust repr(C) markings; make sure the\n                 // fields are actually safe.\n-                let fields = cx.struct_fields(did, substs);\n+                let fields = cx.struct_fields(def.did, substs);\n \n                 if fields.is_empty() {\n                     return FfiUnsafe(\n@@ -488,21 +488,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     match r {\n                         FfiSafe => {}\n                         FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n-                        FfiUnsafe(s) => { return FfiBadStruct(did, s); }\n+                        FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n                     }\n                 }\n                 FfiSafe\n             }\n-            ty::TyEnum(did, substs) => {\n-                let variants = cx.substd_enum_variants(did, substs);\n+            ty::TyEnum(def, substs) => {\n+                let variants = cx.substd_enum_variants(def.did, substs);\n                 if variants.is_empty() {\n                     // Empty enums are okay... although sort of useless.\n                     return FfiSafe\n                 }\n \n                 // Check for a repr() attribute to specify the size of the\n                 // discriminant.\n-                let repr_hints = cx.lookup_repr_hints(did);\n+                let repr_hints = cx.lookup_repr_hints(def.did);\n                 match &**repr_hints {\n                     [] => {\n                         // Special-case types like `Option<extern fn()>`.\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         match r {\n                             FfiSafe => {}\n                             FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadEnum(did, s); }\n+                            FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n                         }\n                     }\n                 }\n@@ -842,8 +842,8 @@ impl LintPass for RawPointerDerive {\n                 }\n \n                 match cx.tcx.node_id_to_type(item.id).sty {\n-                    ty::TyEnum(did, _) => did,\n-                    ty::TyStruct(did, _) => did,\n+                    ty::TyEnum(def, _) => def.did,\n+                    ty::TyStruct(def, _) => def.did,\n                     _ => return,\n                 }\n             }\n@@ -989,16 +989,16 @@ impl LintPass for UnusedResults {\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyBool => return,\n-            ty::TyStruct(did, _) |\n-            ty::TyEnum(did, _) => {\n-                if ast_util::is_local(did) {\n-                    if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n+            ty::TyStruct(def, _) |\n+            ty::TyEnum(def, _) => {\n+                if ast_util::is_local(def.did) {\n+                    if let ast_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n                         check_must_use(cx, &it.attrs, s.span)\n                     } else {\n                         false\n                     }\n                 } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n+                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n                     check_must_use(cx, &attrs[..], s.span)\n                 }\n             }\n@@ -1956,14 +1956,14 @@ impl LintPass for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_struct(local_def(item.id),\n+                cx.tcx.mk_struct(cx.tcx.lookup_adt_def(local_def(item.id)),\n                                  cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_enum(local_def(item.id),\n+                cx.tcx.mk_enum(cx.tcx.lookup_adt_def(local_def(item.id)),\n                                cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n@@ -2575,9 +2575,9 @@ impl LintPass for DropWithReprExtern {\n                 };\n \n             match dtor_self_type.sty {\n-                ty::TyEnum(self_type_did, _) |\n-                ty::TyStruct(self_type_did, _) |\n-                ty::TyClosure(self_type_did, _) => {\n+                ty::TyEnum(self_type_def, _) |\n+                ty::TyStruct(self_type_def, _) => {\n+                    let self_type_did = self_type_def.did;\n                     let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n                         ctx.tcx.ty_dtor(self_type_did).has_drop_flag() {"}, {"sha": "b59cc65248165b3b6806ae93f6e1e967d7e001e8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -690,6 +690,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                    span: Span,\n                    id: ast::DefId,\n                    name: FieldName) {\n+        // TODO: refactor to variant API\n         let fields = self.tcx.lookup_struct_fields(id);\n         let field = match name {\n             NamedField(f_name) => {\n@@ -883,13 +884,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n-                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n-                    self.check_field(expr.span, id, NamedField(ident.node.name));\n+                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n+                    self.check_field(expr.span, def.did, NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n-                    self.check_field(expr.span, id, UnnamedField(idx.node));\n+                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n+                    self.check_field(expr.span, def.did, UnnamedField(idx.node));\n                 }\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n@@ -900,13 +901,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n                 match self.tcx.expr_ty(expr).sty {\n-                    ty::TyStruct(ctor_id, _) => {\n+                    ty::TyStruct(ctor_def, _) => {\n                         // RFC 736: ensure all unmentioned fields are visible.\n                         // Rather than computing the set of unmentioned fields\n                         // (i.e. `all_fields - fields`), just check them all.\n-                        let all_fields = self.tcx.lookup_struct_fields(ctor_id);\n+                        let all_fields = self.tcx.lookup_struct_fields(ctor_def.did);\n                         for field in all_fields {\n-                            self.check_field(expr.span, ctor_id,\n+                            self.check_field(expr.span, ctor_def.did,\n                                              NamedField(field.name));\n                         }\n                     }\n@@ -977,9 +978,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n                 match self.tcx.pat_ty(pattern).sty {\n-                    ty::TyStruct(id, _) => {\n+                    ty::TyStruct(def, _) => {\n                         for field in fields {\n-                            self.check_field(pattern.span, id,\n+                            self.check_field(pattern.span, def.did,\n                                              NamedField(field.node.ident.name));\n                         }\n                     }\n@@ -1008,12 +1009,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n                 match self.tcx.pat_ty(pattern).sty {\n-                    ty::TyStruct(id, _) => {\n+                    ty::TyStruct(def, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             if let ast::PatWild(..) = field.node {\n                                 continue\n                             }\n-                            self.check_field(field.span, id, UnnamedField(i));\n+                            self.check_field(field.span, def.did, UnnamedField(i));\n                         }\n                     }\n                     ty::TyEnum(..) => {"}, {"sha": "7500a959931e28d28e315cf3f652119e92e5187e", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1119,8 +1119,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 let ty = &self.tcx.expr_ty_adjusted(&**sub_ex).sty;\n                 match *ty {\n-                    ty::TyStruct(def_id, _) => {\n-                        let fields = self.tcx.lookup_struct_fields(def_id);\n+                    ty::TyStruct(def, _) => {\n+                        let fields = self.tcx.lookup_struct_fields(def.did);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n                                 let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);"}, {"sha": "dbab7f4a0a970699030359d1d95f2305f7f64636", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -447,8 +447,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprField(ref sub_ex, ident) => {\n                 let ty = &self.tcx.expr_ty_adjusted(&sub_ex).sty;\n                 match *ty {\n-                    ty::TyStruct(def_id, _) => {\n-                        let fields = self.tcx.lookup_struct_fields(def_id);\n+                    ty::TyStruct(def, _) => {\n+                        let fields = self.tcx.lookup_struct_fields(def.did);\n                         for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -474,12 +474,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprStruct(ref path, _, _) => {\n                 let ty = &self.tcx.expr_ty_adjusted(expr).sty;\n                 match *ty {\n-                    ty::TyStruct(def_id, _) => {\n+                    ty::TyStruct(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n                             scope: self.enclosing_scope(expr.id),\n-                            ref_id: def_id,\n+                            ref_id: def.did,\n                         }))\n                     }\n                     _ => {"}, {"sha": "79fe9b90e7d9c77abe611283a36595eba4167598", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1186,13 +1186,13 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         ).collect();\n \n         match left_ty.sty {\n-            ty::TyStruct(def_id, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n+            ty::TyStruct(def, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n                 // The last field is technically unsized but\n                 // since we can only ever match that field behind\n                 // a reference we construct a fat ptr here.\n-                let fields = bcx.tcx().lookup_struct_fields(def_id);\n+                let fields = bcx.tcx().lookup_struct_fields(def.did);\n                 let unsized_ty = fields.iter().last().map(|field| {\n-                    let fty = bcx.tcx().lookup_field_type(def_id, field.id, substs);\n+                    let fty = bcx.tcx().lookup_field_type(def.did, field.id, substs);\n                     monomorphize::normalize_associated_type(bcx.tcx(), &fty)\n                 }).unwrap();\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);"}, {"sha": "62286b7995aa4a8404ea1ee58b62098b7ca74b7a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -245,14 +245,14 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elems) => {\n             Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n-        ty::TyStruct(def_id, substs) => {\n-            let fields = cx.tcx().lookup_struct_fields(def_id);\n+        ty::TyStruct(def, substs) => {\n+            let fields = cx.tcx().lookup_struct_fields(def.did);\n             let mut ftys = fields.iter().map(|field| {\n-                let fty = cx.tcx().lookup_field_type(def_id, field.id, substs);\n+                let fty = cx.tcx().lookup_field_type(def.did, field.id, substs);\n                 monomorphize::normalize_associated_type(cx.tcx(), &fty)\n             }).collect::<Vec<_>>();\n-            let packed = cx.tcx().lookup_packed(def_id);\n-            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n+            let packed = cx.tcx().lookup_packed(def.did);\n+            let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -262,12 +262,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyClosure(_, ref substs) => {\n             Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n         }\n-        ty::TyEnum(def_id, substs) => {\n-            let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *cx.tcx().lookup_repr_hints(def_id).get(0)\n+        ty::TyEnum(def, substs) => {\n+            let cases = get_cases(cx.tcx(), def.did, substs);\n+            let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n+            let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n \n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n@@ -296,7 +296,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                         discriminants\",\n-                                       cx.tcx().item_path_str(def_id)));\n+                                       cx.tcx().item_path_str(def.did)));\n             }\n \n             if cases.len() == 1 {\n@@ -443,10 +443,10 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::TyBareFn(..) => Some(path),\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n-        ty::TyStruct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n-            let nonzero_fields = tcx.lookup_struct_fields(did);\n+        ty::TyStruct(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {\n+            let nonzero_fields = tcx.lookup_struct_fields(def.did);\n             assert_eq!(nonzero_fields.len(), 1);\n-            let nonzero_field = tcx.lookup_field_type(did, nonzero_fields[0].id, substs);\n+            let nonzero_field = tcx.lookup_field_type(def.did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n@@ -462,10 +462,10 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n-        ty::TyStruct(def_id, substs) => {\n-            let fields = tcx.lookup_struct_fields(def_id);\n+        ty::TyStruct(def, substs) => {\n+            let fields = tcx.lookup_struct_fields(def.did);\n             for (j, field) in fields.iter().enumerate() {\n-                let field_ty = tcx.lookup_field_type(def_id, field.id, substs);\n+                let field_ty = tcx.lookup_field_type(def.did, field.id, substs);\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);"}, {"sha": "25e139474bd4d124c5ed1eced356b88d09e2610b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -455,12 +455,12 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n-      ty::TyEnum(tid, substs) => {\n+      ty::TyEnum(en, substs) => {\n           let fcx = cx.fcx;\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ccx.tcx().enum_variants(tid);\n+          let variants = ccx.tcx().enum_variants(en.did);\n           let n_variants = (*variants).len();\n \n           // NB: we must hit the discriminant first so that structural"}, {"sha": "cfb87700842543678829262aa503ed30b96af5e6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -173,10 +173,10 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyStruct(def_id, substs) => {\n-            let fields = ccx.tcx().lookup_struct_fields(def_id);\n+        ty::TyStruct(def, substs) => {\n+            let fields = ccx.tcx().lookup_struct_fields(def.did);\n             fields.len() == 1 && {\n-                let ty = ccx.tcx().lookup_field_type(def_id, fields[0].id, substs);\n+                let ty = ccx.tcx().lookup_field_type(def.did, fields[0].id, substs);\n                 let ty = monomorphize::normalize_associated_type(ccx.tcx(), &ty);\n                 type_is_immediate(ccx, ty)\n             }"}, {"sha": "e7499ad9301ad61c6c427fc18e2c4290348a68d8", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -178,13 +178,13 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::TyFloat(_) => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::TyEnum(def_id, substs) => {\n+            ty::TyEnum(def, substs) => {\n                 unique_type_id.push_str(\"enum \");\n-                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n             },\n-            ty::TyStruct(def_id, substs) => {\n+            ty::TyStruct(def, substs) => {\n                 unique_type_id.push_str(\"struct \");\n-                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n             },\n             ty::TyTuple(ref component_types) if component_types.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n@@ -710,8 +710,12 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyEnum(def_id, _) => {\n-            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n+        ty::TyEnum(def, _) => {\n+            prepare_enum_metadata(cx,\n+                                  t,\n+                                  def.did,\n+                                  unique_type_id,\n+                                  usage_site_span).finalize(cx)\n         }\n         ty::TyArray(typ, len) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, Some(len as u64), usage_site_span)\n@@ -780,10 +784,10 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyStruct(def_id, substs) => {\n+        ty::TyStruct(def, substs) => {\n             prepare_struct_metadata(cx,\n                                     t,\n-                                    def_id,\n+                                    def.did,\n                                     substs,\n                                     unique_type_id,\n                                     usage_site_span).finalize(cx)"}, {"sha": "120134800b000852e2ff74fac34d16a2b84a28f5", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -54,9 +54,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyUint(ast::TyU64)  => output.push_str(\"u64\"),\n         ty::TyFloat(ast::TyF32) => output.push_str(\"f32\"),\n         ty::TyFloat(ast::TyF64) => output.push_str(\"f64\"),\n-        ty::TyStruct(def_id, substs) |\n-        ty::TyEnum(def_id, substs) => {\n-            push_item_name(cx, def_id, qualified, output);\n+        ty::TyStruct(def, substs) |\n+        ty::TyEnum(def, substs) => {\n+            push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n         ty::TyTuple(ref component_types) => {"}, {"sha": "36eff73199506f92a9f7063ee47559f2a1b039fe", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1125,7 +1125,8 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              expr.span,\n                              expr.id,\n-                             tcx.mk_struct(did, tcx.mk_substs(substs)),\n+                             tcx.mk_struct(tcx.lookup_adt_def(did),\n+                                           tcx.mk_substs(substs)),\n                              dest)\n             } else {\n                 tcx.sess.span_bug(expr.span,\n@@ -1268,7 +1269,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n-                ty::TyStruct(did, _) if bcx.tcx().has_dtor(did) => {\n+                ty::TyStruct(def, _) if def.has_dtor(bcx.tcx()) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }\n@@ -1372,8 +1373,8 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n     F: FnOnce(ty::Disr, &[ty::Field<'tcx>]) -> R,\n {\n     match ty.sty {\n-        ty::TyStruct(did, substs) => {\n-            let fields = tcx.struct_fields(did, substs);\n+        ty::TyStruct(def, substs) => {\n+            let fields = tcx.struct_fields(def.did, substs);\n             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n             op(0, &fields[..])\n         }"}, {"sha": "d07776c3d9190f25f2c0021a3d296c18e3b82a49", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -415,7 +415,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n         return (size, align);\n     }\n     match t.sty {\n-        ty::TyStruct(id, substs) => {\n+        ty::TyStruct(def, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n@@ -432,7 +432,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let fields = bcx.tcx().struct_fields(id, substs);\n+            let fields = bcx.tcx().struct_fields(def.did, substs);\n             let last_field = fields[fields.len()-1];\n             let field_ty = last_field.mt.ty;\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n@@ -562,27 +562,27 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 })\n             }\n         }\n-        ty::TyStruct(did, substs) | ty::TyEnum(did, substs) => {\n+        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n             let tcx = bcx.tcx();\n-            match (tcx.ty_dtor(did), skip_dtor) {\n+            match (tcx.ty_dtor(def.did), skip_dtor) {\n                 (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n                     // OK.\n                     if type_is_sized(bcx.tcx(), t) {\n-                        trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                        trans_struct_drop_flag(bcx, t, v0, dtor, def.did, substs)\n                     } else {\n                         // Give the user a heads up that we are doing something\n                         // stupid and dangerous.\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\", t));\n-                        trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                        trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n                     }\n                 }\n                 (ty::TraitDtor(dtor, false), false) => {\n-                    trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                    trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n                 }\n                 (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case"}, {"sha": "91247ebd7919d5504018126a2612f78202f1f1e5", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -333,14 +333,14 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyInt(t) => Type::int_from_ty(cx, t),\n       ty::TyUint(t) => Type::uint_from_ty(cx, t),\n       ty::TyFloat(t) => Type::float_from_ty(cx, t),\n-      ty::TyEnum(did, ref substs) => {\n+      ty::TyEnum(def, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n-          let name = llvm_type_name(cx, did, tps);\n+          let name = llvm_type_name(cx, def.did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n@@ -403,7 +403,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &*repr)\n       }\n-      ty::TyStruct(did, ref substs) => {\n+      ty::TyStruct(def, ref substs) => {\n           if t.is_simd(cx.tcx()) {\n               let llet = in_memory_type_of(cx, t.simd_type(cx.tcx()));\n               let n = t.simd_size(cx.tcx()) as u64;\n@@ -415,7 +415,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n-              let name = llvm_type_name(cx, did, tps);\n+              let name = llvm_type_name(cx, def.did, tps);\n               adt::incomplete_type_of(cx, &*repr, &name[..])\n           }\n       }"}, {"sha": "b0b1acb445c2b4886a4dbe2ead9253ada70000e1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -528,7 +528,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let (enum_def_id, variant_def_id) = match def {\n+    let (adt_def, variant_def_id) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0168,\n@@ -543,11 +543,12 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         _ => {\n             let def_type = tcx.lookup_item_type(def.def_id());\n             match def_type.ty.sty {\n-                ty::TyStruct(struct_def_id, _) =>\n-                    (struct_def_id, struct_def_id),\n-                ty::TyEnum(enum_def_id, _)\n-                    if def == def::DefVariant(enum_def_id, def.def_id(), true) =>\n-                    (enum_def_id, def.def_id()),\n+                ty::TyStruct(struct_def, _) =>\n+                    (struct_def, struct_def.did),\n+                ty::TyEnum(enum_def, _)\n+                    // TODO: wut?\n+                    if def == def::DefVariant(enum_def.did, def.def_id(), true) =>\n+                    (enum_def, def.def_id()),\n                 _ => {\n                     let name = pprust::path_to_string(path);\n                     span_err!(tcx.sess, pat.span, E0163,\n@@ -565,8 +566,8 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n \n     instantiate_path(pcx.fcx,\n                      &path.segments,\n-                     tcx.lookup_item_type(enum_def_id),\n-                     &tcx.lookup_predicates(enum_def_id),\n+                     adt_def.type_scheme(tcx),\n+                     &adt_def.predicates(tcx),\n                      None,\n                      def,\n                      pat.span,\n@@ -647,17 +648,17 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n-        ty::TyEnum(enum_def_id, expected_substs)\n-            if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n+        ty::TyEnum(enum_def, expected_substs)\n+            if def == def::DefVariant(enum_def.did, def.def_id(), false) =>\n         {\n-            let variant = tcx.enum_variant_with_id(enum_def_id, def.def_id());\n+            let variant = tcx.enum_variant_with_id(enum_def.did, def.def_id());\n             (variant.args.iter()\n                          .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n                          .collect(),\n              \"variant\")\n         }\n-        ty::TyStruct(struct_def_id, expected_substs) => {\n-            let struct_fields = tcx.struct_fields(struct_def_id, expected_substs);\n+        ty::TyStruct(struct_def, expected_substs) => {\n+            let struct_fields = tcx.struct_fields(struct_def.did, expected_substs);\n             (struct_fields.iter()\n                           .map(|field| fcx.instantiate_type_scheme(pat.span,\n                                                                    expected_substs,"}, {"sha": "5d93e2ae5d379a70e513936609ba99e194c86e51", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -79,8 +79,8 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match t.sty {\n         ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n         ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n-        ty::TyStruct(did, substs) => {\n-            match fcx.tcx().struct_fields(did, substs).pop() {\n+        ty::TyStruct(def, substs) => {\n+            match fcx.tcx().struct_fields(def.did, substs).pop() {\n                 None => None,\n                 Some(f) => unsize_kind(fcx, f.mt.ty)\n             }"}, {"sha": "7cb2198c68ddf01342032a00a5274960a7db2009", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 13, "deletions": 105, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -41,18 +41,18 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n                          ty: dtor_self_type } = tcx.lookup_item_type(drop_impl_did);\n     let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n-        ty::TyEnum(self_type_did, self_to_impl_substs) |\n-        ty::TyStruct(self_type_did, self_to_impl_substs) => {\n+        ty::TyEnum(adt_def, self_to_impl_substs) |\n+        ty::TyStruct(adt_def, self_to_impl_substs) => {\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,\n                                                                &dtor_self_type,\n-                                                               self_type_did));\n+                                                               adt_def.did));\n \n             ensure_drop_predicates_are_implied_by_item_defn(tcx,\n                                                             drop_impl_did,\n                                                             &dtor_predicates,\n-                                                            self_type_did,\n+                                                            adt_def.did,\n                                                             self_to_impl_substs)\n         }\n         _ => {\n@@ -357,8 +357,6 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         return Err(Error::Overflow(context, ty))\n     }\n \n-    let opt_phantom_data_def_id = tcx.lang_items.phantom_data();\n-\n     if !cx.breadcrumbs.insert(ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                {}ty: {} scope: {:?} - cached\",\n@@ -399,7 +397,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     // type parameters are unbounded.  If both conditions hold, we\n     // simply skip the `type_must_outlive` call entirely (but\n     // resume the recursive checking of the type-substructure).\n-    if has_dtor_of_interest(tcx, ty, cx.span) {\n+    if has_dtor_of_interest(tcx, ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}ty: {} - is a dtorck type!\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n@@ -432,14 +430,15 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(did, substs) if Some(did) == opt_phantom_data_def_id => {\n+        ty::TyStruct(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n             let ity = *substs.types.get(subst::TypeSpace, 0);\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(did, substs) => {\n+        ty::TyStruct(def, substs) => {\n+            let did = def.did;\n             let fields = tcx.lookup_struct_fields(did);\n             for field in &fields {\n                 let fty = tcx.lookup_field_type(did, field.id, substs);\n@@ -457,7 +456,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyEnum(did, substs) => {\n+        ty::TyEnum(def, substs) => {\n+            let did = def.did;\n             let all_variant_info = tcx.substd_enum_variants(did, substs);\n             for variant_info in &all_variant_info {\n                 for (i, fty) in variant_info.args.iter().enumerate() {\n@@ -510,102 +510,10 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n }\n \n fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              ty: ty::Ty<'tcx>,\n-                              span: Span) -> bool {\n+                              ty: ty::Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) => {\n-            let dtor_method_did = match tcx.destructor_for_type.borrow().get(&def_id) {\n-                Some(def_id) => *def_id,\n-                None => {\n-                    debug!(\"ty: {:?} has no dtor, and thus isn't a dropck type\", ty);\n-                    return false;\n-                }\n-            };\n-            let impl_did = tcx.impl_of_method(dtor_method_did)\n-                .unwrap_or_else(|| {\n-                    tcx.sess.span_bug(\n-                        span, \"no Drop impl found for drop method\")\n-                });\n-\n-            let dtor_typescheme = tcx.lookup_item_type(impl_did);\n-            let dtor_generics = dtor_typescheme.generics;\n-\n-            let mut has_pred_of_interest = false;\n-\n-            let mut seen_items = Vec::new();\n-            let mut items_to_inspect = vec![impl_did];\n-            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n-                if seen_items.contains(&item_def_id) {\n-                    continue;\n-                }\n-\n-                for pred in tcx.lookup_predicates(item_def_id).predicates {\n-                    let result = match pred {\n-                        ty::Predicate::Equate(..) |\n-                        ty::Predicate::RegionOutlives(..) |\n-                        ty::Predicate::TypeOutlives(..) |\n-                        ty::Predicate::Projection(..) => {\n-                            // For now, assume all these where-clauses\n-                            // may give drop implementation capabilty\n-                            // to access borrowed data.\n-                            true\n-                        }\n-\n-                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                            let def_id = t_pred.trait_ref.def_id;\n-                            if tcx.trait_items(def_id).len() != 0 {\n-                                // If trait has items, assume it adds\n-                                // capability to access borrowed data.\n-                                true\n-                            } else {\n-                                // Trait without items is itself\n-                                // uninteresting from POV of dropck.\n-                                //\n-                                // However, may have parent w/ items;\n-                                // so schedule checking of predicates,\n-                                items_to_inspect.push(def_id);\n-                                // and say \"no capability found\" for now.\n-                                false\n-                            }\n-                        }\n-                    };\n-\n-                    if result {\n-                        has_pred_of_interest = true;\n-                        debug!(\"ty: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                               ty, pred);\n-                        break 'items;\n-                    }\n-                }\n-\n-                seen_items.push(item_def_id);\n-            }\n-\n-            // In `impl<'a> Drop ...`, we automatically assume\n-            // `'a` is meaningful and thus represents a bound\n-            // through which we could reach borrowed data.\n-            //\n-            // FIXME (pnkfelix): In the future it would be good to\n-            // extend the language to allow the user to express,\n-            // in the impl signature, that a lifetime is not\n-            // actually used (something like `where 'a: ?Live`).\n-            let has_region_param_of_interest =\n-                dtor_generics.has_region_params(subst::TypeSpace);\n-\n-            let has_dtor_of_interest =\n-                has_region_param_of_interest ||\n-                has_pred_of_interest;\n-\n-            if has_dtor_of_interest {\n-                debug!(\"ty: {:?} has interesting dtor, due to \\\n-                        region params: {} or pred: {}\",\n-                       ty,\n-                       has_region_param_of_interest,\n-                       has_pred_of_interest);\n-            } else {\n-                debug!(\"ty: {:?} has dtor, but it is uninteresting\", ty);\n-            }\n-            has_dtor_of_interest\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n+            def.is_dtorck(tcx)\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);"}, {"sha": "2ff40b3590d29fe39e3fd2c134d1b4a0e8af5d42", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -286,10 +286,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 self.assemble_inherent_candidates_from_object(self_ty, data);\n                 self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n             }\n-            ty::TyEnum(did, _) |\n-            ty::TyStruct(did, _) |\n-            ty::TyClosure(did, _) => {\n-                self.assemble_inherent_impl_candidates_for_type(did);\n+            ty::TyEnum(def, _) |\n+            ty::TyStruct(def, _) => {\n+                self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n             ty::TyBox(_) => {\n                 if let Some(box_did) = self.tcx().lang_items.owned_box() {"}, {"sha": "970589fb9c50e2202847e7375084df8365dfcde6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -65,8 +65,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None);\n \n             // If the item has the name of a field, give a help note\n-            if let (&ty::TyStruct(did, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                let fields = cx.lookup_struct_fields(did);\n+            if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n+                let fields = cx.lookup_struct_fields(def.did);\n \n                 if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n                     let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n@@ -89,7 +89,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     };\n \n                     // Determine if the field can be used as a function in some way\n-                    let field_ty = cx.lookup_field_type(did, field.id, substs);\n+                    let field_ty = cx.lookup_field_type(def.did, field.id, substs);\n                     if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n                         let infcx = fcx.infcx();\n                         infcx.probe(|_| {\n@@ -303,7 +303,7 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rcvr_expr: Option<&ast::Expr>) -> bool {\n     fn is_local(ty: Ty) -> bool {\n         match ty.sty {\n-            ty::TyEnum(did, _) | ty::TyStruct(did, _) => ast_util::is_local(did),\n+            ty::TyEnum(def, _) | ty::TyStruct(def, _) => ast_util::is_local(def.did),\n \n             ty::TyTrait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n "}, {"sha": "5e5886cd13ce25a2d16d1a156ab5b8f8552c14ea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 81, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1678,27 +1678,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Indifferent to privacy flags\n     pub fn lookup_field_ty(&self,\n                            span: Span,\n-                           class_id: ast::DefId,\n+                           struct_def: &'tcx ty::ADTDef<'tcx>,\n                            items: &[ty::FieldTy],\n                            fieldname: ast::Name,\n                            substs: &subst::Substs<'tcx>)\n                            -> Option<Ty<'tcx>>\n     {\n         let o_field = items.iter().find(|f| f.name == fieldname);\n-        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n+        o_field.map(|f| self.tcx().lookup_field_type(struct_def.did, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n \n     pub fn lookup_tup_field_ty(&self,\n                                span: Span,\n-                               class_id: ast::DefId,\n+                               struct_def: &'tcx ty::ADTDef<'tcx>,\n                                items: &[ty::FieldTy],\n                                idx: usize,\n                                substs: &subst::Substs<'tcx>)\n                                -> Option<Ty<'tcx>>\n     {\n         let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n-        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n+        o_field.map(|f| self.tcx().lookup_field_type(struct_def.did, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n \n@@ -2878,10 +2878,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n                 match base_t.sty {\n-                    ty::TyStruct(base_id, substs) => {\n+                    ty::TyStruct(base_def, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n-                        let fields = tcx.lookup_struct_fields(base_id);\n-                        fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n+                        let fields = tcx.lookup_struct_fields(base_def.did);\n+                        fcx.lookup_field_ty(expr.span, base_def, &fields[..],\n                                             field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -2919,23 +2919,23 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             actual)\n                 },\n                 expr_t, None);\n-            if let ty::TyStruct(did, _) = expr_t.sty {\n-                suggest_field_names(did, field, tcx, vec![]);\n+            if let ty::TyStruct(def, _) = expr_t.sty {\n+                suggest_field_names(def.did, field, tcx, vec![]);\n             }\n         }\n \n         fcx.write_error(expr.id);\n     }\n \n     // displays hints about the closest matches in field names\n-    fn suggest_field_names<'tcx>(id : DefId,\n-                                 field : &ast::SpannedIdent,\n-                                 tcx : &ty::ctxt<'tcx>,\n+    fn suggest_field_names<'tcx>(variant_id: ast::DefId,\n+                                 field: &ast::SpannedIdent,\n+                                 tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n         let name = field.node.name.as_str();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let fields = tcx.lookup_struct_fields(id);\n+        let fields = tcx.lookup_struct_fields(variant_id);\n         let mut best = None;\n         for elem in &fields {\n             let n = elem.name.as_str();\n@@ -2944,7 +2944,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 continue;\n             }\n             // ignore private fields from non-local crates\n-            if id.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n+            if variant_id.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n                 continue;\n             }\n             let dist = lev_distance(&n, &name);\n@@ -2979,12 +2979,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n                 match base_t.sty {\n-                    ty::TyStruct(base_id, substs) => {\n-                        tuple_like = tcx.is_tuple_struct(base_id);\n+                    ty::TyStruct(base_def, substs) => {\n+                        tuple_like = base_def.is_tuple_struct(tcx);\n                         if tuple_like {\n                             debug!(\"tuple struct named {:?}\",  base_t);\n-                            let fields = tcx.lookup_struct_fields(base_id);\n-                            fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n+                            let fields = tcx.lookup_struct_fields(base_def.did);\n+                            fcx.lookup_tup_field_ty(expr.span, base_def, &fields[..],\n                                                     idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3026,16 +3026,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                struct_ty: Ty<'tcx>,\n+                                                adt_ty: Ty<'tcx>,\n                                                 span: Span,\n-                                                class_id: ast::DefId,\n-                                                node_id: ast::NodeId,\n+                                                variant_id: ast::DefId,\n                                                 substitutions: &'tcx subst::Substs<'tcx>,\n                                                 field_types: &[ty::FieldTy],\n                                                 ast_fields: &'tcx [ast::Field],\n-                                                check_completeness: bool,\n-                                                enum_id_opt: Option<ast::DefId>)  {\n+                                                check_completeness: bool) -> Result<(),()> {\n         let tcx = fcx.ccx.tcx;\n+        let (adt_def, is_enum) = match adt_ty.sty {\n+            ty::TyStruct(def, _) => (def, false),\n+            ty::TyEnum(def, _) => (def, true),\n+            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_struct_or_variant_fields\")\n+        };\n \n         let mut class_field_map = FnvHashMap();\n         let mut fields_found = 0;\n@@ -3054,29 +3057,22 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 None => {\n                     fcx.type_error_message(\n                         field.ident.span,\n-                        |actual| match enum_id_opt {\n-                            Some(enum_id) => {\n-                                let variant_type = tcx.enum_variant_with_id(enum_id,\n-                                                                            class_id);\n-                                format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                                        actual, variant_type.name.as_str(),\n+                        |actual| if is_enum {\n+                            let variant_type = tcx.enum_variant_with_id(adt_def.did,\n+                                                                        variant_id);\n+                            format!(\"struct variant `{}::{}` has no field named `{}`\",\n+                                    actual, variant_type.name.as_str(),\n                                         field.ident.node)\n-                            }\n-                            None => {\n-                                format!(\"structure `{}` has no field named `{}`\",\n-                                        actual,\n+                        } else {\n+                            format!(\"structure `{}` has no field named `{}`\",\n+                                    actual,\n                                         field.ident.node)\n-                            }\n                         },\n-                        struct_ty,\n+                        adt_ty,\n                         None);\n                     // prevent all specified fields from being suggested\n                     let skip_fields = ast_fields.iter().map(|ref x| x.ident.node.name.as_str());\n-                    let actual_id = match enum_id_opt {\n-                        Some(_) => class_id,\n-                        None => struct_ty.ty_to_def_id().unwrap()\n-                    };\n-                    suggest_field_names(actual_id, &field.ident, tcx, skip_fields.collect());\n+                    suggest_field_names(variant_id, &field.ident, tcx, skip_fields.collect());\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n@@ -3087,7 +3083,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 Some((field_id, false)) => {\n                     expected_field_type =\n-                        tcx.lookup_field_type(class_id, field_id, substitutions);\n+                        tcx.lookup_field_type(variant_id, field_id, substitutions);\n                     expected_field_type =\n                         fcx.normalize_associated_types_in(\n                             field.span, &expected_field_type);\n@@ -3102,10 +3098,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n         }\n \n-        if error_happened {\n-            fcx.write_error(node_id);\n-        }\n-\n         if check_completeness && !error_happened {\n             // Make sure the programmer specified all the fields.\n             assert!(fields_found <= field_types.len());\n@@ -3127,15 +3119,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n              }\n         }\n \n-        if !error_happened {\n-            fcx.write_ty(node_id, fcx.ccx.tcx.mk_struct(class_id, substitutions));\n-        }\n+        if error_happened { Err(()) } else { Ok(()) }\n     }\n \n     fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                          id: ast::NodeId,\n                                          span: codemap::Span,\n-                                         class_id: ast::DefId,\n+                                         struct_def: &'tcx ty::ADTDef<'tcx>,\n                                          fields: &'tcx [ast::Field],\n                                          base_expr: Option<&'tcx ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n@@ -3144,21 +3134,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let TypeAndSubsts {\n             ty: mut struct_type,\n             substs: struct_substs\n-        } = fcx.instantiate_type(span, class_id);\n+        } = fcx.instantiate_type(span, struct_def.did);\n \n         // Look up and check the fields.\n-        let class_fields = tcx.lookup_struct_fields(class_id);\n-        check_struct_or_variant_fields(fcx,\n-                                       struct_type,\n-                                       span,\n-                                       class_id,\n-                                       id,\n-                                       fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       &class_fields[..],\n-                                       fields,\n-                                       base_expr.is_none(),\n-                                       None);\n-        if fcx.node_ty(id).references_error() {\n+        let class_fields = tcx.lookup_struct_fields(struct_def.did);\n+        let res = check_struct_or_variant_fields(fcx,\n+                                                 struct_type,\n+                                                 span,\n+                                                 struct_def.did,\n+                                                 fcx.ccx.tcx.mk_substs(struct_substs),\n+                                                 &class_fields[..],\n+                                                 fields,\n+                                                 base_expr.is_none());\n+        if res.is_err() {\n             struct_type = tcx.types.err;\n         }\n \n@@ -3191,16 +3179,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Look up and check the enum variant fields.\n         let variant_fields = tcx.lookup_struct_fields(variant_id);\n-        check_struct_or_variant_fields(fcx,\n-                                       enum_type,\n-                                       span,\n-                                       variant_id,\n-                                       id,\n-                                       fcx.ccx.tcx.mk_substs(substitutions),\n-                                       &variant_fields[..],\n-                                       fields,\n-                                       true,\n-                                       Some(enum_id));\n+        let _ = check_struct_or_variant_fields(fcx,\n+                                               enum_type,\n+                                               span,\n+                                               variant_id,\n+                                               fcx.ccx.tcx.mk_substs(substitutions),\n+                                               &variant_fields[..],\n+                                               fields,\n+                                               true);\n         fcx.write_ty(id, enum_type);\n     }\n \n@@ -3695,11 +3681,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Verify that this was actually a struct.\n                 let typ = fcx.ccx.tcx.lookup_item_type(def.def_id());\n                 match typ.ty.sty {\n-                    ty::TyStruct(struct_did, _) => {\n+                    ty::TyStruct(struct_def, _) => {\n                         check_struct_constructor(fcx,\n                                                  id,\n                                                  expr.span,\n-                                                 struct_did,\n+                                                 struct_def,\n                                                  &fields[..],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n@@ -3835,6 +3821,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 };\n \n                 if let Some(did) = did {\n+                    let def = tcx.lookup_adt_def(did);\n                     let predicates = tcx.lookup_predicates(did);\n                     let substs = Substs::new_type(vec![idx_type], vec![]);\n                     let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n@@ -3844,7 +3831,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                      traits::ItemObligation(did)),\n                         &bounds);\n \n-                    tcx.mk_struct(did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(def, tcx.mk_substs(substs))\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -3853,8 +3840,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None => {\n                 // Neither start nor end => RangeFull\n                 if let Some(did) = tcx.lang_items.range_full_struct() {\n-                    let substs = Substs::new_type(vec![], vec![]);\n-                    tcx.mk_struct(did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(\n+                        tcx.lookup_adt_def(did),\n+                        tcx.mk_substs(Substs::empty())\n+                    )\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -4305,15 +4294,15 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n         return;\n     }\n     match t.sty {\n-        ty::TyStruct(did, substs) => {\n-            let fields = tcx.lookup_struct_fields(did);\n+        ty::TyStruct(def, substs) => {\n+            let fields = tcx.lookup_struct_fields(def.did);\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = tcx.lookup_field_type(did, fields[0].id, substs);\n+            let e = tcx.lookup_field_type(def.did, fields[0].id, substs);\n             if !fields.iter().all(\n-                         |f| tcx.lookup_field_type(did, f.id, substs) == e) {\n+                         |f| tcx.lookup_field_type(def.did, f.id, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }"}, {"sha": "7790a29db12f78176309f34289bfd138bc20b81a", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -571,17 +571,17 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         }\n \n         match t.sty{\n-            ty::TyStruct(type_id, substs) |\n-            ty::TyEnum(type_id, substs) => {\n-                let type_predicates = self.fcx.tcx().lookup_predicates(type_id);\n+            ty::TyStruct(def, substs) |\n+            ty::TyEnum(def, substs) => {\n+                let type_predicates = def.predicates(self.fcx.tcx());\n                 let bounds = self.fcx.instantiate_bounds(self.span, substs,\n                                                          &type_predicates);\n \n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n-                                                     traits::ItemObligation(type_id)),\n+                                                     traits::ItemObligation(def.did)),\n                         &bounds);\n                 } else {\n                     // There are two circumstances in which we ignore\n@@ -610,7 +610,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n-                                                     traits::ItemObligation(type_id)),\n+                                                     traits::ItemObligation(def.did)),\n                         &bounds);\n                 }\n "}, {"sha": "cd4063ac454ed2fadd6989c619a6fa95a58e80fe", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -55,9 +55,9 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n                                   ty: Ty<'tcx>)\n                                   -> Option<DefId> {\n     match ty.sty {\n-        TyEnum(def_id, _) |\n-        TyStruct(def_id, _) => {\n-            Some(def_id)\n+        TyEnum(def, _) |\n+        TyStruct(def, _) => {\n+            Some(def.did)\n         }\n \n         TyTrait(ref t) => {\n@@ -310,12 +310,11 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n-                ty::TyEnum(type_def_id, _) |\n-                ty::TyStruct(type_def_id, _) |\n-                ty::TyClosure(type_def_id, _) => {\n+                ty::TyEnum(type_def, _) |\n+                ty::TyStruct(type_def, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n-                       .insert(type_def_id, method_def_id.def_id());\n+                       .insert(type_def.did, method_def_id.def_id());\n                     tcx.destructors\n                        .borrow_mut()\n                        .insert(method_def_id.def_id());\n@@ -471,10 +470,10 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n                 }\n \n-                (&ty::TyStruct(def_id_a, substs_a), &ty::TyStruct(def_id_b, substs_b)) => {\n-                    if def_id_a != def_id_b {\n-                        let source_path = tcx.item_path_str(def_id_a);\n-                        let target_path = tcx.item_path_str(def_id_b);\n+                (&ty::TyStruct(def_a, substs_a), &ty::TyStruct(def_b, substs_b)) => {\n+                    if def_a != def_b {\n+                        let source_path = tcx.item_path_str(def_a.did);\n+                        let target_path = tcx.item_path_str(def_b.did);\n                         span_err!(tcx.sess, span, E0377,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures with the same \\\n@@ -484,9 +483,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let origin = infer::Misc(span);\n-                    let fields = tcx.lookup_struct_fields(def_id_a);\n+                    let fields = tcx.lookup_struct_fields(def_a.did);\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                        let ty = tcx.lookup_field_type_unsubstituted(def_id_a, f.id);\n+                        let ty = tcx.lookup_field_type_unsubstituted(def_a.did, f.id);\n                         let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n                         if infcx.sub_types(false, origin, b, a).is_ok() {\n                             None"}, {"sha": "8076e63cc55c5529399571a783c9efe62d1a42b7", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -69,9 +69,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        self.tcx.map.node_to_string(item.id));\n                 let self_ty = self.tcx.lookup_item_type(def_id).ty;\n                 match self_ty.sty {\n-                    ty::TyEnum(def_id, _) |\n-                    ty::TyStruct(def_id, _) => {\n-                        self.check_def_id(item, def_id);\n+                    ty::TyEnum(def, _) |\n+                    ty::TyStruct(def, _) => {\n+                        self.check_def_id(item, def.did);\n                     }\n                     ty::TyTrait(ref data) => {\n                         self.check_def_id(item, data.principal_def_id());\n@@ -279,8 +279,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::TyStruct(self_def_id, _) | ty::TyEnum(self_def_id, _) =>\n-                            Some(self_def_id),\n+                        ty::TyStruct(self_def, _) | ty::TyEnum(self_def, _) =>\n+                            Some(self_def.did),\n                         ty::TyBox(..) =>\n                             self.tcx.lang_items.owned_box(),\n                         _ =>"}, {"sha": "0fed9343536a983233e398a7bd3aa03f36a19920", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1103,39 +1103,37 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n-    let substs = mk_item_substs(ccx, &scheme.generics);\n-    let selfty = tcx.mk_struct(local_def(id), tcx.mk_substs(substs));\n \n     // If this struct is enum-like or tuple-like, create the type of its\n     // constructor.\n-    match struct_def.ctor_id {\n-        None => {}\n-        Some(ctor_id) => {\n-            if struct_def.fields.is_empty() {\n-                // Enum-like.\n-                write_ty_to_tcx(tcx, ctor_id, selfty);\n-\n-                tcx.register_item_type(local_def(ctor_id), scheme);\n-                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n-            } else if struct_def.fields[0].node.kind.is_unnamed() {\n-                // Tuple-like.\n-                let inputs: Vec<_> =\n-                    struct_def.fields\n-                              .iter()\n-                              .map(|field| tcx.lookup_item_type(\n-                                  local_def(field.node.id)).ty)\n-                              .collect();\n-                let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n-                                                &inputs[..],\n-                                                selfty);\n-                write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-                tcx.register_item_type(local_def(ctor_id),\n-                                       TypeScheme {\n-                                           generics: scheme.generics,\n-                                           ty: ctor_fn_ty\n-                                       });\n-                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n-            }\n+    if let Some(ctor_id) = struct_def.ctor_id {\n+        let substs = mk_item_substs(ccx, &scheme.generics);\n+        let selfty = tcx.mk_struct(tcx.lookup_adt_def(local_def(id)),\n+                                   tcx.mk_substs(substs));\n+        if struct_def.fields.is_empty() {\n+            // Enum-like.\n+            write_ty_to_tcx(tcx, ctor_id, selfty);\n+\n+            tcx.register_item_type(local_def(ctor_id), scheme);\n+            tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n+        } else if struct_def.fields[0].node.kind.is_unnamed() {\n+            // Tuple-like.\n+            let inputs: Vec<_> =\n+                struct_def.fields\n+                          .iter()\n+                          .map(|field| tcx.lookup_item_type(\n+                              local_def(field.node.id)).ty)\n+                          .collect();\n+            let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n+                                            &inputs[..],\n+                                            selfty);\n+            write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n+            tcx.register_item_type(local_def(ctor_id),\n+                                   TypeScheme {\n+                                       generics: scheme.generics,\n+                                       ty: ctor_fn_ty\n+                                   });\n+            tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n         }\n     }\n }\n@@ -1475,13 +1473,15 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = tcx.mk_enum(local_def(it.id), tcx.mk_substs(substs));\n+            let def = tcx.intern_adt_def(local_def(it.id));\n+            let t = tcx.mk_enum(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = tcx.mk_struct(local_def(it.id), tcx.mk_substs(substs));\n+            let def = tcx.intern_adt_def(local_def(it.id));\n+            let t = tcx.mk_struct(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemDefaultImpl(..) |"}, {"sha": "3721f9a0b105c9151b386cb854cea29dc7cdc7e5", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -902,9 +902,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyEnum(def_id, substs) |\n-            ty::TyStruct(def_id, substs) => {\n-                let item_type = self.tcx().lookup_item_type(def_id);\n+            ty::TyEnum(def, substs) |\n+            ty::TyStruct(def, substs) => {\n+                let item_type = self.tcx().lookup_item_type(def.did);\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n@@ -915,7 +915,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 self.add_constraints_from_substs(\n                     generics,\n-                    def_id,\n+                    def.did,\n                     item_type.generics.types.get_slice(subst::TypeSpace),\n                     item_type.generics.regions.get_slice(subst::TypeSpace),\n                     substs,"}, {"sha": "582927782a4bdbdcf2ef346171f4ed40937a0ce7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -204,11 +204,11 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n-        ty::TyEnum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n+        ty::TyEnum(edef, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: tcx.enum_variants(edid).clean(cx),\n+                variants: tcx.enum_variants(edef.did).clean(cx),\n             })\n         }\n         _ => {}"}, {"sha": "ac8727912191fbd58fa6b376f3e304e5c5ba8365", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764310e7bb90ec14a6c6a399e703f6b455ba52d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=764310e7bb90ec14a6c6a399e703f6b455ba52d3", "patch": "@@ -1658,8 +1658,9 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n-            ty::TyStruct(did, substs) |\n-            ty::TyEnum(did, substs) => {\n+            ty::TyStruct(def, substs) |\n+            ty::TyEnum(def, substs) => {\n+                let did = def.did;\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {"}]}