{"sha": "e84e5ff04a647ce28540300244a26ba120642eea", "node_id": "C_kwDOAAsO6NoAKGU4NGU1ZmYwNGE2NDdjZTI4NTQwMzAwMjQ0YTI2YmExMjA2NDJlZWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T02:50:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T02:50:58Z"}, "message": "Auto merge of #107376 - aliemjay:remove-givens, r=lcnr\n\nremove obsolete `givens` from regionck\n\nFixes #106567\n\nr? `@lcnr` (feel free to reassign)", "tree": {"sha": "e7d03803e692a9917c81a36c3056b0e0a5314cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d03803e692a9917c81a36c3056b0e0a5314cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84e5ff04a647ce28540300244a26ba120642eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84e5ff04a647ce28540300244a26ba120642eea", "html_url": "https://github.com/rust-lang/rust/commit/e84e5ff04a647ce28540300244a26ba120642eea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84e5ff04a647ce28540300244a26ba120642eea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1716932743a7b3705cbf0c34db0c4e070ed1930d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1716932743a7b3705cbf0c34db0c4e070ed1930d", "html_url": "https://github.com/rust-lang/rust/commit/1716932743a7b3705cbf0c34db0c4e070ed1930d"}, {"sha": "211fa45d18e10f9702a1d9ef529c0f1a867f0712", "url": "https://api.github.com/repos/rust-lang/rust/commits/211fa45d18e10f9702a1d9ef529c0f1a867f0712", "html_url": "https://github.com/rust-lang/rust/commit/211fa45d18e10f9702a1d9ef529c0f1a867f0712"}], "stats": {"total": 239, "additions": 87, "deletions": 152}, "files": [{"sha": "123207249d27d2b92e9ab05bf6574e2e3d32a03f", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -330,7 +330,6 @@ fn compare_method_predicate_entailment<'tcx>(\n     // lifetime parameters.\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n@@ -728,7 +727,6 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n     infcx\n@@ -2058,8 +2056,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),"}, {"sha": "28f0924d1d683516eaaeaf919377f4e276f5e905", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -115,8 +115,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     let _ = infcx\n         .err_ctxt()\n@@ -676,7 +675,6 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n     );\n     let region_bound_pairs = outlives_environment.region_bound_pairs();"}, {"sha": "1c5860e97bcb3bc0a34ddcbec885bb778b61162d", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -179,7 +179,7 @@ fn get_impl_substs(\n     }\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n-    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {"}, {"sha": "11ff65d0c373a2a82700a5435482b2ecbe57b872", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -238,15 +238,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that there are two tests to check that this remains true\n         // (`regions-reassign-{match,let}-bound-pointer.rs`).\n         //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n+        // 2. An outdated issue related to the old HIR borrowck. See the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n     }\n \n     /// Compute the new expected type and default binding mode from the old ones"}, {"sha": "90e89a187822d1b09eca72e433b037548ef6b4d3", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -636,11 +636,9 @@ pub fn make_query_region_constraints<'tcx>(\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n-    let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n-        region_constraints;\n+    let RegionConstraintData { constraints, verifys, member_constraints } = region_constraints;\n \n     assert!(verifys.is_empty());\n-    assert!(givens.is_empty());\n \n     debug!(?constraints);\n "}, {"sha": "cf657756ff534477c967f6b8ceefcf36536c42ad", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::intern::Interned;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -132,7 +132,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -164,38 +163,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn expand_givens(&mut self, graph: &RegionGraph<'_>) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            // While all things transitively reachable in the graph\n-            // from the variable (`'0` in the example above).\n-            let seed_index = NodeIndex(vid.index() as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0;\n-\n-                // The first N nodes correspond to the region\n-                // variables. Other nodes correspond to constant\n-                // regions.\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid::new(succ_index);\n-\n-                    // Add `'c <= '1`.\n-                    self.data.givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n     /// Gets the LUb of a given region and the empty region\n     fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n         match *a_region {\n@@ -362,18 +329,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        match *a_region {\n-            // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.data.givens.contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n                 let lub = match self.lub_empty(a_region) {"}, {"sha": "66fb1db46185dc4f9cf978f1c67d5e9071e9d55f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -855,10 +855,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n-    }\n-\n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,"}, {"sha": "a480ee5429eec1af6fd7693def13eb9e00415dcc", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::free_regions::FreeRegionMap;\n-use crate::infer::{GenericKind, InferCtxt};\n+use crate::infer::GenericKind;\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n-use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n+use rustc_middle::ty::{self, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -75,7 +75,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: Default::default(),\n         };\n \n-        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(explicit_outlives_bounds(param_env));\n \n         builder\n     }\n@@ -89,11 +89,10 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n     pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n-        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n-        builder.add_outlives_bounds(infcx, extra_bounds);\n+        builder.add_outlives_bounds(extra_bounds);\n         builder.build()\n     }\n \n@@ -120,12 +119,7 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n-    ///\n-    /// The `infcx` parameter is optional; if the implied bounds may\n-    /// contain inference variables, it must be supplied, in which\n-    /// case we will register \"givens\" on the inference context. (See\n-    /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n@@ -142,27 +136,14 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n-                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n-                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n-                        infcx\n-                            .expect(\"no infcx provided but region vars found\")\n-                            .add_given(r_a, vid_b);\n-                    } else {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        if r_a.is_free_or_static() && r_b.is_free() {\n-                            self.region_relation.add(r_a, r_b)\n-                        }\n-                    }\n-                }\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => match (*r_a, *r_b) {\n+                    (\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                    ) => self.region_relation.add(r_a, r_b),\n+                    (ty::ReError(_), _) | (_, ty::ReError(_)) => {}\n+                    _ => bug!(\"add_outlives_bounds: unexpected regions\"),\n+                },\n             }\n         }\n     }"}, {"sha": "89ada23c6673aefeaa4ccac65e25ff748ee14a13", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -424,9 +424,6 @@ impl<'tcx> MiniGraph<'tcx> {\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n-                &AddGiven(a, b) => {\n-                    each_edge(a, tcx.mk_re_var(b));\n-                }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),\n                     \"we never add verifications while doing higher-ranked things\","}, {"sha": "7b272dfd2a4547f3dcba6ab063b12ca39eb816af", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -104,26 +104,6 @@ pub struct RegionConstraintData<'tcx> {\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n     pub verifys: Vec<Verify<'tcx>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In\n-    /// particular, we often know from closure fn signatures that a\n-    /// particular free region must be a subregion of a region\n-    /// variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically\n-    /// we record the fact that `'a <= 'b` is implied by the fn\n-    /// signature, and then ignore the constraint when solving\n-    /// equations. This is a bit of a hack but seems to work.\n-    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process.\n@@ -297,9 +277,6 @@ pub(crate) enum UndoLog<'tcx> {\n     /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`.\n-    AddGiven(Region<'tcx>, ty::RegionVid),\n-\n     /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n }\n@@ -348,9 +325,6 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n                 self.data.verifys.pop();\n                 assert_eq!(self.data.verifys.len(), index);\n             }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n             }\n@@ -492,15 +466,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n-    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n-        // cannot add givens once regions are resolved\n-        if self.data.givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n-\n-            self.undo_log.push(AddGiven(sub, sup));\n-        }\n-    }\n-\n     pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -804,11 +769,8 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// Returns `true` if this region constraint data contains no constraints, and `false`\n     /// otherwise.\n     pub fn is_empty(&self) -> bool {\n-        let RegionConstraintData { constraints, member_constraints, verifys, givens } = self;\n-        constraints.is_empty()\n-            && member_constraints.is_empty()\n-            && verifys.is_empty()\n-            && givens.is_empty()\n+        let RegionConstraintData { constraints, member_constraints, verifys } = self;\n+        constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()\n     }\n }\n "}, {"sha": "aeaade1d66c2bd113ab2c26293e048becc90887b", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -388,7 +388,6 @@ fn resolve_negative_obligation<'tcx>(\n     let wf_tys = ocx.assumed_wf_types(param_env, DUMMY_SP, body_def_id);\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n "}, {"sha": "0bde43c54df99892fba558fa3bef7ac282986fb5", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -111,7 +111,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // Check regions assuming the self type of the impl is WF\n             let outlives_env = OutlivesEnvironment::with_bounds(\n                 param_env,\n-                Some(&infcx),\n                 infcx.implied_bounds_tys(\n                     param_env,\n                     parent_cause.body_id,"}, {"sha": "e2c198fabde6dc46129333cb69fe756b6d5ac685", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -3,7 +3,8 @@ use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n use crate::traits::ObligationCause;\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_middle::ty::{self, ParamEnv, Ty};\n+use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n \n pub use rustc_middle::traits::query::OutlivesBound;\n@@ -52,6 +53,10 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         body_id: LocalDefId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>> {\n+        let ty = self.resolve_vars_if_possible(ty);\n+        let ty = OpportunisticRegionResolver::new(self).fold_ty(ty);\n+        assert!(!ty.needs_infer());\n+\n         let span = self.tcx.def_span(body_id);\n         let result = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n@@ -105,10 +110,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx> {\n         tys.into_iter()\n-            .map(move |ty| {\n-                let ty = self.resolve_vars_if_possible(ty);\n-                self.implied_outlives_bounds(param_env, body_id, ty)\n-            })\n+            .map(move |ty| self.implied_outlives_bounds(param_env, body_id, ty))\n             .flatten()\n     }\n }"}, {"sha": "f776fc98a9edeb24b3ba13298659d652e38884c2", "filename": "tests/ui/implied-bounds/normalization.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e84e5ff04a647ce28540300244a26ba120642eea/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e5ff04a647ce28540300244a26ba120642eea/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs?ref=e84e5ff04a647ce28540300244a26ba120642eea", "patch": "@@ -0,0 +1,58 @@\n+// Test that we get implied bounds from complex projections after normalization.\n+\n+// check-pass\n+\n+// implementations wil ensure that\n+// WF(<T as Combine<'a>>::Ty) implies T: 'a\n+trait Combine<'a> {\n+    type Ty;\n+}\n+\n+impl<'a, T: 'a> Combine<'a> for Box<T> {\n+    type Ty = &'a T;\n+}\n+\n+// ======= Wrappers ======\n+\n+// normalizes to a projection\n+struct WrapA<T>(T);\n+impl<'a, T> Combine<'a> for WrapA<T>\n+where\n+    T: Combine<'a>,\n+{\n+    type Ty = T::Ty;\n+}\n+\n+// <WrapB<T> as Combine<'a>>::Ty normalizes to a type variable ?X\n+// with constraint `<T as Combine<'a>>::Ty == ?X`\n+struct WrapB<T>(T);\n+impl<'a, X, T> Combine<'a> for WrapB<T>\n+where\n+    T: Combine<'a, Ty = X>,\n+{\n+    type Ty = X;\n+}\n+\n+// <WrapC<T> as Combine<'a>>::Ty normalizes to `&'a &'?x ()`\n+// with constraint `<T as Combine<'a>>::Ty == &'a &'?x ()`\n+struct WrapC<T>(T);\n+impl<'a, 'x: 'a, T> Combine<'a> for WrapC<T>\n+where\n+    T: Combine<'a, Ty = &'a &'x ()>,\n+{\n+    type Ty = &'a &'x ();\n+}\n+\n+//==== Test implied bounds ======\n+\n+fn test_wrap<'a, 'b, 'c1, 'c2, A, B>(\n+    _: <WrapA<Box<A>> as Combine<'a>>::Ty,        // normalized: &'a A\n+    _: <WrapB<Box<B>> as Combine<'b>>::Ty,        // normalized: &'b B\n+    _: <WrapC<Box<&'c1 ()>> as Combine<'c2>>::Ty, // normalized: &'c2 &'c1 ()\n+) {\n+    None::<&'a A>;\n+    None::<&'b B>;\n+    None::<&'c2 &'c1 ()>;\n+}\n+\n+fn main() {}"}]}