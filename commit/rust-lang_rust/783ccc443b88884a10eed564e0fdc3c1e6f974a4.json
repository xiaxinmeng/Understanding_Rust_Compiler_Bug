{"sha": "783ccc443b88884a10eed564e0fdc3c1e6f974a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4M2NjYzQ0M2I4ODg4NGExMGVlZDU2NGUwZmRjM2MxZTZmOTc0YTQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-04T07:49:40Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-11T10:11:38Z"}, "message": "Make TypeckTables::type_dependent_defs use ItemLocalId instead of NodeId.", "tree": {"sha": "b744078d32f987493d52fbe0b34f396cffa03c01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b744078d32f987493d52fbe0b34f396cffa03c01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/783ccc443b88884a10eed564e0fdc3c1e6f974a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/783ccc443b88884a10eed564e0fdc3c1e6f974a4", "html_url": "https://github.com/rust-lang/rust/commit/783ccc443b88884a10eed564e0fdc3c1e6f974a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/783ccc443b88884a10eed564e0fdc3c1e6f974a4/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9868352b953dc88975324b27e2865d5ee2ea72e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9868352b953dc88975324b27e2865d5ee2ea72e9", "html_url": "https://github.com/rust-lang/rust/commit/9868352b953dc88975324b27e2865d5ee2ea72e9"}], "stats": {"total": 537, "additions": 386, "deletions": 151}, "files": [{"sha": "bb3b248674ab7a84e6c4cd4cb8b225c669403b2c", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -201,4 +201,11 @@ impl DefId {\n     pub fn is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n+\n+    pub fn invalid() -> DefId {\n+        DefId {\n+            krate: INVALID_CRATE,\n+            index: CRATE_DEF_INDEX,\n+        }\n+    }\n }"}, {"sha": "27048a71454bcad09839f621d61ae7dbea9ebee4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 113, "deletions": 62, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -155,6 +155,11 @@ enum ParamMode {\n     Optional\n }\n \n+struct LoweredNodeId {\n+    node_id: NodeId,\n+    hir_id: hir::HirId,\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -278,11 +283,14 @@ impl<'a> LoweringContext<'a> {\n     fn lower_node_id_generic<F>(&mut self,\n                                 ast_node_id: NodeId,\n                                 alloc_hir_id: F)\n-                                -> NodeId\n+                                -> LoweredNodeId\n         where F: FnOnce(&mut Self) -> hir::HirId\n     {\n         if ast_node_id == DUMMY_NODE_ID {\n-            return ast_node_id;\n+            return LoweredNodeId {\n+                node_id: DUMMY_NODE_ID,\n+                hir_id: hir::DUMMY_HIR_ID,\n+            }\n         }\n \n         let min_size = ast_node_id.as_usize() + 1;\n@@ -291,12 +299,22 @@ impl<'a> LoweringContext<'a> {\n             self.node_id_to_hir_id.resize(min_size, hir::DUMMY_HIR_ID);\n         }\n \n-        if self.node_id_to_hir_id[ast_node_id] == hir::DUMMY_HIR_ID {\n+        let existing_hir_id = self.node_id_to_hir_id[ast_node_id];\n+\n+        if existing_hir_id == hir::DUMMY_HIR_ID {\n             // Generate a new HirId\n-            self.node_id_to_hir_id[ast_node_id] = alloc_hir_id(self);\n+            let hir_id = alloc_hir_id(self);\n+            self.node_id_to_hir_id[ast_node_id] = hir_id;\n+            LoweredNodeId {\n+                node_id: ast_node_id,\n+                hir_id,\n+            }\n+        } else {\n+            LoweredNodeId {\n+                node_id: ast_node_id,\n+                hir_id: existing_hir_id,\n+            }\n         }\n-\n-        ast_node_id\n     }\n \n     fn with_hir_id_owner<F>(&mut self, owner: NodeId, f: F)\n@@ -323,7 +341,7 @@ impl<'a> LoweringContext<'a> {\n     /// actually used in the HIR, as that would trigger an assertion in the\n     /// HirIdValidator later on, which makes sure that all NodeIds got mapped\n     /// properly. Calling the method twice with the same NodeId is fine though.\n-    fn lower_node_id(&mut self, ast_node_id: NodeId) -> NodeId {\n+    fn lower_node_id(&mut self, ast_node_id: NodeId) -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let &mut (def_index, ref mut local_id_counter) = this.current_hir_id_owner\n                                                                  .last_mut()\n@@ -340,7 +358,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_node_id_with_owner(&mut self,\n                                 ast_node_id: NodeId,\n                                 owner: NodeId)\n-                                -> NodeId {\n+                                -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let local_id_counter = this.item_local_id_counters\n                                        .get_mut(&owner)\n@@ -375,7 +393,7 @@ impl<'a> LoweringContext<'a> {\n         id\n     }\n \n-    fn next_id(&mut self) -> NodeId {\n+    fn next_id(&mut self) -> LoweredNodeId {\n         self.lower_node_id(self.sess.next_node_id())\n     }\n \n@@ -517,7 +535,7 @@ impl<'a> LoweringContext<'a> {\n         match destination {\n             Some((id, label_ident)) => {\n                 let target = if let Def::Label(loop_id) = self.expect_full_def(id) {\n-                    hir::LoopIdResult::Ok(self.lower_node_id(loop_id))\n+                    hir::LoopIdResult::Ok(self.lower_node_id(loop_id).node_id)\n                 } else {\n                     hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 };\n@@ -534,7 +552,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::Destination {\n                     ident: None,\n                     target_id: hir::ScopeTarget::Loop(\n-                        loop_id.map(|id| Ok(self.lower_node_id(id)))\n+                        loop_id.map(|id| Ok(self.lower_node_id(id).node_id))\n                                .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                                .into())\n                 }\n@@ -557,7 +575,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n-            id: self.lower_node_id(b.id),\n+            id: self.lower_node_id(b.id).node_id,\n             name: self.lower_ident(b.ident),\n             ty: self.lower_ty(&b.ty),\n             span: b.span,\n@@ -594,7 +612,7 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_ty(ty);\n             }\n             TyKind::Path(ref qself, ref path) => {\n-                let id = self.lower_node_id(t.id);\n+                let id = self.lower_node_id(t.id).node_id;\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n                 return self.ty_path(id, t.span, qpath);\n             }\n@@ -645,7 +663,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         P(hir::Ty {\n-            id: self.lower_node_id(t.id),\n+            id: self.lower_node_id(t.id).node_id,\n             node: kind,\n             span: t.span,\n         })\n@@ -758,7 +776,7 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id();\n+            let new_id = self.next_id().node_id;\n             self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n@@ -782,7 +800,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            let new_id = self.next_id();\n+            let new_id = self.next_id().node_id;\n             ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n@@ -887,7 +905,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n         P(hir::Local {\n-            id: self.lower_node_id(l.id),\n+            id: self.lower_node_id(l.id).node_id,\n             ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n@@ -905,8 +923,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(arg.id);\n         hir::Arg {\n-            id: self.lower_node_id(arg.id),\n+            id: node_id,\n+            hir_id,\n             pat: self.lower_pat(&arg.pat),\n         }\n     }\n@@ -969,7 +989,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::TyParam {\n-            id: self.lower_node_id(tp.id),\n+            id: self.lower_node_id(tp.id).node_id,\n             name,\n             bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n@@ -987,7 +1007,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         hir::Lifetime {\n-            id: self.lower_node_id(l.id),\n+            id: self.lower_node_id(l.id).node_id,\n             name: self.lower_ident(l.ident),\n             span: l.span,\n         }\n@@ -1059,7 +1079,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n         hir::WhereClause {\n-            id: self.lower_node_id(wc.id),\n+            id: self.lower_node_id(wc.id).node_id,\n             predicates: wc.predicates\n                           .iter()\n                           .map(|predicate| self.lower_where_predicate(predicate))\n@@ -1098,7 +1118,7 @@ impl<'a> LoweringContext<'a> {\n                                                           ref rhs_ty,\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    id: self.lower_node_id(id),\n+                    id: self.lower_node_id(id).node_id,\n                     lhs_ty: self.lower_ty(lhs_ty),\n                     rhs_ty: self.lower_ty(rhs_ty),\n                     span,\n@@ -1114,16 +1134,16 @@ impl<'a> LoweringContext<'a> {\n                                                .enumerate()\n                                                .map(|f| self.lower_struct_field(f))\n                                                .collect(),\n-                                         self.lower_node_id(id))\n+                                         self.lower_node_id(id).node_id)\n             }\n             VariantData::Tuple(ref fields, id) => {\n                 hir::VariantData::Tuple(fields.iter()\n                                               .enumerate()\n                                               .map(|f| self.lower_struct_field(f))\n                                               .collect(),\n-                                        self.lower_node_id(id))\n+                                        self.lower_node_id(id).node_id)\n             }\n-            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id).node_id),\n         }\n     }\n \n@@ -1134,7 +1154,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitRef {\n             path,\n-            ref_id: self.lower_node_id(p.ref_id),\n+            ref_id: self.lower_node_id(p.ref_id).node_id,\n         }\n     }\n \n@@ -1149,7 +1169,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n         hir::StructField {\n             span: f.span,\n-            id: self.lower_node_id(f.id),\n+            id: self.lower_node_id(f.id).node_id,\n             name: self.lower_ident(match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n@@ -1198,8 +1218,11 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+\n         P(hir::Block {\n-            id: self.lower_node_id(b.id),\n+            id: node_id,\n+            hir_id,\n             stmts: stmts.into(),\n             expr,\n             rules: self.lower_block_check_mode(&b.rules),\n@@ -1249,7 +1272,7 @@ impl<'a> LoweringContext<'a> {\n                                         hir::Visibility::Restricted {\n                                             path: path.clone(),\n                                             // We are allocating a new NodeId here\n-                                            id: this.next_id(),\n+                                            id: this.next_id().node_id,\n                                         }\n                                     }\n                                 };\n@@ -1387,7 +1410,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n             hir::TraitItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1448,7 +1471,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ImplItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n@@ -1540,7 +1563,7 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         Some(hir::Item {\n-            id: self.lower_node_id(i.id),\n+            id: self.lower_node_id(i.id).node_id,\n             name,\n             attrs,\n             node,\n@@ -1552,7 +1575,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ForeignItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: i.ident.name,\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1630,8 +1653,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+\n         P(hir::Pat {\n-            id: self.lower_node_id(p.id),\n+            id: node_id,\n+            hir_id,\n             node: match p.node {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n@@ -1813,7 +1839,7 @@ impl<'a> LoweringContext<'a> {\n                     let call_move_val_init =\n                         hir::StmtSemi(\n                             make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n-                            self.next_id());\n+                            self.next_id().node_id);\n                     let call_move_val_init = respan(e.span, call_move_val_init);\n \n                     let place = self.expr_ident(e.span, place_ident, place_binding);\n@@ -1883,11 +1909,15 @@ impl<'a> LoweringContext<'a> {\n                             // wrap the if-let expr in a block\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n-                            let id = self.next_id();\n+                            let LoweredNodeId {\n+                                node_id,\n+                                hir_id,\n+                            } = self.next_id();\n                             let blk = P(hir::Block {\n                                 stmts: hir_vec![],\n                                 expr: Some(els),\n-                                id,\n+                                id: node_id,\n+                                hir_id,\n                                 rules: hir::DefaultBlock,\n                                 span,\n                                 targeted_by_break: false,\n@@ -1986,8 +2016,11 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n+                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+\n                 return hir::Expr {\n-                    id: self.lower_node_id(e.id),\n+                    id: node_id,\n+                    hir_id,\n                     node: if is_unit {\n                         hir::ExprPath(struct_path)\n                     } else {\n@@ -2234,7 +2267,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir::MatchSource::ForLoopDesugar),\n                                 ThinVec::new()))\n                 };\n-                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id()));\n+                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id().node_id));\n \n                 let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n \n@@ -2254,7 +2287,7 @@ impl<'a> LoweringContext<'a> {\n                 let body_block = self.with_loop_scope(e.id,\n                                                         |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id()));\n+                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id().node_id));\n \n                 let loop_block = P(self.block_all(e.span,\n                                                   hir_vec![next_let,\n@@ -2266,8 +2299,10 @@ impl<'a> LoweringContext<'a> {\n                 // `[opt_ident]: loop { ... }`\n                 let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n                                               hir::LoopSource::ForLoop);\n+                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n-                    id: self.lower_node_id(e.id),\n+                    id: node_id,\n+                    hir_id,\n                     node: loop_expr,\n                     span: e.span,\n                     attrs: ThinVec::new(),\n@@ -2406,8 +2441,11 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+\n         hir::Expr {\n-            id: self.lower_node_id(e.id),\n+            id: node_id,\n+            hir_id,\n             node: kind,\n             span: e.span,\n             attrs: e.attrs.clone(),\n@@ -2420,7 +2458,7 @@ impl<'a> LoweringContext<'a> {\n                 node: hir::StmtDecl(P(Spanned {\n                     node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n-                }), self.lower_node_id(s.id)),\n+                }), self.lower_node_id(s.id).node_id),\n                 span: s.span,\n             },\n             StmtKind::Item(ref it) => {\n@@ -2431,22 +2469,22 @@ impl<'a> LoweringContext<'a> {\n                         node: hir::DeclItem(item_id),\n                         span: s.span,\n                     }), id.take()\n-                          .map(|id| self.lower_node_id(id))\n-                          .unwrap_or_else(|| self.next_id())),\n+                          .map(|id| self.lower_node_id(id).node_id)\n+                          .unwrap_or_else(|| self.next_id().node_id)),\n                     span: s.span,\n                 }).collect();\n             }\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n                     node: hir::StmtExpr(P(self.lower_expr(e)),\n-                                          self.lower_node_id(s.id)),\n+                                          self.lower_node_id(s.id).node_id),\n                     span: s.span,\n                 }\n             }\n             StmtKind::Semi(ref e) => {\n                 Spanned {\n                     node: hir::StmtSemi(P(self.lower_expr(e)),\n-                                          self.lower_node_id(s.id)),\n+                                          self.lower_node_id(s.id).node_id),\n                     span: s.span,\n                 }\n             }\n@@ -2477,9 +2515,9 @@ impl<'a> LoweringContext<'a> {\n                 hir::Visibility::Restricted {\n                     path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: if let Some(owner) = explicit_owner {\n-                        self.lower_node_id_with_owner(id, owner)\n+                        self.lower_node_id_with_owner(id, owner).node_id\n                     } else {\n-                        self.lower_node_id(id)\n+                        self.lower_node_id(id).node_id\n                     }\n                 }\n             }\n@@ -2621,8 +2659,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         hir::Expr {\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             node,\n             span,\n             attrs,\n@@ -2639,13 +2679,13 @@ impl<'a> LoweringContext<'a> {\n             pat,\n             ty: None,\n             init: ex,\n-            id: self.next_id(),\n+            id: self.next_id().node_id,\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n-        respan(sp, hir::StmtDecl(P(decl), self.next_id()))\n+        respan(sp, hir::StmtDecl(P(decl), self.next_id().node_id))\n     }\n \n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n@@ -2665,10 +2705,13 @@ impl<'a> LoweringContext<'a> {\n \n     fn block_all(&mut self, span: Span, stmts: hir::HirVec<hir::Stmt>, expr: Option<P<hir::Expr>>)\n                  -> hir::Block {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         hir::Block {\n             stmts,\n             expr,\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             rules: hir::DefaultBlock,\n             span,\n             targeted_by_break: false,\n@@ -2712,18 +2755,22 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingAnnotation)\n                               -> P<hir::Pat> {\n-        let id = self.next_id();\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name);\n-            let def_index = defs\n-                .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n+            let def_index = defs.create_def_with_parent(parent_def,\n+                                                        node_id,\n+                                                        def_path_data,\n+                                                        REGULAR_SPACE,\n+                                                        Mark::root());\n             DefId::local(def_index)\n         };\n \n         P(hir::Pat {\n-            id,\n+            id: node_id,\n+            hir_id,\n             node: hir::PatKind::Binding(bm,\n                                         def_id,\n                                         Spanned {\n@@ -2740,8 +2787,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         P(hir::Pat {\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             node: pat,\n             span,\n         })\n@@ -2770,11 +2819,13 @@ impl<'a> LoweringContext<'a> {\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n                          -> hir::Expr {\n-        let id = self.next_id();\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         let block = P(hir::Block {\n             rules: rule,\n             span,\n-            id,\n+            id: node_id,\n+            hir_id,\n             stmts,\n             expr: Some(expr),\n             targeted_by_break: false,\n@@ -2799,7 +2850,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n-                    id = self.next_id();\n+                    id = self.next_id().node_id;\n \n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n@@ -2813,7 +2864,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n-            id: self.next_id(),\n+            id: self.next_id().node_id,\n             span,\n             name: keywords::Invalid.name()\n         }"}, {"sha": "d3e3998360b602c114be14ae0b171769f9001e04", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -465,6 +465,10 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n+    pub fn find_node_for_hir_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n+        self.node_to_hir_id.binary_search(&hir_id).unwrap()\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,"}, {"sha": "3b73647f0eb0edde45a8570c27d70112634ad636", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -357,6 +357,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[inline]\n     pub fn definitions(&self) -> &Definitions {\n         &self.definitions\n     }\n@@ -377,21 +378,29 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_path(def_id.index)\n     }\n \n+    #[inline]\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n                  node, self.find_entry(node))\n         })\n     }\n \n+    #[inline]\n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n         self.definitions.opt_local_def_id(node)\n     }\n \n+    #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n+        self.definitions.node_to_hir_id(node_id)\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }"}, {"sha": "a2be74b552234350f7d9afe2e55ad2ef962a2675", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -129,9 +129,11 @@ pub const CRATE_HIR_ID: HirId = HirId {\n \n pub const DUMMY_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n-    local_id: ItemLocalId(!0)\n+    local_id: DUMMY_ITEM_LOCAL_ID,\n };\n \n+pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -547,6 +549,7 @@ pub struct Block {\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -560,6 +563,7 @@ pub struct Block {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n }\n@@ -986,6 +990,7 @@ pub struct Expr {\n     pub span: Span,\n     pub node: Expr_,\n     pub attrs: ThinVec<Attribute>,\n+    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Expr {\n@@ -1423,6 +1428,7 @@ pub struct InlineAsm {\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration"}, {"sha": "fca70de704f39c8df7ebbf62de4fba7587f8289a", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -359,6 +359,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n             ref stmts,\n             ref expr,\n             id,\n+            hir_id: _,\n             rules,\n             span,\n             targeted_by_break,\n@@ -423,6 +424,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::P\n \n         let hir::Pat {\n             id,\n+            hir_id: _,\n             ref node,\n             ref span\n         } = *self;\n@@ -551,6 +553,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n                 id,\n+                hir_id: _,\n                 ref span,\n                 ref node,\n                 ref attrs\n@@ -1021,7 +1024,8 @@ impl_stable_hash_for!(enum hir::Stmt_ {\n \n impl_stable_hash_for!(struct hir::Arg {\n     pat,\n-    id\n+    id,\n+    hir_id\n });\n \n impl_stable_hash_for!(struct hir::Body {"}, {"sha": "37ef7e8cbfa3bfb1be89a42142d41a7d8998c693", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -618,6 +618,7 @@ for ty::TypeckTables<'gcx> {\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n+            local_id_root: _,\n             ref type_dependent_defs,\n             ref node_types,\n             ref node_substs,\n@@ -637,7 +638,9 @@ for ty::TypeckTables<'gcx> {\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_nodemap(hcx, hasher, type_dependent_defs);\n+            ich::hash_stable_hashmap(hcx, hasher, type_dependent_defs, |_, item_local_id| {\n+                *item_local_id\n+            });\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n             ich::hash_stable_nodemap(hcx, hasher, node_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);"}, {"sha": "6aa84a97503300fcdefcc58c6eaee3f7f3a5ed93", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -358,8 +358,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty()));\n+    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(table_owner)));\n         self\n     }\n "}, {"sha": "cd06806ca6017d7e79946c08f6a0601a427f9da3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -43,7 +43,7 @@ use syntax::ast;\n use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n use hir;\n-use hir::def_id::LOCAL_CRATE;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n \n@@ -986,7 +986,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut cx = LateContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(DefId::invalid()),\n         param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),"}, {"sha": "4cf27981e1b68f87b631481ab0d5af15ea5f2b99", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n+    fn lookup_and_handle_method(&mut self, id: hir::ItemLocalId) {\n         self.check_def_id(self.tables.type_dependent_defs[&id].def_id());\n     }\n \n@@ -119,6 +119,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n+\n+\n         let variant = match self.tables.node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n@@ -235,11 +237,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(expr.id);\n+                self.lookup_and_handle_method(expr.hir_id.local_id);\n             }\n             hir::ExprField(ref lhs, ref name) => {\n                 self.handle_field_access(&lhs, name.node);\n@@ -282,7 +284,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 self.handle_definition(def);\n             }\n             _ => ()\n@@ -425,7 +427,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(DefId::invalid()),\n         live_symbols: box FxHashSet(),\n         struct_has_extern_repr: false,\n         ignore_non_const_paths: false,"}, {"sha": "e8ecf9c21cd357ef0407b5585d913aadadf7b7c9", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -19,6 +19,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use hir::{self, PatKind};\n use hir::def::Def;\n+use hir::def_id::DefId;\n use hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n \n #[derive(Copy, Clone)]\n@@ -165,7 +166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let def_id = self.tables.type_dependent_defs[&expr.hir_id.local_id].def_id();\n                 let sig = self.tcx.fn_sig(def_id);\n                 debug!(\"effect: method call case, signature is {:?}\",\n                         sig);\n@@ -262,7 +263,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = EffectCheckVisitor {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(DefId::invalid()),\n         body_id: hir::BodyId { node_id: ast::CRATE_NODE_ID },\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };"}, {"sha": "80abe87470c2f8ac0b674390d7687697e0845029", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -537,7 +537,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.tables.type_dependent_defs[&call.id].def_id();\n+                let def_id = self.mc.tables.type_dependent_defs[&call.hir_id.local_id].def_id();\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n@@ -863,7 +863,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = mc.tables.qpath_def(qpath, pat.id);\n+            let def = mc.tables.qpath_def(qpath, pat.hir_id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {"}, {"sha": "83278bd88e92d0e3b0305de5d48262b96208a6bb", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.tables.qpath_def(qpath, expr.id)\n+            self.tables.qpath_def(qpath, expr.hir_id)\n         } else {\n             Def::Err\n         };"}, {"sha": "c6773250bde98cd5b2250ac2b270e557e38d7ae6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -604,7 +604,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(ref qpath) => {\n-            let def = self.tables.qpath_def(qpath, expr.id);\n+            let def = self.tables.qpath_def(qpath, expr.hir_id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -1124,7 +1124,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         match pat.node {\n           PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-            let def = self.tables.qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.hir_id);\n             let (cmt, expected_len) = match def {\n                 Def::Err => {\n                     debug!(\"access to unresolvable pattern {:?}\", pat);\n@@ -1161,7 +1161,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           PatKind::Struct(ref qpath, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            let def = self.tables.qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.hir_id);\n             let cmt = match def {\n                 Def::Err => {\n                     debug!(\"access to unresolvable pattern {:?}\", pat);"}, {"sha": "98f82a51267fea4423bbd01b028831364d9723a4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -107,10 +107,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n-                Some(self.tables.qpath_def(qpath, expr.id))\n+                Some(self.tables.qpath_def(qpath, expr.hir_id))\n             }\n             hir::ExprMethodCall(..) => {\n-                Some(self.tables.type_dependent_defs[&expr.id])\n+                Some(self.tables.type_dependent_defs[&expr.hir_id.local_id])\n             }\n             _ => None\n         };\n@@ -375,7 +375,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     });\n     let mut reachable_context = ReachableContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(DefId::invalid()),\n         reachable_symbols: NodeSet(),\n         worklist: Vec::new(),\n         any_library,"}, {"sha": "46bb13c89ba7849efa7c83995525c77591c00752", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -14,7 +14,7 @@ use dep_graph::DepGraph;\n use errors::DiagnosticBuilder;\n use session::Session;\n use middle;\n-use hir::TraitMap;\n+use hir::{TraitMap};\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n@@ -42,7 +42,7 @@ use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n@@ -209,9 +209,12 @@ pub struct CommonTypes<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TypeckTables<'tcx> {\n+    /// The HirId::owner all ItemLocalIds in this table are relative to.\n+    pub local_id_root: DefId,\n+\n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n-    pub type_dependent_defs: NodeMap<Def>,\n+    pub type_dependent_defs: ItemLocalMap<Def>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n@@ -271,9 +274,10 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty() -> TypeckTables<'tcx> {\n+    pub fn empty(local_id_root: DefId) -> TypeckTables<'tcx> {\n         TypeckTables {\n-            type_dependent_defs: NodeMap(),\n+            local_id_root,\n+            type_dependent_defs: ItemLocalMap(),\n             node_types: FxHashMap(),\n             node_substs: NodeMap(),\n             adjustments: NodeMap(),\n@@ -291,11 +295,12 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_def(&self, qpath: &hir::QPath, id: NodeId) -> Def {\n+    pub fn qpath_def(&self, qpath: &hir::QPath, id: hir::HirId) -> Def {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n             hir::QPath::TypeRelative(..) => {\n-                self.type_dependent_defs.get(&id).cloned().unwrap_or(Def::Err)\n+                self.validate_hir_id(id);\n+                self.type_dependent_defs.get(&id.local_id).cloned().unwrap_or(Def::Err)\n             }\n         }\n     }\n@@ -373,7 +378,8 @@ impl<'tcx> TypeckTables<'tcx> {\n             return false;\n         }\n \n-        match self.type_dependent_defs.get(&expr.id) {\n+        self.validate_hir_id(expr.hir_id);\n+        match self.type_dependent_defs.get(&expr.hir_id.local_id) {\n             Some(&Def::Method(_)) => true,\n             _ => false\n         }\n@@ -382,6 +388,30 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n+\n+    /// Validate that a NodeId can safely be converted to an ItemLocalId for\n+    /// this table.\n+    #[inline]\n+    pub fn validate_hir_id(&self, hir_id: hir::HirId) {\n+        #[cfg(debug_assertions)]\n+        {\n+            if self.local_id_root.is_local() {\n+                if hir_id.owner != self.local_id_root.index {\n+                    ty::tls::with(|tcx| {\n+                        let node_id = tcx.hir\n+                                         .definitions()\n+                                         .find_node_for_hir_id(hir_id);\n+\n+                        bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                              TypeckTables with local_id_root {:?}\",\n+                              tcx.hir.node_to_string(node_id),\n+                              DefId::local(hir_id.owner),\n+                              self.local_id_root)\n+                    });\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {"}, {"sha": "c397371c5c7672021fcca82928b05eb20ad49199", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -13,19 +13,22 @@\n #![allow(non_snake_case)]\n \n use hir::def_id::DefId;\n+use hir::ItemLocalId;\n use syntax::ast;\n \n pub use rustc_data_structures::fx::FxHashMap;\n pub use rustc_data_structures::fx::FxHashSet;\n \n pub type NodeMap<T> = FxHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FxHashMap<DefId, T>;\n+pub type ItemLocalMap<T> = FxHashMap<ItemLocalId, T>;\n \n pub type NodeSet = FxHashSet<ast::NodeId>;\n pub type DefIdSet = FxHashSet<DefId>;\n \n pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn ItemLocalMap<T>() -> ItemLocalMap<T> { FxHashMap() }\n pub fn NodeSet() -> NodeSet { FxHashSet() }\n pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n "}, {"sha": "cce511daf8ae7970882c6770a953d96561fcd853", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -276,7 +276,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       }\n       hir::ExprPath(ref qpath) => {\n         let substs = cx.tables.node_substs(e.id).subst(tcx, cx.substs);\n-          match cx.tables.qpath_def(qpath, e.id) {\n+          match cx.tables.qpath_def(qpath, e.hir_id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                     match tcx.at(e.span).const_eval(cx.param_env.and((def_id, substs))) {"}, {"sha": "30183ca2daf71ef9caebf47d5ea56e59329034af", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, pat.id, pat.id, pat.span);\n+                return self.lower_path(qpath, (pat.id, pat.hir_id), pat.id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -590,12 +590,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n-                  id: ast::NodeId,\n+                  (id, hir_id): (ast::NodeId, hir::HirId),\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n         let ty = self.tables.node_id_to_type(id);\n-        let def = self.tables.qpath_def(qpath, id);\n+        let def = self.tables.qpath_def(qpath, hir_id);\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let substs = self.tables.node_substs(id);\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     _ => bug!()\n                 };\n                 let ty = self.tables.node_id_to_type(callee.id);\n-                let def = self.tables.qpath_def(qpath, callee.id);\n+                let def = self.tables.qpath_def(qpath, callee.hir_id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n                     _ => {\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -755,7 +755,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprPath(ref qpath) => {\n-                return self.lower_path(qpath, expr.id, pat_id, span);\n+                return self.lower_path(qpath, (expr.id, expr.hir_id), pat_id, span);\n             }\n \n             _ => self.lower_lit(expr)"}, {"sha": "bc9bfa4049723fccdce3fc7aef4277a455a8b1d9", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -196,6 +196,16 @@ impl<I: Idx, T: Clone> IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T: Ord> IndexVec<I, T> {\n+    #[inline]\n+    pub fn binary_search(&self, value: &T) -> Result<I, I> {\n+        match self.raw.binary_search(value) {\n+            Ok(i) => Ok(Idx::new(i)),\n+            Err(i) => Err(Idx::new(i)),\n+        }\n+    }\n+}\n+\n impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     type Output = T;\n "}, {"sha": "51f5cc4f249f26268ed488ed5761f90c9529a772", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -45,6 +45,7 @@ use std::option;\n use std::path::Path;\n use std::str::FromStr;\n \n+use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n use rustc::hir;\n@@ -232,7 +233,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let empty_tables = ty::TypeckTables::empty();\n+                    let empty_tables = ty::TypeckTables::empty(DefId::invalid());\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                         tables: Cell::new(&empty_tables)"}, {"sha": "85ec606e87efd993fa5ac78cb054c5eaf196c24f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -896,7 +896,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             match cx.tcx.hir.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n                     };\n@@ -934,7 +934,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for method calls and overloaded operators.\n             if cx.tables.is_method_call(expr) {\n-                let def_id = cx.tables.type_dependent_defs[&id].def_id();\n+                let local_id = cx.tcx.hir.definitions().node_to_hir_id(id).local_id;\n+                let def_id = cx.tables.type_dependent_defs[&local_id].def_id();\n                 let substs = cx.tables.node_substs(id);\n                 if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                     return true;\n@@ -945,7 +946,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             match expr.node {\n                 hir::ExprCall(ref callee, _) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n                     };\n@@ -1179,7 +1180,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                cx.tables.qpath_def(qpath, expr.id)\n+                cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {\n                 return None;\n             };"}, {"sha": "3effc29d67e2db9e18a1843863b08eb579272320", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -450,7 +450,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprPath(ref qpath) => {\n-            let def = cx.tables().qpath_def(qpath, expr.id);\n+            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n             convert_path_expr(cx, expr, def)\n         }\n \n@@ -580,7 +580,8 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  -> Expr<'tcx> {\n     let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n-        (cx.tables().type_dependent_defs[&expr.id].def_id(),\n+        cx.tables().validate_hir_id(expr.hir_id);\n+        (cx.tables().type_dependent_defs[&expr.hir_id.local_id].def_id(),\n          cx.tables().node_substs(expr.id))\n     });\n     Expr {"}, {"sha": "b3a1509972a041acdbcee5b92d41b93c16fa6af1", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -329,7 +329,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n-            let def = v.tables.qpath_def(qpath, e.id);\n+            let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n@@ -365,7 +365,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                v.tables.qpath_def(qpath, callee.id)\n+                v.tables.qpath_def(qpath, callee.hir_id)\n             } else {\n                 Def::Err\n             };\n@@ -387,7 +387,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let def_id = v.tables.type_dependent_defs[&e.id].def_id();\n+            v.tables.validate_hir_id(e.hir_id);\n+            let def_id = v.tables.type_dependent_defs[&e.hir_id.local_id].def_id();\n             match v.tcx.associated_item(def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n@@ -471,7 +472,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir.krate().visit_all_item_likes(&mut CheckCrateVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(DefId::invalid()),\n         in_fn: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),"}, {"sha": "c1cab0cc8f744d1de90835e7630be8d0c59c95b9", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -473,6 +473,7 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: ast::NodeId,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n@@ -489,6 +490,22 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n+// Set the correct TypeckTables for the given `item_id` (or an empty table if\n+// there is no TypeckTables for the item).\n+fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           item_id: ast::NodeId,\n+                           tables: &mut &'a ty::TypeckTables<'tcx>,\n+                           empty_tables: &'a ty::TypeckTables<'tcx>)\n+                           -> &'a ty::TypeckTables<'tcx> {\n+    let def_id = tcx.hir.local_def_id(item_id);\n+\n+    if tcx.has_typeck_tables(def_id) {\n+        replace(tables, tcx.typeck_tables_of(def_id))\n+    } else {\n+        replace(tables, empty_tables)\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n@@ -505,14 +522,28 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = replace(&mut self.current_item, item.id);\n+        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_trait_item(self, ti);\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_impl_item(self, ii);\n+        self.tables = orig_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprStruct(ref qpath, ref fields, ref base) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 if let Some(ref base) = *base {\n@@ -539,7 +570,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n@@ -564,6 +595,7 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n     span: Span,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n@@ -716,7 +748,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n-                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                self.tables.validate_hir_id(expr.hir_id);\n+                let def_id = self.tables.type_dependent_defs[&expr.hir_id.local_id].def_id();\n                 self.span = span;\n                 if self.tcx.type_of(def_id).visit_with(self) {\n                     return;\n@@ -732,7 +765,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         // Inherent associated constants don't have self type in substs,\n         // we have to check it additionally.\n         if let hir::QPath::TypeRelative(..) = *qpath {\n-            if let Some(def) = self.tables.type_dependent_defs.get(&id).cloned() {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            self.tables.validate_hir_id(hir_id);\n+            if let Some(def) = self.tables.type_dependent_defs.get(&hir_id.local_id).cloned() {\n                 if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n                         if self.tcx.type_of(impl_def_id).visit_with(self) {\n@@ -770,6 +805,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // Check types in item interfaces\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = self.current_item;\n+        let orig_tables = update_tables(self.tcx,\n+                                        item.id,\n+                                        &mut self.tables,\n+                                        self.empty_tables);\n \n         match item.node {\n             hir::ItemExternCrate(..) | hir::ItemMod(..) |\n@@ -829,8 +868,21 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n+        self.tables = orig_tables;\n         self.current_item = orig_current_item;\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_trait_item(self, ti);\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_impl_item(self, ii);\n+        self.tables = orig_tables;\n+    }\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -1606,21 +1658,26 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let krate = tcx.hir.krate();\n \n+    let empty_tables = ty::TypeckTables::empty(DefId::invalid());\n+\n+\n     // Check privacy of names not checked in previous compilation stages.\n     let mut visitor = NamePrivacyVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &empty_tables,\n         current_item: CRATE_NODE_ID,\n+        empty_tables: &empty_tables,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n     let mut visitor = TypePrivacyVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &empty_tables,\n         current_item: DefId::local(CRATE_DEF_INDEX),\n         span: krate.span,\n+        empty_tables: &empty_tables,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "d46d8624a12cab52c80697259ad423dbebc37edc", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -550,7 +550,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let method_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let local_id = self.tcx.hir.definitions().node_to_hir_id(expr.id).local_id;\n+                let method_id = self.tables.type_dependent_defs[&local_id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n@@ -586,7 +587,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n-                self.tables.qpath_def(qpath, id)\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.tables.qpath_def(qpath, hir_id)\n             }\n \n             Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n@@ -975,7 +977,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n \n     let save_ctxt = SaveContext {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(DefId::invalid()),\n         analysis: analysis,\n         span_utils: SpanUtils::new(&tcx.sess),\n         config: find_config(config),"}, {"sha": "cdf1c3b235b67a6dcd23e7aede8612110d5be747", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                        self.tables.borrow().qpath_def(qpath, expr.id)\n+                        self.tables.borrow().qpath_def(qpath, expr.hir_id)\n                     } else {\n                         Def::Err\n                     };\n@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.write_method_call(call_expr.id, method_callee);\n+        self.write_method_call((call_expr.id, call_expr.hir_id), method_callee);\n         output_type\n     }\n }\n@@ -364,7 +364,8 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 adjustments.extend(autoref);\n                 fcx.apply_adjustments(self.callee_expr, adjustments);\n \n-                fcx.write_method_call(self.call_expr.id, method_callee);\n+                fcx.write_method_call((self.call_expr.id, self.call_expr.hir_id),\n+                                      method_callee);\n             }\n             None => {\n                 span_bug!(self.call_expr.span,"}, {"sha": "a6f904b0c96c48f0e437acee9fbb94d4755c20a1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.id, method);\n+        self.write_method_call((expr.id, expr.hir_id), method);\n \n         let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n             (r, mt.mutbl)"}, {"sha": "885472a76a92f6977433a2c4eb2369a6f2c4ca30", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -572,8 +572,16 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let hir_id_root = if def_id.is_local() {\n+            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let hir_id = tcx.hir.definitions().node_to_hir_id(node_id);\n+            DefId::local(hir_id.owner)\n+        } else {\n+            def_id\n+        };\n+\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_id_root),\n             def_id,\n         }\n     }\n@@ -840,7 +848,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n     let body = tcx.hir.body(body_id);\n \n-    Inherited::build(tcx, def_id).enter(|inh| {\n+    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n             let fn_sig = tcx.fn_sig(def_id);\n@@ -887,7 +895,13 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         fcx.resolve_type_vars_in_body(body)\n-    })\n+    });\n+\n+    // Consistency check our TypeckTables instance can hold all ItemLocalIds\n+    // it will need to hold.\n+    assert_eq!(tables.local_id_root,\n+               DefId::local(tcx.hir.definitions().node_to_hir_id(id).owner));\n+    tables\n }\n \n fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n@@ -1804,8 +1818,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_method_call(&self, node_id: ast::NodeId, method: MethodCallee<'tcx>) {\n-        self.tables.borrow_mut().type_dependent_defs.insert(node_id, Def::Method(method.def_id));\n+    // The NodeId and the ItemLocalId must identify the same item. We just pass\n+    // both of them for consistency checking.\n+    pub fn write_method_call(&self,\n+                             (node_id, hir_id): (ast::NodeId, hir::HirId),\n+                             method: MethodCallee<'tcx>) {\n+        {\n+            let mut tables = self.tables.borrow_mut();\n+            tables.validate_hir_id(hir_id);\n+            tables.type_dependent_defs.insert(hir_id.local_id, Def::Method(method.def_id));\n+        }\n         self.write_substs(node_id, method.substs);\n     }\n \n@@ -2254,7 +2276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 self.apply_adjustments(base_expr, adjustments);\n \n-                self.write_method_call(expr.id, method);\n+                self.write_method_call((expr.id, expr.hir_id), method);\n                 (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n             });\n             if result.is_some() {\n@@ -2794,7 +2816,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               expr,\n                                               rcvr) {\n             Ok(method) => {\n-                self.write_method_call(expr.id, method);\n+                self.write_method_call((expr.id, expr.hir_id), method);\n                 Ok(method)\n             }\n             Err(error) => {\n@@ -3499,7 +3521,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }]);\n                             }\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.write_method_call(expr.id, method);\n+                            self.write_method_call((expr.id, expr.hir_id), method);\n                         } else {\n                             type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n                                                \"type `{}` cannot be dereferenced\",\n@@ -4000,7 +4022,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n+                let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                let mut tables = self.tables.borrow_mut();\n+                tables.validate_hir_id(hir_id);\n+                tables.type_dependent_defs.insert(hir_id.local_id, def);\n \n                 (def, ty)\n             }\n@@ -4041,7 +4066,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        let mut tables = self.tables.borrow_mut();\n+        tables.validate_hir_id(hir_id);\n+        tables.type_dependent_defs.insert(hir_id.local_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n "}, {"sha": "71457377b10888aeabf6cce04f5be5fb28586205", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             .or_insert(vec![]).push(autoref);\n                     }\n                 }\n-                self.write_method_call(expr.id, method);\n+                self.write_method_call((expr.id, expr.hir_id), method);\n \n                 method.sig.output()\n             }\n@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(op.is_by_value());\n         match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n             Ok(method) => {\n-                self.write_method_call(ex.id, method);\n+                self.write_method_call((ex.id, ex.hir_id), method);\n                 method.sig.output()\n             }\n             Err(()) => {"}, {"sha": "93d0e6e976a700d9ba2657e3cb36a43897dcfa1d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783ccc443b88884a10eed564e0fdc3c1e6f974a4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=783ccc443b88884a10eed564e0fdc3c1e6f974a4", "patch": "@@ -14,6 +14,7 @@\n \n use check::FnCtxt;\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -34,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut wbcx = WritebackCx::new(self, body);\n         for arg in &body.arguments {\n-            wbcx.visit_node_id(arg.pat.span, arg.id);\n+            wbcx.visit_node_id(arg.pat.span, (arg.id, arg.hir_id));\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n@@ -74,10 +75,13 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n-        -> WritebackCx<'cx, 'gcx, 'tcx> {\n+        -> WritebackCx<'cx, 'gcx, 'tcx>\n+    {\n+        let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n+\n         WritebackCx {\n             fcx: fcx,\n-            tables: ty::TypeckTables::empty(),\n+            tables: ty::TypeckTables::empty(DefId::local(owner.owner)),\n             body: body\n         }\n     }\n@@ -105,7 +109,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs.remove(&e.id);\n+                    tables.validate_hir_id(e.hir_id);\n+                    tables.type_dependent_defs.remove(&e.hir_id.local_id);\n                     tables.node_substs.remove(&e.id);\n                 }\n             }\n@@ -119,7 +124,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs.remove(&e.id);\n+                    tables.validate_hir_id(e.hir_id);\n+                    tables.type_dependent_defs.remove(&e.hir_id.local_id);\n                     tables.node_substs.remove(&e.id);\n \n                     match e.node {\n@@ -157,12 +163,12 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         self.fix_scalar_builtin_expr(e);\n \n-        self.visit_node_id(e.span, e.id);\n+        self.visit_node_id(e.span, (e.id, e.hir_id));\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n             for arg in &body.arguments {\n-                self.visit_node_id(e.span, arg.id);\n+                self.visit_node_id(e.span, (arg.id, arg.hir_id));\n             }\n \n             self.visit_body(body);\n@@ -172,7 +178,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        self.visit_node_id(b.span, b.id);\n+        self.visit_node_id(b.span, (b.id, b.hir_id));\n         intravisit::walk_block(self, b);\n     }\n \n@@ -186,7 +192,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             _ => {}\n         };\n \n-        self.visit_node_id(p.span, p.id);\n+        self.visit_node_id(p.span, (p.id, p.hir_id));\n         intravisit::walk_pat(self, p);\n     }\n \n@@ -277,10 +283,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_node_id(&mut self, span: Span, node_id: ast::NodeId) {\n-        // Export associated path extensions and method resultions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_dependent_defs.remove(&node_id) {\n-            self.tables.type_dependent_defs.insert(node_id, def);\n+    fn visit_node_id(&mut self,\n+                     span: Span,\n+                     (node_id, hir_id): (ast::NodeId, hir::HirId)) {\n+        {\n+            let mut fcx_tables = self.fcx.tables.borrow_mut();\n+            fcx_tables.validate_hir_id(hir_id);\n+            // Export associated path extensions and method resultions.\n+            if let Some(def) = fcx_tables.type_dependent_defs.remove(&hir_id.local_id) {\n+                self.tables.validate_hir_id(hir_id);\n+                self.tables.type_dependent_defs.insert(hir_id.local_id, def);\n+            }\n         }\n \n         // Resolve any borrowings for the node with id `node_id`"}]}