{"sha": "52805d233b59503cdfe58ee21e894ed6bb3b1da9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODA1ZDIzM2I1OTUwM2NkZmU1OGVlMjFlODk0ZWQ2YmIzYjFkYTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-06-06T18:34:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-06-08T14:06:43Z"}, "message": "std: Avoid panics in rust_eh_personality\n\nThis commit removes a few calls to panic and/or assert in `rust_eh_personality`.\nThis function definitely can't itself panic (that'd probably segfault or do\nsomething else weird) and I was also noticing that a `pub extern fn foo() {}`\ncdylib was abnormally large. Turns out all that size was the panicking machinery\nbrought in by the personality function!\n\nThe change here is to return a `Result` internally so we can bubble up the fatal\nerror, eventually translating to the appropriate error code for the libunwind\nABI.", "tree": {"sha": "36df6e39ebdde78dc3001625f5d6a612d30e0fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36df6e39ebdde78dc3001625f5d6a612d30e0fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52805d233b59503cdfe58ee21e894ed6bb3b1da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52805d233b59503cdfe58ee21e894ed6bb3b1da9", "html_url": "https://github.com/rust-lang/rust/commit/52805d233b59503cdfe58ee21e894ed6bb3b1da9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52805d233b59503cdfe58ee21e894ed6bb3b1da9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae7920153331f26f2bc144f62082e95e74c2ba31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7920153331f26f2bc144f62082e95e74c2ba31", "html_url": "https://github.com/rust-lang/rust/commit/ae7920153331f26f2bc144f62082e95e74c2ba31"}], "stats": {"total": 78, "additions": 48, "deletions": 30}, "files": [{"sha": "0c326ce3718435f6f4517275f1b7838e12b931b8", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/52805d233b59503cdfe58ee21e894ed6bb3b1da9/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52805d233b59503cdfe58ee21e894ed6bb3b1da9/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=52805d233b59503cdfe58ee21e894ed6bb3b1da9", "patch": "@@ -61,9 +61,11 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext)\n+    -> Result<EHAction, ()>\n+{\n     if lsda.is_null() {\n-        return EHAction::None;\n+        return Ok(EHAction::None)\n     }\n \n     let func_start = context.func_start;\n@@ -72,7 +74,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n     let start_encoding = reader.read::<u8>();\n     // base address for landing pad offsets\n     let lpad_base = if start_encoding != DW_EH_PE_omit {\n-        read_encoded_pointer(&mut reader, context, start_encoding)\n+        read_encoded_pointer(&mut reader, context, start_encoding)?\n     } else {\n         func_start\n     };\n@@ -90,9 +92,9 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n \n     if !USING_SJLJ_EXCEPTIONS {\n         while reader.ptr < action_table {\n-            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n+            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n+            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n             let cs_action = reader.read_uleb128();\n             // Callsite table is sorted by cs_start, so if we've passed the ip, we\n             // may stop searching.\n@@ -101,23 +103,23 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n             }\n             if ip < func_start + cs_start + cs_len {\n                 if cs_lpad == 0 {\n-                    return EHAction::None;\n+                    return Ok(EHAction::None)\n                 } else {\n                     let lpad = lpad_base + cs_lpad;\n-                    return interpret_cs_action(cs_action, lpad);\n+                    return Ok(interpret_cs_action(cs_action, lpad))\n                 }\n             }\n         }\n         // Ip is not present in the table.  This should not happen... but it does: issue #35011.\n         // So rather than returning EHAction::Terminate, we do this.\n-        EHAction::None\n+        Ok(EHAction::None)\n     } else {\n         // SjLj version:\n         // The \"IP\" is an index into the call-site table, with two exceptions:\n         // -1 means 'no-action', and 0 means 'terminate'.\n         match ip as isize {\n-            -1 => return EHAction::None,\n-            0 => return EHAction::Terminate,\n+            -1 => return Ok(EHAction::None),\n+            0 => return Ok(EHAction::Terminate),\n             _ => (),\n         }\n         let mut idx = ip;\n@@ -129,7 +131,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n                 // Can never have null landing pad for sjlj -- that would have\n                 // been indicated by a -1 call site index.\n                 let lpad = (cs_lpad + 1) as usize;\n-                return interpret_cs_action(cs_action, lpad);\n+                return Ok(interpret_cs_action(cs_action, lpad))\n             }\n         }\n     }\n@@ -144,21 +146,26 @@ fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n }\n \n #[inline]\n-fn round_up(unrounded: usize, align: usize) -> usize {\n-    assert!(align.is_power_of_two());\n-    (unrounded + align - 1) & !(align - 1)\n+fn round_up(unrounded: usize, align: usize) -> Result<usize, ()> {\n+    if align.is_power_of_two() {\n+        Ok((unrounded + align - 1) & !(align - 1))\n+    } else {\n+        Err(())\n+    }\n }\n \n unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n                                context: &EHContext,\n                                encoding: u8)\n-                               -> usize {\n-    assert!(encoding != DW_EH_PE_omit);\n+                               -> Result<usize, ()> {\n+    if encoding == DW_EH_PE_omit {\n+        return Err(())\n+    }\n \n     // DW_EH_PE_aligned implies it's an absolute pointer value\n     if encoding == DW_EH_PE_aligned {\n-        reader.ptr = round_up(reader.ptr as usize, mem::size_of::<usize>()) as *const u8;\n-        return reader.read::<usize>();\n+        reader.ptr = round_up(reader.ptr as usize, mem::size_of::<usize>())? as *const u8;\n+        return Ok(reader.read::<usize>())\n     }\n \n     let mut result = match encoding & 0x0F {\n@@ -171,25 +178,27 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n         DW_EH_PE_sdata2 => reader.read::<i16>() as usize,\n         DW_EH_PE_sdata4 => reader.read::<i32>() as usize,\n         DW_EH_PE_sdata8 => reader.read::<i64>() as usize,\n-        _ => panic!(),\n+        _ => return Err(()),\n     };\n \n     result += match encoding & 0x70 {\n         DW_EH_PE_absptr => 0,\n         // relative to address of the encoded value, despite the name\n         DW_EH_PE_pcrel => reader.ptr as usize,\n         DW_EH_PE_funcrel => {\n-            assert!(context.func_start != 0);\n+            if context.func_start == 0 {\n+                return Err(())\n+            }\n             context.func_start\n         }\n         DW_EH_PE_textrel => (*context.get_text_start)(),\n         DW_EH_PE_datarel => (*context.get_data_start)(),\n-        _ => panic!(),\n+        _ => return Err(()),\n     };\n \n     if encoding & DW_EH_PE_indirect != 0 {\n         result = *(result as *const usize);\n     }\n \n-    result\n+    Ok(result)\n }"}, {"sha": "aadbeb96b2d235a255c8981c445de957fb39223c", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52805d233b59503cdfe58ee21e894ed6bb3b1da9/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52805d233b59503cdfe58ee21e894ed6bb3b1da9/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=52805d233b59503cdfe58ee21e894ed6bb3b1da9", "patch": "@@ -156,7 +156,10 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     if version != 1 {\n         return uw::_URC_FATAL_PHASE1_ERROR;\n     }\n-    let eh_action = find_eh_action(context);\n+    let eh_action = match find_eh_action(context) {\n+        Ok(action) => action,\n+        Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n+    };\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n             EHAction::None |\n@@ -219,7 +222,10 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n     // bypassing DWARF compatibility functions.\n \n-    let eh_action = find_eh_action(context);\n+    let eh_action = match find_eh_action(context) {\n+        Ok(action) => action,\n+        Err(_) => return uw::_URC_FAILURE,\n+    };\n     if search_phase {\n         match eh_action {\n             EHAction::None |\n@@ -260,7 +266,9 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     }\n }\n \n-unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> EHAction {\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n+    -> Result<EHAction, ()>\n+{\n     let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n     let mut ip_before_instr: c_int = 0;\n     let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);"}, {"sha": "0a9fa7d9a80b44e637cb453dcc6df449a0c82847", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52805d233b59503cdfe58ee21e894ed6bb3b1da9/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52805d233b59503cdfe58ee21e894ed6bb3b1da9/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=52805d233b59503cdfe58ee21e894ed6bb3b1da9", "patch": "@@ -128,9 +128,10 @@ unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n         get_data_start: &|| unimplemented!(),\n     };\n     match find_eh_action(dc.HandlerData, &eh_ctx) {\n-        EHAction::None => None,\n-        EHAction::Cleanup(lpad) |\n-        EHAction::Catch(lpad) => Some(lpad),\n-        EHAction::Terminate => intrinsics::abort(),\n+        Err(_) |\n+        Ok(EHAction::None) => None,\n+        Ok(EHAction::Cleanup(lpad)) |\n+        Ok(EHAction::Catch(lpad)) => Some(lpad),\n+        Ok(EHAction::Terminate) => intrinsics::abort(),\n     }\n }"}]}