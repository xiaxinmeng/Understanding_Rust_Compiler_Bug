{"sha": "e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYTI2YWQyNzEzOTk0Y2NiYTY1ZDYyY2E2NGEyZWI1ZGI0ZWFmODE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-15T04:37:32Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-15T20:23:28Z"}, "message": "use element count in slices, not size in bytes\n\nThis allows the indexing bounds check or other comparisons against an\nelement length to avoid a multiplication by the size.", "tree": {"sha": "f7727d6f22617258d6a5e05917defc459418af0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7727d6f22617258d6a5e05917defc459418af0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "html_url": "https://github.com/rust-lang/rust/commit/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa93381e1459c5e739fab400ce8f5f83c9466804", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa93381e1459c5e739fab400ce8f5f83c9466804", "html_url": "https://github.com/rust-lang/rust/commit/aa93381e1459c5e739fab400ce8f5f83c9466804"}], "stats": {"total": 230, "additions": 154, "deletions": 76}, "files": [{"sha": "15c1f8ea339d4200babf0cbfb14e1cb661afec21", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -1059,7 +1059,7 @@ fn extract_vec_elems(bcx: @mut Block,\n         Store(bcx, slice_begin,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n         );\n-        Store(bcx, slice_len,\n+        Store(bcx, UDiv(bcx, slice_len, vt.llunit_size),\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_len])\n         );\n         elems[n] = scratch.val;"}, {"sha": "d9f16a4efe6583a8c1552acb1ebb9fe3032b846a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -54,7 +54,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::llrepr::LlvmRepr;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -2910,7 +2910,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint, uint) {\n+pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n     let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n@@ -2942,7 +2942,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint, uint) {\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     }\n-    return (map, keys.len(), llsize_of_alloc(ccx, elttype));\n+    return (map, keys.len())\n }\n \n \n@@ -3004,19 +3004,17 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n         llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n-        let (mod_map, mod_count, mod_struct_size) = create_module_map(ccx);\n+        let (mod_map, mod_count) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(2),\n              C_struct([\n                 p2i(ccx, mod_map),\n-                // byte size of the module map array, an entry consists of two integers\n-                C_int(ccx, ((mod_count * mod_struct_size) as int))\n+                C_uint(ccx, mod_count)\n              ], false),\n              C_struct([\n                 p2i(ccx, vec_elements),\n-                // byte size of the subcrates array, an entry consists of an integer\n-                C_int(ccx, (subcrates.len() * llsize_of_alloc(ccx, ccx.int_type)) as int)\n+                C_uint(ccx, subcrates.len())\n              ], false)\n         ], false));\n     }"}, {"sha": "f85b8de35dd5b6187fea7dbb17f56f93255784c5", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -83,23 +83,18 @@ pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-pub fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr])\n-    -> (ValueRef, ValueRef, Type, bool) {\n-    unsafe {\n-        let vec_ty = ty::expr_ty(cx.tcx, e);\n-        let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n-        let llunitty = type_of::type_of(cx, unit_ty);\n-        let unit_sz = machine::llsize_of(cx, llunitty);\n-        let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n-        let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e)));\n-        // If the vector contains enums, an LLVM array won't work.\n-        let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-            C_struct(vs, false)\n-        } else {\n-            C_array(llunitty, vs)\n-        };\n-        return (v, sz, llunitty, inlineable.iter().fold(true, |a, &b| a && b));\n-    }\n+fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n+    let vec_ty = ty::expr_ty(cx.tcx, e);\n+    let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+    let llunitty = type_of::type_of(cx, unit_ty);\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e)));\n+    // If the vector contains enums, an LLVM array won't work.\n+    let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+        C_struct(vs, false)\n+    } else {\n+        C_array(llunitty, vs)\n+    };\n+    (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n@@ -225,9 +220,8 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                             assert_eq!(abi::slice_elt_len, 1);\n \n                             match ty::get(ty).sty {\n-                                ty::ty_evec(_, ty::vstore_fixed(*)) => {\n-                                    let size = machine::llsize_of(cx, val_ty(llconst));\n-                                    llconst = C_struct([llptr, size], false);\n+                                ty::ty_evec(_, ty::vstore_fixed(len)) => {\n+                                    llconst = C_struct([llptr, C_uint(cx, len)], false);\n                                 }\n                                 _ => {}\n                             }\n@@ -412,14 +406,8 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                           (bv, C_uint(cx, u)),\n \n                       ty::vstore_slice(_) => {\n-                          let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n-                          let llunitty = type_of::type_of(cx, unit_ty);\n-                          let unit_sz = machine::llsize_of(cx, llunitty);\n-\n                           let e1 = const_get_elt(cx, bv, [0]);\n-                          (const_deref_ptr(cx, e1),\n-                           llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n-                                               unit_sz))\n+                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n                       _ => cx.sess.span_bug(base.span,\n                                             \"index-expr base must be fixed-size or slice\")\n@@ -538,7 +526,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n               }\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n-            let (v, _, _, inlineable) = const_vec(cx, e, *es);\n+            let (v, _, inlineable) = const_vec(cx, e, *es);\n             (v, inlineable)\n           }\n           ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n@@ -550,7 +538,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n-                let (cv, sz, llunitty, _) = const_vec(cx, e, *es);\n+                let (cv, llunitty, _) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do \"const\".with_c_str |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n@@ -559,7 +547,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);\n                 let p = const_ptrcast(cx, gv, llunitty);\n-                (C_struct([p, sz], false), false)\n+                (C_struct([p, C_uint(cx, es.len())], false), false)\n               }\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }"}, {"sha": "5ebecca0562b7d4aab973c2a43efbf34f616bda2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -1865,7 +1865,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"size_in_bytes\",\n+            name: @\"length\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,"}, {"sha": "a58151fb265fba2d686ac6986e8aa51ad6dfa6bd", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -274,8 +274,12 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                                    ty::vstore_slice(ty::re_static));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n+\n+        let vt = tvec::vec_types(bcx, datum.ty);\n+        let unscaled_len = UDiv(bcx, len, vt.llunit_size);\n+\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-        Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+        Store(bcx, unscaled_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n "}, {"sha": "0340779d0c53436f8341c3065bf59e78bcf276c8", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -237,8 +237,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n         Ignore => {}\n         SaveIn(lldest) => {\n             Store(bcx, llfixed, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-            let lllen = Mul(bcx, llcount, vt.llunit_size);\n-            Store(bcx, lllen, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+            Store(bcx, llcount, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n         }\n     }\n \n@@ -529,7 +528,8 @@ pub fn get_base_and_len(bcx: @mut Block,\n         }\n         ty::vstore_slice(_) => {\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-            let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            let len = Mul(bcx, count, vt.llunit_size);\n             (base, len)\n         }\n         ty::vstore_uniq | ty::vstore_box => {"}, {"sha": "1e76effd0d248987ce4669e077fd98cfd59d3c29", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -52,6 +52,8 @@ fn main () {\n  ```\n */\n \n+use sys::size_of;\n+use unstable::raw::Slice;\n use cast;\n use container::Container;\n use iter::{Iterator, range};\n@@ -133,10 +135,10 @@ pub trait Rng {\n     ///    println!(\"{:?}\", v);\n     /// }\n     /// ```\n-    fn fill_bytes(&mut self, mut dest: &mut [u8]) {\n-        // this relies on the lengths being transferred correctly when\n-        // transmuting between vectors like this.\n-        let as_u64: &mut &mut [u64] = unsafe { cast::transmute(&mut dest) };\n+    fn fill_bytes(&mut self, dest: &mut [u8]) {\n+        let mut slice: Slice<u64> = unsafe { cast::transmute_copy(&dest) };\n+        slice.len /= size_of::<u64>();\n+        let as_u64: &mut [u64] = unsafe { cast::transmute(slice) };\n         for dest in as_u64.mut_iter() {\n             *dest = self.next_u64();\n         }\n@@ -147,7 +149,9 @@ pub trait Rng {\n \n         // space for a u32\n         if remaining >= 4 {\n-            let as_u32: &mut &mut [u32] = unsafe { cast::transmute(&mut dest) };\n+            let mut slice: Slice<u32> = unsafe { cast::transmute_copy(&dest) };\n+            slice.len /= size_of::<u32>();\n+            let as_u32: &mut [u32] = unsafe { cast::transmute(slice) };\n             as_u32[as_u32.len() - 1] = self.next_u32();\n             remaining -= 4;\n         }"}, {"sha": "49d5bb3918b8d9b112ebaa89d850663b074de895", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -186,12 +186,7 @@ impl<'self> ReprVisitor<'self> {\n         }\n     }\n \n-    pub fn write_vec_range(&mut self,\n-                           _mtbl: uint,\n-                           ptr: *(),\n-                           len: uint,\n-                           inner: *TyDesc)\n-                           -> bool {\n+    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n         let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n         self.writer.write(['[' as u8]);\n@@ -213,13 +208,8 @@ impl<'self> ReprVisitor<'self> {\n         true\n     }\n \n-    pub fn write_unboxed_vec_repr(&mut self,\n-                                  mtbl: uint,\n-                                  v: &raw::Vec<()>,\n-                                  inner: *TyDesc)\n-                                  -> bool {\n-        self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n-                             v.fill, inner)\n+    pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n+        self.write_vec_range(ptr::to_unsafe_ptr(&v.data), v.fill, inner)\n     }\n \n     fn write_escaped_char(&mut self, ch: char, is_str: bool) {\n@@ -377,19 +367,32 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<raw::Slice<()>> |this, s| {\n             this.writer.write(['&' as u8]);\n             this.write_mut_qualifier(mtbl);\n-            this.write_vec_range(mtbl, s.data, s.len, inner);\n+            this.write_vec_range(s.data, s.len, inner);\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<raw::Slice<()>> |this, s| {\n+            this.writer.write(['&' as u8]);\n+            this.write_mut_qualifier(mtbl);\n+            let size = unsafe {\n+                if (*inner).size == 0 { 1 } else { (*inner).size }\n+            };\n+            this.write_vec_range(s.data, s.len * size, inner);\n         }\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n+                        _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         do self.get::<()> |this, b| {\n-            this.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), assumed_size, inner);\n+            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner);\n         }\n     }\n "}, {"sha": "93374d97db55d5d0ff3c31c1a56577968ae12bd8", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -974,6 +974,7 @@ pub trait ImmutableVector<'self, T> {\n \n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     #[inline]\n+    #[cfg(stage0)]\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n@@ -986,10 +987,27 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n             }\n         }\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        do self.as_imm_buf |p, _len| {\n+            unsafe {\n+                cast::transmute(Slice {\n+                    data: ptr::offset(p, start as int),\n+                    len: (end - start)\n+                })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn slice_from(&self, start: uint) -> &'self [T] {\n         self.slice(start, self.len())\n     }\n+\n     #[inline]\n     fn slice_to(&self, end: uint) -> &'self [T] {\n         self.slice(0, end)\n@@ -1130,10 +1148,18 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n         let s = self.repr();\n         f(s.data, s.len / sys::nonzero_size_of::<T>())\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n+        let s = self.repr();\n+        f(s.data, s.len)\n+    }\n }\n \n /// Extension methods for vectors contain `Eq` elements.\n@@ -1899,6 +1925,7 @@ pub trait MutableVector<'self, T> {\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     #[inline]\n+    #[cfg(stage0)]\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n@@ -1912,6 +1939,21 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        do self.as_mut_buf |p, _len| {\n+            unsafe {\n+                cast::transmute(Slice {\n+                    data: ptr::mut_offset(p, start as int) as *T,\n+                    len: (end - start)\n+                })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn mut_slice_from(self, start: uint) -> &'self mut [T] {\n         let len = self.len();\n@@ -1991,11 +2033,18 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n         let Slice{ data, len } = self.repr();\n         f(data as *mut T, len / sys::nonzero_size_of::<T>())\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n+        let Slice{ data, len } = self.repr();\n+        f(data as *mut T, len)\n+    }\n }\n \n /// Trait for &[T] where T is Cloneable\n@@ -2083,6 +2132,7 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n@@ -2097,6 +2147,22 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn buf_as_slice<T,U>(p: *T,\n+                                    len: uint,\n+                                    f: &fn(v: &[T]) -> U) -> U {\n+        f(cast::transmute(Slice {\n+            data: p,\n+            len: len\n+        }))\n+    }\n+\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n@@ -2106,6 +2172,21 @@ pub mod raw {\n         }))\n     }\n \n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n+                                        len: uint,\n+                                        f: &fn(v: &mut [T]) -> U) -> U {\n+        f(cast::transmute(Slice {\n+            data: p as *T,\n+            len: len\n+        }))\n+    }\n+\n     /**\n      * Unchecked vector indexing.\n      */"}, {"sha": "1b6dfaecfcd9cdeb6dc338874ee1bd4b7970eceb", "filename": "src/test/debug-info/vec-slices.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a26ad2713994ccba65d62ca64a2eb5db4eaf81/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec-slices.rs?ref=e1a26ad2713994ccba65d62ca64a2eb5db4eaf81", "patch": "@@ -13,33 +13,33 @@\n // debugger:rbreak zzz\n // debugger:run\n // debugger:finish\n-// debugger:print empty.size_in_bytes\n+// debugger:print empty.length\n // check:$1 = 0\n \n-// debugger:print singleton.size_in_bytes\n-// check:$2 = 8\n+// debugger:print singleton.length\n+// check:$2 = 1\n // debugger:print *((int64_t[1]*)(singleton.data_ptr))\n // check:$3 = {1}\n \n-// debugger:print multiple.size_in_bytes\n-// check:$4 = 32\n+// debugger:print multiple.length\n+// check:$4 = 4\n // debugger:print *((int64_t[4]*)(multiple.data_ptr))\n // check:$5 = {2, 3, 4, 5}\n \n-// debugger:print slice_of_slice.size_in_bytes\n-// check:$6 = 16\n+// debugger:print slice_of_slice.length\n+// check:$6 = 2\n // debugger:print *((int64_t[2]*)(slice_of_slice.data_ptr))\n // check:$7 = {3, 4}\n \n-// debugger:print padded_tuple.size_in_bytes\n-// check:$8 = 16\n+// debugger:print padded_tuple.length\n+// check:$8 = 2\n // debugger:print padded_tuple.data_ptr[0]\n // check:$9 = {6, 7}\n // debugger:print padded_tuple.data_ptr[1]\n // check:$10 = {8, 9}\n \n-// debugger:print padded_struct.size_in_bytes\n-// check:$11 = 24\n+// debugger:print padded_struct.length\n+// check:$11 = 2\n // debugger:print padded_struct.data_ptr[0]\n // check:$12 = {x = 10, y = 11, z = 12}\n // debugger:print padded_struct.data_ptr[1]"}]}