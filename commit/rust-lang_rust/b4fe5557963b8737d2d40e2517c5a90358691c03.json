{"sha": "b4fe5557963b8737d2d40e2517c5a90358691c03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZmU1NTU3OTYzYjg3MzdkMmQ0MGUyNTE3YzVhOTAzNTg2OTFjMDM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-08-01T23:08:05Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-08-02T01:44:36Z"}, "message": "Replace `exist_ty` and `ExistTy` with `opaque_ty` and `OpaqueTy`", "tree": {"sha": "c578ea8ce495456d0656abfc4872e23fbfb0e424", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c578ea8ce495456d0656abfc4872e23fbfb0e424"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4fe5557963b8737d2d40e2517c5a90358691c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4fe5557963b8737d2d40e2517c5a90358691c03", "html_url": "https://github.com/rust-lang/rust/commit/b4fe5557963b8737d2d40e2517c5a90358691c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4fe5557963b8737d2d40e2517c5a90358691c03/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2777386dc2e3c950980a469d4ac9701ccbab3a02", "url": "https://api.github.com/repos/rust-lang/rust/commits/2777386dc2e3c950980a469d4ac9701ccbab3a02", "html_url": "https://github.com/rust-lang/rust/commit/2777386dc2e3c950980a469d4ac9701ccbab3a02"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "625e746c24fec0b15a5f58bf7b37025d93ddf75f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -505,7 +505,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n-        ItemKind::OpaqueTy(ExistTy {\n+        ItemKind::OpaqueTy(OpaqueTy {\n             ref generics,\n             ref bounds,\n             .."}, {"sha": "f16a637aab3b3c484c83c5f465f6686f605bcac4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -1721,38 +1721,38 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         span: Span,\n         fn_def_id: Option<DefId>,\n-        exist_ty_node_id: NodeId,\n+        opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile, as\n         // frequently opened issues show.\n-        let exist_ty_span = self.mark_span_with_reason(\n+        let opaque_ty_span = self.mark_span_with_reason(\n             DesugaringKind::OpaqueTy,\n             span,\n             None,\n         );\n \n-        let exist_ty_def_index = self\n+        let opaque_ty_def_index = self\n             .resolver\n             .definitions()\n-            .opt_def_index(exist_ty_node_id)\n+            .opt_def_index(opaque_ty_node_id)\n             .unwrap();\n \n-        self.allocate_hir_id_counter(exist_ty_node_id);\n+        self.allocate_hir_id_counter(opaque_ty_node_id);\n \n-        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n+        let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n \n         let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-            exist_ty_node_id,\n-            exist_ty_def_index,\n+            opaque_ty_node_id,\n+            opaque_ty_def_index,\n             &hir_bounds,\n         );\n \n-        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-            let exist_ty_item = hir::ExistTy {\n+        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n+            let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n@@ -1766,51 +1766,51 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::OpaqueTyOrigin::ReturnImplTrait,\n             };\n \n-            trace!(\"exist ty from impl trait def-index: {:#?}\", exist_ty_def_index);\n-            let exist_ty_id = lctx.generate_opaque_type(\n-                exist_ty_node_id,\n-                exist_ty_item,\n+            trace!(\"exist ty from impl trait def-index: {:#?}\", opaque_ty_def_index);\n+            let opaque_ty_id = lctx.generate_opaque_type(\n+                opaque_ty_node_id,\n+                opaque_ty_item,\n                 span,\n-                exist_ty_span,\n+                opaque_ty_span,\n             );\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::Def(hir::ItemId { id: exist_ty_id }, lifetimes)\n+            hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, lifetimes)\n         })\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n     /// returns the lowered node-ID for the opaque type.\n     fn generate_opaque_type(\n         &mut self,\n-        exist_ty_node_id: NodeId,\n-        exist_ty_item: hir::ExistTy,\n+        opaque_ty_node_id: NodeId,\n+        opaque_ty_item: hir::OpaqueTy,\n         span: Span,\n-        exist_ty_span: Span,\n+        opaque_ty_span: Span,\n     ) -> hir::HirId {\n-        let exist_ty_item_kind = hir::ItemKind::OpaqueTy(exist_ty_item);\n-        let exist_ty_id = self.lower_node_id(exist_ty_node_id);\n+        let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n+        let opaque_ty_id = self.lower_node_id(opaque_ty_node_id);\n         // Generate an `type Foo = impl Trait;` declaration.\n-        trace!(\"registering opaque type with id {:#?}\", exist_ty_id);\n-        let exist_ty_item = hir::Item {\n-            hir_id: exist_ty_id,\n+        trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n+        let opaque_ty_item = hir::Item {\n+            hir_id: opaque_ty_id,\n             ident: Ident::invalid(),\n             attrs: Default::default(),\n-            node: exist_ty_item_kind,\n+            node: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n-            span: exist_ty_span,\n+            span: opaque_ty_span,\n         };\n \n         // Insert the item into the global item list. This usually happens\n         // automatically for all AST items. But this opaque type item\n         // does not actually exist in the AST.\n-        self.insert_item(exist_ty_item);\n-        exist_ty_id\n+        self.insert_item(opaque_ty_item);\n+        opaque_ty_id\n     }\n \n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n-        exist_ty_id: NodeId,\n+        opaque_ty_id: NodeId,\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n@@ -1820,7 +1820,7 @@ impl<'a> LoweringContext<'a> {\n         struct ImplTraitLifetimeCollector<'r, 'a> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n-            exist_ty_id: NodeId,\n+            opaque_ty_id: NodeId,\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n@@ -1916,7 +1916,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let def_node_id = self.context.sess.next_node_id();\n                     let hir_id =\n-                        self.context.lower_node_id_with_owner(def_node_id, self.exist_ty_id);\n+                        self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n@@ -1952,7 +1952,7 @@ impl<'a> LoweringContext<'a> {\n         let mut lifetime_collector = ImplTraitLifetimeCollector {\n             context: self,\n             parent: parent_index,\n-            exist_ty_id,\n+            opaque_ty_id,\n             collect_elided_lifetimes: true,\n             currently_bound_lifetimes: Vec::new(),\n             already_defined_lifetimes: FxHashSet::default(),\n@@ -2582,40 +2582,40 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    // Transforms `-> T` for `async fn` into `-> ExistTy { .. }`\n-    // combined with the following definition of `ExistTy`:\n+    // Transforms `-> T` for `async fn` into `-> OpaqueTy { .. }`\n+    // combined with the following definition of `OpaqueTy`:\n     //\n-    //     type ExistTy<generics_from_parent_fn> = impl Future<Output = T>;\n+    //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n     // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n-    // `exist_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n+    // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n     // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n-        exist_ty_node_id: NodeId,\n+        opaque_ty_node_id: NodeId,\n         elided_lt_replacement: LtReplacement,\n     ) -> hir::FunctionRetTy {\n         let span = output.span();\n \n-        let exist_ty_span = self.mark_span_with_reason(\n+        let opaque_ty_span = self.mark_span_with_reason(\n             DesugaringKind::Async,\n             span,\n             None,\n         );\n \n-        let exist_ty_def_index = self\n+        let opaque_ty_def_index = self\n             .resolver\n             .definitions()\n-            .opt_def_index(exist_ty_node_id)\n+            .opt_def_index(opaque_ty_node_id)\n             .unwrap();\n \n-        self.allocate_hir_id_counter(exist_ty_node_id);\n+        self.allocate_hir_id_counter(opaque_ty_node_id);\n \n-        let (exist_ty_id, lifetime_params) = self.with_hir_id_owner(exist_ty_node_id, |this| {\n+        let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             let future_bound = this.with_anonymous_lifetime_mode(\n                 AnonymousLifetimeMode::Replace(elided_lt_replacement),\n                 |this| this.lower_async_fn_output_type_to_future_bound(\n@@ -2642,11 +2642,11 @@ impl<'a> LoweringContext<'a> {\n                 lifetime_params\n                     .iter().cloned()\n                     .map(|(span, hir_name)| {\n-                        this.lifetime_to_generic_param(span, hir_name, exist_ty_def_index)\n+                        this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_index)\n                     })\n                     .collect();\n \n-            let exist_ty_item = hir::ExistTy {\n+            let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: generic_params,\n                     where_clause: hir::WhereClause {\n@@ -2660,15 +2660,15 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::OpaqueTyOrigin::AsyncFn,\n             };\n \n-            trace!(\"exist ty from async fn def index: {:#?}\", exist_ty_def_index);\n-            let exist_ty_id = this.generate_opaque_type(\n-                exist_ty_node_id,\n-                exist_ty_item,\n+            trace!(\"exist ty from async fn def index: {:#?}\", opaque_ty_def_index);\n+            let opaque_ty_id = this.generate_opaque_type(\n+                opaque_ty_node_id,\n+                opaque_ty_item,\n                 span,\n-                exist_ty_span,\n+                opaque_ty_span,\n             );\n \n-            (exist_ty_id, lifetime_params)\n+            (opaque_ty_id, lifetime_params)\n         });\n \n         let generic_args =\n@@ -2683,10 +2683,10 @@ impl<'a> LoweringContext<'a> {\n                 })\n                 .collect();\n \n-        let exist_ty_ref = hir::TyKind::Def(hir::ItemId { id: exist_ty_id }, generic_args);\n+        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n \n         hir::FunctionRetTy::Return(P(hir::Ty {\n-            node: exist_ty_ref,\n+            node: opaque_ty_ref,\n             span,\n             hir_id: self.next_id(),\n         }))\n@@ -3445,7 +3445,7 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::OpaqueTy(ref b, ref generics) => hir::ItemKind::OpaqueTy(\n-                hir::ExistTy {\n+                hir::OpaqueTy {\n                     generics: self.lower_generics(generics,\n                         ImplTraitContext::OpaqueTy(None)),\n                     bounds: self.lower_param_bounds(b,"}, {"sha": "b93961a1239160c10f00661caf06e20c7f2094e8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -827,7 +827,7 @@ impl<'hir> Map<'hir> {\n             match self.get(scope) {\n                 Node::Item(i) => {\n                     match i.node {\n-                        ItemKind::OpaqueTy(ExistTy { impl_trait_fn: None, .. }) => {}\n+                        ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {}\n                         _ => break,\n                     }\n                 }"}, {"sha": "54392a420a479d9fb2296c05fb282564d1713117", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -1922,7 +1922,7 @@ pub struct BareFnTy {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct ExistTy {\n+pub struct OpaqueTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n@@ -2422,7 +2422,7 @@ pub enum ItemKind {\n     /// A type alias, e.g., `type Foo = Bar<u8>`\n     Ty(P<Ty>, Generics),\n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`\n-    OpaqueTy(ExistTy),\n+    OpaqueTy(OpaqueTy),\n     /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n     Enum(EnumDef, Generics),\n     /// A struct definition, e.g., `struct Foo<A> {x: A}`\n@@ -2479,7 +2479,7 @@ impl ItemKind {\n         Some(match *self {\n             ItemKind::Fn(_, _, ref generics, _) |\n             ItemKind::Ty(_, ref generics) |\n-            ItemKind::OpaqueTy(ExistTy { ref generics, impl_trait_fn: None, .. }) |\n+            ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. }) |\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Struct(_, ref generics) |\n             ItemKind::Union(_, ref generics) |"}, {"sha": "e797a37fe75364138f879e2d3484cb7de7759289", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -1033,13 +1033,13 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // Anonymous `impl Trait`\n-                                hir::ItemKind::OpaqueTy(hir::ExistTy {\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: Some(parent),\n                                     origin,\n                                     ..\n                                 }) => (parent == self.parent_def_id, origin),\n                                 // Named `type Foo = impl Bar;`\n-                                hir::ItemKind::OpaqueTy(hir::ExistTy {\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: None,\n                                     origin,\n                                     .."}, {"sha": "80f85bec879d895b1d614554bf750ade77544b6b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::OpaqueTy(hir::ExistTy {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 impl_trait_fn: Some(_),\n                 ..\n             }) => {\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // it.\n             }\n             hir::ItemKind::Ty(_, ref generics)\n-            | hir::ItemKind::OpaqueTy(hir::ExistTy {\n+            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 impl_trait_fn: None,\n                 ref generics,\n                 ..\n@@ -629,15 +629,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n-                    hir::ItemKind::OpaqueTy(hir::ExistTy {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         impl_trait_fn: None,\n                         ..\n                     }) => {\n                         intravisit::walk_ty(self, ty);\n                         return;\n                     }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::OpaqueTy(hir::ExistTy {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         ref generics,\n                         ref bounds,\n                         ..\n@@ -1254,7 +1254,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::OpaqueTy(hir::ExistTy {\n+            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 ref generics,\n                 impl_trait_fn: None,\n                 .."}, {"sha": "8e170578227c0a624f36cf78b96c70b380949d69", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -3214,8 +3214,8 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         if let Node::Item(item) = tcx.hir().get(hir_id) {\n-            if let hir::ItemKind::OpaqueTy(ref exist_ty) = item.node {\n-                return exist_ty.impl_trait_fn;\n+            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.node {\n+                return opaque_ty.impl_trait_fn;\n             }\n         }\n     }"}, {"sha": "8d6f9185962be8066e28087d6e0ca265d82bf337", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -1403,7 +1403,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n         hir::ItemKind::Union(..) => {\n             check_union(tcx, it.hir_id, it.span);\n         }\n-        hir::ItemKind::OpaqueTy(hir::ExistTy{origin, ..}) => {\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy{origin, ..}) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);"}, {"sha": "15687eaa943e115da6456cb380731e1aa3925c5a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -294,7 +294,7 @@ fn type_param_predicates(\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n                 | ItemKind::Ty(_, ref generics)\n-                | ItemKind::OpaqueTy(ExistTy {\n+                | ItemKind::OpaqueTy(OpaqueTy {\n                     ref generics,\n                     impl_trait_fn: None,\n                     ..\n@@ -456,7 +456,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         }\n \n         // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::OpaqueTy(hir::ExistTy {\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n             impl_trait_fn: Some(_),\n             ..\n         }) => {}\n@@ -896,7 +896,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n         Node::Item(item) => match item.node {\n-            ItemKind::OpaqueTy(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n+            ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n         _ => None,\n@@ -920,7 +920,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                 ItemKind::Ty(_, ref generics)\n                 | ItemKind::Enum(_, ref generics)\n                 | ItemKind::Struct(_, ref generics)\n-                | ItemKind::OpaqueTy(hir::ExistTy { ref generics, .. })\n+                | ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, .. })\n                 | ItemKind::Union(_, ref generics) => {\n                     allow_defaults = true;\n                     generics\n@@ -1253,12 +1253,12 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n-                ItemKind::OpaqueTy(hir::ExistTy {\n+                ItemKind::OpaqueTy(hir::OpaqueTy {\n                     impl_trait_fn: None,\n                     ..\n                 }) => find_opaque_ty_constraints(tcx, def_id),\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(hir::ExistTy {\n+                ItemKind::OpaqueTy(hir::OpaqueTy {\n                     impl_trait_fn: Some(owner),\n                     ..\n                 }) => {\n@@ -2051,7 +2051,7 @@ fn explicit_predicates_of(\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), &empty_trait_items));\n                     generics\n                 }\n-                ItemKind::OpaqueTy(ExistTy {\n+                ItemKind::OpaqueTy(OpaqueTy {\n                     ref bounds,\n                     impl_trait_fn,\n                     ref generics,"}, {"sha": "a41b12e29b055b7cbcfb2925e006673a5d75e5be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -3664,8 +3664,8 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n             inner: OpaqueTyItem(OpaqueTy {\n-                bounds: self.exist_ty.bounds.clean(cx),\n-                generics: self.exist_ty.generics.clean(cx),\n+                bounds: self.opaque_ty.bounds.clean(cx),\n+                generics: self.opaque_ty.generics.clean(cx),\n             }, false),\n         }\n     }"}, {"sha": "098cecef95c8df8ee23dc26c33569d57ff18edd7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4fe5557963b8737d2d40e2517c5a90358691c03/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b4fe5557963b8737d2d40e2517c5a90358691c03", "patch": "@@ -472,9 +472,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.typedefs.push(t);\n             },\n-            hir::ItemKind::OpaqueTy(ref exist_ty) => {\n+            hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n                 let t = OpaqueTy {\n-                    exist_ty,\n+                    opaque_ty,\n                     name: ident.name,\n                     id: item.hir_id,\n                     attrs: &item.attrs,"}]}