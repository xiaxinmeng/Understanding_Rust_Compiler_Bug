{"sha": "4385d3dcd0df7713b3a35f31f11034f0a570adbd", "node_id": "C_kwDOAAsO6NoAKDQzODVkM2RjZDBkZjc3MTNiM2EzNWYzMWYxMTAzNGYwYTU3MGFkYmQ", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-02T12:13:21Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-02T17:39:25Z"}, "message": "Change generic parameter/argument order\n\nThis commit \"inverts\" the order of generic parameters/arguments of an\nitem and its parent. This is to fulfill chalk's expectation on the\norder of `Substitution` for generic associated types and it's one step\nforward for their support (hopefully).\n\nAlthough chalk doesn't put any constraint on the order of `Substitution`\nfor other items, it feels natural to get everything aligned rather than\nspecial casing GATs.\n\nOne complication is that `TyBuilder` now demands its users to pass in\nparent's `Substitution` upon construction unless it's obvious that the\nthe item has no parent (e.g. an ADT never has parent). All users\n*should* already know the parent of the item in question, and without\nthis, it cannot be easily reasoned about whether we're pushing the\nargument for the item or for its parent.\n\nQuick comparison of how this commit changes `Substitution`:\n\n```rust\ntrait Trait<TP, const CP: usize> {\n  type Type<TC, const CC: usize> = ();\n  fn f<TC, const CC: usize>() {}\n}\n```\n\n- before this commit: `[Self, TP, CP, TC, CC]` for each trait item\n- after this commit: `[TC, CC, Self, TP, CP]` for each trait item", "tree": {"sha": "6f47f4a8703478b78e4ed438bbcd495d3d1c6e32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f47f4a8703478b78e4ed438bbcd495d3d1c6e32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4385d3dcd0df7713b3a35f31f11034f0a570adbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmM5zM0ACgkQ4laYqTBY\nYXHBpxAAmDDlrIEVrbwBzCxEkUffkFBIFmSggTwlTEwiBmuKzE55oJv2pzP/vyUB\nIEX3rWlXykQkwR6SuE/T3RvebRO6VwQ3xBwlQQ4jjt0zNZ2sqH/ab/p4aOXHsmVi\nknTK5BUz5bwfogGMphi9tqhCpnz/JsXMFSh4v0gocd5tXmayy9e+ZM/34NUXrOs1\nvs3X5PCa10rJQbVjd1MD4pC3rUsSuFXeNGsEJQakaCmwjzdiMftdig2FP2tW15zV\ndD5Gwa15kacMT1je+xLI7vIElRV8vrsJheKemts2fO7gU9TLx83usB9STJ931W1z\nCY1/Jf6uNCvrp4hRt64sxgoA0mkHMG+cFT2eKjILlA8p6AEwRjNWyi8DRHyh2AaR\nEuf75bp9US6sKinxoREDuQHV9cyxCCqCiavKWUJaX3+VtEpN7w95xbKd1J+nISU4\nyI0yOvB+400ztx3v4NZ+uXYh36oe9FwuMzVN7oCW7bp0febS1ao4McGVZGHZOfln\nq8fgn1ojDlRTH0QRCQ1M6wiUVNtsvvs5JfZCjniKMcy532pZRek3F6mVSzyJg8Uz\neVVPPLnZrLJrsnK23rcrZBJJHUKtC/cqjbh6D/30H0Lm4wh7E1qDzIoWVLo51AmG\nnjUfmoXuEXA8X7T3H8rXRyvVrox6L4RYQfC/tyT7tHpkCXY/tRg=\n=2Ae3\n-----END PGP SIGNATURE-----", "payload": "tree 6f47f4a8703478b78e4ed438bbcd495d3d1c6e32\nparent f8f5a5ea5788a846013545d63c9b46fd70cc4f7c\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1664712801 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1664732365 +0900\n\nChange generic parameter/argument order\n\nThis commit \"inverts\" the order of generic parameters/arguments of an\nitem and its parent. This is to fulfill chalk's expectation on the\norder of `Substitution` for generic associated types and it's one step\nforward for their support (hopefully).\n\nAlthough chalk doesn't put any constraint on the order of `Substitution`\nfor other items, it feels natural to get everything aligned rather than\nspecial casing GATs.\n\nOne complication is that `TyBuilder` now demands its users to pass in\nparent's `Substitution` upon construction unless it's obvious that the\nthe item has no parent (e.g. an ADT never has parent). All users\n*should* already know the parent of the item in question, and without\nthis, it cannot be easily reasoned about whether we're pushing the\nargument for the item or for its parent.\n\nQuick comparison of how this commit changes `Substitution`:\n\n```rust\ntrait Trait<TP, const CP: usize> {\n  type Type<TC, const CC: usize> = ();\n  fn f<TC, const CC: usize>() {}\n}\n```\n\n- before this commit: `[Self, TP, CP, TC, CC]` for each trait item\n- after this commit: `[TC, CC, Self, TP, CP]` for each trait item\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4385d3dcd0df7713b3a35f31f11034f0a570adbd", "html_url": "https://github.com/rust-lang/rust/commit/4385d3dcd0df7713b3a35f31f11034f0a570adbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4385d3dcd0df7713b3a35f31f11034f0a570adbd/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8f5a5ea5788a846013545d63c9b46fd70cc4f7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f5a5ea5788a846013545d63c9b46fd70cc4f7c", "html_url": "https://github.com/rust-lang/rust/commit/f8f5a5ea5788a846013545d63c9b46fd70cc4f7c"}], "stats": {"total": 228, "additions": 141, "deletions": 87}, "files": [{"sha": "c0052258ee03700df1719928f9a2bce4ab7f972a", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 104, "deletions": 78, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4385d3dcd0df7713b3a35f31f11034f0a570adbd/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4385d3dcd0df7713b3a35f31f11034f0a570adbd/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=4385d3dcd0df7713b3a35f31f11034f0a570adbd", "patch": "@@ -34,31 +34,51 @@ pub struct TyBuilder<D> {\n     data: D,\n     vec: SmallVec<[GenericArg; 2]>,\n     param_kinds: SmallVec<[ParamKind; 2]>,\n+    parent_subst: Substitution,\n }\n \n impl<A> TyBuilder<A> {\n     fn with_data<B>(self, data: B) -> TyBuilder<B> {\n-        TyBuilder { data, param_kinds: self.param_kinds, vec: self.vec }\n+        TyBuilder {\n+            data,\n+            vec: self.vec,\n+            param_kinds: self.param_kinds,\n+            parent_subst: self.parent_subst,\n+        }\n     }\n }\n \n impl<D> TyBuilder<D> {\n-    fn new(data: D, param_kinds: SmallVec<[ParamKind; 2]>) -> TyBuilder<D> {\n-        TyBuilder { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds }\n+    fn new(\n+        data: D,\n+        param_kinds: SmallVec<[ParamKind; 2]>,\n+        parent_subst: Option<Substitution>,\n+    ) -> Self {\n+        let parent_subst = parent_subst.unwrap_or_else(|| Substitution::empty(Interner));\n+        Self { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds, parent_subst }\n+    }\n+\n+    fn new_empty(data: D) -> Self {\n+        TyBuilder::new(data, SmallVec::new(), None)\n     }\n \n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_kinds.len());\n         for (a, e) in self.vec.iter().zip(self.param_kinds.iter()) {\n             self.assert_match_kind(a, e);\n         }\n-        let subst = Substitution::from_iter(Interner, self.vec);\n+        let subst = Substitution::from_iter(\n+            Interner,\n+            self.vec.into_iter().chain(self.parent_subst.iter(Interner).cloned()),\n+        );\n         (self.data, subst)\n     }\n \n     pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n+        assert!(self.remaining() > 0);\n         let arg = arg.cast(Interner);\n         let expected_kind = &self.param_kinds[self.vec.len()];\n+\n         let arg_kind = match arg.data(Interner) {\n             chalk_ir::GenericArgData::Ty(_) => ParamKind::Type,\n             chalk_ir::GenericArgData::Lifetime(_) => panic!(\"Got lifetime in TyBuilder::push\"),\n@@ -68,7 +88,9 @@ impl<D> TyBuilder<D> {\n             }\n         };\n         assert_eq!(*expected_kind, arg_kind);\n+\n         self.vec.push(arg);\n+\n         self\n     }\n \n@@ -116,20 +138,6 @@ impl<D> TyBuilder<D> {\n         self\n     }\n \n-    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(Interner) <= self.param_kinds.len());\n-        self.extend(parent_substs.iter(Interner).cloned());\n-        self\n-    }\n-\n-    fn extend(&mut self, it: impl Iterator<Item = GenericArg> + Clone) {\n-        for x in it.clone().zip(self.param_kinds.iter().skip(self.vec.len())) {\n-            self.assert_match_kind(&x.0, &x.1);\n-        }\n-        self.vec.extend(it);\n-    }\n-\n     fn assert_match_kind(&self, a: &chalk_ir::GenericArg<Interner>, e: &ParamKind) {\n         match (a.data(Interner), e) {\n             (chalk_ir::GenericArgData::Ty(_), ParamKind::Type)\n@@ -178,53 +186,44 @@ impl TyBuilder<()> {\n         params.placeholder_subst(db)\n     }\n \n-    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n-        let def = def.into();\n-        let params = generics(db.upcast(), def);\n-        TyBuilder::new(\n-            (),\n-            params\n-                .iter()\n-                .map(|(id, data)| match data {\n-                    TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n-                    TypeOrConstParamData::ConstParamData(_) => {\n-                        ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n-                    }\n-                })\n-                .collect(),\n-        )\n+    pub fn subst_for_def(\n+        db: &dyn HirDatabase,\n+        def: impl Into<GenericDefId>,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<()> {\n+        let generics = generics(db.upcast(), def.into());\n+        // FIXME: this assertion should hold but some adjustment around\n+        // `ValueTyDefId::EnumVariantId` is needed.\n+        // assert!(generics.parent_generics().is_some() == parent_subst.is_some());\n+        let params = generics\n+            .iter_self()\n+            .map(|(id, data)| match data {\n+                TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n+                TypeOrConstParamData::ConstParamData(_) => {\n+                    ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n+                }\n+            })\n+            .collect();\n+        TyBuilder::new((), params, parent_subst)\n     }\n \n     /// Creates a `TyBuilder` to build `Substitution` for a generator defined in `parent`.\n     ///\n     /// A generator's substitution consists of:\n-    /// - generic parameters in scope on `parent`\n     /// - resume type of generator\n     /// - yield type of generator ([`Generator::Yield`](std::ops::Generator::Yield))\n     /// - return type of generator ([`Generator::Return`](std::ops::Generator::Return))\n+    /// - generic parameters in scope on `parent`\n     /// in this order.\n     ///\n     /// This method prepopulates the builder with placeholder substitution of `parent`, so you\n     /// should only push exactly 3 `GenericArg`s before building.\n     pub fn subst_for_generator(db: &dyn HirDatabase, parent: DefWithBodyId) -> TyBuilder<()> {\n-        let parent_subst = match parent.as_generic_def_id() {\n-            Some(parent) => generics(db.upcast(), parent).placeholder_subst(db),\n-            // Static initializers *may* contain generators.\n-            None => Substitution::empty(Interner),\n-        };\n-        let builder = TyBuilder::new(\n-            (),\n-            parent_subst\n-                .iter(Interner)\n-                .map(|arg| match arg.constant(Interner) {\n-                    Some(c) => ParamKind::Const(c.data(Interner).ty.clone()),\n-                    None => ParamKind::Type,\n-                })\n-                // These represent resume type, yield type, and return type of generator.\n-                .chain(std::iter::repeat(ParamKind::Type).take(3))\n-                .collect(),\n-        );\n-        builder.use_parent_substs(&parent_subst)\n+        let parent_subst =\n+            parent.as_generic_def_id().map(|p| generics(db.upcast(), p).placeholder_subst(db));\n+        // These represent resume type, yield type, and return type of generator.\n+        let params = std::iter::repeat(ParamKind::Type).take(3).collect();\n+        TyBuilder::new((), params, parent_subst)\n     }\n \n     pub fn build(self) -> Substitution {\n@@ -235,25 +234,35 @@ impl TyBuilder<()> {\n \n impl TyBuilder<hir_def::AdtId> {\n     pub fn adt(db: &dyn HirDatabase, def: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn fill_with_defaults(\n         mut self,\n         db: &dyn HirDatabase,\n         mut fallback: impl FnMut() -> Ty,\n     ) -> Self {\n+        // Note that we're building ADT, so we never have parent generic parameters.\n         let defaults = db.generic_defaults(self.data.into());\n+        let dummy_ty = TyKind::Error.intern(Interner).cast(Interner);\n         for default_ty in defaults.iter().skip(self.vec.len()) {\n             // NOTE(skip_binders): we only check if the arg type is error type.\n             if let Some(x) = default_ty.skip_binders().ty(Interner) {\n                 if x.is_unknown() {\n                     self.vec.push(fallback().cast(Interner));\n                     continue;\n                 }\n-            };\n-            // each default can depend on the previous parameters\n-            let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n+            }\n+            // Each default can only depend on the previous parameters.\n+            // FIXME: we don't handle const generics here.\n+            let subst_so_far = Substitution::from_iter(\n+                Interner,\n+                self.vec\n+                    .iter()\n+                    .cloned()\n+                    .chain(iter::repeat(dummy_ty.clone()))\n+                    .take(self.param_kinds.len()),\n+            );\n             self.vec.push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n         }\n         self\n@@ -268,7 +277,7 @@ impl TyBuilder<hir_def::AdtId> {\n pub struct Tuple(usize);\n impl TyBuilder<Tuple> {\n     pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n-        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect())\n+        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect(), None)\n     }\n \n     pub fn build(self) -> Ty {\n@@ -279,7 +288,7 @@ impl TyBuilder<Tuple> {\n \n impl TyBuilder<TraitId> {\n     pub fn trait_ref(db: &dyn HirDatabase, def: TraitId) -> TyBuilder<TraitId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn build(self) -> TraitRef {\n@@ -289,8 +298,12 @@ impl TyBuilder<TraitId> {\n }\n \n impl TyBuilder<TypeAliasId> {\n-    pub fn assoc_type_projection(db: &dyn HirDatabase, def: TypeAliasId) -> TyBuilder<TypeAliasId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+    pub fn assoc_type_projection(\n+        db: &dyn HirDatabase,\n+        def: TypeAliasId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<TypeAliasId> {\n+        TyBuilder::subst_for_def(db, def, parent_subst).with_data(def)\n     }\n \n     pub fn build(self) -> ProjectionTy {\n@@ -300,35 +313,48 @@ impl TyBuilder<TypeAliasId> {\n }\n \n impl<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>> TyBuilder<Binders<T>> {\n-    fn subst_binders(b: Binders<T>) -> Self {\n-        let param_kinds = b\n-            .binders\n-            .iter(Interner)\n-            .map(|x| match x {\n-                chalk_ir::VariableKind::Ty(_) => ParamKind::Type,\n-                chalk_ir::VariableKind::Lifetime => panic!(\"Got lifetime parameter\"),\n-                chalk_ir::VariableKind::Const(ty) => ParamKind::Const(ty.clone()),\n-            })\n-            .collect();\n-        TyBuilder::new(b, param_kinds)\n-    }\n-\n     pub fn build(self) -> T {\n         let (b, subst) = self.build_internal();\n         b.substitute(Interner, &subst)\n     }\n }\n \n impl TyBuilder<Binders<Ty>> {\n-    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.ty(def))\n+    pub fn def_ty(\n+        db: &dyn HirDatabase,\n+        def: TyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_ty = db.ty(def);\n+        let id: GenericDefId = match def {\n+            TyDefId::BuiltinType(_) => {\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_ty);\n+            }\n+            TyDefId::AdtId(id) => id.into(),\n+            TyDefId::TypeAliasId(id) => id.into(),\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_ty)\n     }\n \n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.impl_self_ty(def))\n+        TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n \n-    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.value_ty(def))\n+    pub fn value_ty(\n+        db: &dyn HirDatabase,\n+        def: ValueTyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_value_ty = db.value_ty(def);\n+        let id = match def.to_generic_def_id() {\n+            Some(id) => id,\n+            None => {\n+                // static items\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_value_ty);\n+            }\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n     }\n }"}, {"sha": "82128ae6586d161a173b3a9fc512b8e21c9309b0", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4385d3dcd0df7713b3a35f31f11034f0a570adbd/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4385d3dcd0df7713b3a35f31f11034f0a570adbd/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=4385d3dcd0df7713b3a35f31f11034f0a570adbd", "patch": "@@ -1641,6 +1641,19 @@ pub enum ValueTyDefId {\n }\n impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);\n \n+impl ValueTyDefId {\n+    pub(crate) fn to_generic_def_id(self) -> Option<GenericDefId> {\n+        match self {\n+            Self::FunctionId(id) => Some(id.into()),\n+            Self::StructId(id) => Some(id.into()),\n+            Self::UnionId(id) => Some(id.into()),\n+            Self::EnumVariantId(var) => Some(var.parent.into()),\n+            Self::ConstId(id) => Some(id.into()),\n+            Self::StaticId(_) => None,\n+        }\n+    }\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values"}, {"sha": "adcf142bc35f00b1ffa27bb416af56894584a90c", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4385d3dcd0df7713b3a35f31f11034f0a570adbd/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4385d3dcd0df7713b3a35f31f11034f0a570adbd/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=4385d3dcd0df7713b3a35f31f11034f0a570adbd", "patch": "@@ -220,36 +220,49 @@ impl Generics {\n         })\n     }\n \n-    /// Iterator over types and const params of parent, then self.\n+    /// Iterator over types and const params of self, then parent.\n     pub(crate) fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         let to_toc_id = |it: &'a Generics| {\n             move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n         };\n-        self.parent_generics()\n-            .into_iter()\n-            .flat_map(move |it| it.params.iter().map(to_toc_id(it)))\n-            .chain(self.params.iter().map(to_toc_id(self)))\n+        self.params.iter().map(to_toc_id(self)).chain(self.iter_parent())\n+    }\n+\n+    /// Iterate over types and const params without parent params.\n+    pub(crate) fn iter_self<'a>(\n+        &'a self,\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+        let to_toc_id = |it: &'a Generics| {\n+            move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n+        };\n+        self.params.iter().map(to_toc_id(self))\n     }\n \n     /// Iterator over types and const params of parent.\n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics().into_iter().flat_map(|it| {\n             let to_toc_id =\n                 move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p);\n             it.params.iter().map(to_toc_id)\n         })\n     }\n \n+    /// Returns total number of generic parameters in scope, including those from parent.\n     pub(crate) fn len(&self) -> usize {\n         let parent = self.parent_generics().map_or(0, Generics::len);\n         let child = self.params.type_or_consts.len();\n         parent + child\n     }\n \n+    /// Returns numbers of generic parameters excluding those from parent.\n+    pub(crate) fn len_self(&self) -> usize {\n+        self.params.type_or_consts.len()\n+    }\n+\n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n         let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n@@ -274,10 +287,12 @@ impl Generics {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) =\n                 self.params.iter().enumerate().find(|(_, (idx, _))| *idx == param.local_id)?;\n-            let parent_len = self.parent_generics().map_or(0, Generics::len);\n-            Some((parent_len + idx, data))\n+            Some((idx, data))\n         } else {\n-            self.parent_generics().and_then(|g| g.find_param(param))\n+            self.parent_generics()\n+                .and_then(|g| g.find_param(param))\n+                // Remember that parent parameters come after parameters for self.\n+                .map(|(idx, data)| (self.len_self() + idx, data))\n         }\n     }\n "}]}