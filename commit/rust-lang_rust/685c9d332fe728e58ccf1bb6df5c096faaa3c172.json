{"sha": "685c9d332fe728e58ccf1bb6df5c096faaa3c172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NWM5ZDMzMmZlNzI4ZTU4Y2NmMWJiNmRmNWMwOTZmYWFhM2MxNzI=", "commit": {"author": {"name": "Tarin Mahmood", "email": "mahmood.tarin+home@gmail.com", "date": "2017-10-27T15:45:35Z"}, "committer": {"name": "Tarin Mahmood", "email": "mahmood.tarin+home@gmail.com", "date": "2017-10-28T10:26:33Z"}, "message": "Unstable options added", "tree": {"sha": "84ac2a383cb22285f9032fc8bad0ad39df253b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84ac2a383cb22285f9032fc8bad0ad39df253b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/685c9d332fe728e58ccf1bb6df5c096faaa3c172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/685c9d332fe728e58ccf1bb6df5c096faaa3c172", "html_url": "https://github.com/rust-lang/rust/commit/685c9d332fe728e58ccf1bb6df5c096faaa3c172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/685c9d332fe728e58ccf1bb6df5c096faaa3c172/comments", "author": null, "committer": null, "parents": [{"sha": "ee490aea0074afd4d2bd119984d153ef54682058", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee490aea0074afd4d2bd119984d153ef54682058", "html_url": "https://github.com/rust-lang/rust/commit/ee490aea0074afd4d2bd119984d153ef54682058"}], "stats": {"total": 270, "additions": 176, "deletions": 94}, "files": [{"sha": "c7461069db42e7c65b740d50900899350b0b6a2e", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/685c9d332fe728e58ccf1bb6df5c096faaa3c172/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685c9d332fe728e58ccf1bb6df5c096faaa3c172/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=685c9d332fe728e58ccf1bb6df5c096faaa3c172", "patch": "@@ -60,13 +60,25 @@ struct CliOptions {\n     verbose: bool,\n     write_mode: Option<WriteMode>,\n     file_lines: FileLines, // Default is all lines in all files.\n+    unstable_features: bool,\n }\n \n impl CliOptions {\n     fn from_matches(matches: &Matches) -> FmtResult<CliOptions> {\n         let mut options = CliOptions::default();\n         options.skip_children = matches.opt_present(\"skip-children\");\n         options.verbose = matches.opt_present(\"verbose\");\n+        let unstable_features = matches.opt_present(\"unstable_features\");\n+        let rust_nightly = option_env!(\"CFG_RELEASE_CHANNEL\")\n+            .map(|c| c == \"nightly\")\n+            .unwrap_or(false);\n+        if unstable_features && !rust_nightly {\n+            return Err(FmtError::from(format!(\n+                \"Unstable features are only available on Nightly channel\"\n+            )));\n+        } else {\n+            options.unstable_features = unstable_features;\n+        }\n \n         if let Some(ref write_mode) = matches.opt_str(\"write-mode\") {\n             if let Ok(write_mode) = WriteMode::from_str(write_mode) {\n@@ -89,6 +101,7 @@ impl CliOptions {\n         config.set().skip_children(self.skip_children);\n         config.set().verbose(self.verbose);\n         config.set().file_lines(self.file_lines);\n+        config.set().unstable_features(self.unstable_features);\n         if let Some(write_mode) = self.write_mode {\n             config.set().write_mode(write_mode);\n         }\n@@ -120,6 +133,12 @@ fn make_opts() -> Options {\n     );\n     opts.optflag(\"\", \"skip-children\", \"don't reformat child modules\");\n \n+    opts.optflag(\n+        \"\",\n+        \"unstable-features\",\n+        \"Enables unstable features. Only available on nightly channel\",\n+    );\n+\n     opts.optflag(\n         \"\",\n         \"config-help\","}, {"sha": "18969908c86391321e7b35ae37c4386c7704fb08", "filename": "src/config.rs", "status": "modified", "additions": 157, "deletions": 94, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/685c9d332fe728e58ccf1bb6df5c096faaa3c172/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685c9d332fe728e58ccf1bb6df5c096faaa3c172/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=685c9d332fe728e58ccf1bb6df5c096faaa3c172", "patch": "@@ -20,6 +20,15 @@ use file_lines::FileLines;\n use lists::{ListTactic, SeparatorPlace, SeparatorTactic};\n use Summary;\n \n+\n+macro_rules! is_nightly_channel {\n+    () => {\n+    env::var(\"CFG_RELEASE_CHANNEL\")\n+        .map(|c| c == \"nightly\")\n+        .unwrap_or(false)\n+    }\n+}\n+\n macro_rules! configuration_option_enum{\n     ($e:ident: $( $x:ident ),+ $(,)*) => {\n         #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n@@ -215,13 +224,13 @@ impl ConfigHelpItem {\n }\n \n macro_rules! create_config {\n-    ($($i:ident: $ty:ty, $def:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n+    ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n         #[derive(Clone)]\n         pub struct Config {\n             // For each config item, we store a bool indicating whether it has\n             // been accessed and the value, and a bool whether the option was\n             // manually initialised, or taken from the default,\n-            $($i: (Cell<bool>, bool, $ty)),+\n+            $($i: (Cell<bool>, bool, $ty, bool)),+\n         }\n \n         // Just like the Config struct but with each property wrapped\n@@ -309,8 +318,18 @@ macro_rules! create_config {\n             fn fill_from_parsed_config(mut self, parsed: PartialConfig) -> Config {\n             $(\n                 if let Some(val) = parsed.$i {\n-                    self.$i.1 = true;\n-                    self.$i.2 = val;\n+                    if !self.$i.3 {\n+                        self.$i.1 = true;\n+                        self.$i.2 = val;\n+                    } else {\n+                        if is_nightly_channel!() {\n+                            self.$i.1 = true;\n+                            self.$i.2 = val;\n+                        } else {\n+                            println!(\"Warning: can't set some features as unstable \\\n+                                    features are only available in nightly channel.\");\n+                        }\n+                    }\n                 }\n             )+\n                 self\n@@ -478,7 +497,7 @@ macro_rules! create_config {\n             fn default() -> Config {\n                 Config {\n                     $(\n-                        $i: (Cell::new(false), false, $def),\n+                        $i: (Cell::new(false), false, $def, $stb),\n                     )+\n                 }\n             }\n@@ -511,138 +530,149 @@ pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n \n \n create_config! {\n-    verbose: bool, false, \"Use verbose output\";\n-    disable_all_formatting: bool, false, \"Don't reformat anything\";\n-    skip_children: bool, false, \"Don't reformat out of line modules\";\n-    file_lines: FileLines, FileLines::all(),\n+    unstable_features: bool, false, true,\n+            \"Enables unstable features. Only available on nightly channel\";\n+    verbose: bool, false, false, \"Use verbose output\";\n+    disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n+    skip_children: bool, false, false, \"Don't reformat out of line modules\";\n+    file_lines: FileLines, FileLines::all(), false,\n         \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n          via the --file-lines option\";\n-    max_width: usize, 100, \"Maximum width of each line\";\n-    error_on_line_overflow: bool, true, \"Error if unable to get all lines within max_width\";\n-    error_on_line_overflow_comments: bool, true, \"Error if unable to get comments within max_width\";\n-    tab_spaces: usize, 4, \"Number of spaces per tab\";\n-    fn_call_width: usize, 60,\n+    max_width: usize, 100, false, \"Maximum width of each line\";\n+    error_on_line_overflow: bool, true, false, \"Error if unable to get all lines within max_width\";\n+    error_on_line_overflow_comments: bool, true, false,\n+        \"Error if unable to get comments within max_width\";\n+    tab_spaces: usize, 4, false, \"Number of spaces per tab\";\n+    fn_call_width: usize, 60, false,\n         \"Maximum width of the args of a function call before falling back to vertical formatting\";\n-    struct_lit_width: usize, 18,\n+    struct_lit_width: usize, 18, false,\n         \"Maximum width in the body of a struct lit before falling back to vertical formatting\";\n-    struct_variant_width: usize, 35,\n+    struct_variant_width: usize, 35, false,\n         \"Maximum width in the body of a struct variant before falling back to vertical formatting\";\n-    force_explicit_abi: bool, true, \"Always print the abi for extern items\";\n-    newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n-    fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";\n-    item_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for structs and enums\";\n-    control_style: Style, Style::Rfc, \"Indent style for control flow statements\";\n-    control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine,\n+    force_explicit_abi: bool, true, false, \"Always print the abi for extern items\";\n+    newline_style: NewlineStyle, NewlineStyle::Unix, false, \"Unix or Windows line endings\";\n+    fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, false, \"Brace style for functions\";\n+    item_brace_style: BraceStyle, BraceStyle::SameLineWhere, false,\n+        \"Brace style for structs and enums\";\n+    control_style: Style, Style::Rfc, false, \"Indent style for control flow statements\";\n+    control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine, false,\n         \"Brace style for control flow constructs\";\n-    impl_empty_single_line: bool, true, \"Put empty-body implementations on a single line\";\n-    trailing_comma: SeparatorTactic, SeparatorTactic::Vertical,\n+    impl_empty_single_line: bool, true, false, \"Put empty-body implementations on a single line\";\n+    trailing_comma: SeparatorTactic, SeparatorTactic::Vertical, false,\n         \"How to handle trailing commas for lists\";\n-    trailing_semicolon: bool, true, \"Add trailing semicolon after break, continue and return\";\n-    fn_empty_single_line: bool, true, \"Put empty-body functions on a single line\";\n-    fn_single_line: bool, false, \"Put single-expression functions on a single line\";\n-    fn_return_indent: ReturnIndent, ReturnIndent::WithArgs,\n+    trailing_semicolon: bool, true, false,\n+        \"Add trailing semicolon after break, continue and return\";\n+    fn_empty_single_line: bool, true, false, \"Put empty-body functions on a single line\";\n+    fn_single_line: bool, false, false, \"Put single-expression functions on a single line\";\n+    fn_return_indent: ReturnIndent, ReturnIndent::WithArgs, false,\n         \"Location of return type in function declaration\";\n-    fn_args_paren_newline: bool, false, \"If function argument parenthesis goes on a newline\";\n-    fn_args_density: Density, Density::Tall, \"Argument density in functions\";\n-    fn_args_layout: IndentStyle, IndentStyle::Block,\n+    fn_args_paren_newline: bool, false, false, \"If function argument parenthesis goes on a newline\";\n+    fn_args_density: Density, Density::Tall, false, \"Argument density in functions\";\n+    fn_args_layout: IndentStyle, IndentStyle::Block, false,\n         \"Layout of function arguments and tuple structs\";\n-    array_layout: IndentStyle, IndentStyle::Block, \"Indent on arrays\";\n-    array_width: usize, 60,\n+    array_layout: IndentStyle, IndentStyle::Block, false, \"Indent on arrays\";\n+    array_width: usize, 60, false,\n         \"Maximum width of an array literal before falling back to vertical formatting\";\n-    array_horizontal_layout_threshold: usize, 0,\n+    array_horizontal_layout_threshold: usize, 0, false,\n         \"How many elements array must have before rustfmt uses horizontal layout.\";\n-    type_punctuation_density: TypeDensity, TypeDensity::Wide,\n+    type_punctuation_density: TypeDensity, TypeDensity::Wide, false,\n         \"Determines if '+' or '=' are wrapped in spaces in the punctuation of types\";\n-    where_style: Style, Style::Rfc, \"Overall strategy for where clauses\";\n+    where_style: Style, Style::Rfc, false, \"Overall strategy for where clauses\";\n     // TODO:\n     // 1. Should we at least try to put the where clause on the same line as the rest of the\n     // function decl?\n     // 2. Currently options `Tall` and `Vertical` produce the same output.\n-    where_density: Density, Density::Vertical, \"Density of a where clause\";\n-    where_layout: ListTactic, ListTactic::Vertical, \"Element layout inside a where clause\";\n-    where_pred_indent: IndentStyle, IndentStyle::Visual,\n+    where_density: Density, Density::Vertical, false, \"Density of a where clause\";\n+    where_layout: ListTactic, ListTactic::Vertical, false, \"Element layout inside a where clause\";\n+    where_pred_indent: IndentStyle, IndentStyle::Visual, false,\n         \"Indentation style of a where predicate\";\n-    generics_indent: IndentStyle, IndentStyle::Block, \"Indentation of generics\";\n-    struct_lit_style: IndentStyle, IndentStyle::Block, \"Style of struct definition\";\n-    struct_lit_multiline_style: MultilineStyle, MultilineStyle::PreferSingle,\n+    generics_indent: IndentStyle, IndentStyle::Block, false, \"Indentation of generics\";\n+    struct_lit_style: IndentStyle, IndentStyle::Block, false, \"Style of struct definition\";\n+    struct_lit_multiline_style: MultilineStyle, MultilineStyle::PreferSingle, false,\n         \"Multiline style on literal structs\";\n-    fn_call_style: IndentStyle, IndentStyle::Block, \"Indentation for function calls, etc.\";\n-    report_todo: ReportTactic, ReportTactic::Never,\n+    fn_call_style: IndentStyle, IndentStyle::Block, false, \"Indentation for function calls, etc.\";\n+    report_todo: ReportTactic, ReportTactic::Never, false,\n         \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n-    report_fixme: ReportTactic, ReportTactic::Never,\n+    report_fixme: ReportTactic, ReportTactic::Never, false,\n         \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n-    chain_indent: IndentStyle, IndentStyle::Block, \"Indentation of chain\";\n-    chain_one_line_max: usize, 60, \"Maximum length of a chain to fit on a single line\";\n-    chain_split_single_child: bool, false, \"Split a chain with a single child if its length \\\n+    chain_indent: IndentStyle, IndentStyle::Block, false, \"Indentation of chain\";\n+    chain_one_line_max: usize, 60, false, \"Maximum length of a chain to fit on a single line\";\n+    chain_split_single_child: bool, false, false, \"Split a chain with a single child if its length \\\n                                             exceeds `chain_one_line_max`\";\n-    imports_indent: IndentStyle, IndentStyle::Visual, \"Indent of imports\";\n-    imports_layout: ListTactic, ListTactic::Mixed, \"Item layout inside a import block\";\n-    reorder_extern_crates: bool, true, \"Reorder extern crate statements alphabetically\";\n-    reorder_extern_crates_in_group: bool, true, \"Reorder extern crate statements in group\";\n-    reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n-    reorder_imports_in_group: bool, false, \"Reorder import statements in group\";\n-    reorder_imported_names: bool, true,\n+    imports_indent: IndentStyle, IndentStyle::Visual, false, \"Indent of imports\";\n+    imports_layout: ListTactic, ListTactic::Mixed, false, \"Item layout inside a import block\";\n+    reorder_extern_crates: bool, true, false, \"Reorder extern crate statements alphabetically\";\n+    reorder_extern_crates_in_group: bool, true, false, \"Reorder extern crate statements in group\";\n+    reorder_imports: bool, false, false, \"Reorder import statements alphabetically\";\n+    reorder_imports_in_group: bool, false, false, \"Reorder import statements in group\";\n+    reorder_imported_names: bool, true, false,\n         \"Reorder lists of names in import statements alphabetically\";\n-    single_line_if_else_max_width: usize, 50, \"Maximum line length for single line if-else \\\n+    single_line_if_else_max_width: usize, 50, false, \"Maximum line length for single line if-else \\\n                                                 expressions. A value of zero means always break \\\n                                                 if-else expressions.\";\n-    format_strings: bool, false, \"Format string literals where necessary\";\n-    force_format_strings: bool, false, \"Always format string literals\";\n-    take_source_hints: bool, false, \"Retain some formatting characteristics from the source code\";\n-    hard_tabs: bool, false, \"Use tab characters for indentation, spaces for alignment\";\n-    wrap_comments: bool, false, \"Break comments to fit on the line\";\n-    comment_width: usize, 80, \"Maximum length of comments. No effect unless wrap_comments = true\";\n-    normalize_comments: bool, false, \"Convert /* */ comments to // comments where possible\";\n-    wrap_match_arms: bool, true, \"Wrap the body of arms in blocks when it does not fit on \\\n+    format_strings: bool, false, false, \"Format string literals where necessary\";\n+    force_format_strings: bool, false, false, \"Always format string literals\";\n+    take_source_hints: bool, false, false,\n+        \"Retain some formatting characteristics from the source code\";\n+    hard_tabs: bool, false, false, \"Use tab characters for indentation, spaces for alignment\";\n+    wrap_comments: bool, false, false, \"Break comments to fit on the line\";\n+    comment_width: usize, 80, false,\n+        \"Maximum length of comments. No effect unless wrap_comments = true\";\n+    normalize_comments: bool, false, false, \"Convert /* */ comments to // comments where possible\";\n+    wrap_match_arms: bool, true, false, \"Wrap the body of arms in blocks when it does not fit on \\\n                                   the same line with the pattern of arms\";\n-    match_block_trailing_comma: bool, false,\n+    match_block_trailing_comma: bool, false, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n-    match_arm_forces_newline: bool, false,\n+    match_arm_forces_newline: bool, false, false,\n         \"Force match arm bodies to be in a new lines\";\n-    indent_match_arms: bool, true, \"Indent match arms instead of keeping them at the same \\\n+    indent_match_arms: bool, true, false, \"Indent match arms instead of keeping them at the same \\\n                                     indentation level as the match keyword\";\n-    match_pattern_separator_break_point: SeparatorPlace, SeparatorPlace::Back,\n+    match_pattern_separator_break_point: SeparatorPlace, SeparatorPlace::Back, false,\n         \"Put a match sub-patterns' separator in front or back.\";\n-    closure_block_indent_threshold: isize, 7, \"How many lines a closure must have before it is \\\n-                                               block indented. -1 means never use block indent.\";\n-    space_before_type_annotation: bool, false,\n+    closure_block_indent_threshold: isize, 7, false,\n+        \"How many lines a closure must have before it is block indented. \\\n+        -1 means never use block indent.\";\n+    space_before_type_annotation: bool, false, false,\n         \"Leave a space before the colon in a type annotation\";\n-    space_after_type_annotation_colon: bool, true,\n+    space_after_type_annotation_colon: bool, true, false,\n         \"Leave a space after the colon in a type annotation\";\n-    space_before_struct_lit_field_colon: bool, false,\n+    space_before_struct_lit_field_colon: bool, false, false,\n         \"Leave a space before the colon in a struct literal field\";\n-    space_after_struct_lit_field_colon: bool, true,\n+    space_after_struct_lit_field_colon: bool, true, false,\n         \"Leave a space after the colon in a struct literal field\";\n-    space_before_bound: bool, false, \"Leave a space before the colon in a trait or lifetime bound\";\n-    space_after_bound_colon: bool, true,\n+    space_before_bound: bool, false, false,\n+        \"Leave a space before the colon in a trait or lifetime bound\";\n+    space_after_bound_colon: bool, true, false,\n         \"Leave a space after the colon in a trait or lifetime bound\";\n-    spaces_around_ranges: bool, false, \"Put spaces around the  .. and ... range operators\";\n-    spaces_within_angle_brackets: bool, false, \"Put spaces within non-empty generic arguments\";\n-    spaces_within_square_brackets: bool, false, \"Put spaces within non-empty square brackets\";\n-    spaces_within_parens: bool, false, \"Put spaces within non-empty parentheses\";\n-    use_try_shorthand: bool, false, \"Replace uses of the try! macro by the ? shorthand\";\n-    write_mode: WriteMode, WriteMode::Overwrite,\n+    spaces_around_ranges: bool, false, false, \"Put spaces around the  .. and ... range operators\";\n+    spaces_within_angle_brackets: bool, false, false,\n+        \"Put spaces within non-empty generic arguments\";\n+    spaces_within_square_brackets: bool, false, false,\n+        \"Put spaces within non-empty square brackets\";\n+    spaces_within_parens: bool, false, false, \"Put spaces within non-empty parentheses\";\n+    use_try_shorthand: bool, false, false, \"Replace uses of the try! macro by the ? shorthand\";\n+    write_mode: WriteMode, WriteMode::Overwrite, false,\n         \"What Write Mode to use when none is supplied: \\\n          Replace, Overwrite, Display, Plain, Diff, Coverage\";\n-    condense_wildcard_suffixes: bool, false, \"Replace strings of _ wildcards by a single .. in \\\n-                                              tuple patterns\";\n-    combine_control_expr: bool, true, \"Combine control expressions with function calls.\";\n-    struct_field_align_threshold: usize, 0, \"Align struct fields if their diffs fits within \\\n+    condense_wildcard_suffixes: bool, false, false, \"Replace strings of _ wildcards by a single .. \\\n+                                              in tuple patterns\";\n+    combine_control_expr: bool, true, false, \"Combine control expressions with function calls.\";\n+    struct_field_align_threshold: usize, 0, false, \"Align struct fields if their diffs fits within \\\n                                              threshold.\";\n-    remove_blank_lines_at_start_or_end_of_block: bool, true,\n+    remove_blank_lines_at_start_or_end_of_block: bool, true, false,\n         \"Remove blank lines at start or end of a block\";\n-    attributes_on_same_line_as_field: bool, true,\n+    attributes_on_same_line_as_field: bool, true, false,\n         \"Try to put attributes on the same line as fields.\";\n-    attributes_on_same_line_as_variant: bool, true,\n+    attributes_on_same_line_as_variant: bool, true, false,\n         \"Try to put attributes on the same line as variants in enum declarations.\";\n-    multiline_closure_forces_block: bool, false,\n+    multiline_closure_forces_block: bool, false, false,\n         \"Force multiline closure bodies to be wrapped in a block\";\n-    multiline_match_arm_forces_block: bool, false,\n+    multiline_match_arm_forces_block: bool, false, false,\n         \"Force multiline match arm bodies to be wrapped in a block\";\n-    merge_derives: bool, true, \"Merge multiple `#[derive(...)]` into a single one\";\n-    binop_separator: SeparatorPlace, SeparatorPlace::Front,\n+    merge_derives: bool, true, false, \"Merge multiple `#[derive(...)]` into a single one\";\n+    binop_separator: SeparatorPlace, SeparatorPlace::Front, false,\n         \"Where to put a binary operator when a binary expression goes multiline.\";\n-    required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(),\n+    required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n         \"Require a specific version of rustfmt.\"\n }\n \n@@ -681,4 +711,37 @@ mod test {\n         assert_eq!(config.was_set().hard_tabs(), true);\n         assert_eq!(config.was_set().verbose(), false);\n     }\n+\n+    #[test]\n+    fn test_as_not_nightly_channel() {\n+        let mut config = Config::default();\n+        assert_eq!(config.was_set().unstable_features(), false);\n+        config.set().unstable_features(true);\n+        assert_eq!(config.was_set().unstable_features(), false);\n+    }\n+\n+    #[test]\n+    fn test_as_nightly_channel() {\n+        let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+        ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+        let mut config = Config::default();\n+        config.set().unstable_features(true);\n+        assert_eq!(config.was_set().unstable_features(), false);\n+        config.set().unstable_features(true);\n+        assert_eq!(config.unstable_features(), true);\n+        ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    }\n+\n+    #[test]\n+    fn test_unstable_from_toml() {\n+        let mut config = Config::from_toml(\"unstable_features = true\").unwrap();\n+        assert_eq!(config.was_set().unstable_features(), false);\n+        let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+        ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+        config = Config::from_toml(\"unstable_features = true\").unwrap();\n+        assert_eq!(config.was_set().unstable_features(), true);\n+        assert_eq!(config.unstable_features(), true);\n+        ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    }\n+\n }"}]}