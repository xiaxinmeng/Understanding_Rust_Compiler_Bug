{"sha": "4224fc7aad3cfbd7093e55812e5a566d7aad3325", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMjRmYzdhYWQzY2ZiZDcwOTNlNTU4MTJlNWE1NjZkN2FhZDMzMjU=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-06-12T21:55:32Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-06-12T21:55:32Z"}, "message": "added functionality to tell schedulers to refuse to run tasks that are not pinned to them", "tree": {"sha": "9c04690212581ccaac9359e7eda0377e4dc6e963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c04690212581ccaac9359e7eda0377e4dc6e963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4224fc7aad3cfbd7093e55812e5a566d7aad3325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4224fc7aad3cfbd7093e55812e5a566d7aad3325", "html_url": "https://github.com/rust-lang/rust/commit/4224fc7aad3cfbd7093e55812e5a566d7aad3325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4224fc7aad3cfbd7093e55812e5a566d7aad3325/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84280819585fb65bf18903aef9364579f3552522", "url": "https://api.github.com/repos/rust-lang/rust/commits/84280819585fb65bf18903aef9364579f3552522", "html_url": "https://github.com/rust-lang/rust/commit/84280819585fb65bf18903aef9364579f3552522"}], "stats": {"total": 78, "additions": 60, "deletions": 18}, "files": [{"sha": "4bc61d638248d388f0c59193152be2e7cd021ae8", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4224fc7aad3cfbd7093e55812e5a566d7aad3325/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4224fc7aad3cfbd7093e55812e5a566d7aad3325/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=4224fc7aad3cfbd7093e55812e5a566d7aad3325", "patch": "@@ -70,7 +70,9 @@ pub struct Scheduler {\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>,\n-    metrics: SchedMetrics\n+    metrics: SchedMetrics,\n+    /// Should this scheduler run any task, or only pinned tasks?\n+    run_anything: bool\n }\n \n pub struct SchedHandle {\n@@ -136,6 +138,16 @@ pub impl Scheduler {\n            sleeper_list: SleeperList)\n         -> Scheduler {\n \n+        Scheduler::new_special(event_loop, work_queue, sleeper_list, true)\n+\n+    }\n+\n+    fn new_special(event_loop: ~EventLoopObject,\n+           work_queue: WorkQueue<~Coroutine>,\n+           sleeper_list: SleeperList,\n+           run_anything: bool)\n+        -> Scheduler {\n+\n         // Lazily initialize the runtime TLS key\n         local_ptr::init_tls_key();\n \n@@ -150,7 +162,8 @@ pub impl Scheduler {\n             saved_context: Context::empty(),\n             current_task: None,\n             cleanup_job: None,\n-            metrics: SchedMetrics::new()\n+            metrics: SchedMetrics::new(),\n+            run_anything: run_anything\n         }\n     }\n \n@@ -429,19 +442,28 @@ pub impl Scheduler {\n         assert!(!self.in_task_context());\n \n         rtdebug!(\"looking in work queue for task to schedule\");\n-\n         let mut this = self;\n-        match this.work_queue.pop() {\n-            Some(task) => {\n-                rtdebug!(\"resuming task from work queue\");\n-                this.resume_task_immediately(task);\n-                return true;\n-            }\n-            None => {\n-                rtdebug!(\"no tasks in queue\");\n-                Local::put(this);\n-                return false;\n+\n+        if this.run_anything {\n+            match this.work_queue.pop() {\n+                Some(task) => {\n+                    rtdebug!(\"resuming task from work queue\");\n+                    this.resume_task_immediately(task);\n+                    return true;\n+                }\n+                None => {\n+                    rtdebug!(\"no tasks in queue\");\n+                    Local::put(this);\n+                    return false;\n+                }\n             }\n+        } else {\n+            // In this branch we have a scheduler that is not allowed\n+            // to run unpinned tasks. As such it will only get tasks\n+            // to run from the message queue.\n+            rtdebug!(\"skipping resume_task_from_queue\");\n+            Local::put(this);\n+            return false;\n         }\n     }\n "}, {"sha": "ecef505ce579df3be8da45918e4c9fc571b35653", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4224fc7aad3cfbd7093e55812e5a566d7aad3325/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4224fc7aad3cfbd7093e55812e5a566d7aad3325/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=4224fc7aad3cfbd7093e55812e5a566d7aad3325", "patch": "@@ -157,23 +157,43 @@ pub fn run_in_mt_newsched_task_random_homed() {\n         let mut handles = ~[];\n         let mut scheds = ~[];\n \n-        for uint::range(0, nthreads) |_| {\n+        // create a few special schedulers, those with even indicies\n+        // will be pinned-only\n+        for uint::range(0, nthreads) |i| {\n+            let special = (i % 2) == 0;\n             let loop_ = ~UvEventLoop::new();\n-            let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n+            let mut sched = ~Scheduler::new_special(loop_, work_queue.clone(), sleepers.clone(), special);\n             let handle = sched.make_handle();\n             handles.push(handle);\n             scheds.push(sched);\n-        }\n+        }           \n \n         // Schedule a pile o tasks\n-        let n = 120*stress_factor();        \n+        let n = 5*stress_factor();        \n         for uint::range(0,n) |_i| {\n                 rtdebug!(\"creating task: %u\", _i);\n                 let hf: ~fn() = || { assert!(true) };\n                 spawntask_homed(&mut scheds, hf);            \n             }\n \n-        let f: ~fn() = || { assert!(true); };\n+        // Now we want another pile o tasks that do not ever run on a\n+        // special scheduler, because they are normal tasks. Because\n+        // we can we put these in the \"main\" task.\n+\n+        let n = 5*stress_factor();\n+\n+        let f: ~fn() = || {        \n+            for uint::range(0,n) |_| {\n+                let f: ~fn()  = || {                                 \n+                    // Borrow the scheduler we run on and check if it is\n+                    // privliged.\n+                    do Local::borrow::<Scheduler,()> |sched| {\n+                        assert!(sched.run_anything);\n+                    };\n+                };\n+                spawntask_random(f);\n+            };\n+        };\n         \n         let f_cell = Cell(f);\n         let handles = Cell(handles);"}]}