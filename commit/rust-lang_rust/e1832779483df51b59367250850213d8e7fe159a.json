{"sha": "e1832779483df51b59367250850213d8e7fe159a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODMyNzc5NDgzZGY1MWI1OTM2NzI1MDg1MDIxM2Q4ZTdmZTE1OWE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-11T11:11:02Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-11T11:11:02Z"}, "message": "Make errors allow for cross-crate issues", "tree": {"sha": "2e3bb1f69388b82a4a77b75ac1e8f2ead5596e73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e3bb1f69388b82a4a77b75ac1e8f2ead5596e73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1832779483df51b59367250850213d8e7fe159a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1832779483df51b59367250850213d8e7fe159a", "html_url": "https://github.com/rust-lang/rust/commit/e1832779483df51b59367250850213d8e7fe159a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1832779483df51b59367250850213d8e7fe159a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc0de42035dc5c71e47ded2968fc6fd7c76641c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc0de42035dc5c71e47ded2968fc6fd7c76641c6", "html_url": "https://github.com/rust-lang/rust/commit/dc0de42035dc5c71e47ded2968fc6fd7c76641c6"}], "stats": {"total": 52, "additions": 33, "deletions": 19}, "files": [{"sha": "0b0079c062db35bff5261f272ea80602a0fd14fa", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e1832779483df51b59367250850213d8e7fe159a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1832779483df51b59367250850213d8e7fe159a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=e1832779483df51b59367250850213d8e7fe159a", "patch": "@@ -22,7 +22,7 @@ use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n use std::collections::HashMap;\n-use syntax::codemap::Span;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use util::ppaux::{Repr, UserString};\n \n@@ -66,13 +66,20 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n }\n \n fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                     trait_ref: &TraitRef<'tcx>) -> Option<String> {\n+                                     trait_ref: &TraitRef<'tcx>,\n+                                     span: Span) -> Option<String> {\n     let def_id = trait_ref.def_id;\n     let mut report = None;\n     ty::each_attr(infcx.tcx, def_id, |item| {\n         if item.check_name(\"on_unimplemented\") {\n+            let err_sp = if item.meta().span == DUMMY_SP {\n+                span\n+            } else {\n+                item.meta().span\n+            };\n+            let def = ty::lookup_trait_def(infcx.tcx, def_id);\n+            let trait_str = def.trait_ref.user_string(infcx.tcx);\n             if let Some(ref istring) = item.value_str() {\n-                let def = ty::lookup_trait_def(infcx.tcx, def_id);\n                 let mut generic_map = def.generics.types.iter_enumerated()\n                                          .map(|(param, i, gen)| {\n                                                (gen.name.as_str().to_string(),\n@@ -91,20 +98,24 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 Some(val) => Some(val.as_slice()),\n                                 None => {\n                                     infcx.tcx.sess\n-                                         .span_err(item.meta().span,\n-                                                   format!(\"there is no type parameter \\\n-                                                            {} on trait {}\",\n-                                                           s, def.trait_ref\n-                                                                 .user_string(infcx.tcx))\n+                                         .span_err(err_sp,\n+                                                   format!(\"the #[on_unimplemented] attribute on \\\n+                                                            trait definition for {} refers to \\\n+                                                            non-existent type parameter {}\",\n+                                                           trait_str, s)\n                                                    .as_slice());\n                                     errored = true;\n                                     None\n                                 }\n                             },\n                             _ => {\n-                                infcx.tcx.sess.span_err(item.meta().span,\n-                                                        \"only named substitution \\\n-                                                        parameters are allowed\");\n+                                infcx.tcx.sess\n+                                     .span_err(err_sp,\n+                                               format!(\"the #[on_unimplemented] attribute on \\\n+                                                        trait definition for {} must have named \\\n+                                                        format arguments, \\\n+                                                        eg `#[on_unimplemented = \\\"foo {{T}}\\\"]`\",\n+                                                       trait_str).as_slice());\n                                 errored = true;\n                                 None\n                             }\n@@ -116,9 +127,11 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     report = Some(err);\n                 }\n             } else {\n-                infcx.tcx.sess.span_err(item.meta().span,\n-                                        \"this attribute must have a value, \\\n-                                        eg `#[on_unimplemented = \\\"foo\\\"]`\")\n+                infcx.tcx.sess.span_err(err_sp,\n+                                        format!(\"the #[on_unimplemented] attribute on \\\n+                                                 trait definition for {} must have a value, \\\n+                                                 eg `#[on_unimplemented = \\\"foo\\\"]`\",\n+                                                 trait_str).as_slice());\n             }\n             false\n         } else {\n@@ -154,15 +167,16 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.resolve_type_vars_if_possible(trait_predicate);\n                     if !trait_predicate.references_error() {\n                         let trait_ref = trait_predicate.to_poly_trait_ref();\n-                        // Check if it has a custom \"#[on_unimplemented]\" error message,\n-                        // report with that message if it does\n-                        let custom_note = report_on_unimplemented(infcx, &*trait_ref.0);\n                         infcx.tcx.sess.span_err(\n                             obligation.cause.span,\n                             format!(\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(infcx.tcx),\n                                 trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                        // Check if it has a custom \"#[on_unimplemented]\" error message,\n+                        // report with that message if it does\n+                        let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n+                                                                  obligation.cause.span);\n                         if let Some(s) = custom_note {\n                            infcx.tcx.sess.span_note(\n                                 obligation.cause.span,"}, {"sha": "3f899288f50d2d639460d3bfc0a4adf5168fc922", "filename": "src/test/compile-fail/on-unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1832779483df51b59367250850213d8e7fe159a/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1832779483df51b59367250850213d8e7fe159a/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs?ref=e1832779483df51b59367250850213d8e7fe159a", "patch": "@@ -26,11 +26,11 @@ fn collect<A, I: Iterator<Item=A>, B: MyFromIterator<A>>(it: I) -> B {\n     MyFromIterator::my_from_iter(it)\n }\n \n-#[on_unimplemented] //~ ERROR this attribute must have a value\n+#[on_unimplemented] //~ ERROR the #[on_unimplemented] attribute on trait definition for BadAnnotation1 must have a value, eg `#[on_unimplemented = \"foo\"]`\n trait BadAnnotation1 {}\n \n #[on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n-//~^ ERROR there is no type parameter C on trait BadAnnotation2<A, B>\n+//~^ ERROR the #[on_unimplemented] attribute on trait definition for BadAnnotation2<A, B> refers to non-existent type parameter C\n trait BadAnnotation2<A,B> {}\n \n fn trigger1<T: BadAnnotation1>(t: T)  {}"}]}