{"sha": "278067d34d1535a840cf9c99bcb8b538bf5b109a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ODA2N2QzNGQxNTM1YTg0MGNmOWM5OWJjYjhiNTM4YmY1YjEwOWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T21:23:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T21:23:11Z"}, "message": "Auto merge of #57879 - Centril:rollup, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #57380 (Fix Instant/Duration math precision & associativity on Windows)\n - #57606 (Get rid of the fake stack frame for reading from constants)\n - #57803 (Several changes to libunwind for SGX target)\n - #57846 (rustdoc: fix ICE from loading proc-macro stubs)\n - #57860 (Add os::fortanix_sgx::ffi module)\n - #57861 (Don't export table by default in wasm)\n - #57863 (Add suggestion for incorrect field syntax.)\n - #57867 (Fix std::future::from_generator documentation)\n - #57873 (Stabilize no_panic_pow)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7d3bd558b1a01bef4485dba03117107a7e132635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d3bd558b1a01bef4485dba03117107a7e132635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278067d34d1535a840cf9c99bcb8b538bf5b109a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278067d34d1535a840cf9c99bcb8b538bf5b109a", "html_url": "https://github.com/rust-lang/rust/commit/278067d34d1535a840cf9c99bcb8b538bf5b109a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278067d34d1535a840cf9c99bcb8b538bf5b109a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "html_url": "https://github.com/rust-lang/rust/commit/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1"}, {"sha": "5fa1016f93d77e43c3ed69b1155308616095cfcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa1016f93d77e43c3ed69b1155308616095cfcb", "html_url": "https://github.com/rust-lang/rust/commit/5fa1016f93d77e43c3ed69b1155308616095cfcb"}], "stats": {"total": 604, "additions": 432, "deletions": 172}, "files": [{"sha": "952c1ba2ccb76b21ac52e3296b579398d04e8d73", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -32,7 +32,7 @@ RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n # We pass the commit id of the port of LLVM's libunwind to the build script.\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n-RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"bbe23902411be88d7388f381becefadd6e3ef819\"\n+RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"13fad13f8ea83a8da58d04a5faa45943151b3398\"\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "423b800d5852f98d3f75826d80c145712d7655e9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -847,13 +847,12 @@ overflow occurred.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\",\n $EndFeature, \"\n ```\"),\n \n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n@@ -966,15 +965,14 @@ saturating at the numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\n assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\n assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\",\n $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n@@ -1297,13 +1295,12 @@ wrapping around at the boundary of the type.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\n assert_eq!(3i8.wrapping_pow(5), -13);\n assert_eq!(3i8.wrapping_pow(6), -39);\",\n $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n@@ -1669,12 +1666,11 @@ whether an overflow happened.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\n assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n@@ -2789,11 +2785,10 @@ overflow occurred.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n@@ -2893,14 +2888,13 @@ saturating at the numeric bounds instead of overflowing.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"use std::\", stringify!($SelfT), \";\n \n assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\n assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\",\n $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n@@ -3178,11 +3172,10 @@ wrapping around at the boundary of the type.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\n assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n@@ -3497,11 +3490,10 @@ whether an overflow happened.\n Basic usage:\n \n ```\n-#![feature(no_panic_pow)]\n \", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\n assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n ```\"),\n-            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n             #[inline]\n             pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;"}, {"sha": "ad61f8f01d8d416692f70e678474e2b0ab15ce07", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -911,9 +911,6 @@ impl<'a> WasmLd<'a> {\n         // For now we just never have an entry symbol\n         cmd.arg(\"--no-entry\");\n \n-        // Make the default table accessible\n-        cmd.arg(\"--export-table\");\n-\n         // Rust code should never have warnings, and warnings are often\n         // indicative of bugs, let's prevent them.\n         cmd.arg(\"--fatal-warnings\");"}, {"sha": "56d4342e6e1618094c8f74575996db1f38002339", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -59,7 +59,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let field = const_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),\n-                        self.instance,\n                         None,\n                         mir::Field::new(field as usize),\n                         c,"}, {"sha": "45c6c1b42496a052038d0758575bb509b2365c5c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 67, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -10,11 +10,10 @@ use rustc::hir::{self, def_id::DefId};\n use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n-use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::ErrorReported;\n \n@@ -35,72 +34,20 @@ const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n /// Should be a power of two for performance reasons.\n const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n-/// Warning: do not use this function if you expect to start interpreting the given `Mir`.\n-/// The `EvalContext` is only meant to be used to query values from constants and statics.\n-///\n-/// This function is used during const propagation. We cannot use `mk_eval_cx`, because copy\n-/// propagation happens *during* the computation of the MIR of the current function. So if we\n-/// tried to call the `optimized_mir` query, we'd get a cycle error because we are (transitively)\n-/// inside the `optimized_mir` query of the `Instance` given.\n-///\n-/// Since we are looking at the MIR of the function in an abstract manner, we don't have a\n-/// `ParamEnv` available to us. This function creates a `ParamEnv` for the given instance.\n-pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    mir: &'mir mir::Mir<'tcx>,\n-    span: Span,\n-) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n-    debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n-    let param_env = tcx.param_env(instance.def_id());\n-    mk_eval_cx_inner(tcx, instance, mir, span, param_env)\n-}\n-\n-/// This is just a helper function to reduce code duplication between `mk_borrowck_eval_cx` and\n-/// `mk_eval_cx`. Do not call this function directly.\n-fn mk_eval_cx_inner<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    mir: &'mir mir::Mir<'tcx>,\n-    span: Span,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n-    // Insert a stack frame so any queries have the correct substs.\n-    // We also avoid all the extra work performed by push_stack_frame,\n-    // like initializing local variables\n-    ecx.stack.push(interpret::Frame {\n-        block: mir::START_BLOCK,\n-        locals: IndexVec::new(),\n-        local_layouts: IndexVec::new(),\n-        instance,\n-        span,\n-        mir,\n-        return_place: None,\n-        return_to_block: StackPopCleanup::Goto(None), // never pop\n-        stmt: 0,\n-        extra: (),\n-    });\n-    Ok(ecx)\n-}\n-\n-/// Warning: do not use this function if you expect to start interpreting the given `Mir`.\n /// The `EvalContext` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n /// that inform us about the generic bounds of the constant. E.g. using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-fn mk_eval_cx<'a, 'tcx>(\n+pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n+    span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'tcx, 'tcx>> {\n-    debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n-    let span = tcx.def_span(instance.def_id());\n-    let mir = tcx.optimized_mir(instance.def.def_id());\n-    mk_eval_cx_inner(tcx, instance, mir, span, param_env)\n+) -> CompileTimeEvalContext<'a, 'mir, 'tcx> {\n+    debug!(\"mk_eval_cx: {:?}\", param_env);\n+    EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n@@ -109,7 +56,8 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-    let mut ecx = mk_borrowck_eval_cx(tcx, cid.instance, mir, DUMMY_SP).unwrap();\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut ecx = mk_eval_cx(tcx, span, param_env);\n     eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n@@ -530,13 +478,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    instance: ty::Instance<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n     value: ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n-    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    trace!(\"const_field: {:?}, {:?}\", field, value);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n         let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(value), value.ty)?;\n@@ -561,11 +508,10 @@ pub fn const_field<'a, 'tcx>(\n pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    instance: ty::Instance<'tcx>,\n     val: ty::Const<'tcx>,\n ) -> EvalResult<'tcx, VariantIdx> {\n-    trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n-    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    trace!(\"const_variant_index: {:?}\", val);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(val), val.ty)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n@@ -585,7 +531,7 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n-    let ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n+    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env);\n     let val = (|| {\n         let op = ecx.raw_const_to_mplace(constant)?.into();\n         // FIXME: Once the visitor infrastructure landed, change validation to"}, {"sha": "9cc5c93de41d8e3f9c4f1091ccdfed769a6a6b5c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -427,13 +427,24 @@ pub enum Constructor<'tcx> {\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n+    fn variant_index_for_adt<'a>(\n+        &self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+    ) -> VariantIdx {\n         match self {\n             &Variant(vid) => adt.variant_index_with_id(vid),\n             &Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n+            &ConstantValue(c) => {\n+                ::const_eval::const_variant_index(\n+                    cx.tcx,\n+                    cx.param_env,\n+                    c,\n+                ).unwrap()\n+            },\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n@@ -567,7 +578,7 @@ impl<'tcx> Witness<'tcx> {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n-                                variant_index: ctor.variant_index_for_adt(adt),\n+                                variant_index: ctor.variant_index_for_adt(cx, adt),\n                                 subpatterns: pats\n                             }\n                         } else {\n@@ -1329,7 +1340,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n+fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty: Ty<'tcx>) -> u64 {\n     debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::Tuple(ref fs) => fs.len() as u64,\n@@ -1340,7 +1351,7 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n         },\n         ty::Ref(..) => 1,\n         ty::Adt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n+            adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64\n         }\n         _ => 0\n     }\n@@ -1351,7 +1362,7 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n ///\n /// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n-                                             ctor: &Constructor,\n+                                             ctor: &Constructor<'tcx>,\n                                              ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n@@ -1368,7 +1379,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n             } else {\n-                adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n+                adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n                     if is_visible {"}, {"sha": "cdaffe5d45673adc747c08d93a069b1f17a03dc2", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -885,7 +885,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = const_field(\n-                self.tcx, self.param_env, instance,\n+                self.tcx, self.param_env,\n                 variant_opt, field, cv,\n             ).expect(\"field access failed\");\n             self.const_to_pat(instance, val, id, span)\n@@ -928,7 +928,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             },\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(\n-                    self.tcx, self.param_env, instance, cv\n+                    self.tcx, self.param_env, cv\n                 ).expect(\"const_variant_index failed\");\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),"}, {"sha": "c3b71be8354daabcb1c6c1b6c0ce952876f740cd", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -109,11 +109,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n-                        let substs = self.tcx.subst_and_normalize_erasing_regions(\n-                            self.substs(),\n-                            ty::ParamEnv::reveal_all(),\n-                            &substs,\n-                        );\n+                        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,"}, {"sha": "132b753eb9a62dc92595556e7d95224b0ed9663e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -216,11 +216,21 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         self.frame().mir\n     }\n \n-    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n-        if let Some(frame) = self.stack.last() {\n-            frame.instance.substs\n-        } else {\n-            Substs::empty()\n+    pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n+        &self,\n+        substs: T,\n+    ) -> EvalResult<'tcx, T> {\n+        match self.stack.last() {\n+            Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n+                frame.instance.substs,\n+                self.param_env,\n+                &substs,\n+            )),\n+            None => if substs.needs_subst() {\n+                err!(TooGeneric).into()\n+            } else {\n+                Ok(substs)\n+            },\n         }\n     }\n \n@@ -230,13 +240,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         substs: &'tcx Substs<'tcx>\n     ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n-        trace!(\"substs: {:#?}\", self.substs());\n         trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.tcx.subst_and_normalize_erasing_regions(\n-            self.substs(),\n-            self.param_env,\n-            &substs,\n-        );\n+        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+        trace!(\"substs: {:#?}\", substs);\n         ty::Instance::resolve(\n             *self.tcx,\n             self.param_env,\n@@ -276,7 +282,21 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n     }\n \n-    pub fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+        &self,\n+        t: T,\n+    ) -> EvalResult<'tcx, T> {\n+        match self.stack.last() {\n+            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)),\n+            None => if t.needs_subst() {\n+                err!(TooGeneric).into()\n+            } else {\n+                Ok(t)\n+            },\n+        }\n+    }\n+\n+    fn monomorphize_with_substs<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n         &self,\n         t: T,\n         substs: &'tcx Substs<'tcx>\n@@ -295,7 +315,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         let cell = &frame.local_layouts[local];\n         if cell.get().is_none() {\n             let local_ty = frame.mir.local_decls[local].ty;\n-            let local_ty = self.monomorphize(local_ty, frame.instance.substs);\n+            let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n             let layout = self.layout_of(local_ty)?;\n             cell.set(Some(layout));\n         }"}, {"sha": "8741571342f83aff5e01e3700d028791d9d92a4e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -508,7 +508,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             Constant(ref constant) => {\n                 let layout = from_known_layout(layout, || {\n-                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx), self.substs());\n+                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx))?;\n                     self.layout_of(ty)\n                 })?;\n                 let op = self.const_value_to_op(*constant.literal)?;"}, {"sha": "f3a948a6ca3e70dbff560c86e5fa5db5f5a6a19f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -9,6 +9,7 @@ use rustc::hir;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n+use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n@@ -583,8 +584,8 @@ where\n             }\n \n             Static(ref static_) => {\n-                let ty = self.monomorphize(static_.ty, self.substs());\n-                let layout = self.layout_of(ty)?;\n+                assert!(!static_.ty.needs_subst());\n+                let layout = self.layout_of(static_.ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n                 let cid = GlobalId {\n                     instance,"}, {"sha": "25f3e4c1f771d80879409f9c6c0e9fe939659c0e", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty, self.substs());\n+                let ty = self.monomorphize(ty)?;\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n@@ -260,7 +260,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n-                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest.layout.ty);\n+                debug_assert_eq!(self.monomorphize(cast_ty)?, dest.layout.ty);\n                 let src = self.eval_operand(operand, None)?;\n                 self.cast(src, kind, dest)?;\n             }"}, {"sha": "dc556a15cd8550fe0891bba8995997519f50d915", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::layout::{\n \n use interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n use const_eval::{\n-    CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx,\n+    CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n     lazy_const_to_op,\n };\n use transform::{MirPass, MirSource};\n@@ -110,9 +110,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source: MirSource,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id);\n-        let substs = Substs::identity_for_item(tcx, source.def_id);\n-        let instance = Instance::new(source.def_id, substs);\n-        let ecx = mk_borrowck_eval_cx(tcx, instance, mir, DUMMY_SP).unwrap();\n+        let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id), param_env);\n         ConstPropagator {\n             ecx,\n             mir,"}, {"sha": "13ad05101e4b66bfee470a363e3646b16a3c74f5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -431,8 +431,12 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     let parent_scope = resolver.dummy_parent_scope();\n     if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n                                                          &parent_scope, false, false) {\n-        if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n-            return Some(def);\n+        if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n+            // skip proc-macro stubs, they'll cause `get_macro` to crash\n+        } else {\n+            if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n+                return Some(def);\n+            }\n         }\n     }\n     if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {"}, {"sha": "22900c3067b112470cd02075ce76bbd5e9681e90", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -11,7 +11,7 @@ use core::ops::{Drop, Generator, GeneratorState};\n #[doc(inline)]\n pub use core::future::*;\n \n-/// Wrap a future in a generator.\n+/// Wrap a generator in a future.\n ///\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`)."}, {"sha": "810965fc1b85af02892ba3126eb8db80ccaed161", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -56,4 +56,4 @@ pub mod mem {\n     pub use sys::abi::mem::*;\n }\n \n-pub use sys::ext::{io, arch};\n+pub use sys::ext::{io, arch, ffi};"}, {"sha": "7b0ffea49ae7caaf7c9af35ea0cf203a60c2bf98", "filename": "src/libstd/sys/sgx/ext/ffi.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fffi.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -0,0 +1,109 @@\n+//! SGX-specific extension to the primitives in the `std::ffi` module\n+\n+#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+\n+use ffi::{OsStr, OsString};\n+use mem;\n+use sys::os_str::Buf;\n+use sys_common::{FromInner, IntoInner, AsInner};\n+\n+/// SGX-specific extensions to [`OsString`].\n+///\n+/// [`OsString`]: ../../../../std/ffi/struct.OsString.html\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub trait OsStringExt {\n+    /// Creates an [`OsString`] from a byte vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsString;\n+    /// use std::os::unix::ffi::OsStringExt;\n+    ///\n+    /// let bytes = b\"foo\".to_vec();\n+    /// let os_string = OsString::from_vec(bytes);\n+    /// assert_eq!(os_string.to_str(), Some(\"foo\"));\n+    /// ```\n+    ///\n+    /// [`OsString`]: ../../../ffi/struct.OsString.html\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yields the underlying byte vector of this [`OsString`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsString;\n+    /// use std::os::unix::ffi::OsStringExt;\n+    ///\n+    /// let mut os_string = OsString::new();\n+    /// os_string.push(\"foo\");\n+    /// let bytes = os_string.into_vec();\n+    /// assert_eq!(bytes, b\"foo\");\n+    /// ```\n+    ///\n+    /// [`OsString`]: ../../../ffi/struct.OsString.html\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+/// SGX-specific extensions to [`OsStr`].\n+///\n+/// [`OsStr`]: ../../../../std/ffi/struct.OsStr.html\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub trait OsStrExt {\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    /// Creates an [`OsStr`] from a byte slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsStr;\n+    /// use std::os::unix::ffi::OsStrExt;\n+    ///\n+    /// let bytes = b\"foo\";\n+    /// let os_str = OsStr::from_bytes(bytes);\n+    /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n+    /// ```\n+    ///\n+    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n+    fn from_bytes(slice: &[u8]) -> &Self;\n+\n+    /// Gets the underlying byte view of the [`OsStr`] slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsStr;\n+    /// use std::os::unix::ffi::OsStrExt;\n+    ///\n+    /// let mut os_str = OsStr::new(\"foo\");\n+    /// let bytes = os_str.as_bytes();\n+    /// assert_eq!(bytes, b\"foo\");\n+    /// ```\n+    ///\n+    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    fn as_bytes(&self) -> &[u8];\n+}\n+\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+impl OsStrExt for OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}"}, {"sha": "51b2659da83e369f7e3ec1aa19aa37c2e64b63df", "filename": "src/libstd/sys/sgx/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -2,3 +2,4 @@\n \n pub mod arch;\n pub mod io;\n+pub mod ffi;"}, {"sha": "43ceae7d33b8d88d8c2e904531730db606f3ee6a", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -1,3 +1,4 @@\n+use alloc::{self, Layout};\n use num::NonZeroUsize;\n use slice;\n use str;\n@@ -147,6 +148,7 @@ impl RWLock {\n         self.__write_unlock(rguard, wguard);\n     }\n \n+    // only used by __rust_rwlock_unlock below\n     #[inline]\n     unsafe fn unlock(&self) {\n         let rguard = self.readers.lock();\n@@ -164,6 +166,7 @@ impl RWLock {\n \n const EINVAL: i32 = 22;\n \n+// used by libunwind port\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n@@ -190,6 +193,8 @@ pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n     return 0;\n }\n \n+// the following functions are also used by the libunwind port. They're\n+// included here to make sure parallel codegen and LTO don't mess things up.\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n     if s < 0 {\n@@ -206,6 +211,16 @@ pub unsafe extern \"C\" fn __rust_abort() {\n     ::sys::abort_internal();\n }\n \n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n+    alloc::alloc(Layout::from_size_align_unchecked(size, align))\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n+    alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+}\n+\n #[cfg(test)]\n mod tests {\n "}, {"sha": "8a8159af2f1a6ee2b5c4e8eecb8995296dc65726", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 74, "deletions": 44, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -1,10 +1,7 @@\n use cmp::Ordering;\n use fmt;\n use mem;\n-use sync::Once;\n use sys::c;\n-use sys::cvt;\n-use sys_common::mul_div_u64;\n use time::Duration;\n use convert::TryInto;\n use core::hash::{Hash, Hasher};\n@@ -14,7 +11,9 @@ const INTERVALS_PER_SEC: u64 = NANOS_PER_SEC / 100;\n \n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n pub struct Instant {\n-    t: c::LARGE_INTEGER,\n+    // This duration is relative to an arbitrary microsecond epoch\n+    // from the winapi QueryPerformanceCounter function.\n+    t: Duration,\n }\n \n #[derive(Copy, Clone)]\n@@ -33,59 +32,44 @@ pub const UNIX_EPOCH: SystemTime = SystemTime {\n \n impl Instant {\n     pub fn now() -> Instant {\n-        let mut t = Instant { t: 0 };\n-        cvt(unsafe {\n-            c::QueryPerformanceCounter(&mut t.t)\n-        }).unwrap();\n-        t\n+        // High precision timing on windows operates in \"Performance Counter\"\n+        // units, as returned by the WINAPI QueryPerformanceCounter function.\n+        // These relate to seconds by a factor of QueryPerformanceFrequency.\n+        // In order to keep unit conversions out of normal interval math, we\n+        // measure in QPC units and immediately convert to nanoseconds.\n+        perf_counter::PerformanceCounterInstant::now().into()\n     }\n \n     pub fn actually_monotonic() -> bool {\n         false\n     }\n \n     pub const fn zero() -> Instant {\n-        Instant { t: 0 }\n+        Instant { t: Duration::from_secs(0) }\n     }\n \n     pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        // Values which are +- 1 need to be considered as basically the same\n-        // units in time due to various measurement oddities, according to\n-        // Windows [1]\n-        //\n-        // [1]:\n-        // https://msdn.microsoft.com/en-us/library/windows/desktop\n-        //                           /dn553408%28v=vs.85%29.aspx#guidance\n-        if other.t > self.t && other.t - self.t == 1 {\n+        // On windows there's a threshold below which we consider two timestamps\n+        // equivalent due to measurement error. For more details + doc link,\n+        // check the docs on epsilon.\n+        let epsilon =\n+            perf_counter::PerformanceCounterInstant::epsilon();\n+        if other.t > self.t && other.t - self.t <= epsilon {\n             return Duration::new(0, 0)\n         }\n-        let diff = (self.t as u64).checked_sub(other.t as u64)\n-                                  .expect(\"specified instant was later than \\\n-                                           self\");\n-        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n-        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n+        self.t.checked_sub(other.t)\n+              .expect(\"specified instant was later than self\")\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        let freq = frequency() as u64;\n-        let t = other.as_secs()\n-            .checked_mul(freq)?\n-            .checked_add(mul_div_u64(other.subsec_nanos() as u64, freq, NANOS_PER_SEC))?\n-            .checked_add(self.t as u64)?;\n         Some(Instant {\n-            t: t as c::LARGE_INTEGER,\n+            t: self.t.checked_add(*other)?\n         })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        let freq = frequency() as u64;\n-        let t = other.as_secs().checked_mul(freq).and_then(|i| {\n-            (self.t as u64).checked_sub(i)\n-        }).and_then(|i| {\n-            i.checked_sub(mul_div_u64(other.subsec_nanos() as u64, freq, NANOS_PER_SEC))\n-        })?;\n         Some(Instant {\n-            t: t as c::LARGE_INTEGER,\n+            t: self.t.checked_sub(*other)?\n         })\n     }\n }\n@@ -186,14 +170,60 @@ fn intervals2dur(intervals: u64) -> Duration {\n                   ((intervals % INTERVALS_PER_SEC) * 100) as u32)\n }\n \n-fn frequency() -> c::LARGE_INTEGER {\n-    static mut FREQUENCY: c::LARGE_INTEGER = 0;\n-    static ONCE: Once = Once::new();\n+mod perf_counter {\n+    use super::{NANOS_PER_SEC};\n+    use sync::Once;\n+    use sys_common::mul_div_u64;\n+    use sys::c;\n+    use sys::cvt;\n+    use time::Duration;\n+\n+    pub struct PerformanceCounterInstant {\n+        ts: c::LARGE_INTEGER\n+    }\n+    impl PerformanceCounterInstant {\n+        pub fn now() -> Self {\n+            Self {\n+                ts: query()\n+            }\n+        }\n \n-    unsafe {\n-        ONCE.call_once(|| {\n-            cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n-        });\n-        FREQUENCY\n+        // Per microsoft docs, the margin of error for cross-thread time comparisons\n+        // using QueryPerformanceCounter is 1 \"tick\" -- defined as 1/frequency().\n+        // Reference: https://docs.microsoft.com/en-us/windows/desktop/SysInfo\n+        //                   /acquiring-high-resolution-time-stamps\n+        pub fn epsilon() -> Duration {\n+            let epsilon = NANOS_PER_SEC / (frequency() as u64);\n+            Duration::from_nanos(epsilon)\n+        }\n+    }\n+    impl From<PerformanceCounterInstant> for super::Instant {\n+        fn from(other: PerformanceCounterInstant) -> Self {\n+            let freq = frequency() as u64;\n+            let instant_nsec = mul_div_u64(other.ts as u64, NANOS_PER_SEC, freq);\n+            Self {\n+                t: Duration::from_nanos(instant_nsec)\n+            }\n+        }\n+    }\n+\n+    fn frequency() -> c::LARGE_INTEGER {\n+        static mut FREQUENCY: c::LARGE_INTEGER = 0;\n+        static ONCE: Once = Once::new();\n+\n+        unsafe {\n+            ONCE.call_once(|| {\n+                cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n+            });\n+            FREQUENCY\n+        }\n+    }\n+\n+    fn query() -> c::LARGE_INTEGER {\n+        let mut qpc_value: c::LARGE_INTEGER = 0;\n+        cvt(unsafe {\n+            c::QueryPerformanceCounter(&mut qpc_value)\n+        }).unwrap();\n+        qpc_value\n     }\n }"}, {"sha": "23924559fcc248c447bb54fc268a115dc07d4da4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -610,6 +610,15 @@ mod tests {\n         assert_eq!(a + year, a.checked_add(year).unwrap());\n     }\n \n+    #[test]\n+    fn instant_math_is_associative() {\n+        let now = Instant::now();\n+        let offset = Duration::from_millis(5);\n+        // Changing the order of instant math shouldn't change the results,\n+        // especially when the expression reduces to X + identity.\n+        assert_eq!((now + offset) - now, (now - now) + offset);\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn instant_duration_panic() {"}, {"sha": "fb832afb74833296716e46f3cf4e59f5ffa9b057", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -2319,8 +2319,24 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-        let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n+        let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| {\n+            t == &token::Colon || t == &token::Eq\n+        }) {\n             let fieldname = self.parse_field_name()?;\n+\n+            // Check for an equals token. This means the source incorrectly attempts to\n+            // initialize a field with an eq rather than a colon.\n+            if self.token == token::Eq {\n+                self.diagnostic()\n+                    .struct_span_err(self.span, \"expected `:`, found `=`\")\n+                    .span_suggestion_with_applicability(\n+                        fieldname.span.shrink_to_hi().to(self.span),\n+                        \"replace equals symbol with a colon\",\n+                        \":\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            }\n             self.bump(); // `:`\n             (fieldname, self.parse_expr()?, false)\n         } else {"}, {"sha": "1e396f1be0e0440ce8c24e3b23bce3e26d780824", "filename": "src/test/rustdoc/proc-macro.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -4,6 +4,11 @@\n #![crate_type=\"proc-macro\"]\n #![crate_name=\"some_macros\"]\n \n+// @has some_macros/index.html\n+// @has - '//a/[@href=\"attr.some_proc_attr.html\"]' 'some_proc_attr'\n+\n+//! include a link to [some_proc_attr] to make sure it works.\n+\n extern crate proc_macro;\n \n use proc_macro::TokenStream;"}, {"sha": "53c5782a4c70e53d8b0c3854c8be8476126f0f27", "filename": "src/test/ui/consts/match_ice.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -0,0 +1,10 @@\n+// https://github.com/rust-lang/rust/issues/53708\n+\n+struct S;\n+\n+fn main() {\n+    const C: &S = &S;\n+    match C { //~ ERROR non-exhaustive\n+        C => {} // this is a common bug around constants and references in patterns\n+    }\n+}"}, {"sha": "e6e04e2c4627687d8388b124e7df0bdf431533da", "filename": "src/test/ui/consts/match_ice.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -0,0 +1,9 @@\n+error[E0004]: non-exhaustive patterns: `&S` not covered\n+  --> $DIR/match_ice.rs:7:11\n+   |\n+LL |     match C { //~ ERROR non-exhaustive\n+   |           ^ pattern `&S` not covered\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "4a432206d51e1488275e52a8ce1ac1fa1b80550d", "filename": "src/test/ui/issues/issue-57684.fixed", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fissues%2Fissue-57684.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fissues%2Fissue-57684.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57684.fixed?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// This test checks that the following error is emitted when a `=` character is used to initialize\n+// a struct field when a `:` is expected.\n+//\n+// ```\n+// error: struct fields are initialized with a colon\n+//   --> $DIR/issue-57684.rs:12:20\n+//    |\n+// LL |     let _ = X { f1 = 5 };\n+//    |                    ^ help: replace equals symbol with a colon: `:`\n+// ```\n+\n+struct X {\n+    f1: i32,\n+}\n+\n+struct Y {\n+    f1: i32,\n+    f2: i32,\n+    f3: i32,\n+}\n+\n+fn main() {\n+    let _ = X { f1: 5 };\n+    //~^ ERROR expected `:`, found `=`\n+\n+    let f3 = 3;\n+    let _ = Y {\n+        f1: 5,\n+        //~^ ERROR expected `:`, found `=`\n+        f2: 4,\n+        f3,\n+    };\n+}"}, {"sha": "7a62785e32f1c045583ca276283bca8cfaa2bc6a", "filename": "src/test/ui/issues/issue-57684.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fissues%2Fissue-57684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fissues%2Fissue-57684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57684.rs?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// This test checks that the following error is emitted when a `=` character is used to initialize\n+// a struct field when a `:` is expected.\n+//\n+// ```\n+// error: struct fields are initialized with a colon\n+//   --> $DIR/issue-57684.rs:12:20\n+//    |\n+// LL |     let _ = X { f1 = 5 };\n+//    |                    ^ help: replace equals symbol with a colon: `:`\n+// ```\n+\n+struct X {\n+    f1: i32,\n+}\n+\n+struct Y {\n+    f1: i32,\n+    f2: i32,\n+    f3: i32,\n+}\n+\n+fn main() {\n+    let _ = X { f1 = 5 };\n+    //~^ ERROR expected `:`, found `=`\n+\n+    let f3 = 3;\n+    let _ = Y {\n+        f1 = 5,\n+        //~^ ERROR expected `:`, found `=`\n+        f2: 4,\n+        f3,\n+    };\n+}"}, {"sha": "514bbffde6b1e957b68ad94042b1bef77d322a48", "filename": "src/test/ui/issues/issue-57684.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fissues%2Fissue-57684.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Ftest%2Fui%2Fissues%2Fissue-57684.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57684.stderr?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -0,0 +1,18 @@\n+error: expected `:`, found `=`\n+  --> $DIR/issue-57684.rs:27:20\n+   |\n+LL |     let _ = X { f1 = 5 };\n+   |                   -^\n+   |                   |\n+   |                   help: replace equals symbol with a colon: `:`\n+\n+error: expected `:`, found `=`\n+  --> $DIR/issue-57684.rs:32:12\n+   |\n+LL |         f1 = 5,\n+   |           -^\n+   |           |\n+   |           help: replace equals symbol with a colon: `:`\n+\n+error: aborting due to 2 previous errors\n+"}]}