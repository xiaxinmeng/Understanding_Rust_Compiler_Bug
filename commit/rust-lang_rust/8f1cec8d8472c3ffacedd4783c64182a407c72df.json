{"sha": "8f1cec8d8472c3ffacedd4783c64182a407c72df", "node_id": "C_kwDOAAsO6NoAKDhmMWNlYzhkODQ3MmMzZmZhY2VkZDQ3ODNjNjQxODJhNDA3YzcyZGY", "commit": {"author": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-04-21T23:49:36Z"}, "committer": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-05-24T21:52:18Z"}, "message": "Safe Transmute: Enable handling references, including recursive types\n\nThis patch enables support for references in Safe Transmute, by generating\nnested obligations during trait selection. Specifically, when we call\n`confirm_transmutability_candidate(...)`, we now recursively traverse the\n`rustc_transmute::Answer` tree and create obligations for all the `Answer`\nvariants, some of which include multiple nested `Answer`s.\n\nAlso, to handle recursive types, enable support for coinduction for the Safe\nTransmute trait (`BikeshedIntrinsicFrom`) by adding the `#[rustc_coinduction]`\nannotation.\n\nAlso fix some small logic issues when reducing the `or` and `and` combinations\nin `rustc_transmute`, so that we don't end up with additional redundant\n`Answer`s in the tree.\n\nCo-authored-by: Jack Wrenn <jack@wrenn.fyi>", "tree": {"sha": "79f6bc12055896112e0b0898c13042411638847d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79f6bc12055896112e0b0898c13042411638847d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f1cec8d8472c3ffacedd4783c64182a407c72df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1cec8d8472c3ffacedd4783c64182a407c72df", "html_url": "https://github.com/rust-lang/rust/commit/8f1cec8d8472c3ffacedd4783c64182a407c72df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f1cec8d8472c3ffacedd4783c64182a407c72df/comments", "author": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8", "html_url": "https://github.com/rust-lang/rust/commit/97d328012b9ed9b7d481c40e84aa1f2c65b33ec8"}], "stats": {"total": 563, "additions": 460, "deletions": 103}, "files": [{"sha": "7e132e0ab60c718cbcf21826afc4ef918f6ef343", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -2783,6 +2783,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     rustc_transmute::Reason::DstIsTooBig => {\n                         format!(\"The size of `{src}` is smaller than the size of `{dst}`\")\n                     }\n+                    rustc_transmute::Reason::DstHasStricterAlignment => {\n+                        format!(\n+                            \"The alignment of `{src}` should be stricter than that of `{dst}`, but it is not\"\n+                        )\n+                    }\n+                    rustc_transmute::Reason::DstIsMoreUnique => {\n+                        format!(\"`{src}` is a shared reference, but `{dst}` is a unique reference\")\n+                    }\n                 };\n                 (custom_err_msg, Some(reason_msg))\n             }\n@@ -2791,7 +2799,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 span,\n                 \"Inconsistent rustc_transmute::is_transmutable(...) result, got Yes\",\n             ),\n-            _ => span_bug!(span, \"Unsupported rustc_transmute::Reason variant\"),\n+            other => span_bug!(span, \"Unsupported rustc_transmute::Answer variant: `{other:?}`\"),\n         }\n     }\n "}, {"sha": "9b28873f7099c99546817a53b433efe56ffdf244", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -13,7 +13,7 @@ use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::traits::SelectionOutputTypeParameterMismatch;\n use rustc_middle::ty::{\n     self, Binder, GenericParamDefKind, InternalSubsts, SubstsRef, ToPolyTraitRef, ToPredicate,\n-    TraitRef, Ty, TyCtxt, TypeVisitableExt,\n+    TraitPredicate, TraitRef, Ty, TyCtxt, TypeVisitableExt,\n };\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::DefId;\n@@ -279,10 +279,61 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ImplSourceBuiltinData { nested: obligations }\n     }\n \n+    #[instrument(skip(self))]\n     fn confirm_transmutability_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        fn flatten_answer_tree<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            obligation: &TraitObligation<'tcx>,\n+            predicate: TraitPredicate<'tcx>,\n+            answer: rustc_transmute::Answer<rustc_transmute::layout::rustc::Ref<'tcx>>,\n+        ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+            match answer {\n+                rustc_transmute::Answer::Yes => Ok(vec![]),\n+                rustc_transmute::Answer::No(_) => Err(Unimplemented),\n+                // FIXME(bryangarza): Add separate `IfAny` case, instead of treating as `IfAll`\n+                rustc_transmute::Answer::IfAll(answers)\n+                | rustc_transmute::Answer::IfAny(answers) => {\n+                    let mut nested = vec![];\n+                    for flattened in answers\n+                        .into_iter()\n+                        .map(|answer| flatten_answer_tree(tcx, obligation, predicate, answer))\n+                    {\n+                        nested.extend(flattened?);\n+                    }\n+                    Ok(nested)\n+                }\n+                rustc_transmute::Answer::IfTransmutable { src, dst } => {\n+                    let trait_def_id = obligation.predicate.def_id();\n+                    let scope = predicate.trait_ref.substs.type_at(2);\n+                    let assume_const = predicate.trait_ref.substs.const_at(3);\n+                    let make_obl = |from_ty, to_ty| {\n+                        let trait_ref1 = tcx.mk_trait_ref(\n+                            trait_def_id,\n+                            [\n+                                ty::GenericArg::from(to_ty),\n+                                ty::GenericArg::from(from_ty),\n+                                ty::GenericArg::from(scope),\n+                                ty::GenericArg::from(assume_const),\n+                            ],\n+                        );\n+                        Obligation::with_depth(\n+                            tcx,\n+                            obligation.cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            obligation.param_env,\n+                            trait_ref1,\n+                        )\n+                    };\n+\n+                    // // FIXME(bryangarza): Check src.mutability or dst.mutability to know whether dst -> src obligation is needed\n+                    Ok(vec![make_obl(src.ty, dst.ty), make_obl(dst.ty, src.ty)])\n+                }\n+            }\n+        }\n+\n         debug!(?obligation, \"confirm_transmutability_candidate\");\n \n         // We erase regions here because transmutability calls layout queries,\n@@ -312,10 +363,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             assume,\n         );\n \n-        match maybe_transmutable {\n-            rustc_transmute::Answer::Yes => Ok(ImplSourceBuiltinData { nested: vec![] }),\n-            _ => Err(Unimplemented),\n-        }\n+        info!(?maybe_transmutable);\n+        let nested = flatten_answer_tree(self.tcx(), obligation, predicate, maybe_transmutable)?;\n+        info!(?nested);\n+        Ok(ImplSourceBuiltinData { nested })\n     }\n \n     /// This handles the case where an `auto trait Foo` impl is being used."}, {"sha": "b318447e581c7e495eb38aaff02dbe4d7b82f723", "filename": "compiler/rustc_transmute/src/layout/mod.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -30,33 +30,46 @@ impl fmt::Debug for Byte {\n }\n \n pub(crate) trait Def: Debug + Hash + Eq + PartialEq + Copy + Clone {}\n-pub trait Ref: Debug + Hash + Eq + PartialEq + Copy + Clone {}\n+pub trait Ref: Debug + Hash + Eq + PartialEq + Copy + Clone {\n+    fn min_align(&self) -> usize {\n+        1\n+    }\n+\n+    fn is_mutable(&self) -> bool {\n+        false\n+    }\n+}\n \n impl Def for ! {}\n impl Ref for ! {}\n \n #[cfg(feature = \"rustc\")]\n-pub(crate) mod rustc {\n+pub mod rustc {\n     use rustc_middle::mir::Mutability;\n-    use rustc_middle::ty;\n-    use rustc_middle::ty::Region;\n-    use rustc_middle::ty::Ty;\n+    use rustc_middle::ty::{self, Ty};\n \n     /// A reference in the layout.\n     #[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone, Copy)]\n     pub struct Ref<'tcx> {\n-        lifetime: Region<'tcx>,\n-        ty: Ty<'tcx>,\n-        mutability: Mutability,\n+        pub lifetime: ty::Region<'tcx>,\n+        pub ty: Ty<'tcx>,\n+        pub mutability: Mutability,\n+        pub align: usize,\n     }\n \n-    impl<'tcx> super::Ref for Ref<'tcx> {}\n+    impl<'tcx> super::Ref for Ref<'tcx> {\n+        fn min_align(&self) -> usize {\n+            self.align\n+        }\n \n-    impl<'tcx> Ref<'tcx> {\n-        pub fn min_align(&self) -> usize {\n-            todo!()\n+        fn is_mutable(&self) -> bool {\n+            match self.mutability {\n+                Mutability::Mut => true,\n+                Mutability::Not => false,\n+            }\n         }\n     }\n+    impl<'tcx> Ref<'tcx> {}\n \n     /// A visibility node in the layout.\n     #[derive(Debug, Hash, Eq, PartialEq, Clone, Copy)]"}, {"sha": "ed9309b015d647e5df5e8defc81ac14c55538d6b", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -365,6 +365,17 @@ pub(crate) mod rustc {\n                         }\n                     }))\n                 }\n+\n+                ty::Ref(lifetime, ty, mutability) => {\n+                    let align = layout_of(tcx, *ty)?.align();\n+                    Ok(Tree::Ref(Ref {\n+                        lifetime: *lifetime,\n+                        ty: *ty,\n+                        mutability: *mutability,\n+                        align,\n+                    }))\n+                }\n+\n                 _ => Err(Err::Unspecified),\n             }\n         }"}, {"sha": "c4a99d9eb89a25aafee16791b6dedbf918b337d6", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -8,7 +8,7 @@ extern crate tracing;\n \n pub(crate) use rustc_data_structures::fx::{FxIndexMap as Map, FxIndexSet as Set};\n \n-pub(crate) mod layout;\n+pub mod layout;\n pub(crate) mod maybe_transmutable;\n \n #[derive(Default)]\n@@ -21,10 +21,7 @@ pub struct Assume {\n \n /// The type encodes answers to the question: \"Are these types transmutable?\"\n #[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n-pub enum Answer<R>\n-where\n-    R: layout::Ref,\n-{\n+pub enum Answer<R> {\n     /// `Src` is transmutable into `Dst`.\n     Yes,\n \n@@ -54,6 +51,10 @@ pub enum Reason {\n     DstIsPrivate,\n     /// `Dst` is larger than `Src`, and the excess bytes were not exclusively uninitialized.\n     DstIsTooBig,\n+    /// Src should have a stricter alignment than Dst, but it does not.\n+    DstHasStricterAlignment,\n+    /// Can't go from shared pointer to unique pointer\n+    DstIsMoreUnique,\n }\n \n #[cfg(feature = \"rustc\")]"}, {"sha": "d1077488c79de32c2e2505c8a5fffb23bf6c071f", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "modified", "additions": 136, "deletions": 34, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -1,13 +1,13 @@\n-use crate::Map;\n-use crate::{Answer, Reason};\n-\n+pub(crate) mod query_context;\n #[cfg(test)]\n mod tests;\n \n-mod query_context;\n-use query_context::QueryContext;\n+use crate::{\n+    layout::{self, dfa, Byte, Dfa, Nfa, Ref, Tree, Uninhabited},\n+    maybe_transmutable::query_context::QueryContext,\n+    Answer, Map, Reason,\n+};\n \n-use crate::layout::{self, dfa, Byte, Dfa, Nfa, Tree, Uninhabited};\n pub(crate) struct MaybeTransmutableQuery<L, C>\n where\n     C: QueryContext,\n@@ -53,6 +53,7 @@ where\n     }\n }\n \n+// FIXME: Nix this cfg, so we can write unit tests independently of rustc\n #[cfg(feature = \"rustc\")]\n mod rustc {\n     use super::*;\n@@ -77,12 +78,11 @@ mod rustc {\n                 match (src, dst) {\n                     // Answer `Yes` here, because 'unknown layout' and type errors will already\n                     // be reported by rustc. No need to spam the user with more errors.\n-                    (Err(Err::TypeError(_)), _) => Err(Answer::Yes),\n-                    (_, Err(Err::TypeError(_))) => Err(Answer::Yes),\n-                    (Err(Err::Unknown), _) => Err(Answer::Yes),\n-                    (_, Err(Err::Unknown)) => Err(Answer::Yes),\n-                    (Err(Err::Unspecified), _) => Err(Answer::No(Reason::SrcIsUnspecified)),\n-                    (_, Err(Err::Unspecified)) => Err(Answer::No(Reason::DstIsUnspecified)),\n+                    (Err(Err::TypeError(_)), _) | (_, Err(Err::TypeError(_))) => Err(Answer::Yes),\n+                    (Err(Err::Unknown), _) | (_, Err(Err::Unknown)) => Err(Answer::Yes),\n+                    (Err(Err::Unspecified), _) | (_, Err(Err::Unspecified)) => {\n+                        Err(Answer::No(Reason::SrcIsUnspecified))\n+                    }\n                     (Ok(src), Ok(dst)) => Ok((src, dst)),\n                 }\n             });\n@@ -214,34 +214,99 @@ where\n                     Answer::No(Reason::DstIsTooBig)\n                 }\n             } else {\n-                let src_quantification = if self.assume.validity {\n+                let src_quantifier = if self.assume.validity {\n                     // if the compiler may assume that the programmer is doing additional validity checks,\n                     // (e.g.: that `src != 3u8` when the destination type is `bool`)\n                     // then there must exist at least one transition out of `src_state` such that the transmute is viable...\n-                    there_exists\n+                    Quantifier::ThereExists\n                 } else {\n                     // if the compiler cannot assume that the programmer is doing additional validity checks,\n                     // then for all transitions out of `src_state`, such that the transmute is viable...\n-                    // then there must exist at least one transition out of `src_state` such that the transmute is viable...\n-                    for_all\n+                    // then there must exist at least one transition out of `dst_state` such that the transmute is viable...\n+                    Quantifier::ForAll\n                 };\n \n-                src_quantification(\n-                    self.src.bytes_from(src_state).unwrap_or(&Map::default()),\n-                    |(&src_validity, &src_state_prime)| {\n-                        if let Some(dst_state_prime) = self.dst.byte_from(dst_state, src_validity) {\n-                            self.answer_memo(cache, src_state_prime, dst_state_prime)\n-                        } else if let Some(dst_state_prime) =\n-                            self.dst.byte_from(dst_state, Byte::Uninit)\n-                        {\n-                            self.answer_memo(cache, src_state_prime, dst_state_prime)\n-                        } else {\n-                            Answer::No(Reason::DstIsBitIncompatible)\n-                        }\n-                    },\n-                )\n+                let bytes_answer = src_quantifier.apply(\n+                    // for each of the byte transitions out of the `src_state`...\n+                    self.src.bytes_from(src_state).unwrap_or(&Map::default()).into_iter().map(\n+                        |(&src_validity, &src_state_prime)| {\n+                            // ...try to find a matching transition out of `dst_state`.\n+                            if let Some(dst_state_prime) =\n+                                self.dst.byte_from(dst_state, src_validity)\n+                            {\n+                                self.answer_memo(cache, src_state_prime, dst_state_prime)\n+                            } else if let Some(dst_state_prime) =\n+                                // otherwise, see if `dst_state` has any outgoing `Uninit` transitions\n+                                // (any init byte is a valid uninit byte)\n+                                self.dst.byte_from(dst_state, Byte::Uninit)\n+                            {\n+                                self.answer_memo(cache, src_state_prime, dst_state_prime)\n+                            } else {\n+                                // otherwise, we've exhausted our options.\n+                                // the DFAs, from this point onwards, are bit-incompatible.\n+                                Answer::No(Reason::DstIsBitIncompatible)\n+                            }\n+                        },\n+                    ),\n+                );\n+\n+                // The below early returns reflect how this code would behave:\n+                //   if self.assume.validity {\n+                //       bytes_answer.or(refs_answer)\n+                //   } else {\n+                //       bytes_answer.and(refs_answer)\n+                //   }\n+                // ...if `refs_answer` was computed lazily. The below early\n+                // returns can be deleted without impacting the correctness of\n+                // the algoritm; only its performance.\n+                match bytes_answer {\n+                    Answer::No(..) if !self.assume.validity => return bytes_answer,\n+                    Answer::Yes if self.assume.validity => return bytes_answer,\n+                    _ => {}\n+                };\n+\n+                let refs_answer = src_quantifier.apply(\n+                    // for each reference transition out of `src_state`...\n+                    self.src.refs_from(src_state).unwrap_or(&Map::default()).into_iter().map(\n+                        |(&src_ref, &src_state_prime)| {\n+                            // ...there exists a reference transition out of `dst_state`...\n+                            Quantifier::ThereExists.apply(\n+                                self.dst\n+                                    .refs_from(dst_state)\n+                                    .unwrap_or(&Map::default())\n+                                    .into_iter()\n+                                    .map(|(&dst_ref, &dst_state_prime)| {\n+                                        if !src_ref.is_mutable() && dst_ref.is_mutable() {\n+                                            Answer::No(Reason::DstIsMoreUnique)\n+                                        } else if !self.assume.alignment\n+                                            && src_ref.min_align() < dst_ref.min_align()\n+                                        {\n+                                            Answer::No(Reason::DstHasStricterAlignment)\n+                                        } else {\n+                                            // ...such that `src` is transmutable into `dst`, if\n+                                            // `src_ref` is transmutability into `dst_ref`.\n+                                            Answer::IfTransmutable { src: src_ref, dst: dst_ref }\n+                                                .and(self.answer_memo(\n+                                                    cache,\n+                                                    src_state_prime,\n+                                                    dst_state_prime,\n+                                                ))\n+                                        }\n+                                    }),\n+                            )\n+                        },\n+                    ),\n+                );\n+\n+                if self.assume.validity {\n+                    bytes_answer.or(refs_answer)\n+                } else {\n+                    bytes_answer.and(refs_answer)\n+                }\n             };\n-            cache.insert((src_state, dst_state), answer.clone());\n+            if let Some(..) = cache.insert((src_state, dst_state), answer.clone()) {\n+                panic!(\"failed to correctly cache transmutability\")\n+            }\n             answer\n         }\n     }\n@@ -253,25 +318,29 @@ where\n {\n     pub(crate) fn and(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Self::No(reason), _) | (_, Self::No(reason)) => Self::No(reason),\n-            (Self::Yes, Self::Yes) => Self::Yes,\n+            (_, Self::No(reason)) | (Self::No(reason), _) => Self::No(reason),\n+\n+            (Self::Yes, other) | (other, Self::Yes) => other,\n+\n             (Self::IfAll(mut lhs), Self::IfAll(ref mut rhs)) => {\n                 lhs.append(rhs);\n                 Self::IfAll(lhs)\n             }\n+\n             (constraint, Self::IfAll(mut constraints))\n             | (Self::IfAll(mut constraints), constraint) => {\n                 constraints.push(constraint);\n                 Self::IfAll(constraints)\n             }\n+\n             (lhs, rhs) => Self::IfAll(vec![lhs, rhs]),\n         }\n     }\n \n     pub(crate) fn or(self, rhs: Self) -> Self {\n         match (self, rhs) {\n             (Self::Yes, _) | (_, Self::Yes) => Self::Yes,\n-            (Self::No(lhr), Self::No(rhr)) => Self::No(lhr),\n+            (other, Self::No(reason)) | (Self::No(reason), other) => other,\n             (Self::IfAny(mut lhs), Self::IfAny(ref mut rhs)) => {\n                 lhs.append(rhs);\n                 Self::IfAny(lhs)\n@@ -319,3 +388,36 @@ where\n     );\n     result\n }\n+\n+pub enum Quantifier {\n+    ThereExists,\n+    ForAll,\n+}\n+\n+impl Quantifier {\n+    pub fn apply<R, I>(&self, iter: I) -> Answer<R>\n+    where\n+        R: layout::Ref,\n+        I: IntoIterator<Item = Answer<R>>,\n+    {\n+        use std::ops::ControlFlow::{Break, Continue};\n+\n+        let (init, try_fold_f): (_, fn(_, _) -> _) = match self {\n+            Self::ThereExists => {\n+                (Answer::No(Reason::DstIsBitIncompatible), |accum: Answer<R>, next| {\n+                    match accum.or(next) {\n+                        Answer::Yes => Break(Answer::Yes),\n+                        maybe => Continue(maybe),\n+                    }\n+                })\n+            }\n+            Self::ForAll => (Answer::Yes, |accum: Answer<R>, next| match accum.and(next) {\n+                Answer::No(reason) => Break(Answer::No(reason)),\n+                maybe => Continue(maybe),\n+            }),\n+        };\n+\n+        let (Continue(result) | Break(result)) = iter.into_iter().try_fold(init, try_fold_f);\n+        result\n+    }\n+}"}, {"sha": "d0c30e715d56b63b664f3f8117c37f8c52af1938", "filename": "library/core/src/mem/transmutability.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -5,6 +5,7 @@\n /// notwithstanding whatever safety checks you have asked the compiler to [`Assume`] are satisfied.\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n #[lang = \"transmute_trait\"]\n+#[rustc_coinductive]\n pub unsafe trait BikeshedIntrinsicFrom<Src, Context, const ASSUME: Assume = { Assume::NOTHING }>\n where\n     Src: ?Sized,"}, {"sha": "4a0cd17640801c13ec125b53e547c03017b595c8", "filename": "tests/ui/transmutability/arrays/should_require_well_defined_layout.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -23,7 +23,7 @@ error[E0277]: `u128` cannot be safely transmuted into `[String; 0]` in the defin\n   --> $DIR/should_require_well_defined_layout.rs:27:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `[String; 0]` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -65,7 +65,7 @@ error[E0277]: `u128` cannot be safely transmuted into `[String; 1]` in the defin\n   --> $DIR/should_require_well_defined_layout.rs:33:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `[String; 1]` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -107,7 +107,7 @@ error[E0277]: `u128` cannot be safely transmuted into `[String; 2]` in the defin\n   --> $DIR/should_require_well_defined_layout.rs:39:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `[String; 2]` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14"}, {"sha": "77d2dc4f50ca390ebd798d052c33ca507ae638b8", "filename": "tests/ui/transmutability/enums/repr/primitive_reprs_should_have_correct_length.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -24,7 +24,7 @@ error[E0277]: `V0i8` cannot be safely transmuted into `u16` in the defining scop\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:50:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0i8` is smaller than the size of `u16`\n+   |                                            ^^^^^^ At least one value of `V0i8` isn't a bit-valid value of `u16`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -68,7 +68,7 @@ error[E0277]: `V0u8` cannot be safely transmuted into `u16` in the defining scop\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:58:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0u8` is smaller than the size of `u16`\n+   |                                            ^^^^^^ At least one value of `V0u8` isn't a bit-valid value of `u16`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -112,7 +112,7 @@ error[E0277]: `V0i16` cannot be safely transmuted into `u32` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:74:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0i16` is smaller than the size of `u32`\n+   |                                            ^^^^^^ At least one value of `V0i16` isn't a bit-valid value of `u32`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -156,7 +156,7 @@ error[E0277]: `V0u16` cannot be safely transmuted into `u32` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:82:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0u16` is smaller than the size of `u32`\n+   |                                            ^^^^^^ At least one value of `V0u16` isn't a bit-valid value of `u32`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -200,7 +200,7 @@ error[E0277]: `V0i32` cannot be safely transmuted into `u64` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:98:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0i32` is smaller than the size of `u64`\n+   |                                            ^^^^^^ At least one value of `V0i32` isn't a bit-valid value of `u64`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -244,7 +244,7 @@ error[E0277]: `V0u32` cannot be safely transmuted into `u64` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:106:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0u32` is smaller than the size of `u64`\n+   |                                            ^^^^^^ At least one value of `V0u32` isn't a bit-valid value of `u64`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -288,7 +288,7 @@ error[E0277]: `V0i64` cannot be safely transmuted into `u128` in the defining sc\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:122:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0i64` is smaller than the size of `u128`\n+   |                                            ^^^^^^ At least one value of `V0i64` isn't a bit-valid value of `u128`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -332,7 +332,7 @@ error[E0277]: `V0u64` cannot be safely transmuted into `u128` in the defining sc\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:130:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0u64` is smaller than the size of `u128`\n+   |                                            ^^^^^^ At least one value of `V0u64` isn't a bit-valid value of `u128`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -376,7 +376,7 @@ error[E0277]: `V0isize` cannot be safely transmuted into `[usize; 2]` in the def\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:146:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0isize` is smaller than the size of `[usize; 2]`\n+   |                                            ^^^^^^ At least one value of `V0isize` isn't a bit-valid value of `[usize; 2]`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -420,7 +420,7 @@ error[E0277]: `V0usize` cannot be safely transmuted into `[usize; 2]` in the def\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:154:44\n    |\n LL |         assert::is_transmutable::<Current, Larger, Context>();\n-   |                                            ^^^^^^ The size of `V0usize` is smaller than the size of `[usize; 2]`\n+   |                                            ^^^^^^ At least one value of `V0usize` isn't a bit-valid value of `[usize; 2]`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14"}, {"sha": "6508d535b05c35509557c439cf99ee98313059c4", "filename": "tests/ui/transmutability/enums/repr/should_require_well_defined_layout.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -24,7 +24,7 @@ error[E0277]: `u128` cannot be safely transmuted into `void::repr_rust` in the d\n   --> $DIR/should_require_well_defined_layout.rs:29:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `void::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:14:14\n@@ -68,7 +68,7 @@ error[E0277]: `u128` cannot be safely transmuted into `singleton::repr_rust` in\n   --> $DIR/should_require_well_defined_layout.rs:35:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `singleton::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:14:14\n@@ -112,7 +112,7 @@ error[E0277]: `u128` cannot be safely transmuted into `duplex::repr_rust` in the\n   --> $DIR/should_require_well_defined_layout.rs:41:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `duplex::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:14:14"}, {"sha": "c82a79680225d78d98239a806baf00173b0ba757", "filename": "tests/ui/transmutability/enums/should_pad_variants.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `Src` cannot be safely transmuted into `Dst` in the defining scope\n   --> $DIR/should_pad_variants.rs:44:36\n    |\n LL |     assert::is_transmutable::<Src, Dst, Context>();\n-   |                                    ^^^ The size of `Src` is smaller than the size of `Dst`\n+   |                                    ^^^ At least one value of `Src` isn't a bit-valid value of `Dst`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/should_pad_variants.rs:13:14"}, {"sha": "918147a086211977b0f1cb4d80d55ce3df63a11e", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-compatible.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,27 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(bool, &'static A);\n+    #[repr(C)] struct B(u8, &'static B);\n+    // FIXME(bryangarza): Make 2 variants of this test, depending on mutability.\n+    // Right now, we are being strict by default and checking A->B and B->A both.\n+    assert::is_maybe_transmutable::<&'static A, &'static B>(); //~ ERROR `B` cannot be safely transmuted into `A`\n+}"}, {"sha": "fac0e4f032e00bdfec63687124c52d2babb3c66a", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-compatible.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: `B` cannot be safely transmuted into `A` in the defining scope of `assert::Context`\n+  --> $DIR/recursive-wrapper-types-bit-compatible.rs:26:49\n+   |\n+LL |     assert::is_maybe_transmutable::<&'static A, &'static B>();\n+   |                                                 ^^^^^^^^^^ At least one value of `B` isn't a bit-valid value of `A`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/recursive-wrapper-types-bit-compatible.rs:10:14\n+   |\n+LL |       pub fn is_maybe_transmutable<Src, Dst>()\n+   |              --------------------- required by a bound in this function\n+LL |       where\n+LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n+   |  ______________^\n+LL | |             Assume {\n+LL | |                 alignment: true,\n+LL | |                 lifetimes: false,\n+...  |\n+LL | |             }\n+LL | |         }>\n+   | |__________^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6dcb7df9feb1c2c468db34594d4c5032062baf66", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-incompatible.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,25 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(bool, &'static A);\n+    #[repr(C)] struct B(u8, &'static B);\n+    assert::is_maybe_transmutable::<&'static B, &'static A>(); //~ ERROR `B` cannot be safely transmuted into `A`\n+}"}, {"sha": "ecfe4865962f72d84a1b9fbd1134c7b07a3adced", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-incompatible.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: `B` cannot be safely transmuted into `A` in the defining scope of `assert::Context`\n+  --> $DIR/recursive-wrapper-types-bit-incompatible.rs:24:49\n+   |\n+LL |     assert::is_maybe_transmutable::<&'static B, &'static A>();\n+   |                                                 ^^^^^^^^^^ At least one value of `B` isn't a bit-valid value of `A`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/recursive-wrapper-types-bit-incompatible.rs:10:14\n+   |\n+LL |       pub fn is_maybe_transmutable<Src, Dst>()\n+   |              --------------------- required by a bound in this function\n+LL |       where\n+LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n+   |  ______________^\n+LL | |             Assume {\n+LL | |                 alignment: true,\n+LL | |                 lifetimes: false,\n+...  |\n+LL | |             }\n+LL | |         }>\n+   | |__________^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "090c1fea6dbdf64d03b12d5374038d706018240f", "filename": "tests/ui/transmutability/references/recursive-wrapper-types.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(&'static B);\n+    #[repr(C)] struct B(&'static A);\n+    assert::is_maybe_transmutable::<&'static A, &'static B>();\n+    assert::is_maybe_transmutable::<&'static B, &'static A>();\n+}"}, {"sha": "b7dd638b952ad2499f1f709e37190f01b61ae67e", "filename": "tests/ui/transmutability/references/u8-to-unit.rs", "status": "renamed", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -1,11 +1,5 @@\n-// revisions: current next\n-//[next] compile-flags: -Ztrait-solver=next\n-\n-//! Transmutations involving references are not yet supported.\n-\n-#![crate_type = \"lib\"]\n+// check-fail\n #![feature(transmutability)]\n-#![allow(dead_code, incomplete_features, non_camel_case_types)]\n \n mod assert {\n     use std::mem::{Assume, BikeshedIntrinsicFrom};\n@@ -24,7 +18,7 @@ mod assert {\n     {}\n }\n \n-fn not_yet_implemented() {\n+fn main() {\n     #[repr(C)] struct Unit;\n-    assert::is_maybe_transmutable::<&'static Unit, &'static Unit>(); //~ ERROR cannot be safely transmuted\n+    assert::is_maybe_transmutable::<&'static u8, &'static Unit>(); //~ ERROR `Unit` cannot be safely transmuted into `u8`\n }", "previous_filename": "tests/ui/transmutability/references.rs"}, {"sha": "81b0b57f0cf4bd158841133d0a89edab52488dad", "filename": "tests/ui/transmutability/references/u8-to-unit.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -1,11 +1,11 @@\n-error[E0277]: `&Unit` cannot be safely transmuted into `&Unit` in the defining scope of `assert::Context`\n-  --> $DIR/references.rs:29:52\n+error[E0277]: `Unit` cannot be safely transmuted into `u8` in the defining scope of `assert::Context`\n+  --> $DIR/u8-to-unit.rs:23:50\n    |\n-LL |     assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n-   |                                                    ^^^^^^^^^^^^^ `&Unit` does not have a well-specified layout\n+LL |     assert::is_maybe_transmutable::<&'static u8, &'static Unit>();\n+   |                                                  ^^^^^^^^^^^^^ The size of `Unit` is smaller than the size of `u8`\n    |\n note: required by a bound in `is_maybe_transmutable`\n-  --> $DIR/references.rs:16:14\n+  --> $DIR/u8-to-unit.rs:10:14\n    |\n LL |       pub fn is_maybe_transmutable<Src, Dst>()\n    |              --------------------- required by a bound in this function", "previous_filename": "tests/ui/transmutability/references.next.stderr"}, {"sha": "04a7e16d7cccc2b74bdb62b70ec842853d53c0c3", "filename": "tests/ui/transmutability/references/unit-to-itself.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-itself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-itself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-itself.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct Unit;\n+    assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n+}"}, {"sha": "73e1db3d2d58b2057d1e271b6382c754f751adbe", "filename": "tests/ui/transmutability/references/unit-to-u8.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.rs?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -0,0 +1,24 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: true,\n+                safety: true,\n+                validity: true,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct Unit;\n+    assert::is_maybe_transmutable::<&'static Unit, &'static u8>(); //~ ERROR `Unit` cannot be safely transmuted into `u8`\n+}"}, {"sha": "f2b72357f792b7ced043a4eb7a4ec0bf7d83df50", "filename": "tests/ui/transmutability/references/unit-to-u8.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -1,11 +1,11 @@\n-error[E0277]: `&Unit` cannot be safely transmuted into `&Unit` in the defining scope of `assert::Context`\n-  --> $DIR/references.rs:29:52\n+error[E0277]: `Unit` cannot be safely transmuted into `u8` in the defining scope of `assert::Context`\n+  --> $DIR/unit-to-u8.rs:23:52\n    |\n-LL |     assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n-   |                                                    ^^^^^^^^^^^^^ `&Unit` does not have a well-specified layout\n+LL |     assert::is_maybe_transmutable::<&'static Unit, &'static u8>();\n+   |                                                    ^^^^^^^^^^^ The size of `Unit` is smaller than the size of `u8`\n    |\n note: required by a bound in `is_maybe_transmutable`\n-  --> $DIR/references.rs:16:14\n+  --> $DIR/unit-to-u8.rs:10:14\n    |\n LL |       pub fn is_maybe_transmutable<Src, Dst>()\n    |              --------------------- required by a bound in this function", "previous_filename": "tests/ui/transmutability/references.current.stderr"}, {"sha": "307d0dfe50d2258a990ad1daf2f9283e7ea0a568", "filename": "tests/ui/transmutability/region-infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fregion-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fregion-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fregion-infer.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `()` cannot be safely transmuted into `W<'_>` in the defining scop\n   --> $DIR/region-infer.rs:20:5\n    |\n LL |     test();\n-   |     ^^^^ `W<'_>` does not have a well-specified layout\n+   |     ^^^^ The size of `()` is smaller than the size of `W<'_>`\n    |\n note: required by a bound in `test`\n   --> $DIR/region-infer.rs:11:12"}, {"sha": "7f26bc498176cef3aecb7698c157b64f7fbff428", "filename": "tests/ui/transmutability/structs/repr/should_require_well_defined_layout.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -24,7 +24,7 @@ error[E0277]: `u128` cannot be safely transmuted into `should_reject_repr_rust::\n   --> $DIR/should_require_well_defined_layout.rs:29:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `should_reject_repr_rust::unit::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -68,7 +68,7 @@ error[E0277]: `u128` cannot be safely transmuted into `should_reject_repr_rust::\n   --> $DIR/should_require_well_defined_layout.rs:35:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `should_reject_repr_rust::tuple::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -112,7 +112,7 @@ error[E0277]: `u128` cannot be safely transmuted into `should_reject_repr_rust::\n   --> $DIR/should_require_well_defined_layout.rs:41:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `should_reject_repr_rust::braces::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -156,7 +156,7 @@ error[E0277]: `u128` cannot be safely transmuted into `aligned::repr_rust` in th\n   --> $DIR/should_require_well_defined_layout.rs:47:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `aligned::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -200,7 +200,7 @@ error[E0277]: `u128` cannot be safely transmuted into `packed::repr_rust` in the\n   --> $DIR/should_require_well_defined_layout.rs:53:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                               ^^^^^^^^^ `packed::repr_rust` does not have a well-specified layout\n+   |                                               ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14\n@@ -244,7 +244,7 @@ error[E0277]: `u128` cannot be safely transmuted into `nested::repr_c` in the de\n   --> $DIR/should_require_well_defined_layout.rs:60:47\n    |\n LL |         assert::is_maybe_transmutable::<u128, repr_c>();\n-   |                                               ^^^^^^ `nested::repr_c` does not have a well-specified layout\n+   |                                               ^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14"}, {"sha": "305ecc71733d3d2b86196c9b4a1fc59e5b0c0ef3", "filename": "tests/ui/transmutability/unions/repr/should_require_well_defined_layout.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -24,7 +24,7 @@ error[E0277]: `u128` cannot be safely transmuted into `should_reject_repr_rust::\n   --> $DIR/should_require_well_defined_layout.rs:31:43\n    |\n LL |     assert::is_maybe_transmutable::<u128, repr_rust>();\n-   |                                           ^^^^^^^^^ `should_reject_repr_rust::repr_rust` does not have a well-specified layout\n+   |                                           ^^^^^^^^^ `u128` does not have a well-specified layout\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/should_require_well_defined_layout.rs:13:14"}, {"sha": "c82a79680225d78d98239a806baf00173b0ba757", "filename": "tests/ui/transmutability/unions/should_pad_variants.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `Src` cannot be safely transmuted into `Dst` in the defining scope\n   --> $DIR/should_pad_variants.rs:44:36\n    |\n LL |     assert::is_transmutable::<Src, Dst, Context>();\n-   |                                    ^^^ The size of `Src` is smaller than the size of `Dst`\n+   |                                    ^^^ At least one value of `Src` isn't a bit-valid value of `Dst`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/should_pad_variants.rs:13:14"}, {"sha": "2739fd16645abccd8abdfa239d30311f24039358", "filename": "tests/ui/transmute/transmute-padding-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmute%2Ftransmute-padding-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f1cec8d8472c3ffacedd4783c64182a407c72df/tests%2Fui%2Ftransmute%2Ftransmute-padding-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute%2Ftransmute-padding-ice.stderr?ref=8f1cec8d8472c3ffacedd4783c64182a407c72df", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `B` cannot be safely transmuted into `A` in the defining scope of\n   --> $DIR/transmute-padding-ice.rs:27:40\n    |\n LL |     assert::is_maybe_transmutable::<B, A>();\n-   |                                        ^ The size of `B` is smaller than the size of `A`\n+   |                                        ^ At least one value of `B` isn't a bit-valid value of `A`\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/transmute-padding-ice.rs:11:14"}]}