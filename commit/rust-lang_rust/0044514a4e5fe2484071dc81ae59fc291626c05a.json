{"sha": "0044514a4e5fe2484071dc81ae59fc291626c05a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNDQ1MTRhNGU1ZmUyNDg0MDcxZGM4MWFlNTlmYzI5MTYyNmMwNWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-25T17:02:53Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-25T17:02:53Z"}, "message": "remember where fields resolve to during inference", "tree": {"sha": "fed92822ffe01e0a0e22985df998ddda0d4d4c85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed92822ffe01e0a0e22985df998ddda0d4d4c85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0044514a4e5fe2484071dc81ae59fc291626c05a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0044514a4e5fe2484071dc81ae59fc291626c05a", "html_url": "https://github.com/rust-lang/rust/commit/0044514a4e5fe2484071dc81ae59fc291626c05a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0044514a4e5fe2484071dc81ae59fc291626c05a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc5ecf446991c65359cf49d52098fcec5f1a1f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5ecf446991c65359cf49d52098fcec5f1a1f68", "html_url": "https://github.com/rust-lang/rust/commit/dc5ecf446991c65359cf49d52098fcec5f1a1f68"}], "stats": {"total": 28, "additions": 19, "deletions": 9}, "files": [{"sha": "97a876da8e8b9bf13a9b2285ffb35ea1eff45a15", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0044514a4e5fe2484071dc81ae59fc291626c05a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0044514a4e5fe2484071dc81ae59fc291626c05a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=0044514a4e5fe2484071dc81ae59fc291626c05a", "patch": "@@ -732,8 +732,10 @@ pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n-    /// For each method call expr, record the function it resolved to.\n+    /// For each method call expr, records the function it resolves to.\n     method_resolutions: FxHashMap<ExprId, Function>,\n+    /// For each field access expr, records the field it resolves to.\n+    field_resolutions: FxHashMap<ExprId, StructField>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -770,6 +772,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n+    field_resolutions: FxHashMap<ExprId, StructField>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -861,6 +864,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     ) -> Self {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n+            field_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -886,6 +890,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n         InferenceResult {\n             method_resolutions: mem::replace(&mut self.method_resolutions, Default::default()),\n+            field_resolutions: mem::replace(&mut self.field_resolutions, Default::default()),\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -899,6 +904,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.method_resolutions.insert(expr, func);\n     }\n \n+    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n+        self.field_resolutions.insert(expr, field);\n+    }\n+\n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n         self.type_of_pat.insert(pat, ty);\n     }\n@@ -1251,9 +1260,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n-    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+    fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        let ty = match &body[expr] {\n+        let ty = match &body[tgt_expr] {\n             Expr::Missing => Ty::Unknown,\n             Expr::If {\n                 condition,\n@@ -1344,7 +1353,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n                     Some(func) => {\n-                        self.write_method_resolution(expr, func);\n+                        self.write_method_resolution(tgt_expr, func);\n                         self.db.type_for_def(func.into())\n                     }\n                     None => Ty::Unknown,\n@@ -1389,7 +1398,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 expected.ty\n             }\n-            Expr::Path(p) => self.infer_path_expr(expr, p).unwrap_or(Ty::Unknown),\n+            Expr::Path(p) => self.infer_path_expr(tgt_expr, p).unwrap_or(Ty::Unknown),\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n@@ -1436,9 +1445,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             def_id: AdtDef::Struct(s),\n                             ref substs,\n                             ..\n-                        } => s\n-                            .field(self.db, name)\n-                            .map(|field| field.ty(self.db).subst(substs)),\n+                        } => s.field(self.db, name).map(|field| {\n+                            self.write_field_resolution(tgt_expr, field);\n+                            field.ty(self.db).subst(substs)\n+                        }),\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);\n@@ -1545,7 +1555,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(ty);\n-        self.write_expr_ty(expr, ty.clone());\n+        self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }\n "}]}