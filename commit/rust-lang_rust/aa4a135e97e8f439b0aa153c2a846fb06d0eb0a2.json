{"sha": "aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNGExMzVlOTdlOGY0MzliMGFhMTUzYzJhODQ2ZmIwNmQwZWIwYTI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-25T17:04:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-25T17:04:36Z"}, "message": "Merge branch 'master' of github.com:Manishearth/rust-clippy", "tree": {"sha": "89d34803f1e15369f5202721b47855b6d4634fd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89d34803f1e15369f5202721b47855b6d4634fd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "html_url": "https://github.com/rust-lang/rust/commit/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af1340e4fe55affdb0a3ad89788ff1e05d37d5fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/af1340e4fe55affdb0a3ad89788ff1e05d37d5fd", "html_url": "https://github.com/rust-lang/rust/commit/af1340e4fe55affdb0a3ad89788ff1e05d37d5fd"}, {"sha": "53d72faca4222dbe03523cff74bf86318a206342", "url": "https://api.github.com/repos/rust-lang/rust/commits/53d72faca4222dbe03523cff74bf86318a206342", "html_url": "https://github.com/rust-lang/rust/commit/53d72faca4222dbe03523cff74bf86318a206342"}], "stats": {"total": 1186, "additions": 806, "deletions": 380}, "files": [{"sha": "be7154c8c629e930143ece32a1eaeca8130daaa7", "filename": "README.md", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -4,56 +4,55 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-Lints included in this crate:\n-\n-name                 | default | meaning\n----------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n-approx_constant      | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n-bad_bit_mask         | deny    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n-box_vec              | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n-cmp_nan              | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n-cmp_owned            | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n-collapsible_if       | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n-eq_op                | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n-explicit_iter_loop   | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n-float_cmp            | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n-identity_op          | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n-ineffective_bit_mask | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n-inline_always        | warn    | `#[inline(always)]` is a bad idea in most cases\n-iter_next_loop       | warn    | for-looping over `_.next()` which is probably not intended\n-len_without_is_empty | warn    | traits and impls that have `.len()` but not `.is_empty()`\n-len_zero             | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n-let_and_return       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a function\n-let_unit_value       | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n-linkedlist           | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n-modulo_one           | warn    | taking a number modulo 1, which always returns 0\n-mut_mut              | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n-needless_bool        | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n-needless_lifetimes   | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n-needless_range_loop  | warn    | for-looping over a range of indices where an iterator over items would do\n-needless_return      | warn    | using a return statement like `return expr;` where an expression would suffice\n-non_ascii_literal    | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n-option_unwrap_used   | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n-precedence           | warn    | expressions where precedence may trip up the unwary reader of the source; suggests adding parentheses, e.g. `x << 2 + y` will be parsed as `x << (2 + y)`\n-ptr_arg              | allow   | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n-range_step_by_zero   | warn    | using Range::step_by(0), which produces an infinite iterator\n-redundant_closure    | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n-result_unwrap_used   | allow   | using `Result.unwrap()`, which might be better handled\n-single_match         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n-str_to_string        | warn    | using `to_string()` on a str, which should be `to_owned()`\n-string_add           | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n-string_add_assign    | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n-string_to_string     | warn    | calling `String.to_string()` which is a no-op\n-toplevel_ref_arg     | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n-unit_cmp             | warn    | comparing unit values (which is always `true` or `false`, respectively)\n-zero_width_space     | deny    | using a zero-width space in a string literal, which is confusing\n-\n-To use, add the following lines to your Cargo.toml:\n-\n-```\n-[dependencies]\n-clippy = \"*\"\n-```\n+There are 45 lints included in this crate:\n+\n+name                     | default | meaning\n+-------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n+approx_constant          | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n+bad_bit_mask             | deny    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n+box_vec                  | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n+cast_possible_truncation | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n+cast_possible_wrap       | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n+cast_precision_loss      | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n+cast_sign_loss           | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n+cmp_nan                  | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n+cmp_owned                | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n+collapsible_if           | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n+eq_op                    | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+explicit_iter_loop       | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n+float_cmp                | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n+identity_op              | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n+ineffective_bit_mask     | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n+inline_always            | warn    | `#[inline(always)]` is a bad idea in most cases\n+iter_next_loop           | warn    | for-looping over `_.next()` which is probably not intended\n+len_without_is_empty     | warn    | traits and impls that have `.len()` but not `.is_empty()`\n+len_zero                 | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n+let_and_return           | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a function\n+let_unit_value           | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n+linkedlist               | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n+match_ref_pats           | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n+modulo_one               | warn    | taking a number modulo 1, which always returns 0\n+mut_mut                  | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n+needless_bool            | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n+needless_lifetimes       | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n+needless_range_loop      | warn    | for-looping over a range of indices where an iterator over items would do\n+needless_return          | warn    | using a return statement like `return expr;` where an expression would suffice\n+non_ascii_literal        | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+option_unwrap_used       | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n+precedence               | warn    | expressions where precedence may trip up the unwary reader of the source; suggests adding parentheses, e.g. `x << 2 + y` will be parsed as `x << (2 + y)`\n+ptr_arg                  | allow   | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n+range_step_by_zero       | warn    | using Range::step_by(0), which produces an infinite iterator\n+redundant_closure        | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n+result_unwrap_used       | allow   | using `Result.unwrap()`, which might be better handled\n+single_match             | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n+str_to_string            | warn    | using `to_string()` on a str, which should be `to_owned()`\n+string_add               | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n+string_add_assign        | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n+string_to_string         | warn    | calling `String.to_string()` which is a no-op\n+toplevel_ref_arg         | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n+type_complexity          | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n+unit_cmp                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n+zero_width_space         | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!\n \n@@ -63,8 +62,8 @@ Compiler plugins are highly unstable and will only work with a nightly Rust for\n \n Add in your `Cargo.toml`:\n ```toml\n-[dependencies.clippy]\n-git = \"https://github.com/Manishearth/rust-clippy\"\n+[dependencies]\n+clippy = \"*\"\n ```\n \n Sample `main.rs`:"}, {"sha": "3e0ba4eb669f8e20941033c4c6b3558da1c2f5e6", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -37,10 +37,10 @@ impl LintPass for ApproxConstant {\n }\n \n fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n-    match &lit.node {\n-        &LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n-        &LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        &LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n+    match lit.node {\n+        LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n+        LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n+        LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n }"}, {"sha": "ad021f28a4d67ef45f43044c76ea6dab12b7ba2c", "filename": "src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -71,14 +71,14 @@ fn is_relevant_block(block: &Block) -> bool {\n             _ => ()\n         }\n     }\n-    block.expr.as_ref().map_or(false, |e| is_relevant_expr(&*e))\n+    block.expr.as_ref().map_or(false, |e| is_relevant_expr(e))\n }\n \n fn is_relevant_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(block),\n         ExprRet(Some(ref e)) | ExprParen(ref e) =>\n-            is_relevant_expr(&*e),\n+            is_relevant_expr(e),\n         ExprRet(None) | ExprBreak(_) | ExprMac(_) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {"}, {"sha": "6537fcf4c1abb77be0211a1e01cdf0b26c969491", "filename": "src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -82,9 +82,9 @@ fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n \n \n fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n-    match &bit_op.node {\n-        &ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n-        &ExprBinary(ref op, ref left, ref right) => {\n+    match bit_op.node {\n+        ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n+        ExprBinary(ref op, ref left, ref right) => {\n             if op.node != BiBitAnd && op.node != BiBitOr { return; }\n             fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n                 cx, left)).map_or((), |mask| check_bit_mask(cx, op.node,\n@@ -182,13 +182,13 @@ fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n }\n \n fn fetch_int_literal(cx: &Context, lit : &Expr) -> Option<u64> {\n-    match &lit.node {\n-        &ExprLit(ref lit_ptr) => {\n+    match lit.node {\n+        ExprLit(ref lit_ptr) => {\n             if let &LitInt(value, _) = &lit_ptr.node {\n                 Option::Some(value) //TODO: Handle sign\n             } else { Option::None }\n         },\n-        &ExprPath(_, _) => {\n+        ExprPath(_, _) => {\n             // Important to let the borrow expire before the const lookup to avoid double\n             // borrowing.\n             let def_map = cx.tcx.def_map.borrow();"}, {"sha": "e0b25b7283bf8ab8355cf8b6cf1a717eff137e25", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -48,7 +48,6 @@ fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n                 if e.span.expn_id != sp.expn_id {\n                     return;\n                 }\n-                cx.sess().note(&format!(\"{:?} -- {:?}\", e.span, sp));\n                 span_help_and_lint(cx, COLLAPSIBLE_IF, e.span,\n                     \"this if statement can be collapsed\",\n                     &format!(\"try\\nif {} && {} {}\",\n@@ -80,7 +79,7 @@ fn single_stmt_of_block(block: &Block) -> Option<&Expr> {\n         } else { None }\n     } else {\n         if block.stmts.is_empty() {\n-            if let Some(ref p) = block.expr { Some(&*p) } else { None }\n+            if let Some(ref p) = block.expr { Some(p) } else { None }\n         } else { None }\n     }\n }"}, {"sha": "1a828317fc2de35a77151d2d93ecff6418c36736", "filename": "src/consts.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -67,15 +67,16 @@ impl Constant {\n     }\n \n     /// convert this constant to a f64, if possible\n-   pub fn as_float(&self) -> Option<f64> {\n-       match *self {\n-           ConstantByte(b) => Some(b as f64),\n-           ConstantFloat(ref s, _) => s.parse().ok(),\n-           ConstantInt(i, ty) => Some(if is_negative(ty) {\n-               -(i as f64) } else { i as f64 }),\n-           _ => None\n-       }\n-   }\n+    #[allow(cast_precision_loss)]\n+    pub fn as_float(&self) -> Option<f64> {\n+        match *self {\n+            ConstantByte(b) => Some(b as f64),\n+            ConstantFloat(ref s, _) => s.parse().ok(),\n+            ConstantInt(i, ty) => Some(if is_negative(ty) {\n+                -(i as f64) } else { i as f64 }),\n+            _ => None\n+        }\n+    }\n }\n \n impl PartialEq for Constant {\n@@ -221,7 +222,7 @@ fn neg_float_str(s: String) -> String {\n     if s.starts_with('-') {\n         s[1..].to_owned()\n     } else {\n-        format!(\"-{}\", &*s)\n+        format!(\"-{}\", s)\n     }\n }\n \n@@ -298,7 +299,7 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n             ExprPath(_, _) => self.fetch_path(e),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) =>\n-                self.ifthenelse(&*cond, &*then, &*otherwise),\n+                self.ifthenelse(cond, then, otherwise),\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n             ExprVec(ref vec) => self.multi(vec).map(ConstantVec),\n             ExprTup(ref tup) => self.multi(tup).map(ConstantTuple),\n@@ -329,8 +330,13 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n+            let mut maybe_id = None;\n             if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n                 lcx.tcx.def_map.borrow().get(&e.id) {\n+                maybe_id = Some(id);\n+            }\n+            // separate if lets to avoid doubleborrowing the defmap\n+            if let Some(id) = maybe_id {\n                 if let Some(const_expr) = lookup_const_by_id(lcx.tcx, id, None) {\n                     let ret = self.expr(const_expr);\n                     if ret.is_some() {\n@@ -356,7 +362,7 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n             if b {\n                 self.block(then)\n             } else {\n-                otherwise.as_ref().and_then(|ref expr| self.expr(expr))\n+                otherwise.as_ref().and_then(|expr| self.expr(expr))\n             }\n         } else { None }\n     }"}, {"sha": "ebc6aa171006bb6157a10f6364412a5f5722cff7", "filename": "src/eq_op.rs", "status": "modified", "additions": 68, "deletions": 63, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -4,6 +4,7 @@ use syntax::ast_util as ast_util;\n use syntax::ptr::P;\n use syntax::codemap as code;\n \n+use consts::constant;\n use utils::span_lint;\n \n declare_lint! {\n@@ -22,7 +23,7 @@ impl LintPass for EqOp {\n \n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n+            if is_cmp_or_bit(op) && is_exp_equal(cx, left, right) {\n                 span_lint(cx, EQ_OP, e.span, &format!(\n                     \"equal expressions as operands to {}\",\n                         ast_util::binop_to_string(op.node)));\n@@ -31,45 +32,49 @@ impl LintPass for EqOp {\n     }\n }\n \n-pub fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n-    match (&left.node, &right.node) {\n+pub fn is_exp_equal(cx: &Context, left : &Expr, right : &Expr) -> bool {\n+    if match (&left.node, &right.node) {\n         (&ExprBinary(ref lop, ref ll, ref lr),\n                 &ExprBinary(ref rop, ref rl, ref rr)) =>\n             lop.node == rop.node &&\n-            is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n+            is_exp_equal(cx, ll, rl) && is_exp_equal(cx, lr, rr),\n         (&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) =>\n-            both(lpl, rpl, |l, r| is_exp_equal(l, r)) &&\n-                is_exp_equal(lbox, rbox),\n+            both(lpl, rpl, |l, r| is_exp_equal(cx, l, r)) &&\n+                is_exp_equal(cx, lbox, rbox),\n         (&ExprCall(ref lcallee, ref largs),\n-         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee,\n-            rcallee) && is_exps_equal(largs, rargs),\n+         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(cx, lcallee,\n+            rcallee) && is_exps_equal(cx, largs, rargs),\n         (&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) =>\n-            is_ty_equal(lty, rty) && is_exp_equal(lc, rc),\n+            is_ty_equal(cx, lty, rty) && is_exp_equal(cx, lc, rc),\n         (&ExprField(ref lfexp, ref lfident),\n                 &ExprField(ref rfexp, ref rfident)) =>\n-            lfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n+            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n         (&ExprMethodCall(ref lident, ref lcty, ref lmargs),\n                 &ExprMethodCall(ref rident, ref rcty, ref rmargs)) =>\n-            lident.node == rident.node && is_tys_equal(lcty, rcty) &&\n-                is_exps_equal(lmargs, rmargs),\n-        (&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n-        (_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n+            lident.node == rident.node && is_tys_equal(cx, lcty, rcty) &&\n+                is_exps_equal(cx, lmargs, rmargs),\n+        (&ExprParen(ref lparen), _) => is_exp_equal(cx, lparen, right),\n+        (_, &ExprParen(ref rparen)) => is_exp_equal(cx, left, rparen),\n         (&ExprPath(ref lqself, ref lsubpath),\n                 &ExprPath(ref rqself, ref rsubpath)) =>\n             both(lqself, rqself, |l, r| is_qself_equal(l, r)) &&\n                 is_path_equal(lsubpath, rsubpath),\n         (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n-            is_exps_equal(ltup, rtup),\n+            is_exps_equal(cx, ltup, rtup),\n         (&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) =>\n-            lunop == runop && is_exp_equal(l, r),\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(l, r),\n+            lunop == runop && is_exp_equal(cx, l, r),\n+        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n+        _ => false\n+    } { return true; }\n+    match (constant(cx, left), constant(cx, right)) {\n+        (Some(l), Some(r)) => l == r,\n         _ => false\n     }\n }\n \n-fn is_exps_equal(left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n-    over(left, right, |l, r| is_exp_equal(l, r))\n+fn is_exps_equal(cx: &Context, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n+    over(left, right, |l, r| is_exp_equal(cx, l, r))\n }\n \n fn is_path_equal(left : &Path, right : &Path) -> bool {\n@@ -85,29 +90,29 @@ fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n     left.ty.node == right.ty.node && left.position == right.position\n }\n \n-fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n+fn is_ty_equal(cx: &Context, left : &Ty, right : &Ty) -> bool {\n     match (&left.node, &right.node) {\n-    (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n+    (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(cx, lvec, rvec),\n     (&TyFixedLengthVec(ref lfvty, ref lfvexp),\n             &TyFixedLengthVec(ref rfvty, ref rfvexp)) =>\n-        is_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n-    (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n+        is_ty_equal(cx, lfvty, rfvty) && is_exp_equal(cx, lfvexp, rfvexp),\n+    (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(cx, lmut, rmut),\n     (&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) =>\n         both(ltime, rtime, is_lifetime_equal) &&\n-        is_mut_ty_equal(lrmut, rrmut),\n+        is_mut_ty_equal(cx, lrmut, rrmut),\n     (&TyBareFn(ref lbare), &TyBareFn(ref rbare)) =>\n-        is_bare_fn_ty_equal(lbare, rbare),\n-    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(ltup, rtup),\n+        is_bare_fn_ty_equal(cx, lbare, rbare),\n+    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(cx, ltup, rtup),\n     (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n         both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n     (&TyObjectSum(ref lsumty, ref lobounds),\n             &TyObjectSum(ref rsumty, ref robounds)) =>\n-        is_ty_equal(lsumty, rsumty) &&\n+        is_ty_equal(cx, lsumty, rsumty) &&\n         is_param_bounds_equal(lobounds, robounds),\n     (&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) =>\n         is_param_bounds_equal(ltbounds, rtbounds),\n-    (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n-    (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(lof, rof),\n+    (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(cx, lty, rty),\n+    (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(cx, lof, rof),\n     (&TyInfer, &TyInfer) => true,\n     _ => false\n     }\n@@ -136,41 +141,41 @@ fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds)\n     over(left, right, is_param_bound_equal)\n }\n \n-fn is_mut_ty_equal(left : &MutTy, right : &MutTy) -> bool {\n-    left.mutbl == right.mutbl && is_ty_equal(&left.ty, &right.ty)\n+fn is_mut_ty_equal(cx: &Context, left : &MutTy, right : &MutTy) -> bool {\n+    left.mutbl == right.mutbl && is_ty_equal(cx, &left.ty, &right.ty)\n }\n \n-fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n+fn is_bare_fn_ty_equal(cx: &Context, left : &BareFnTy, right : &BareFnTy) -> bool {\n     left.unsafety == right.unsafety && left.abi == right.abi &&\n         is_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) &&\n-            is_fndecl_equal(&left.decl, &right.decl)\n+            is_fndecl_equal(cx, &left.decl, &right.decl)\n }\n \n-fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n+fn is_fndecl_equal(cx: &Context, left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n     left.variadic == right.variadic &&\n-        is_args_equal(&left.inputs, &right.inputs) &&\n-        is_fnret_ty_equal(&left.output, &right.output)\n+        is_args_equal(cx, &left.inputs, &right.inputs) &&\n+        is_fnret_ty_equal(cx, &left.output, &right.output)\n }\n \n-fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy)\n-        -> bool {\n+fn is_fnret_ty_equal(cx: &Context, left : &FunctionRetTy,\n+        right : &FunctionRetTy) -> bool {\n     match (left, right) {\n     (&NoReturn(_), &NoReturn(_)) |\n     (&DefaultReturn(_), &DefaultReturn(_)) => true,\n-    (&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n+    (&Return(ref lty), &Return(ref rty)) => is_ty_equal(cx, lty, rty),\n     _ => false\n     }\n }\n \n-fn is_arg_equal(l: &Arg, r : &Arg) -> bool {\n-    is_ty_equal(&l.ty, &r.ty) && is_pat_equal(&l.pat, &r.pat)\n+fn is_arg_equal(cx: &Context, l: &Arg, r : &Arg) -> bool {\n+    is_ty_equal(cx, &l.ty, &r.ty) && is_pat_equal(cx, &l.pat, &r.pat)\n }\n \n-fn is_args_equal(left : &[Arg], right : &[Arg]) -> bool {\n-    over(left, right, is_arg_equal)\n+fn is_args_equal(cx: &Context, left : &[Arg], right : &[Arg]) -> bool {\n+    over(left, right, |l, r| is_arg_equal(cx, l, r))\n }\n \n-fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n+fn is_pat_equal(cx: &Context, left : &Pat, right : &Pat) -> bool {\n     match(&left.node, &right.node) {\n     (&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n     (&PatIdent(ref lmode, ref lident, Option::None),\n@@ -179,51 +184,51 @@ fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n     (&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)),\n             &PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n         lmode == rmode && is_ident_equal(&lident.node, &rident.node) &&\n-            is_pat_equal(lpat, rpat),\n+            is_pat_equal(cx, lpat, rpat),\n     (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) =>\n         is_path_equal(lpath, rpath) && both(lenum, renum, |l, r|\n-            is_pats_equal(l, r)),\n+            is_pats_equal(cx, l, r)),\n     (&PatStruct(ref lpath, ref lfieldpat, lbool),\n             &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n         lbool == rbool && is_path_equal(lpath, rpath) &&\n-            is_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n-    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup),\n+            is_spanned_fieldpats_equal(cx, lfieldpat, rfieldpat),\n+    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(cx, ltup, rtup),\n     (&PatBox(ref lboxed), &PatBox(ref rboxed)) =>\n-        is_pat_equal(lboxed, rboxed),\n+        is_pat_equal(cx, lboxed, rboxed),\n     (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) =>\n-        is_pat_equal(lpat, rpat) && lmut == rmut,\n-    (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n+        is_pat_equal(cx, lpat, rpat) && lmut == rmut,\n+    (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(cx, llit, rlit),\n     (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n-        is_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n+        is_exp_equal(cx, lfrom, rfrom) && is_exp_equal(cx, lto, rto),\n     (&PatVec(ref lfirst, Option::None, ref llast),\n             &PatVec(ref rfirst, Option::None, ref rlast)) =>\n-        is_pats_equal(lfirst, rfirst) && is_pats_equal(llast, rlast),\n+        is_pats_equal(cx, lfirst, rfirst) && is_pats_equal(cx, llast, rlast),\n     (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast),\n             &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n-        is_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) &&\n-            is_pats_equal(llast, rlast),\n+        is_pats_equal(cx, lfirst, rfirst) && is_pat_equal(cx, lpat, rpat) &&\n+            is_pats_equal(cx, llast, rlast),\n     // I don't match macros for now, the code is slow enough as is ;-)\n     _ => false\n     }\n }\n \n-fn is_spanned_fieldpats_equal(left : &[code::Spanned<FieldPat>],\n+fn is_spanned_fieldpats_equal(cx: &Context, left : &[code::Spanned<FieldPat>],\n         right : &[code::Spanned<FieldPat>]) -> bool {\n-    over(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n+    over(left, right, |l, r| is_fieldpat_equal(cx, &l.node, &r.node))\n }\n \n-fn is_fieldpat_equal(left : &FieldPat, right : &FieldPat) -> bool {\n+fn is_fieldpat_equal(cx: &Context, left : &FieldPat, right : &FieldPat) -> bool {\n     left.is_shorthand == right.is_shorthand &&\n         is_ident_equal(&left.ident, &right.ident) &&\n-        is_pat_equal(&left.pat, &right.pat)\n+        is_pat_equal(cx, &left.pat, &right.pat)\n }\n \n fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n     &left.name == &right.name && left.ctxt == right.ctxt\n }\n \n-fn is_pats_equal(left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n-    over(left, right, |l, r| is_pat_equal(l, r))\n+fn is_pats_equal(cx: &Context, left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n+    over(left, right, |l, r| is_pat_equal(cx, l, r))\n }\n \n fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef)\n@@ -241,8 +246,8 @@ fn is_lifetime_equal(left : &Lifetime, right : &Lifetime) -> bool {\n     left.name == right.name\n }\n \n-fn is_tys_equal(left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n-    over(left, right, |l, r| is_ty_equal(l, r))\n+fn is_tys_equal(cx: &Context, left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n+    over(left, right, |l, r| is_ty_equal(cx, l, r))\n }\n \n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool"}, {"sha": "481512abc6270fd8172afd542cbf82144c9c86f9", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -18,11 +18,11 @@ impl LintPass for EtaPass {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        match &expr.node {\n-            &ExprCall(_, ref args) |\n-            &ExprMethodCall(_, _, ref args) => {\n+        match expr.node {\n+            ExprCall(_, ref args) |\n+            ExprMethodCall(_, _, ref args) => {\n                 for arg in args {\n-                    check_closure(cx, &*arg)\n+                    check_closure(cx, arg)\n                 }\n             },\n             _ => (),"}, {"sha": "ca3ce51bf7cc6deb3c8fafa8b421f299b186b45a", "filename": "src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -22,10 +22,10 @@ impl LintPass for LenZero {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-        match &item.node {\n-            &ItemTrait(_, _, _, ref trait_items) =>\n+        match item.node {\n+            ItemTrait(_, _, _, ref trait_items) =>\n                 check_trait_items(cx, item, trait_items),\n-            &ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n+            ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n                 check_impl_items(cx, item, impl_items),\n             _ => ()\n         }\n@@ -100,9 +100,9 @@ fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, op: &str) {\n \n fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let &Spanned{node: LitInt(0, _), ..} = lit {\n+    if let Spanned{node: LitInt(0, _), ..} = *lit {\n         if method.node.name == \"len\" && args.len() == 1 &&\n-            has_is_empty(cx, &*args[0]) {\n+            has_is_empty(cx, &args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!(\n                     \"consider replacing the len comparison with `{}{}.is_empty()`\",\n                     op, snippet(cx, args[0].span, \"_\")))"}, {"sha": "863ba2624dddb233b188139dd89edd4ae6343f27", "filename": "src/lib.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -1,6 +1,7 @@\n #![feature(plugin_registrar, box_syntax)]\n #![feature(rustc_private, core, collections)]\n-#![feature(str_split_at)]\n+#![feature(str_split_at, num_bits_bytes)]\n+#![allow(unknown_lints)]\n \n #[macro_use]\n extern crate syntax;\n@@ -37,11 +38,11 @@ pub mod returns;\n pub mod lifetimes;\n pub mod loops;\n pub mod ranges;\n+pub mod matches;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box types::TypePass as LintPassObject);\n-    reg.register_lint_pass(box misc::MiscPass as LintPassObject);\n     reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n     reg.register_lint_pass(box misc::CmpNan as LintPassObject);\n     reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n@@ -68,6 +69,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box loops::LoopsPass as LintPassObject);\n     reg.register_lint_pass(box lifetimes::LifetimePass as LintPassObject);\n     reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n+    reg.register_lint_pass(box types::CastPass as LintPassObject);\n+    reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n+    reg.register_lint_pass(box matches::MatchPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n@@ -84,6 +88,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,\n+        matches::MATCH_REF_PATS,\n+        matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::STR_TO_STRING,\n@@ -93,7 +99,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::FLOAT_CMP,\n         misc::MODULO_ONE,\n         misc::PRECEDENCE,\n-        misc::SINGLE_MATCH,\n         misc::TOPLEVEL_REF_ARG,\n         mut_mut::MUT_MUT,\n         needless_bool::NEEDLESS_BOOL,\n@@ -104,8 +109,13 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         strings::STRING_ADD,\n         strings::STRING_ADD_ASSIGN,\n         types::BOX_VEC,\n+        types::CAST_POSSIBLE_TRUNCATION,\n+        types::CAST_POSSIBLE_WRAP,\n+        types::CAST_PRECISION_LOSS,\n+        types::CAST_SIGN_LOSS,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n+        types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n         unicode::NON_ASCII_LITERAL,\n         unicode::ZERO_WIDTH_SPACE,"}, {"sha": "660d68535bd5a593bb03ef8fd51825ca669844bb", "filename": "src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -26,14 +26,14 @@ impl LintPass for LifetimePass {\n \n     fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n         if let MethodImplItem(ref sig, _) = item.node {\n-            check_fn_inner(cx, &*sig.decl, Some(&sig.explicit_self),\n+            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n                            &sig.generics.lifetimes, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n-            check_fn_inner(cx, &*sig.decl, Some(&sig.explicit_self),\n+            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n                            &sig.generics.lifetimes, item.span);\n         }\n     }\n@@ -92,7 +92,7 @@ fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n     }\n     // extract lifetimes in input argument types\n     for arg in &func.inputs {\n-        walk_ty(&mut input_visitor, &*arg.ty);\n+        walk_ty(&mut input_visitor, &arg.ty);\n     }\n     // extract lifetimes in output type\n     if let Return(ref ty) = func.output {"}, {"sha": "ca8d3990fc5da424eb0c65297891b4d43baa6682", "filename": "src/loops.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -1,10 +1,9 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::visit::{Visitor, walk_expr};\n-use rustc::middle::ty;\n use std::collections::HashSet;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_def_path};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n                \"for-looping over a range of indices where an iterator over items would do\" }\n@@ -68,16 +67,10 @@ impl LintPass for LoopsPass {\n                             object, object));\n                     // check for looping over Iterator::next() which is not what you want\n                     } else if method_name == \"next\" {\n-                        let method_call = ty::MethodCall::expr(arg.id);\n-                        let trt_id = cx.tcx.tables\n-                                           .borrow().method_map.get(&method_call)\n-                                           .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n-                        if let Some(trt_id) = trt_id {\n-                            if match_def_path(cx, trt_id, &[\"core\", \"iter\", \"Iterator\"]) {\n-                                span_lint(cx, ITER_NEXT_LOOP, expr.span,\n-                                          \"you are iterating over `Iterator::next()` which is an Option; \\\n-                                           this will compile but is probably not what you want\");\n-                            }\n+                        if match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n+                            span_lint(cx, ITER_NEXT_LOOP, expr.span,\n+                                      \"you are iterating over `Iterator::next()` which is an Option; \\\n+                                       this will compile but is probably not what you want\");\n                         }\n                     }\n                 }\n@@ -102,9 +95,9 @@ fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n             let PatEnum(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n             somepats.len() == 1\n         ], {\n-            return Some((&*somepats[0],\n-                         &*iterargs[0],\n-                         &*innerarms[0].body));\n+            return Some((&somepats[0],\n+                         &iterargs[0],\n+                         &innerarms[0].body));\n         }\n     }\n     None"}, {"sha": "d1c74daf2cd189c87515ea5cf98e1ec625ddf654", "filename": "src/matches.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -0,0 +1,86 @@\n+use rustc::lint::*;\n+use syntax::ast;\n+use syntax::ast::*;\n+use std::borrow::Cow;\n+\n+use utils::{snippet, snippet_block, span_lint, span_help_and_lint};\n+\n+declare_lint!(pub SINGLE_MATCH, Warn,\n+              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n+               is `_ => {}`) is used; recommends `if let` instead\");\n+declare_lint!(pub MATCH_REF_PATS, Warn,\n+              \"a match has all arms prefixed with `&`; the match expression can be \\\n+               dereferenced instead\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct MatchPass;\n+\n+impl LintPass for MatchPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SINGLE_MATCH, MATCH_REF_PATS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n+            // check preconditions for SINGLE_MATCH\n+                // only two arms\n+            if arms.len() == 2 &&\n+                // both of the arms have a single pattern and no guard\n+                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+                // since the exhaustiveness check will ensure the last one is a catch-all,\n+                // but in some cases, an explicit match is preferred to catch situations\n+                // when an enum is extended, so we don't consider these cases\n+                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n+                // finally, we don't want any content in the second arm (unit or empty block)\n+                is_unit_expr(&arms[1].body)\n+            {\n+                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n+                let body_code = if let ExprBlock(_) = arms[0].body.node {\n+                    body_code\n+                } else {\n+                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n+                };\n+                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                      \"you seem to be trying to use match for \\\n+                      destructuring a single pattern. Did you mean to \\\n+                      use `if let`?\",\n+                      &format!(\"try\\nif let {} = {} {}\",\n+                               snippet(cx, arms[0].pats[0].span, \"..\"),\n+                               snippet(cx, ex.span, \"..\"),\n+                               body_code)\n+                );\n+            }\n+\n+            // check preconditions for MATCH_REF_PATS\n+            if has_only_ref_pats(arms) {\n+                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"you don't need to add `&` to both the expression to match \\\n+                         and the patterns: use `match {} {{ ...`\", snippet(cx, inner.span, \"..\")));\n+                } else {\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                         expression to match: `match *{} {{ ...`\", snippet(cx, ex.span, \"..\")));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_unit_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprTup(ref v) if v.is_empty() => true,\n+        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        _ => false,\n+    }\n+}\n+\n+fn has_only_ref_pats(arms: &[Arm]) -> bool {\n+    arms.iter().flat_map(|a| &a.pats).all(|p| match p.node {\n+        PatRegion(..) => true,  // &-patterns\n+        PatWild(..) => true,    // an \"anything\" wildcard is also fine\n+        _ => false,\n+    })\n+}"}, {"sha": "07693e11d996589389f58fa8286ac07afcc1c57a", "filename": "src/methods.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -2,7 +2,8 @@ use syntax::ast::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n \n-use utils::{span_lint, match_def_path, walk_ptrs_ty};\n+use utils::{span_lint, match_type, walk_ptrs_ty};\n+use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n@@ -16,45 +17,32 @@ declare_lint!(pub STR_TO_STRING, Warn,\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n \n-#[allow(unused_imports)]\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        {\n-            // In case stuff gets moved around\n-            use core::option::Option;\n-            use core::result::Result;\n-            use collections::string::String;\n-        }\n         if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n-            let ref obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0])).sty;\n+            let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&args[0]));\n             if ident.node.name == \"unwrap\" {\n-                if let ty::TyEnum(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"core\", \"option\", \"Option\"]) {\n-                        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on an Option value. If you don't want \\\n-                                   to handle the None case gracefully, consider using\n-                                   expect() to provide a better panic message\");\n-                    }\n-                    else if match_def_path(cx, did.did, &[\"core\", \"result\", \"Result\"]) {\n-                        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on a Result value. Graceful handling \\\n-                                   of Err values is preferred\");\n-                    }\n+                if match_type(cx, obj_ty, &OPTION_PATH) {\n+                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on an Option value. If you don't want \\\n+                               to handle the None case gracefully, consider using \\\n+                               expect() to provide a better panic message\");\n+                } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on a Result value. Graceful handling \\\n+                               of Err values is preferred\");\n                 }\n             }\n             else if ident.node.name == \"to_string\" {\n-                if let ty::TyStr = *obj_ty {\n+                if obj_ty.sty == ty::TyStr {\n                     span_lint(cx, STR_TO_STRING, expr.span, \"`str.to_owned()` is faster\");\n-                }\n-                else if let ty::TyStruct(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"]) {\n-                        span_lint(cx, STRING_TO_STRING, expr.span,\n-                                  \"`String.to_string()` is a no-op\")\n-                    }\n+                } else if match_type(cx, obj_ty, &STRING_PATH) {\n+                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op; use \\\n+                                                                `clone()` to make a copy\");\n                 }\n             }\n         }"}, {"sha": "2290af38bb5745621441cb1f5187b54b7bfde417", "filename": "src/misc.rs", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -1,75 +1,14 @@\n use rustc::lint::*;\n use syntax::ptr::P;\n-use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n-use std::borrow::Cow;\n \n-use utils::{match_path, snippet, snippet_block, span_lint, span_help_and_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n use consts::constant;\n \n-/// Handles uncategorized lints\n-/// Currently handles linting of if-let-able matches\n-#[allow(missing_copy_implementations)]\n-pub struct MiscPass;\n-\n-\n-declare_lint!(pub SINGLE_MATCH, Warn,\n-              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n-               is `_ => {}`) is used; recommends `if let` instead\");\n-\n-impl LintPass for MiscPass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n-            // check preconditions: only two arms\n-            if arms.len() == 2 &&\n-                // both of the arms have a single pattern and no guard\n-                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-                // since the exhaustiveness check will ensure the last one is a catch-all,\n-                // but in some cases, an explicit match is preferred to catch situations\n-                // when an enum is extended, so we don't consider these cases\n-                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n-                // finally, we don't want any content in the second arm (unit or empty block)\n-                is_unit_expr(&*arms[1].body)\n-            {\n-                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                let body_code = if let ExprBlock(_) = arms[0].body.node {\n-                    body_code\n-                } else {\n-                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n-                };\n-                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                      \"you seem to be trying to use match for \\\n-                      destructuring a single pattern. Did you mean to \\\n-                      use `if let`?\",\n-                      &*format!(\"try\\nif let {} = {} {}\",\n-                                snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                snippet(cx, ex.span, \"..\"),\n-                                body_code)\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_unit_expr(expr: &Expr) -> bool {\n-    match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n-        _ => false,\n-    }\n-}\n-\n-\n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n               \"a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not \\\n                `fn foo((ref x, ref y): (u8, u8))`)\");\n@@ -236,8 +175,8 @@ impl LintPass for CmpOwned {\n }\n \n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n-    match &expr.node {\n-        &ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n+    match expr.node {\n+        ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n             let name = ident.name;\n             if name == \"to_string\" ||\n                 name == \"to_owned\" && is_str_arg(cx, args) {\n@@ -247,7 +186,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n                         snippet(cx, other_span, \"..\")))\n                 }\n         },\n-        &ExprCall(ref path, _) => {\n+        ExprCall(ref path, _) => {\n             if let &ExprPath(None, ref path) = &path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) ||\n                     match_path(path, &[\"String\", \"from\"]) {\n@@ -264,7 +203,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n \n fn is_str_arg(cx: &Context, args: &[P<Expr>]) -> bool {\n     args.len() == 1 && if let ty::TyStr =\n-        walk_ptrs_ty(cx.tcx.expr_ty(&*args[0])).sty { true } else { false }\n+        walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty { true } else { false }\n }\n \n declare_lint!(pub MODULO_ONE, Warn, \"taking a number modulo 1, which always returns 0\");"}, {"sha": "0fe52c44189cdb584d1e8e993ef9c22a3b43853e", "filename": "src/needless_bool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -5,7 +5,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n \n-use utils::{de_p, span_lint, snippet};\n+use utils::{span_lint, snippet};\n \n declare_lint! {\n     pub NEEDLESS_BOOL,\n@@ -55,14 +55,14 @@ impl LintPass for NeedlessBool {\n \n fn fetch_bool_block(block: &Block) -> Option<bool> {\n     if block.stmts.is_empty() {\n-        block.expr.as_ref().map(de_p).and_then(fetch_bool_expr)\n+        block.expr.as_ref().and_then(|e| fetch_bool_expr(e))\n     } else { None }\n }\n \n fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n-    match &expr.node {\n-        &ExprBlock(ref block) => fetch_bool_block(block),\n-        &ExprLit(ref lit_ptr) => if let &LitBool(value) = &lit_ptr.node {\n+    match expr.node {\n+        ExprBlock(ref block) => fetch_bool_block(block),\n+        ExprLit(ref lit_ptr) => if let LitBool(value) = lit_ptr.node {\n             Some(value) } else { None },\n         _ => None\n     }"}, {"sha": "bcbd8dad68a9c74b3f25255c32544f09f9f0bfb5", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -4,10 +4,10 @@\n \n use rustc::lint::*;\n use syntax::ast::*;\n-use syntax::codemap::Span;\n+use rustc::middle::ty;\n \n-use types::match_ty_unwrap;\n-use utils::span_lint;\n+use utils::{span_lint, match_type};\n+use utils::{STRING_PATH, VEC_PATH};\n \n declare_lint! {\n     pub PTR_ARG,\n@@ -45,22 +45,19 @@ impl LintPass for PtrArg {\n \n fn check_fn(cx: &Context, decl: &FnDecl) {\n     for arg in &decl.inputs {\n-        match &arg.ty.node {\n-            &TyPtr(ref p) | &TyRptr(_, ref p) =>\n-                check_ptr_subtype(cx, arg.ty.span, &p.ty),\n-            _ => ()\n+        if let Some(pat_ty) = cx.tcx.pat_ty_opt(&arg.pat) {\n+            if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = pat_ty.sty {\n+                if match_type(cx, ty, &VEC_PATH) {\n+                    span_lint(cx, PTR_ARG, arg.ty.span,\n+                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n+                               and cannot be used with non-Vec-based slices. Consider changing \\\n+                               the type to `&[...]`\");\n+                } else if match_type(cx, ty, &STRING_PATH) {\n+                    span_lint(cx, PTR_ARG, arg.ty.span,\n+                              \"writing `&String` instead of `&str` involves a new object \\\n+                               where a slice will do. Consider changing the type to `&str`\");\n+                }\n+            }\n         }\n     }\n }\n-\n-fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n-    match_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty,\n-        &[\"String\"]).map_or((), |_| {\n-            span_lint(cx, PTR_ARG, span,\n-                      \"writing `&String` instead of `&str` involves a new object \\\n-                       where a slice will do. Consider changing the type to `&str`\")\n-        }), |_| span_lint(cx, PTR_ARG, span,\n-                          \"writing `&Vec<_>` instead of \\\n-                           `&[_]` involves one more reference and cannot be used with \\\n-                           non-Vec-based slices. Consider changing the type to `&[...]`\"))\n-}"}, {"sha": "914b4daa6bea66e3f97bcd11abb355a0daad8bf5", "filename": "src/ranges.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::{Context, LintArray, LintPass};\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n-use utils::{match_def_path};\n+use utils::match_type;\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n@@ -21,7 +20,7 @@ impl LintPass for StepByZero {\n         if let ExprMethodCall(Spanned { node: ref ident, .. }, _,\n                               ref args) = expr.node {\n             // Only warn on literal ranges.\n-            if ident.name.as_str() == \"step_by\" && args.len() == 2 &&\n+            if ident.name == \"step_by\" && args.len() == 2 &&\n                 is_range(cx, &args[0]) && is_lit_zero(&args[1]) {\n                 cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n                              \"Range::step_by(0) produces an infinite iterator. \\\n@@ -34,11 +33,9 @@ impl LintPass for StepByZero {\n fn is_range(cx: &Context, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n-    if let TyStruct(did, _) = cx.tcx.expr_ty(expr).sty {\n-        // Note: RangeTo and RangeFull don't have step_by\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"Range\"]) ||\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"RangeFrom\"])\n-    } else { false }\n+    let ty = cx.tcx.expr_ty(expr);\n+    // Note: RangeTo and RangeFull don't have step_by\n+    match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n }\n \n fn is_lit_zero(expr: &Expr) -> bool {"}, {"sha": "301072f79123d08598123c2fda3f7f9cef972d69", "filename": "src/returns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -50,7 +50,7 @@ impl ReturnPass {\n             // a match expr, check all arms\n             ExprMatch(_, ref arms, _) => {\n                 for arm in arms {\n-                    self.check_final_expr(cx, &*arm.body);\n+                    self.check_final_expr(cx, &arm.body);\n                 }\n             }\n             _ => { }\n@@ -76,7 +76,7 @@ impl ReturnPass {\n                 let PatIdent(_, Spanned { node: id, .. }, _) = local.pat.node,\n                 let Some(ref retexpr) = block.expr,\n                 let ExprPath(_, ref path) = retexpr.node,\n-                match_path(path, &[&*id.name.as_str()])\n+                match_path(path, &[&id.name.as_str()])\n             ], {\n                 self.emit_let_lint(cx, retexpr.span, initexpr.span);\n             }"}, {"sha": "d03f4d53c606b835a4e0a28f7997522b1ad2f479", "filename": "src/strings.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -4,12 +4,12 @@\n //! disable the subsumed lint unless it has a higher level\n \n use rustc::lint::*;\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_def_path, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::STRING_PATH;\n \n declare_lint! {\n     pub STRING_ADD_ASSIGN,\n@@ -41,7 +41,7 @@ impl LintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let &ExprAssign(ref target, _) = &p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(target, left) { return; }\n+                            if is_exp_equal(cx, target, left) { return; }\n                         }\n                     }\n                 }\n@@ -51,7 +51,7 @@ impl LintPass for StringAdd {\n                          Consider using `String::push_str()` instead\")\n             }\n         } else if let &ExprAssign(ref target, ref  src) = &e.node {\n-            if is_string(cx, target) && is_add(src, target) {\n+            if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n                      Consider using `String::push_str()` instead\")\n@@ -61,19 +61,17 @@ impl LintPass for StringAdd {\n }\n \n fn is_string(cx: &Context, e: &Expr) -> bool {\n-    let ty = walk_ptrs_ty(cx.tcx.expr_ty(e));\n-    if let TyStruct(did, _) = ty.sty {\n-        match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"])\n-    } else { false }\n+    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n }\n \n-fn is_add(src: &Expr, target: &Expr) -> bool {\n-    match &src.node {\n-        &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n-            is_exp_equal(target, left),\n-        &ExprBlock(ref block) => block.stmts.is_empty() &&\n-            block.expr.as_ref().map_or(false, |expr| is_add(&*expr, target)),\n-        &ExprParen(ref expr) => is_add(&*expr, target),\n+fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {\n+    match src.node {\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n+            is_exp_equal(cx, target, left),\n+        ExprBlock(ref block) => block.stmts.is_empty() &&\n+            block.expr.as_ref().map_or(false,\n+                |expr| is_add(cx, expr, target)),\n+        ExprParen(ref expr) => is_add(cx, expr, target),\n         _ => false\n     }\n }"}, {"sha": "7479a65b6ee5d18b9862cf301944d815fe8f8713", "filename": "src/types.rs", "status": "modified", "additions": 287, "deletions": 53, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -2,11 +2,13 @@ use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n-use syntax::ptr::P;\n+use syntax::codemap::Span;\n+use syntax::visit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, snippet, span_lint, span_help_and_lint};\n+use utils::{in_macro, match_type, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -18,61 +20,26 @@ declare_lint!(pub LINKEDLIST, Warn,\n               \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n                structure like a RingBuf\");\n \n-/// Matches a type with a provided string, and returns its type parameters if successful\n-pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]> {\n-    match ty.node {\n-        TyPath(_, Path {segments: ref seg, ..}) => {\n-            // So ast::Path isn't the full path, just the tokens that were provided.\n-            // I could muck around with the maps and find the full path\n-            // however the more efficient way is to simply reverse the iterators and zip them\n-            // which will compare them in reverse until one of them runs out of segments\n-            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.name == b) {\n-                match seg[..].last() {\n-                    Some(&PathSegment {parameters: AngleBracketedParameters(ref a), ..}) => {\n-                        Some(&a.types[..])\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None\n-    }\n-}\n-\n-#[allow(unused_imports)]\n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_VEC, LINKEDLIST)\n     }\n \n-    fn check_ty(&mut self, cx: &Context, ty: &ast::Ty) {\n-        {\n-            // In case stuff gets moved around\n-            use std::boxed::Box;\n-            use std::vec::Vec;\n-        }\n-        match_ty_unwrap(ty, &[\"std\", \"boxed\", \"Box\"]).and_then(|t| t.first())\n-          .and_then(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n-          .map(|_| {\n-            span_help_and_lint(cx, BOX_VEC, ty.span,\n-                              \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                              \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n-          });\n-        {\n-            // In case stuff gets moved around\n-            use collections::linked_list::LinkedList as DL1;\n-            use std::collections::linked_list::LinkedList as DL2;\n-        }\n-        let dlists = [vec![\"std\",\"collections\",\"linked_list\",\"LinkedList\"],\n-                      vec![\"collections\",\"linked_list\",\"LinkedList\"]];\n-        for path in &dlists {\n-            if match_ty_unwrap(ty, &path[..]).is_some() {\n-                span_help_and_lint(cx, LINKEDLIST, ty.span,\n-                                   \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                   \"a RingBuf might work\");\n-                return;\n+    fn check_ty(&mut self, cx: &Context, ast_ty: &ast::Ty) {\n+        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+            if let ty::TyBox(ref inner) = ty.sty {\n+                if match_type(cx, inner, &VEC_PATH) {\n+                    span_help_and_lint(\n+                        cx, BOX_VEC, ast_ty.span,\n+                        \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n+                }\n+            }\n+            else if match_type(cx, ty, &LL_PATH) {\n+                span_help_and_lint(\n+                    cx, LINKEDLIST, ast_ty.span,\n+                    \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                    \"a RingBuf might work\");\n             }\n         }\n     }\n@@ -88,7 +55,7 @@ declare_lint!(pub LET_UNIT_VALUE, Warn,\n fn check_let_unit(cx: &Context, decl: &Decl, info: Option<&ExpnInfo>) {\n     if in_macro(cx, info) { return; }\n     if let DeclLocal(ref local) = decl.node {\n-        let bindtype = &cx.tcx.pat_ty(&*local.pat).sty;\n+        let bindtype = &cx.tcx.pat_ty(&local.pat).sty;\n         if *bindtype == ty::TyTuple(vec![]) {\n             span_lint(cx, LET_UNIT_VALUE, decl.span, &format!(\n                 \"this let-binding has unit value. Consider omitting `let {} =`\",\n@@ -136,3 +103,270 @@ impl LintPass for UnitCmp {\n         }\n     }\n }\n+\n+pub struct CastPass;\n+\n+declare_lint!(pub CAST_PRECISION_LOSS, Allow,\n+              \"casts that cause loss of precision, e.g `x as f32` where `x: u64`\");\n+declare_lint!(pub CAST_SIGN_LOSS, Allow,\n+              \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\");\n+declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n+              \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\");\n+declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n+              \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\");\n+\n+/// Returns the size in bits of an integral type.\n+/// Will return 0 if the type is not an int or uint variant\n+fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n+    let n = match typ.sty {\n+        ty::TyInt(i) =>  4 << (i as usize),\n+        ty::TyUint(u) => 4 << (u as usize),\n+        _ => 0\n+    };\n+    // n == 4 is the usize/isize case\n+    if n == 4 { ::std::usize::BITS } else { n }\n+}\n+\n+fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n+    match typ.sty {\n+        ty::TyInt(ast::TyIs) | ty::TyUint(ast::TyUs) => true,\n+        _ => false\n+    }\n+}\n+\n+fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+    let mantissa_nbits = if cast_to_f64 {52} else {23};\n+    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n+    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n+    let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n+                         else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n+                         else {int_ty_to_nbits(cast_from).to_string()};\n+    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+              &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n+                        ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n+                       cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n+                       if arch_dependent {arch_dependent_str} else {\"\"},\n+                       from_nbits_str,\n+                       mantissa_nbits));\n+}\n+\n+enum ArchSuffix {\n+    _32, _64, None\n+}\n+\n+fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n+    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n+    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n+    let (from_nbits, to_nbits) = (int_ty_to_nbits(cast_from), int_ty_to_nbits(cast_to));\n+    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n+        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+            (true, true) | (false, false) => (\n+                to_nbits < from_nbits,\n+                ArchSuffix::None,\n+                to_nbits == from_nbits && cast_unsigned_to_signed,\n+                ArchSuffix::None\n+                ),\n+            (true, false) => (\n+                to_nbits <= 32,\n+                if to_nbits == 32 {ArchSuffix::_64} else {ArchSuffix::None},\n+                to_nbits <= 32 && cast_unsigned_to_signed,\n+                ArchSuffix::_32\n+                ),\n+            (false, true) => (\n+                from_nbits == 64,\n+                ArchSuffix::_32,\n+                cast_unsigned_to_signed,\n+                if from_nbits == 64 {ArchSuffix::_64} else {ArchSuffix::_32}\n+                ),\n+        };\n+    if span_truncation {\n+        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                  &format!(\"casting {} to {} may truncate the value{}\",\n+                           cast_from, cast_to,\n+                           match suffix_truncation {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\" }));\n+    }\n+    if span_wrap {\n+        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                  &format!(\"casting {} to {} may wrap around the value{}\",\n+                           cast_from, cast_to,\n+                           match suffix_wrap {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\" }));\n+    }\n+}\n+\n+impl LintPass for CastPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(CAST_PRECISION_LOSS,\n+                    CAST_SIGN_LOSS,\n+                    CAST_POSSIBLE_TRUNCATION,\n+                    CAST_POSSIBLE_WRAP)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprCast(ref ex, _) = expr.node {\n+            let (cast_from, cast_to) = (cx.tcx.expr_ty(ex), cx.tcx.expr_ty(expr));\n+            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n+                match (cast_from.is_integral(), cast_to.is_integral()) {\n+                    (true, false) => {\n+                        let from_nbits = int_ty_to_nbits(cast_from);\n+                        let to_nbits = if let ty::TyFloat(ast::TyF32) = cast_to.sty {32} else {64};\n+                        if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n+                            span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n+                        }\n+                    },\n+                    (false, true) => {\n+                        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                                  &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n+                        if !cast_to.is_signed() {\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n+                        }\n+                    },\n+                    (true, true) => {\n+                        if cast_from.is_signed() && !cast_to.is_signed() {\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n+                        }\n+                        check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n+                    }\n+                    (false, false) => {\n+                        if let (&ty::TyFloat(ast::TyF64),\n+                                &ty::TyFloat(ast::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n+                            span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, \"casting f64 to f32 may truncate the value\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint!(pub TYPE_COMPLEXITY, Warn,\n+              \"usage of very complex types; recommends factoring out parts into `type` definitions\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct TypeComplexityPass;\n+\n+impl LintPass for TypeComplexityPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TYPE_COMPLEXITY)\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+        check_fndecl(cx, decl);\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &Context, field: &StructField) {\n+        check_type(cx, &field.node.ty);\n+    }\n+\n+    fn check_variant(&mut self, cx: &Context, var: &Variant, _: &Generics) {\n+        // StructVariant is covered by check_struct_field\n+        if let TupleVariantKind(ref args) = var.node.kind {\n+            for arg in args {\n+                check_type(cx, &arg.ty);\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        match item.node {\n+            ItemStatic(ref ty, _, _) |\n+            ItemConst(ref ty, _) => check_type(cx, ty),\n+            // functions, enums, structs, impls and traits are covered\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        match item.node {\n+            ConstTraitItem(ref ty, _) |\n+            TypeTraitItem(_, Some(ref ty)) => check_type(cx, ty),\n+            MethodTraitItem(MethodSig { ref decl, .. }, None) => check_fndecl(cx, decl),\n+            // methods with default impl are covered by check_fn\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+        match item.node {\n+            ConstImplItem(ref ty, _) |\n+            TypeImplItem(ref ty) => check_type(cx, ty),\n+            // methods are covered by check_fn\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &Context, local: &Local) {\n+        if let Some(ref ty) = local.ty {\n+            check_type(cx, ty);\n+        }\n+    }\n+}\n+\n+fn check_fndecl(cx: &Context, decl: &FnDecl) {\n+    for arg in &decl.inputs {\n+        check_type(cx, &arg.ty);\n+    }\n+    if let Return(ref ty) = decl.output {\n+        check_type(cx, ty);\n+    }\n+}\n+\n+fn check_type(cx: &Context, ty: &ast::Ty) {\n+    if in_external_macro(cx, ty.span) { return; }\n+    let score = {\n+        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        visitor.visit_ty(ty);\n+        visitor.score\n+    };\n+    // println!(\"{:?} --> {}\", ty, score);\n+    if score > 250 {\n+        span_lint(cx, TYPE_COMPLEXITY, ty.span, &format!(\n+            \"very complex type used. Consider factoring parts into `type` definitions\"));\n+    }\n+}\n+\n+/// Walks a type and assigns a complexity score to it.\n+struct TypeComplexityVisitor {\n+    /// total complexity score of the type\n+    score: u32,\n+    /// current nesting level\n+    nest: u32,\n+}\n+\n+impl<'v> Visitor<'v> for TypeComplexityVisitor {\n+    fn visit_ty(&mut self, ty: &'v ast::Ty) {\n+        let (add_score, sub_nest) = match ty.node {\n+            // _, &x and *x have only small overhead; don't mess with nesting level\n+            TyInfer |\n+            TyPtr(..) |\n+            TyRptr(..) => (1, 0),\n+\n+            // the \"normal\" components of a type: named types, arrays/tuples\n+            TyPath(..) |\n+            TyVec(..) |\n+            TyTup(..) |\n+            TyFixedLengthVec(..) => (10 * self.nest, 1),\n+\n+            // \"Sum\" of trait bounds\n+            TyObjectSum(..) => (20 * self.nest, 0),\n+\n+            // function types and \"for<...>\" bring a lot of overhead\n+            TyBareFn(..) |\n+            TyPolyTraitRef(..) => (50 * self.nest, 1),\n+\n+            _ => (0, 0)\n+        };\n+        self.score += add_score;\n+        self.nest += sub_nest;\n+        walk_ty(self, ty);\n+        self.nest -= sub_nest;\n+    }\n+}"}, {"sha": "8a64f612666b26046166da5feac4d34ccdc547d8", "filename": "src/unicode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -40,6 +40,7 @@ fn check_str(cx: &Context, string: &str, span: Span) {\n     }\n }\n \n+#[allow(cast_possible_truncation)]\n fn str_pos_lint(cx: &Context, lint: &'static Lint, span: Span, index: usize, msg: &str) {\n     span_lint(cx, lint, Span { lo: span.lo + BytePos((1 + index) as u32),\n                                hi: span.lo + BytePos((1 + index) as u32),"}, {"sha": "394204bedfc714e11f5ab4089b064523b8d36150", "filename": "src/utils.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -1,11 +1,17 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::{ExpnInfo, Span};\n-use syntax::ptr::P;\n use rustc::ast_map::Node::NodeExpr;\n use rustc::middle::ty;\n use std::borrow::Cow;\n \n+// module DefPaths for certain structs/enums we check for\n+pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+\n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n@@ -37,6 +43,31 @@ pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n         .zip(path.iter()).all(|(nm, p)| nm == p))\n }\n \n+/// check if type is struct or enum type with given def path\n+pub fn match_type(cx: &Context, ty: ty::Ty, path: &[&str]) -> bool {\n+    match ty.sty {\n+        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => {\n+            match_def_path(cx, adt.did, path)\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n+/// check if method call given in \"expr\" belongs to given trait\n+pub fn match_trait_method(cx: &Context, expr: &Expr, path: &[&str]) -> bool {\n+    let method_call = ty::MethodCall::expr(expr.id);\n+    let trt_id = cx.tcx.tables\n+                       .borrow().method_map.get(&method_call)\n+                       .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n+    if let Some(trt_id) = trt_id {\n+        match_def_path(cx, trt_id, path)\n+    } else {\n+        false\n+    }\n+}\n+\n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n@@ -98,9 +129,6 @@ pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n         if let NodeExpr(parent) = node { Some(parent) } else { None } )\n }\n \n-/// dereference a P<T> and return a ref on the result\n-pub fn de_p<T>(p: &P<T>) -> &T { &*p }\n-\n #[cfg(not(feature=\"structured_logging\"))]\n pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     cx.span_lint(lint, sp, msg);"}, {"sha": "b17f5de841b409dba142a8257e253202dac43754", "filename": "tests/compile-fail/cast.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -0,0 +1,63 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(cast_precision_loss, cast_possible_truncation, cast_sign_loss, cast_possible_wrap)]\n+fn main() {\n+    // Test cast_precision_loss\n+    1i32 as f32; //~ERROR casting i32 to f32 causes a loss of precision (i32 is 32 bits wide, but f32's mantissa is only 23 bits wide)\n+    1i64 as f32; //~ERROR casting i64 to f32 causes a loss of precision (i64 is 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1i64 as f64; //~ERROR casting i64 to f64 causes a loss of precision (i64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1u32 as f32; //~ERROR casting u32 to f32 causes a loss of precision (u32 is 32 bits wide, but f32's mantissa is only 23 bits wide)\n+    1u64 as f32; //~ERROR casting u64 to f32 causes a loss of precision (u64 is 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1u64 as f64; //~ERROR casting u64 to f64 causes a loss of precision (u64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1i32 as f64; // Should not trigger the lint\n+    1u32 as f64; // Should not trigger the lint\n+\n+    // Test cast_possible_truncation\n+    1f32 as i32;   //~ERROR casting f32 to i32 may truncate the value\n+    1f32 as u32;   //~ERROR casting f32 to u32 may truncate the value\n+                  //~^ERROR casting f32 to u32 may lose the sign of the value\n+    1f64 as f32;   //~ERROR casting f64 to f32 may truncate the value\n+    1i32 as i8;    //~ERROR casting i32 to i8 may truncate the value\n+    1i32 as u8;    //~ERROR casting i32 to u8 may truncate the value\n+                  //~^ERROR casting i32 to u8 may lose the sign of the value\n+    1f64 as isize; //~ERROR casting f64 to isize may truncate the value\n+    1f64 as usize; //~ERROR casting f64 to usize may truncate the value\n+                  //~^ERROR casting f64 to usize may lose the sign of the value\n+\n+    // Test cast_possible_wrap\n+    1u8 as i8;       //~ERROR casting u8 to i8 may wrap around the value\n+    1u16 as i16;     //~ERROR casting u16 to i16 may wrap around the value\n+    1u32 as i32;     //~ERROR casting u32 to i32 may wrap around the value\n+    1u64 as i64;     //~ERROR casting u64 to i64 may wrap around the value\n+    1usize as isize; //~ERROR casting usize to isize may wrap around the value\n+\n+    // Test cast_sign_loss\n+    1i32 as u32;     //~ERROR casting i32 to u32 may lose the sign of the value\n+    1isize as usize; //~ERROR casting isize to usize may lose the sign of the value\n+\n+    // Extra checks for *size\n+    // Casting from *size\n+    1isize as i8;  //~ERROR casting isize to i8 may truncate the value\n+    1isize as f64; //~ERROR casting isize to f64 causes a loss of precision on targets with 64-bit wide pointers (isize is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1usize as f64; //~ERROR casting usize to f64 causes a loss of precision on targets with 64-bit wide pointers (usize is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1isize as f32; //~ERROR casting isize to f32 causes a loss of precision (isize is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1usize as f32; //~ERROR casting usize to f32 causes a loss of precision (usize is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1isize as i32; //~ERROR casting isize to i32 may truncate the value on targets with 64-bit wide pointers\n+    1isize as u32; //~ERROR casting isize to u32 may lose the sign of the value\n+                  //~^ERROR casting isize to u32 may truncate the value on targets with 64-bit wide pointers       \n+    1usize as u32; //~ERROR casting usize to u32 may truncate the value on targets with 64-bit wide pointers\n+    1usize as i32; //~ERROR casting usize to i32 may truncate the value on targets with 64-bit wide pointers\n+                  //~^ERROR casting usize to i32 may wrap around the value on targets with 32-bit wide pointers\n+    // Casting to *size\n+    1i64 as isize; //~ERROR casting i64 to isize may truncate the value on targets with 32-bit wide pointers\n+    1i64 as usize; //~ERROR casting i64 to usize may truncate the value on targets with 32-bit wide pointers\n+                  //~^ERROR casting i64 to usize may lose the sign of the value\n+    1u64 as isize; //~ERROR casting u64 to isize may truncate the value on targets with 32-bit wide pointers\n+                  //~^ERROR casting u64 to isize may wrap around the value on targets with 64-bit wide pointers\n+    1u64 as usize; //~ERROR casting u64 to usize may truncate the value on targets with 32-bit wide pointers\n+    1u32 as isize; //~ERROR casting u32 to isize may wrap around the value on targets with 32-bit wide pointers\n+    1u32 as usize; // Should not trigger any lint\n+    1i32 as isize; // Neither should this\n+    1i32 as usize; //~ERROR casting i32 to usize may lose the sign of the value\n+}\n\\ No newline at end of file"}, {"sha": "995132ba88c9420961cd2d2cbaa33e8008110dfa", "filename": "tests/compile-fail/complex_types.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fcomplex_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fcomplex_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcomplex_types.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -0,0 +1,44 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+#![allow(unused)]\n+#![feature(associated_consts, associated_type_defaults)]\n+\n+type Alias = Vec<Vec<Box<(u32, u32, u32, u32)>>>; // no warning here\n+\n+const CST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+static ST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+\n+struct S {\n+    f: Vec<Vec<Box<(u32, u32, u32, u32)>>>, //~ERROR very complex type\n+}\n+\n+struct TS(Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n+\n+enum E {\n+    V1(Vec<Vec<Box<(u32, u32, u32, u32)>>>), //~ERROR very complex type\n+    V2 { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> }, //~ERROR very complex type\n+}\n+\n+impl S {\n+    const A: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0)))); //~ERROR very complex type\n+    fn impl_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+}\n+\n+trait T {\n+    const A: Vec<Vec<Box<(u32, u32, u32, u32)>>>; //~ERROR very complex type\n+    type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>; //~ERROR very complex type\n+    fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n+    fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+}\n+\n+fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> { vec![] } //~ERROR very complex type\n+\n+fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) { } //~ERROR very complex type\n+\n+fn test3() {\n+    let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![]; //~ERROR very complex type\n+}\n+\n+fn main() {\n+}"}, {"sha": "a800c045a502a8e6843792e30fab3b3d4b3bca73", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -12,4 +12,4 @@ pub fn test(foo: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n \n fn main(){\n     test(LinkedList::new());\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a1183629344afa4a69c0d61d6e4b6139b04f3218", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -34,4 +34,8 @@ fn main() {\n     ((1, 2) != (1, 2)); //~ERROR equal expressions\n     [1].len() == [1].len(); //~ERROR equal expressions\n     vec![1, 2, 3] == vec![1, 2, 3]; //no error yet, as we don't match macros\n+\n+    // const folding\n+    1 + 1 == 2; //~ERROR equal expressions\n+    1 - 1 == 0; //~ERROR equal expressions\n }"}, {"sha": "3cc540992c99c5629561f4197fc072355ddb52e3", "filename": "tests/compile-fail/matches.rs", "status": "renamed", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -2,8 +2,9 @@\n \n #![plugin(clippy)]\n #![deny(clippy)]\n+#![allow(unused)]\n \n-fn main(){\n+fn single_match(){\n     let x = Some(1u8);\n     match x {  //~ ERROR you seem to be trying to use match\n                //~^ HELP try\n@@ -36,3 +37,29 @@ fn main(){\n         _ => println!(\"nope\"),\n     }\n }\n+\n+fn ref_pats() {\n+    let ref v = Some(0);\n+    match v {  //~ERROR instead of prefixing all patterns with `&`\n+        &Some(v) => println!(\"{:?}\", v),\n+        &None => println!(\"none\"),\n+    }\n+    match v {  // this doesn't trigger, we have a different pattern\n+        &Some(v) => println!(\"some\"),\n+        other => println!(\"other\"),\n+    }\n+    let ref tup = (1, 2);\n+    match tup {  //~ERROR instead of prefixing all patterns with `&`\n+        &(v, 1) => println!(\"{}\", v),\n+        _ => println!(\"none\"),\n+    }\n+    // special case: using & both in expr and pats\n+    let w = Some(0);\n+    match &w {  //~ERROR you don't need to add `&` to both\n+        &Some(v) => println!(\"{:?}\", v),\n+        &None => println!(\"none\"),\n+    }\n+}\n+\n+fn main() {\n+}", "previous_filename": "tests/compile-fail/match_if_let.rs"}, {"sha": "d0615be492b01e4d49d5ff0e8524c5cde46566e0", "filename": "tests/compile-fail/ptr_arg.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/tests%2Fcompile-fail%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_arg.rs?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -1,20 +1,23 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n+#![allow(unused)]\n+#![deny(ptr_arg)]\n \n-#[deny(ptr_arg)]\n-#[allow(unused)]\n fn do_vec(x: &Vec<i64>) { //~ERROR writing `&Vec<_>` instead of `&[_]`\n     //Nothing here\n }\n \n-#[deny(ptr_arg)]\n-#[allow(unused)]\n+fn do_vec_mut(x: &mut Vec<i64>) { // no error here\n+    //Nothing here\n+}\n+\n fn do_str(x: &String) { //~ERROR writing `&String` instead of `&str`\n     //Nothing here either\n }\n \n+fn do_str_mut(x: &mut String) { // no error here\n+    //Nothing here either\n+}\n+\n fn main() {\n-    let x = vec![1i64, 2, 3];\n-    do_vec(&x);\n-    do_str(&\"hello\".to_owned());\n }"}, {"sha": "940899d4ebb33aa5bc05ef1b932469533f3518ff", "filename": "util/update_lints.py", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "patch": "@@ -113,6 +113,11 @@ def main(print_only=False, check=False):\n                              lambda: gen_table(lints),\n                              write_back=not check)\n \n+    changed |= replace_region('README.md',\n+        r'^There are \\d+ lints included in this crate:', \"\",\n+        lambda: ['There are %d lints included in this crate:\\n' % len(lints)],\n+        write_back=not check)\n+\n     # same for \"clippy\" lint collection\n     changed |= replace_region('src/lib.rs', r'reg.register_lint_group\\(\"clippy\"', r'\\]\\);',\n                               lambda: gen_group(lints), replace_start=False,"}]}