{"sha": "c1d3610ac1ddd1cd605479274047fd0a3f37d220", "node_id": "C_kwDOAAsO6NoAKGMxZDM2MTBhYzFkZGQxY2Q2MDU0NzkyNzQwNDdmZDBhM2YzN2QyMjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-30T22:02:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-30T22:02:10Z"}, "message": "Auto merge of #109791 - compiler-errors:rollup-c3o710k, r=compiler-errors\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #109347 (Skip no_mangle if the item has no name.)\n - #109522 (Implement current_dll_path for AIX)\n - #109679 (Freshen normalizes-to hack goal RHS in the evaluate loop)\n - #109704 (resolve: Minor improvements to effective visibilities)\n - #109739 (Closures always implement `FnOnce` in new solver)\n - #109758 (Parallel compiler cleanups)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5b55207a7dc24c6ba38c70285c42bf69d51e4c93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b55207a7dc24c6ba38c70285c42bf69d51e4c93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d3610ac1ddd1cd605479274047fd0a3f37d220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d3610ac1ddd1cd605479274047fd0a3f37d220", "html_url": "https://github.com/rust-lang/rust/commit/c1d3610ac1ddd1cd605479274047fd0a3f37d220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d3610ac1ddd1cd605479274047fd0a3f37d220/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec2f40c6b04f0e9850dd1f454e8639d319f4ed9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec2f40c6b04f0e9850dd1f454e8639d319f4ed9b", "html_url": "https://github.com/rust-lang/rust/commit/ec2f40c6b04f0e9850dd1f454e8639d319f4ed9b"}, {"sha": "249198c1f8ae841a49124729a8a0f6f20a905c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/249198c1f8ae841a49124729a8a0f6f20a905c9c", "html_url": "https://github.com/rust-lang/rust/commit/249198c1f8ae841a49124729a8a0f6f20a905c9c"}], "stats": {"total": 538, "additions": 321, "deletions": 217}, "files": [{"sha": "8542bab689d6d04a7286384b75dfd00c4dbf1a60", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 46, "deletions": 69, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -89,44 +89,39 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n         };\n \n         match name {\n-            sym::cold => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-            }\n-            sym::rustc_allocator => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-            }\n+            sym::cold => codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD,\n+            sym::rustc_allocator => codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR,\n             sym::ffi_returns_twice => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-            }\n-            sym::ffi_pure => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-            }\n-            sym::ffi_const => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-            }\n-            sym::rustc_nounwind => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-            }\n-            sym::rustc_reallocator => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n-            }\n-            sym::rustc_deallocator => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE\n             }\n+            sym::ffi_pure => codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE,\n+            sym::ffi_const => codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST,\n+            sym::rustc_nounwind => codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND,\n+            sym::rustc_reallocator => codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR,\n+            sym::rustc_deallocator => codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR,\n             sym::rustc_allocator_zeroed => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n-            }\n-            sym::naked => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED\n             }\n+            sym::naked => codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED,\n             sym::no_mangle => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-            }\n-            sym::no_coverage => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+                if tcx.opt_item_name(did.to_def_id()).is_some() {\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE\n+                } else {\n+                    tcx.sess\n+                        .struct_span_err(\n+                            attr.span,\n+                            format!(\n+                                \"`#[no_mangle]` cannot be used on {} {} as it has no name\",\n+                                tcx.def_descr_article(did.to_def_id()),\n+                                tcx.def_descr(did.to_def_id()),\n+                            ),\n+                        )\n+                        .emit();\n+                }\n             }\n+            sym::no_coverage => codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE,\n             sym::rustc_std_internal_symbol => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL\n             }\n             sym::used => {\n                 let inner = attr.meta_item_list();\n@@ -207,11 +202,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                     struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n                     .emit();\n                 }\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-            }\n-            sym::thread_local => {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY\n             }\n+            sym::thread_local => codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL,\n             sym::track_caller => {\n                 if !tcx.is_closure(did.to_def_id())\n                     && let Some(fn_sig) = fn_sig()\n@@ -229,7 +222,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                     )\n                     .emit();\n                 }\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER\n             }\n             sym::export_name => {\n                 if let Some(s) = attr.value_str() {\n@@ -306,20 +299,14 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n             sym::link_section => {\n                 if let Some(val) = attr.value_str() {\n                     if val.as_str().bytes().any(|b| b == 0) {\n-                        let msg = format!(\n-                            \"illegal null byte in link_section \\\n-                             value: `{}`\",\n-                            &val\n-                        );\n+                        let msg = format!(\"illegal null byte in link_section value: `{}`\", &val);\n                         tcx.sess.span_err(attr.span, &msg);\n                     } else {\n                         codegen_fn_attrs.link_section = Some(val);\n                     }\n                 }\n             }\n-            sym::link_name => {\n-                codegen_fn_attrs.link_name = attr.value_str();\n-            }\n+            sym::link_name => codegen_fn_attrs.link_name = attr.value_str(),\n             sym::link_ordinal => {\n                 link_ordinal_span = Some(attr.span);\n                 if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n@@ -330,37 +317,27 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                 no_sanitize_span = Some(attr.span);\n                 if let Some(list) = attr.meta_item_list() {\n                     for item in list.iter() {\n-                        match item.ident().map(|ident| ident.name) {\n-                            Some(sym::address) => {\n+                        match item.name_or_empty() {\n+                            sym::address => {\n                                 codegen_fn_attrs.no_sanitize |=\n-                                    SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS;\n-                            }\n-                            Some(sym::cfi) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                                    SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS\n                             }\n-                            Some(sym::kcfi) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n+                            sym::cfi => codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI,\n+                            sym::kcfi => codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI,\n+                            sym::memory => codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY,\n+                            sym::memtag => codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG,\n+                            sym::shadow_call_stack => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK\n                             }\n-                            Some(sym::memory) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                            }\n-                            Some(sym::memtag) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n-                            }\n-                            Some(sym::shadow_call_stack) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n-                            }\n-                            Some(sym::thread) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n-                            }\n-                            Some(sym::hwaddress) => {\n-                                codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+                            sym::thread => codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD,\n+                            sym::hwaddress => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS\n                             }\n                             _ => {\n                                 tcx.sess\n-                                .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                                .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                                .emit();\n+                                    .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                                    .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                                    .emit();\n                             }\n                         }\n                     }"}, {"sha": "f88c055a9b56972558c25a6799cd58069fbd910c", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -5,7 +5,7 @@ use std::collections::hash_map::RawEntryMut;\n use std::hash::{Hash, Hasher};\n use std::mem;\n \n-#[derive(Clone, Default)]\n+#[derive(Default)]\n #[cfg_attr(parallel_compiler, repr(align(64)))]\n struct CacheAligned<T>(T);\n \n@@ -21,7 +21,6 @@ const SHARD_BITS: usize = 0;\n pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n-#[derive(Clone)]\n pub struct Sharded<T> {\n     shards: [CacheAligned<Lock<T>>; SHARDS],\n }"}, {"sha": "4e2126fff7be9e730b073ddd4e95a50ab21252e6", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -1,21 +1,46 @@\n-//! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n+//! This module defines various operations and types that are implemented in\n+//! one way for the serial compiler, and another way the parallel compiler.\n //!\n-//! `Lrc` is an alias of `Arc` if cfg!(parallel_compiler) is true, `Rc` otherwise.\n+//! Operations\n+//! ----------\n+//! The parallel versions of operations use Rayon to execute code in parallel,\n+//! while the serial versions degenerate straightforwardly to serial execution.\n+//! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `Lock` is a mutex.\n-//! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n+//! serial version and `Erased + Send + Sync` for the parallel version.\n //!\n-//! `RwLock` is a read-write lock.\n-//! It internally uses `parking_lot::RwLock` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! Types\n+//! -----\n+//! The parallel versions of types provide various kinds of synchronization,\n+//! while the serial compiler versions do not.\n //!\n-//! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n+//! The following table shows how the types are implemented internally. Except\n+//! where noted otherwise, the type in column one is defined as a\n+//! newtype around the type from column two or three.\n //!\n-//! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n+//! | Type                    | Serial version      | Parallel version                |\n+//! | ----------------------- | ------------------- | ------------------------------- |\n+//! | `Lrc<T>`                | `rc::Rc<T>`         | `sync::Arc<T>`                  |\n+//! |` Weak<T>`               | `rc::Weak<T>`       | `sync::Weak<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `AtomicBool`            | `Cell<bool>`        | `atomic::AtomicBool`            |\n+//! | `AtomicU32`             | `Cell<u32>`         | `atomic::AtomicU32`             |\n+//! | `AtomicU64`             | `Cell<u64>`         | `atomic::AtomicU64`             |\n+//! | `AtomicUsize`           | `Cell<usize>`       | `atomic::AtomicUsize`           |\n+//! |                         |                     |                                 |\n+//! | `Lock<T>`               | `RefCell<T>`        | `parking_lot::Mutex<T>`         |\n+//! | `RwLock<T>`             | `RefCell<T>`        | `parking_lot::RwLock<T>`        |\n+//! | `MTLock<T>`        [^1] | `T`                 | `Lock<T>`                       |\n+//! | `MTLockRef<'a, T>` [^2] | `&'a mut MTLock<T>` | `&'a MTLock<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `ParallelIterator`      | `Iterator`          | `rayon::iter::ParallelIterator` |\n //!\n-//! `rustc_erase_owner!` erases an OwningRef owner into Erased or Erased + Send + Sync\n-//! depending on the value of cfg!(parallel_compiler).\n+//! [^1] `MTLock` is similar to `Lock`, but the serial version avoids the cost\n+//! of a `RefCell`. This is appropriate when interior mutability is not\n+//! required.\n+//!\n+//! [^2] `MTLockRef` is a typedef.\n \n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n@@ -209,7 +234,7 @@ cfg_if! {\n             }\n         }\n \n-        pub type MTRef<'a, T> = &'a mut T;\n+        pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(T);\n@@ -267,7 +292,7 @@ cfg_if! {\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n-        pub type MTRef<'a, T> = &'a T;\n+        pub type MTLockRef<'a, T> = &'a MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(Lock<T>);\n@@ -553,18 +578,6 @@ impl<T> RwLock<T> {\n         self.write()\n     }\n \n-    #[cfg(not(parallel_compiler))]\n-    #[inline(always)]\n-    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n-        ReadGuard::clone(rg)\n-    }\n-\n-    #[cfg(parallel_compiler)]\n-    #[inline(always)]\n-    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n-        ReadGuard::rwlock(&rg).read()\n-    }\n-\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn leak(&self) -> &T {"}, {"sha": "967fed687b6a8de21f9d27c20d5c695766314fe4", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::def_id::LocalDefId;\n+use rustc_span::def_id::{LocalDefId, CRATE_DEF_ID};\n use std::hash::Hash;\n \n /// Represents the levels of effective visibility an item can have.\n@@ -107,6 +107,10 @@ impl EffectiveVisibilities {\n         })\n     }\n \n+    pub fn update_root(&mut self) {\n+        self.map.insert(CRATE_DEF_ID, EffectiveVisibility::from_vis(Visibility::Public));\n+    }\n+\n     // FIXME: Share code with `fn update`.\n     pub fn update_eff_vis(\n         &mut self,"}, {"sha": "7ca18fca18c147815037bef92d16c02f4f2676d0", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -174,7 +174,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::{par_for_each_in, MTLock, MTRef};\n+use rustc_data_structures::sync::{par_for_each_in, MTLock, MTLockRef};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n@@ -341,8 +341,8 @@ pub fn collect_crate_mono_items(\n     let recursion_limit = tcx.recursion_limit();\n \n     {\n-        let visited: MTRef<'_, _> = &mut visited;\n-        let inlining_map: MTRef<'_, _> = &mut inlining_map;\n+        let visited: MTLockRef<'_, _> = &mut visited;\n+        let inlining_map: MTLockRef<'_, _> = &mut inlining_map;\n \n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_for_each_in(roots, |root| {\n@@ -407,10 +407,10 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n-    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n+    visited: MTLockRef<'_, FxHashSet<MonoItem<'tcx>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     recursion_limit: Limit,\n-    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+    inlining_map: MTLockRef<'_, InliningMap<'tcx>>,\n ) {\n     if !visited.lock_mut().insert(starting_point.node) {\n         // We've been here already, no need to search again."}, {"sha": "51a0a3e9a197c5d7998f69385f5bbc93335ad72c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -2149,6 +2149,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n \n     let mut check_visitor =\n         TestReachabilityVisitor { tcx, effective_visibilities: &visitor.effective_visibilities };\n+    check_visitor.effective_visibility_diagnostic(CRATE_DEF_ID);\n     tcx.hir().visit_all_item_likes_in_crate(&mut check_visitor);\n \n     tcx.arena.alloc(visitor.effective_visibilities)"}, {"sha": "d3efc22a194515a0a67d6e94fe3709216d1072e9", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -21,9 +21,6 @@ pub trait QueryCache: Sized {\n     type Value: Copy + Debug;\n \n     /// Checks if the query is already computed and in the cache.\n-    /// It returns the shard index and a lock guard to the shard,\n-    /// which will be used if the query is not in the cache and we need\n-    /// to compute it.\n     fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n \n     fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex);"}, {"sha": "3673f603d16767eae28d95f800c980cb3136fa58", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 29, "deletions": 41, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -61,7 +61,7 @@ impl Resolver<'_, '_> {\n         // For mod items `nearest_normal_mod` returns its argument, but we actually need its parent.\n         let normal_mod_id = self.nearest_normal_mod(def_id);\n         if normal_mod_id == def_id {\n-            self.tcx.opt_local_parent(def_id).map_or(Visibility::Public, Visibility::Restricted)\n+            Visibility::Restricted(self.tcx.local_parent(def_id))\n         } else {\n             Visibility::Restricted(normal_mod_id)\n         }\n@@ -80,12 +80,11 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n             r,\n             def_effective_visibilities: Default::default(),\n             import_effective_visibilities: Default::default(),\n-            current_private_vis: Visibility::Public,\n+            current_private_vis: Visibility::Restricted(CRATE_DEF_ID),\n             changed: false,\n         };\n \n-        visitor.update(CRATE_DEF_ID, CRATE_DEF_ID);\n-        visitor.current_private_vis = Visibility::Restricted(CRATE_DEF_ID);\n+        visitor.def_effective_visibilities.update_root();\n         visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n@@ -125,43 +124,32 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n \n         for (_, name_resolution) in resolutions.borrow().iter() {\n             if let Some(mut binding) = name_resolution.borrow().binding() {\n-                if !binding.is_ambiguity() {\n-                    // Set the given effective visibility level to `Level::Direct` and\n-                    // sets the rest of the `use` chain to `Level::Reexported` until\n-                    // we hit the actual exported item.\n-                    let mut parent_id = ParentId::Def(module_id);\n-                    while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind\n-                    {\n-                        let binding_id = ImportId::new_unchecked(binding);\n-                        self.update_import(binding_id, parent_id);\n-\n-                        parent_id = ParentId::Import(binding_id);\n-                        binding = nested_binding;\n-                    }\n-\n-                    if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                        self.update_def(def_id, binding.vis.expect_local(), parent_id);\n+                // Set the given effective visibility level to `Level::Direct` and\n+                // sets the rest of the `use` chain to `Level::Reexported` until\n+                // we hit the actual exported item.\n+                //\n+                // If the binding is ambiguous, put the root ambiguity binding and all reexports\n+                // leading to it into the table. They are used by the `ambiguous_glob_reexports`\n+                // lint. For all bindings added to the table this way `is_ambiguity` returns true.\n+                let mut parent_id = ParentId::Def(module_id);\n+                while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind {\n+                    let binding_id = ImportId::new_unchecked(binding);\n+                    self.update_import(binding_id, parent_id);\n+\n+                    if binding.ambiguity.is_some() {\n+                        // Stop at the root ambiguity, further bindings in the chain should not\n+                        // be reexported because the root ambiguity blocks any access to them.\n+                        // (Those further bindings are most likely not ambiguities themselves.)\n+                        break;\n                     }\n-                } else {\n-                    // Put the root ambiguity binding and all reexports leading to it into the\n-                    // table. They are used by the `ambiguous_glob_reexports` lint. For all\n-                    // bindings added to the table here `is_ambiguity` returns true.\n-                    let mut parent_id = ParentId::Def(module_id);\n-                    while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind\n-                    {\n-                        let binding_id = ImportId::new_unchecked(binding);\n-                        self.update_import(binding_id, parent_id);\n \n-                        if binding.ambiguity.is_some() {\n-                            // Stop at the root ambiguity, further bindings in the chain should not\n-                            // be reexported because the root ambiguity blocks any access to them.\n-                            // (Those further bindings are most likely not ambiguities themselves.)\n-                            break;\n-                        }\n+                    parent_id = ParentId::Import(binding_id);\n+                    binding = nested_binding;\n+                }\n \n-                        parent_id = ParentId::Import(binding_id);\n-                        binding = nested_binding;\n-                    }\n+                if binding.ambiguity.is_none()\n+                    && let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n+                    self.update_def(def_id, binding.vis.expect_local(), parent_id);\n                 }\n             }\n         }\n@@ -213,7 +201,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         );\n     }\n \n-    fn update(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n+    fn update_field(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n         self.update_def(def_id, self.r.visibilities[&def_id], ParentId::Def(parent_id));\n     }\n }\n@@ -245,14 +233,14 @@ impl<'r, 'ast, 'tcx> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r, 't\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n-                        self.update(self.r.local_def_id(field.id), variant_def_id);\n+                        self.update_field(self.r.local_def_id(field.id), variant_def_id);\n                     }\n                 }\n             }\n \n             ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n-                    self.update(self.r.local_def_id(field.id), def_id);\n+                    self.update_field(self.r.local_def_id(field.id), def_id);\n                 }\n             }\n "}, {"sha": "40879db49def9bba2c57990253a3816ab064507f", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -68,6 +68,7 @@ fn current_dll_path() -> Result<PathBuf, String> {\n     use std::ffi::{CStr, OsStr};\n     use std::os::unix::prelude::*;\n \n+    #[cfg(not(target_os = \"aix\"))]\n     unsafe {\n         let addr = current_dll_path as usize as *mut _;\n         let mut info = std::mem::zeroed();\n@@ -81,6 +82,49 @@ fn current_dll_path() -> Result<PathBuf, String> {\n         let os = OsStr::from_bytes(bytes);\n         Ok(PathBuf::from(os))\n     }\n+\n+    #[cfg(target_os = \"aix\")]\n+    unsafe {\n+        // On AIX, the symbol `current_dll_path` references a function descriptor.\n+        // A function descriptor is consisted of (See https://reviews.llvm.org/D62532)\n+        // * The address of the entry point of the function.\n+        // * The TOC base address for the function.\n+        // * The environment pointer.\n+        // The function descriptor is in the data section.\n+        let addr = current_dll_path as u64;\n+        let mut buffer = vec![std::mem::zeroed::<libc::ld_info>(); 64];\n+        loop {\n+            if libc::loadquery(\n+                libc::L_GETINFO,\n+                buffer.as_mut_ptr() as *mut i8,\n+                (std::mem::size_of::<libc::ld_info>() * buffer.len()) as u32,\n+            ) >= 0\n+            {\n+                break;\n+            } else {\n+                if std::io::Error::last_os_error().raw_os_error().unwrap() != libc::ENOMEM {\n+                    return Err(\"loadquery failed\".into());\n+                }\n+                buffer.resize(buffer.len() * 2, std::mem::zeroed::<libc::ld_info>());\n+            }\n+        }\n+        let mut current = buffer.as_mut_ptr() as *mut libc::ld_info;\n+        loop {\n+            let data_base = (*current).ldinfo_dataorg as u64;\n+            let data_end = data_base + (*current).ldinfo_datasize;\n+            if (data_base..data_end).contains(&addr) {\n+                let bytes = CStr::from_ptr(&(*current).ldinfo_filename[0]).to_bytes();\n+                let os = OsStr::from_bytes(bytes);\n+                return Ok(PathBuf::from(os));\n+            }\n+            if (*current).ldinfo_next == 0 {\n+                break;\n+            }\n+            current =\n+                (current as *mut i8).offset((*current).ldinfo_next as isize) as *mut libc::ld_info;\n+        }\n+        return Err(format!(\"current dll's address {} is not in the load map\", addr));\n+    }\n }\n \n #[cfg(windows)]"}, {"sha": "705e79aebd8c1ffbfa998bb664e15a481f6ae6e8", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -67,7 +67,20 @@ pub(super) enum IsNormalizesToHack {\n \n #[derive(Debug, Clone)]\n pub(super) struct NestedGoals<'tcx> {\n+    /// This normalizes-to goal that is treated specially during the evaluation\n+    /// loop. In each iteration we take the RHS of the projection, replace it with\n+    /// a fresh inference variable, and only after evaluating that goal do we\n+    /// equate the fresh inference variable with the actual RHS of the predicate.\n+    ///\n+    /// This is both to improve caching, and to avoid using the RHS of the\n+    /// projection predicate to influence the normalizes-to candidate we select.\n+    ///\n+    /// This is not a 'real' nested goal. We must not forget to replace the RHS\n+    /// with a fresh inference variable when we evaluate this goal. That can result\n+    /// in a trait solver cycle. This would currently result in overflow but can be\n+    /// can be unsound with more powerful coinduction in the future.\n     pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    /// The rest of the goals which have not yet processed or remain ambiguous.\n     pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n }\n \n@@ -182,6 +195,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             canonical_response,\n         )?;\n \n+        if !has_changed && !nested_goals.is_empty() {\n+            bug!(\"an unchanged goal shouldn't have any side-effects on instantiation\");\n+        }\n+\n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n         //\n@@ -199,9 +216,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+                bug!(\n+                    \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n+            }\n+            if certainty != canonical_response.value.certainty {\n+                bug!(\n+                    \"unstable certainty: {certainty:#?} re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n             }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n         Ok((has_changed, certainty, nested_goals))\n@@ -281,15 +306,44 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n-                        IsNormalizesToHack::Yes,\n-                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    // Replace the goal with an unconstrained infer var, so the\n+                    // RHS does not affect projection candidate assembly.\n+                    let unconstrained_rhs = this.next_term_infer_of_kind(goal.predicate.term);\n+                    let unconstrained_goal = goal.with(\n+                        this.tcx(),\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: goal.predicate.projection_ty,\n+                            term: unconstrained_rhs,\n+                        }),\n+                    );\n+\n+                    let (_, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::Yes, unconstrained_goal) {\n+                            Ok(r) => r,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+                    new_goals.goals.extend(instantiate_goals);\n+\n+                    // Finally, equate the goal's RHS with the unconstrained var.\n+                    // We put the nested goals from this into goals instead of\n+                    // next_goals to avoid needing to process the loop one extra\n+                    // time if this goal returns something -- I don't think this\n+                    // matters in practice, though.\n+                    match this.eq_and_get_goals(\n+                        goal.param_env,\n+                        goal.predicate.term,\n+                        unconstrained_rhs,\n                     ) {\n-                        Ok(r) => r,\n+                        Ok(eq_goals) => {\n+                            goals.goals.extend(eq_goals);\n+                        }\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n-                    new_goals.goals.extend(nested_goals);\n \n+                    // We only look at the `projection_ty` part here rather than\n+                    // looking at the \"has changed\" return from evaluate_goal,\n+                    // because we expect the `unconstrained_rhs` part of the predicate\n+                    // to have changed -- that means we actually normalized successfully!\n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n                     {\n@@ -299,40 +353,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            let goal = this.resolve_vars_if_possible(goal);\n-\n-                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n-                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n-                            // regardless of the rhs.\n-                            //\n-                            // However it is important not to unconditionally replace the rhs with a new infer var\n-                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n-                            // and never propagate any constraints on the new var back to the original var.\n-                            let term = this\n-                                .term_is_fully_unconstrained(goal)\n-                                .then_some(goal.predicate.term)\n-                                .unwrap_or_else(|| {\n-                                    this.next_term_infer_of_kind(goal.predicate.term)\n-                                });\n-                            let projection_pred = ty::ProjectionPredicate {\n-                                term,\n-                                projection_ty: goal.predicate.projection_ty,\n-                            };\n+                            // We need to resolve vars here so that we correctly\n+                            // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n-                                Some(goal.with(this.tcx(), projection_pred));\n-\n+                                Some(this.resolve_vars_if_possible(goal));\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }\n                 }\n \n-                for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty, nested_goals) =\n-                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                for goal in goals.goals.drain(..) {\n+                    let (changed, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n-                    new_goals.goals.extend(nested_goals);\n+                    new_goals.goals.extend(instantiate_goals);\n \n                     if changed {\n                         has_changed = Ok(());\n@@ -341,7 +377,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            new_goals.goals.push(nested_goal);\n+                            new_goals.goals.push(goal);\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }"}, {"sha": "da713268f1123ddd54756662327db540ba825046", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -34,16 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n             self.merge_candidates(candidates)\n         } else {\n-            let predicate = goal.predicate;\n-            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n-            let unconstrained_predicate = ProjectionPredicate {\n-                projection_ty: goal.predicate.projection_ty,\n-                term: unconstrained_rhs,\n-            };\n-\n-            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n-            self.try_evaluate_added_goals()?;\n-            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.set_normalizes_to_hack_goal(goal);\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }"}, {"sha": "fcb965dd725af297d4e5565d7017d733214f666f", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -214,9 +214,20 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n         ty::Closure(_, substs) => {\n             let closure_substs = substs.as_closure();\n             match closure_substs.kind_ty().to_opt_closure_kind() {\n-                Some(closure_kind) if closure_kind.extends(goal_kind) => {}\n-                None => return Ok(None),\n-                _ => return Err(NoSolution),\n+                // If the closure's kind doesn't extend the goal kind,\n+                // then the closure doesn't implement the trait.\n+                Some(closure_kind) => {\n+                    if !closure_kind.extends(goal_kind) {\n+                        return Err(NoSolution);\n+                    }\n+                }\n+                // Closure kind is not yet determined, so we return ambiguity unless\n+                // the expected kind is `FnOnce` as that is always implemented.\n+                None => {\n+                    if goal_kind != ty::ClosureKind::FnOnce {\n+                        return Ok(None);\n+                    }\n+                }\n             }\n             Ok(Some(closure_substs.sig().map_bound(|sig| (sig.inputs()[0], sig.output()))))\n         }"}, {"sha": "c76baa27f38a0f73eeb2140d5c653bd0d2ef8822", "filename": "tests/ui/attributes/no-mangle-closure.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fattributes%2Fno-mangle-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fattributes%2Fno-mangle-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Fno-mangle-closure.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -0,0 +1,11 @@\n+// Check that we do not ICE when `no_mangle` is applied to something that has no name.\n+\n+#![crate_type = \"lib\"]\n+#![feature(stmt_expr_attributes)]\n+\n+pub struct S([usize; 8]);\n+\n+pub fn outer_function(x: S, y: S) -> usize {\n+    (#[no_mangle] || y.0[0])()\n+    //~^ ERROR `#[no_mangle]` cannot be used on a closure as it has no name\n+}"}, {"sha": "949eb70510e4d2bc3bc8425c15e21457b276d898", "filename": "tests/ui/attributes/no-mangle-closure.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fattributes%2Fno-mangle-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fattributes%2Fno-mangle-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Fno-mangle-closure.stderr?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -0,0 +1,8 @@\n+error: `#[no_mangle]` cannot be used on a closure as it has no name\n+  --> $DIR/no-mangle-closure.rs:9:6\n+   |\n+LL |     (#[no_mangle] || y.0[0])()\n+   |      ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3e9eef462306cb33c0b17e43e8dfcc4d68e360a6", "filename": "tests/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -1,3 +1,4 @@\n+#![rustc_effective_visibility] //~ ERROR Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n #![feature(rustc_attrs)]\n \n #[rustc_effective_visibility]"}, {"sha": "2618fc427e917c5e7e84648ac7e561d24b86ee59", "filename": "tests/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -1,140 +1,152 @@\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:1:1\n+   |\n+LL | / #![rustc_effective_visibility]\n+LL | | #![feature(rustc_attrs)]\n+LL | |\n+LL | | #[rustc_effective_visibility]\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n-  --> $DIR/effective_visibilities.rs:4:1\n+  --> $DIR/effective_visibilities.rs:5:1\n    |\n LL | mod outer {\n    | ^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:6:5\n+  --> $DIR/effective_visibilities.rs:7:5\n    |\n LL |     pub mod inner1 {\n    |     ^^^^^^^^^^^^^^\n \n error: not in the table\n-  --> $DIR/effective_visibilities.rs:9:9\n+  --> $DIR/effective_visibilities.rs:10:9\n    |\n LL |         extern \"C\" {}\n    |         ^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:12:9\n+  --> $DIR/effective_visibilities.rs:13:9\n    |\n LL |         pub trait PubTrait {\n    |         ^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n-  --> $DIR/effective_visibilities.rs:20:9\n+  --> $DIR/effective_visibilities.rs:21:9\n    |\n LL |         struct PrivStruct;\n    |         ^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n-  --> $DIR/effective_visibilities.rs:20:9\n+  --> $DIR/effective_visibilities.rs:21:9\n    |\n LL |         struct PrivStruct;\n    |         ^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:24:9\n+  --> $DIR/effective_visibilities.rs:25:9\n    |\n LL |         pub union PubUnion {\n    |         ^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n-  --> $DIR/effective_visibilities.rs:26:13\n+  --> $DIR/effective_visibilities.rs:27:13\n    |\n LL |             a: u8,\n    |             ^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:28:13\n+  --> $DIR/effective_visibilities.rs:29:13\n    |\n LL |             pub b: u8,\n    |             ^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:32:9\n+  --> $DIR/effective_visibilities.rs:33:9\n    |\n LL |         pub enum Enum {\n    |         ^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:34:13\n+  --> $DIR/effective_visibilities.rs:35:13\n    |\n LL |             A(\n    |             ^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:34:13\n+  --> $DIR/effective_visibilities.rs:35:13\n    |\n LL |             A(\n    |             ^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:37:17\n+  --> $DIR/effective_visibilities.rs:38:17\n    |\n LL |                 PubUnion,\n    |                 ^^^^^^^^\n \n error: not in the table\n-  --> $DIR/effective_visibilities.rs:43:5\n+  --> $DIR/effective_visibilities.rs:44:5\n    |\n LL |     macro_rules! none_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:49:5\n+  --> $DIR/effective_visibilities.rs:50:5\n    |\n LL |     macro_rules! public_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:54:5\n+  --> $DIR/effective_visibilities.rs:55:5\n    |\n LL |     pub struct ReachableStruct {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:56:9\n+  --> $DIR/effective_visibilities.rs:57:9\n    |\n LL |         pub a: u8,\n    |         ^^^^^^^^^\n \n error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:61:9\n+  --> $DIR/effective_visibilities.rs:62:9\n    |\n LL | pub use outer::inner1;\n    |         ^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:67:5\n+  --> $DIR/effective_visibilities.rs:68:5\n    |\n LL |     pub type HalfPublicImport = u8;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n-  --> $DIR/effective_visibilities.rs:70:5\n+  --> $DIR/effective_visibilities.rs:71:5\n    |\n LL |     pub(crate) const HalfPublicImport: u8 = 0;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:74:9\n+  --> $DIR/effective_visibilities.rs:75:9\n    |\n LL | pub use half_public_import::HalfPublicImport;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:14:13\n+  --> $DIR/effective_visibilities.rs:15:13\n    |\n LL |             const A: i32;\n    |             ^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:16:13\n+  --> $DIR/effective_visibilities.rs:17:13\n    |\n LL |             type B;\n    |             ^^^^^^\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "d2ad0cc0316e3d4925f6f03eca422bd043567de1", "filename": "tests/ui/traits/new-solver/closure-inference-guidance.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Ftraits%2Fnew-solver%2Fclosure-inference-guidance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3610ac1ddd1cd605479274047fd0a3f37d220/tests%2Fui%2Ftraits%2Fnew-solver%2Fclosure-inference-guidance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fclosure-inference-guidance.rs?ref=c1d3610ac1ddd1cd605479274047fd0a3f37d220", "patch": "@@ -0,0 +1,11 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+fn foo(i: isize) -> isize { i + 1 }\n+\n+fn apply<A, F>(f: F, v: A) -> A where F: FnOnce(A) -> A { f(v) }\n+\n+pub fn main() {\n+    let f = |i| foo(i);\n+    assert_eq!(apply(f, 2), 3);\n+}"}]}