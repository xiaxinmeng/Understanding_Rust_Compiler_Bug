{"sha": "57d8206093aaa877c01258a55455aad41ec7d99e", "node_id": "C_kwDOAAsO6NoAKDU3ZDgyMDYwOTNhYWE4NzdjMDEyNThhNTU0NTVhYWQ0MWVjN2Q5OWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-30T21:41:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-30T21:41:41Z"}, "message": "Auto merge of #2165 - saethlin:more-clocks, r=RalfJung\n\nAdd support for _COARSE clocks\n\nOriginal idea does not work, so I'm just going to try expanding support to include the `_COARSE` clocks.\n\nThe original motivation for this PR is that the test suite for the crate [`minstant`](https://crates.io/crates/minstant) reports UB, because it tries to use a clock type Miri didn't support, but never checked for an error code and so just used the uninit `libc::timespec`. So, that's technically a bug in `minstant`, but outside of Miri you'd have to be using an incredibly old Linux to ever see an `EINVAL` so the more helpful thing for Miri to do is behave like a newer Linux.\n\nSo now we don't detect UB in `minstant`, but we have a test failure:\n```\nfailures:\n\n---- src/instant.rs - instant::Instant::as_unix_nanos (line 150) stdout ----\nTest executable failed (exit status: 101).\n\nstderr:\nthread 'main' panicked at 'assertion failed: (instant.as_unix_nanos(&anchor) as i64 - expected as i64).abs() < 1_000_000', src/instant.rs:11:1\n```\nI'm having trouble getting my head around the code in `minstant` that's involved in this test, but as far as I can tell from the man pages, these `_COARSE` clocks meet the requirements.\n\nCloses https://github.com/rust-lang/miri/issues/1983 at least as best as I can.", "tree": {"sha": "9196f4abd8a5c3c40ebd21c2f26d538ad3e2b7b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9196f4abd8a5c3c40ebd21c2f26d538ad3e2b7b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57d8206093aaa877c01258a55455aad41ec7d99e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57d8206093aaa877c01258a55455aad41ec7d99e", "html_url": "https://github.com/rust-lang/rust/commit/57d8206093aaa877c01258a55455aad41ec7d99e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57d8206093aaa877c01258a55455aad41ec7d99e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "065ff89e33b67b3527fcdd56cf8b432e593e32d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/065ff89e33b67b3527fcdd56cf8b432e593e32d4", "html_url": "https://github.com/rust-lang/rust/commit/065ff89e33b67b3527fcdd56cf8b432e593e32d4"}, {"sha": "ba9391334e8d23261eb09ce7162015993f7c2aa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba9391334e8d23261eb09ce7162015993f7c2aa3", "html_url": "https://github.com/rust-lang/rust/commit/ba9391334e8d23261eb09ce7162015993f7c2aa3"}], "stats": {"total": 47, "additions": 43, "deletions": 4}, "files": [{"sha": "be453a429ec5192616e31f6741b47cba0f865c53", "filename": "src/shims/time.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57d8206093aaa877c01258a55455aad41ec7d99e/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d8206093aaa877c01258a55455aad41ec7d99e/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=57d8206093aaa877c01258a55455aad41ec7d99e", "patch": "@@ -16,18 +16,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         clk_id_op: &OpTy<'tcx, Tag>,\n         tp_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n+        // This clock support is deliberately minimal because a lot of clock types have fiddly\n+        // properties (is it possible for Miri to be suspended independently of the host?). If you\n+        // have a use for another clock type, please open an issue.\n+\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"clock_gettime\");\n         this.check_no_isolation(\"`clock_gettime`\")?;\n \n         let clk_id = this.read_scalar(clk_id_op)?.to_i32()?;\n \n-        let duration = if clk_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n+        // Linux has two main kinds of clocks. REALTIME clocks return the actual time since the\n+        // Unix epoch, including effects which may cause time to move backwards such as NTP.\n+        // Linux further distinguishes regular and \"coarse\" clocks, but the \"coarse\" version\n+        // is just specified to be \"faster and less precise\", so we implement both the same way.\n+        let absolute_clocks =\n+            [this.eval_libc_i32(\"CLOCK_REALTIME\")?, this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\")?];\n+        // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n+        // never allowed to go backwards. We don't need to do any additonal monotonicity\n+        // enforcement because std::time::Instant already guarantees that it is monotonic.\n+        let relative_clocks =\n+            [this.eval_libc_i32(\"CLOCK_MONOTONIC\")?, this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?];\n+\n+        let duration = if absolute_clocks.contains(&clk_id) {\n             system_time_to_duration(&SystemTime::now())?\n-        } else if clk_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n-            // Absolute time does not matter, only relative time does, so we can just\n-            // use our own time anchor here.\n+        } else if relative_clocks.contains(&clk_id) {\n             Instant::now().duration_since(this.machine.time_anchor)\n         } else {\n             let einval = this.eval_libc(\"EINVAL\")?;"}, {"sha": "bf5ae98290118b391ee3d1a2098a78af91511ad9", "filename": "tests/run-pass/libc.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/57d8206093aaa877c01258a55455aad41ec7d99e/tests%2Frun-pass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d8206093aaa877c01258a55455aad41ec7d99e/tests%2Frun-pass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.rs?ref=57d8206093aaa877c01258a55455aad41ec7d99e", "patch": "@@ -230,6 +230,28 @@ fn test_thread_local_errno() {\n     }\n }\n \n+/// Tests whether clock support exists at all\n+#[cfg(target_os = \"linux\")]\n+fn test_clocks() {\n+    let mut tp = std::mem::MaybeUninit::<libc::timespec>::uninit();\n+    let is_error = unsafe {\n+        libc::clock_gettime(libc::CLOCK_REALTIME, tp.as_mut_ptr())\n+    };\n+    assert_eq!(is_error, 0);\n+    let is_error = unsafe {\n+        libc::clock_gettime(libc::CLOCK_REALTIME_COARSE, tp.as_mut_ptr())\n+    };\n+    assert_eq!(is_error, 0);\n+     let is_error = unsafe {\n+        libc::clock_gettime(libc::CLOCK_MONOTONIC, tp.as_mut_ptr())\n+    };\n+    assert_eq!(is_error, 0);\n+    let is_error = unsafe {\n+        libc::clock_gettime(libc::CLOCK_MONOTONIC_COARSE, tp.as_mut_ptr())\n+    };\n+    assert_eq!(is_error, 0);\n+}\n+\n fn main() {\n     #[cfg(target_os = \"linux\")]\n     test_posix_fadvise();\n@@ -249,4 +271,7 @@ fn main() {\n     test_prctl_thread_name();\n \n     test_thread_local_errno();\n+\n+    #[cfg(target_os = \"linux\")]\n+    test_clocks();\n }"}]}