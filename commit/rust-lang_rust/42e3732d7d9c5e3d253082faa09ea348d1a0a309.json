{"sha": "42e3732d7d9c5e3d253082faa09ea348d1a0a309", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZTM3MzJkN2Q5YzVlM2QyNTMwODJmYWEwOWVhMzQ4ZDFhMGEzMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-17T04:21:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-17T04:21:06Z"}, "message": "Auto merge of #41476 - abonander:book_proc_macro, r=nrc\n\nDocument the `proc_macro` feature in the Unstable Book\n\nDiscusses the `proc_macro` feature flag and the features it enables:\n\n* Implicit enable of `extern_use_macros` feature and how to import proc macros\n* Error handling in proc macros (using panic messages)\n* Function-like proc macros using `#[proc_macro]` and a usage example for creating and invoking\n* Attribute-like proc macros using `#[proc_macro_attribute]` and a usage example for creating and invoking\n\n[Rendered](https://github.com/abonander/rust/blob/book_proc_macro/src/doc/unstable-book/src/language-features/proc-macro.md)", "tree": {"sha": "0a46452637c5ac5e2ea027e46320130eeec39af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a46452637c5ac5e2ea027e46320130eeec39af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42e3732d7d9c5e3d253082faa09ea348d1a0a309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42e3732d7d9c5e3d253082faa09ea348d1a0a309", "html_url": "https://github.com/rust-lang/rust/commit/42e3732d7d9c5e3d253082faa09ea348d1a0a309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42e3732d7d9c5e3d253082faa09ea348d1a0a309/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8215fc238a974950fcd4155a34f5383ebb589b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8215fc238a974950fcd4155a34f5383ebb589b9", "html_url": "https://github.com/rust-lang/rust/commit/d8215fc238a974950fcd4155a34f5383ebb589b9"}, {"sha": "e616d12cbbe2b38ab3d683233e716104ca56d388", "url": "https://api.github.com/repos/rust-lang/rust/commits/e616d12cbbe2b38ab3d683233e716104ca56d388", "html_url": "https://github.com/rust-lang/rust/commit/e616d12cbbe2b38ab3d683233e716104ca56d388"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "1bd8c41629eea01712d001f940d2e797ee47138f", "filename": "src/doc/unstable-book/src/language-features/proc-macro.md", "status": "modified", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/42e3732d7d9c5e3d253082faa09ea348d1a0a309/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/42e3732d7d9c5e3d253082faa09ea348d1a0a309/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md?ref=42e3732d7d9c5e3d253082faa09ea348d1a0a309", "patch": "@@ -6,5 +6,236 @@ The tracking issue for this feature is: [#38356]\n \n ------------------------\n \n+This feature flag guards the new procedural macro features as laid out by [RFC 1566], which alongside the now-stable \n+[custom derives], provide stabilizable alternatives to the compiler plugin API (which requires the use of \n+perma-unstable internal APIs) for programmatically modifying Rust code at compile-time.\n \n+The two new procedural macro kinds are:\n+ \n+* Function-like procedural macros which are invoked like regular declarative macros, and:\n \n+* Attribute-like procedural macros which can be applied to any item which built-in attributes can\n+be applied to, and which can take arguments in their invocation as well.\n+\n+Additionally, this feature flag implicitly enables the [`use_extern_macros`](language-features/use-extern-macros.html) feature,\n+which allows macros to be imported like any other item with `use` statements, as compared to \n+applying `#[macro_use]` to an `extern crate` declaration. It is important to note that procedural macros may\n+**only** be imported in this manner, and will throw an error otherwise.\n+\n+You **must** declare the `proc_macro` feature in both the crate declaring these new procedural macro kinds as well as \n+in any crates that use them.\n+\n+### Common Concepts\n+\n+As with custom derives, procedural macros may only be declared in crates of the `proc-macro` type, and must be public\n+functions. No other public items may be declared in `proc-macro` crates, but private items are fine.\n+\n+To declare your crate as a `proc-macro` crate, simply add:\n+\n+```toml\n+[lib]\n+proc-macro = true\n+```\n+\n+to your `Cargo.toml`. \n+\n+Unlike custom derives, however, the name of the function implementing the procedural macro is used directly as the \n+procedural macro's name, so choose carefully.\n+\n+Additionally, both new kinds of procedural macros return a `TokenStream` which *wholly* replaces the original \n+invocation and its input.\n+\n+#### Importing\n+\n+As referenced above, the new procedural macros are not meant to be imported via `#[macro_use]` and will throw an \n+error if they are. Instead, they are meant to be imported like any other item in Rust, with `use` statements:\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+// Where `my_proc_macros` is some crate of type `proc_macro`\n+extern crate my_proc_macros;\n+\n+// And declares a `#[proc_macro] pub fn my_bang_macro()` at its root.\n+use my_proc_macros::my_bang_macro;\n+\n+fn main() {\n+    println!(\"{}\", my_bang_macro!());\n+}\n+```\n+\n+#### Error Reporting\n+\n+Any panics in a procedural macro implementation will be caught by the compiler and turned into an error message pointing \n+to the problematic invocation. Thus, it is important to make your panic messages as informative as possible: use \n+`Option::expect` instead of `Option::unwrap` and `Result::expect` instead of `Result::unwrap`, and inform the user of \n+the error condition as unambiguously as you can.\n+ \n+#### `TokenStream`\n+\n+The `proc_macro::TokenStream` type is hardcoded into the signatures of procedural macro functions for both input and \n+output. It is a wrapper around the compiler's internal representation for a given chunk of Rust code.\n+\n+### Function-like Procedural Macros\n+\n+These are procedural macros that are invoked like regular declarative macros. They are declared as public functions in \n+crates of the `proc_macro` type and using the `#[proc_macro]` attribute. The name of the declared function becomes the \n+name of the macro as it is to be imported and used. The function must be of the kind `fn(TokenStream) -> TokenStream` \n+where the sole argument is the input to the macro and the return type is the macro's output.\n+\n+This kind of macro can expand to anything that is valid for the context it is invoked in, including expressions and\n+statements, as well as items.\n+\n+**Note**: invocations of this kind of macro require a wrapping `[]`, `{}` or `()` like regular macros, but these do not \n+appear in the input, only the tokens between them. The tokens between the braces do not need to be valid Rust syntax.\n+\n+<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+// This is always necessary to get the `TokenStream` typedef.\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn say_hello(_input: TokenStream) -> TokenStream {\n+    // This macro will accept any input because it ignores it. \n+    // To enforce correctness in macros which don't take input,\n+    // you may want to add `assert!(_input.to_string().is_empty());`.\n+    \"println!(\\\"Hello, world!\\\")\".parse().unwrap()\n+}\n+```\n+\n+<span class=\"filename\">my_macro_user/Cargo.toml</span>\n+\n+```toml\n+[dependencies]\n+my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n+```\n+\n+<span class=\"filename\">my_macro_user/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+extern crate my_macro_crate;\n+\n+use my_macro_crate::say_hello;\n+\n+fn main() {\n+    say_hello!();\n+}\n+```\n+\n+As expected, this prints `Hello, world!`.\n+\n+### Attribute-like Procedural Macros\n+\n+These are arguably the most powerful flavor of procedural macro as they can be applied anywhere attributes are allowed. \n+\n+They are declared as public functions in crates of the `proc-macro` type, using the `#[proc_macro_attribute]` attribute. \n+The name of the function becomes the name of the attribute as it is to be imported and used. The function must be of the \n+kind `fn(TokenStream, TokenStream) -> TokenStream` where:\n+\n+The first argument represents any metadata for the attribute (see [the reference chapter on attributes][refr-attr]). \n+Only the metadata itself will appear in this argument, for example:\n+ \n+ * `#[my_macro]` will get an empty string.\n+ * `#[my_macro = \"string\"]` will get `= \"string\"`.\n+ * `#[my_macro(ident)]` will get `(ident)`.\n+ * etc.\n+ \n+The second argument is the item that the attribute is applied to. It can be a function, a type definition, \n+an impl block, an `extern` block, or a module\u2014attribute invocations can take the inner form (`#![my_attr]`) \n+or outer form (`#[my_attr]`).\n+\n+The return type is the output of the macro which *wholly* replaces the item it was applied to. Thus, if your intention\n+is to merely modify an item, it *must* be copied to the output. The output must be an item; expressions, statements\n+and bare blocks are not allowed.\n+\n+There is no restriction on how many items an attribute-like procedural macro can emit as long as they are valid in \n+the given context.\n+\n+<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+/// Adds a `/// ### Panics` docstring to the end of the input's documentation\n+///\n+/// Does not assert that its receiver is a function or method.\n+#[proc_macro_attribute]\n+pub fn panics_note(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let args = args.to_string();\n+    let mut input = input.to_string();\n+\n+    assert!(args.starts_with(\"= \\\"\"), \"`#[panics_note]` requires an argument of the form \\\n+                                       `#[panics_note = \\\"panic note here\\\"]`\");\n+\n+    // Get just the bare note string\n+    let panics_note = args.trim_matches(&['=', ' ', '\"'][..]);\n+\n+    // The input will include all docstrings regardless of where the attribute is placed,\n+    // so we need to find the last index before the start of the item\n+    let insert_idx = idx_after_last_docstring(&input);\n+\n+    // And insert our `### Panics` note there so it always appears at the end of an item's docs\n+    input.insert_str(insert_idx, &format!(\"/// # Panics \\n/// {}\\n\", panics_note));\n+\n+    input.parse().unwrap()\n+}\n+\n+// `proc-macro` crates can contain any kind of private item still\n+fn idx_after_last_docstring(input: &str) -> usize {\n+    // Skip docstring lines to find the start of the item proper\n+    input.lines().skip_while(|line| line.trim_left().starts_with(\"///\")).next()\n+        // Find the index of the first non-docstring line in the input\n+        // Note: assumes this exact line is unique in the input\n+        .and_then(|line_after| input.find(line_after))\n+        // No docstrings in the input\n+        .unwrap_or(0)\n+}\n+```\n+\n+<span class=\"filename\">my_macro_user/Cargo.toml</span>\n+\n+```toml\n+[dependencies]\n+my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n+```\n+\n+<span class=\"filename\">my_macro_user/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+extern crate my_macro_crate;\n+\n+use my_macro_crate::panics_note;\n+\n+/// Do the `foo` thing.\n+#[panics_note = \"Always.\"]\n+pub fn foo() {\n+    panic!()\n+}\n+```\n+\n+Then the rendered documentation for `pub fn foo` will look like this:\n+\n+> `pub fn foo()`\n+> \n+> ----\n+> Do the `foo` thing.\n+> # Panics\n+> Always.\n+\n+[RFC 1566]: https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md\n+[custom derives]: https://doc.rust-lang.org/book/procedural-macros.html\n+[rust-lang/rust#41430]: https://github.com/rust-lang/rust/issues/41430\n+[refr-attr]: https://doc.rust-lang.org/reference/attributes.html"}]}