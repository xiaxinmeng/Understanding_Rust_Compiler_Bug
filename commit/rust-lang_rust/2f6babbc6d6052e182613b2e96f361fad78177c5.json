{"sha": "2f6babbc6d6052e182613b2e96f361fad78177c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNmJhYmJjNmQ2MDUyZTE4MjYxM2IyZTk2ZjM2MWZhZDc4MTc3YzU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-07-07T15:34:06Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-11T14:00:42Z"}, "message": "Remove `is_self` and `has_self_ty` methods", "tree": {"sha": "1e0a15fb46c0b1523d4acbc384c22012469ab941", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e0a15fb46c0b1523d4acbc384c22012469ab941"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f6babbc6d6052e182613b2e96f361fad78177c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6babbc6d6052e182613b2e96f361fad78177c5", "html_url": "https://github.com/rust-lang/rust/commit/2f6babbc6d6052e182613b2e96f361fad78177c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f6babbc6d6052e182613b2e96f361fad78177c5/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee36cfaff97116bcc6230408015dbeb3fb5e2bb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee36cfaff97116bcc6230408015dbeb3fb5e2bb9", "html_url": "https://github.com/rust-lang/rust/commit/ee36cfaff97116bcc6230408015dbeb3fb5e2bb9"}], "stats": {"total": 271, "additions": 128, "deletions": 143}, "files": [{"sha": "84687b8cab5c0b9160103167a97ab4a149c7efe6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -1329,15 +1329,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(did);\n                     // Account for the case where `did` corresponds to `Self`, which doesn't have\n                     // the expected type argument.\n-                    if !param.is_self() {\n+                    if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n                         hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "98603edd8066b940b21649f1660d600b590f4d68", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 81, "deletions": 63, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -91,8 +91,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        let self_ty = self.mk_self_type();\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n-            .filter(|&def_id| self.predicates_reference_self(def_id, true))\n+            .filter(|&def_id| self.predicates_reference_self(def_id, self_ty, true))\n             .map(|_| ObjectSafetyViolation::SupertraitSelf)\n             .collect();\n \n@@ -106,21 +108,44 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        let self_ty = self.mk_self_type();\n         debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n         traits::supertrait_def_ids(self, trait_def_id)\n-            .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n+            .flat_map(|def_id| self.object_safety_violations_for_trait(def_id, self_ty))\n             .collect()\n     }\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation>\n-    {\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        let self_ty = self.mk_self_type();\n+        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n+        // Any method that has a `Self : Sized` requisite can't be called.\n+        if self.generics_require_sized_self(method.def_id, self_ty) {\n+            return false;\n+        }\n+\n+        match self.virtual_call_violation_for_method(trait_def_id, self_ty, method) {\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            Some(_) => false,\n+        }\n+    }\n+\n+    fn object_safety_violations_for_trait(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+    ) -> Vec<ObjectSafetyViolation> {\n         // Check methods for violations.\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n             .filter_map(|item|\n-                self.object_safety_violation_for_method(trait_def_id, &item)\n+                self.object_safety_violation_for_method(trait_def_id, self_ty, &item)\n                     .map(|code| ObjectSafetyViolation::Method(item.ident.name, code))\n             ).filter(|violation| {\n                 if let ObjectSafetyViolation::Method(_,\n@@ -142,10 +167,10 @@ impl<'tcx> TyCtxt<'tcx> {\n             }).collect();\n \n         // Check the trait itself.\n-        if self.trait_has_sized_self(trait_def_id) {\n+        if self.trait_has_sized_self(trait_def_id, self_ty) {\n             violations.push(ObjectSafetyViolation::SizedSelf);\n         }\n-        if self.predicates_reference_self(trait_def_id, false) {\n+        if self.predicates_reference_self(trait_def_id, self_ty, false) {\n             violations.push(ObjectSafetyViolation::SupertraitSelf);\n         }\n \n@@ -163,14 +188,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn predicates_reference_self(\n         self,\n         trait_def_id: DefId,\n-        supertraits_only: bool) -> bool\n-    {\n+        self_ty: Ty<'tcx>,\n+        supertraits_only: bool,\n+    ) -> bool {\n         let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n         let predicates = if supertraits_only {\n             self.super_predicates_of(trait_def_id)\n         } else {\n             self.predicates_of(trait_def_id)\n         };\n+        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n         predicates\n             .predicates\n             .iter()\n@@ -179,7 +206,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n                     }\n                     ty::Predicate::Projection(ref data) => {\n                         // And similarly for projections. This should be redundant with\n@@ -199,7 +226,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .trait_ref(self)\n                             .input_types()\n                             .skip(1)\n-                            .any(|t| t.has_self_ty())\n+                            .any(has_self_ty)\n                     }\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -214,11 +241,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             })\n     }\n \n-    fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n-        self.generics_require_sized_self(trait_def_id)\n+    fn trait_has_sized_self(self, trait_def_id: DefId, self_ty: Ty<'tcx>) -> bool {\n+        self.generics_require_sized_self(trait_def_id, self_ty)\n     }\n \n-    fn generics_require_sized_self(self, def_id: DefId) -> bool {\n+    fn generics_require_sized_self(self, def_id: DefId, self_ty: Ty<'tcx>) -> bool {\n         let sized_def_id = match self.lang_items().sized_trait() {\n             Some(def_id) => def_id,\n             None => { return false; /* No Sized trait, can't require it! */ }\n@@ -229,11 +256,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.skip_binder().self_ty().is_self()\n+                ty::Predicate::Trait(ref trait_pred) => {\n+                    trait_pred.def_id() == sized_def_id\n+                        && trait_pred.skip_binder().self_ty() == self_ty\n                 }\n                 ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::WellFormed(..) |\n@@ -248,51 +275,32 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(self,\n-                                          trait_def_id: DefId,\n-                                          method: &ty::AssocItem)\n-                                          -> Option<MethodViolationCode>\n-    {\n+    fn object_safety_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n-        if self.generics_require_sized_self(method.def_id) {\n+        if self.generics_require_sized_self(method.def_id, self_ty) {\n             return None;\n         }\n \n-        self.virtual_call_violation_for_method(trait_def_id, method)\n-    }\n-\n-    /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n-    pub fn is_vtable_safe_method(self,\n-                                 trait_def_id: DefId,\n-                                 method: &ty::AssocItem)\n-                                 -> bool\n-    {\n-        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return false;\n-        }\n-\n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n-            Some(_) => false,\n-        }\n+        self.virtual_call_violation_for_method(trait_def_id, self_ty, method)\n     }\n \n     /// Returns `Some(_)` if this method cannot be called on a trait\n     /// object; this does not necessarily imply that the enclosing trait\n     /// is not object safe, because the method might have a where clause\n     /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(self,\n-                                         trait_def_id: DefId,\n-                                         method: &ty::AssocItem)\n-                                         -> Option<MethodViolationCode>\n-    {\n+    fn virtual_call_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n@@ -301,11 +309,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         let sig = self.fn_sig(method.def_id);\n \n         for input_ty in &sig.skip_binder().inputs()[1..] {\n-            if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n+            if self.contains_illegal_self_type_reference(trait_def_id, self_ty, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n             }\n         }\n-        if self.contains_illegal_self_type_reference(trait_def_id, sig.output().skip_binder()) {\n+        if self.contains_illegal_self_type_reference(\n+            trait_def_id,\n+            self_ty,\n+            sig.output().skip_binder(),\n+        ) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n \n@@ -323,7 +335,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting.\n-                .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t)) {\n+                .visit_tys_shallow(|t| {\n+                    self.contains_illegal_self_type_reference(trait_def_id, self_ty, t)\n+                }) {\n             let span = self.def_span(method.def_id);\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n@@ -337,7 +351,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n         // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n-        if receiver_ty != self.mk_self_type() {\n+        if receiver_ty != self_ty {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n@@ -404,7 +418,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n     /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n-        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+        self,\n+        receiver_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        method_def_id: DefId,\n     ) -> Ty<'tcx> {\n         debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n         let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n@@ -608,11 +625,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    fn contains_illegal_self_type_reference(self,\n-                                            trait_def_id: DefId,\n-                                            ty: Ty<'tcx>)\n-                                            -> bool\n-    {\n+    fn contains_illegal_self_type_reference(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n+     ) -> bool {\n         // This is somewhat subtle. In general, we want to forbid\n         // references to `Self` in the argument and return types,\n         // since the value of `Self` is erased. However, there is one\n@@ -656,8 +674,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut error = false;\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n-                ty::Param(ref param_ty) => {\n-                    if param_ty.is_self() {\n+                ty::Param(_) => {\n+                    if ty == self_ty {\n                         error = true;\n                     }\n "}, {"sha": "d6d17a67e01e95ef54529bfdd4eddd790321a612", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -239,13 +239,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n-            ty::Param(ref p) => {\n-                if p.is_self() {\n-                    \"Self\".into()\n-                } else {\n-                    \"type parameter\".into()\n-                }\n-            }\n+            ty::Param(_) => \"type parameter\".into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n         }"}, {"sha": "3944a2d9d039d8bfa7cb900f1d5b0fbb792d7bf9", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -86,13 +86,9 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty::Param(ref p) => {\n+            &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                if p.is_self() {\n-                    self.add_flags(TypeFlags::HAS_SELF);\n-                } else {\n-                    self.add_flags(TypeFlags::HAS_PARAMS);\n-                }\n+                self.add_flags(TypeFlags::HAS_PARAMS);\n             }\n \n             &ty::Generator(_, ref substs, _) => {"}, {"sha": "4b30412b41954e98355d645fa988dfd3dbaacac2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -85,9 +85,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_param_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PARAMS)\n     }\n-    fn has_self_ty(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_SELF)\n-    }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }"}, {"sha": "c71e1ea4e585989d763de4195328aab4fadc272a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -298,8 +298,9 @@ impl<'tcx> Instance<'tcx> {\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n-        let is_vtable_shim =\n-            fn_sig.inputs().skip_binder().len() > 0 && fn_sig.input(0).skip_binder().is_self();\n+        let is_vtable_shim = fn_sig.inputs().skip_binder().len() > 0\n+            && fn_sig.input(0).skip_binder().is_param(0)\n+            && tcx.generics_of(def_id).has_self;\n         if is_vtable_shim {\n             debug!(\" => associated item with unsizeable self: Self\");\n             Some(Instance {"}, {"sha": "2475fc86bb72b2feb8dc03f92615e19180cdbde2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -1601,7 +1601,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // resulting from the final codegen session.\n         if\n             layout.ty.has_param_types() ||\n-            layout.ty.has_self_ty() ||\n             !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n@@ -1767,7 +1766,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types() || tail.has_self_ty());\n+                        debug_assert!(tail.has_param_types());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n                             tail: tcx.erase_regions(&tail)"}, {"sha": "77237bf9b39d9db40e9749b9540c5c8bb73d89a3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -414,31 +414,30 @@ pub struct CReaderCacheKey {\n bitflags! {\n     pub struct TypeFlags: u32 {\n         const HAS_PARAMS         = 1 << 0;\n-        const HAS_SELF           = 1 << 1;\n-        const HAS_TY_INFER       = 1 << 2;\n-        const HAS_RE_INFER       = 1 << 3;\n-        const HAS_RE_PLACEHOLDER = 1 << 4;\n+        const HAS_TY_INFER       = 1 << 1;\n+        const HAS_RE_INFER       = 1 << 2;\n+        const HAS_RE_PLACEHOLDER = 1 << 3;\n \n         /// Does this have any `ReEarlyBound` regions? Used to\n         /// determine whether substitition is required, since those\n         /// represent regions that are bound in a `ty::Generics` and\n         /// hence may be substituted.\n-        const HAS_RE_EARLY_BOUND = 1 << 5;\n+        const HAS_RE_EARLY_BOUND = 1 << 4;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS   = 1 << 6;\n+        const HAS_FREE_REGIONS   = 1 << 5;\n \n         /// Is an error type reachable?\n-        const HAS_TY_ERR         = 1 << 7;\n-        const HAS_PROJECTION     = 1 << 8;\n+        const HAS_TY_ERR         = 1 << 6;\n+        const HAS_PROJECTION     = 1 << 7;\n \n         // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 9;\n+        const HAS_TY_CLOSURE     = 1 << 8;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n+        const HAS_FREE_LOCAL_NAMES    = 1 << 9;\n \n         /// Present if the type belongs in a local type context.\n         /// Only set for Infer other than Fresh.\n@@ -458,14 +457,12 @@ bitflags! {\n         const HAS_CT_PLACEHOLDER = 1 << 16;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n-                                   TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n         /// flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n                                   TypeFlags::HAS_CT_INFER.bits |\n@@ -1734,7 +1731,6 @@ impl<'tcx> ParamEnv<'tcx> {\n                 if value.has_placeholders()\n                     || value.needs_infer()\n                     || value.has_param_types()\n-                    || value.has_self_ty()\n                 {\n                     ParamEnvAnd {\n                         param_env: self,"}, {"sha": "1dd8108cb4bdbf0e3a30646ca7a517ed17bea006", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -1140,13 +1140,6 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n-\n-    pub fn is_self(&self) -> bool {\n-        // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n-        // but this should only be possible when using `-Z continue-parse-after-error` like\n-        // `compile-fail/issue-36638.rs`.\n-        self.name.as_symbol() == kw::SelfUpper && self.index == 0\n-    }\n }\n \n #[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n@@ -1788,14 +1781,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_self(&self) -> bool {\n-        match self.sty {\n-            Param(ref p) => p.is_self(),\n-            _ => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.sty {"}, {"sha": "39deb0fe5d34069baf4d9f4ec6d2ce791af7dcea", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -710,7 +710,7 @@ fn build_call_shim<'tcx>(\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n-            assert!(arg_ty.is_self());\n+            debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.mk_self_type());\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n             Operand::Move(rcvr_l.deref())"}, {"sha": "e29e412858f27f790e302ccdc5256ce5eb5d38d0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -635,8 +635,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    if tcx.at(span).type_of(param.def_id).has_self_ty() {\n+                if is_object && has_default && has_self {\n+                    let self_param = tcx.mk_self_type();\n+                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;"}, {"sha": "a70aff1dee6f828a187f9b40641d7f5026a539a1", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -3,7 +3,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::util::nodemap::FxHashMap;\n \n use super::explicit::ExplicitPredicatesMap;\n@@ -178,11 +177,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // let _: () = substs.region_at(0);\n                 check_explicit_predicates(\n                     tcx,\n-                    &def.did,\n+                    def.did,\n                     substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -208,11 +207,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                         .substs;\n                     check_explicit_predicates(\n                         tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n+                        ex_trait_ref.skip_binder().def_id,\n                         substs,\n                         required_predicates,\n                         explicit_map,\n-                        IgnoreSelfTy(true),\n+                        Some(tcx.mk_self_type()),\n                     );\n                 }\n             }\n@@ -223,11 +222,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    &tcx.associated_item(obj.item_def_id).container.id(),\n+                    tcx.associated_item(obj.item_def_id).container.id(),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -236,9 +235,6 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     }\n }\n \n-#[derive(Debug)]\n-pub struct IgnoreSelfTy(bool);\n-\n /// We also have to check the explicit predicates\n /// declared on the type.\n ///\n@@ -256,25 +252,25 @@ pub struct IgnoreSelfTy(bool);\n /// applying the substitution as above.\n pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: &DefId,\n+    def_id: DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n-    ignore_self_ty: IgnoreSelfTy,\n+    ignored_self_ty: Option<Ty<'tcx>>,\n ) {\n     debug!(\n         \"check_explicit_predicates(def_id={:?}, \\\n          substs={:?}, \\\n          explicit_map={:?}, \\\n          required_predicates={:?}, \\\n-         ignore_self_ty={:?})\",\n+         ignored_self_ty={:?})\",\n         def_id,\n         substs,\n         explicit_map,\n         required_predicates,\n-        ignore_self_ty,\n+        ignored_self_ty,\n     );\n-    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, *def_id);\n+    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n     for outlives_predicate in explicit_predicates.iter() {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n@@ -313,9 +309,9 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if ignore_self_ty.0 {\n+        if let Some(self_ty) = ignored_self_ty {\n             if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.has_self_ty() {\n+                if ty.walk().any(|ty| ty == self_ty) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "4075d2af667aa46d37a73d2e086a261822591e93", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -149,9 +149,11 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child);\n+    debug_assert!(cx.tcx.generics_of(child).has_self);\n+    let self_ty = cx.tcx.mk_self_type();\n     predicates.predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n-            if pred.skip_binder().trait_ref.self_ty().is_self() {\n+            if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                 Some(pred.def_id())\n             } else {\n                 None"}, {"sha": "c938ce8dad98d69a9beef006d41fb432d1b04d49", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -3,13 +3,13 @@ struct S;\n trait Tr {\n     fn f() {\n         let s = Self {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         let z = Self::<u8> {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         //~| ERROR type arguments are not allowed for this type\n         match s {\n             Self { .. } => {}\n-            //~^ ERROR expected struct, variant or union type, found Self\n+            //~^ ERROR expected struct, variant or union type, found type parameter\n         }\n     }\n }"}, {"sha": "8c88cacc69e315f8607e7e91de664c50908bbef7", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -1,4 +1,4 @@\n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:5:17\n    |\n LL |         let s = Self {};\n@@ -10,13 +10,13 @@ error[E0109]: type arguments are not allowed for this type\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:7:17\n    |\n LL |         let z = Self::<u8> {};\n    |                 ^^^^^^^^^^ not a struct\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:11:13\n    |\n LL |             Self { .. } => {}"}, {"sha": "71fb7f380aeac6e72a36a6f6c8371bfc82f50ecb", "filename": "src/test/ui/type/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -5,7 +5,7 @@ trait BrokenAdd: Copy + Add<Output=Self> {\n         *self + rhs //~  ERROR mismatched types\n                     //~| expected type `Self`\n                     //~| found type `T`\n-                    //~| expected Self, found type parameter\n+                    //~| expected type parameter, found a different type parameter\n     }\n }\n "}, {"sha": "0448a28ea8e2721b7722fa7ab09c2dd484f89bd9", "filename": "src/test/ui/type/type-params-in-different-spaces-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/type-params-in-different-spaces-1.rs:5:17\n    |\n LL |         *self + rhs\n-   |                 ^^^ expected Self, found type parameter\n+   |                 ^^^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `T`"}, {"sha": "e25f79947c73233c0128a9f253b06fe9c42219f2", "filename": "src/test/ui/type/type-params-in-different-spaces-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f6babbc6d6052e182613b2e96f361fad78177c5/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr?ref=2f6babbc6d6052e182613b2e96f361fad78177c5", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     fn test<X>(u: X) -> Self {\n    |                         ---- expected `Self` because of return type\n LL |         u\n-   |         ^ expected Self, found type parameter\n+   |         ^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `X`"}]}