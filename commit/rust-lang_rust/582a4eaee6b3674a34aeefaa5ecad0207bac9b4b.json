{"sha": "582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MmE0ZWFlZTZiMzY3NGEzNGFlZWZhYTVlY2FkMDIwN2JhYzliNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-25T09:28:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-25T09:28:59Z"}, "message": "Auto merge of #66279 - cjgillot:hashstable, r=Zoxc\n\nUse proc-macro to derive HashStable everywhere\n\nHello,\n\nA second proc-macro is added to derive HashStable for crates librustc depends on.\nThis proc-macro `HashStable_Generic` (to bikeshed) allows to decouple code and strip much of librustc's boilerplate.\n\nStill, two implementations `Span` and `TokenKind` require to be placed in librustc.\nThe latter only depends on the `bug` macro. Advise welcome on how to sever that link.\nA trait `StableHasingContextLike` has been introduced at each crate root,\nin order to handle those implementations which require librustc's very `StableHashingContext`.\n\nThis overall effort allowed to remove the `impl_stable_hash_for` macro.\n\nEach commit passes the `x.py check`.\nI still have to double check there was no change in the implementation.", "tree": {"sha": "6c33a566e5fc413793dba4c935ffc7b4b969b255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c33a566e5fc413793dba4c935ffc7b4b969b255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "html_url": "https://github.com/rust-lang/rust/commit/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eee955502558a049df75b4313a60cf57c885aa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eee955502558a049df75b4313a60cf57c885aa6", "html_url": "https://github.com/rust-lang/rust/commit/4eee955502558a049df75b4313a60cf57c885aa6"}, {"sha": "782cc9f65c0c19ef79bd009074e09bf0394674f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/782cc9f65c0c19ef79bd009074e09bf0394674f4", "html_url": "https://github.com/rust-lang/rust/commit/782cc9f65c0c19ef79bd009074e09bf0394674f4"}], "stats": {"total": 626, "additions": 199, "deletions": 427}, "files": [{"sha": "8b35839c182ac921db0480899ad4c432d64108bd", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 10, "deletions": 91, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -2,26 +2,23 @@ use crate::hir;\n use crate::hir::def_id::{DefId, DefIndex};\n use crate::hir::map::DefPathHash;\n use crate::hir::map::definitions::Definitions;\n-use crate::ich::{self, CachingSourceMapView, Fingerprint};\n+use crate::ich::{self, CachingSourceMapView};\n use crate::middle::cstore::CrateStore;\n use crate::ty::{TyCtxt, fast_reject};\n use crate::session::Session;\n \n use std::cmp::Ord;\n-use std::hash as std_hash;\n-use std::cell::RefCell;\n \n use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::symbol::Symbol;\n-use syntax::tokenstream::DelimSpan;\n-use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{self, SyntaxContext};\n+use syntax_pos::{SourceFile, BytePos};\n \n use rustc_data_structures::stable_hasher::{\n     HashStable, StableHasher, ToStableHashKey,\n };\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n@@ -281,93 +278,15 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for Span {\n-    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n-    /// fields (that would be similar to hashing pointers, since those are just\n-    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n-    /// triple, which stays the same even if the containing `SourceFile` has moved\n-    /// within the `SourceMap`.\n-    /// Also note that we are hashing byte offsets for the column, not unicode\n-    /// codepoint offsets. For the purpose of the hash that's sufficient.\n-    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n-    /// span starts and ends in the same file, which is almost always the case.\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        const TAG_VALID_SPAN: u8 = 0;\n-        const TAG_INVALID_SPAN: u8 = 1;\n-        const TAG_EXPANSION: u8 = 0;\n-        const TAG_NO_EXPANSION: u8 = 1;\n-\n-        if !hcx.hash_spans {\n-            return\n-        }\n-\n-        if *self == DUMMY_SP {\n-            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-        }\n-\n-        // If this is not an empty or invalid span, we want to hash the last\n-        // position that belongs to it, as opposed to hashing the first\n-        // position past it.\n-        let span = self.data();\n-        let (file_lo, line_lo, col_lo) = match hcx.source_map()\n-                                                  .byte_pos_to_line_and_col(span.lo) {\n-            Some(pos) => pos,\n-            None => {\n-                return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-            }\n-        };\n-\n-        if !file_lo.contains(span.hi) {\n-            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-        }\n-\n-        std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n-        // We truncate the stable ID hash and line and column numbers. The chances\n-        // of causing a collision this way should be minimal.\n-        std_hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n-\n-        let col = (col_lo.0 as u64) & 0xFF;\n-        let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n-        let len = ((span.hi - span.lo).0 as u64) << 32;\n-        let line_col_len = col | line | len;\n-        std_hash::Hash::hash(&line_col_len, hasher);\n-\n-        if span.ctxt == SyntaxContext::root() {\n-            TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n-        } else {\n-            TAG_EXPANSION.hash_stable(hcx, hasher);\n-\n-            // Since the same expansion context is usually referenced many\n-            // times, we cache a stable hash of it and hash that instead of\n-            // recursing every time.\n-            thread_local! {\n-                static CACHE: RefCell<FxHashMap<hygiene::ExpnId, u64>> = Default::default();\n-            }\n-\n-            let sub_hash: u64 = CACHE.with(|cache| {\n-                let expn_id = span.ctxt.outer_expn();\n-\n-                if let Some(&sub_hash) = cache.borrow().get(&expn_id) {\n-                    return sub_hash;\n-                }\n-\n-                let mut hasher = StableHasher::new();\n-                expn_id.expn_data().hash_stable(hcx, &mut hasher);\n-                let sub_hash: Fingerprint = hasher.finish();\n-                let sub_hash = sub_hash.to_smaller_hash();\n-                cache.borrow_mut().insert(expn_id, sub_hash);\n-                sub_hash\n-            });\n-\n-            sub_hash.hash_stable(hcx, hasher);\n-        }\n+impl<'a> syntax_pos::HashStableContext for StableHashingContext<'a> {\n+    fn hash_spans(&self) -> bool {\n+        self.hash_spans\n     }\n-}\n \n-impl<'a> HashStable<StableHashingContext<'a>> for DelimSpan {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.open.hash_stable(hcx, hasher);\n-        self.close.hash_stable(hcx, hasher);\n+    fn byte_pos_to_line_and_col(&mut self, byte: BytePos)\n+        -> Option<(Lrc<SourceFile>, usize, BytePos)>\n+    {\n+        self.source_map().byte_pos_to_line_and_col(byte)\n     }\n }\n "}, {"sha": "066359bd4e0361b67178d0b8b96a5bebc75ad653", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -9,7 +9,6 @@ use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use smallvec::SmallVec;\n use std::mem;\n-use syntax::ast;\n use syntax::attr;\n \n impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n@@ -119,10 +118,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-impl_stable_hash_for!(struct ast::Label {\n-    ident\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n@@ -138,10 +133,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::BinOpKind);\n-\n-impl_stable_hash_for_spanned!(ast::Name);\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n@@ -159,13 +150,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     }\n }\n \n-impl_stable_hash_for_spanned!(usize);\n-\n-impl_stable_hash_for!(struct ast::Ident {\n-    name,\n-    span,\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItem {\n@@ -234,8 +218,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::VisibilityKind);\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Mod {\n@@ -263,9 +245,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::Variant);\n-\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Item {"}, {"sha": "144980c53eb5fe7188c51332d52f59acc0eddb20", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 150, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -3,29 +3,23 @@\n \n use crate::ich::StableHashingContext;\n \n-use std::hash as std_hash;\n-use std::mem;\n-\n use syntax::ast;\n use syntax::feature_gate;\n-use syntax::token;\n-use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n-impl_stable_hash_for!(struct ::syntax::ast::Lit {\n-    kind,\n-    token,\n-    span\n-});\n-\n-impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+impl<'ctx> rustc_target::HashStableContext for StableHashingContext<'ctx> {}\n \n-impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, ident });\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Lifetime {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        self.id.hash_stable(hcx, hasher);\n+        self.ident.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n@@ -50,20 +44,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.segments.len().hash_stable(hcx, hasher);\n-        for segment in &self.segments {\n-            segment.ident.name.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct ::syntax::ast::AttrItem {\n-    path,\n-    tokens,\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n@@ -81,129 +61,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for tokenstream::TokenTree {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            tokenstream::TokenTree::Token(ref token) => {\n-                token.hash_stable(hcx, hasher);\n-            }\n-            tokenstream::TokenTree::Delimited(span, delim, ref tts) => {\n-                span.hash_stable(hcx, hasher);\n-                std_hash::Hash::hash(&delim, hasher);\n-                for sub_tt in tts.trees() {\n-                    sub_tt.hash_stable(hcx, hasher);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for tokenstream::TokenStream {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        for sub_tt in self.trees() {\n-            sub_tt.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            token::Eq |\n-            token::Lt |\n-            token::Le |\n-            token::EqEq |\n-            token::Ne |\n-            token::Ge |\n-            token::Gt |\n-            token::AndAnd |\n-            token::OrOr |\n-            token::Not |\n-            token::Tilde |\n-            token::At |\n-            token::Dot |\n-            token::DotDot |\n-            token::DotDotDot |\n-            token::DotDotEq |\n-            token::Comma |\n-            token::Semi |\n-            token::Colon |\n-            token::ModSep |\n-            token::RArrow |\n-            token::LArrow |\n-            token::FatArrow |\n-            token::Pound |\n-            token::Dollar |\n-            token::Question |\n-            token::SingleQuote |\n-            token::Whitespace |\n-            token::Comment |\n-            token::Eof => {}\n-\n-            token::BinOp(bin_op_token) |\n-            token::BinOpEq(bin_op_token) => {\n-                std_hash::Hash::hash(&bin_op_token, hasher);\n-            }\n-\n-            token::OpenDelim(delim_token) |\n-            token::CloseDelim(delim_token) => {\n-                std_hash::Hash::hash(&delim_token, hasher);\n-            }\n-            token::Literal(lit) => lit.hash_stable(hcx, hasher),\n-\n-            token::Ident(name, is_raw) => {\n-                name.hash_stable(hcx, hasher);\n-                is_raw.hash_stable(hcx, hasher);\n-            }\n-            token::Lifetime(name) => name.hash_stable(hcx, hasher),\n-\n-            token::Interpolated(_) => {\n-                bug!(\"interpolated tokens should not be present in the HIR\")\n-            }\n-\n-            token::DocComment(val) |\n-            token::Shebang(val) |\n-            token::Unknown(val) => val.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct token::Token {\n-    kind,\n-    span\n-});\n-\n-impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItem {\n-    MetaItem(meta_item),\n-    Literal(lit)\n-});\n-\n-impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n-    path,\n-    kind,\n-    span\n-});\n-\n-impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n-    Word,\n-    List(nested_items),\n-    NameValue(lit)\n-});\n-\n-impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n-    kind,\n-    parent -> _,\n-    call_site,\n-    def_site,\n-    allow_internal_unstable,\n-    allow_internal_unsafe,\n-    local_inner_macros,\n-    edition\n-});\n+impl<'ctx> syntax::HashStableContext for StableHashingContext<'ctx> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {"}, {"sha": "ece438266c0c249bee7af39491a5d52439a85d77", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -1,12 +1,11 @@\n //! ICH - Incremental Compilation Hash\n \n crate use rustc_data_structures::fingerprint::Fingerprint;\n-pub use self::caching_source_map_view::CachingSourceMapView;\n+pub use syntax_pos::CachingSourceMapView;\n pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls};\n use syntax::symbol::{Symbol, sym};\n \n-mod caching_source_map_view;\n mod hcx;\n \n mod impls_hir;"}, {"sha": "2bda0c0bef02daf5fa589bf033e29f85120dc51d", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n macro_rules! enum_from_u32 {\n     ($(#[$attr:meta])* pub enum $name:ident {\n         $($variant:ident = $e:expr,)*\n@@ -52,137 +50,6 @@ macro_rules! span_bug {\n     })\n }\n \n-#[macro_export]\n-macro_rules! __impl_stable_hash_field {\n-    ($field:ident, $ctx:expr, $hasher:expr) => ($field.hash_stable($ctx, $hasher));\n-    ($field:ident, $ctx:expr, $hasher:expr, _) => ({ let _ = $field; });\n-    ($field:ident, $ctx:expr, $hasher:expr, $delegate:expr) => ($delegate.hash_stable($ctx, $hasher));\n-}\n-\n-#[macro_export]\n-macro_rules! impl_stable_hash_for {\n-    // Enums\n-    (enum $enum_name:path {\n-        $( $variant:ident\n-           // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n-           // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n-           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n-        ),* $(,)?\n-    }) => {\n-        impl_stable_hash_for!(\n-            impl<> for enum $enum_name [ $enum_name ] { $( $variant\n-                $( ( $($field $(-> $delegate)?),* ) )?\n-                $( { $($named_field $(-> $named_delegate)?),* } )?\n-            ),* }\n-        );\n-    };\n-    // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n-    // importing all the variants. Unfortunately it seems we have to take the name\n-    // twice for this purpose\n-    (impl<$($T:ident),* $(,)?>\n-        for enum $enum_name:path\n-        [ $enum_path:path ]\n-    {\n-        $( $variant:ident\n-           // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n-           // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n-           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n-        ),* $(,)?\n-    }) => {\n-        impl<$($T,)*>\n-            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n-            for $enum_name\n-            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n-        {\n-            #[inline]\n-            fn hash_stable(&self,\n-                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n-                use $enum_path::*;\n-                ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n-\n-                match *self {\n-                    $(\n-                        $variant $( ( $(ref $field),* ) )? $( { $(ref $named_field),* } )? => {\n-                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)?\n-                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)?) );*)?\n-                        }\n-                    )*\n-                }\n-            }\n-        }\n-    };\n-    // Structs\n-    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),* $(,)? }) => {\n-        impl_stable_hash_for!(\n-            impl<> for struct $struct_name { $($field $(-> $delegate)?),* }\n-        );\n-    };\n-    (impl<$($T:ident),* $(,)?> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)?),* $(,)?\n-    }) => {\n-        impl<$($T,)*>\n-            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n-            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n-        {\n-            #[inline]\n-            fn hash_stable(&self,\n-                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n-                let $struct_name {\n-                    $(ref $field),*\n-                } = *self;\n-\n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n-            }\n-        }\n-    };\n-    // Tuple structs\n-    // We cannot use normal parentheses here, the parser won't allow it\n-    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n-        impl_stable_hash_for!(\n-            impl<> for tuple_struct $struct_name { $($field $(-> $delegate)?),* }\n-        );\n-    };\n-    (impl<$($T:ident),* $(,)?>\n-     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n-        impl<$($T,)*>\n-            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n-            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n-        {\n-            #[inline]\n-            fn hash_stable(&self,\n-                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n-                let $struct_name (\n-                    $(ref $field),*\n-                ) = *self;\n-\n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! impl_stable_hash_for_spanned {\n-    ($T:path) => (\n-\n-        impl HashStable<StableHashingContext<'a>> for ::syntax::source_map::Spanned<$T>\n-        {\n-            #[inline]\n-            fn hash_stable(&self,\n-                           hcx: &mut StableHashingContext<'a>,\n-                           hasher: &mut StableHasher) {\n-                self.node.hash_stable(hcx, hasher);\n-                self.span.hash_stable(hcx, hasher);\n-            }\n-        }\n-    );\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Lift and TypeFoldable macros\n //"}, {"sha": "103fcd0e8e7bd79eda8cae46bc217446bb241f86", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -51,6 +51,7 @@ pub fn hash_stable_generic_derive(mut s: synstructure::Structure<'_>) -> proc_ma\n     let generic: syn::GenericParam = parse_quote!(__CTX);\n     s.add_bounds(synstructure::AddBounds::Generics);\n     s.add_impl_generic(generic);\n+    s.add_where_predicate(parse_quote!{ __CTX: crate::HashStableContext });\n     let body = s.each(|bi| {\n         let attrs = parse_attributes(bi.ast());\n         if attrs.ignore {"}, {"sha": "471227f74037ea5f4011850eb75b05354b8faf0c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -3,6 +3,7 @@ use std::fmt::Write;\n use std::mem;\n \n use syntax::source_map::{self, Span, DUMMY_SP};\n+use rustc::ich::StableHashingContext;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::DefKind;\n use rustc::mir;\n@@ -18,6 +19,7 @@ use rustc::mir::interpret::{\n     InterpResult, truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n \n use super::{\n@@ -829,3 +831,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         frames\n     }\n }\n+\n+impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>\n+for Frame<'mir, 'tcx, Tag, Extra>\n+    where Extra: HashStable<StableHashingContext<'ctx>>,\n+          Tag:   HashStable<StableHashingContext<'ctx>>\n+{\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n+        self.body.hash_stable(hcx, hasher);\n+        self.instance.hash_stable(hcx, hasher);\n+        self.span.hash_stable(hcx, hasher);\n+        self.return_to_block.hash_stable(hcx, hasher);\n+        self.return_place.as_ref().map(|r| &**r).hash_stable(hcx, hasher);\n+        self.locals.hash_stable(hcx, hasher);\n+        self.block.hash_stable(hcx, hasher);\n+        self.stmt.hash_stable(hcx, hasher);\n+        self.extra.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "3ea00d69221868ee46fe7247d5440441ff973f86", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -304,18 +304,6 @@ struct FrameSnapshot<'a, 'tcx> {\n     stmt: usize,\n }\n \n-impl_stable_hash_for!(impl<> for struct Frame<'mir, 'tcx> {\n-    body,\n-    instance,\n-    span,\n-    return_to_block,\n-    return_place -> (return_place.as_ref().map(|r| &**r)),\n-    locals,\n-    block,\n-    stmt,\n-    extra,\n-});\n-\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     where Ctx: SnapshotContext<'a>,\n {"}, {"sha": "5582eaf47c426f09b3409bd78b68dc7edc2e0c3e", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -17,3 +17,8 @@\n \n pub mod abi;\n pub mod spec;\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in librustc.\n+pub trait HashStableContext {}"}, {"sha": "5bf12c54c4a203b8f47796a10e723f21a282a299", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -33,6 +33,7 @@ use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP, ExpnId};\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_index::vec::Idx;\n@@ -54,7 +55,7 @@ mod tests;\n /// ```\n ///\n /// `'outer` is a label.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable_Generic)]\n pub struct Label {\n     pub ident: Ident,\n }\n@@ -112,6 +113,15 @@ impl PartialEq<Symbol> for Path {\n     }\n }\n \n+impl<CTX> HashStable<CTX> for Path {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.segments.len().hash_stable(hcx, hasher);\n+        for segment in &self.segments {\n+            segment.ident.name.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n impl Path {\n     // Convert a span and an identifier to the corresponding\n     // one-segment path.\n@@ -473,7 +483,7 @@ pub struct Crate {\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum NestedMetaItem {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n@@ -486,7 +496,7 @@ pub enum NestedMetaItem {\n /// A spanned compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct MetaItem {\n     pub path: Path,\n     pub kind: MetaItemKind,\n@@ -496,7 +506,7 @@ pub struct MetaItem {\n /// A compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n@@ -1426,7 +1436,7 @@ pub enum StrStyle {\n }\n \n /// An AST literal.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     /// The original literal token as written in source code.\n     pub token: token::Lit,\n@@ -2286,7 +2296,7 @@ impl rustc_serialize::Decodable for AttrId {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n     pub tokens: TokenStream,"}, {"sha": "22b49862f4965f74be2d9b443590e1af610659f0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -110,3 +110,8 @@ pub mod print {\n }\n \n pub mod early_buffered_lints;\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in librustc.\n+pub trait HashStableContext: syntax_pos::HashStableContext {}"}, {"sha": "6f45211ac5f2998b5ddec09467cce98674f149a4", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -14,10 +14,12 @@ use syntax_pos::{self, Span, DUMMY_SP};\n \n use std::fmt;\n use std::mem;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic)]\n pub enum BinOpToken {\n     Plus,\n     Minus,\n@@ -33,6 +35,7 @@ pub enum BinOpToken {\n \n /// A delimiter token.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic)]\n pub enum DelimToken {\n     /// A round parenthesis (i.e., `(` or `)`).\n     Paren,\n@@ -190,7 +193,7 @@ fn ident_can_begin_type(name: ast::Name, span: Span, is_raw: bool) -> bool {\n     ].contains(&name)\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n     Eq,\n@@ -262,7 +265,7 @@ pub enum TokenKind {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n     pub span: Span,\n@@ -725,3 +728,11 @@ impl fmt::Debug for Nonterminal {\n         }\n     }\n }\n+\n+impl<CTX> HashStable<CTX> for Nonterminal\n+    where CTX: crate::HashStableContext\n+{\n+    fn hash_stable(&self, _hcx: &mut CTX, _hasher: &mut StableHasher) {\n+        panic!(\"interpolated tokens should not be present in the HIR\")\n+    }\n+}"}, {"sha": "6a0523dd655b861d0d03b41f3c5ecbdda323d54d", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -16,6 +16,8 @@\n use crate::token::{self, DelimToken, Token, TokenKind};\n \n use syntax_pos::{Span, DUMMY_SP};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable_Generic;\n use rustc_data_structures::sync::Lrc;\n use smallvec::{SmallVec, smallvec};\n \n@@ -33,7 +35,7 @@ use std::{iter, mem};\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub enum TokenTree {\n     /// A single token\n     Token(Token),\n@@ -115,6 +117,16 @@ impl TokenTree {\n     }\n }\n \n+impl<CTX> HashStable<CTX> for TokenStream\n+    where CTX: crate::HashStableContext\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        for sub_tt in self.trees() {\n+            sub_tt.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n /// A `TokenStream` is an abstract sequence of tokens, organized into `TokenTree`s.\n ///\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n@@ -444,7 +456,7 @@ impl Cursor {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct DelimSpan {\n     pub open: Span,\n     pub close: Span,"}, {"sha": "8237173087610b1e42c838a2a9dfad4daa704b32", "filename": "src/libsyntax_pos/caching_source_map_view.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fcaching_source_map_view.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::sync::Lrc;\n-use syntax::source_map::SourceMap;\n-use syntax_pos::{BytePos, SourceFile};\n+use crate::source_map::SourceMap;\n+use crate::{BytePos, SourceFile};\n \n #[derive(Clone)]\n struct CacheEntry {", "previous_filename": "src/librustc/ich/caching_source_map_view.rs"}, {"sha": "3c1d19256e91c45d007fa77ca10b9a7028d97d06", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -616,12 +616,13 @@ impl Span {\n \n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct ExpnData {\n     // --- The part unique to each expansion.\n     /// The kind of this expansion - macro or compiler desugaring.\n     pub kind: ExpnKind,\n     /// The expansion that produced this expansion.\n+    #[stable_hasher(ignore)]\n     pub parent: ExpnId,\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`"}, {"sha": "66f25770722b2563ae824c1cd9bd8c9554f653f7", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -18,6 +18,8 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_macros::HashStable_Generic;\n \n pub mod source_map;\n+mod caching_source_map_view;\n+pub use self::caching_source_map_view::CachingSourceMapView;\n \n pub mod edition;\n use edition::Edition;\n@@ -34,11 +36,13 @@ pub use symbol::{Symbol, sym};\n mod analyze_source_file;\n pub mod fatal_error;\n \n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::fx::FxHashMap;\n \n use std::borrow::Cow;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hasher, Hash};\n@@ -1562,3 +1566,96 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n         Err(line) => line as isize - 1\n     }\n }\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in librustc.\n+pub trait HashStableContext {\n+    fn hash_spans(&self) -> bool;\n+    fn byte_pos_to_line_and_col(&mut self, byte: BytePos)\n+        -> Option<(Lrc<SourceFile>, usize, BytePos)>;\n+}\n+\n+impl<CTX> HashStable<CTX> for Span\n+    where CTX: HashStableContext\n+{\n+    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n+    /// fields (that would be similar to hashing pointers, since those are just\n+    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n+    /// triple, which stays the same even if the containing `SourceFile` has moved\n+    /// within the `SourceMap`.\n+    /// Also note that we are hashing byte offsets for the column, not unicode\n+    /// codepoint offsets. For the purpose of the hash that's sufficient.\n+    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n+    /// span starts and ends in the same file, which is almost always the case.\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        const TAG_VALID_SPAN: u8 = 0;\n+        const TAG_INVALID_SPAN: u8 = 1;\n+        const TAG_EXPANSION: u8 = 0;\n+        const TAG_NO_EXPANSION: u8 = 1;\n+\n+        if !ctx.hash_spans() {\n+            return\n+        }\n+\n+        if *self == DUMMY_SP {\n+            return std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span = self.data();\n+        let (file_lo, line_lo, col_lo) = match ctx.byte_pos_to_line_and_col(span.lo) {\n+            Some(pos) => pos,\n+            None => {\n+                return std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+            }\n+        };\n+\n+        if !file_lo.contains(span.hi) {\n+            return std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n+        std::hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n+        // We truncate the stable ID hash and line and column numbers. The chances\n+        // of causing a collision this way should be minimal.\n+        std::hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n+\n+        let col = (col_lo.0 as u64) & 0xFF;\n+        let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n+        let len = ((span.hi - span.lo).0 as u64) << 32;\n+        let line_col_len = col | line | len;\n+        std::hash::Hash::hash(&line_col_len, hasher);\n+\n+        if span.ctxt == SyntaxContext::root() {\n+            TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n+        } else {\n+            TAG_EXPANSION.hash_stable(ctx, hasher);\n+\n+            // Since the same expansion context is usually referenced many\n+            // times, we cache a stable hash of it and hash that instead of\n+            // recursing every time.\n+            thread_local! {\n+                static CACHE: RefCell<FxHashMap<hygiene::ExpnId, u64>> = Default::default();\n+            }\n+\n+            let sub_hash: u64 = CACHE.with(|cache| {\n+                let expn_id = span.ctxt.outer_expn();\n+\n+                if let Some(&sub_hash) = cache.borrow().get(&expn_id) {\n+                    return sub_hash;\n+                }\n+\n+                let mut hasher = StableHasher::new();\n+                expn_id.expn_data().hash_stable(ctx, &mut hasher);\n+                let sub_hash: Fingerprint = hasher.finish();\n+                let sub_hash = sub_hash.to_smaller_hash();\n+                cache.borrow_mut().insert(expn_id, sub_hash);\n+                sub_hash\n+            });\n+\n+            sub_hash.hash_stable(ctx, hasher);\n+        }\n+    }\n+}"}, {"sha": "b597fad080fa03effffecd443d1aabe17c77ef18", "filename": "src/libsyntax_pos/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsource_map.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -39,7 +39,7 @@ pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,"}, {"sha": "7d43c3c8d076e93bc347bff192bdfbfed4937579", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=582a4eaee6b3674a34aeefaa5ecad0207bac9b4b", "patch": "@@ -5,7 +5,7 @@\n use arena::DroplessArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n-use rustc_macros::symbols;\n+use rustc_macros::{symbols, HashStable_Generic};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n@@ -754,7 +754,7 @@ symbols! {\n     }\n }\n \n-#[derive(Copy, Clone, Eq)]\n+#[derive(Copy, Clone, Eq, HashStable_Generic)]\n pub struct Ident {\n     pub name: Symbol,\n     pub span: Span,"}]}