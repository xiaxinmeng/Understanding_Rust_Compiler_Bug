{"sha": "99f5c8593b1778947830d1da580c55b70680b919", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZjVjODU5M2IxNzc4OTQ3ODMwZDFkYTU4MGM1NWI3MDY4MGI5MTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T20:51:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T20:51:58Z"}, "message": "rustc: ban registering obligations during InferCtxt snapshots.", "tree": {"sha": "1f5d6b504e88fd64101e6f8095e13c8deca7d475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f5d6b504e88fd64101e6f8095e13c8deca7d475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99f5c8593b1778947830d1da580c55b70680b919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99f5c8593b1778947830d1da580c55b70680b919", "html_url": "https://github.com/rust-lang/rust/commit/99f5c8593b1778947830d1da580c55b70680b919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99f5c8593b1778947830d1da580c55b70680b919/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c67cf5fddc1d2807e9942c1f9793c3230367332b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c67cf5fddc1d2807e9942c1f9793c3230367332b", "html_url": "https://github.com/rust-lang/rust/commit/c67cf5fddc1d2807e9942c1f9793c3230367332b"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "a1bafe113e415cb90a30a0b2522c7df2b03ded98", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=99f5c8593b1778947830d1da580c55b70680b919", "patch": "@@ -199,10 +199,8 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n \n-    // This flag is used for debugging, and is set to true if there are\n-    // any obligations set during the current snapshot. In that case, the\n-    // snapshot can't be rolled back.\n-    pub obligations_in_snapshot: Cell<bool>,\n+    // This flag is true while there is an active snapshot.\n+    in_snapshot: Cell<bool>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -507,7 +505,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             projection_mode: Reveal::UserFacing,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n-            obligations_in_snapshot: Cell::new(false),\n+            in_snapshot: Cell::new(false),\n         }\n     }\n }\n@@ -545,7 +543,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n-            obligations_in_snapshot: Cell::new(false),\n+            in_snapshot: Cell::new(false),\n         }))\n     }\n }\n@@ -573,7 +571,7 @@ pub struct CombinedSnapshot {\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n-    obligations_in_snapshot: bool,\n+    was_in_snapshot: bool,\n }\n \n /// Helper trait for shortening the lifetimes inside a\n@@ -734,6 +732,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.projection_mode\n     }\n \n+    pub fn is_in_snapshot(&self) -> bool {\n+        self.in_snapshot.get()\n+    }\n+\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n@@ -861,46 +863,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n-    // Clear the \"obligations in snapshot\" flag, invoke the closure,\n+    // Clear the \"currently in a snapshot\" flag, invoke the closure,\n     // then restore the flag to its original value. This flag is a\n     // debugging measure designed to detect cases where we start a\n-    // snapshot, create type variables, register obligations involving\n-    // those type variables in the fulfillment cx, and then have to\n-    // unroll the snapshot, leaving \"dangling type variables\" behind.\n-    // In such cases, the flag will be set by the fulfillment cx, and\n-    // an assertion will fail when rolling the snapshot back.  Very\n-    // useful, much better than grovelling through megabytes of\n-    // RUST_LOG output.\n+    // snapshot, create type variables, and register obligations\n+    // which may involve those type variables in the fulfillment cx,\n+    // potentially leaving \"dangling type variables\" behind.\n+    // In such cases, an assertion will fail when attempting to\n+    // register obligations, within a snapshot. Very useful, much\n+    // better than grovelling through megabytes of RUST_LOG output.\n     //\n-    // HOWEVER, in some cases the flag is wrong. In particular, we\n+    // HOWEVER, in some cases the flag is unhelpful. In particular, we\n     // sometimes create a \"mini-fulfilment-cx\" in which we enroll\n     // obligations. As long as this fulfillment cx is fully drained\n     // before we return, this is not a problem, as there won't be any\n     // escaping obligations in the main cx. In those cases, you can\n     // use this function.\n-    pub fn save_and_restore_obligations_in_snapshot_flag<F, R>(&self, func: F) -> R\n+    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n         where F: FnOnce(&Self) -> R\n     {\n-        let flag = self.obligations_in_snapshot.get();\n-        self.obligations_in_snapshot.set(false);\n+        let flag = self.in_snapshot.get();\n+        self.in_snapshot.set(false);\n         let result = func(self);\n-        self.obligations_in_snapshot.set(flag);\n+        self.in_snapshot.set(flag);\n         result\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n         debug!(\"start_snapshot()\");\n \n-        let obligations_in_snapshot = self.obligations_in_snapshot.get();\n-        self.obligations_in_snapshot.set(false);\n+        let in_snapshot = self.in_snapshot.get();\n+        self.in_snapshot.set(true);\n \n         CombinedSnapshot {\n             projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n-            obligations_in_snapshot: obligations_in_snapshot,\n+            was_in_snapshot: in_snapshot,\n         }\n     }\n \n@@ -911,10 +912,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               obligations_in_snapshot } = snapshot;\n+                               was_in_snapshot } = snapshot;\n \n-        assert!(!self.obligations_in_snapshot.get());\n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n+        self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()\n@@ -939,9 +939,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               obligations_in_snapshot } = snapshot;\n+                               was_in_snapshot } = snapshot;\n \n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n+        self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()"}, {"sha": "d771be077ae3a403aeb830a216ea5a2d12f7f1fb", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=99f5c8593b1778947830d1da580c55b70680b919", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n-        infcx.obligations_in_snapshot.set(true);\n+        assert!(!infcx.is_in_snapshot());\n \n         if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n             debug!(\"register_predicate_obligation: duplicate\");"}, {"sha": "92b7c736d42fda8e676ad48cbaa0554ab83d4938", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=99f5c8593b1778947830d1da580c55b70680b919", "patch": "@@ -242,7 +242,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n \n-    infcx.save_and_restore_obligations_in_snapshot_flag(|infcx| {\n+    infcx.save_and_restore_in_snapshot_flag(|infcx| {\n         let mut fulfill_cx = FulfillmentContext::new();\n         for oblig in obligations.into_iter() {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);"}, {"sha": "61e4b74ae8d502d9a0f78a28898f0fdb486e2521", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f5c8593b1778947830d1da580c55b70680b919/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=99f5c8593b1778947830d1da580c55b70680b919", "patch": "@@ -2588,7 +2588,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // we can.  We don't care if some things turn\n                         // out unconstrained or ambiguous, as we're\n                         // just trying to get hints here.\n-                        let result = self.save_and_restore_obligations_in_snapshot_flag(|_| {\n+                        let result = self.save_and_restore_in_snapshot_flag(|_| {\n                             let mut fulfill = FulfillmentContext::new();\n                             let ok = ok; // FIXME(#30046)\n                             for obligation in ok.obligations {"}]}