{"sha": "b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYzVkYzJjYzFmMTg2ZjBhYjdhODgzZDEyYjFjYWM4NGEwZmFiMTA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T12:34:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T12:34:59Z"}, "message": "edit docs a little", "tree": {"sha": "29723225ccff09cd0db720711173f282a9add95a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29723225ccff09cd0db720711173f282a9add95a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10", "html_url": "https://github.com/rust-lang/rust/commit/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8da32158189118790e64873be6493cfdedbeac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8da32158189118790e64873be6493cfdedbeac1", "html_url": "https://github.com/rust-lang/rust/commit/c8da32158189118790e64873be6493cfdedbeac1"}], "stats": {"total": 76, "additions": 49, "deletions": 27}, "files": [{"sha": "9748feddddff754b08e480607bec11ccf6047a85", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10", "patch": "@@ -986,11 +986,14 @@ extern \"rust-intrinsic\" {\n     ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n     ///   beginning at `dst` with the same size.\n     ///\n-    /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n+    /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using *both* the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n+    /// These restrictions apply even if the effectively copied size (`count *\n+    /// size_of::<T>()`) is `0`.\n+    ///\n     /// [`Copy`]: ../marker/trait.Copy.html\n     /// [`read`]: ../ptr/fn.read.html\n     /// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n@@ -1071,6 +1074,9 @@ extern \"rust-intrinsic\" {\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n+    /// These restrictions apply even if the effectively copied size (`count *\n+    /// size_of::<T>()`) is `0`.\n+    ///\n     /// [`Copy`]: ../marker/trait.Copy.html\n     /// [`read`]: ../ptr/fn.read.html\n     /// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n@@ -1115,6 +1121,9 @@ extern \"rust-intrinsic\" {\n     /// value of `T`. Creating an invalid value of `T` can result in undefined\n     /// behavior.\n     ///\n+    /// These restrictions apply even if the effectively written size (`count *\n+    /// size_of::<T>()`) is `0`.\n+    ///\n     /// [valid]: ../ptr/index.html#safety\n     ///\n     /// # Examples\n@@ -1164,7 +1173,7 @@ extern \"rust-intrinsic\" {\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n-    /// unless size is equal to zero..\n+    /// unless size is equal to zero.\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of"}, {"sha": "b82afecd7696cf585707f6fca68d78a8458683a9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b0c5dc2cc1f186f0ab7a883d12b1cac84a0fab10", "patch": "@@ -16,35 +16,23 @@\n //!\n //! # Safety\n //!\n-//! Many functions in this module take raw pointers as arguments and dereference\n-//! them. For this to be safe, these pointers must be valid. However, because\n-//! rust does not yet have a formal memory model, determining whether an\n-//! arbitrary pointer is valid for a given operation can be tricky.\n+//! Many functions in this module take raw pointers as arguments and read from\n+//! or write to them. For this to be safe, these pointers must be *valid*.\n+//! Whether a pointer is valid depends on the operation it is used for\n+//! (read or write), and the extent of the memory that is accessed (i.e.,\n+//! how many bytes are read/written). Most functions use `*mut T` and `*const T`\n+//! to access only a single value, in which case the documentation omits the size\n+//! and implicitly assumes it to be `size_of::<T>()` bytes.\n //!\n-//! There are two types of operations on memory, reads and writes. A single\n-//! pointer can be valid for any combination of these operations. For example, a\n-//! pointer is not valid for writes if a `&mut` exists which [refers to the same\n-//! memory][aliasing]. The set of operations for which a pointer argument must\n-//! be valid is explicitly documented for each function. This is not strictly\n-//! necessary for `*const` arguments, as they can only be used for reads and\n-//! never for writes.\n-//!\n-//! Some functions (e.g. [`copy`]) take a single pointer but\n-//! operate on many values. In this case, the function will state the size of\n-//! the operation for which the pointer must be valid. For example,\n-//! `copy::<T>(&src, &mut dst, 3)` requires `dst` to be valid for writes of\n-//! `size_of::<T>() * 3` bytes. When the documentation requires that a pointer\n-//! be valid for an operation but omits the size of that operation, the size is\n-//! implied to be `size_of::<T>()` bytes.\n-//!\n-//! While we can't yet define whether an arbitrary pointer is a valid one, there\n+//! While we can't yet define whether an arbitrary pointer is valid, there\n //! are a few rules regarding validity:\n //!\n-//! * The result of casting a reference to a pointer is valid for as long as the\n-//!   underlying object is live.\n-//! * A [null] pointer is *never* valid.\n+//! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n //! * All pointers (except for the null pointer) are valid for all operations of\n //!   [size zero][zst].\n+//! * The result of casting a reference to a pointer is valid for as long as the\n+//!   underlying object is live and no reference (just raw pointers) is used to\n+//!   access the same memory.\n //!\n //! These axioms, along with careful use of [`offset`] for pointer arithmentic,\n //! are enough to correctly implement many useful things in unsafe code. Still,\n@@ -60,6 +48,10 @@\n //! this requirement in their documentation. Notable exceptions to this are\n //! [`read_unaligned`] and [`write_unaligned`].\n //!\n+//! When a function requires proper alignment, it does so even if the access\n+//! has size 0, i.e., even if memory is not actually touched. Consider using\n+//! [`NonNull::dangling`] in such cases.\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/second-edition/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n@@ -69,6 +61,7 @@\n //! [`offset`]: ../../std/primitive.pointer.html#method.offset\n //! [`read_unaligned`]: ./fn.read_unaligned.html\n //! [`write_unaligned`]: ./fn.write_unaligned.html\n+//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -122,6 +115,8 @@ pub use intrinsics::write_bytes;\n /// again. [`write`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n /// [`Copy`]: ../marker/trait.Copy.html\n /// [`write`]: ../ptr/fn.write.html\n@@ -211,6 +206,8 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n ///\n /// * Both `x` and `y` must be properly aligned.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n@@ -278,6 +275,8 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n ///   beginning at `y` with the same size.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n@@ -389,6 +388,8 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// * `dest` must be properly aligned.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n@@ -426,6 +427,8 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n ///   case.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// ## Ownership of the Returned Value\n ///\n /// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n@@ -540,6 +543,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [`Copy`]: ../marker/trait.Copy.html\n /// [`read`]: ./fn.read.html\n /// [`write_unaligned`]: ./fn.write_unaligned.html\n@@ -616,6 +621,8 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n ///   case.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n /// [`write_unaligned`]: ./fn.write_unaligned.html\n ///\n@@ -687,6 +694,8 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// * `dst` must be [valid] for writes.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n@@ -770,6 +779,8 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n /// [`Copy`]: ../marker/trait.Copy.html\n /// [`read`]: ./fn.read.html\n@@ -839,6 +850,8 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// * `dst` must be properly aligned.\n ///\n+/// These restrictions apply even if `T` has size `0`.\n+///\n /// [valid]: ../ptr/index.html#safety\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever"}]}