{"sha": "8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "node_id": "C_kwDOAAsO6NoAKDhjYzVhYTU2MWNlYTUyNDJmYmY1ODM0YWNmMTFlMWU2ZThmMzc5ZmM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-26T14:23:14Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-05T14:19:52Z"}, "message": "rustc_metadata: Refactor lazy table reading/writing\n\nChange wording from \"nullable\" to \"default\".\nIntroduce a trait `IsDefault` for detecting values that are encoded as zeros or not encoded at all.\nAdd panics to impossible cases.\nSome other minor cleanups.", "tree": {"sha": "2b218d83dee93ec595d7be3d13beaa20a3b4d5b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b218d83dee93ec595d7be3d13beaa20a3b4d5b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "html_url": "https://github.com/rust-lang/rust/commit/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f97aeaf73047268299ab55288b3dd886130be47", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f97aeaf73047268299ab55288b3dd886130be47", "html_url": "https://github.com/rust-lang/rust/commit/7f97aeaf73047268299ab55288b3dd886130be47"}], "stats": {"total": 217, "additions": 127, "deletions": 90}, "files": [{"sha": "0533aacbd2fa1f7c5939531658dbd68f799aa703", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "patch": "@@ -365,26 +365,26 @@ impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// Shorthand for `$self.$tables.$table.set_some($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n             let lazy = $self.lazy(value);\n-            $self.$tables.$table.set($def_id.index, lazy);\n+            $self.$tables.$table.set_some($def_id.index, lazy);\n         }\n     }};\n }\n \n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// Shorthand for `$self.$tables.$table.set_some($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record_array {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n             let lazy = $self.lazy_array(value);\n-            $self.$tables.$table.set($def_id.index, lazy);\n+            $self.$tables.$table.set_some($def_id.index, lazy);\n         }\n     }};\n }\n@@ -467,14 +467,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             {\n                 let def_key = self.lazy(table.def_key(def_index));\n                 let def_path_hash = table.def_path_hash(def_index);\n-                self.tables.def_keys.set(def_index, def_key);\n-                self.tables.def_path_hashes.set(def_index, def_path_hash);\n+                self.tables.def_keys.set_some(def_index, def_key);\n+                self.tables.def_path_hashes.set_some(def_index, def_path_hash);\n             }\n         } else {\n             for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n                 let def_key = self.lazy(def_key);\n-                self.tables.def_keys.set(def_index, def_key);\n-                self.tables.def_path_hashes.set(def_index, *def_path_hash);\n+                self.tables.def_keys.set_some(def_index, def_key);\n+                self.tables.def_path_hashes.set_some(def_index, *def_path_hash);\n             }\n         }\n     }\n@@ -548,7 +548,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             let on_disk_index: u32 =\n                 on_disk_index.try_into().expect(\"cannot export more than U32_MAX files\");\n-            adapted.set(on_disk_index, self.lazy(source_file));\n+            adapted.set_some(on_disk_index, self.lazy(source_file));\n         }\n \n         adapted.encode(&mut self.opaque)\n@@ -1147,9 +1147,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n-        if !attr_flags.is_empty() {\n-            self.tables.attr_flags.set_nullable(def_id.local_def_index, attr_flags);\n-        }\n+        self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n     }\n \n     fn encode_def_ids(&mut self) {\n@@ -1161,7 +1159,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n-            self.tables.opt_def_kind.set(def_id.index, def_kind);\n+            self.tables.opt_def_kind.set_some(def_id.index, def_kind);\n             let def_span = tcx.def_span(local_id);\n             record!(self.tables.def_span[def_id] <- def_span);\n             self.encode_attrs(local_id);\n@@ -1264,14 +1262,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             };\n             record!(self.tables.variant_data[variant.def_id] <- data);\n \n-            self.tables.constness.set(variant.def_id.index, hir::Constness::Const);\n+            self.tables.constness.set_some(variant.def_id.index, hir::Constness::Const);\n             record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             }));\n \n             if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-                self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n+                self.tables.constness.set_some(ctor_def_id.index, hir::Constness::Const);\n                 let fn_sig = tcx.fn_sig(ctor_def_id);\n                 record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n                 // FIXME only encode signature for ctor_def_id\n@@ -1342,16 +1340,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         let impl_defaultness = tcx.impl_defaultness(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, impl_defaultness);\n+        self.tables.impl_defaultness.set_some(def_id.index, impl_defaultness);\n         let trait_item = tcx.associated_item(def_id);\n-        self.tables.assoc_container.set(def_id.index, trait_item.container);\n+        self.tables.assoc_container.set_some(def_id.index, trait_item.container);\n \n         match trait_item.kind {\n             ty::AssocKind::Const => {}\n             ty::AssocKind::Fn => {\n                 record_array!(self.tables.fn_arg_names[def_id] <- tcx.fn_arg_names(def_id));\n-                self.tables.asyncness.set(def_id.index, tcx.asyncness(def_id));\n-                self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n+                self.tables.asyncness.set_some(def_id.index, tcx.asyncness(def_id));\n+                self.tables.constness.set_some(def_id.index, hir::Constness::NotConst);\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1367,33 +1365,31 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         let ast_item = self.tcx.hir().expect_impl_item(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, ast_item.defaultness);\n+        self.tables.impl_defaultness.set_some(def_id.index, ast_item.defaultness);\n         let impl_item = self.tcx.associated_item(def_id);\n-        self.tables.assoc_container.set(def_id.index, impl_item.container);\n+        self.tables.assoc_container.set_some(def_id.index, impl_item.container);\n \n         match impl_item.kind {\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n-                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n+                self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                self.tables.constness.set(def_id.index, constness);\n+                self.tables.constness.set_some(def_id.index, constness);\n             }\n             ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n-            self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n+            self.tables.trait_item_def_id.set_some(def_id.index, trait_item_def_id.into());\n         }\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n     }\n \n@@ -1522,35 +1518,33 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n-                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n+                self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                self.tables.constness.set(def_id.index, sig.header.constness);\n+                self.tables.constness.set_some(def_id.index, sig.header.constness);\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                if macro_def.macro_rules {\n-                    self.tables.is_macro_rules.set_nullable(def_id.index, true);\n-                }\n+                self.tables.is_macro_rules.set(def_id.index, macro_def.macro_rules);\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n-                    self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n-                }\n+                self.tables\n+                    .is_type_alias_impl_trait\n+                    .set(def_id.index, matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias));\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n-                self.tables.impl_defaultness.set(def_id.index, *defaultness);\n-                self.tables.constness.set(def_id.index, *constness);\n+                self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n+                self.tables.constness.set_some(def_id.index, *constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {\n-                            self.tables.impl_parent.set(def_id.index, parent.into());\n+                            self.tables.impl_parent.set_some(def_id.index, parent.into());\n                         }\n                     }\n \n@@ -1564,7 +1558,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n \n                 let polarity = self.tcx.impl_polarity(def_id);\n-                self.tables.impl_polarity.set(def_id.index, polarity);\n+                self.tables.impl_polarity.set_some(def_id.index, polarity);\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n@@ -1601,9 +1595,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n@@ -1650,7 +1642,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty::Closure(_, substs) => {\n                 let constness = self.tcx.constness(def_id.to_def_id());\n-                self.tables.constness.set(def_id.to_def_id().index, constness);\n+                self.tables.constness.set_some(def_id.to_def_id().index, constness);\n                 record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder(substs.as_closure().sig()));\n             }\n \n@@ -1678,12 +1670,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.hygiene_ctxt.encode(\n             &mut (&mut *self, &mut syntax_contexts, &mut expn_data_table, &mut expn_hash_table),\n             |(this, syntax_contexts, _, _), index, ctxt_data| {\n-                syntax_contexts.set(index, this.lazy(ctxt_data));\n+                syntax_contexts.set_some(index, this.lazy(ctxt_data));\n             },\n             |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n                 if let Some(index) = index.as_local() {\n-                    expn_data_table.set(index.as_raw(), this.lazy(expn_data));\n-                    expn_hash_table.set(index.as_raw(), this.lazy(hash));\n+                    expn_data_table.set_some(index.as_raw(), this.lazy(expn_data));\n+                    expn_hash_table.set_some(index.as_raw(), this.lazy(hash));\n                 }\n             },\n         );\n@@ -1708,10 +1700,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n             for (i, span) in spans.into_iter().enumerate() {\n                 let span = self.lazy(span);\n-                self.tables.proc_macro_quoted_spans.set(i, span);\n+                self.tables.proc_macro_quoted_spans.set_some(i, span);\n             }\n \n-            self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n+            self.tables.opt_def_kind.set_some(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             self.encode_attrs(LOCAL_CRATE.as_def_id().expect_local());\n             let vis = tcx.local_visibility(CRATE_DEF_ID).map_id(|def_id| def_id.local_def_index);\n@@ -1753,8 +1745,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = id.to_def_id();\n-                self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n-                self.tables.proc_macro.set(def_id.index, macro_kind);\n+                self.tables.opt_def_kind.set_some(def_id.index, DefKind::Macro(macro_kind));\n+                self.tables.proc_macro.set_some(def_id.index, macro_kind);\n                 self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n@@ -1979,22 +1971,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n-                self.tables.asyncness.set(def_id.index, hir::IsAsync::NotAsync);\n+                self.tables.asyncness.set_some(def_id.index, hir::IsAsync::NotAsync);\n                 record_array!(self.tables.fn_arg_names[def_id] <- *names);\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                self.tables.constness.set(def_id.index, constness);\n+                self.tables.constness.set_some(def_id.index, constness);\n                 record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             }\n             hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => {}\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n     }\n }"}, {"sha": "da82ae253e6f5002ceb0dcb08dd5fdb8d3625b57", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "patch": "@@ -316,7 +316,7 @@ pub(crate) struct IncoherentImpls {\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     (\n-        - nullable: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n+        - defaulted: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n         - optional: $($name2:ident: Table<$IDX2:ty, $T2:ty>,)+\n     ) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n@@ -343,7 +343,7 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-- nullable:\n+- defaulted:\n     is_intrinsic: Table<DefIndex, bool>,\n     is_macro_rules: Table<DefIndex, bool>,\n     is_type_alias_impl_trait: Table<DefIndex, bool>,"}, {"sha": "78cf9149f7d6fb082cbf7221087c4216efb581a2", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 80, "deletions": 33, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "patch": "@@ -10,11 +10,39 @@ use rustc_span::hygiene::MacroKind;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+pub(super) trait IsDefault: Default {\n+    fn is_default(&self) -> bool;\n+}\n+\n+impl<T> IsDefault for Option<T> {\n+    fn is_default(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+impl IsDefault for AttrFlags {\n+    fn is_default(&self) -> bool {\n+        self.is_empty()\n+    }\n+}\n+\n+impl IsDefault for bool {\n+    fn is_default(&self) -> bool {\n+        !self\n+    }\n+}\n+\n+impl IsDefault for u32 {\n+    fn is_default(&self) -> bool {\n+        *self == 0\n+    }\n+}\n+\n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n-pub(super) trait FixedSizeEncoding: Default {\n+pub(super) trait FixedSizeEncoding: IsDefault {\n     /// This should be `[u8; BYTE_LEN]`;\n     /// Cannot use an associated `const BYTE_LEN: usize` instead due to const eval limitations.\n     type ByteArray;\n@@ -23,6 +51,8 @@ pub(super) trait FixedSizeEncoding: Default {\n     fn write_to_bytes(self, b: &mut Self::ByteArray);\n }\n \n+/// This implementation is not used generically, but for reading/writing\n+/// concrete `u32` fields in `Lazy*` structures, which may be zero.\n impl FixedSizeEncoding for u32 {\n     type ByteArray = [u8; 4];\n \n@@ -58,7 +88,7 @@ macro_rules! fixed_size_enum {\n             fn write_to_bytes(self, b: &mut [u8;1]) {\n                 use $ty::*;\n                 b[0] = match self {\n-                    None => 0,\n+                    None => unreachable!(),\n                     $(Some($($pat)*) => 1 + ${index()},)*\n                 }\n             }\n@@ -160,15 +190,16 @@ impl FixedSizeEncoding for Option<DefPathHash> {\n \n     #[inline]\n     fn from_bytes(b: &[u8; 16]) -> Self {\n+        // NOTE: There's a collision between `None` and `Some(0)`.\n         Some(DefPathHash(Fingerprint::from_le_bytes(*b)))\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 16]) {\n-        let Some(DefPathHash(fingerprint)) = self else {\n-            panic!(\"Trying to encode absent DefPathHash.\")\n-        };\n-        *b = fingerprint.to_le_bytes();\n+        match self {\n+            None => unreachable!(),\n+            Some(DefPathHash(fingerprint)) => *b = fingerprint.to_le_bytes(),\n+        }\n     }\n }\n \n@@ -179,17 +210,17 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n         let krate = u32::from_le_bytes(b[0..4].try_into().unwrap());\n-        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n         if krate == 0 {\n             return None;\n         }\n+        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n         Some(RawDefId { krate: krate - 1, index })\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n         match self {\n-            None => *b = [0; 8],\n+            None => unreachable!(),\n             Some(RawDefId { krate, index }) => {\n                 // CrateNum is less than `CrateNum::MAX_AS_U32`.\n                 debug_assert!(krate < u32::MAX);\n@@ -210,6 +241,7 @@ impl FixedSizeEncoding for AttrFlags {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        debug_assert!(!self.is_default());\n         b[0] = self.bits();\n     }\n }\n@@ -224,6 +256,7 @@ impl FixedSizeEncoding for bool {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        debug_assert!(!self.is_default());\n         b[0] = self as u8\n     }\n }\n@@ -242,9 +275,14 @@ impl<T> FixedSizeEncoding for Option<LazyValue<T>> {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 4]) {\n-        let position = self.map_or(0, |lazy| lazy.position.get());\n-        let position: u32 = position.try_into().unwrap();\n-        position.write_to_bytes(b)\n+        match self {\n+            None => unreachable!(),\n+            Some(lazy) => {\n+                let position = lazy.position.get();\n+                let position: u32 = position.try_into().unwrap();\n+                position.write_to_bytes(b)\n+            }\n+        }\n     }\n }\n \n@@ -253,23 +291,28 @@ impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n \n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n-        let ([ref position_bytes, ref meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n         let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n         let len = u32::from_bytes(meta_bytes) as usize;\n         Some(LazyArray::from_position_and_num_elems(position, len))\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n-        let ([ref mut position_bytes, ref mut meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+        match self {\n+            None => unreachable!(),\n+            Some(lazy) => {\n+                let ([position_bytes, meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n \n-        let position = self.map_or(0, |lazy| lazy.position.get());\n-        let position: u32 = position.try_into().unwrap();\n-        position.write_to_bytes(position_bytes);\n+                let position = lazy.position.get();\n+                let position: u32 = position.try_into().unwrap();\n+                position.write_to_bytes(position_bytes);\n \n-        let len = self.map_or(0, |lazy| lazy.num_elems);\n-        let len: u32 = len.try_into().unwrap();\n-        len.write_to_bytes(meta_bytes);\n+                let len = lazy.num_elems;\n+                let len: u32 = len.try_into().unwrap();\n+                len.write_to_bytes(meta_bytes);\n+            }\n+        }\n     }\n }\n \n@@ -289,20 +332,27 @@ impl<I: Idx, const N: usize, T> TableBuilder<I, Option<T>>\n where\n     Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n-    pub(crate) fn set(&mut self, i: I, value: T) {\n-        self.set_nullable(i, Some(value))\n+    pub(crate) fn set_some(&mut self, i: I, value: T) {\n+        self.set(i, Some(value))\n     }\n }\n \n impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]>> TableBuilder<I, T> {\n-    pub(crate) fn set_nullable(&mut self, i: I, value: T) {\n-        // FIXME(eddyb) investigate more compact encodings for sparse tables.\n-        // On the PR @michaelwoerister mentioned:\n-        // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n-        // > trick (i.e. divide things into buckets of 32 or 64 items and then\n-        // > store bit-masks of which item in each bucket is actually serialized).\n-        self.blocks.ensure_contains_elem(i, || [0; N]);\n-        value.write_to_bytes(&mut self.blocks[i]);\n+    /// Sets the table value if it is not default.\n+    /// ATTENTION: For optimization default values are simply ignored by this function, because\n+    /// right now metadata tables never need to reset non-default values to default. If such need\n+    /// arises in the future then a new method (e.g. `clear` or `reset`) will need to be introduced\n+    /// for doing that explicitly.\n+    pub(crate) fn set(&mut self, i: I, value: T) {\n+        if !value.is_default() {\n+            // FIXME(eddyb) investigate more compact encodings for sparse tables.\n+            // On the PR @michaelwoerister mentioned:\n+            // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n+            // > trick (i.e. divide things into buckets of 32 or 64 items and then\n+            // > store bit-masks of which item in each bucket is actually serialized).\n+            self.blocks.ensure_contains_elem(i, || [0; N]);\n+            value.write_to_bytes(&mut self.blocks[i]);\n+        }\n     }\n \n     pub(crate) fn encode(&self, buf: &mut FileEncoder) -> LazyTable<I, T> {\n@@ -331,10 +381,7 @@ where\n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n-        match bytes.get(i.index()) {\n-            Some(bytes) => FixedSizeEncoding::from_bytes(bytes),\n-            None => FixedSizeEncoding::from_bytes(&[0; N]),\n-        }\n+        bytes.get(i.index()).map_or_else(Default::default, FixedSizeEncoding::from_bytes)\n     }\n \n     /// Size of the table in entries, including possible gaps."}]}